Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: Kooboo.Web(net461)
    #1 Path: D:\a\1\s\Kooboo.Web\Api\ApiContainer.cs, Line: 112, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #2 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Binding.cs, Line: 268, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #3 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Binding.cs, Line: 65, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #4 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Cluster.cs, Line: 133, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #5 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Cluster.cs, Line: 135, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #6 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Commerce\PaymentCallBack.cs, Line: 67, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\CoreSetting.cs, Line: 156, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\DataBase.cs, Line: 97, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #9 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\DataMethodSetting.cs, Line: 103, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #10 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\DataMethodSetting.cs, Line: 213, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #11 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\DataMethodSetting.cs, Line: 411, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #12 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\DataMethodSetting.cs, Line: 413, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #13 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Domain.cs, Line: 205, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #14 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Extension.cs, Line: 150, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #15 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Form.cs, Line: 234, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #16 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Form.cs, Line: 357, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #17 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Form.cs, Line: 426, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #18 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Form.cs, Line: 447, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #19 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Layout.cs, Line: 128, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #20 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Mails\EmailAttachment.cs, Line: 84, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #21 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Media.cs, Line: 237, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #22 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Media.cs, Line: 334, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #23 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Media.cs, Line: 461, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #24 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Page.cs, Line: 374, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #25 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Page.cs, Line: 464, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #26 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Page.cs, Line: 55, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #27 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Publish.cs, Line: 195, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #28 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Publish.cs, Line: 311, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #29 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\ResourceGroup.cs, Line: 228, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #30 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Role.cs, Line: 106, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #31 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Site.cs, Line: 154, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #32 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Site.cs, Line: 398, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #33 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Site.cs, Line: 511, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #34 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Site.cs, Line: 87, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #35 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\SiteLog.cs, Line: 306, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #36 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\SiteObjectApi.cs, Line: 140, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #37 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Template.cs, Line: 171, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #38 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Template.cs, Line: 186, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #39 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Template.cs, Line: 199, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #40 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Template.cs, Line: 331, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #41 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Template.cs, Line: 541, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #42 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\TextContent.cs, Line: 153, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #43 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\TextContent.cs, Line: 174, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #44 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Transfer.cs, Line: 133, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #45 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Transfer.cs, Line: 325, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #46 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\Transfer.cs, Line: 84, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #47 Path: D:\a\1\s\Kooboo.Web\Api\Implementation\VisitorLog.cs, Line: 56, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #48 Path: D:\a\1\s\Kooboo.Web\Backend\ApiPermission.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #49 Path: D:\a\1\s\Kooboo.Web\Backend\ApiPermission.cs, Line: 73, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #50 Path: D:\a\1\s\Kooboo.Web\DashBoard\DashBoardManager.cs, Line: 112, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #51 Path: D:\a\1\s\Kooboo.Web\DashBoard\MyVisitor\FrontVisitors.cs, Line: 38, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #52 Path: D:\a\1\s\Kooboo.Web\DashBoard\MyVisitor\FrontVisitors.cs, Line: 40, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #53 Path: D:\a\1\s\Kooboo.Web\JsTest\JsTestHelper.cs, Line: 178, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #54 Path: D:\a\1\s\Kooboo.Web\JsTest\JsTestHelper.cs, Line: 420, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #55 Path: D:\a\1\s\Kooboo.Web\JsTest\JsTestHelper.cs, Line: 432, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #56 Path: D:\a\1\s\Kooboo.Web\JsTest\JsTestHelper.cs, Line: 436, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #57 Path: D:\a\1\s\Kooboo.Web\JsTest\JsTestHelper.cs, Line: 440, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #58 Path: D:\a\1\s\Kooboo.Web\JsTest\JsTestOption.cs, Line: 16, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #59 Path: D:\a\1\s\Kooboo.Web\Module\ModuleApiHelper.cs, Line: 162, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #60 Path: D:\a\1\s\Kooboo.Web\Module\ModuleApiHelper.cs, Line: 169, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #61 Path: D:\a\1\s\Kooboo.Web\Module\ModuleApiHelper.cs, Line: 41, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #62 Path: D:\a\1\s\Kooboo.Web\Module\ModuleApiHelper.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #63 Path: D:\a\1\s\Kooboo.Web\Service\AdminLogService.cs, Line: 108, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: Kooboo.IndexedDB(net461)
    #64 Path: D:\a\1\s\Kooboo.IndexedDB\Btree\BtreeIndexDuplicate.cs, Line: 873, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #65 Path: D:\a\1\s\Kooboo.IndexedDB\Btree\KeyBytesCollection.cs, Line: 197, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #66 Path: D:\a\1\s\Kooboo.IndexedDB\Btree\KeyBytesCollection.cs, Line: 267, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #67 Path: D:\a\1\s\Kooboo.IndexedDB\Btree\TreeFile.cs, Line: 1467, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #68 Path: D:\a\1\s\Kooboo.IndexedDB\Btree\TreeFile.cs, Line: 1493, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #69 Path: D:\a\1\s\Kooboo.IndexedDB\Btree\TreeFile.cs, Line: 1504, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #70 Path: D:\a\1\s\Kooboo.IndexedDB\Database.cs, Line: 860, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #71 Path: D:\a\1\s\Kooboo.IndexedDB\Dynamic\Query.cs, Line: 286, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #72 Path: D:\a\1\s\Kooboo.IndexedDB\Dynamic\Query.cs, Line: 300, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #73 Path: D:\a\1\s\Kooboo.IndexedDB\Dynamic\Query.cs, Line: 360, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #74 Path: D:\a\1\s\Kooboo.IndexedDB\Dynamic\SettingHelper.cs, Line: 110, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #75 Path: D:\a\1\s\Kooboo.IndexedDB\Dynamic\SettingHelper.cs, Line: 445, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #76 Path: D:\a\1\s\Kooboo.IndexedDB\Dynamic\Sync.cs, Line: 32, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #77 Path: D:\a\1\s\Kooboo.IndexedDB\Dynamic\Table.cs, Line: 301, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #78 Path: D:\a\1\s\Kooboo.IndexedDB\Helper\SettingHelper.cs, Line: 110, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #79 Path: D:\a\1\s\Kooboo.IndexedDB\Indexs\IndexInstanceList.cs, Line: 21, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #80 Path: D:\a\1\s\Kooboo.IndexedDB\ObjectStore.cs, Line: 1018, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #81 Path: D:\a\1\s\Kooboo.IndexedDB\ObjectStore.cs, Line: 205, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #82 Path: D:\a\1\s\Kooboo.IndexedDB\Query\Filter.cs, Line: 473, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #83 Path: D:\a\1\s\Kooboo.IndexedDB\Queue\QueueContent.cs, Line: 111, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #84 Path: D:\a\1\s\Kooboo.IndexedDB\Queue\QueueList.cs, Line: 165, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #85 Path: D:\a\1\s\Kooboo.IndexedDB\Sequence\Sequence.cs, Line: 314, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #86 Path: D:\a\1\s\Kooboo.IndexedDB\Serializer\Simple\ValueConverter.cs, Line: 121, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Kooboo.Dom(net461)
    #87 Path: D:\a\1\s\Kooboo.Dom\CSS\CSSDeclarationBlock.cs, Line: 56, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #88 Path: D:\a\1\s\Kooboo.Dom\CSS\CSSDeclarationBlock.cs, Line: 81, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #89 Path: D:\a\1\s\Kooboo.Dom\CSS\CSSRuleList.cs, Line: 28, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #90 Path: D:\a\1\s\Kooboo.Dom\CSS\CSSRuleList.cs, Line: 55, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #91 Path: D:\a\1\s\Kooboo.Dom\CSS\CSSRuleList.cs, Line: 70, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #92 Path: D:\a\1\s\Kooboo.Dom\CSS\StyleSheetList.cs, Line: 27, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #93 Path: D:\a\1\s\Kooboo.Dom\CSSParser\CSSParser.cs, Line: 69, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #94 Path: D:\a\1\s\Kooboo.Dom\Dom\Document.cs, Line: 470, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #95 Path: D:\a\1\s\Kooboo.Dom\Dom\Document.cs, Line: 478, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #96 Path: D:\a\1\s\Kooboo.Dom\Dom\DOMTokenList.cs, Line: 21, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #97 Path: D:\a\1\s\Kooboo.Dom\Dom\Element.cs, Line: 407, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #98 Path: D:\a\1\s\Kooboo.Dom\Dom\HTMLCollection.cs, Line: 36, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #99 Path: D:\a\1\s\Kooboo.Dom\Dom\Node.cs, Line: 357, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #100 Path: D:\a\1\s\Kooboo.Dom\Dom\Node.cs, Line: 358, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #101 Path: D:\a\1\s\Kooboo.Dom\Dom\NodeList.cs, Line: 20, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #102 Path: D:\a\1\s\Kooboo.Dom\DomParser\ActiveFormattingElementList.cs, Line: 33, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #103 Path: D:\a\1\s\Kooboo.Dom\DomParser\HtmlToken.cs, Line: 150, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #104 Path: D:\a\1\s\Kooboo.Dom\DomParser\StackOpenElements.cs, Line: 30, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #105 Path: D:\a\1\s\Kooboo.Dom\DomParser\StackTemplateMode.cs, Line: 19, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #106 Path: D:\a\1\s\Kooboo.Dom\Helper\Loader.cs, Line: 242, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: Kooboo.Lib(net461)
    #107 Path: D:\a\1\s\Kooboo.Lib\Helper\CurrencyHelper.cs, Line: 33, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #108 Path: D:\a\1\s\Kooboo.Lib\Helper\Encoding\EmailEncoding.cs, Line: 128, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #109 Path: D:\a\1\s\Kooboo.Lib\Helper\Encoding\EmailEncoding.cs, Line: 159, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #110 Path: D:\a\1\s\Kooboo.Lib\Helper\HttpHelper.cs, Line: 117, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #111 Path: D:\a\1\s\Kooboo.Lib\Helper\HttpHelper.cs, Line: 160, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #112 Path: D:\a\1\s\Kooboo.Lib\Helper\HttpHelper.cs, Line: 211, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #113 Path: D:\a\1\s\Kooboo.Lib\Helper\HttpHelper.cs, Line: 360, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #114 Path: D:\a\1\s\Kooboo.Lib\Helper\HttpHelper.cs, Line: 93, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #115 Path: D:\a\1\s\Kooboo.Lib\Helper\IOHelper.cs, Line: 900, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #116 Path: D:\a\1\s\Kooboo.Lib\Helper\IOHelper.cs, Line: 909, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #117 Path: D:\a\1\s\Kooboo.Lib\Helper\IOHelper.cs, Line: 920, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #118 Path: D:\a\1\s\Kooboo.Lib\Helper\JintHelper.cs, Line: 194, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #119 Path: D:\a\1\s\Kooboo.Lib\Helper\JintHelper.cs, Line: 210, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #120 Path: D:\a\1\s\Kooboo.Lib\Helper\JintHelper.cs, Line: 269, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #121 Path: D:\a\1\s\Kooboo.Lib\Helper\JsonHelper.cs, Line: 549, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #122 Path: D:\a\1\s\Kooboo.Lib\Helper\NetworkHelper.cs, Line: 37, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #123 Path: D:\a\1\s\Kooboo.Lib\IOC\Service.cs, Line: 88, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #124 Path: D:\a\1\s\Kooboo.Lib\Jint\Engine.cs, Line: 320, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #125 Path: D:\a\1\s\Kooboo.Lib\Jint\Engine.cs, Line: 562, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #126 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\Array\ArrayConstructor.cs, Line: 76, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #127 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\Function\FunctionInstance.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #128 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\Function\FunctionPrototype.cs, Line: 56, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #129 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\Json\JsonParser.cs, Line: 101, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #130 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\Json\JsonParser.cs, Line: 312, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #131 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\Json\JsonParser.cs, Line: 739, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #132 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\Json\JsonParser.cs, Line: 868, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #133 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\Json\JsonSerializer.cs, Line: 131, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #134 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 182, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #135 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 319, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #136 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 331, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #137 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 355, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #138 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 389, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #139 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 398, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #140 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 422, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #141 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 431, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #142 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 440, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #143 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 449, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #144 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 458, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #145 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\JsValue.cs, Line: 467, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #146 Path: D:\a\1\s\Kooboo.Lib\Jint\Native\Object\ObjectConstructor.cs, Line: 147, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #147 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\Debugger\DebugHandler.cs, Line: 119, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #148 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\Debugger\DebugHandler.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #149 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\Debugger\DebugHandler.cs, Line: 65, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #150 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\ExpressionIntepreter.cs, Line: 849, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #151 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\ExpressionIntepreter.cs, Line: 854, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #152 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\Interop\DefaultTypeConverter.cs, Line: 179, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #153 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\Interop\DefaultTypeConverter.cs, Line: 199, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #154 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\Interop\DefaultTypeConverter.cs, Line: 199, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #155 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\Interop\DefaultTypeConverter.cs, Line: 35, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #156 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\Interop\MethodInfoFunctionInstance.cs, Line: 74, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #157 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\TypeConverter.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #158 Path: D:\a\1\s\Kooboo.Lib\Jint\Runtime\TypeConverter.cs, Line: 257, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #159 Path: D:\a\1\s\Kooboo.Lib\Less\configuration\XmlConfigurationInterpreter.cs, Line: 154, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #160 Path: D:\a\1\s\Kooboo.Lib\Less\configuration\XmlConfigurationInterpreter.cs, Line: 160, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #161 Path: D:\a\1\s\Kooboo.Lib\Less\configuration\XmlConfigurationInterpreter.cs, Line: 169, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #162 Path: D:\a\1\s\Kooboo.Lib\Less\configuration\XmlConfigurationInterpreter.cs, Line: 176, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #163 Path: D:\a\1\s\Kooboo.Lib\Less\Engine\CacheDecorator.cs, Line: 34, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #164 Path: D:\a\1\s\Kooboo.Lib\Less\Engine\CacheDecorator.cs, Line: 43, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #165 Path: D:\a\1\s\Kooboo.Lib\Less\Engine\ParameterDecorator.cs, Line: 32, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #166 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Functions\ColorFunction.cs, Line: 24, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #167 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Functions\ColorFunctionBase.cs, Line: 13, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #168 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Functions\DataUriFunction.cs, Line: 19, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #169 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Functions\DataUriFunction.cs, Line: 35, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #170 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Functions\DataUriFunction.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #171 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Functions\FormatStringFunction.cs, Line: 33, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #172 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Functions\Function.cs, Line: 29, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #173 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Functions\HexFunction.cs, Line: 15, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #174 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Functions\ListFunctionBase.cs, Line: 33, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #175 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Infrastructure\Env.cs, Line: 126, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #176 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Infrastructure\Env.cs, Line: 133, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #177 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Infrastructure\Env.cs, Line: 239, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #178 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Infrastructure\Env.cs, Line: 245, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #179 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Infrastructure\Env.cs, Line: 363, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #180 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Parsers.cs, Line: 1035, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #181 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tokenizer.cs, Line: 101, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #182 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Color.cs, Line: 344, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #183 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Condition.cs, Line: 54, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #184 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Condition.cs, Line: 61, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #185 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\CssFunction.cs, Line: 14, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #186 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Media.cs, Line: 108, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #187 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\MixinCall.cs, Line: 103, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #188 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\MixinDefinition.cs, Line: 146, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #189 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\MixinDefinition.cs, Line: 94, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #190 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Operation.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #191 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Operation.cs, Line: 44, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #192 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Root.cs, Line: 54, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #193 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Ruleset.cs, Line: 258, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #194 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Url.cs, Line: 40, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #195 Path: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Url.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #196 Path: D:\a\1\s\Kooboo.Lib\Less\Plugins\GenericPluginConfigurator.cs, Line: 43, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #197 Path: D:\a\1\s\Kooboo.Lib\Less\Plugins\PluginFinder.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #198 Path: D:\a\1\s\Kooboo.Lib\Less\Plugins\PluginFinder.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #199 Path: D:\a\1\s\Kooboo.Lib\Less\Plugins\RtlPlugin.cs, Line: 132, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #200 Path: D:\a\1\s\Kooboo.Lib\Less\Plugins\RtlPlugin.cs, Line: 270, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #201 Path: D:\a\1\s\Kooboo.Lib\Less\Plugins\RtlPlugin.cs, Line: 279, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #202 Path: D:\a\1\s\Kooboo.Lib\Less\Plugins\RtlPlugin.cs, Line: 287, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #203 Path: D:\a\1\s\Kooboo.Lib\Less\Stylizers\HtmlStylizer.cs, Line: 9, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #204 Path: D:\a\1\s\Kooboo.Lib\Less\Stylizers\PlainStylizer.cs, Line: 9, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #205 Path: D:\a\1\s\Kooboo.Lib\Less\Utils\Guard.cs, Line: 18, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #206 Path: D:\a\1\s\Kooboo.Lib\Less\Utils\Guard.cs, Line: 38, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #207 Path: D:\a\1\s\Kooboo.Lib\Less\Utils\Guard.cs, Line: 51, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #208 Path: D:\a\1\s\Kooboo.Lib\Less\Utils\Guard.cs, Line: 70, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #209 Path: D:\a\1\s\Kooboo.Lib\Less\Utils\Guard.cs, Line: 80, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #210 Path: D:\a\1\s\Kooboo.Lib\Less\Utils\Guard.cs, Line: 90, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #211 Path: D:\a\1\s\Kooboo.Lib\Less\Utils\NodeHelper.cs, Line: 20, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #212 Path: D:\a\1\s\Kooboo.Lib\Multipart\AttributeReader.cs, Line: 23, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #213 Path: D:\a\1\s\Kooboo.Lib\NUglify\Css\CssParser.cs, Line: 3766, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #214 Path: D:\a\1\s\Kooboo.Lib\NUglify\Css\CssParser.cs, Line: 3781, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #215 Path: D:\a\1\s\Kooboo.Lib\NUglify\Css\CssParser.cs, Line: 3795, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #216 Path: D:\a\1\s\Kooboo.Lib\NUglify\Css\CssParser.cs, Line: 3814, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #217 Path: D:\a\1\s\Kooboo.Lib\NUglify\Css\CssParser.cs, Line: 3903, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #218 Path: D:\a\1\s\Kooboo.Lib\NUglify\Helpers\ReflectionHelper.cs, Line: 65, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #219 Path: D:\a\1\s\Kooboo.Lib\NUglify\Html\HtmlMinifier.cs, Line: 174, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #220 Path: D:\a\1\s\Kooboo.Lib\NUglify\Html\HtmlNode.cs, Line: 67, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #221 Path: D:\a\1\s\Kooboo.Lib\NUglify\Html\HtmlTagDescriptor.cs, Line: 367, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #222 Path: D:\a\1\s\Kooboo.Lib\NUglify\Html\HtmlWriterBase.cs, Line: 12, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #223 Path: D:\a\1\s\Kooboo.Lib\NUglify\Html\HtmlWriterBase.cs, Line: 20, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #224 Path: D:\a\1\s\Kooboo.Lib\NUglify\Html\HtmlWriterBase.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #225 Path: D:\a\1\s\Kooboo.Lib\NUglify\Html\HtmlWriterBase.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #226 Path: D:\a\1\s\Kooboo.Lib\NUglify\Html\HtmlWriterBase.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #227 Path: D:\a\1\s\Kooboo.Lib\NUglify\Html\HtmlWriterBase.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #228 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\documentcontext.cs, Line: 63, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #229 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\documentcontext.cs, Line: 71, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #230 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\ScriptSharpSourceMap.cs, Line: 169, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #231 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ArrayLiteral.cs, Line: 109, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #232 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ArrayLiteral.cs, Line: 91, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #233 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\AspNetBlockNode.cs, Line: 34, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #234 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\AstNode.cs, Line: 233, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #235 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\AstNode.cs, Line: 243, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #236 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\AstNodeList.cs, Line: 131, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #237 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\AstNodeList.cs, Line: 152, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #238 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\AstNodeList.cs, Line: 174, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #239 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\AstNodeList.cs, Line: 231, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #240 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\AstNodeList.cs, Line: 47, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #241 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\AstNodeList.cs, Line: 83, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #242 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BinaryExpression.cs, Line: 289, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #243 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BindingIdentifier.cs, Line: 101, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #244 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BindingIdentifier.cs, Line: 87, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #245 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BindingIdentifier.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #246 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BindingTransform.cs, Line: 190, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #247 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BindingTransform.cs, Line: 326, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #248 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BindingTransform.cs, Line: 344, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #249 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BindingTransform.cs, Line: 353, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #250 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BindingTransform.cs, Line: 383, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #251 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BindingTransform.cs, Line: 395, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #252 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BindingTransform.cs, Line: 45, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #253 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BindingTransform.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #254 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BlockStatement.cs, Line: 129, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #255 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BlockStatement.cs, Line: 186, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #256 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BlockStatement.cs, Line: 266, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #257 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BlockStatement.cs, Line: 298, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #258 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\BreakStatement.cs, Line: 36, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #259 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\CallExpression.cs, Line: 101, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #260 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\CallExpression.cs, Line: 131, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #261 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\CallExpression.cs, Line: 155, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #262 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ClassNode.cs, Line: 102, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #263 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\CommaExpression.cs, Line: 35, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #264 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\CommaExpression.cs, Line: 43, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #265 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\CommaExpression.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #266 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\CommaExpression.cs, Line: 78, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #267 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ComprehensionForClause.cs, Line: 56, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #268 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ComprehensionIfClause.cs, Line: 42, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #269 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ComprehensionNode.cs, Line: 69, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #270 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ComputedPropertyField.cs, Line: 32, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #271 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\Conditional.cs, Line: 115, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #272 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\Conditional.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #273 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ConditionalCompilationComment.cs, Line: 43, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #274 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ConditionalCompilationElse.cs, Line: 30, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #275 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ConditionalCompilationElseIf.cs, Line: 50, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #276 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ConditionalCompilationEnd.cs, Line: 30, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #277 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ConditionalCompilationIf.cs, Line: 50, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #278 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ConditionalCompilationOn.cs, Line: 30, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #279 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ConditionalCompilationSet.cs, Line: 52, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #280 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ConstantWrapper.cs, Line: 199, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #281 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ConstantWrapper.cs, Line: 237, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #282 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ConstantWrapperPP.cs, Line: 34, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #283 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ConstStatement.cs, Line: 37, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #284 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ContinueStatement.cs, Line: 36, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #285 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\CustomNode.cs, Line: 35, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #286 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\DebuggerNode.cs, Line: 31, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #287 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\DirectivePrologue.cs, Line: 55, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #288 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\DoWhileStatement.cs, Line: 45, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #289 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\EmptyStatement.cs, Line: 30, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #290 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ExportStatement.cs, Line: 35, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #291 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ForInStatement.cs, Line: 66, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #292 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ForStatement.cs, Line: 81, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #293 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\FunctionObject.cs, Line: 116, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #294 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\FunctionObject.cs, Line: 164, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #295 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\FunctionScope.cs, Line: 143, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #296 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\GetterSetter.cs, Line: 34, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #297 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\GroupingOperator.cs, Line: 46, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #298 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\GroupingOperator.cs, Line: 89, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #299 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\IfStatement.cs, Line: 91, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #300 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ImportantComment.cs, Line: 44, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #301 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ImportExportSpecifier.cs, Line: 90, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #302 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ImportExportStatement.cs, Line: 121, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #303 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ImportExportStatement.cs, Line: 99, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #304 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ImportStatement.cs, Line: 31, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #305 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\InitializerNode.cs, Line: 68, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #306 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\LabeledStatement.cs, Line: 58, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #307 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\LexicalDeclaration.cs, Line: 31, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #308 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\LookupExpression.cs, Line: 130, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #309 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\MemberExpression.cs, Line: 54, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #310 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\MemberExpression.cs, Line: 60, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #311 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ModuleDeclaration.cs, Line: 82, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #312 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ObjectLiteral.cs, Line: 64, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #313 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ObjectLiteralField.cs, Line: 35, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #314 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ObjectLiteralProperty.cs, Line: 63, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #315 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ParameterDeclaration.cs, Line: 100, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #316 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\RegExpLiteral.cs, Line: 41, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #317 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\RegExpLiteral.cs, Line: 47, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #318 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ReturnStatement.cs, Line: 41, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #319 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\SwitchCase.cs, Line: 59, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #320 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\SwitchStatement.cs, Line: 57, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #321 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\TemplateLiteral.cs, Line: 57, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #322 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\TemplateLiteralExpression.cs, Line: 46, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #323 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ThisLiteral.cs, Line: 31, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #324 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ThisLiteral.cs, Line: 41, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #325 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ThrowStatement.cs, Line: 42, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #326 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\TryStatement.cs, Line: 77, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #327 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\UnaryExpression.cs, Line: 111, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #328 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\UnaryExpression.cs, Line: 53, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #329 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\VarDeclaration.cs, Line: 34, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #330 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\VariableDeclaration.cs, Line: 33, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #331 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\WhileStatement.cs, Line: 52, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #332 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\WithStatement.cs, Line: 62, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #333 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\V3SourceMap.cs, Line: 209, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #334 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs, Line: 1927, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #335 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs, Line: 1948, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #336 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs, Line: 2802, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #337 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs, Line: 2806, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #338 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs, Line: 3510, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #339 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs, Line: 3963, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #340 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs, Line: 4539, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #341 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs, Line: 712, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #342 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\BindingsVisitor.cs, Line: 104, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #343 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\BindingsVisitor.cs, Line: 145, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #344 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\BindingsVisitor.cs, Line: 155, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #345 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\BindingsVisitor.cs, Line: 196, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #346 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\BindingsVisitor.cs, Line: 220, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #347 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\BindingsVisitor.cs, Line: 43, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #348 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\BindingsVisitor.cs, Line: 60, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #349 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\BindingsVisitor.cs, Line: 87, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #350 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\DetachReferencesVisitor.cs, Line: 32, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #351 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\FinalPassVisitor.cs, Line: 74, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #352 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\JsonOutputVisitor.cs, Line: 119, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #353 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\JsonOutputVisitor.cs, Line: 544, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #354 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\LogicalNotVisitor.cs, Line: 519, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #355 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\MatchPropertiesVisitor.cs, Line: 130, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #356 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\MatchPropertiesVisitor.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #357 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\OutputVisitor.cs, Line: 1904, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #358 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\OutputVisitor.cs, Line: 2396, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #359 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\OutputVisitor.cs, Line: 2474, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #360 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\OutputVisitor.cs, Line: 3911, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #361 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\OutputVisitor.cs, Line: 443, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #362 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\OutputVisitor.cs, Line: 725, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #363 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\OutputVisitor.cs, Line: 797, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #364 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\RequiresSeparatorVisitor.cs, Line: 42, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #365 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 1065, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #366 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 1113, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #367 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 1381, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #368 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 1654, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #369 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 1716, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #370 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 243, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #371 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 252, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #372 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 276, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #373 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 290, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #374 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 329, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #375 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 514, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #376 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 580, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #377 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 650, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #378 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ResolutionVisitor.cs, Line: 911, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #379 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\StatementStartVisitor.cs, Line: 48, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #380 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\StatementStartVisitor.cs, Line: 61, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #381 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\StatementStartVisitor.cs, Line: 70, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #382 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\StatementStartVisitor.cs, Line: 79, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #383 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\StatementStartVisitor.cs, Line: 88, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #384 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\TreeVisitor.cs, Line: 277, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #385 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\TreeVisitor.cs, Line: 296, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #386 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\TreeVisitor.cs, Line: 501, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #387 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\TreeVisitor.cs, Line: 53, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #388 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\TreeVisitor.cs, Line: 721, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #389 Path: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\TreeVisitor.cs, Line: 88, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #390 Path: D:\a\1\s\Kooboo.Lib\Reflection\CollectionWrapper.cs, Line: 43, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #391 Path: D:\a\1\s\Kooboo.Lib\Reflection\ExtensionAssemblyLoader.cs, Line: 132, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #392 Path: D:\a\1\s\Kooboo.Lib\Reflection\ExtensionAssemblyLoader.cs, Line: 170, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #393 Path: D:\a\1\s\Kooboo.Lib\Reflection\TypeHelper.cs, Line: 152, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #394 Path: D:\a\1\s\Kooboo.Lib\Reflection\TypeHelper.cs, Line: 231, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Kooboo.Sites(net461)
    #395 Path: D:\a\1\s\Kooboo.Sites\Constraints\ConstraintChecker.cs, Line: 158, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #396 Path: D:\a\1\s\Kooboo.Sites\Constraints\ConstraintChecker.cs, Line: 158, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #397 Path: D:\a\1\s\Kooboo.Sites\Constraints\ConstraintChecker.cs, Line: 194, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #398 Path: D:\a\1\s\Kooboo.Sites\Constraints\ConstraintChecker.cs, Line: 194, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #399 Path: D:\a\1\s\Kooboo.Sites\Contents\Models\TextContent.cs, Line: 132, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #400 Path: D:\a\1\s\Kooboo.Sites\Contents\Models\TextContent.cs, Line: 238, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #401 Path: D:\a\1\s\Kooboo.Sites\Contents\Models\TextContent.cs, Line: 243, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #402 Path: D:\a\1\s\Kooboo.Sites\Contents\Models\TextContent.cs, Line: 267, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #403 Path: D:\a\1\s\Kooboo.Sites\Converter\Implementation\ContentListConverter.cs, Line: 107, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #404 Path: D:\a\1\s\Kooboo.Sites\Converter\Implementation\MenuConverter.cs, Line: 184, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #405 Path: D:\a\1\s\Kooboo.Sites\Converter\Implementation\MenuConverter.cs, Line: 269, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #406 Path: D:\a\1\s\Kooboo.Sites\Converter\Implementation\MenuConverter.cs, Line: 72, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #407 Path: D:\a\1\s\Kooboo.Sites\DataSources\ContentList.cs, Line: 59, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #408 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataMethodExecutor.cs, Line: 157, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #409 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataMethodExecutor.cs, Line: 179, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #410 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataMethodExecutor.cs, Line: 238, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #411 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataMethodExecutor.cs, Line: 433, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #412 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataMethodExecutor.cs, Line: 462, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #413 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataMethodExecutor.cs, Line: 490, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #414 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataMethodExecutor.cs, Line: 505, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #415 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataMethodExecutor.cs, Line: 570, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #416 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataSourceHelper.cs, Line: 608, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #417 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataSourceHelper.cs, Line: 640, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #418 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataSourceHelper.cs, Line: 674, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #419 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataSourceHelper.cs, Line: 713, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #420 Path: D:\a\1\s\Kooboo.Sites\DataSources\DataSourceHelper.cs, Line: 842, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #421 Path: D:\a\1\s\Kooboo.Sites\DataSources\FilterHelper.cs, Line: 156, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #422 Path: D:\a\1\s\Kooboo.Sites\DataSources\FilterHelper.cs, Line: 164, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #423 Path: D:\a\1\s\Kooboo.Sites\DataSources\FilterHelper.cs, Line: 171, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #424 Path: D:\a\1\s\Kooboo.Sites\DataSources\FilterHelper.cs, Line: 178, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #425 Path: D:\a\1\s\Kooboo.Sites\DataTraceAndModify\Modifiers\DomModifier.cs, Line: 227, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #426 Path: D:\a\1\s\Kooboo.Sites\Diagnosis\Advanced\DomParser.cs, Line: 51, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #427 Path: D:\a\1\s\Kooboo.Sites\Diagnosis\DiagnosisHelper.cs, Line: 87, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #428 Path: D:\a\1\s\Kooboo.Sites\Diagnosis\Implementation\HtmlTag.cs, Line: 126, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #429 Path: D:\a\1\s\Kooboo.Sites\Diagnosis\Implementation\HtmlTag.cs, Line: 59, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #430 Path: D:\a\1\s\Kooboo.Sites\Diagnosis\Implementation\ImageSize.cs, Line: 44, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #431 Path: D:\a\1\s\Kooboo.Sites\Ecommerce\Models\Product.cs, Line: 142, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #432 Path: D:\a\1\s\Kooboo.Sites\Ecommerce\Models\Product.cs, Line: 147, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #433 Path: D:\a\1\s\Kooboo.Sites\Ecommerce\Models\Product.cs, Line: 171, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #434 Path: D:\a\1\s\Kooboo.Sites\Ecommerce\Models\Product.cs, Line: 53, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #435 Path: D:\a\1\s\Kooboo.Sites\Events\Cms\Handler.cs, Line: 294, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #436 Path: D:\a\1\s\Kooboo.Sites\Events\Cms\Handler.cs, Line: 310, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #437 Path: D:\a\1\s\Kooboo.Sites\Events\Cms\Handler.cs, Line: 74, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #438 Path: D:\a\1\s\Kooboo.Sites\FrontEvent\EventConditionSetting.cs, Line: 17, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #439 Path: D:\a\1\s\Kooboo.Sites\FrontEvent\Manager.cs, Line: 116, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #440 Path: D:\a\1\s\Kooboo.Sites\FrontEvent\Manager.cs, Line: 145, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #441 Path: D:\a\1\s\Kooboo.Sites\FrontEvent\Manager.cs, Line: 165, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #442 Path: D:\a\1\s\Kooboo.Sites\FrontEvent\Manager.cs, Line: 171, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #443 Path: D:\a\1\s\Kooboo.Sites\FrontEvent\Manager.cs, Line: 181, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #444 Path: D:\a\1\s\Kooboo.Sites\Helper\ChangeHelper.cs, Line: 175, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #445 Path: D:\a\1\s\Kooboo.Sites\Helper\ChangeHelper.cs, Line: 44, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #446 Path: D:\a\1\s\Kooboo.Sites\Helper\ContentHelper.cs, Line: 134, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #447 Path: D:\a\1\s\Kooboo.Sites\Helper\ContentHelper.cs, Line: 169, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #448 Path: D:\a\1\s\Kooboo.Sites\Helper\ContentHelper.cs, Line: 320, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #449 Path: D:\a\1\s\Kooboo.Sites\Helper\ContentHelper.cs, Line: 73, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #450 Path: D:\a\1\s\Kooboo.Sites\Helper\ContentHelper.cs, Line: 78, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #451 Path: D:\a\1\s\Kooboo.Sites\Helper\ElementHelper.cs, Line: 151, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #452 Path: D:\a\1\s\Kooboo.Sites\Helper\ElementHelper.cs, Line: 161, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #453 Path: D:\a\1\s\Kooboo.Sites\Helper\ElementHelper.cs, Line: 228, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #454 Path: D:\a\1\s\Kooboo.Sites\Helper\ElementHelper.cs, Line: 236, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #455 Path: D:\a\1\s\Kooboo.Sites\Helper\MenuHelper.cs, Line: 278, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #456 Path: D:\a\1\s\Kooboo.Sites\Helper\PackageHelper.cs, Line: 49, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #457 Path: D:\a\1\s\Kooboo.Sites\HtmlForm\ValueSubmitter.cs, Line: 61, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #458 Path: D:\a\1\s\Kooboo.Sites\Models\ViewDataMethod.cs, Line: 64, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #459 Path: D:\a\1\s\Kooboo.Sites\Models\ViewDataMethod.cs, Line: 72, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #460 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\Alipay\lib\AopDictionary.cs, Line: 30, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #461 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\Braintree\lib\BraintreeAPI.cs, Line: 30, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #462 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\Braintree\lib\BraintreeAPI.cs, Line: 53, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #463 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\Braintree\lib\BraintreeAPI.cs, Line: 83, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #464 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\Ogone\lib\OgoneApi.cs, Line: 30, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #465 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\Ogone\lib\OgoneApi.cs, Line: 62, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #466 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\Ogone\lib\OgoneApi.cs, Line: 78, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #467 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\Ogone\lib\OgoneApi.cs, Line: 89, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #468 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\Ogone\OgoneForm.cs, Line: 99, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #469 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\Stripe\StripeForm.cs, Line: 72, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #470 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\wechat\lib\Data.cs, Line: 208, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #471 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\wechat\lib\HttpService.cs, Line: 114, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #472 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\wechat\lib\HttpService.cs, Line: 118, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #473 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\wechat\lib\HttpService.cs, Line: 18, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #474 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\wechat\lib\HttpService.cs, Line: 190, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #475 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\wechat\lib\HttpService.cs, Line: 194, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #476 Path: D:\a\1\s\Kooboo.Sites\Payment\Methods\wechat\lib\WxPayApi.cs, Line: 601, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #477 Path: D:\a\1\s\Kooboo.Sites\Payment\PaymentHelper.cs, Line: 35, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #478 Path: D:\a\1\s\Kooboo.Sites\Relation\CmsCssRuleRelation.cs, Line: 38, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #479 Path: D:\a\1\s\Kooboo.Sites\Relation\DomRelation.cs, Line: 471, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #480 Path: D:\a\1\s\Kooboo.Sites\Relation\DomRelation.cs, Line: 491, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #481 Path: D:\a\1\s\Kooboo.Sites\Relation\DomRelation.cs, Line: 583, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #482 Path: D:\a\1\s\Kooboo.Sites\Relation\RelationManager.cs, Line: 113, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #483 Path: D:\a\1\s\Kooboo.Sites\Relation\RelationManager.cs, Line: 195, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #484 Path: D:\a\1\s\Kooboo.Sites\Relation\RelationManager.cs, Line: 195, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #485 Path: D:\a\1\s\Kooboo.Sites\Relation\RelationManager.cs, Line: 86, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #486 Path: D:\a\1\s\Kooboo.Sites\Relation\StyleRelation.cs, Line: 56, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #487 Path: D:\a\1\s\Kooboo.Sites\Render\Commands\IncludeCommand.cs, Line: 27, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #488 Path: D:\a\1\s\Kooboo.Sites\Render\Commands\IncludeCommand.cs, Line: 37, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #489 Path: D:\a\1\s\Kooboo.Sites\Render\Commands\LayoutCommand.cs, Line: 26, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #490 Path: D:\a\1\s\Kooboo.Sites\Render\Commands\LayoutCommand.cs, Line: 36, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #491 Path: D:\a\1\s\Kooboo.Sites\Render\Components\Manager.cs, Line: 77, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #492 Path: D:\a\1\s\Kooboo.Sites\Render\Components\Manager.cs, Line: 85, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #493 Path: D:\a\1\s\Kooboo.Sites\Render\Components\ViewComponent.cs, Line: 122, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #494 Path: D:\a\1\s\Kooboo.Sites\Render\Components\ViewComponent.cs, Line: 209, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #495 Path: D:\a\1\s\Kooboo.Sites\Render\Components\ViewComponent.cs, Line: 274, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #496 Path: D:\a\1\s\Kooboo.Sites\Render\Components\ViewComponent.cs, Line: 294, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #497 Path: D:\a\1\s\Kooboo.Sites\Render\Evaluators\Attribute.cs, Line: 135, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #498 Path: D:\a\1\s\Kooboo.Sites\Render\Evaluators\LocalCacheEvaluator.cs, Line: 71, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #499 Path: D:\a\1\s\Kooboo.Sites\Render\Evaluators\Version.cs, Line: 125, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #500 Path: D:\a\1\s\Kooboo.Sites\Render\Functions\AppendUrlFunction.cs, Line: 53, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #501 Path: D:\a\1\s\Kooboo.Sites\Render\Functions\CountFunction.cs, Line: 31, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #502 Path: D:\a\1\s\Kooboo.Sites\Render\Functions\CountFunction.cs, Line: 36, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #503 Path: D:\a\1\s\Kooboo.Sites\Render\Functions\CountFunction.cs, Line: 50, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #504 Path: D:\a\1\s\Kooboo.Sites\Render\Functions\CountFunction.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #505 Path: D:\a\1\s\Kooboo.Sites\Render\Functions\PagerFunction.cs, Line: 47, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #506 Path: D:\a\1\s\Kooboo.Sites\Render\Functions\PagerFunction.cs, Line: 52, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #507 Path: D:\a\1\s\Kooboo.Sites\Render\Functions\SetUrlFunction.cs, Line: 47, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #508 Path: D:\a\1\s\Kooboo.Sites\Render\Functions\ValueFunction.cs, Line: 60, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #509 Path: D:\a\1\s\Kooboo.Sites\Render\Renderers\ImageRenderer.cs, Line: 210, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #510 Path: D:\a\1\s\Kooboo.Sites\Render\Renderers\ScriptRenderer.cs, Line: 40, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #511 Path: D:\a\1\s\Kooboo.Sites\Render\Renderers\StyleRenderer.cs, Line: 14, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #512 Path: D:\a\1\s\Kooboo.Sites\Render\RenderEvaluator.cs, Line: 125, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #513 Path: D:\a\1\s\Kooboo.Sites\Render\RenderEvaluator.cs, Line: 239, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #514 Path: D:\a\1\s\Kooboo.Sites\Render\RenderEvaluator.cs, Line: 52, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #515 Path: D:\a\1\s\Kooboo.Sites\Render\RenderHelper.cs, Line: 65, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #516 Path: D:\a\1\s\Kooboo.Sites\Render\RenderTask\ForRenderTask.cs, Line: 107, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #517 Path: D:\a\1\s\Kooboo.Sites\Render\RenderTask\ForRenderTask.cs, Line: 107, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #518 Path: D:\a\1\s\Kooboo.Sites\Render\RenderTask\HeaderRenderTask.cs, Line: 206, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #519 Path: D:\a\1\s\Kooboo.Sites\Render\RenderTask\RepeaterRenderTask.cs, Line: 103, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #520 Path: D:\a\1\s\Kooboo.Sites\Render\RenderTask\RepeaterRenderTask.cs, Line: 103, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #521 Path: D:\a\1\s\Kooboo.Sites\Render\RenderTask\RepeaterRenderTask.cs, Line: 141, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #522 Path: D:\a\1\s\Kooboo.Sites\Render\RenderTask\RepeaterRenderTask.cs, Line: 276, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #523 Path: D:\a\1\s\Kooboo.Sites\Render\RenderTask\RepeaterRenderTask.cs, Line: 287, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #524 Path: D:\a\1\s\Kooboo.Sites\Render\RenderTask\VersionRenderTask.cs, Line: 114, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #525 Path: D:\a\1\s\Kooboo.Sites\Render\RenderTask\VersionRenderTask.cs, Line: 124, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #526 Path: D:\a\1\s\Kooboo.Sites\Render\RenderTask\VersionRenderTask.cs, Line: 168, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #527 Path: D:\a\1\s\Kooboo.Sites\Repository\CmsCssRuleRepository.cs, Line: 168, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #528 Path: D:\a\1\s\Kooboo.Sites\Repository\CmsCssRuleRepository.cs, Line: 201, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #529 Path: D:\a\1\s\Kooboo.Sites\Repository\CmsCssRuleRepository.cs, Line: 247, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #530 Path: D:\a\1\s\Kooboo.Sites\Repository\CmsCssRuleRepository.cs, Line: 469, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #531 Path: D:\a\1\s\Kooboo.Sites\Repository\CmsCssRuleRepository.cs, Line: 494, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #532 Path: D:\a\1\s\Kooboo.Sites\Repository\ContentFolderRepository.cs, Line: 96, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #533 Path: D:\a\1\s\Kooboo.Sites\Repository\CoreSettingRepository.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #534 Path: D:\a\1\s\Kooboo.Sites\Repository\DatabaseTableRepository.cs, Line: 144, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #535 Path: D:\a\1\s\Kooboo.Sites\Repository\DomElementRepository.cs, Line: 147, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #536 Path: D:\a\1\s\Kooboo.Sites\Repository\DomElementRepository.cs, Line: 87, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #537 Path: D:\a\1\s\Kooboo.Sites\Repository\FolderRepository.cs, Line: 220, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #538 Path: D:\a\1\s\Kooboo.Sites\Repository\IEmbeddableRepositoryBase.cs, Line: 153, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #539 Path: D:\a\1\s\Kooboo.Sites\Repository\IEmbeddableRepositoryBase.cs, Line: 194, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #540 Path: D:\a\1\s\Kooboo.Sites\Repository\IEmbeddableRepositoryBase.cs, Line: 282, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #541 Path: D:\a\1\s\Kooboo.Sites\Repository\IEmbeddableRepositoryBase.cs, Line: 419, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #542 Path: D:\a\1\s\Kooboo.Sites\Repository\MenuRepository.cs, Line: 127, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #543 Path: D:\a\1\s\Kooboo.Sites\Repository\PageRepository.cs, Line: 103, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #544 Path: D:\a\1\s\Kooboo.Sites\Repository\PageRepository.cs, Line: 74, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #545 Path: D:\a\1\s\Kooboo.Sites\Repository\RouteRepository.cs, Line: 187, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #546 Path: D:\a\1\s\Kooboo.Sites\Repository\SearchIndexRepository.cs, Line: 1220, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #547 Path: D:\a\1\s\Kooboo.Sites\Repository\SearchIndexRepository.cs, Line: 1265, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #548 Path: D:\a\1\s\Kooboo.Sites\Repository\SearchIndexRepository.cs, Line: 1298, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #549 Path: D:\a\1\s\Kooboo.Sites\Repository\SearchIndexRepository.cs, Line: 321, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #550 Path: D:\a\1\s\Kooboo.Sites\Repository\SearchIndexRepository.cs, Line: 452, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #551 Path: D:\a\1\s\Kooboo.Sites\Repository\SearchIndexRepository.cs, Line: 493, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #552 Path: D:\a\1\s\Kooboo.Sites\Repository\SearchIndexRepository.cs, Line: 522, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #553 Path: D:\a\1\s\Kooboo.Sites\Repository\SearchIndexRepository.cs, Line: 585, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #554 Path: D:\a\1\s\Kooboo.Sites\Repository\SearchIndexRepository.cs, Line: 744, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #555 Path: D:\a\1\s\Kooboo.Sites\Repository\SearchIndexRepository.cs, Line: 930, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #556 Path: D:\a\1\s\Kooboo.Sites\Repository\SiteDb.cs, Line: 1019, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #557 Path: D:\a\1\s\Kooboo.Sites\Repository\SiteRepositoryBase.cs, Line: 665, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #558 Path: D:\a\1\s\Kooboo.Sites\Repository\StyleRepository.cs, Line: 132, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #559 Path: D:\a\1\s\Kooboo.Sites\Repository\StyleRepository.cs, Line: 81, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #560 Path: D:\a\1\s\Kooboo.Sites\Repository\TextContentRepository.cs, Line: 85, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #561 Path: D:\a\1\s\Kooboo.Sites\Repository\TextContentRepository.cs, Line: 94, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #562 Path: D:\a\1\s\Kooboo.Sites\Repository\TransferTaskRepository.cs, Line: 135, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #563 Path: D:\a\1\s\Kooboo.Sites\Repository\TransferTaskRepository.cs, Line: 59, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #564 Path: D:\a\1\s\Kooboo.Sites\Routing\ObjectRoute.cs, Line: 240, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #565 Path: D:\a\1\s\Kooboo.Sites\Routing\ObjectRoute.cs, Line: 244, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #566 Path: D:\a\1\s\Kooboo.Sites\Routing\ObjectRoute.cs, Line: 270, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #567 Path: D:\a\1\s\Kooboo.Sites\Routing\ObjectRoute.cs, Line: 291, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #568 Path: D:\a\1\s\Kooboo.Sites\Routing\PageRoute.cs, Line: 149, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #569 Path: D:\a\1\s\Kooboo.Sites\Routing\PageRoute.cs, Line: 260, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #570 Path: D:\a\1\s\Kooboo.Sites\Routing\PageRoute.cs, Line: 46, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #571 Path: D:\a\1\s\Kooboo.Sites\Scripting\Extension\WebService.cs, Line: 44, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #572 Path: D:\a\1\s\Kooboo.Sites\Scripting\Extension\WebService.cs, Line: 94, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #573 Path: D:\a\1\s\Kooboo.Sites\Scripting\ExtensionContainer.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #574 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\Curl.cs, Line: 465, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #575 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\Database\DynamicTableObjectBase.cs, Line: 36, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #576 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\kHelper.cs, Line: 49, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #577 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\kHelper.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #578 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\KTemplate.cs, Line: 153, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #579 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\KTemplate.cs, Line: 224, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #580 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\KTemplate.cs, Line: 282, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #581 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\KTemplate.cs, Line: 425, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #582 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\KTemplate.cs, Line: 444, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #583 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\KTemplate.cs, Line: 452, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #584 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\KTemplate.cs, Line: 611, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #585 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\KTemplate.cs, Line: 626, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #586 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\KTemplate.cs, Line: 639, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #587 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\KTemplate.cs, Line: 675, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #588 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\KTemplate.cs, Line: 74, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #589 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\Mail.cs, Line: 106, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #590 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\Mail.cs, Line: 202, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #591 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\Mail.cs, Line: 318, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #592 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\Mail.cs, Line: 332, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #593 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\Mail.cs, Line: 62, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #594 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\Mail.cs, Line: 70, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #595 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\Mail.cs, Line: 92, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #596 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\RelationalDatabase\RelationalDynamicTableObject.cs, Line: 67, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #597 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\RelationalDatabase\RelationalSchema.cs, Line: 27, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #598 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\RelationalDatabase\RelationalTable.cs, Line: 32, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #599 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\SiteItem\MultilingualRepository.cs, Line: 109, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #600 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\SiteItem\MultilingualRepository.cs, Line: 134, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #601 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\SiteItem\MultilingualRepository.cs, Line: 203, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #602 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\SiteItem\MultilingualRepository.cs, Line: 217, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #603 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\SiteItem\MultilingualRepository.cs, Line: 35, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #604 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\SiteItem\MultilingualRepository.cs, Line: 47, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #605 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\SiteItem\RepositoryBase.cs, Line: 42, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #606 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\SiteItem\RoutableTextRepository.cs, Line: 55, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #607 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\SiteItem\RoutableTextRepository.cs, Line: 91, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #608 Path: D:\a\1\s\Kooboo.Sites\Scripting\Global\SiteItem\TextContentRepository.cs, Line: 480, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #609 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\DocumentHelper.cs, Line: 28, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #610 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\DocumentHelper.cs, Line: 33, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #611 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\ScriptHelper\ScriptHelperRender.cs, Line: 115, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #612 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\ScriptHelper\ScriptHelperRender.cs, Line: 116, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #613 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\ScriptHelper\ScriptHelperRender.cs, Line: 120, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #614 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\ScriptHelper\ScriptHelperRender.cs, Line: 144, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #615 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\ScriptHelper\ScriptHelperRender.cs, Line: 151, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #616 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\ScriptHelper\ScriptHelperRender.cs, Line: 154, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #617 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\ScriptHelper\ScriptHelperRender.cs, Line: 175, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #618 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\ScriptHelper\ScriptHelperRender.cs, Line: 178, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #619 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\ScriptHelper\ScriptHelperRender.cs, Line: 70, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #620 Path: D:\a\1\s\Kooboo.Sites\Scripting\Helper\ViewHelp\ViewHelpRender.cs, Line: 55, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #621 Path: D:\a\1\s\Kooboo.Sites\Scripting\k.cs, Line: 1015, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #622 Path: D:\a\1\s\Kooboo.Sites\Scripting\k.cs, Line: 839, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #623 Path: D:\a\1\s\Kooboo.Sites\Scripting\k.cs, Line: 879, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #624 Path: D:\a\1\s\Kooboo.Sites\Scripting\KscriptConfig\KscriptConfigContainer.cs, Line: 104, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #625 Path: D:\a\1\s\Kooboo.Sites\Scripting\KscriptConfig\KscriptConfigContainer.cs, Line: 308, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #626 Path: D:\a\1\s\Kooboo.Sites\Scripting\KscriptConfig\KscriptConfigContainer.cs, Line: 315, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #627 Path: D:\a\1\s\Kooboo.Sites\Scripting\Manager.cs, Line: 122, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #628 Path: D:\a\1\s\Kooboo.Sites\Scripting\Manager.cs, Line: 139, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #629 Path: D:\a\1\s\Kooboo.Sites\Scripting\Manager.cs, Line: 162, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #630 Path: D:\a\1\s\Kooboo.Sites\Scripting\Manager.cs, Line: 203, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #631 Path: D:\a\1\s\Kooboo.Sites\Scripting\Manager.cs, Line: 426, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #632 Path: D:\a\1\s\Kooboo.Sites\Scripting\Manager.cs, Line: 438, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #633 Path: D:\a\1\s\Kooboo.Sites\Scripting\Manager.cs, Line: 498, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #634 Path: D:\a\1\s\Kooboo.Sites\Scripting\Manager.cs, Line: 518, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #635 Path: D:\a\1\s\Kooboo.Sites\Scripting\Manager.cs, Line: 584, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #636 Path: D:\a\1\s\Kooboo.Sites\Scripting\Manager.cs, Line: 645, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #637 Path: D:\a\1\s\Kooboo.Sites\Scripting\Manager.cs, Line: 713, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #638 Path: D:\a\1\s\Kooboo.Sites\Scripting\ScriptHelper.cs, Line: 30, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #639 Path: D:\a\1\s\Kooboo.Sites\Service\CoreSettingService.cs, Line: 127, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #640 Path: D:\a\1\s\Kooboo.Sites\Service\CoreSettingService.cs, Line: 172, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #641 Path: D:\a\1\s\Kooboo.Sites\Service\CssService.cs, Line: 192, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #642 Path: D:\a\1\s\Kooboo.Sites\Service\CssService.cs, Line: 342, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #643 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 1174, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #644 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 1233, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #645 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 1236, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #646 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 1247, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #647 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 1268, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #648 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 1343, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #649 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 1367, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #650 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 1393, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #651 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 269, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #652 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 37, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #653 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 844, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #654 Path: D:\a\1\s\Kooboo.Sites\Service\DomService.cs, Line: 845, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #655 Path: D:\a\1\s\Kooboo.Sites\Service\DomUrlService.cs, Line: 309, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #656 Path: D:\a\1\s\Kooboo.Sites\Service\FontService.cs, Line: 105, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #657 Path: D:\a\1\s\Kooboo.Sites\Service\FontService.cs, Line: 357, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #658 Path: D:\a\1\s\Kooboo.Sites\Service\FontService.cs, Line: 446, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #659 Path: D:\a\1\s\Kooboo.Sites\Service\FontService.cs, Line: 480, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #660 Path: D:\a\1\s\Kooboo.Sites\Service\FontService.cs, Line: 497, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #661 Path: D:\a\1\s\Kooboo.Sites\Service\HtmlHeadService.cs, Line: 244, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #662 Path: D:\a\1\s\Kooboo.Sites\Service\HtmlHeadService.cs, Line: 252, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #663 Path: D:\a\1\s\Kooboo.Sites\Service\HtmlHeadService.cs, Line: 254, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #664 Path: D:\a\1\s\Kooboo.Sites\Service\HtmlHeadService.cs, Line: 371, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #665 Path: D:\a\1\s\Kooboo.Sites\Service\HtmlHeadService.cs, Line: 51, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #666 Path: D:\a\1\s\Kooboo.Sites\Service\HtmlHeadService.cs, Line: 96, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #667 Path: D:\a\1\s\Kooboo.Sites\Service\LogService.cs, Line: 139, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #668 Path: D:\a\1\s\Kooboo.Sites\Service\LogService.cs, Line: 37, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #669 Path: D:\a\1\s\Kooboo.Sites\Service\MenuService.cs, Line: 102, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #670 Path: D:\a\1\s\Kooboo.Sites\Service\MenuService.cs, Line: 1125, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #671 Path: D:\a\1\s\Kooboo.Sites\Service\MenuService.cs, Line: 1128, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #672 Path: D:\a\1\s\Kooboo.Sites\Service\MenuService.cs, Line: 134, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #673 Path: D:\a\1\s\Kooboo.Sites\Service\MenuService.cs, Line: 149, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #674 Path: D:\a\1\s\Kooboo.Sites\Service\MenuService.cs, Line: 21, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #675 Path: D:\a\1\s\Kooboo.Sites\Service\MenuService.cs, Line: 654, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #676 Path: D:\a\1\s\Kooboo.Sites\Service\MenuService.cs, Line: 76, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #677 Path: D:\a\1\s\Kooboo.Sites\Service\MenuService.cs, Line: 88, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #678 Path: D:\a\1\s\Kooboo.Sites\Service\ObjectService.cs, Line: 137, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #679 Path: D:\a\1\s\Kooboo.Sites\Service\ObjectService.cs, Line: 46, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #680 Path: D:\a\1\s\Kooboo.Sites\Service\ObjectService.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #681 Path: D:\a\1\s\Kooboo.Sites\Service\ObjectService.cs, Line: 77, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #682 Path: D:\a\1\s\Kooboo.Sites\Service\PageService.cs, Line: 139, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #683 Path: D:\a\1\s\Kooboo.Sites\Service\PageService.cs, Line: 574, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #684 Path: D:\a\1\s\Kooboo.Sites\Service\PathService.cs, Line: 177, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #685 Path: D:\a\1\s\Kooboo.Sites\Service\PathService.cs, Line: 186, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #686 Path: D:\a\1\s\Kooboo.Sites\Service\VisitorLogService.cs, Line: 18, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #687 Path: D:\a\1\s\Kooboo.Sites\Service\WebSiteService.cs, Line: 137, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #688 Path: D:\a\1\s\Kooboo.Sites\Service\WebSiteService.cs, Line: 96, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #689 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\Analyzer\AnalyzerManager.cs, Line: 107, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #690 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\Analyzer\InlineAnalyzer.cs, Line: 24, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #691 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\Analyzer\InlineAnalyzer.cs, Line: 32, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #692 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\Analyzer\InlineAnalyzer.cs, Line: 40, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #693 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\Analyzer\InlineAnalyzer.cs, Line: 63, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #694 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\Analyzer\InlineAnalyzer.cs, Line: 70, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #695 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\Continue\ContinueTask.cs, Line: 26, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #696 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\Executor\TransferByLevelExecutor.cs, Line: 136, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #697 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\Executor\TransferByLevelExecutor.cs, Line: 204, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #698 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\Executor\TransferByLevelExecutor.cs, Line: 78, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #699 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\Executor\TransferBySelectedPagesExecutor.cs, Line: 73, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #700 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\TransferManager.cs, Line: 116, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #701 Path: D:\a\1\s\Kooboo.Sites\SiteTransfer\TransferManager.cs, Line: 132, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #702 Path: D:\a\1\s\Kooboo.Sites\SMS\Aliyun\Core\Auth\CredentialsBackupCompatibilityAdaptor.cs, Line: 57, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #703 Path: D:\a\1\s\Kooboo.Sites\SMS\Aliyun\Core\DefaultAcsClient.cs, Line: 273, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #704 Path: D:\a\1\s\Kooboo.Sites\SMS\Aliyun\Core\Exceptions\ClientException.cs, Line: 27, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #705 Path: D:\a\1\s\Kooboo.Sites\SMS\Aliyun\Core\Http\HttpResponse.cs, Line: 145, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #706 Path: D:\a\1\s\Kooboo.Sites\SMS\Aliyun\Core\Http\HttpResponse.cs, Line: 151, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #707 Path: D:\a\1\s\Kooboo.Sites\SMS\Aliyun\Core\Http\HttpResponse.cs, Line: 158, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #708 Path: D:\a\1\s\Kooboo.Sites\SMS\Aliyun\Core\Regions\InternalEndpointsParser.cs, Line: 47, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #709 Path: D:\a\1\s\Kooboo.Sites\SMS\Aliyun\Core\Retry\Condition\RetryOnExceptionCondition.cs, Line: 46, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #710 Path: D:\a\1\s\Kooboo.Sites\SMS\TencentCloud\Common\AbstractModel.cs, Line: 50, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #711 Path: D:\a\1\s\Kooboo.Sites\SMS\TencentCloud\Common\Sign.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #712 Path: D:\a\1\s\Kooboo.Sites\Sync\Cluster\ClusterService.cs, Line: 333, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #713 Path: D:\a\1\s\Kooboo.Sites\Sync\Cluster\ClusterService.cs, Line: 45, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #714 Path: D:\a\1\s\Kooboo.Sites\Sync\Cluster\Integrity.cs, Line: 34, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #715 Path: D:\a\1\s\Kooboo.Sites\Sync\Cluster\Integrity.cs, Line: 36, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #716 Path: D:\a\1\s\Kooboo.Sites\Sync\ImportExport.cs, Line: 1221, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #717 Path: D:\a\1\s\Kooboo.Sites\Sync\ImportExport.cs, Line: 1233, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #718 Path: D:\a\1\s\Kooboo.Sites\Sync\ImportExport.cs, Line: 1244, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #719 Path: D:\a\1\s\Kooboo.Sites\Sync\ImportExport.cs, Line: 170, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #720 Path: D:\a\1\s\Kooboo.Sites\Sync\ImportExport.cs, Line: 191, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #721 Path: D:\a\1\s\Kooboo.Sites\Sync\ImportExport.cs, Line: 200, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #722 Path: D:\a\1\s\Kooboo.Sites\Sync\ImportExport.cs, Line: 686, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #723 Path: D:\a\1\s\Kooboo.Sites\Sync\ImportExport.cs, Line: 963, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #724 Path: D:\a\1\s\Kooboo.Sites\Sync\ImportExport.cs, Line: 980, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #725 Path: D:\a\1\s\Kooboo.Sites\Sync\SiteClusterSync\SiteClusterManager.cs, Line: 107, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #726 Path: D:\a\1\s\Kooboo.Sites\Sync\SiteClusterSync\SiteClusterManager.cs, Line: 329, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #727 Path: D:\a\1\s\Kooboo.Sites\Sync\SyncService.cs, Line: 296, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #728 Path: D:\a\1\s\Kooboo.Sites\Sync\SyncService.cs, Line: 391, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #729 Path: D:\a\1\s\Kooboo.Sites\Sync\SyncService.cs, Line: 414, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #730 Path: D:\a\1\s\Kooboo.Sites\TaskQueue\JobBackGroundWorker.cs, Line: 53, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #731 Path: D:\a\1\s\Kooboo.Sites\Upgrade\HardCodeUpgrade.cs, Line: 47, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #732 Path: D:\a\1\s\Kooboo.Sites\Upgrade\SiteContentDataSourceUpgrade.cs, Line: 51, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #733 Path: D:\a\1\s\Kooboo.Sites\ViewModel\TextContent.cs, Line: 140, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #734 Path: D:\a\1\s\Kooboo.Sites\ViewModel\TextContent.cs, Line: 158, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #735 Path: D:\a\1\s\Kooboo.Sites\ViewModel\TextContent.cs, Line: 174, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155



Project: Kooboo.Data(net461)
    #736 Path: D:\a\1\s\Kooboo.Data\Cache\MultilingualRender.cs, Line: 130, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #737 Path: D:\a\1\s\Kooboo.Data\Context\RequestManager.cs, Line: 22, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #738 Path: D:\a\1\s\Kooboo.Data\Context\RequestManager.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #739 Path: D:\a\1\s\Kooboo.Data\Context\RequestManager.cs, Line: 75, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #740 Path: D:\a\1\s\Kooboo.Data\Context\WebServerContext.cs, Line: 484, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #741 Path: D:\a\1\s\Kooboo.Data\Extensions\JobExtension.cs, Line: 47, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #742 Path: D:\a\1\s\Kooboo.Data\GeoLocation\IPLocation.cs, Line: 260, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #743 Path: D:\a\1\s\Kooboo.Data\GeoLocation\IPLocation.cs, Line: 278, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #744 Path: D:\a\1\s\Kooboo.Data\Helper\ChromeScreenShotHelper.cs, Line: 25, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #745 Path: D:\a\1\s\Kooboo.Data\Helper\Domain\DomainParser.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #746 Path: D:\a\1\s\Kooboo.Data\Language\LanguageProvider.cs, Line: 130, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #747 Path: D:\a\1\s\Kooboo.Data\Language\LanguageProvider.cs, Line: 39, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #748 Path: D:\a\1\s\Kooboo.Data\Language\LanguageSetting.cs, Line: 240, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #749 Path: D:\a\1\s\Kooboo.Data\Language\LanguageSetting.cs, Line: 338, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #750 Path: D:\a\1\s\Kooboo.Data\Language\LanguageTaskHelper.cs, Line: 191, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #751 Path: D:\a\1\s\Kooboo.Data\Language\LanguageTaskHelper.cs, Line: 36, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #752 Path: D:\a\1\s\Kooboo.Data\Models\WebSite.cs, Line: 114, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #753 Path: D:\a\1\s\Kooboo.Data\Repository\BindingRepository.cs, Line: 210, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #754 Path: D:\a\1\s\Kooboo.Data\Repository\BindingRepository.cs, Line: 210, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #755 Path: D:\a\1\s\Kooboo.Data\Repository\WebSiteRepository.cs, Line: 154, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #756 Path: D:\a\1\s\Kooboo.Data\Server\ServerHandler.cs, Line: 402, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #757 Path: D:\a\1\s\Kooboo.Data\Service\DefaultPasswordHash.cs, Line: 45, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #758 Path: D:\a\1\s\Kooboo.Data\Service\StartService.cs, Line: 18, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #759 Path: D:\a\1\s\Kooboo.Data\Service\UserLoginProtection.cs, Line: 45, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Kooboo.Mail(net461)
    #760 Path: D:\a\1\s\Kooboo.Mail\Dns\Client\ResponseException.cs, Line: 7, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #761 Path: D:\a\1\s\Kooboo.Mail\Dns\Protocol\Utils\ObjectStringifier.cs, Line: 21, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #762 Path: D:\a\1\s\Kooboo.Mail\Dns\Protocol\Utils\ObjectStringifier.cs, Line: 3, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #763 Path: D:\a\1\s\Kooboo.Mail\Imap\CommandManager.cs, Line: 156, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #764 Path: D:\a\1\s\Kooboo.Mail\Imap\Commands\FetchCommand\CommandReader.cs, Line: 214, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #765 Path: D:\a\1\s\Kooboo.Mail\Imap\Commands\SearchCommand\CommandReader.cs, Line: 165, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #766 Path: D:\a\1\s\Kooboo.Mail\Imap\Commands\SearchCommand\CommandReader.cs, Line: 244, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #767 Path: D:\a\1\s\Kooboo.Mail\Imap\Commands\SearchCommand\CommandReader.cs, Line: 49, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #768 Path: D:\a\1\s\Kooboo.Mail\Imap\Commands\SearchCommand\Search.cs, Line: 150, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #769 Path: D:\a\1\s\Kooboo.Mail\Imap\ImapHelper.cs, Line: 262, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #770 Path: D:\a\1\s\Kooboo.Mail\Imap\ImapHelper.cs, Line: 74, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #771 Path: D:\a\1\s\Kooboo.Mail\Imap\ResultLine.cs, Line: 110, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #772 Path: D:\a\1\s\Kooboo.Mail\Imap\ResultLine.cs, Line: 125, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #773 Path: D:\a\1\s\Kooboo.Mail\Imap\ResultLine.cs, Line: 146, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #774 Path: D:\a\1\s\Kooboo.Mail\Imap\ResultLine.cs, Line: 51, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #775 Path: D:\a\1\s\Kooboo.Mail\Imap\ResultLine.cs, Line: 71, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #776 Path: D:\a\1\s\Kooboo.Mail\Imap\Server\ImapServer.cs, Line: 111, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #777 Path: D:\a\1\s\Kooboo.Mail\Imap\Server\ImapServer.cs, Line: 116, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #778 Path: D:\a\1\s\Kooboo.Mail\LumiSoft.Net\AUTH\AUTH_Gmail_OAuth1_3leg.cs, Line: 444, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #779 Path: D:\a\1\s\Kooboo.Mail\LumiSoft.Net\AUTH\AUTH_Gmail_OAuth1_3leg.cs, Line: 465, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #780 Path: D:\a\1\s\Kooboo.Mail\LumiSoft.Net\IO\MemoryStreamEx.cs, Line: 57, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #781 Path: D:\a\1\s\Kooboo.Mail\LumiSoft.Net\IO\SmartStream.cs, Line: 1443, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #782 Path: D:\a\1\s\Kooboo.Mail\LumiSoft.Net\Mail\Mail_t_AddressList.cs, Line: 308, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #783 Path: D:\a\1\s\Kooboo.Mail\Models\Message.cs, Line: 146, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #784 Path: D:\a\1\s\Kooboo.Mail\Multipart\BodyComposer.cs, Line: 155, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #785 Path: D:\a\1\s\Kooboo.Mail\Queue\Executor\GroupMailExecutor.cs, Line: 35, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #786 Path: D:\a\1\s\Kooboo.Mail\Repositories\MessageRepository.cs, Line: 262, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #787 Path: D:\a\1\s\Kooboo.Mail\Repositories\MessageRepository.cs, Line: 263, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #788 Path: D:\a\1\s\Kooboo.Mail\Settings.cs, Line: 79, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #789 Path: D:\a\1\s\Kooboo.Mail\Settings.cs, Line: 89, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #790 Path: D:\a\1\s\Kooboo.Mail\Smtp\ConnectionInfo.cs, Line: 76, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #791 Path: D:\a\1\s\Kooboo.Mail\Smtp\SmtpConnector.cs, Line: 102, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #792 Path: D:\a\1\s\Kooboo.Mail\Smtp\SmtpServer.cs, Line: 106, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #793 Path: D:\a\1\s\Kooboo.Mail\Smtp\SmtpServer.cs, Line: 110, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #794 Path: D:\a\1\s\Kooboo.Mail\Transport\Incoming.cs, Line: 199, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #795 Path: D:\a\1\s\Kooboo.Mail\Transport\Incoming.cs, Line: 207, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #796 Path: D:\a\1\s\Kooboo.Mail\Transport\Incoming.cs, Line: 53, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #797 Path: D:\a\1\s\Kooboo.Mail\Utility\MessageUtility.cs, Line: 113, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #798 Path: D:\a\1\s\Kooboo.Mail\Utility\MessageUtility.cs, Line: 152, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #799 Path: D:\a\1\s\Kooboo.Mail\Utility\MessageUtility.cs, Line: 170, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #800 Path: D:\a\1\s\Kooboo.Mail\Utility\MessageUtility.cs, Line: 249, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #801 Path: D:\a\1\s\Kooboo.Mail\Utility\MessageUtility.cs, Line: 304, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #802 Path: D:\a\1\s\Kooboo.Mail\Utility\MessageUtility.cs, Line: 427, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #803 Path: D:\a\1\s\Kooboo.Mail\Utility\MessageUtility.cs, Line: 75, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #804 Path: D:\a\1\s\Kooboo.Mail\Utility\MessageUtility.cs, Line: 94, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Kooboo.App
    #805 Path: D:\a\1\s\Kooboo.App\App.xaml.cs, Line: 34, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #806 Path: D:\a\1\s\Kooboo.App\App.xaml.cs, Line: 38, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #807 Path: D:\a\1\s\Kooboo.App\App.xaml.cs, Line: 58, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #808 Path: D:\a\1\s\Kooboo.App\Commands\TaskbarClickCommand.cs, Line: 19, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #809 Path: D:\a\1\s\Kooboo.App\Commands\TaskbarClickCommand.cs, Line: 31, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #810 Path: D:\a\1\s\Kooboo.App\SystemTray\RoutedEventHelper.cs, Line: 41, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #811 Path: D:\a\1\s\Kooboo.App\SystemTray\RoutedEventHelper.cs, Line: 48, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #812 Path: D:\a\1\s\Kooboo.App\SystemTray\RoutedEventHelper.cs, Line: 62, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #813 Path: D:\a\1\s\Kooboo.App\SystemTray\RoutedEventHelper.cs, Line: 72, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #814 Path: D:\a\1\s\Kooboo.App\SystemTray\Util.cs, Line: 239, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #815 Path: D:\a\1\s\Kooboo.App\UpgradePage.xaml.cs, Line: 104, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #816 Path: D:\a\1\s\Kooboo.App\UpgradePage.xaml.cs, Line: 109, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #817 Path: D:\a\1\s\Kooboo.App\UpgradePage.xaml.cs, Line: 176, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Kooboo.Render(net461)
    #818 Path: D:\a\1\s\Kooboo.Render\Controller\Response\ResponseBase.cs, Line: 73, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #819 Path: D:\a\1\s\Kooboo.Render\Customized\AdminVersionEvaluator.cs, Line: 112, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #820 Path: D:\a\1\s\Kooboo.Render\ServerSide\LoadJs.cs, Line: 18, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #821 Path: D:\a\1\s\Kooboo.Render\ServerSide\LoadJsFolder.cs, Line: 19, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #822 Path: D:\a\1\s\Kooboo.Render\ServerSide\ServerEngine.cs, Line: 159, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #823 Path: D:\a\1\s\Kooboo.Render\ServerSide\ServerEngine.cs, Line: 209, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #824 Path: D:\a\1\s\Kooboo.Render\ServerSide\ServerEngine.cs, Line: 65, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #825 Path: D:\a\1\s\Kooboo.Render\ServerSide\SetHtml.cs, Line: 19, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #826 Path: D:\a\1\s\Kooboo.Render\ServerSide\SetMethods.cs, Line: 18, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #827 Path: D:\a\1\s\Kooboo.Render\ServerSide\StringTask.cs, Line: 26, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155



Project: Kooboo.Api(net461)
    #828 Path: D:\a\1\s\Kooboo.Api\ApiManager.cs, Line: 193, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #829 Path: D:\a\1\s\Kooboo.Api\ApiManager.cs, Line: 239, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #830 Path: D:\a\1\s\Kooboo.Api\ApiManager.cs, Line: 265, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #831 Path: D:\a\1\s\Kooboo.Api\ApiProvider.cs, Line: 35, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #832 Path: D:\a\1\s\Kooboo.Api\ApiResponse\MetaResponse.cs, Line: 97, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #833 Path: D:\a\1\s\Kooboo.Api\Methods\ApiMethodManager.cs, Line: 357, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #834 Path: D:\a\1\s\Kooboo.Api\MultilingualService.cs, Line: 21, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: Kooboo.HttpServer(net461)
    #835 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\Http\Http1\HttpHeaders.cs, Line: 434, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #836 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\Micosoft\Extensions\Primitives\StringValues.cs, Line: 388, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #837 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\Micosoft\Extensions\Primitives\StringValues.cs, Line: 393, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #838 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\Micosoft\Extensions\Primitives\StringValues.cs, Line: 398, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #839 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\Sockets\SocketConnection.cs, Line: 135, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #840 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\Sockets\Ssl\SslAdapter.cs, Line: 217, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #841 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\System\Memory.cs, Line: 328, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #842 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\System\ValueTuple\ValueTuple.cs, Line: 1102, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #843 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\System\ValueTuple\ValueTuple.cs, Line: 1333, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #844 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\System\ValueTuple\ValueTuple.cs, Line: 1582, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #845 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\System\ValueTuple\ValueTuple.cs, Line: 1855, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #846 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\System\ValueTuple\ValueTuple.cs, Line: 339, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #847 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\System\ValueTuple\ValueTuple.cs, Line: 515, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #848 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\System\ValueTuple\ValueTuple.cs, Line: 694, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #849 Path: D:\a\1\s\Kooboo.HttpServer\src\Kooboo.HttpServer\System\ValueTuple\ValueTuple.cs, Line: 889, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: Kooboo.Engines
    #850 Path: D:\a\1\s\Kooboo.Engines\Core\Pipeline\ContentTransformState.cs, Line: 44, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #851 Path: D:\a\1\s\Kooboo.Engines\Core\Utility.cs, Line: 16, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #852 Path: D:\a\1\s\Kooboo.Engines\JavaScript\ActiveScript\ActiveScriptException.cs, Line: 76, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #853 Path: D:\a\1\s\Kooboo.Engines\JavaScript\ActiveScript\BaseActiveScriptSite.cs, Line: 72, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #854 Path: D:\a\1\s\Kooboo.Engines\JavaScript\ActiveScript\BaseActiveScriptSite.cs, Line: 79, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Kooboo.App.Standard(net461)
    #855 Path: D:\a\1\s\Kooboo.App.Standard\UpgradeHelper.cs, Line: 38, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #856 Path: D:\a\1\s\Kooboo.App.Standard\UpgradeHelper.cs, Line: 60, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Kooboo.App.Upgrade(net461)
    #857 Path: D:\a\1\s\Kooboo.App.Upgrade\CmdHelper.cs, Line: 14, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #858 Path: D:\a\1\s\Kooboo.App.Upgrade\KoobooUpgrade.cs, Line: 150, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #859 Path: D:\a\1\s\Kooboo.App.Upgrade\KoobooUpgrade.cs, Line: 180, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #860 Path: D:\a\1\s\Kooboo.App.Upgrade\KoobooUpgrade.cs, Line: 248, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #861 Path: D:\a\1\s\Kooboo.App.Upgrade\KoobooUpgrade.cs, Line: 266, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #862 Path: D:\a\1\s\Kooboo.App.Upgrade\KoobooUpgrade.cs, Line: 290, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #863 Path: D:\a\1\s\Kooboo.App.Upgrade\KoobooUpgrade.cs, Line: 364, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #864 Path: D:\a\1\s\Kooboo.App.Upgrade\KoobooUpgrade.cs, Line: 384, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #865 Path: D:\a\1\s\Kooboo.App.Upgrade\KoobooUpgrade.cs, Line: 410, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #866 Path: D:\a\1\s\Kooboo.App.Upgrade\KoobooUpgrade.cs, Line: 84, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



--- Rules Summary ---
R6: 239
R8: 183
R9: 122
R7: 120
R4: 82
R2: 58
R3: 32
R5: 29
R10: 1

--- Summary ---
Fixed ReSharper issues: 808
Fixed SonarQube issues: 383
Total fixed issues: 866

Finished in: 1 min 24 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.IndexedDB\Dynamic\Table.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Kooboo.IndexedDB.Dynamic
{
    public class Table
    {
        public Setting Setting { get; set; }

        public Guid CurrentUserId { get; set; }

        internal object _Locker = new object();

        public Converter.ObjectConverter ObjectConverter { get; set; }

        private BlockFile _blockfile;
        private object _lockerBlockFile = new object();
        public BlockFile BlockFile
        {
            get
            {
                if (_blockfile == null)
                {
                    lock (_lockerBlockFile)
                    {
                        if (_blockfile == null)
                        {
                            string blockfileName = System.IO.Path.Combine(this.ObjectFolder, "table.block");
                            _blockfile = new BlockFile(blockfileName);
                            _blockfile.OpenOrCreate();
                        }
                    }
                }
                return _blockfile;
            }
        }

        internal Btree.BtreeIndex<Guid> PrimaryBtree
        {
            get
            {
                var find = this.Indexs.Find(o => o.FieldName == Dynamic.Constants.DefaultIdFieldName);
                var right = find as TableIndexBase<Guid>;
                return right.index;
            }
        }

        public long length
        {
            get
            {
                return this.PrimaryBtree.Count(false);
            }
        }

        public long count
        {
            get
            {
                return this.length;
            }
        }

        public List<Guid> Keys
        {
            get
            {
                List<Guid> result = new List<Guid>();
                var keyconverter = ObjectContainer.GetConverter<Guid>();

                foreach (var item in this.PrimaryBtree.AllKeyBytesCollection(true))
                {
                    var key = keyconverter.FromByte(item);
                    result.Add(key);
                }
                return result;
            }
        }

        public List<ITableIndex> Indexs { get; set; }

        public string ObjectFolder { get; set; }

        internal string SettingFile { get; set; }

        /// <summary>
        /// The name of this object store.
        /// </summary>
        public string Name { get; set; }

        public Database OwnerDatabase { get; set; }

        public Guid FirstKey
        {
            get
            {
                return this.PrimaryBtree.FirstKey;
            }
        }

        public Guid LastKey
        {
            get
            {
                return this.PrimaryBtree.LastKey;
            }
        }

        private string PrimaryKey { get; set; }

        public Table(string name, Database ownerdatabase, Setting setting)
        {
            this.Name = name;
            this.ObjectFolder = ownerdatabase.TableFolder(name);
            this.SettingFile = ownerdatabase.TableSetitingFile(name);

            setting = SettingHelper.GetOrSetTableSetting(this.SettingFile, setting);

            this.OwnerDatabase = ownerdatabase;
            Init(setting);
        }
        public Table(string name, Database ownerdatabase)
        {
            Setting setting = null;
            this.Name = name;
            this.ObjectFolder = ownerdatabase.TableFolder(name);
            this.SettingFile = ownerdatabase.TableSetitingFile(name);

            setting = SettingHelper.GetOrSetTableSetting(this.SettingFile, setting);

            this.OwnerDatabase = ownerdatabase;
            Init(setting);
        }

        private void Init(Setting setting)
        {
            this.Indexs = IndexHelper.CreatIndexs(setting, this.ObjectFolder);
            this.Setting = setting;
            var primary = this.Indexs.Find(o => o.IsPrimaryKey);
            this.PrimaryKey = primary.FieldName;

            SettingHelper.EnsureColumnRelativePosition(this.Setting.Columns);

            ObjectConverter = new Dynamic.Converter.ObjectConverter(this.Setting.Columns.ToList(), this.PrimaryKey);
        }


        private long _addBlock(Dictionary<string, object> data)
        {
            lock (_lockerBlockFile)
            {
                byte[] valuebyte = ObjectConverter.ToBytes(data);
                return this.BlockFile.Add(valuebyte, valuebyte.Length);
            }
        }

        public void RebuildTable(Setting newSetting)
        {
            var isenable = newSetting.EnableLog;

            string newname = "_koobootemp_" + System.Guid.NewGuid().ToString() + this.Name;
            var newtable = this.OwnerDatabase.GetOrCreateTable(newname, newSetting);

            newtable.Setting.EnableLog = false;

            var primaryindex = this.Indexs.Find(o => o.IsSystem);

            string errormsg = null;

            try
            {
                foreach (var item in primaryindex.AllItems(true))
                {
                    var value = this._getvalue(item);
                    newtable.Add(value);
                }
            }
            catch (Exception ex)
            {
                errormsg = ex.Message;
            }

            if (errormsg != null)
            {
                this.OwnerDatabase.DeleteTable(newtable.Name);
                throw new Exception(errormsg);
            }

            string oldfolder = this.ObjectFolder;
            string newfolder = newtable.ObjectFolder;

            this.Close();
            newtable.Close();
            this.DelSelf();
            this._blockfile = null;
            System.IO.Directory.Move(newfolder, oldfolder);


            newtable.Setting.EnableLog = isenable;

            SettingHelper.WriteSetting(this.SettingFile, newSetting);
            Init(newSetting);

            if (System.IO.Directory.Exists(newfolder))
            {
                System.IO.Directory.Delete(newfolder, true);
            }

            this.OwnerDatabase.openTableList.Remove(newname);
        }

        public void UpdateSetting(Setting newsetting)
        {
            ensureincremental(newsetting);

            var check = SettingHelper.UpdateSetting(newsetting.Columns.ToList(), this.Setting);

            lock (_Locker)
            {
                if (check.ShouldRebuild)
                {
                    RebuildTable(check.NewSetting);
                }
                else if (check.HasChange)
                {
                    // reinit index... and try to find remove or create index. 

                    var newindexs = IndexHelper.CreatIndexs(check.NewSetting, this.ObjectFolder);

                    foreach (var item in newindexs)
                    {
                        item.Close();
                    }

                    List<string> toremove = new List<string>();

                    foreach (var item in this.Indexs)
                    {
                        var newer = newindexs.Find(o => o.FieldName == item.FieldName);
                        if (newer == null)
                        {
                            toremove.Add(item.FieldName);
                        }
                    }

                    Dictionary<string, bool> indexToRebuild = new Dictionary<string, bool>();

                    foreach (var item in newindexs)
                    {
                        var older = this.Indexs.Find(o => o.FieldName == item.FieldName);
                        if (older == null)
                        {
                            indexToRebuild.Add(item.FieldName, item.IsUnique);
                        }
                    }

                    foreach (var item in indexToRebuild)
                    {
                        this.CreateIndex(item.Key, item.Value, check.NewSetting);
                    }

                    foreach (var item in toremove)
                    {
                        this.RemoveIndex(item);
                    }

                    this.Setting = check.NewSetting;

                    SettingHelper.WriteSetting(this.SettingFile, this.Setting);

                    var primary = newindexs.Find(o => o.IsPrimaryKey);

                    this.ObjectConverter = new Dynamic.Converter.ObjectConverter(this.Setting.Columns.ToList(), primary.FieldName);

                    this.PrimaryKey = primary.FieldName;

                    foreach (var item in this.Indexs)
                    {
                        item.Close();
                    }

                    this.Indexs = newindexs;

                    foreach (var item in this.Indexs)
                    {
                        item.Close();
                    }

                }

                this.Close();
            }
        }

        private void ensureincremental(Setting newsetting)
        {
            if (newsetting?.Columns != null)
            {
                foreach (var item in newsetting.Columns)
                {
                    if (item.IsIncremental)
                    {
                        item.IsUnique = true;
                        item.IsIndex = true;
                        if (item.Seed < 0)
                        {
                            item.Seed = 0;
                        }
                        if (item.Increment < 1)
                        {
                            item.Increment = 1;
                        }
                    }
                }
            }
        }

        public Dictionary<string, object> PrepareData(object dataobj, bool Update = false)
        {
            // prepare key...
            Dictionary<string, object> data = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);

            System.Collections.IDictionary idict = dataobj as System.Collections.IDictionary;

            IDictionary<string, object> dynamicobj = null;
            Type objecttype = null;

            if (idict == null)
            {
                dynamicobj = dataobj as IDictionary<string, object>;
            }

            if (idict == null && dynamicobj == null)
            {
                objecttype = dataobj.GetType();
            }

            Guid DefaultId = default(Guid);
            var DefaultIdObj = _GetObjValue(idict, dynamicobj, Dynamic.Constants.DefaultIdFieldName, typeof(Guid), dataobj, objecttype);
            if (DefaultIdObj != null)
            {
                System.Guid.TryParse(DefaultIdObj.ToString(), out DefaultId);
            }

            foreach (var item in this.Setting.Columns)
            {
                if (item.IsSystem)
                {
                    // the only system field is the id fields. 
                    object Value = null;

                    if (this.PrimaryKey != Dynamic.Constants.DefaultIdFieldName)
                    { 
                        if (idict != null)
                        {
                            Value = Accessor.GetValueIDict(idict, this.PrimaryKey, item.ClrType);

                        }
                        else if (dynamicobj != null)
                        {
                            Value = Accessor.GetValue(dynamicobj, this.PrimaryKey, item.ClrType);
                        }
                        else
                        {
                            Value = Accessor.GetValue(dataobj, objecttype, this.PrimaryKey, item.ClrType);
                        }

                        if (Value == null)
                        {
                            var col = this.Setting.Columns.First(o => o.Name == this.PrimaryKey);
                            if (col != null)
                            {
                                if (col.ClrType == typeof(string))
                                {
                                    Value = default(Guid);
                                }
                                else
                                { 
                                    Value = IndexHelper.DefaultValue(col.ClrType);
                                }
                            }
                        }

                        if (Update == false && Value !=null )
                        {
                            DefaultId = _ParseKey(Value);
                        } 
                    }

                    if (Value == null)
                    {
                        if (idict != null)
                        {
                            Value = Accessor.GetValueIDict(idict, item.Name, item.ClrType);
                        }
                        else if (dynamicobj != null)
                        {
                            Value = Accessor.GetValue(dynamicobj, item.Name, item.ClrType);
                        }
                        else
                        {
                            Value = Accessor.GetValue(dataobj, objecttype, item.Name, item.ClrType);
                        }
                    }

                    if (Value == null)
                    {
                        // the only possible null value value for key is string.   
                        Value = Helper.IndexHelper.NewTimeGuid();
                    }
                    else
                    {
                        Value = _ParseKey(Value);
                    }
                    if (!data.ContainsKey(item.Name))
                    {
                        data.Add(item.Name, Value);
                    }
                }

                else
                {
                    object Value = null;

                    if (idict != null)
                    {
                        Value = Accessor.GetValueIDict(idict, item.Name, item.ClrType);

                    }
                    else if (dynamicobj != null)
                    {
                        Value = Accessor.GetValue(dynamicobj, item.Name, item.ClrType);
                    }
                    else
                    {
                        Value = Accessor.GetValue(dataobj, objecttype, item.Name, item.ClrType);
                    }

                    if (item.IsIncremental && !Update)
                    {
                        if (Value == null || Accessor.ChangeType<long>(Value) == 0)
                        {
                            var index = this.Indexs.Find(o => o.FieldName == item.Name);
                            Value = index.NextIncrement();
                        }

                        if (item.IsPrimaryKey && Value != null)
                        {
                            var keyvalue = _ParseKey(Value);
                            data[Dynamic.Constants.DefaultIdFieldName] = keyvalue;
                        }
                    }

                    if (Value == null)
                    {
                        if (item.IsIncremental)
                        {
                            var index = this.Indexs.Find(o => o.FieldName == item.Name);
                            Value = index.NextIncrement();
                        }
                        else if (item.IsIndex || item.IsPrimaryKey)
                        {
                            Value = IndexHelper.DefaultValue(item.ClrType);
                        }
                    }

                    if (Value == null && (item.IsIndex || item.IsPrimaryKey))
                    {
                        Value = IndexHelper.DefaultValue(item.ClrType);
                    } 
                    // var rightvalue = Accessor.ChangeType(Value, item.ClrType);  
                    data.Add(item.Name, Value);
                }
            }


            if (DefaultId != default(Guid))
            {
                data[Dynamic.Constants.DefaultIdFieldName] = DefaultId;
            }

            return data;
        }


        private object _GetObjValue(System.Collections.IDictionary idict, IDictionary<string, object> dynamicobj, string key, Type clrType, object dataobj, Type objecttype)
        {
            if (idict != null)
            {
                return Accessor.GetValueIDict(idict, key, clrType);

            }
            else if (dynamicobj != null)
            {
                return Accessor.GetValue(dynamicobj, key, clrType);
            }
            else
            {
                return Accessor.GetValue(dataobj, objecttype, key, clrType);
            }
        }

        private void CheckAddConstraints(Dictionary<string, object> data)
        {
            foreach (var item in this.Indexs.Where(o => o.IsUnique))
            {
                if (data.ContainsKey(item.FieldName))
                {
                    var value = data[item.FieldName];

                    if (value == null)
                    {
                        value = IndexHelper.DefaultValue(item.keyType);

                        // throw new Exception("Value not provided for Index: " + item.FieldName);
                    }

                    //    if (IndexHelper.IsDefaultValue(value, item.keyType))
                    //   {
                    //  throw new Exception("Value not provided for Index: " + item.FieldName);
                    // TODO: think of whether this is needed or not. 
                    //  }

                    var block = item.Get(value);
                    if (block > 0)
                    {
                        throw new Exception("Uniqueness contraints validation failed. Index: " + item.FieldName);
                    }
                }
                else
                {
                    throw new Exception("Value not provided for index: " + item.FieldName);
                }
            }
        }

        public Guid Add(object Value, bool CheckCol = false, Action<long> CallBackPos = null)
        {
            lock (_Locker)
            {
                if (CheckCol)
                {
                    var check = SettingHelper.CompareSetting(Value, this.Setting);

                    if (check.ShouldRebuild)
                    {
                        RebuildTable(check.NewSetting);
                        return Add(Value);
                    }

                    else if (check.HasChange)
                    {
                        this.Setting = check.NewSetting;
                        SettingHelper.WriteSetting(this.SettingFile, this.Setting);
                        var primary = this.Indexs.Find(o => o.IsPrimaryKey);
                        this.ObjectConverter = new Dynamic.Converter.ObjectConverter(this.Setting.Columns.ToList(), primary.FieldName);
                    }
                }

                var data = this.PrepareData(Value);

                CheckAddConstraints(data);

                Int64 contentposition = _addBlock(data);

                if (CallBackPos != null)
                {
                    CallBackPos(contentposition);
                }


                foreach (var item in this.Indexs)
                {
                    object key = null;

                    if (data.ContainsKey(item.FieldName))
                    {
                        key = data[item.FieldName];
                    }
                    else
                    {
                        // should not be, because there is a constraints checking. 
                        throw new Exception("data not provided for index: " + item.FieldName);
                    }

                    item.Add(key, contentposition);
                }

                this.Close();

                Guid ReturnId = default(Guid);

                if (data.ContainsKey(Constants.DefaultIdFieldName))
                {
                    ReturnId = (Guid)data[Constants.DefaultIdFieldName];

                    if (this.Setting.EnableLog)
                    {
                        var logid = this.OwnerDatabase.Log.GetNewLogId(this.OwnerDatabase.Name);

                        var logpos = AddLogData(logid, data);

                        var log = new LogEntry()
                        {
                            Id = logid,
                            EditType = EditType.Add,
                            OldBlockPosition = logpos,
                            NewBlockPosition = logpos,
                            UserId = this.CurrentUserId,
                            TableName = this.Name,
                            UpdateTime = DateTime.UtcNow,
                            KeyBytes = ObjectContainer.GuidConverter.ToByte(ReturnId)
                        };

                        this.OwnerDatabase.Log.Add(log);
                    }
                }

                return ReturnId;
            }
        }

        public long AddLogData(long LogId, Dictionary<string, object> data)
        {
            byte[] valuebyte = Kooboo.IndexedDB.Serializer.Simple.TableDataLogConverter.Instance.ToBytes(data);
            int len = valuebyte.Length;

            var logidbytes = BitConverter.GetBytes(LogId);

            byte[] totalbytes = new byte[len + 8];
            System.Buffer.BlockCopy(logidbytes, 0, totalbytes, 0, 8);
            System.Buffer.BlockCopy(valuebyte, 0, totalbytes, 8, len);

            var LogPos = this.OwnerDatabase.TableLog.Add(totalbytes, totalbytes.Length);
            this.OwnerDatabase.TableLog.Close(); // relese to enable delete. 

            return LogPos;
        }

        public Dictionary<string, object> GetLogData(LogEntry log)
        {
            return GetLogData(log.Id, log.NewBlockPosition);
        }

        public Dictionary<string, object> GetLogData(long LogId, long DiskPosition)
        {
            var databytes = this.OwnerDatabase.TableLog.Get(DiskPosition);

            if (databytes != null)
            {
                var dbLogId = BitConverter.ToInt64(databytes, 0);
                if (dbLogId == LogId)
                {
                    var valuebytes = new byte[databytes.Length - 8];
                    System.Buffer.BlockCopy(databytes, 8, valuebytes, 0, databytes.Length - 8);

                    return Kooboo.IndexedDB.Serializer.Simple.TableDataLogConverter.Instance.FromBytes(valuebytes);
                }
            }

            return null;
        }

        internal Guid _ParseKey(object key)
        {
            if (key == null)
            {
                return default(Guid);
            }

            if (key is System.Guid)
            {
                return (Guid)key;
            }
            string strkey = key.ToString();
            Guid guidkey;
            if (System.Guid.TryParse(strkey, out guidkey))
            {
                return guidkey;
            }
            else
            {
                return Helper.KeyHelper.ComputeGuid(strkey);
            }
        }

        public IDictionary<string, object> Get(Guid key)
        {
            Int64 blockposition;

            var primary = this.Indexs.Find(o => o.IsSystem);
            blockposition = primary.Get(key);

            if (blockposition > 0)
            {
                return _getvalue(blockposition);
            }
            return null;
        }

        public long GetDiskPos(object key)
        {
            var guidkey = _ParseKey(key);
            return GetDiskPos(guidkey);
        }

        public long GetDiskPos(Guid key)
        {
            var primary = this.Indexs.Find(o => o.IsSystem);
            return primary.Get(key);
        }

        public IDictionary<string, object> GetValue(long diskposition)
        {
            return _getvalue(diskposition);
        }

        public IDictionary<string, object> Get(object key)
        {
            var guidkey = _ParseKey(key);
            return Get(guidkey);
        }


        public T Get<T>(object key)
        {
            var guidkey = _ParseKey(key);

            Int64 blockposition;

            var primary = this.Indexs.Find(o => o.IsSystem);
            blockposition = primary.Get(guidkey);

            if (blockposition > 0)
            {
                return _getvalue<T>(blockposition);
            }
            return default(T);
        }

        internal IDictionary<string, object> _getvalue(Int64 blockposition)
        {
            lock (_Locker)
            {
                byte[] contentbytes = this.BlockFile.Get(blockposition);
                if (contentbytes != null)
                {
                    return this.ObjectConverter.FromBytes(contentbytes);
                }
                return null;
            }
        }

        internal T _getvalue<T>(Int64 blockposition)
        {
            lock (_Locker)
            {
                byte[] contentbytes = this.BlockFile.Get(blockposition);
                if (contentbytes != null)
                {
                    return this.ObjectConverter.FromBytes<T>(contentbytes);
                }
                return default(T);
            }
        }

        public bool Delete(object key)
        {
            var guidkey = _ParseKey(key);

            lock (_Locker)
            {
                var primary = this.Indexs.Find(o => o.IsSystem);
                List<Int64> blocklist = primary.Del(guidkey);

                if (blocklist.Count == 0)
                {
                    // key not found, not delete. 
                    return false;
                }

                var blockposition = blocklist[0];
                var value = this._getvalue(blockposition);

                if (value == null)
                {
                    return false;
                }

                var data = this.PrepareData(value, true);

                foreach (var item in this.Indexs)
                {
                    if (item.FieldName != primary.FieldName)
                    {
                        if (data.ContainsKey(item.FieldName))
                        {
                            var keyvalue = data[item.FieldName];
                            item.Del(keyvalue, blockposition);
                        }
                    }
                }



                if (this.Setting.EnableLog)
                {
                    var logid = this.OwnerDatabase.Log.GetNewLogId(this.OwnerDatabase.Name);

                    var diskposition = this.AddLogData(logid, data);

                    var log = new LogEntry()
                    {
                        Id = logid,
                        EditType = EditType.Delete,
                        UserId = this.CurrentUserId,
                        TableName = this.Name,
                        UpdateTime = DateTime.UtcNow,
                        OldBlockPosition = diskposition,
                        NewBlockPosition = diskposition,
                        KeyBytes = ObjectContainer.GuidConverter.ToByte(guidkey)
                    };

                    this.OwnerDatabase.Log.Add(log);
                }


                this.Close();

                return true;
            }
        }

        private void CheckUpdateConstraints(IDictionary<string, object> olddata, Dictionary<string, object> newdata)
        {
            AssignIncremental(olddata, newdata);

            foreach (var item in this.Indexs.Where(o => o.IsUnique && o.FieldName != Constants.DefaultIdFieldName))
            {
                if (olddata.ContainsKey(item.FieldName))
                {
                    if (newdata.ContainsKey(item.FieldName))
                    {

                        var oldkey = olddata[item.FieldName];
                        var newkey = newdata[item.FieldName];

                        if (oldkey.ToString() != newkey.ToString())
                        {
                            var newobj = item.Get(newkey);
                            if (newobj > 0)
                            {
                                throw new Exception("Uniqueness contraints validation failed. Index: " + item.FieldName);
                            }
                        }
                    }
                    else
                    {
                        throw new Exception("Value not provided for index: " + item.FieldName);
                    }
                }
            }

        }


        public bool UpdateOrAdd(object newvalue)
        {
            lock (_Locker)
            {
                var primary = this.Indexs.Find(o => o.IsPrimaryKey);
                if (primary.IsSystem)
                {
                    throw new Exception("Update requires a primary key");
                }

                var newdata = this.PrepareData(newvalue, true);

                if (newdata.ContainsKey(Constants.DefaultIdFieldName))
                {
                    var key = newdata[Constants.DefaultIdFieldName];
                    var id = _ParseKey(key);

                    var sys = this.Indexs.Find(o => o.IsSystem);

                    var blockposition = sys.Get(id);

                    if (blockposition <= 0)
                    {
                        var newid = this.Add(newvalue);
                        return newid != default(Guid);
                    }
                    else
                    {
                        var oldvalue = this._getvalue(blockposition);

                        if (IsPrimaryKeyChange(oldvalue, newdata))
                        {
                            throw new Exception("primary key can not be changed or null");
                        }

                        newdata[Dynamic.Constants.DefaultIdFieldName] = key;


                        if (oldvalue != null && newvalue is IDictionary<string, object>)
                        {
                            var newdict = newvalue as IDictionary<string, object>;

                            foreach (var item in oldvalue)
                            {
                                if (!newdict.ContainsKey(item.Key))
                                {
                                    newdata[item.Key] = item.Value;
                                }
                            }
                        }


                        CheckUpdateConstraints(oldvalue, newdata);

                        return UpdateNewData(newdata, id, blockposition, oldvalue);

                    }
                }
                else
                {
                    throw new Exception("Update requires a primary key");
                }

            }
        }


        private bool IsPrimaryKeyChange(IDictionary<string, object> old, IDictionary<string, object> newer)
        {
            var primarykey = this.Indexs.Find(o => o.IsPrimaryKey);
            if (primarykey != null && !primarykey.IsSystem)
            {
                var field = primarykey.FieldName;

                if (old.ContainsKey(field))
                {
                    if (newer.ContainsKey(field))
                    {
                        var oldkey = old[field];
                        var newkey = newer[field];
                        if (oldkey.ToString() != newkey.ToString())
                        {
                            return true;
                        }
                    }
                    return false;
                }
                else
                {
                    return false;
                }

            }

            return false;
        }

        public bool Update(Guid key, object newvalue)
        {
            lock (_Locker)
            {
                var primary = this.Indexs.Find(o => o.IsSystem);

                var blockposition = primary.Get(key);

                if (blockposition <= 0)
                {
                    return false;
                }

                var oldvalue = this._getvalue(blockposition);

                long newblock = blockposition;

                var newdata = this.PrepareData(newvalue, true);

                // verify that update does not change primary key. 
                if (IsPrimaryKeyChange(oldvalue, newdata))
                {
                    throw new Exception("Primary key can not be changed or null");
                }

                newdata[Dynamic.Constants.DefaultIdFieldName] = key;

                if (oldvalue != null && newvalue is IDictionary<string, object>)
                {
                    var newdict = newvalue as IDictionary<string, object>;

                    foreach (var item in oldvalue)
                    {
                        if (!newdict.ContainsKey(item.Key))
                        {
                            newdata[item.Key] = item.Value;
                        }
                    }
                }

                CheckUpdateConstraints(oldvalue, newdata);

                return UpdateNewData(newdata, key, blockposition, oldvalue);
            }

        }


        public bool Update(object newvalue)
        {
            lock (_Locker)
            {
                var primary = this.Indexs.Find(o => o.IsPrimaryKey);
                if (primary.IsSystem)
                {
                    throw new Exception("Update requires a primary key");
                }

                var newdata = this.PrepareData(newvalue, true);

                if (newdata.ContainsKey(Constants.DefaultIdFieldName))
                {
                    var key = newdata[Constants.DefaultIdFieldName];
                    var id = _ParseKey(key);

                    var sys = this.Indexs.Find(o => o.IsSystem);

                    var blockposition = sys.Get(id);

                    if (blockposition <= 0)
                    {
                        return false;
                    }
                    else
                    {
                        var oldvalue = this._getvalue(blockposition);

                        // verify that update does not change primary key. 
                        if (IsPrimaryKeyChange(oldvalue, newdata))
                        {
                            throw new Exception("primary key can not be changed or null");
                        }

                        newdata[Dynamic.Constants.DefaultIdFieldName] = key;

                        if (oldvalue != null && newvalue is IDictionary<string, object>)
                        {
                            var newdict = newvalue as IDictionary<string, object>;

                            foreach (var item in oldvalue)
                            {
                                if (!newdict.ContainsKey(item.Key))
                                {
                                    newdata[item.Key] = item.Value;
                                }
                            }
                        }

                        CheckUpdateConstraints(oldvalue, newdata);

                        return UpdateNewData(newdata, id, blockposition, oldvalue);
                    }
                }
                else
                {
                    throw new Exception("Update requires a primary key");
                }
            }
        }

        private bool UpdateNewData(Dictionary<string, object> newdata, Guid id, long blockposition, IDictionary<string, object> oldvalue)
        {
            bool UpdateOk = false;

            long newblock = blockposition;

            byte[] valuebyte = ObjectConverter.ToBytes(newdata);

            int tolanrance = this.BlockFile.GetTolerance(blockposition);

            if (tolanrance > valuebyte.Length)
            {
                var oldvaluebytes = this.BlockFile.Get(blockposition);

                var oldhash = Helper.KeyHelper.ComputeGuid(oldvaluebytes);
                var newhash = Helper.KeyHelper.ComputeGuid(valuebyte);

                if (oldhash == newhash)
                {
                    return false;
                }
                else
                {
                    this.BlockFile.UpdateBlock(valuebyte, blockposition);
                    UpdateOk = true;
                }
            }
            else
            {
                newblock = this.BlockFile.Add(valuebyte, valuebyte.Length);
                UpdateOk = true;
            }

            foreach (var item in this.Indexs)
            {
                if (oldvalue.ContainsKey(item.FieldName))
                {
                    var old = oldvalue[item.FieldName];
                    var newer = newdata[item.FieldName];
                    item.Update(old, newer, blockposition, newblock);
                }
                else
                {
                    var newer = newdata[item.FieldName];
                    item.Update(newer, blockposition, newblock);
                }
            }

            this.Close();

            CreateUpdateLog(newdata, id);
            return UpdateOk;
        }

        private void CreateUpdateLog(Dictionary<string, object> data, Guid key, string colname = null)
        {
            if (!this.Setting.EnableLog)
            {
                return;
            }
            var logid = this.OwnerDatabase.Log.GetNewLogId(this.OwnerDatabase.Name);

            var LogPos = this.AddLogData(logid, data);

            var log = new LogEntry()
            {
                Id = logid,
                EditType = EditType.Update,
                OldBlockPosition = LogPos,
                NewBlockPosition = LogPos,
                UserId = this.CurrentUserId,
                TableName = this.Name,
                TableColName = colname,
                UpdateTime = DateTime.UtcNow,
                KeyBytes = ObjectContainer.GuidConverter.ToByte(key)
            };

            this.OwnerDatabase.Log.Add(log);
        }

        private void AssignIncremental(IDictionary<string, object> old, IDictionary<string, object> newer)
        {
            foreach (var item in this.Setting.Columns.Where(o => o.IsIncremental))
            {
                if (old.ContainsKey(item.Name))
                {
                    newer[item.Name] = old[item.Name];
                }
                else
                {
                    var index = this.Indexs.Find(o => o.FieldName == item.Name);
                    var next = index.NextIncrement();

                    var rightvalue = Convert.ChangeType(next, item.ClrType);

                    newer[item.Name] = rightvalue;
                }
            }
        }

        public void Update(object key, object newvalue)
        {
            var tkey = _ParseKey(key);
            Update(tkey, newvalue);
        }



        public List<IDictionary<string, object>> All()
        {
            List<IDictionary<string, object>> result = new List<IDictionary<string, object>>();

            var primary = this.Indexs.Find(o => o.IsSystem);

            foreach (var item in primary.AllItems(false))
            {
                var value = _getvalue(item);
                result.Add(value);
            }
            return result;
        }

        public List<T> All<T>()
        {
            List<T> result = new List<T>();

            var primary = this.Indexs.Find(o => o.IsSystem);

            foreach (var item in primary.AllItems(false))
            {
                var value = _getvalue<T>(item);
                result.Add(value);
            }
            return result;
        }

        public bool UpdateColumn(object key, string ColumnName, object value)
        {
            if (ColumnName == null)
            {
                throw new Exception("column name is required");
            }

            var col = this.Setting.Columns.FirstOrDefault(o => o.Name == ColumnName);

            if (col == null)
            {
                throw new Exception("Column name not found or data type not match");
            }

            var coltype = Helper.TypeHelper.GetType(col.DataType);
            var colvalue = Convert.ChangeType(value, coltype);
            var fieldConverter = this.ObjectConverter.Fields.Find(o => o.FieldName == col.Name);


            if (coltype == null || fieldConverter == null)
            {
                throw new Exception(col.DataType + " data type or field converter not found");
            }

            if (col.Length == int.MaxValue)
            {
                throw new Exception("columns wiht unlimited length can not be update by this method");
            }

            var valuebytes = fieldConverter.ToBytes(colvalue);

            valuebytes = Helper.KeyHelper.AppendToKeyLength(valuebytes, coltype == typeof(string), col.Length);

            lock (_Locker)
            {
                var guidkey = _ParseKey(key);

                Int64 blockposition;

                var primary = this.Indexs.Find(o => o.IsSystem);
                blockposition = primary.Get(key);

                if (blockposition > 0)
                {
                    var ok = this.BlockFile.UpdateCol(blockposition, col.relativePosition, col.Length, valuebytes);

                    this.BlockFile.Close();

                    if (ok)
                    {

                        Dictionary<string, object> coldata = new Dictionary<string, object>();
                        coldata.Add(ColumnName, colvalue);
                        CreateUpdateLog(coldata, guidkey, ColumnName);
                    }
                    return ok;
                }
            }

            return false;
        }

        public void UpdateColumn<T>(object key, Expression<Func<T, object>> expression, object newvalue)
        {
            string fieldname = Helper.ExpressionHelper.GetFieldName<T>(expression);

            if (!string.IsNullOrEmpty(fieldname))
            {
                this.UpdateColumn(key, fieldname, newvalue);
            }
        }

        public Query Query
        {
            get
            {
                return new Query(this);
            }
        }

        public void Close()
        {
            lock (_Locker)
            {
                if (this._blockfile != null)
                {
                    this._blockfile.Close();
                }
                foreach (var item in this.Indexs)
                {
                    item.Close();
                }
            }
        }

        public void Flush()
        {
            lock (_Locker)
            {
                if (this._blockfile != null)
                {
                    this._blockfile.Flush();
                }

                foreach (var item in this.Indexs)
                {
                    item.Flush();
                }
            }
        }

        public void DelSelf()
        {
            lock (_Locker)
            {
                foreach (var item in this.Indexs)
                {
                    item.DelSelf();
                }

                if (this._blockfile != null)
                {
                    this._blockfile.Close();

                }

                if (System.IO.Directory.Exists(this.ObjectFolder))
                {
                    System.IO.Directory.Delete(this.ObjectFolder, true);
                }
            }
        }

        #region TOCHECK

        public void CreateIndex(string fieldName, bool unique = false, Setting setting = null)
        {
            if (setting == null)
            {
                setting = this.Setting;
            }
            lock (_Locker)
            {
                if (this.Indexs.Find(o => o.FieldName == fieldName) != null)
                {
                    throw new Exception("the index " + fieldName + " already exits");
                }

                if (fieldName == Constants.DefaultIdFieldName)
                {
                    throw new Exception(Constants.DefaultIdFieldName + " is reserved");
                }

                var col = setting.Columns.FirstOrDefault(o => o.Name == fieldName);

                if (col == null || col.Length == int.MaxValue)
                {
                    throw new Exception("Index fieldname must be in the column with fixed length");
                }


                string indexfile = IndexHelper.GetIndexFile(this.ObjectFolder, fieldName);

                var newindex = IndexHelper.CreateIndex(fieldName, col.ClrType, indexfile, unique, col.Length);

                if (col.IsIncremental)
                {
                    newindex.IsIncremental = true;
                    newindex.Seed = col.Seed;
                    newindex.Increment = col.Increment;
                }

                var primaryindex = this.Indexs.Find(o => o.IsSystem);

                foreach (var item in primaryindex.AllItems(true))
                {
                    object fieldvalue = null;
                    if (col.IsIncremental)
                    {
                        fieldvalue = newindex.NextIncrement();
                    }
                    else
                    {
                        var value = this._getvalue(item);
                        // need to check uniquness constraints... 
                        fieldvalue = Accessor.GetValue(value, fieldName, col.ClrType);
                    }

                    if (unique)
                    {
                        if (fieldvalue == null)
                        {
                            newindex.Close();
                            newindex.DelSelf();
                            throw new Exception("Create index failed, Value not provided for Index: " + newindex.FieldName);
                        }
                        else
                        {
                            var oldblock = newindex.Get(fieldvalue);
                            if (oldblock > 0)
                            {
                                newindex.Close();
                                newindex.DelSelf();
                                throw new Exception("Violate uniqueness constraints for Index: " + newindex.FieldName);
                            }
                        }

                    }

                    if (fieldvalue == null)
                    {
                        fieldvalue = IndexHelper.DefaultValue(col.ClrType);
                    }
                    newindex.Add(fieldvalue, item);
                }


                col.IsIndex = true;
                col.IsUnique = unique;
                this.Indexs.Add(newindex);
            }
        }

        public void CreateIndex<T>(Expression<Func<T, object>> FieldNameExpression, bool unique = false)
        {
            string fieldname = Helper.ExpressionHelper.GetFieldName<T>(FieldNameExpression);

            CreateIndex(fieldname, unique);
        }

        public void RemoveIndex<T>(Expression<Func<T, object>> FieldNameExpression)
        {
            string fieldname = Helper.ExpressionHelper.GetFieldName<T>(FieldNameExpression);

            RemoveIndex(fieldname);
        }

        public void RemoveIndex(string FieldName)
        {
            if (FieldName.ToLower() == Dynamic.Constants.DefaultIdFieldName)
            {
                return;
            }
            var index = this.Indexs.Find(o => o.FieldName == FieldName);

            if (index != null)
            {
                lock (_Locker)
                {
                    this.Indexs.Remove(index);
                    index.Close();
                    index.DelSelf();
                }
            }
        }

        /// <summary>
        /// Update the content to the record before that log. 
        /// </summary>
        /// <param name="log"></param>
        public void RollBack(LogEntry log)
        {
            //just double confirm. 
            if (log.TableName == this.Name)
            {
                Guid key = ObjectContainer.GuidConverter.FromByte(log.KeyBytes);

                if (log.EditType == EditType.Add)
                {
                    // undo of add == delete. 
                    this.Delete(key);
                }
                else if (log.EditType == EditType.Delete)
                {
                    var lastlog = this.OwnerDatabase.Log.GetPreviousTableLog(log);
                    if (lastlog == null || lastlog.EditType == EditType.Delete)
                    {
                        this.Delete(key);
                    }
                    else
                    {
                        Dictionary<string, object> item = GetLastUpdateLogItem(lastlog);

                        if (item != null)
                        {
                            if (item.ContainsKey(Constants.DefaultIdFieldName))
                            {
                                var idkey = item[Constants.DefaultIdFieldName];
                                var id = _ParseKey(idkey);

                                if (this.Get(id) != null)
                                {
                                    this.Update(id, item);
                                }
                                else
                                {
                                    this.Add(item);
                                }

                            }
                        }
                    }
                }

                else if (log.EditType == EditType.Update)
                {
                    var lastlog = this.OwnerDatabase.Log.GetPreviousTableLog(log);
                    if (lastlog != null)
                    {
                        if (lastlog.EditType == EditType.Delete)
                        {
                            this.Delete(key);
                        }
                        else if (lastlog.EditType == EditType.Add || lastlog.EditType == EditType.Update)
                        {
                            Dictionary<string, object> item = GetLastUpdateLogItem(lastlog);

                            if (item != null)
                            {

                                if (item.ContainsKey(Constants.DefaultIdFieldName))
                                {
                                    var idkey = item[Constants.DefaultIdFieldName];
                                    var id = _ParseKey(idkey);
                                    if (this.Get(id) != null)
                                    {
                                        this.Update(id, item);
                                    }
                                    else
                                    {
                                        this.Add(item);
                                    }
                                }

                            }
                        }
                    }
                }
            }
        }


        public void RollBack(List<LogEntry> loglist)
        {
            HashSet<Guid> finished = new HashSet<Guid>();

            foreach (var item in loglist.OrderBy(o => o.TimeTick))
            {
                Guid key = Kooboo.IndexedDB.ObjectContainer.GuidConverter.FromByte(item.KeyBytes);

                if (!finished.Contains(key))
                {
                    RollBack(item);
                    finished.Add(key);
                }
            }
        }

        private Dictionary<string, object> GetLastUpdateLogItem(LogEntry lastlog)
        {
            if (lastlog.EditType == EditType.Update && !string.IsNullOrWhiteSpace(lastlog.TableColName))
            {
                var previousLog = this.OwnerDatabase.Log.GetPreviousTableLog(lastlog);
                if (previousLog == null)
                {
                    return null;
                }
                else
                {
                    var item = GetLastUpdateLogItem(previousLog);
                    var ColItem = this.GetLogData(lastlog);
                    if (item != null && ColItem != null)
                    {
                        foreach (var col in ColItem)
                        {
                            item[col.Key] = col.Value;
                        }

                        return item;
                    }

                }
            }
            else
            {
                return this.GetLogData(lastlog);
            }

            return null;

        }


        public void CheckOut(Int64 VersionId, Table destinationTable, bool SelfIncluded, bool UpdateSetting = true)
        {
            if (UpdateSetting)
            {
                UpdateCheckOutTableSetting(destinationTable);
            }

            List<LogEntry> logs;
            int namehash = this.Name.GetHashCode32();
            if (SelfIncluded)
            {
                logs = this.OwnerDatabase.Log.Store.Where(o => o.Id > VersionId && o.TableNameHash == namehash).Take(99999);
            }
            else
            {
                logs = this.OwnerDatabase.Log.Store.Where(o => o.Id >= VersionId && o.TableNameHash == namehash).Take(99999);
            }

            CheckOutExcl(logs, destinationTable);
        }

        private void UpdateCheckOutTableSetting(Table desttable)
        {
            var newsetting = Dynamic.SettingHelper.Clone(this.Setting);
            desttable.UpdateSetting(newsetting);
        }

        internal void CheckOutExcl(List<LogEntry> ExclLogs, Table destTable)
        {
            var exclitems = GetExclItems(ExclLogs);

            var processed = new HashSet<Guid>();

            var all = this.All();

            foreach (var item in all)
            {
                Guid dataid = default(Guid);
                if (item.ContainsKey("_id"))
                {
                    var objid = item["_id"];
                    Guid.TryParse(objid.ToString(), out dataid);
                }

                if (dataid == default(Guid))
                {
                    continue;
                }

                if (!exclitems.ContainsKey(dataid))
                {
                    destTable.Add(item);
                }
                else
                {
                    var exclitem = exclitems[dataid];

                    if (exclitem.EditType == EditType.Update || exclitem.EditType == EditType.Delete)
                    {
                        var lastlog = this.OwnerDatabase.Log.GetPreviousTableLog(exclitem);

                        var value = this.GetLogData(lastlog);

                        var old = this.Get(dataid);
                        if (old == null)
                        {
                            destTable.Add(value);
                        }
                        else
                        {
                            destTable.Update(dataid, value);
                        }
                    }
                    processed.Add(dataid);
                }
            }



            foreach (var item in exclitems)
            {
                if (!processed.Contains(item.Key))
                {
                    var logitem = item.Value;

                    if (logitem.EditType == EditType.Update || logitem.EditType == EditType.Delete)
                    {
                        var lastlog = this.OwnerDatabase.Log.GetPreviousTableLog(logitem);

                        if (lastlog != null)
                        {
                            var value = this.GetLogData(lastlog);
                            if (value != null)
                            {
                                destTable.Update(value);
                            }
                        }
                    }
                }

            }
        }

        private Dictionary<Guid, LogEntry> GetExclItems(List<LogEntry> logs)
        {
            Dictionary<Guid, LogEntry> result = new Dictionary<Guid, LogEntry>();

            foreach (var item in logs.OrderBy(o => o.TimeTick))
            {
                var key = ObjectContainer.GuidConverter.FromByte(item.KeyBytes);

                if (!result.ContainsKey(key))
                {
                    result[key] = item;
                }
            }
            return result;
        }

    }

    #endregion
}


---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace Kooboo.IndexedDB.Dynamic
{
    public class Table
    {
        public Setting Setting { get; set; }

        public Guid CurrentUserId { get; set; }

        internal object _Locker = new object();

        public Converter.ObjectConverter ObjectConverter { get; set; }

        private BlockFile _blockfile;
        private object _lockerBlockFile = new object();
        public BlockFile BlockFile
        {
            get
            {
                if (_blockfile == null)
                {
                    lock (_lockerBlockFile)
                    {
                        if (_blockfile == null)
                        {
                            string blockfileName = System.IO.Path.Combine(this.ObjectFolder, "table.block");
                            _blockfile = new BlockFile(blockfileName);
                            _blockfile.OpenOrCreate();
                        }
                    }
                }
                return _blockfile;
            }
        }

        internal Btree.BtreeIndex<Guid> PrimaryBtree
        {
            get
            {
                var find = this.Indexs.Find(o => o.FieldName == Dynamic.Constants.DefaultIdFieldName);
                var right = find as TableIndexBase<Guid>;
                return right.index;
            }
        }

        public long length
        {
            get
            {
                return this.PrimaryBtree.Count(false);
            }
        }

        public long count
        {
            get
            {
                return this.length;
            }
        }

        public List<Guid> Keys
        {
            get
            {
                List<Guid> result = new List<Guid>();
                var keyconverter = ObjectContainer.GetConverter<Guid>();

                foreach (var item in this.PrimaryBtree.AllKeyBytesCollection(true))
                {
                    var key = keyconverter.FromByte(item);
                    result.Add(key);
                }
                return result;
            }
        }

        public List<ITableIndex> Indexs { get; set; }

        public string ObjectFolder { get; set; }

        internal string SettingFile { get; set; }

        /// <summary>
        /// The name of this object store.
        /// </summary>
        public string Name { get; set; }

        public Database OwnerDatabase { get; set; }

        public Guid FirstKey
        {
            get
            {
                return this.PrimaryBtree.FirstKey;
            }
        }

        public Guid LastKey
        {
            get
            {
                return this.PrimaryBtree.LastKey;
            }
        }

        private string PrimaryKey { get; set; }

        public Table(string name, Database ownerdatabase, Setting setting)
        {
            this.Name = name;
            this.ObjectFolder = ownerdatabase.TableFolder(name);
            this.SettingFile = ownerdatabase.TableSetitingFile(name);

            setting = SettingHelper.GetOrSetTableSetting(this.SettingFile, setting);

            this.OwnerDatabase = ownerdatabase;
            Init(setting);
        }
        public Table(string name, Database ownerdatabase)
        {
            Setting setting = null;
            this.Name = name;
            this.ObjectFolder = ownerdatabase.TableFolder(name);
            this.SettingFile = ownerdatabase.TableSetitingFile(name);

            setting = SettingHelper.GetOrSetTableSetting(this.SettingFile, setting);

            this.OwnerDatabase = ownerdatabase;
            Init(setting);
        }

        private void Init(Setting setting)
        {
            this.Indexs = IndexHelper.CreatIndexs(setting, this.ObjectFolder);
            this.Setting = setting;
            var primary = this.Indexs.Find(o => o.IsPrimaryKey);
            this.PrimaryKey = primary.FieldName;

            SettingHelper.EnsureColumnRelativePosition(this.Setting.Columns);

            ObjectConverter = new Dynamic.Converter.ObjectConverter(this.Setting.Columns.ToList(), this.PrimaryKey);
        }


        private long _addBlock(Dictionary<string, object> data)
        {
            lock (_lockerBlockFile)
            {
                byte[] valuebyte = ObjectConverter.ToBytes(data);
                return this.BlockFile.Add(valuebyte, valuebyte.Length);
            }
        }

        public void RebuildTable(Setting newSetting)
        {
            var isenable = newSetting.EnableLog;

            string newname = "_koobootemp_" + System.Guid.NewGuid().ToString() + this.Name;
            var newtable = this.OwnerDatabase.GetOrCreateTable(newname, newSetting);

            newtable.Setting.EnableLog = false;

            var primaryindex = this.Indexs.Find(o => o.IsSystem);

            string errormsg = null;

            try
            {
                foreach (var item in primaryindex.AllItems(true))
                {
                    var value = this._getvalue(item);
                    newtable.Add(value);
                }
            }
            catch (Exception ex)
            {
                errormsg = ex.Message;
            }

            if (errormsg != null)
            {
                this.OwnerDatabase.DeleteTable(newtable.Name);
                throw new Exception(errormsg);
            }

            string oldfolder = this.ObjectFolder;
            string newfolder = newtable.ObjectFolder;

            this.Close();
            newtable.Close();
            this.DelSelf();
            this._blockfile = null;
            System.IO.Directory.Move(newfolder, oldfolder);


            newtable.Setting.EnableLog = isenable;

            SettingHelper.WriteSetting(this.SettingFile, newSetting);
            Init(newSetting);

            if (System.IO.Directory.Exists(newfolder))
            {
                System.IO.Directory.Delete(newfolder, true);
            }

            this.OwnerDatabase.openTableList.Remove(newname);
        }

        public void UpdateSetting(Setting newsetting)
        {
            ensureincremental(newsetting);

            var check = SettingHelper.UpdateSetting(newsetting.Columns.ToList(), this.Setting);

            lock (_Locker)
            {
                if (check.ShouldRebuild)
                {
                    RebuildTable(check.NewSetting);
                }
                else if (check.HasChange)
                {
                    // reinit index... and try to find remove or create index. 

                    var newindexs = IndexHelper.CreatIndexs(check.NewSetting, this.ObjectFolder);

                    foreach (var item in newindexs)
                    {
                        item.Close();
                    }

                    List<string> toremove = new List<string>();

                    foreach (var item in this.Indexs)
                    {
                        var newer = newindexs.Find(o => o.FieldName == item.FieldName);
                        if (newer == null)
                        {
                            toremove.Add(item.FieldName);
                        }
                    }

                    Dictionary<string, bool> indexToRebuild = new Dictionary<string, bool>();

                    foreach (var item in newindexs)
                    {
                        var older = this.Indexs.Find(o => o.FieldName == item.FieldName);
                        if (older == null)
                        {
                            indexToRebuild.Add(item.FieldName, item.IsUnique);
                        }
                    }

                    foreach (var item in indexToRebuild)
                    {
                        this.CreateIndex(item.Key, item.Value, check.NewSetting);
                    }

                    foreach (var item in toremove)
                    {
                        this.RemoveIndex(item);
                    }

                    this.Setting = check.NewSetting;

                    SettingHelper.WriteSetting(this.SettingFile, this.Setting);

                    var primary = newindexs.Find(o => o.IsPrimaryKey);

                    this.ObjectConverter = new Dynamic.Converter.ObjectConverter(this.Setting.Columns.ToList(), primary.FieldName);

                    this.PrimaryKey = primary.FieldName;

                    foreach (var item in this.Indexs)
                    {
                        item.Close();
                    }

                    this.Indexs = newindexs;

                    foreach (var item in this.Indexs)
                    {
                        item.Close();
                    }

                }

                this.Close();
            }
        }

        private void ensureincremental(Setting newsetting)
        {
            if (newsetting?.Columns != null)
            {
                foreach (var item in newsetting.Columns)
                {
                    if (item.IsIncremental)
                    {
                        item.IsUnique = true;
                        item.IsIndex = true;
                        if (item.Seed < 0)
                        {
                            item.Seed = 0;
                        }
                        if (item.Increment < 1)
                        {
                            item.Increment = 1;
                        }
                    }
                }
            }
        }

        public Dictionary<string, object> PrepareData(object dataobj, bool Update = false)
        {
            // prepare key...
            Dictionary<string, object> data = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);

            IDictionary<string, object> dynamicobj = null;
            Type objecttype = null;

            if (idict == null)
            {
                dynamicobj = dataobj as IDictionary<string, object>;
            }

            if (idict == null && dynamicobj == null)
            {
                objecttype = dataobj.GetType();
            }

            Guid DefaultId = default(Guid);
            var DefaultIdObj = _GetObjValue(idict, dynamicobj, Dynamic.Constants.DefaultIdFieldName, typeof(Guid), dataobj, objecttype);
            if (DefaultIdObj != null)
            {
                System.Guid.TryParse(DefaultIdObj.ToString(), out DefaultId);
            }

            foreach (var item in this.Setting.Columns)
            {
                if (item.IsSystem)
                {
                    // the only system field is the id fields. 
                    object Value = null;

                    if (this.PrimaryKey != Dynamic.Constants.DefaultIdFieldName)
                    { 
                        if (dataobj is System.Collections.IDictionary idict)
                        {
                            Value = Accessor.GetValueIDict(idict, this.PrimaryKey, item.ClrType);

                        }
                        else if (dynamicobj != null)
                        {
                            Value = Accessor.GetValue(dynamicobj, this.PrimaryKey, item.ClrType);
                        }
                        else
                        {
                            Value = Accessor.GetValue(dataobj, objecttype, this.PrimaryKey, item.ClrType);
                        }

                        if (Value == null)
                        {
                            var col = this.Setting.Columns.First(o => o.Name == this.PrimaryKey);
                            if (col != null)
                            {
                                if (col.ClrType == typeof(string))
                                {
                                    Value = default(Guid);
                                }
                                else
                                { 
                                    Value = IndexHelper.DefaultValue(col.ClrType);
                                }
                            }
                        }

                        if (Update == false && Value !=null )
                        {
                            DefaultId = _ParseKey(Value);
                        } 
                    }

                    if (Value == null)
                    {
                        if (dataobj is System.Collections.IDictionary idict)
                        {
                            Value = Accessor.GetValueIDict(idict, item.Name, item.ClrType);
                        }
                        else if (dynamicobj != null)
                        {
                            Value = Accessor.GetValue(dynamicobj, item.Name, item.ClrType);
                        }
                        else
                        {
                            Value = Accessor.GetValue(dataobj, objecttype, item.Name, item.ClrType);
                        }
                    }

                    if (Value == null)
                    {
                        // the only possible null value value for key is string.   
                        Value = Helper.IndexHelper.NewTimeGuid();
                    }
                    else
                    {
                        Value = _ParseKey(Value);
                    }
                    if (!data.ContainsKey(item.Name))
                    {
                        data.Add(item.Name, Value);
                    }
                }

                else
                {
                    object Value = null;

                    if (dataobj is System.Collections.IDictionary idict)
                    {
                        Value = Accessor.GetValueIDict(idict, item.Name, item.ClrType);

                    }
                    else if (dynamicobj != null)
                    {
                        Value = Accessor.GetValue(dynamicobj, item.Name, item.ClrType);
                    }
                    else
                    {
                        Value = Accessor.GetValue(dataobj, objecttype, item.Name, item.ClrType);
                    }

                    if (item.IsIncremental && !Update)
                    {
                        if (Value == null || Accessor.ChangeType<long>(Value) == 0)
                        {
                            var index = this.Indexs.Find(o => o.FieldName == item.Name);
                            Value = index.NextIncrement();
                        }

                        if (item.IsPrimaryKey && Value != null)
                        {
                            var keyvalue = _ParseKey(Value);
                            data[Dynamic.Constants.DefaultIdFieldName] = keyvalue;
                        }
                    }

                    if (Value == null)
                    {
                        if (item.IsIncremental)
                        {
                            var index = this.Indexs.Find(o => o.FieldName == item.Name);
                            Value = index.NextIncrement();
                        }
                        else if (item.IsIndex || item.IsPrimaryKey)
                        {
                            Value = IndexHelper.DefaultValue(item.ClrType);
                        }
                    }

                    if (Value == null && (item.IsIndex || item.IsPrimaryKey))
                    {
                        Value = IndexHelper.DefaultValue(item.ClrType);
                    } 
                    // var rightvalue = Accessor.ChangeType(Value, item.ClrType);  
                    data.Add(item.Name, Value);
                }
            }


            if (DefaultId != default(Guid))
            {
                data[Dynamic.Constants.DefaultIdFieldName] = DefaultId;
            }

            return data;
        }


        private object _GetObjValue(System.Collections.IDictionary idict, IDictionary<string, object> dynamicobj, string key, Type clrType, object dataobj, Type objecttype)
        {
            if (idict != null)
            {
                return Accessor.GetValueIDict(idict, key, clrType);

            }
            else if (dynamicobj != null)
            {
                return Accessor.GetValue(dynamicobj, key, clrType);
            }
            else
            {
                return Accessor.GetValue(dataobj, objecttype, key, clrType);
            }
        }

        private void CheckAddConstraints(Dictionary<string, object> data)
        {
            foreach (var item in this.Indexs.Where(o => o.IsUnique))
            {
                if (data.ContainsKey(item.FieldName))
                {
                    var value = data[item.FieldName];

                    if (value == null)
                    {
                        value = IndexHelper.DefaultValue(item.keyType);

                        // throw new Exception("Value not provided for Index: " + item.FieldName);
                    }

                    //    if (IndexHelper.IsDefaultValue(value, item.keyType))
                    //   {
                    //  throw new Exception("Value not provided for Index: " + item.FieldName);
                    // TODO: think of whether this is needed or not. 
                    //  }

                    var block = item.Get(value);
                    if (block > 0)
                    {
                        throw new Exception("Uniqueness contraints validation failed. Index: " + item.FieldName);
                    }
                }
                else
                {
                    throw new Exception("Value not provided for index: " + item.FieldName);
                }
            }
        }

        public Guid Add(object Value, bool CheckCol = false, Action<long> CallBackPos = null)
        {
            lock (_Locker)
            {
                if (CheckCol)
                {
                    var check = SettingHelper.CompareSetting(Value, this.Setting);

                    if (check.ShouldRebuild)
                    {
                        RebuildTable(check.NewSetting);
                        return Add(Value);
                    }

                    else if (check.HasChange)
                    {
                        this.Setting = check.NewSetting;
                        SettingHelper.WriteSetting(this.SettingFile, this.Setting);
                        var primary = this.Indexs.Find(o => o.IsPrimaryKey);
                        this.ObjectConverter = new Dynamic.Converter.ObjectConverter(this.Setting.Columns.ToList(), primary.FieldName);
                    }
                }

                var data = this.PrepareData(Value);

                CheckAddConstraints(data);

                Int64 contentposition = _addBlock(data);

                if (CallBackPos != null)
                {
                    CallBackPos(contentposition);
                }


                foreach (var item in this.Indexs)
                {
                    object key = null;

                    if (data.ContainsKey(item.FieldName))
                    {
                        key = data[item.FieldName];
                    }
                    else
                    {
                        // should not be, because there is a constraints checking. 
                        throw new Exception("data not provided for index: " + item.FieldName);
                    }

                    item.Add(key, contentposition);
                }

                this.Close();

                Guid ReturnId = default(Guid);

                if (data.ContainsKey(Constants.DefaultIdFieldName))
                {
                    ReturnId = (Guid)data[Constants.DefaultIdFieldName];

                    if (this.Setting.EnableLog)
                    {
                        var logid = this.OwnerDatabase.Log.GetNewLogId(this.OwnerDatabase.Name);

                        var logpos = AddLogData(logid, data);

                        var log = new LogEntry()
                        {
                            Id = logid,
                            EditType = EditType.Add,
                            OldBlockPosition = logpos,
                            NewBlockPosition = logpos,
                            UserId = this.CurrentUserId,
                            TableName = this.Name,
                            UpdateTime = DateTime.UtcNow,
                            KeyBytes = ObjectContainer.GuidConverter.ToByte(ReturnId)
                        };

                        this.OwnerDatabase.Log.Add(log);
                    }
                }

                return ReturnId;
            }
        }

        public long AddLogData(long LogId, Dictionary<string, object> data)
        {
            byte[] valuebyte = Kooboo.IndexedDB.Serializer.Simple.TableDataLogConverter.Instance.ToBytes(data);
            int len = valuebyte.Length;

            var logidbytes = BitConverter.GetBytes(LogId);

            byte[] totalbytes = new byte[len + 8];
            System.Buffer.BlockCopy(logidbytes, 0, totalbytes, 0, 8);
            System.Buffer.BlockCopy(valuebyte, 0, totalbytes, 8, len);

            var LogPos = this.OwnerDatabase.TableLog.Add(totalbytes, totalbytes.Length);
            this.OwnerDatabase.TableLog.Close(); // relese to enable delete. 

            return LogPos;
        }

        public Dictionary<string, object> GetLogData(LogEntry log)
        {
            return GetLogData(log.Id, log.NewBlockPosition);
        }

        public Dictionary<string, object> GetLogData(long LogId, long DiskPosition)
        {
            var databytes = this.OwnerDatabase.TableLog.Get(DiskPosition);

            if (databytes != null)
            {
                var dbLogId = BitConverter.ToInt64(databytes, 0);
                if (dbLogId == LogId)
                {
                    var valuebytes = new byte[databytes.Length - 8];
                    System.Buffer.BlockCopy(databytes, 8, valuebytes, 0, databytes.Length - 8);

                    return Kooboo.IndexedDB.Serializer.Simple.TableDataLogConverter.Instance.FromBytes(valuebytes);
                }
            }

            return null;
        }

        internal Guid _ParseKey(object key)
        {
            if (key == null)
            {
                return default(Guid);
            }

            if (key is System.Guid)
            {
                return (Guid)key;
            }
            string strkey = key.ToString();
            Guid guidkey;
            if (System.Guid.TryParse(strkey, out guidkey))
            {
                return guidkey;
            }
            else
            {
                return Helper.KeyHelper.ComputeGuid(strkey);
            }
        }

        public IDictionary<string, object> Get(Guid key)
        {
            Int64 blockposition;

            var primary = this.Indexs.Find(o => o.IsSystem);
            blockposition = primary.Get(key);

            if (blockposition > 0)
            {
                return _getvalue(blockposition);
            }
            return null;
        }

        public long GetDiskPos(object key)
        {
            var guidkey = _ParseKey(key);
            return GetDiskPos(guidkey);
        }

        public long GetDiskPos(Guid key)
        {
            var primary = this.Indexs.Find(o => o.IsSystem);
            return primary.Get(key);
        }

        public IDictionary<string, object> GetValue(long diskposition)
        {
            return _getvalue(diskposition);
        }

        public IDictionary<string, object> Get(object key)
        {
            var guidkey = _ParseKey(key);
            return Get(guidkey);
        }


        public T Get<T>(object key)
        {
            var guidkey = _ParseKey(key);

            Int64 blockposition;

            var primary = this.Indexs.Find(o => o.IsSystem);
            blockposition = primary.Get(guidkey);

            if (blockposition > 0)
            {
                return _getvalue<T>(blockposition);
            }
            return default(T);
        }

        internal IDictionary<string, object> _getvalue(Int64 blockposition)
        {
            lock (_Locker)
            {
                byte[] contentbytes = this.BlockFile.Get(blockposition);
                if (contentbytes != null)
                {
                    return this.ObjectConverter.FromBytes(contentbytes);
                }
                return null;
            }
        }

        internal T _getvalue<T>(Int64 blockposition)
        {
            lock (_Locker)
            {
                byte[] contentbytes = this.BlockFile.Get(blockposition);
                if (contentbytes != null)
                {
                    return this.ObjectConverter.FromBytes<T>(contentbytes);
                }
                return default(T);
            }
        }

        public bool Delete(object key)
        {
            var guidkey = _ParseKey(key);

            lock (_Locker)
            {
                var primary = this.Indexs.Find(o => o.IsSystem);
                List<Int64> blocklist = primary.Del(guidkey);

                if (blocklist.Count == 0)
                {
                    // key not found, not delete. 
                    return false;
                }

                var blockposition = blocklist[0];
                var value = this._getvalue(blockposition);

                if (value == null)
                {
                    return false;
                }

                var data = this.PrepareData(value, true);

                foreach (var item in this.Indexs)
                {
                    if (item.FieldName != primary.FieldName)
                    {
                        if (data.ContainsKey(item.FieldName))
                        {
                            var keyvalue = data[item.FieldName];
                            item.Del(keyvalue, blockposition);
                        }
                    }
                }



                if (this.Setting.EnableLog)
                {
                    var logid = this.OwnerDatabase.Log.GetNewLogId(this.OwnerDatabase.Name);

                    var diskposition = this.AddLogData(logid, data);

                    var log = new LogEntry()
                    {
                        Id = logid,
                        EditType = EditType.Delete,
                        UserId = this.CurrentUserId,
                        TableName = this.Name,
                        UpdateTime = DateTime.UtcNow,
                        OldBlockPosition = diskposition,
                        NewBlockPosition = diskposition,
                        KeyBytes = ObjectContainer.GuidConverter.ToByte(guidkey)
                    };

                    this.OwnerDatabase.Log.Add(log);
                }


                this.Close();

                return true;
            }
        }

        private void CheckUpdateConstraints(IDictionary<string, object> olddata, Dictionary<string, object> newdata)
        {
            AssignIncremental(olddata, newdata);

            foreach (var item in this.Indexs.Where(o => o.IsUnique && o.FieldName != Constants.DefaultIdFieldName))
            {
                if (olddata.ContainsKey(item.FieldName))
                {
                    if (newdata.ContainsKey(item.FieldName))
                    {

                        var oldkey = olddata[item.FieldName];
                        var newkey = newdata[item.FieldName];

                        if (oldkey.ToString() != newkey.ToString())
                        {
                            var newobj = item.Get(newkey);
                            if (newobj > 0)
                            {
                                throw new Exception("Uniqueness contraints validation failed. Index: " + item.FieldName);
                            }
                        }
                    }
                    else
                    {
                        throw new Exception("Value not provided for index: " + item.FieldName);
                    }
                }
            }

        }


        public bool UpdateOrAdd(object newvalue)
        {
            lock (_Locker)
            {
                var primary = this.Indexs.Find(o => o.IsPrimaryKey);
                if (primary.IsSystem)
                {
                    throw new Exception("Update requires a primary key");
                }

                var newdata = this.PrepareData(newvalue, true);

                if (newdata.ContainsKey(Constants.DefaultIdFieldName))
                {
                    var key = newdata[Constants.DefaultIdFieldName];
                    var id = _ParseKey(key);

                    var sys = this.Indexs.Find(o => o.IsSystem);

                    var blockposition = sys.Get(id);

                    if (blockposition <= 0)
                    {
                        var newid = this.Add(newvalue);
                        return newid != default(Guid);
                    }
                    else
                    {
                        var oldvalue = this._getvalue(blockposition);

                        if (IsPrimaryKeyChange(oldvalue, newdata))
                        {
                            throw new Exception("primary key can not be changed or null");
                        }

                        newdata[Dynamic.Constants.DefaultIdFieldName] = key;


                        if (oldvalue != null && newvalue is IDictionary<string, object>)
                        {
                            var newdict = newvalue as IDictionary<string, object>;

                            foreach (var item in oldvalue)
                            {
                                if (!newdict.ContainsKey(item.Key))
                                {
                                    newdata[item.Key] = item.Value;
                                }
                            }
                        }


                        CheckUpdateConstraints(oldvalue, newdata);

                        return UpdateNewData(newdata, id, blockposition, oldvalue);

                    }
                }
                else
                {
                    throw new Exception("Update requires a primary key");
                }

            }
        }


        private bool IsPrimaryKeyChange(IDictionary<string, object> old, IDictionary<string, object> newer)
        {
            var primarykey = this.Indexs.Find(o => o.IsPrimaryKey);
            if (primarykey != null && !primarykey.IsSystem)
            {
                var field = primarykey.FieldName;

                if (old.ContainsKey(field))
                {
                    if (newer.ContainsKey(field))
                    {
                        var oldkey = old[field];
                        var newkey = newer[field];
                        if (oldkey.ToString() != newkey.ToString())
                        {
                            return true;
                        }
                    }
                    return false;
                }
                else
                {
                    return false;
                }

            }

            return false;
        }

        public bool Update(Guid key, object newvalue)
        {
            lock (_Locker)
            {
                var primary = this.Indexs.Find(o => o.IsSystem);

                var blockposition = primary.Get(key);

                if (blockposition <= 0)
                {
                    return false;
                }

                var oldvalue = this._getvalue(blockposition);

                long newblock = blockposition;

                var newdata = this.PrepareData(newvalue, true);

                // verify that update does not change primary key. 
                if (IsPrimaryKeyChange(oldvalue, newdata))
                {
                    throw new Exception("Primary key can not be changed or null");
                }

                newdata[Dynamic.Constants.DefaultIdFieldName] = key;

                if (oldvalue != null && newvalue is IDictionary<string, object>)
                {
                    var newdict = newvalue as IDictionary<string, object>;

                    foreach (var item in oldvalue)
                    {
                        if (!newdict.ContainsKey(item.Key))
                        {
                            newdata[item.Key] = item.Value;
                        }
                    }
                }

                CheckUpdateConstraints(oldvalue, newdata);

                return UpdateNewData(newdata, key, blockposition, oldvalue);
            }

        }


        public bool Update(object newvalue)
        {
            lock (_Locker)
            {
                var primary = this.Indexs.Find(o => o.IsPrimaryKey);
                if (primary.IsSystem)
                {
                    throw new Exception("Update requires a primary key");
                }

                var newdata = this.PrepareData(newvalue, true);

                if (newdata.ContainsKey(Constants.DefaultIdFieldName))
                {
                    var key = newdata[Constants.DefaultIdFieldName];
                    var id = _ParseKey(key);

                    var sys = this.Indexs.Find(o => o.IsSystem);

                    var blockposition = sys.Get(id);

                    if (blockposition <= 0)
                    {
                        return false;
                    }
                    else
                    {
                        var oldvalue = this._getvalue(blockposition);

                        // verify that update does not change primary key. 
                        if (IsPrimaryKeyChange(oldvalue, newdata))
                        {
                            throw new Exception("primary key can not be changed or null");
                        }

                        newdata[Dynamic.Constants.DefaultIdFieldName] = key;

                        if (oldvalue != null && newvalue is IDictionary<string, object>)
                        {
                            var newdict = newvalue as IDictionary<string, object>;

                            foreach (var item in oldvalue)
                            {
                                if (!newdict.ContainsKey(item.Key))
                                {
                                    newdata[item.Key] = item.Value;
                                }
                            }
                        }

                        CheckUpdateConstraints(oldvalue, newdata);

                        return UpdateNewData(newdata, id, blockposition, oldvalue);
                    }
                }
                else
                {
                    throw new Exception("Update requires a primary key");
                }
            }
        }

        private bool UpdateNewData(Dictionary<string, object> newdata, Guid id, long blockposition, IDictionary<string, object> oldvalue)
        {
            bool UpdateOk = false;

            long newblock = blockposition;

            byte[] valuebyte = ObjectConverter.ToBytes(newdata);

            int tolanrance = this.BlockFile.GetTolerance(blockposition);

            if (tolanrance > valuebyte.Length)
            {
                var oldvaluebytes = this.BlockFile.Get(blockposition);

                var oldhash = Helper.KeyHelper.ComputeGuid(oldvaluebytes);
                var newhash = Helper.KeyHelper.ComputeGuid(valuebyte);

                if (oldhash == newhash)
                {
                    return false;
                }
                else
                {
                    this.BlockFile.UpdateBlock(valuebyte, blockposition);
                    UpdateOk = true;
                }
            }
            else
            {
                newblock = this.BlockFile.Add(valuebyte, valuebyte.Length);
                UpdateOk = true;
            }

            foreach (var item in this.Indexs)
            {
                if (oldvalue.ContainsKey(item.FieldName))
                {
                    var old = oldvalue[item.FieldName];
                    var newer = newdata[item.FieldName];
                    item.Update(old, newer, blockposition, newblock);
                }
                else
                {
                    var newer = newdata[item.FieldName];
                    item.Update(newer, blockposition, newblock);
                }
            }

            this.Close();

            CreateUpdateLog(newdata, id);
            return UpdateOk;
        }

        private void CreateUpdateLog(Dictionary<string, object> data, Guid key, string colname = null)
        {
            if (!this.Setting.EnableLog)
            {
                return;
            }
            var logid = this.OwnerDatabase.Log.GetNewLogId(this.OwnerDatabase.Name);

            var LogPos = this.AddLogData(logid, data);

            var log = new LogEntry()
            {
                Id = logid,
                EditType = EditType.Update,
                OldBlockPosition = LogPos,
                NewBlockPosition = LogPos,
                UserId = this.CurrentUserId,
                TableName = this.Name,
                TableColName = colname,
                UpdateTime = DateTime.UtcNow,
                KeyBytes = ObjectContainer.GuidConverter.ToByte(key)
            };

            this.OwnerDatabase.Log.Add(log);
        }

        private void AssignIncremental(IDictionary<string, object> old, IDictionary<string, object> newer)
        {
            foreach (var item in this.Setting.Columns.Where(o => o.IsIncremental))
            {
                if (old.ContainsKey(item.Name))
                {
                    newer[item.Name] = old[item.Name];
                }
                else
                {
                    var index = this.Indexs.Find(o => o.FieldName == item.Name);
                    var next = index.NextIncrement();

                    var rightvalue = Convert.ChangeType(next, item.ClrType);

                    newer[item.Name] = rightvalue;
                }
            }
        }

        public void Update(object key, object newvalue)
        {
            var tkey = _ParseKey(key);
            Update(tkey, newvalue);
        }



        public List<IDictionary<string, object>> All()
        {
            List<IDictionary<string, object>> result = new List<IDictionary<string, object>>();

            var primary = this.Indexs.Find(o => o.IsSystem);

            foreach (var item in primary.AllItems(false))
            {
                var value = _getvalue(item);
                result.Add(value);
            }
            return result;
        }

        public List<T> All<T>()
        {
            List<T> result = new List<T>();

            var primary = this.Indexs.Find(o => o.IsSystem);

            foreach (var item in primary.AllItems(false))
            {
                var value = _getvalue<T>(item);
                result.Add(value);
            }
            return result;
        }

        public bool UpdateColumn(object key, string ColumnName, object value)
        {
            if (ColumnName == null)
            {
                throw new Exception("column name is required");
            }

            var col = this.Setting.Columns.FirstOrDefault(o => o.Name == ColumnName);

            if (col == null)
            {
                throw new Exception("Column name not found or data type not match");
            }

            var coltype = Helper.TypeHelper.GetType(col.DataType);
            var colvalue = Convert.ChangeType(value, coltype);
            var fieldConverter = this.ObjectConverter.Fields.Find(o => o.FieldName == col.Name);


            if (coltype == null || fieldConverter == null)
            {
                throw new Exception(col.DataType + " data type or field converter not found");
            }

            if (col.Length == int.MaxValue)
            {
                throw new Exception("columns wiht unlimited length can not be update by this method");
            }

            var valuebytes = fieldConverter.ToBytes(colvalue);

            valuebytes = Helper.KeyHelper.AppendToKeyLength(valuebytes, coltype == typeof(string), col.Length);

            lock (_Locker)
            {
                var guidkey = _ParseKey(key);

                Int64 blockposition;

                var primary = this.Indexs.Find(o => o.IsSystem);
                blockposition = primary.Get(key);

                if (blockposition > 0)
                {
                    var ok = this.BlockFile.UpdateCol(blockposition, col.relativePosition, col.Length, valuebytes);

                    this.BlockFile.Close();

                    if (ok)
                    {

                        Dictionary<string, object> coldata = new Dictionary<string, object>();
                        coldata.Add(ColumnName, colvalue);
                        CreateUpdateLog(coldata, guidkey, ColumnName);
                    }
                    return ok;
                }
            }

            return false;
        }

        public void UpdateColumn<T>(object key, Expression<Func<T, object>> expression, object newvalue)
        {
            string fieldname = Helper.ExpressionHelper.GetFieldName<T>(expression);

            if (!string.IsNullOrEmpty(fieldname))
            {
                this.UpdateColumn(key, fieldname, newvalue);
            }
        }

        public Query Query
        {
            get
            {
                return new Query(this);
            }
        }

        public void Close()
        {
            lock (_Locker)
            {
                if (this._blockfile != null)
                {
                    this._blockfile.Close();
                }
                foreach (var item in this.Indexs)
                {
                    item.Close();
                }
            }
        }

        public void Flush()
        {
            lock (_Locker)
            {
                if (this._blockfile != null)
                {
                    this._blockfile.Flush();
                }

                foreach (var item in this.Indexs)
                {
                    item.Flush();
                }
            }
        }

        public void DelSelf()
        {
            lock (_Locker)
            {
                foreach (var item in this.Indexs)
                {
                    item.DelSelf();
                }

                if (this._blockfile != null)
                {
                    this._blockfile.Close();

                }

                if (System.IO.Directory.Exists(this.ObjectFolder))
                {
                    System.IO.Directory.Delete(this.ObjectFolder, true);
                }
            }
        }

        #region TOCHECK

        public void CreateIndex(string fieldName, bool unique = false, Setting setting = null)
        {
            if (setting == null)
            {
                setting = this.Setting;
            }
            lock (_Locker)
            {
                if (this.Indexs.Find(o => o.FieldName == fieldName) != null)
                {
                    throw new Exception("the index " + fieldName + " already exits");
                }

                if (fieldName == Constants.DefaultIdFieldName)
                {
                    throw new Exception(Constants.DefaultIdFieldName + " is reserved");
                }

                var col = setting.Columns.FirstOrDefault(o => o.Name == fieldName);

                if (col == null || col.Length == int.MaxValue)
                {
                    throw new Exception("Index fieldname must be in the column with fixed length");
                }


                string indexfile = IndexHelper.GetIndexFile(this.ObjectFolder, fieldName);

                var newindex = IndexHelper.CreateIndex(fieldName, col.ClrType, indexfile, unique, col.Length);

                if (col.IsIncremental)
                {
                    newindex.IsIncremental = true;
                    newindex.Seed = col.Seed;
                    newindex.Increment = col.Increment;
                }

                var primaryindex = this.Indexs.Find(o => o.IsSystem);

                foreach (var item in primaryindex.AllItems(true))
                {
                    object fieldvalue = null;
                    if (col.IsIncremental)
                    {
                        fieldvalue = newindex.NextIncrement();
                    }
                    else
                    {
                        var value = this._getvalue(item);
                        // need to check uniquness constraints... 
                        fieldvalue = Accessor.GetValue(value, fieldName, col.ClrType);
                    }

                    if (unique)
                    {
                        if (fieldvalue == null)
                        {
                            newindex.Close();
                            newindex.DelSelf();
                            throw new Exception("Create index failed, Value not provided for Index: " + newindex.FieldName);
                        }
                        else
                        {
                            var oldblock = newindex.Get(fieldvalue);
                            if (oldblock > 0)
                            {
                                newindex.Close();
                                newindex.DelSelf();
                                throw new Exception("Violate uniqueness constraints for Index: " + newindex.FieldName);
                            }
                        }

                    }

                    if (fieldvalue == null)
                    {
                        fieldvalue = IndexHelper.DefaultValue(col.ClrType);
                    }
                    newindex.Add(fieldvalue, item);
                }


                col.IsIndex = true;
                col.IsUnique = unique;
                this.Indexs.Add(newindex);
            }
        }

        public void CreateIndex<T>(Expression<Func<T, object>> FieldNameExpression, bool unique = false)
        {
            string fieldname = Helper.ExpressionHelper.GetFieldName<T>(FieldNameExpression);

            CreateIndex(fieldname, unique);
        }

        public void RemoveIndex<T>(Expression<Func<T, object>> FieldNameExpression)
        {
            string fieldname = Helper.ExpressionHelper.GetFieldName<T>(FieldNameExpression);

            RemoveIndex(fieldname);
        }

        public void RemoveIndex(string FieldName)
        {
            if (FieldName.ToLower() == Dynamic.Constants.DefaultIdFieldName)
            {
                return;
            }
            var index = this.Indexs.Find(o => o.FieldName == FieldName);

            if (index != null)
            {
                lock (_Locker)
                {
                    this.Indexs.Remove(index);
                    index.Close();
                    index.DelSelf();
                }
            }
        }

        /// <summary>
        /// Update the content to the record before that log. 
        /// </summary>
        /// <param name="log"></param>
        public void RollBack(LogEntry log)
        {
            //just double confirm. 
            if (log.TableName == this.Name)
            {
                Guid key = ObjectContainer.GuidConverter.FromByte(log.KeyBytes);

                if (log.EditType == EditType.Add)
                {
                    // undo of add == delete. 
                    this.Delete(key);
                }
                else if (log.EditType == EditType.Delete)
                {
                    var lastlog = this.OwnerDatabase.Log.GetPreviousTableLog(log);
                    if (lastlog == null || lastlog.EditType == EditType.Delete)
                    {
                        this.Delete(key);
                    }
                    else
                    {
                        Dictionary<string, object> item = GetLastUpdateLogItem(lastlog);

                        if (item != null)
                        {
                            if (item.ContainsKey(Constants.DefaultIdFieldName))
                            {
                                var idkey = item[Constants.DefaultIdFieldName];
                                var id = _ParseKey(idkey);

                                if (this.Get(id) != null)
                                {
                                    this.Update(id, item);
                                }
                                else
                                {
                                    this.Add(item);
                                }

                            }
                        }
                    }
                }

                else if (log.EditType == EditType.Update)
                {
                    var lastlog = this.OwnerDatabase.Log.GetPreviousTableLog(log);
                    if (lastlog != null)
                    {
                        if (lastlog.EditType == EditType.Delete)
                        {
                            this.Delete(key);
                        }
                        else if (lastlog.EditType == EditType.Add || lastlog.EditType == EditType.Update)
                        {
                            Dictionary<string, object> item = GetLastUpdateLogItem(lastlog);

                            if (item != null)
                            {

                                if (item.ContainsKey(Constants.DefaultIdFieldName))
                                {
                                    var idkey = item[Constants.DefaultIdFieldName];
                                    var id = _ParseKey(idkey);
                                    if (this.Get(id) != null)
                                    {
                                        this.Update(id, item);
                                    }
                                    else
                                    {
                                        this.Add(item);
                                    }
                                }

                            }
                        }
                    }
                }
            }
        }


        public void RollBack(List<LogEntry> loglist)
        {
            HashSet<Guid> finished = new HashSet<Guid>();

            foreach (var item in loglist.OrderBy(o => o.TimeTick))
            {
                Guid key = Kooboo.IndexedDB.ObjectContainer.GuidConverter.FromByte(item.KeyBytes);

                if (!finished.Contains(key))
                {
                    RollBack(item);
                    finished.Add(key);
                }
            }
        }

        private Dictionary<string, object> GetLastUpdateLogItem(LogEntry lastlog)
        {
            if (lastlog.EditType == EditType.Update && !string.IsNullOrWhiteSpace(lastlog.TableColName))
            {
                var previousLog = this.OwnerDatabase.Log.GetPreviousTableLog(lastlog);
                if (previousLog == null)
                {
                    return null;
                }
                else
                {
                    var item = GetLastUpdateLogItem(previousLog);
                    var ColItem = this.GetLogData(lastlog);
                    if (item != null && ColItem != null)
                    {
                        foreach (var col in ColItem)
                        {
                            item[col.Key] = col.Value;
                        }

                        return item;
                    }

                }
            }
            else
            {
                return this.GetLogData(lastlog);
            }

            return null;

        }


        public void CheckOut(Int64 VersionId, Table destinationTable, bool SelfIncluded, bool UpdateSetting = true)
        {
            if (UpdateSetting)
            {
                UpdateCheckOutTableSetting(destinationTable);
            }

            List<LogEntry> logs;
            int namehash = this.Name.GetHashCode32();
            if (SelfIncluded)
            {
                logs = this.OwnerDatabase.Log.Store.Where(o => o.Id > VersionId && o.TableNameHash == namehash).Take(99999);
            }
            else
            {
                logs = this.OwnerDatabase.Log.Store.Where(o => o.Id >= VersionId && o.TableNameHash == namehash).Take(99999);
            }

            CheckOutExcl(logs, destinationTable);
        }

        private void UpdateCheckOutTableSetting(Table desttable)
        {
            var newsetting = Dynamic.SettingHelper.Clone(this.Setting);
            desttable.UpdateSetting(newsetting);
        }

        internal void CheckOutExcl(List<LogEntry> ExclLogs, Table destTable)
        {
            var exclitems = GetExclItems(ExclLogs);

            var processed = new HashSet<Guid>();

            var all = this.All();

            foreach (var item in all)
            {
                Guid dataid = default(Guid);
                if (item.ContainsKey("_id"))
                {
                    var objid = item["_id"];
                    Guid.TryParse(objid.ToString(), out dataid);
                }

                if (dataid == default(Guid))
                {
                    continue;
                }

                if (!exclitems.ContainsKey(dataid))
                {
                    destTable.Add(item);
                }
                else
                {
                    var exclitem = exclitems[dataid];

                    if (exclitem.EditType == EditType.Update || exclitem.EditType == EditType.Delete)
                    {
                        var lastlog = this.OwnerDatabase.Log.GetPreviousTableLog(exclitem);

                        var value = this.GetLogData(lastlog);

                        var old = this.Get(dataid);
                        if (old == null)
                        {
                            destTable.Add(value);
                        }
                        else
                        {
                            destTable.Update(dataid, value);
                        }
                    }
                    processed.Add(dataid);
                }
            }



            foreach (var item in exclitems)
            {
                if (!processed.Contains(item.Key))
                {
                    var logitem = item.Value;

                    if (logitem.EditType == EditType.Update || logitem.EditType == EditType.Delete)
                    {
                        var lastlog = this.OwnerDatabase.Log.GetPreviousTableLog(logitem);

                        if (lastlog != null)
                        {
                            var value = this.GetLogData(lastlog);
                            if (value != null)
                            {
                                destTable.Update(value);
                            }
                        }
                    }
                }

            }
        }

        private Dictionary<Guid, LogEntry> GetExclItems(List<LogEntry> logs)
        {
            Dictionary<Guid, LogEntry> result = new Dictionary<Guid, LogEntry>();

            foreach (var item in logs.OrderBy(o => o.TimeTick))
            {
                var key = ObjectContainer.GuidConverter.FromByte(item.KeyBytes);

                if (!result.ContainsKey(key))
                {
                    result[key] = item;
                }
            }
            return result;
        }

    }

    #endregion
}


---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.IndexedDB\Dynamic\Table.cs(330,17): error CS0103: The name 'idict' does not exist in the current context,D:\a\1\s\Kooboo.IndexedDB\Dynamic\Table.cs(335,17): error CS0103: The name 'idict' does not exist in the current context,D:\a\1\s\Kooboo.IndexedDB\Dynamic\Table.cs(341,45): error CS0103: The name 'idict' does not exist in the current context
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\Helper\JintHelper.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System;
using System.Collections;
using Newtonsoft.Json.Linq;
using System.Xml.Linq;
using Jint.Parser;

namespace Kooboo.Lib.Helper
{
    public static class JintHelper
    {
        public static string GetFuncBody(string js, int startLine, int startColumn, int endLine, int endColumn)
        {
            if (startLine > endLine || (startLine == endLine && startColumn > endColumn))
            {
                return null;
            }
            MemoryStream mo = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(js));
            StreamReader reader = new StreamReader(mo);

            string body = string.Empty;

            for (int i = 1; i <= endLine; i++)
            {
                var line = reader.ReadLine();
                if (line == null) { break; }

                if (i < startLine)
                {
                    continue;
                }
                else if (i == startLine)
                {
                    if (i == endLine)
                    {
                        body = line.Substring(startColumn, endColumn - startColumn);
                        break;
                    }
                    else
                    {
                        body += line.Substring(startColumn) + "\r\n";
                    }
                }
                else
                {
                    if (i < endLine)
                    {
                        body += line + "\r\n";
                    }
                    else
                    {
                        body += line.Substring(0, endColumn);
                        break;
                    }
                }
            }

            return body;
        }

        public static string GetFuncBody(string js, Jint.Parser.Ast.FunctionDeclaration func)
        {
            return GetFuncBody(js, func.Location.Start.Line, func.Location.Start.Column, func.Location.End.Line, func.Location.End.Column);
        }

        public static string GetFuncBody(string js, string functionName)
        {
            Jint.Parser.JavaScriptParser parser = new Jint.Parser.JavaScriptParser();

            var jsprogram = parser.Parse(js);

            if (jsprogram != null)
            {

                var func = GetFuncByName(jsprogram, functionName);
                if (func != null)
                {
                    return GetFuncBody(js, func);
                }
            }
            return null;
        }

        public static Jint.Parser.Ast.FunctionDeclaration GetFuncByName(Jint.Parser.Ast.Program program, string FuncName)
        {
            if (program == null || program.FunctionDeclarations.Count == 0)
            {
                return null;
            }

            if (string.IsNullOrEmpty(FuncName))
            {
                return null;
            }
            string lower = FuncName.ToLower();

            foreach (var item in program.FunctionDeclarations)
            {
                if (item.Id.Name.ToLower() == lower)
                {
                    return item;
                }
            }
            return null;
        }

        public static HashSet<string> ListFunctionNames(string js)
        {
            HashSet<string> result = new HashSet<string>();

            if (IsRequireJs(js))
            {
                var functions = ListRequireJsFuncs(js);

                foreach (var item in functions)
                {
                    result.Add(item.Id.Name); 
                }
            }
            else
            {
                Jint.Parser.JavaScriptParser parser = new Jint.Parser.JavaScriptParser();

                var jsprogram = parser.Parse(js);

                foreach (var item in jsprogram.FunctionDeclarations)
                {
                    result.Add(item.Id.Name);
                }
            }
            return result;
        }


        public static Dictionary<string,List<string>> ListFunctions(string js)
        {
            Dictionary<string, List<string>> result = new Dictionary<string, List<string>>();  

            if (IsRequireJs(js))
            {
                var functions = ListRequireJsFuncs(js);

                foreach (var item in functions)
                {
                    string name = item.Id.Name;
                    List<string> paras = new List<string>(); 
                    if (item.Parameters !=null)
                    {
                        foreach (var p in item.Parameters)
                        {
                            paras.Add(p.Name); 
                        }
                    }

                    result[name] = paras; 
                }
            }
            else
            {
                Jint.Parser.JavaScriptParser parser = new Jint.Parser.JavaScriptParser();

                var jsprogram = parser.Parse(js);

                foreach (var item in jsprogram.FunctionDeclarations)
                {
                    string name = item.Id.Name;
                    List<string> paras = new List<string>();
                    if (item.Parameters != null)
                    {
                        foreach (var p in item.Parameters)
                        {
                            paras.Add(p.Name);
                        }
                    }

                    result[name] = paras;
                }
            }
            return result;
        }

         
        public static List<Jint.Parser.Ast.FunctionDeclaration> ListRequireJsFuncs(string requireJsBlock)
        {
            Jint.Parser.JavaScriptParser parser = new Jint.Parser.JavaScriptParser();

            var prog = parser.Parse(requireJsBlock);

            if (prog != null && prog.Body.Any())
            {

                var item = prog.Body.First();

                if (item is Jint.Parser.Ast.ExpressionStatement)
                {
                    var expres = item as Jint.Parser.Ast.ExpressionStatement;

                    if (expres.Expression is Jint.Parser.Ast.CallExpression)
                    {
                        var call = expres.Expression as Jint.Parser.Ast.CallExpression;
                        if (call != null && call.Arguments.Count() == 2)
                        {
                            var requireargu = call.Arguments[1];

                            if (requireargu is Jint.Parser.Ast.FunctionExpression)
                            {
                                var requireFunc = requireargu as Jint.Parser.Ast.FunctionExpression;

                                if (requireFunc != null)
                                {
                                    return requireFunc.FunctionDeclarations.ToList();
                                }
                            }

                        }

                    }
                }
            }


            return new List<Jint.Parser.Ast.FunctionDeclaration>();
        }

        public static bool IsRequireJs(string JsBlock)
        {
            Jint.Parser.JavaScriptParser parser = new Jint.Parser.JavaScriptParser();

            var prog = parser.Parse(JsBlock);

            foreach (var item in prog.Body)
            {
                if (item is Jint.Parser.Ast.ExpressionStatement)
                {
                    var expres = item as Jint.Parser.Ast.ExpressionStatement;

                    if (expres.Expression is Jint.Parser.Ast.CallExpression)
                    {
                        var call = expres.Expression as Jint.Parser.Ast.CallExpression;

                        if (call.Callee is Jint.Parser.Ast.Identifier)
                        {
                            var id = call.Callee as Jint.Parser.Ast.Identifier;
                            if (id.Name.ToLower() == "require" || id.Name.ToLower() == "define")
                            {
                                return true;
                            }
                        }
                    }
                }
            }

            return false;
        }

        // append to end of the functions. 
        public static string AppendRequireJsBlock(string Js, string append, List<Jint.Parser.Ast.FunctionDeclaration> list = null)
        {
            if (list == null)
            {
                list = ListRequireJsFuncs(Js);
            }

            if (!list.Any())
            {
                return Js;
            }

            int LastLine = 0;
            int LastCol = 0;

            foreach (var item in list)
            {
                if (item.Location.End.Line > LastLine)
                {
                    LastLine = item.Location.End.Line;
                    LastCol = item.Location.End.Column;
                }
                else if (item.Location.End.Line == LastLine)
                {
                    if (item.Location.End.Column > LastCol)
                    {
                        LastCol = item.Location.End.Column;
                    }
                }
            }

            if (LastCol == 0 && LastLine == 0)
            {
                return Js;
            }

            MemoryStream mo = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(Js));
            StreamReader reader = new StreamReader(mo);

            string result = string.Empty;

            var line = reader.ReadLine();
            int linenumber = 0;
            while (line != null)
            {
                linenumber += 1;
                if (linenumber != 1)
                {
                    result += "\r\n";
                }

                if (linenumber == LastLine)
                {
                    string before = line.Substring(0, LastCol);
                    result += before;
                    result += append;
                    if (line.Length > LastCol)
                    {
                        string after = line.Substring(LastCol);
                        result += after;
                    }
                }
                else
                {
                    result += line;
                }

                line = reader.ReadLine();
            }

            return result;
        }

        private static object GetValue(Jint.Runtime.Debugger.DebugInformation info, string property)
        { 
            var value = info.Locals.Where(item => item.Key.ToLower() == property).Select(item => item.Value).FirstOrDefault();
            if (value == null)
            {
                value = info.Globals.Where(item => item.Key.ToLower() == property).Select(item => item.Value).FirstOrDefault();
            }
            return value;
        }
        public static object GetGebuggerValue(Jint.Engine engine, string FullProperty)
        {
            if (string.IsNullOrEmpty(FullProperty))
            {
                return null;
            }
               
            FullProperty = FullProperty.Trim();
            FullProperty = FullProperty.TrimEnd(';'); 

            string[] parts = FullProperty.Split(".".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
            var info = engine.DebugHandler.GetDebugInformation();

            object value = null;

            for (int i = 0; i < parts.Length; i++)
            {
                if (i == 0)
                {
                    value = GetValue(info,parts[i]);
                    if (value == null)
                    {
                        return null;
                    }
                }
                else
                {
                    value = getMember(value, parts[i]);
                    if (value == null)
                    {
                        return null;
                    }
                }
            }


            if (value is Jint.Native.JsValue)
            {
                var jsvalue = value as Jint.Native.JsValue;
                if (jsvalue != null)
                {
                    return jsvalue.ToObject();
                }
            }

            return value;


        }


        private static object getMember(object obj, string PropertyName)
        {
            if (obj is IDictionary)
            {
                var dict = obj as IDictionary;
                return GetValueDic(dict, PropertyName);
            }

            else if (obj is JObject)
            {
                return Lib.Helper.JsonHelper.GetObject(obj as JObject, PropertyName);
            }

            else if (obj is System.Dynamic.ExpandoObject)
            {
                IDictionary<String, Object> value = obj as IDictionary<String, Object>;
                if (value != null)
                {
                    return value.Where(item => EqualsIgnoreCasing(PropertyName, item.Key)).Select(item => item.Value).FirstOrDefault();
                }
                return null;
            }
            else if (obj is IDictionary<string, object>)
            {
                IDictionary<string, object> value = obj as IDictionary<string, object>;
                if (value != null)
                {
                    return value.Where(item => EqualsIgnoreCasing(PropertyName, item.Key)).Select(item => item.Value).FirstOrDefault();
                }
                return null;
            }
            else if (obj is Jint.Native.JsValue)
            {
                var value = obj as Jint.Native.JsValue;

                var jsObject = value.ToObject();
                if (jsObject ==null)
                {
                    return null; 
                }

                IDictionary<String, Object> rightvalue = jsObject as IDictionary<String, Object>;
                if (rightvalue != null)
                {
                    return rightvalue.Where(item => EqualsIgnoreCasing(PropertyName, item.Key)).Select(item => item.Value).FirstOrDefault();
                }
                else
                {
                    if (jsObject is System.Dynamic.ExpandoObject)
                    {
                        IDictionary<String, Object> expvalue = obj as IDictionary<String, Object>;
                        if (expvalue != null)
                        {
                            return expvalue.Where(item => EqualsIgnoreCasing(PropertyName, item.Key)).Select(item => item.Value).FirstOrDefault();
                        }
                        return null;
                    }
                    else
                    {
                        return Kooboo.Lib.Reflection.Dynamic.GetObjectMember(jsObject, PropertyName);
                    }
                }

            }

            return Kooboo.Lib.Reflection.Dynamic.GetObjectMember(obj, PropertyName);
        }

        private static object GetValueDic(IDictionary dictionary,string name)
        {
            var keys = dictionary.Keys;
            string matchKey=null;
            foreach(var key in keys)
            {
                if (EqualsIgnoreCasing(name, key as string))
                {
                    matchKey = key as string;
                    break;
                }
            }
            if(!string.IsNullOrEmpty(matchKey))
            {
                return dictionary[matchKey];
            }
            return null;
        }

        private static bool EqualsIgnoreCasing(string s1, string s2)
        {
            bool equals = false;
            if (s1.Length == s2.Length)
            {
                if (s1.Length > 0 && s2.Length > 0)
                {
                    equals = (s1.ToLower()[0] == s2.ToLower()[0]);
                }
                if (s1.Length > 1 && s2.Length > 1)
                {
                    equals = equals && (s1.Substring(1) == s2.Substring(1));
                }
            }
            return equals;
        }


        public static bool IsMemberExpression(string code)
        {
            if (string.IsNullOrWhiteSpace(code))
            {
                return false;
            }

            if (code.Contains("\n") || code.Contains("=") || code.Contains("{") || code.Contains("("))
            {
                return false;
            }

            var parser = new JavaScriptParser();
            var prog = parser.Parse(code);

            if (prog == null || prog.Body == null || prog.Body.Count() != 1)
            {
                return false;
            }

            var statement = prog.Body.First(); 

            if (statement == null)
            {
                return false; 
            } 
            var exp = statement as Jint.Parser.Ast.ExpressionStatement; 

            if (exp == null)
            {
                return false; 
            }
              
            var t = exp.Expression.GetType();

            if (t == typeof(Jint.Parser.Ast.MemberExpression) || t== typeof(Jint.Parser.Ast.Identifier))
            {
                return true; 
            } 
            return false;  
        }

        public static bool IsAssignmentExpression(string code)
        {
            if (string.IsNullOrWhiteSpace(code))
            {
                return false;
            }

            if (code.Contains("{") || code.Contains("("))
            {
                return false;
            }

            var parser = new JavaScriptParser();
            var prog = parser.Parse(code);

            if (prog == null || prog.Body == null || prog.Body.Count() != 1)
            {
                return false;
            }

            var statement = prog.Body.First();

            if (statement == null)
            {
                return false;
            }
            var exp = statement as Jint.Parser.Ast.ExpressionStatement;

            if (exp == null)
            {
                return false;
            }
              
            var t = exp.Expression.GetType();

            if (t == typeof(Jint.Parser.Ast.AssignmentExpression))
            {
                return true;
            }
            return false;
        }

        public static object GetAssignmentValue(string code)
        { 
            var parser = new JavaScriptParser();
            var prog = parser.Parse(code);
             
            var statement = prog.Body.First(); 
  
            var exp = statement as Jint.Parser.Ast.ExpressionStatement;

            var ass = exp.Expression as Jint.Parser.Ast.AssignmentExpression;

            var rightvalue = ass.Right as Jint.Parser.Ast.Literal; 

            if (rightvalue !=null)
            {
                return rightvalue.Value; 
            }

            return null; 
        }

    }
}

---- Transformed Tree ----
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System;
using System.Collections;
using Newtonsoft.Json.Linq;
using System.Xml.Linq;
using Jint.Parser;

namespace Kooboo.Lib.Helper
{
    public static class JintHelper
    {
        public static string GetFuncBody(string js, int startLine, int startColumn, int endLine, int endColumn)
        {
            if (startLine > endLine || (startLine == endLine && startColumn > endColumn))
            {
                return null;
            }
            MemoryStream mo = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(js));
            StreamReader reader = new StreamReader(mo);

            string body = string.Empty;

            for (int i = 1; i <= endLine; i++)
            {
                var line = reader.ReadLine();
                if (line == null) { break; }

                if (i < startLine)
                {
                    continue;
                }
                else if (i == startLine)
                {
                    if (i == endLine)
                    {
                        body = line.Substring(startColumn, endColumn - startColumn);
                        break;
                    }
                    else
                    {
                        body += line.Substring(startColumn) + "\r\n";
                    }
                }
                else
                {
                    if (i < endLine)
                    {
                        body += line + "\r\n";
                    }
                    else
                    {
                        body += line.Substring(0, endColumn);
                        break;
                    }
                }
            }

            return body;
        }

        public static string GetFuncBody(string js, Jint.Parser.Ast.FunctionDeclaration func)
        {
            return GetFuncBody(js, func.Location.Start.Line, func.Location.Start.Column, func.Location.End.Line, func.Location.End.Column);
        }

        public static string GetFuncBody(string js, string functionName)
        {
            Jint.Parser.JavaScriptParser parser = new Jint.Parser.JavaScriptParser();

            var jsprogram = parser.Parse(js);

            if (jsprogram != null)
            {

                var func = GetFuncByName(jsprogram, functionName);
                if (func != null)
                {
                    return GetFuncBody(js, func);
                }
            }
            return null;
        }

        public static Jint.Parser.Ast.FunctionDeclaration GetFuncByName(Jint.Parser.Ast.Program program, string FuncName)
        {
            if (program == null || program.FunctionDeclarations.Count == 0)
            {
                return null;
            }

            if (string.IsNullOrEmpty(FuncName))
            {
                return null;
            }
            string lower = FuncName.ToLower();

            foreach (var item in program.FunctionDeclarations)
            {
                if (item.Id.Name.ToLower() == lower)
                {
                    return item;
                }
            }
            return null;
        }

        public static HashSet<string> ListFunctionNames(string js)
        {
            HashSet<string> result = new HashSet<string>();

            if (IsRequireJs(js))
            {
                var functions = ListRequireJsFuncs(js);

                foreach (var item in functions)
                {
                    result.Add(item.Id.Name); 
                }
            }
            else
            {
                Jint.Parser.JavaScriptParser parser = new Jint.Parser.JavaScriptParser();

                var jsprogram = parser.Parse(js);

                foreach (var item in jsprogram.FunctionDeclarations)
                {
                    result.Add(item.Id.Name);
                }
            }
            return result;
        }


        public static Dictionary<string,List<string>> ListFunctions(string js)
        {
            Dictionary<string, List<string>> result = new Dictionary<string, List<string>>();  

            if (IsRequireJs(js))
            {
                var functions = ListRequireJsFuncs(js);

                foreach (var item in functions)
                {
                    string name = item.Id.Name;
                    List<string> paras = new List<string>(); 
                    if (item.Parameters !=null)
                    {
                        foreach (var p in item.Parameters)
                        {
                            paras.Add(p.Name); 
                        }
                    }

                    result[name] = paras; 
                }
            }
            else
            {
                Jint.Parser.JavaScriptParser parser = new Jint.Parser.JavaScriptParser();

                var jsprogram = parser.Parse(js);

                foreach (var item in jsprogram.FunctionDeclarations)
                {
                    string name = item.Id.Name;
                    List<string> paras = new List<string>();
                    if (item.Parameters != null)
                    {
                        foreach (var p in item.Parameters)
                        {
                            paras.Add(p.Name);
                        }
                    }

                    result[name] = paras;
                }
            }
            return result;
        }

         
        public static List<Jint.Parser.Ast.FunctionDeclaration> ListRequireJsFuncs(string requireJsBlock)
        {
            Jint.Parser.JavaScriptParser parser = new Jint.Parser.JavaScriptParser();

            var prog = parser.Parse(requireJsBlock);

            if (prog != null && prog.Body.Any())
            {

                var item = prog.Body.First();

                if (item is Jint.Parser.Ast.ExpressionStatement)
                {
                    var expres = item as Jint.Parser.Ast.ExpressionStatement;

                    if (expres.Expression is Jint.Parser.Ast.CallExpression)
                    {
                        if (expres.Expression is Jint.Parser.Ast.CallExpression call && call.Arguments.Count() == 2)
                        {
                            var requireargu = call.Arguments[1];

                            if (requireargu is Jint.Parser.Ast.FunctionExpression)
                            {
                                if (requireargu is Jint.Parser.Ast.FunctionExpression requireFunc)
                                {
                                    return requireFunc.FunctionDeclarations.ToList();
                                }
                            }

                        }

                    }
                }
            }


            return new List<Jint.Parser.Ast.FunctionDeclaration>();
        }

        public static bool IsRequireJs(string JsBlock)
        {
            Jint.Parser.JavaScriptParser parser = new Jint.Parser.JavaScriptParser();

            var prog = parser.Parse(JsBlock);

            foreach (var item in prog.Body)
            {
                if (item is Jint.Parser.Ast.ExpressionStatement)
                {
                    var expres = item as Jint.Parser.Ast.ExpressionStatement;

                    if (expres.Expression is Jint.Parser.Ast.CallExpression)
                    {
                        var call = expres.Expression as Jint.Parser.Ast.CallExpression;

                        if (call.Callee is Jint.Parser.Ast.Identifier)
                        {
                            var id = call.Callee as Jint.Parser.Ast.Identifier;
                            if (id.Name.ToLower() == "require" || id.Name.ToLower() == "define")
                            {
                                return true;
                            }
                        }
                    }
                }
            }

            return false;
        }

        // append to end of the functions. 
        public static string AppendRequireJsBlock(string Js, string append, List<Jint.Parser.Ast.FunctionDeclaration> list = null)
        {
            if (list == null)
            {
                list = ListRequireJsFuncs(Js);
            }

            if (!list.Any())
            {
                return Js;
            }

            int LastLine = 0;
            int LastCol = 0;

            foreach (var item in list)
            {
                if (item.Location.End.Line > LastLine)
                {
                    LastLine = item.Location.End.Line;
                    LastCol = item.Location.End.Column;
                }
                else if (item.Location.End.Line == LastLine)
                {
                    if (item.Location.End.Column > LastCol)
                    {
                        LastCol = item.Location.End.Column;
                    }
                }
            }

            if (LastCol == 0 && LastLine == 0)
            {
                return Js;
            }

            MemoryStream mo = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(Js));
            StreamReader reader = new StreamReader(mo);

            string result = string.Empty;

            var line = reader.ReadLine();
            int linenumber = 0;
            while (line != null)
            {
                linenumber += 1;
                if (linenumber != 1)
                {
                    result += "\r\n";
                }

                if (linenumber == LastLine)
                {
                    string before = line.Substring(0, LastCol);
                    result += before;
                    result += append;
                    if (line.Length > LastCol)
                    {
                        string after = line.Substring(LastCol);
                        result += after;
                    }
                }
                else
                {
                    result += line;
                }

                line = reader.ReadLine();
            }

            return result;
        }

        private static object GetValue(Jint.Runtime.Debugger.DebugInformation info, string property)
        { 
            var value = info.Locals.Where(item => item.Key.ToLower() == property).Select(item => item.Value).FirstOrDefault();
            if (value == null)
            {
                value = info.Globals.Where(item => item.Key.ToLower() == property).Select(item => item.Value).FirstOrDefault();
            }
            return value;
        }
        public static object GetGebuggerValue(Jint.Engine engine, string FullProperty)
        {
            if (string.IsNullOrEmpty(FullProperty))
            {
                return null;
            }
               
            FullProperty = FullProperty.Trim();
            FullProperty = FullProperty.TrimEnd(';'); 

            string[] parts = FullProperty.Split(".".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
            var info = engine.DebugHandler.GetDebugInformation();

            object value = null;

            for (int i = 0; i < parts.Length; i++)
            {
                if (i == 0)
                {
                    value = GetValue(info,parts[i]);
                    if (value == null)
                    {
                        return null;
                    }
                }
                else
                {
                    value = getMember(value, parts[i]);
                    if (value == null)
                    {
                        return null;
                    }
                }
            }


            if (value is Jint.Native.JsValue)
            {
                if (value is Jint.Native.JsValue jsvalue)
                {
                    return jsvalue.ToObject();
                }
            }

            return value;


        }


        private static object getMember(object obj, string PropertyName)
        {
            if (obj is IDictionary)
            {
                var dict = obj as IDictionary;
                return GetValueDic(dict, PropertyName);
            }

            else if (obj is JObject)
            {
                return Lib.Helper.JsonHelper.GetObject(obj as JObject, PropertyName);
            }

            else if (obj is System.Dynamic.ExpandoObject)
            {
                if (obj is IDictionary<String, Object> value)
                {
                    return value.Where(item => EqualsIgnoreCasing(PropertyName, item.Key)).Select(item => item.Value).FirstOrDefault();
                }
                return null;
            }
            else if (obj is IDictionary<string, object>)
            {
                if (obj is IDictionary<String, Object> value)
                {
                    return value.Where(item => EqualsIgnoreCasing(PropertyName, item.Key)).Select(item => item.Value).FirstOrDefault();
                }
                return null;
            }
            else if (obj is Jint.Native.JsValue)
            {

                var jsObject = value.ToObject();
                if (jsObject ==null)
                {
                    return null; 
                }

                if (jsObject is IDictionary<String, Object> rightvalue)
                {
                    return rightvalue.Where(item => EqualsIgnoreCasing(PropertyName, item.Key)).Select(item => item.Value).FirstOrDefault();
                }
                else
                {
                    if (jsObject is System.Dynamic.ExpandoObject)
                    {
                        if (obj is IDictionary<String, Object> expvalue)
                        {
                            return expvalue.Where(item => EqualsIgnoreCasing(PropertyName, item.Key)).Select(item => item.Value).FirstOrDefault();
                        }
                        return null;
                    }
                    else
                    {
                        return Kooboo.Lib.Reflection.Dynamic.GetObjectMember(jsObject, PropertyName);
                    }
                }

            }

            return Kooboo.Lib.Reflection.Dynamic.GetObjectMember(obj, PropertyName);
        }

        private static object GetValueDic(IDictionary dictionary,string name)
        {
            var keys = dictionary.Keys;
            string matchKey=null;
            foreach(var key in keys)
            {
                if (EqualsIgnoreCasing(name, key as string))
                {
                    matchKey = key as string;
                    break;
                }
            }
            if(!string.IsNullOrEmpty(matchKey))
            {
                return dictionary[matchKey];
            }
            return null;
        }

        private static bool EqualsIgnoreCasing(string s1, string s2)
        {
            bool equals = false;
            if (s1.Length == s2.Length)
            {
                if (s1.Length > 0 && s2.Length > 0)
                {
                    equals = (s1.ToLower()[0] == s2.ToLower()[0]);
                }
                if (s1.Length > 1 && s2.Length > 1)
                {
                    equals = equals && (s1.Substring(1) == s2.Substring(1));
                }
            }
            return equals;
        }


        public static bool IsMemberExpression(string code)
        {
            if (string.IsNullOrWhiteSpace(code))
            {
                return false;
            }

            if (code.Contains("\n") || code.Contains("=") || code.Contains("{") || code.Contains("("))
            {
                return false;
            }

            var parser = new JavaScriptParser();
            var prog = parser.Parse(code);

            if (prog == null || prog.Body == null || prog.Body.Count() != 1)
            {
                return false;
            }

            var statement = prog.Body.First(); 

            if (statement == null)
            {
                return false; 
            } 
            var exp = statement as Jint.Parser.Ast.ExpressionStatement; 

            if (exp == null)
            {
                return false; 
            }
              
            var t = exp.Expression.GetType();

            if (t == typeof(Jint.Parser.Ast.MemberExpression) || t== typeof(Jint.Parser.Ast.Identifier))
            {
                return true; 
            } 
            return false;  
        }

        public static bool IsAssignmentExpression(string code)
        {
            if (string.IsNullOrWhiteSpace(code))
            {
                return false;
            }

            if (code.Contains("{") || code.Contains("("))
            {
                return false;
            }

            var parser = new JavaScriptParser();
            var prog = parser.Parse(code);

            if (prog == null || prog.Body == null || prog.Body.Count() != 1)
            {
                return false;
            }

            var statement = prog.Body.First();

            if (statement == null)
            {
                return false;
            }
            var exp = statement as Jint.Parser.Ast.ExpressionStatement;

            if (exp == null)
            {
                return false;
            }
              
            var t = exp.Expression.GetType();

            if (t == typeof(Jint.Parser.Ast.AssignmentExpression))
            {
                return true;
            }
            return false;
        }

        public static object GetAssignmentValue(string code)
        { 
            var parser = new JavaScriptParser();
            var prog = parser.Parse(code);
             
            var statement = prog.Body.First(); 
  
            var exp = statement as Jint.Parser.Ast.ExpressionStatement;

            var ass = exp.Expression as Jint.Parser.Ast.AssignmentExpression;

            if (ass.Right is Jint.Parser.Ast.Literal rightvalue)
            {
                return rightvalue.Value; 
            }

            return null; 
        }

    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Kooboo.Lib\Helper\JintHelper.cs(6,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Kooboo.Lib\Helper\JintHelper.cs(10,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\Helper\JintHelper.cs(423,32): error CS0103: The name 'value' does not exist in the current context,D:\a\1\s\Kooboo.Lib\Helper\JintHelper.cs(6,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Kooboo.Lib\Helper\JintHelper.cs(10,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\Jint\Native\String\StringPrototype.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Jint.Native.Array;
using Jint.Native.Function;
using Jint.Native.Object;
using Jint.Native.RegExp;
using Jint.Runtime;
using Jint.Runtime.Descriptors;
using Jint.Runtime.Interop;

namespace Jint.Native.String
{


    /// <summary>
    /// http://www.ecma-international.org/ecma-262/5.1/#sec-15.5.4
    /// </summary>
    public sealed class StringPrototype : StringInstance
    {
        private StringPrototype(Engine engine)
            : base(engine)
        {
        }

        public static StringPrototype CreatePrototypeObject(Engine engine, StringConstructor stringConstructor)
        {
            var obj = new StringPrototype(engine);
            obj.Prototype = engine.Object.PrototypeObject;
            obj.PrimitiveValue = "";
            obj.Extensible = true;
            obj.FastAddProperty("length", 0, false, false, false); 
            obj.FastAddProperty("constructor", stringConstructor, true, false, true);

            return obj;
        }

        public void Configure()
        {
            FastAddProperty("toString", new ClrFunctionInstance(Engine, ToStringString), true, false, true);
            FastAddProperty("valueOf", new ClrFunctionInstance(Engine, ValueOf), true, false, true);
            FastAddProperty("charAt", new ClrFunctionInstance(Engine, CharAt, 1), true, false, true);
            FastAddProperty("charCodeAt", new ClrFunctionInstance(Engine, CharCodeAt, 1), true, false, true);
            FastAddProperty("concat", new ClrFunctionInstance(Engine, Concat, 1), true, false, true);
            FastAddProperty("indexOf", new ClrFunctionInstance(Engine, IndexOf, 1), true, false, true);
            FastAddProperty("lastIndexOf", new ClrFunctionInstance(Engine, LastIndexOf, 1), true, false, true);
            FastAddProperty("localeCompare", new ClrFunctionInstance(Engine, LocaleCompare, 1), true, false, true);
            FastAddProperty("match", new ClrFunctionInstance(Engine, Match, 1), true, false, true);
            FastAddProperty("replace", new ClrFunctionInstance(Engine, Replace, 2), true, false, true);
            FastAddProperty("search", new ClrFunctionInstance(Engine, Search, 1), true, false, true);
            FastAddProperty("slice", new ClrFunctionInstance(Engine, Slice, 2), true, false, true);
            FastAddProperty("split", new ClrFunctionInstance(Engine, Split, 2), true, false, true);
            FastAddProperty("substr", new ClrFunctionInstance(Engine, Substr, 2), true, false, true);
            FastAddProperty("substring", new ClrFunctionInstance(Engine, Substring, 2), true, false, true);
            FastAddProperty("toLowerCase", new ClrFunctionInstance(Engine, ToLowerCase), true, false, true);
            FastAddProperty("toLocaleLowerCase", new ClrFunctionInstance(Engine, ToLocaleLowerCase), true, false, true);
            FastAddProperty("toUpperCase", new ClrFunctionInstance(Engine, ToUpperCase), true, false, true);
            FastAddProperty("toLocaleUpperCase", new ClrFunctionInstance(Engine, ToLocaleUpperCase), true, false, true);
            FastAddProperty("trim", new ClrFunctionInstance(Engine, Trim), true, false, true);
        }

        private JsValue ToStringString(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToObject(Engine, thisObj) as StringInstance;
            if (s == null)
            {
                throw new JavaScriptException(Engine.TypeError);
            }

            return s.PrimitiveValue;
        }

        // http://msdn.microsoft.com/en-us/library/system.char.iswhitespace(v=vs.110).aspx
        // http://en.wikipedia.org/wiki/Byte_order_mark
        const char BOM_CHAR = '\uFEFF';
        const char MONGOLIAN_VOWEL_SEPARATOR = '\u180E';

        private static bool IsWhiteSpaceEx(char c)
        {
            return 
                char.IsWhiteSpace(c) || 
                c == BOM_CHAR ||
                // In .NET 4.6 this was removed from WS based on Unicode 6.3 changes
                c == MONGOLIAN_VOWEL_SEPARATOR;
        }

        public static string TrimEndEx(string s)
        {
            if (s.Length == 0)
                return string.Empty;

            var i = s.Length - 1;
            while (i >= 0)
            {
                if (IsWhiteSpaceEx(s[i]))
                    i--;
                else
                    break;
            }
            if (i >= 0)
                return s.Substring(0, i + 1);
            else
                return string.Empty;
        }

        public static string TrimStartEx(string s)
        {
            if (s.Length == 0)
                return string.Empty;

            var i = 0;
            while (i < s.Length)
            {
                if (IsWhiteSpaceEx(s[i]))
                    i++;
                else
                    break;
            }
            if (i >= s.Length)
                return string.Empty;
            else
                return s.Substring(i);
        }

        public static string TrimEx(string s)
        {
            return TrimEndEx(TrimStartEx(s));
        } 

        private JsValue Trim(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);
            var s = TypeConverter.ToString(thisObj);
            return TrimEx(s);
        }
        
        private static JsValue ToLocaleUpperCase(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToString(thisObj);
            return s.ToUpper();
        }

        private static JsValue ToUpperCase(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToString(thisObj);
            return s.ToUpperInvariant();
        }

        private static JsValue ToLocaleLowerCase(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToString(thisObj);
            return s.ToLower();
        }

        private static JsValue ToLowerCase(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToString(thisObj);
            return s.ToLowerInvariant();
        }

        private static int ToIntegerSupportInfinity(JsValue numberVal)
        {
            var doubleVal = TypeConverter.ToInteger(numberVal);
            var intVal = (int) doubleVal;
            if (double.IsPositiveInfinity(doubleVal))
                intVal = int.MaxValue;
            else if (double.IsNegativeInfinity(doubleVal))
                intVal = int.MinValue;
            else
                intVal = (int) doubleVal;
            return intVal;
        }

        private JsValue Substring(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);
            var start = TypeConverter.ToNumber(arguments.At(0));
            var end = TypeConverter.ToNumber(arguments.At(1));

            if (double.IsNaN(start) || start < 0)
            {
                start = 0;
            }

            if (double.IsNaN(end) || end < 0)
            {
                end = 0;
            }

            var len = s.Length;
            var intStart = ToIntegerSupportInfinity(start);

            var intEnd = arguments.At(1) == Undefined.Instance ? len : (int)ToIntegerSupportInfinity(end);
            var finalStart = System.Math.Min(len, System.Math.Max(intStart, 0));
            var finalEnd = System.Math.Min(len, System.Math.Max(intEnd, 0));
            // Swap value if finalStart < finalEnd
            var from = System.Math.Min(finalStart, finalEnd);
            var to = System.Math.Max(finalStart, finalEnd);
            return s.Substring(from, to - from);
        }

        private JsValue Substr(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToString(thisObj);
            var start = TypeConverter.ToInteger(arguments.At(0));
            var length = arguments.At(1) == JsValue.Undefined 
                ? double.PositiveInfinity 
                : TypeConverter.ToInteger(arguments.At(1));

            start = start >= 0 ? start : System.Math.Max(s.Length + start, 0);
            length = System.Math.Min(System.Math.Max(length, 0), s.Length - start);
            if (length <= 0)
            {
                return "";
            }

            return s.Substring(TypeConverter.ToInt32(start), TypeConverter.ToInt32(length));
        }

        private JsValue Split(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);
            var s = TypeConverter.ToString(thisObj);

            var separator = arguments.At(0);

            // Coerce into a number, true will become 1 
            var l = arguments.At(1);
            var a = (ArrayInstance) Engine.Array.Construct(Arguments.Empty);
            var limit = l == Undefined.Instance ? UInt32.MaxValue : TypeConverter.ToUint32(l);
            var len = s.Length;
            
            if (limit == 0)
            {
                return a;
            }

            if (separator == Null.Instance)
            {
                separator = Null.Text;
            }
            else if (separator == Undefined.Instance)
            {
                return (ArrayInstance)Engine.Array.Construct(Arguments.From(s));
            }
            else
            {
                if (!separator.IsRegExp())
                {
                    separator = TypeConverter.ToString(separator); // Coerce into a string, for an object call toString()
                }
            }

            var rx = TypeConverter.ToObject(Engine, separator) as RegExpInstance;

            const string regExpForMatchingAllCharactere = "(?:)";

            if (rx != null &&
                rx.Source != regExpForMatchingAllCharactere // We need pattern to be defined -> for s.split(new RegExp) 
                )
            {
                var match = rx.Value.Match(s, 0);

                if (!match.Success) // No match at all return the string in an array
                {
                    a.DefineOwnProperty("0", new PropertyDescriptor(s, true, true, true), false);
                    return a;
                }

                int lastIndex = 0;
                int index = 0;
                while (match.Success && index < limit)
                {
                    if (match.Length == 0 && (match.Index == 0 || match.Index == len || match.Index == lastIndex))
                    {
                        match = match.NextMatch();
                        continue;
                    }

                    // Add the match results to the array.
                    a.DefineOwnProperty(index++.ToString(), new PropertyDescriptor(s.Substring(lastIndex, match.Index - lastIndex), true, true, true), false);
                    
                    if (index >= limit)
                    {
                        return a;
                    }

                    lastIndex = match.Index + match.Length;
                    for (int i = 1; i < match.Groups.Count; i++)
                    {
                        var group = match.Groups[i];
                        var item = Undefined.Instance;
                        if (group.Captures.Count > 0)
                        {
                            item = match.Groups[i].Value;
                        }

                        a.DefineOwnProperty(index++.ToString(), new PropertyDescriptor(item, true, true, true ), false);

                        if (index >= limit)
                        {
                            return a;
                        }
                    }

                    match = match.NextMatch();
                    if (!match.Success) // Add the last part of the split
                    {
                        a.DefineOwnProperty(index++.ToString(), new PropertyDescriptor(s.Substring(lastIndex), true, true, true), false);                        
                    }
                }

                return a;
            }
            else
            {
                var segments = new List<string>();
                var sep = TypeConverter.ToString(separator);

                if (sep == string.Empty || (rx != null && rx.Source == regExpForMatchingAllCharactere)) // for s.split(new RegExp)
                {
                    foreach (var c in s)
                    {
                        segments.Add(c.ToString());    
                    }
                }
                else
                {
                    segments = s.Split(new[] {sep}, StringSplitOptions.None).ToList();
                }

                for (int i = 0; i < segments.Count && i < limit; i++)
                {
                    a.DefineOwnProperty(i.ToString(), new PropertyDescriptor(segments[i], true, true, true), false);
                }
            
                return a;
            }
        }

        private JsValue Slice(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);

            var start = TypeConverter.ToNumber(arguments.At(0));
            if (double.NegativeInfinity.Equals(start))
            {
                start = 0;
            }
            if (double.PositiveInfinity.Equals(start))
            {
                return string.Empty;
            }
            
            var end = TypeConverter.ToNumber(arguments.At(1));
            if (double.PositiveInfinity.Equals(end))
            {
                end = s.Length;
            }

            var len = s.Length;
            var intStart = (int)TypeConverter.ToInteger(start);
            var intEnd = arguments.At(1) == Undefined.Instance ? len : (int)TypeConverter.ToInteger(end);
            var from = intStart < 0 ? System.Math.Max(len + intStart, 0) : System.Math.Min(intStart, len);
            var to = intEnd < 0 ? System.Math.Max(len + intEnd, 0) : System.Math.Min(intEnd, len);
            var span = System.Math.Max(to - from, 0);

            return s.Substring(from, span);
        }

        private JsValue Search(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);

            var regex = arguments.At(0);

            if (regex.IsUndefined())
            {
                regex = string.Empty;
            }
            else if (regex.IsNull())
            {
                regex = Null.Text;
            }

            var rx = TypeConverter.ToObject(Engine, regex) as RegExpInstance ?? (RegExpInstance)Engine.RegExp.Construct(new[] { regex });
            var match = rx.Value.Match(s);
            if (!match.Success)
            {
                return -1;
            }

            return match.Index;
        }

        private JsValue Replace(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var thisString = TypeConverter.ToString(thisObj);
            var searchValue = arguments.At(0);
            var replaceValue = arguments.At(1);

            // If the second parameter is not a function we create one
            var replaceFunction = replaceValue.TryCast<FunctionInstance>();
            if (replaceFunction == null)
            {
                replaceFunction = new ClrFunctionInstance(Engine, (self, args) =>
                {
                    var replaceString = TypeConverter.ToString(replaceValue);
                    var matchValue = TypeConverter.ToString(args.At(0));
                    var matchIndex = (int)TypeConverter.ToInteger(args.At(args.Length - 2));

                    // Check if the replacement string contains any patterns.
                    bool replaceTextContainsPattern = replaceString.IndexOf('$') >= 0;

                    // If there is no pattern, replace the pattern as is.
                    if (replaceTextContainsPattern == false)
                        return replaceString;

                    // Patterns
                    // $$	Inserts a "$".
                    // $&	Inserts the matched substring.
                    // $`	Inserts the portion of the string that precedes the matched substring.
                    // $'	Inserts the portion of the string that follows the matched substring.
                    // $n or $nn	Where n or nn are decimal digits, inserts the nth parenthesized submatch string, provided the first argument was a RegExp object.
                    var replacementBuilder = new StringBuilder();
                    for (int i = 0; i < replaceString.Length; i++)
                    {
                        char c = replaceString[i];
                        if (c == '$' && i < replaceString.Length - 1)
                        {
                            c = replaceString[++i];
                            if (c == '$')
                                replacementBuilder.Append('$');
                            else if (c == '&')
                                replacementBuilder.Append(matchValue);
                            else if (c == '`')
                                replacementBuilder.Append(thisString.Substring(0, matchIndex));
                            else if (c == '\'')
                                replacementBuilder.Append(thisString.Substring(matchIndex + matchValue.Length));
                            else if (c >= '0' && c <= '9')
                            {
                                int matchNumber1 = c - '0';

                                // The match number can be one or two digits long.
                                int matchNumber2 = 0;
                                if (i < replaceString.Length - 1 && replaceString[i + 1] >= '0' && replaceString[i + 1] <= '9')
                                    matchNumber2 = matchNumber1 * 10 + (replaceString[i + 1] - '0');

                                // Try the two digit capture first.
                                if (matchNumber2 > 0 && matchNumber2 < args.Length - 2)
                                {
                                    // Two digit capture replacement.
                                    replacementBuilder.Append(TypeConverter.ToString(args[matchNumber2]));
                                    i++;
                                }
                                else if (matchNumber1 > 0 && matchNumber1 < args.Length - 2)
                                {
                                    // Single digit capture replacement.
                                    replacementBuilder.Append(TypeConverter.ToString(args[matchNumber1]));
                                }
                                else
                                {
                                    // Capture does not exist.
                                    replacementBuilder.Append('$');
                                    i--;
                                }
                            }
                            else
                            {
                                // Unknown replacement pattern.
                                replacementBuilder.Append('$');
                                replacementBuilder.Append(c);
                            }
                        }
                        else
                            replacementBuilder.Append(c);
                    }

                    return replacementBuilder.ToString();
                });
            }

            // searchValue is a regular expression

            if (searchValue.IsNull()) 
            {
                searchValue = new JsValue(Null.Text);
            }
            if (searchValue.IsUndefined())
            {
                searchValue = new JsValue(Undefined.Text);
            }
            
            var rx = TypeConverter.ToObject(Engine, searchValue) as RegExpInstance;
            if (rx != null)
            {
                // Replace the input string with replaceText, recording the last match found.
                string result = rx.Value.Replace(thisString, match =>
                {
                    var args = new List<JsValue>();
                    
                    for (var k = 0; k < match.Groups.Count; k++)
                    {
                        var group = match.Groups[k];
                        args.Add(group.Value);
                    }
                    
                    args.Add(match.Index);
                    args.Add(thisString);

                    var v = TypeConverter.ToString(replaceFunction.Call(Undefined.Instance, args.ToArray()));
                    return v;
                }, rx.Global == true ? -1 : 1);

                // Set the deprecated RegExp properties if at least one match was found.
                //if (lastMatch != null)
                //    this.Engine.RegExp.SetDeprecatedProperties(input, lastMatch);

                return result;
            }

            // searchValue is a string
            else
            {
                var substr = TypeConverter.ToString(searchValue);

                // Find the first occurrance of substr.
                int start = thisString.IndexOf(substr, StringComparison.Ordinal);
                if (start == -1)
                    return thisString;
                int end = start + substr.Length;

                var args = new List<JsValue>();
                args.Add(substr);
                args.Add(start);
                args.Add(thisString);

                var replaceString = TypeConverter.ToString(replaceFunction.Call(Undefined.Instance, args.ToArray()));

                // Replace only the first match.
                var result = new StringBuilder(thisString.Length + (substr.Length - substr.Length));
                result.Append(thisString, 0, start);
                result.Append(replaceString);
                result.Append(thisString, end, thisString.Length - end);
                return result.ToString();
            }
        }

        private JsValue Match(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);

            var regex = arguments.At(0);
            var rx = regex.TryCast<RegExpInstance>();

            rx = rx ?? (RegExpInstance) Engine.RegExp.Construct(new[] {regex});

            var global = rx.Get("global").AsBoolean();
            if (!global)
            {
                return Engine.RegExp.PrototypeObject.Exec(rx, Arguments.From(s));
            }
            else
            {
                rx.Put("lastIndex", 0, false);
                var a = Engine.Array.Construct(Arguments.Empty);
                double previousLastIndex = 0;
                var n = 0;
                var lastMatch = true;
                while (lastMatch)
                {
                    var result = Engine.RegExp.PrototypeObject.Exec(rx, Arguments.From(s)).TryCast<ObjectInstance>();
                    if (result == null)
                    {
                        lastMatch = false;
                    }
                    else
                    {
                        var thisIndex = rx.Get("lastIndex").AsNumber();
                        if (thisIndex == previousLastIndex)
                        {
                            rx.Put("lastIndex", thisIndex + 1, false);
                            previousLastIndex = thisIndex;
                        }

                        var matchStr = result.Get("0");
                        a.DefineOwnProperty(TypeConverter.ToString(n), new PropertyDescriptor(matchStr, true, true, true), false);
                        n++;
                    }
                }
                if (n == 0)
                {
                    return Null.Instance;
                }
                return a;
            }

        }

        private JsValue LocaleCompare(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);
            var that = TypeConverter.ToString(arguments.At(0));
            
            return string.CompareOrdinal(s, that);
        }

        private JsValue LastIndexOf(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);
            var searchStr = TypeConverter.ToString(arguments.At(0));
            double numPos = double.NaN;
            if (arguments.Length > 1 && arguments[1] != Undefined.Instance)
            {
                numPos = TypeConverter.ToNumber(arguments[1]);
            }

            var pos = double.IsNaN(numPos) ? double.PositiveInfinity : TypeConverter.ToInteger(numPos);

            var len = s.Length;
            var start = (int)System.Math.Min(System.Math.Max(pos, 0), len);
            var searchLen = searchStr.Length;

            var i = start;
            bool found;

            do
            {
                found = true;
                var j = 0;

                while (found && j < searchLen)
                {
                    if ((i + searchLen > len) || (s[i + j] != searchStr[j]))
                    {
                        found = false;
                    }
                    else
                    {
                        j++;
                    }
                }
                if (!found)
                {
                    i--;
                }

            } while (!found && i >= 0);

            return i;
        }

        private JsValue IndexOf(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);
            var searchStr = TypeConverter.ToString(arguments.At(0));
            double pos = 0;
            if (arguments.Length > 1 && arguments[1] != Undefined.Instance)
            {
                pos = TypeConverter.ToInteger(arguments[1]);
            }

            if (pos >= s.Length)
            {
                return -1;
            }

            if (pos < 0)
            {
                pos = 0;
            }

            return s.IndexOf(searchStr, (int) pos, StringComparison.Ordinal);
        }

        private JsValue Concat(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);
            var sb = new StringBuilder(s);
            for (int i = 0; i < arguments.Length; i++)
            {
                sb.Append(TypeConverter.ToString(arguments[i]));
            }

            return sb.ToString();
        }

        private JsValue CharCodeAt(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            JsValue pos = arguments.Length > 0 ? arguments[0] : 0;
            var s = TypeConverter.ToString(thisObj);
            var position = (int)TypeConverter.ToInteger(pos);
            if (position < 0 || position >= s.Length)
            {
                return double.NaN;
            }
            return s[position];
        }

        private JsValue CharAt(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);
            var s = TypeConverter.ToString(thisObj);
            var position = TypeConverter.ToInteger(arguments.At(0));
            var size = s.Length;
            if (position >= size || position < 0)
            {
                return "";
            }
            return s[(int) position].ToString();

        }

        private JsValue ValueOf(JsValue thisObj, JsValue[] arguments)
        {
            var s = thisObj.TryCast<StringInstance>();
            if (s == null)
            {
                throw new JavaScriptException(Engine.TypeError);
            }

            return s.PrimitiveValue;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Jint.Native.Array;
using Jint.Native.Function;
using Jint.Native.Object;
using Jint.Native.RegExp;
using Jint.Runtime;
using Jint.Runtime.Descriptors;
using Jint.Runtime.Interop;

namespace Jint.Native.String
{


    /// <summary>
    /// http://www.ecma-international.org/ecma-262/5.1/#sec-15.5.4
    /// </summary>
    public sealed class StringPrototype : StringInstance
    {
        private StringPrototype(Engine engine)
            : base(engine)
        {
        }

        public static StringPrototype CreatePrototypeObject(Engine engine, StringConstructor stringConstructor)
        {
            var obj = new StringPrototype(engine);
            obj.Prototype = engine.Object.PrototypeObject;
            obj.PrimitiveValue = "";
            obj.Extensible = true;
            obj.FastAddProperty("length", 0, false, false, false); 
            obj.FastAddProperty("constructor", stringConstructor, true, false, true);

            return obj;
        }

        public void Configure()
        {
            FastAddProperty("toString", new ClrFunctionInstance(Engine, ToStringString), true, false, true);
            FastAddProperty("valueOf", new ClrFunctionInstance(Engine, ValueOf), true, false, true);
            FastAddProperty("charAt", new ClrFunctionInstance(Engine, CharAt, 1), true, false, true);
            FastAddProperty("charCodeAt", new ClrFunctionInstance(Engine, CharCodeAt, 1), true, false, true);
            FastAddProperty("concat", new ClrFunctionInstance(Engine, Concat, 1), true, false, true);
            FastAddProperty("indexOf", new ClrFunctionInstance(Engine, IndexOf, 1), true, false, true);
            FastAddProperty("lastIndexOf", new ClrFunctionInstance(Engine, LastIndexOf, 1), true, false, true);
            FastAddProperty("localeCompare", new ClrFunctionInstance(Engine, LocaleCompare, 1), true, false, true);
            FastAddProperty("match", new ClrFunctionInstance(Engine, Match, 1), true, false, true);
            FastAddProperty("replace", new ClrFunctionInstance(Engine, Replace, 2), true, false, true);
            FastAddProperty("search", new ClrFunctionInstance(Engine, Search, 1), true, false, true);
            FastAddProperty("slice", new ClrFunctionInstance(Engine, Slice, 2), true, false, true);
            FastAddProperty("split", new ClrFunctionInstance(Engine, Split, 2), true, false, true);
            FastAddProperty("substr", new ClrFunctionInstance(Engine, Substr, 2), true, false, true);
            FastAddProperty("substring", new ClrFunctionInstance(Engine, Substring, 2), true, false, true);
            FastAddProperty("toLowerCase", new ClrFunctionInstance(Engine, ToLowerCase), true, false, true);
            FastAddProperty("toLocaleLowerCase", new ClrFunctionInstance(Engine, ToLocaleLowerCase), true, false, true);
            FastAddProperty("toUpperCase", new ClrFunctionInstance(Engine, ToUpperCase), true, false, true);
            FastAddProperty("toLocaleUpperCase", new ClrFunctionInstance(Engine, ToLocaleUpperCase), true, false, true);
            FastAddProperty("trim", new ClrFunctionInstance(Engine, Trim), true, false, true);
        }

        private JsValue ToStringString(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToObject(Engine, thisObj) as StringInstance;
            if (s == null)
            {
                throw new JavaScriptException(Engine.TypeError);
            }

            return s.PrimitiveValue;
        }

        // http://msdn.microsoft.com/en-us/library/system.char.iswhitespace(v=vs.110).aspx
        // http://en.wikipedia.org/wiki/Byte_order_mark
        const char BOM_CHAR = '\uFEFF';
        const char MONGOLIAN_VOWEL_SEPARATOR = '\u180E';

        private static bool IsWhiteSpaceEx(char c)
        {
            return 
                char.IsWhiteSpace(c) || 
                c == BOM_CHAR ||
                // In .NET 4.6 this was removed from WS based on Unicode 6.3 changes
                c == MONGOLIAN_VOWEL_SEPARATOR;
        }

        public static string TrimEndEx(string s)
        {
            if (s.Length == 0)
                return string.Empty;

            var i = s.Length - 1;
            while (i >= 0)
            {
                if (IsWhiteSpaceEx(s[i]))
                    i--;
                else
                    break;
            }
            if (i >= 0)
                return s.Substring(0, i + 1);
            else
                return string.Empty;
        }

        public static string TrimStartEx(string s)
        {
            if (s.Length == 0)
                return string.Empty;

            var i = 0;
            while (i < s.Length)
            {
                if (IsWhiteSpaceEx(s[i]))
                    i++;
                else
                    break;
            }
            if (i >= s.Length)
                return string.Empty;
            else
                return s.Substring(i);
        }

        public static string TrimEx(string s)
        {
            return TrimEndEx(TrimStartEx(s));
        } 

        private JsValue Trim(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);
            var s = TypeConverter.ToString(thisObj);
            return TrimEx(s);
        }
        
        private static JsValue ToLocaleUpperCase(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToString(thisObj);
            return s.ToUpper();
        }

        private static JsValue ToUpperCase(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToString(thisObj);
            return s.ToUpperInvariant();
        }

        private static JsValue ToLocaleLowerCase(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToString(thisObj);
            return s.ToLower();
        }

        private static JsValue ToLowerCase(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToString(thisObj);
            return s.ToLowerInvariant();
        }

        private static int ToIntegerSupportInfinity(JsValue numberVal)
        {
            var doubleVal = TypeConverter.ToInteger(numberVal);
            var intVal = (int) doubleVal;
            if (double.IsPositiveInfinity(doubleVal))
                intVal = int.MaxValue;
            else if (double.IsNegativeInfinity(doubleVal))
                intVal = int.MinValue;
            else
                intVal = (int) doubleVal;
            return intVal;
        }

        private JsValue Substring(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);
            var start = TypeConverter.ToNumber(arguments.At(0));
            var end = TypeConverter.ToNumber(arguments.At(1));

            if (double.IsNaN(start) || start < 0)
            {
                start = 0;
            }

            if (double.IsNaN(end) || end < 0)
            {
                end = 0;
            }

            var len = s.Length;
            var intStart = ToIntegerSupportInfinity(start);

            var intEnd = arguments.At(1) == Undefined.Instance ? len : (int)ToIntegerSupportInfinity(end);
            var finalStart = System.Math.Min(len, System.Math.Max(intStart, 0));
            var finalEnd = System.Math.Min(len, System.Math.Max(intEnd, 0));
            // Swap value if finalStart < finalEnd
            var from = System.Math.Min(finalStart, finalEnd);
            var to = System.Math.Max(finalStart, finalEnd);
            return s.Substring(from, to - from);
        }

        private JsValue Substr(JsValue thisObj, JsValue[] arguments)
        {
            var s = TypeConverter.ToString(thisObj);
            var start = TypeConverter.ToInteger(arguments.At(0));
            var length = arguments.At(1) == JsValue.Undefined 
                ? double.PositiveInfinity 
                : TypeConverter.ToInteger(arguments.At(1));

            start = start >= 0 ? start : System.Math.Max(s.Length + start, 0);
            length = System.Math.Min(System.Math.Max(length, 0), s.Length - start);
            if (length <= 0)
            {
                return "";
            }

            return s.Substring(TypeConverter.ToInt32(start), TypeConverter.ToInt32(length));
        }

        private JsValue Split(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);
            var s = TypeConverter.ToString(thisObj);

            var separator = arguments.At(0);

            // Coerce into a number, true will become 1 
            var l = arguments.At(1);
            var a = (ArrayInstance) Engine.Array.Construct(Arguments.Empty);
            var limit = l == Undefined.Instance ? UInt32.MaxValue : TypeConverter.ToUint32(l);
            var len = s.Length;
            
            if (limit == 0)
            {
                return a;
            }

            if (separator == Null.Instance)
            {
                separator = Null.Text;
            }
            else if (separator == Undefined.Instance)
            {
                return (ArrayInstance)Engine.Array.Construct(Arguments.From(s));
            }
            else
            {
                if (!separator.IsRegExp())
                {
                    separator = TypeConverter.ToString(separator); // Coerce into a string, for an object call toString()
                }
            }

            const string regExpForMatchingAllCharactere = "(?:)";

            if (TypeConverter.ToObject(Engine, separator) is RegExpInstance rx &&
                rx.Source != regExpForMatchingAllCharactere // We need pattern to be defined -> for s.split(new RegExp) 
                )
            {
                var match = rx.Value.Match(s, 0);

                if (!match.Success) // No match at all return the string in an array
                {
                    a.DefineOwnProperty("0", new PropertyDescriptor(s, true, true, true), false);
                    return a;
                }

                int lastIndex = 0;
                int index = 0;
                while (match.Success && index < limit)
                {
                    if (match.Length == 0 && (match.Index == 0 || match.Index == len || match.Index == lastIndex))
                    {
                        match = match.NextMatch();
                        continue;
                    }

                    // Add the match results to the array.
                    a.DefineOwnProperty(index++.ToString(), new PropertyDescriptor(s.Substring(lastIndex, match.Index - lastIndex), true, true, true), false);
                    
                    if (index >= limit)
                    {
                        return a;
                    }

                    lastIndex = match.Index + match.Length;
                    for (int i = 1; i < match.Groups.Count; i++)
                    {
                        var group = match.Groups[i];
                        var item = Undefined.Instance;
                        if (group.Captures.Count > 0)
                        {
                            item = match.Groups[i].Value;
                        }

                        a.DefineOwnProperty(index++.ToString(), new PropertyDescriptor(item, true, true, true ), false);

                        if (index >= limit)
                        {
                            return a;
                        }
                    }

                    match = match.NextMatch();
                    if (!match.Success) // Add the last part of the split
                    {
                        a.DefineOwnProperty(index++.ToString(), new PropertyDescriptor(s.Substring(lastIndex), true, true, true), false);                        
                    }
                }

                return a;
            }
            else
            {
                var segments = new List<string>();
                var sep = TypeConverter.ToString(separator);

                if (sep == string.Empty || (TypeConverter.ToObject(Engine, separator) is RegExpInstance rx && rx.Source == regExpForMatchingAllCharactere)) // for s.split(new RegExp)
                {
                    foreach (var c in s)
                    {
                        segments.Add(c.ToString());    
                    }
                }
                else
                {
                    segments = s.Split(new[] {sep}, StringSplitOptions.None).ToList();
                }

                for (int i = 0; i < segments.Count && i < limit; i++)
                {
                    a.DefineOwnProperty(i.ToString(), new PropertyDescriptor(segments[i], true, true, true), false);
                }
            
                return a;
            }
        }

        private JsValue Slice(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);

            var start = TypeConverter.ToNumber(arguments.At(0));
            if (double.NegativeInfinity.Equals(start))
            {
                start = 0;
            }
            if (double.PositiveInfinity.Equals(start))
            {
                return string.Empty;
            }
            
            var end = TypeConverter.ToNumber(arguments.At(1));
            if (double.PositiveInfinity.Equals(end))
            {
                end = s.Length;
            }

            var len = s.Length;
            var intStart = (int)TypeConverter.ToInteger(start);
            var intEnd = arguments.At(1) == Undefined.Instance ? len : (int)TypeConverter.ToInteger(end);
            var from = intStart < 0 ? System.Math.Max(len + intStart, 0) : System.Math.Min(intStart, len);
            var to = intEnd < 0 ? System.Math.Max(len + intEnd, 0) : System.Math.Min(intEnd, len);
            var span = System.Math.Max(to - from, 0);

            return s.Substring(from, span);
        }

        private JsValue Search(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);

            var regex = arguments.At(0);

            if (regex.IsUndefined())
            {
                regex = string.Empty;
            }
            else if (regex.IsNull())
            {
                regex = Null.Text;
            }

            var rx = TypeConverter.ToObject(Engine, regex) as RegExpInstance ?? (RegExpInstance)Engine.RegExp.Construct(new[] { regex });
            var match = rx.Value.Match(s);
            if (!match.Success)
            {
                return -1;
            }

            return match.Index;
        }

        private JsValue Replace(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var thisString = TypeConverter.ToString(thisObj);
            var searchValue = arguments.At(0);
            var replaceValue = arguments.At(1);

            // If the second parameter is not a function we create one
            var replaceFunction = replaceValue.TryCast<FunctionInstance>();
            if (replaceFunction == null)
            {
                replaceFunction = new ClrFunctionInstance(Engine, (self, args) =>
                {
                    var replaceString = TypeConverter.ToString(replaceValue);
                    var matchValue = TypeConverter.ToString(args.At(0));
                    var matchIndex = (int)TypeConverter.ToInteger(args.At(args.Length - 2));

                    // Check if the replacement string contains any patterns.
                    bool replaceTextContainsPattern = replaceString.IndexOf('$') >= 0;

                    // If there is no pattern, replace the pattern as is.
                    if (replaceTextContainsPattern == false)
                        return replaceString;

                    // Patterns
                    // $$	Inserts a "$".
                    // $&	Inserts the matched substring.
                    // $`	Inserts the portion of the string that precedes the matched substring.
                    // $'	Inserts the portion of the string that follows the matched substring.
                    // $n or $nn	Where n or nn are decimal digits, inserts the nth parenthesized submatch string, provided the first argument was a RegExp object.
                    var replacementBuilder = new StringBuilder();
                    for (int i = 0; i < replaceString.Length; i++)
                    {
                        char c = replaceString[i];
                        if (c == '$' && i < replaceString.Length - 1)
                        {
                            c = replaceString[++i];
                            if (c == '$')
                                replacementBuilder.Append('$');
                            else if (c == '&')
                                replacementBuilder.Append(matchValue);
                            else if (c == '`')
                                replacementBuilder.Append(thisString.Substring(0, matchIndex));
                            else if (c == '\'')
                                replacementBuilder.Append(thisString.Substring(matchIndex + matchValue.Length));
                            else if (c >= '0' && c <= '9')
                            {
                                int matchNumber1 = c - '0';

                                // The match number can be one or two digits long.
                                int matchNumber2 = 0;
                                if (i < replaceString.Length - 1 && replaceString[i + 1] >= '0' && replaceString[i + 1] <= '9')
                                    matchNumber2 = matchNumber1 * 10 + (replaceString[i + 1] - '0');

                                // Try the two digit capture first.
                                if (matchNumber2 > 0 && matchNumber2 < args.Length - 2)
                                {
                                    // Two digit capture replacement.
                                    replacementBuilder.Append(TypeConverter.ToString(args[matchNumber2]));
                                    i++;
                                }
                                else if (matchNumber1 > 0 && matchNumber1 < args.Length - 2)
                                {
                                    // Single digit capture replacement.
                                    replacementBuilder.Append(TypeConverter.ToString(args[matchNumber1]));
                                }
                                else
                                {
                                    // Capture does not exist.
                                    replacementBuilder.Append('$');
                                    i--;
                                }
                            }
                            else
                            {
                                // Unknown replacement pattern.
                                replacementBuilder.Append('$');
                                replacementBuilder.Append(c);
                            }
                        }
                        else
                            replacementBuilder.Append(c);
                    }

                    return replacementBuilder.ToString();
                });
            }

            // searchValue is a regular expression

            if (searchValue.IsNull()) 
            {
                searchValue = new JsValue(Null.Text);
            }
            if (searchValue.IsUndefined())
            {
                searchValue = new JsValue(Undefined.Text);
            }

            if (TypeConverter.ToObject(Engine, searchValue) is RegExpInstance rx)
            {
                // Replace the input string with replaceText, recording the last match found.
                string result = rx.Value.Replace(thisString, match =>
                {
                    var args = new List<JsValue>();
                    
                    for (var k = 0; k < match.Groups.Count; k++)
                    {
                        var group = match.Groups[k];
                        args.Add(group.Value);
                    }
                    
                    args.Add(match.Index);
                    args.Add(thisString);

                    var v = TypeConverter.ToString(replaceFunction.Call(Undefined.Instance, args.ToArray()));
                    return v;
                }, rx.Global == true ? -1 : 1);

                // Set the deprecated RegExp properties if at least one match was found.
                //if (lastMatch != null)
                //    this.Engine.RegExp.SetDeprecatedProperties(input, lastMatch);

                return result;
            }

            // searchValue is a string
            else
            {
                var substr = TypeConverter.ToString(searchValue);

                // Find the first occurrance of substr.
                int start = thisString.IndexOf(substr, StringComparison.Ordinal);
                if (start == -1)
                    return thisString;
                int end = start + substr.Length;

                var args = new List<JsValue>();
                args.Add(substr);
                args.Add(start);
                args.Add(thisString);

                var replaceString = TypeConverter.ToString(replaceFunction.Call(Undefined.Instance, args.ToArray()));

                // Replace only the first match.
                var result = new StringBuilder(thisString.Length + (substr.Length - substr.Length));
                result.Append(thisString, 0, start);
                result.Append(replaceString);
                result.Append(thisString, end, thisString.Length - end);
                return result.ToString();
            }
        }

        private JsValue Match(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);

            var regex = arguments.At(0);
            var rx = regex.TryCast<RegExpInstance>();

            rx = rx ?? (RegExpInstance) Engine.RegExp.Construct(new[] {regex});

            var global = rx.Get("global").AsBoolean();
            if (!global)
            {
                return Engine.RegExp.PrototypeObject.Exec(rx, Arguments.From(s));
            }
            else
            {
                rx.Put("lastIndex", 0, false);
                var a = Engine.Array.Construct(Arguments.Empty);
                double previousLastIndex = 0;
                var n = 0;
                var lastMatch = true;
                while (lastMatch)
                {
                    var result = Engine.RegExp.PrototypeObject.Exec(rx, Arguments.From(s)).TryCast<ObjectInstance>();
                    if (result == null)
                    {
                        lastMatch = false;
                    }
                    else
                    {
                        var thisIndex = rx.Get("lastIndex").AsNumber();
                        if (thisIndex == previousLastIndex)
                        {
                            rx.Put("lastIndex", thisIndex + 1, false);
                            previousLastIndex = thisIndex;
                        }

                        var matchStr = result.Get("0");
                        a.DefineOwnProperty(TypeConverter.ToString(n), new PropertyDescriptor(matchStr, true, true, true), false);
                        n++;
                    }
                }
                if (n == 0)
                {
                    return Null.Instance;
                }
                return a;
            }

        }

        private JsValue LocaleCompare(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);
            var that = TypeConverter.ToString(arguments.At(0));
            
            return string.CompareOrdinal(s, that);
        }

        private JsValue LastIndexOf(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);
            var searchStr = TypeConverter.ToString(arguments.At(0));
            double numPos = double.NaN;
            if (arguments.Length > 1 && arguments[1] != Undefined.Instance)
            {
                numPos = TypeConverter.ToNumber(arguments[1]);
            }

            var pos = double.IsNaN(numPos) ? double.PositiveInfinity : TypeConverter.ToInteger(numPos);

            var len = s.Length;
            var start = (int)System.Math.Min(System.Math.Max(pos, 0), len);
            var searchLen = searchStr.Length;

            var i = start;
            bool found;

            do
            {
                found = true;
                var j = 0;

                while (found && j < searchLen)
                {
                    if ((i + searchLen > len) || (s[i + j] != searchStr[j]))
                    {
                        found = false;
                    }
                    else
                    {
                        j++;
                    }
                }
                if (!found)
                {
                    i--;
                }

            } while (!found && i >= 0);

            return i;
        }

        private JsValue IndexOf(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);
            var searchStr = TypeConverter.ToString(arguments.At(0));
            double pos = 0;
            if (arguments.Length > 1 && arguments[1] != Undefined.Instance)
            {
                pos = TypeConverter.ToInteger(arguments[1]);
            }

            if (pos >= s.Length)
            {
                return -1;
            }

            if (pos < 0)
            {
                pos = 0;
            }

            return s.IndexOf(searchStr, (int) pos, StringComparison.Ordinal);
        }

        private JsValue Concat(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            var s = TypeConverter.ToString(thisObj);
            var sb = new StringBuilder(s);
            for (int i = 0; i < arguments.Length; i++)
            {
                sb.Append(TypeConverter.ToString(arguments[i]));
            }

            return sb.ToString();
        }

        private JsValue CharCodeAt(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);

            JsValue pos = arguments.Length > 0 ? arguments[0] : 0;
            var s = TypeConverter.ToString(thisObj);
            var position = (int)TypeConverter.ToInteger(pos);
            if (position < 0 || position >= s.Length)
            {
                return double.NaN;
            }
            return s[position];
        }

        private JsValue CharAt(JsValue thisObj, JsValue[] arguments)
        {
            TypeConverter.CheckObjectCoercible(Engine, thisObj);
            var s = TypeConverter.ToString(thisObj);
            var position = TypeConverter.ToInteger(arguments.At(0));
            var size = s.Length;
            if (position >= size || position < 0)
            {
                return "";
            }
            return s[(int) position].ToString();

        }

        private JsValue ValueOf(JsValue thisObj, JsValue[] arguments)
        {
            var s = thisObj.TryCast<StringInstance>();
            if (s == null)
            {
                throw new JavaScriptException(Engine.TypeError);
            }

            return s.PrimitiveValue;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\Jint\Native\String\StringPrototype.cs(321,105): error CS0136: A local or parameter named 'rx' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 4 - MergeSequentialChecksRewriterR2
Filepath: D:\a\1\s\Kooboo.Lib\Jint\Runtime\Debugger\DebugHandler.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Jint.Native;
using Jint.Parser.Ast;
using Jint.Runtime.Environments;
using Jint.Runtime.References;

namespace Jint.Runtime.Debugger
{
    internal class DebugHandler
    {
        private readonly Stack<string> _debugCallStack;
        private StepMode _stepMode;
        private int _callBackStepOverDepth;
        private readonly Engine _engine;

        public DebugHandler(Engine engine)
        {
            _engine = engine;
            _debugCallStack = new Stack<string>();
            // _stepMode = StepMode.Into;
            // edit Guoqi
            _stepMode = StepMode.None;
        }

        public StepMode SetMode(StepMode stepMode)
        {
            var old = _stepMode;
            _stepMode = stepMode;
            return old;
        }

        internal void PopDebugCallStack()
        {
            if (_debugCallStack.Count > 0)
            {
                _debugCallStack.Pop();
            }
            if (_stepMode == StepMode.Out && _debugCallStack.Count < _callBackStepOverDepth)
            {
                _callBackStepOverDepth = _debugCallStack.Count;
                _stepMode = StepMode.Into;
            }
            else if (_stepMode == StepMode.Over && _debugCallStack.Count == _callBackStepOverDepth)
            {
                _callBackStepOverDepth = _debugCallStack.Count;
                _stepMode = StepMode.Into;
            }
        }

        internal void AddToDebugCallStack(CallExpression callExpression)
        {
            var identifier = callExpression.Callee as Identifier;
            if (identifier != null)
            {
                var stack = identifier.Name + "(";
                var paramStrings = new List<string>();

                foreach (var argument in callExpression.Arguments)
                {
                    if (argument != null)
                    {
                        var argIdentifier = argument as Identifier;
                        paramStrings.Add(argIdentifier != null ? argIdentifier.Name : "null");
                    }
                    else
                    {
                        paramStrings.Add("null");
                    }
                }

                stack += string.Join(", ", paramStrings);
                stack += ")";
                _debugCallStack.Push(stack);
            }
        }

        internal void OnStep(Statement statement)
        {
            var old = _stepMode;
            if (statement == null)
            {
                return;
            }

            BreakPoint breakpoint = _engine.BreakPoints.FirstOrDefault(breakPoint => BpTest(statement, breakPoint));
            bool breakpointFound = false;

            if (breakpoint != null)
            {
                DebugInformation info = CreateDebugInformation(statement);
                var result = _engine.InvokeBreakEvent(info);
                if (result.HasValue)
                {
                    _stepMode = result.Value;
                    breakpointFound = true;
                }
            }

            if (breakpointFound == false && _stepMode == StepMode.Into)
            {
                DebugInformation info = CreateDebugInformation(statement);
                var result = _engine.InvokeStepEvent(info);
                if (result.HasValue)
                {
                    _stepMode = result.Value;
                }
            }

            //add StepMode.None to fix line 22 changed on this document
            if ((old == StepMode.Into || old == StepMode.None) && _stepMode == StepMode.Out)
            {
                _callBackStepOverDepth = _debugCallStack.Count;
            }
            else if ((old == StepMode.Into || old == StepMode.None) && _stepMode == StepMode.Over)
            {
                var expressionStatement = statement as ExpressionStatement;
                if (expressionStatement != null && expressionStatement.Expression is CallExpression)
                {
                    _callBackStepOverDepth = _debugCallStack.Count;
                }
                else
                {
                    _stepMode = StepMode.Into;
                }
            }
        }

        private bool BpTest(Statement statement, BreakPoint breakpoint)
        {

            bool afterStart, beforeEnd;

            //afterStart = (breakpoint.Line == statement.Location.Start.Line &&
            //                 breakpoint.Char >= statement.Location.Start.Column);
            //our breakpoint column always start with zero,so it don't need to compare the start column
            afterStart = (breakpoint.Line == statement.Location.Start.Line);

            if (!afterStart)
            {
                return false;
            }

            beforeEnd = breakpoint.Line < statement.Location.End.Line
                        || (breakpoint.Line == statement.Location.End.Line &&
                            breakpoint.Char <= statement.Location.End.Column);

            if (!beforeEnd)
            {
                return false;
            }

            if (!string.IsNullOrEmpty(breakpoint.Condition))
            {
                return _engine.Execute(breakpoint.Condition).GetCompletionValue().AsBoolean();
            }

            return true;
        }

        public DebugInformation GetDebugInformation()
        {
            var info = new DebugInformation();
            if (_engine.ExecutionContext != null && _engine.ExecutionContext.LexicalEnvironment != null)
            {
                var lexicalEnvironment = _engine.ExecutionContext.LexicalEnvironment;
                info.Locals = GetLocalVariables(lexicalEnvironment);
                info.Globals = GetGlobalVariables(lexicalEnvironment);
            }
            return info;
        }

        private DebugInformation CreateDebugInformation(Statement statement)
        {
            var info = new DebugInformation { CurrentStatement = statement, CallStack = _debugCallStack };

            if (_engine.ExecutionContext != null && _engine.ExecutionContext.LexicalEnvironment != null)
            {
                var lexicalEnvironment = _engine.ExecutionContext.LexicalEnvironment;
                info.Locals = GetLocalVariables(lexicalEnvironment);
                info.Globals = GetGlobalVariables(lexicalEnvironment);
            }

            return info;
        }

        private static Dictionary<string, JsValue> GetLocalVariables(LexicalEnvironment lex)
        {
            Dictionary<string, JsValue> locals = new Dictionary<string, JsValue>();
            if (lex != null && lex.Record != null)
            {
                AddRecordsFromEnvironment(lex, locals);
            }
            return locals;
        }

        private static Dictionary<string, JsValue> GetGlobalVariables(LexicalEnvironment lex)
        {
            Dictionary<string, JsValue> globals = new Dictionary<string, JsValue>();
            LexicalEnvironment tempLex = lex;

            while (tempLex != null && tempLex.Record != null)
            {
                AddRecordsFromEnvironment(tempLex, globals);
                tempLex = tempLex.Outer;
            }
            return globals;
        }

        private static void AddRecordsFromEnvironment(LexicalEnvironment lex, Dictionary<string, JsValue> locals)
        {
            var bindings = lex.Record.GetAllBindingNames();
            foreach (var binding in bindings)
            {
                if (locals.ContainsKey(binding) == false)
                {
                    var jsValue = lex.Record.GetBindingValue(binding, false);
                    if (jsValue.TryCast<ICallable>() == null)
                    {
                        locals.Add(binding, jsValue);
                    }
                }
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Jint.Native;
using Jint.Parser.Ast;
using Jint.Runtime.Environments;
using Jint.Runtime.References;

namespace Jint.Runtime.Debugger
{
    internal class DebugHandler
    {
        private readonly Stack<string> _debugCallStack;
        private StepMode _stepMode;
        private int _callBackStepOverDepth;
        private readonly Engine _engine;

        public DebugHandler(Engine engine)
        {
            _engine = engine;
            _debugCallStack = new Stack<string>();
            // _stepMode = StepMode.Into;
            // edit Guoqi
            _stepMode = StepMode.None;
        }

        public StepMode SetMode(StepMode stepMode)
        {
            var old = _stepMode;
            _stepMode = stepMode;
            return old;
        }

        internal void PopDebugCallStack()
        {
            if (_debugCallStack.Count > 0)
            {
                _debugCallStack.Pop();
            }
            if (_stepMode == StepMode.Out && _debugCallStack.Count < _callBackStepOverDepth)
            {
                _callBackStepOverDepth = _debugCallStack.Count;
                _stepMode = StepMode.Into;
            }
            else if (_stepMode == StepMode.Over && _debugCallStack.Count == _callBackStepOverDepth)
            {
                _callBackStepOverDepth = _debugCallStack.Count;
                _stepMode = StepMode.Into;
            }
        }

        internal void AddToDebugCallStack(CallExpression callExpression)
        {
            var identifier = callExpression.Callee as Identifier;
            if (identifier != null)
            {
                var stack = identifier.Name + "(";
                var paramStrings = new List<string>();

                foreach (var argument in callExpression.Arguments)
                {
                    if (argument != null)
                    {
                        var argIdentifier = argument as Identifier;
                        paramStrings.Add(argIdentifier != null ? argIdentifier.Name : "null");
                    }
                    else
                    {
                        paramStrings.Add("null");
                    }
                }

                stack += string.Join(", ", paramStrings);
                stack += ")";
                _debugCallStack.Push(stack);
            }
        }

        internal void OnStep(Statement statement)
        {
            var old = _stepMode;
            if (statement == null)
            {
                return;
            }

            BreakPoint breakpoint = _engine.BreakPoints.FirstOrDefault(breakPoint => BpTest(statement, breakPoint));
            bool breakpointFound = false;

            if (breakpoint != null)
            {
                DebugInformation info = CreateDebugInformation(statement);
                var result = _engine.InvokeBreakEvent(info);
                if (result.HasValue)
                {
                    _stepMode = result.Value;
                    breakpointFound = true;
                }
            }

            if (breakpointFound == false && _stepMode == StepMode.Into)
            {
                DebugInformation info = CreateDebugInformation(statement);
                var result = _engine.InvokeStepEvent(info);
                if (result.HasValue)
                {
                    _stepMode = result.Value;
                }
            }

            //add StepMode.None to fix line 22 changed on this document
            if ((old == StepMode.Into || old == StepMode.None) && _stepMode == StepMode.Out)
            {
                _callBackStepOverDepth = _debugCallStack.Count;
            }
            else if ((old == StepMode.Into || old == StepMode.None) && _stepMode == StepMode.Over)
            {
                var expressionStatement = statement as ExpressionStatement;
                if (expressionStatement?.Expression is CallExpression)
                {
                    _callBackStepOverDepth = _debugCallStack.Count;
                }
                else
                {
                    _stepMode = StepMode.Into;
                }
            }
        }

        private bool BpTest(Statement statement, BreakPoint breakpoint)
        {

            bool afterStart, beforeEnd;

            //afterStart = (breakpoint.Line == statement.Location.Start.Line &&
            //                 breakpoint.Char >= statement.Location.Start.Column);
            //our breakpoint column always start with zero,so it don't need to compare the start column
            afterStart = (breakpoint.Line == statement.Location.Start.Line);

            if (!afterStart)
            {
                return false;
            }

            beforeEnd = breakpoint.Line < statement.Location.End.Line
                        || (breakpoint.Line == statement.Location.End.Line &&
                            breakpoint.Char <= statement.Location.End.Column);

            if (!beforeEnd)
            {
                return false;
            }

            if (!string.IsNullOrEmpty(breakpoint.Condition))
            {
                return _engine.Execute(breakpoint.Condition).GetCompletionValue().AsBoolean();
            }

            return true;
        }

        public DebugInformation GetDebugInformation()
        {
            var info = new DebugInformation();
            if (_engine.ExecutionContext != null && _engine.ExecutionContext.LexicalEnvironment != null)
            {
                var lexicalEnvironment = _engine.ExecutionContext.LexicalEnvironment;
                info.Locals = GetLocalVariables(lexicalEnvironment);
                info.Globals = GetGlobalVariables(lexicalEnvironment);
            }
            return info;
        }

        private DebugInformation CreateDebugInformation(Statement statement)
        {
            var info = new DebugInformation { CurrentStatement = statement, CallStack = _debugCallStack };

            if (_engine.ExecutionContext != null && _engine.ExecutionContext.LexicalEnvironment != null)
            {
                var lexicalEnvironment = _engine.ExecutionContext.LexicalEnvironment;
                info.Locals = GetLocalVariables(lexicalEnvironment);
                info.Globals = GetGlobalVariables(lexicalEnvironment);
            }

            return info;
        }

        private static Dictionary<string, JsValue> GetLocalVariables(LexicalEnvironment lex)
        {
            Dictionary<string, JsValue> locals = new Dictionary<string, JsValue>();
            if (lex?.Record != null)
            {
                AddRecordsFromEnvironment(lex, locals);
            }
            return locals;
        }

        private static Dictionary<string, JsValue> GetGlobalVariables(LexicalEnvironment lex)
        {
            Dictionary<string, JsValue> globals = new Dictionary<string, JsValue>();
            LexicalEnvironment tempLex = lex;

            while (tempLex?.Record != null)
            {
                AddRecordsFromEnvironment(tempLex, globals);
                tempLex = tempLex.Outer;
            }
            return globals;
        }

        private static void AddRecordsFromEnvironment(LexicalEnvironment lex, Dictionary<string, JsValue> locals)
        {
            var bindings = lex.Record.GetAllBindingNames();
            foreach (var binding in bindings)
            {
                if (locals.ContainsKey(binding) == false)
                {
                    var jsValue = lex.Record.GetBindingValue(binding, false);
                    if (jsValue.TryCast<ICallable>() == null)
                    {
                        locals.Add(binding, jsValue);
                    }
                }
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Kooboo.Lib\Jint\Runtime\Debugger\DebugHandler.cs(7,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Kooboo.Lib\Jint\Runtime\Debugger\DebugHandler.cs(1,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\Jint\Runtime\Debugger\DebugHandler.cs(119,56): error CS8370: Feature 'type pattern' is not available in C# 7.3. Please use language version 9.0 or greater.,D:\a\1\s\Kooboo.Lib\Jint\Runtime\Debugger\DebugHandler.cs(7,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Kooboo.Lib\Jint\Runtime\Debugger\DebugHandler.cs(1,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\Jint\Runtime\ExpressionIntepreter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Linq;
using Jint.Native;
using Jint.Native.Function;
using Jint.Native.Number;
using Jint.Parser.Ast;
using Jint.Runtime.Descriptors;
using Jint.Runtime.Environments;
using Jint.Runtime.Interop;
using Jint.Runtime.References;

namespace Jint.Runtime
{
    public class ExpressionInterpreter
    {
        private readonly Engine _engine;

        public ExpressionInterpreter(Engine engine)
        {
            _engine = engine;
        }

        private object EvaluateExpression(Expression expression)
        {
            return _engine.EvaluateExpression(expression);
        }

        public JsValue EvaluateConditionalExpression(ConditionalExpression conditionalExpression)
        {
            var lref = _engine.EvaluateExpression(conditionalExpression.Test);
            if (TypeConverter.ToBoolean(_engine.GetValue(lref)))
            {
                var trueRef = _engine.EvaluateExpression(conditionalExpression.Consequent);
                return _engine.GetValue(trueRef);
            }
            else
            {
                var falseRef = _engine.EvaluateExpression(conditionalExpression.Alternate);
                return _engine.GetValue(falseRef);
            }
        }

        public JsValue EvaluateAssignmentExpression(AssignmentExpression assignmentExpression)
        {
            var lref = EvaluateExpression(assignmentExpression.Left) as Reference;
            JsValue rval = _engine.GetValue(EvaluateExpression(assignmentExpression.Right));

            if (lref == null)
            {
                throw new JavaScriptException(_engine.ReferenceError);
            }

            if (assignmentExpression.Operator == AssignmentOperator.Assign) // "="
            {

                if(lref.IsStrict() && lref.GetBase().TryCast<EnvironmentRecord>() != null && (lref.GetReferencedName() == "eval" || lref.GetReferencedName() == "arguments"))
                {
                    throw new JavaScriptException(_engine.SyntaxError);
                }

                _engine.PutValue(lref, rval);
                return rval;
            }

            JsValue lval = _engine.GetValue(lref);

            switch (assignmentExpression.Operator)
            {
                case AssignmentOperator.PlusAssign:
                    var lprim = TypeConverter.ToPrimitive(lval);
                    var rprim = TypeConverter.ToPrimitive(rval);
                    if (lprim.IsString() || rprim.IsString())
                    {
                        lval = TypeConverter.ToString(lprim) + TypeConverter.ToString(rprim);
                    }
                    else
                    {
                        lval = TypeConverter.ToNumber(lprim) + TypeConverter.ToNumber(rprim);
                    }
                    break;

                case AssignmentOperator.MinusAssign:
                    lval = TypeConverter.ToNumber(lval) - TypeConverter.ToNumber(rval);
                    break;

                case AssignmentOperator.TimesAssign:
                    if (lval == Undefined.Instance || rval == Undefined.Instance)
                    {
                        lval = Undefined.Instance;
                    }
                    else
                    {
                        lval = TypeConverter.ToNumber(lval) * TypeConverter.ToNumber(rval);
                    }
                    break;

                case AssignmentOperator.DivideAssign:
                    lval = Divide(lval, rval);
                    break;

                case AssignmentOperator.ModuloAssign:
                    if (lval == Undefined.Instance || rval == Undefined.Instance)
                    {
                        lval = Undefined.Instance;
                    }
                    else
                    {
                        lval = TypeConverter.ToNumber(lval) % TypeConverter.ToNumber(rval);
                    }
                    break;

                case AssignmentOperator.BitwiseAndAssign:
                    lval = TypeConverter.ToInt32(lval) & TypeConverter.ToInt32(rval);
                    break;

                case AssignmentOperator.BitwiseOrAssign:
                    lval = TypeConverter.ToInt32(lval) | TypeConverter.ToInt32(rval);
                    break;

                case AssignmentOperator.BitwiseXOrAssign:
                    lval = TypeConverter.ToInt32(lval) ^ TypeConverter.ToInt32(rval);
                    break;

                case AssignmentOperator.LeftShiftAssign:
                    lval = TypeConverter.ToInt32(lval) << (int)(TypeConverter.ToUint32(rval) & 0x1F);
                    break;

                case AssignmentOperator.RightShiftAssign:
                    lval = TypeConverter.ToInt32(lval) >> (int)(TypeConverter.ToUint32(rval) & 0x1F);
                    break;

                case AssignmentOperator.UnsignedRightShiftAssign:
                    lval = (uint)TypeConverter.ToInt32(lval) >> (int)(TypeConverter.ToUint32(rval) & 0x1F);
                    break;

                default:
                    throw new NotImplementedException();

            }

            _engine.PutValue(lref, lval);

            return lval;
        }

        private JsValue Divide(JsValue lval, JsValue rval)
        {
            if (lval == Undefined.Instance || rval == Undefined.Instance)
            {
                return Undefined.Instance;
            }
            else
            {
                var lN = TypeConverter.ToNumber(lval);
                var rN = TypeConverter.ToNumber(rval);

                if (double.IsNaN(rN) || double.IsNaN(lN))
                {
                    return double.NaN;
                }

                if (double.IsInfinity(lN) && double.IsInfinity(rN))
                {
                    return double.NaN;
                }

                if (double.IsInfinity(lN) && rN.Equals(0))
                {
                    if (NumberInstance.IsNegativeZero(rN))
                    {
                        return -lN;
                    }

                    return lN;
                }

                if (lN.Equals(0) && rN.Equals(0))
                {
                    return double.NaN;
                }

                if (rN.Equals(0))
                {
                    if (NumberInstance.IsNegativeZero(rN))
                    {
                        return lN > 0 ? -double.PositiveInfinity : -double.NegativeInfinity;
                    }

                    return lN > 0 ? double.PositiveInfinity : double.NegativeInfinity;
                }

                return lN/rN;
            }
        }

        public JsValue EvaluateBinaryExpression(BinaryExpression expression)
        {
            var leftExpression = EvaluateExpression(expression.Left);
            JsValue left = _engine.GetValue(leftExpression);

            var rightExpression = EvaluateExpression(expression.Right);
            JsValue right = _engine.GetValue(rightExpression);

            JsValue value;

            switch (expression.Operator)
            {
                case BinaryOperator.Plus:
                    var lprim = TypeConverter.ToPrimitive(left);
                    var rprim = TypeConverter.ToPrimitive(right);
                    if (lprim.IsString() || rprim.IsString())
                    {
                        value = TypeConverter.ToString(lprim) + TypeConverter.ToString(rprim);
                    }
                    else
                    {
                        value = TypeConverter.ToNumber(lprim) + TypeConverter.ToNumber(rprim);
                    }
                    break;

                case BinaryOperator.Minus:
                    value = TypeConverter.ToNumber(left) - TypeConverter.ToNumber(right);
                    break;

                case BinaryOperator.Times:
                    if (left == Undefined.Instance || right == Undefined.Instance)
                    {
                        value = Undefined.Instance;
                    }
                    else
                    {
                        value = TypeConverter.ToNumber(left) * TypeConverter.ToNumber(right);
                    }
                    break;

                case BinaryOperator.Divide:
                    value = Divide(left, right);
                    break;

                case BinaryOperator.Modulo:
                    if (left == Undefined.Instance || right == Undefined.Instance)
                    {
                        value = Undefined.Instance;
                    }
                    else
                    {
                        value = TypeConverter.ToNumber(left) % TypeConverter.ToNumber(right);
                    }
                    break;

                case BinaryOperator.Equal:
                    value = Equal(left, right);
                    break;

                case BinaryOperator.NotEqual:
                    value = !Equal(left, right);
                    break;

                case BinaryOperator.Greater:
                    value = Compare(right, left, false);
                    if (value == Undefined.Instance)
                    {
                        value = false;
                    }
                    break;

                case BinaryOperator.GreaterOrEqual:
                    value = Compare(left, right);
                    if (value == Undefined.Instance || value.AsBoolean())
                    {
                        value = false;
                    }
                    else
                    {
                        value = true;
                    }
                    break;

                case BinaryOperator.Less:
                    value = Compare(left, right);
                    if (value == Undefined.Instance)
                    {
                        value = false;
                    }
                    break;

                case BinaryOperator.LessOrEqual:
                    value = Compare(right, left, false);
                    if (value == Undefined.Instance || value.AsBoolean())
                    {
                        value = false;
                    }
                    else
                    {
                        value = true;
                    }
                    break;

                case BinaryOperator.StrictlyEqual:
                    return StrictlyEqual(left, right);

                case BinaryOperator.StricltyNotEqual:
                    return !StrictlyEqual(left, right);

                case BinaryOperator.BitwiseAnd:
                    return TypeConverter.ToInt32(left) & TypeConverter.ToInt32(right);

                case BinaryOperator.BitwiseOr:
                    return TypeConverter.ToInt32(left) | TypeConverter.ToInt32(right);

                case BinaryOperator.BitwiseXOr:
                    return TypeConverter.ToInt32(left) ^ TypeConverter.ToInt32(right);

                case BinaryOperator.LeftShift:
                    return TypeConverter.ToInt32(left) << (int)(TypeConverter.ToUint32(right) & 0x1F);

                case BinaryOperator.RightShift:
                    return TypeConverter.ToInt32(left) >> (int)(TypeConverter.ToUint32(right) & 0x1F);

                case BinaryOperator.UnsignedRightShift:
                    return (uint)TypeConverter.ToInt32(left) >> (int)(TypeConverter.ToUint32(right) & 0x1F);

                case BinaryOperator.InstanceOf:
                    var f = right.TryCast<FunctionInstance>();

                    if (f == null)
                    {
                        throw new JavaScriptException(_engine.TypeError, "instanceof can only be used with a function object");
                    }

                    value = f.HasInstance(left);
                    break;

                case BinaryOperator.In:
                    if (!right.IsObject())
                    {
                        throw new JavaScriptException(_engine.TypeError, "in can only be used with an object");
                    }

                    value = right.AsObject().HasProperty(TypeConverter.ToString(left));
                    break;

                default:
                    throw new NotImplementedException();
            }

            return value;
        }

        public JsValue EvaluateLogicalExpression(LogicalExpression logicalExpression)
        {
            var left = _engine.GetValue(EvaluateExpression(logicalExpression.Left));

            switch (logicalExpression.Operator)
            {

                case LogicalOperator.LogicalAnd:
                    if (!TypeConverter.ToBoolean(left))
                    {
                        return left;
                    }

                    return _engine.GetValue(EvaluateExpression(logicalExpression.Right));

                case LogicalOperator.LogicalOr:
                    if (TypeConverter.ToBoolean(left))
                    {
                        return left;
                    }

                    return _engine.GetValue(EvaluateExpression(logicalExpression.Right));

                default:
                    throw new NotImplementedException();
            }
        }

        public static bool Equal(JsValue x, JsValue y)
        {
            var typex = x.Type;
            var typey = y.Type;

            if (typex == typey)
            {
				return StrictlyEqual(x, y);
            }

            if (x == Null.Instance && y == Undefined.Instance)
            {
                return true;
            }

            if (x == Undefined.Instance && y == Null.Instance)
            {
                return true;
            }

            if (typex == Types.Number && typey == Types.String)
            {
                return Equal(x, TypeConverter.ToNumber(y));
            }

            if (typex == Types.String && typey == Types.Number)
            {
                return Equal(TypeConverter.ToNumber(x), y);
            }

            if (typex == Types.Boolean)
            {
                return Equal(TypeConverter.ToNumber(x), y);
            }

            if (typey == Types.Boolean)
            {
                return Equal(x, TypeConverter.ToNumber(y));
            }

            if (typey == Types.Object && (typex == Types.String || typex == Types.Number))
            {
                return Equal(x, TypeConverter.ToPrimitive(y));
            }

            if (typex == Types.Object && (typey == Types.String || typey == Types.Number))
            {
                return Equal(TypeConverter.ToPrimitive(x), y);
            }

            return false;
        }

        public static bool StrictlyEqual(JsValue x, JsValue y)
        {
            var typea = x.Type;
            var typeb = y.Type;

            if (typea != typeb)
            {
                return false;
            }

            if (typea == Types.Undefined || typea == Types.Null)
            {
                return true;
            }

            if (typea == Types.None)
            {
                return true;
            }

            if (typea == Types.Number)
            {
                var nx = x.AsNumber();
                var ny = y.AsNumber();

                if (double.IsNaN(nx) || double.IsNaN(ny))
                {
                    return false;
                }

                if (nx.Equals(ny))
                {
                    return true;
                }

                return false;
            }

            if (typea == Types.String)
            {
                return x.AsString() == y.AsString();
            }

            if (typea == Types.Boolean)
            {
                return x.AsBoolean() == y.AsBoolean();
            }

			if (typea == Types.Object)
			{
				var xw = x.AsObject() as IObjectWrapper;

				if (xw != null)
				{
					var yw = y.AsObject() as IObjectWrapper;
					return Object.Equals(xw.Target, yw.Target);
				}
			}

            return x == y;
        }

        public static bool SameValue(JsValue x, JsValue y)
        {
            var typea = TypeConverter.GetPrimitiveType(x);
            var typeb = TypeConverter.GetPrimitiveType(y);

            if (typea != typeb)
            {
                return false;
            }

            if (typea == Types.None)
            {
                return true;
            }
            if (typea == Types.Number)
            {
                var nx = TypeConverter.ToNumber(x);
                var ny = TypeConverter.ToNumber(y);

                if (double.IsNaN(nx) && double.IsNaN(ny))
                {
                    return true;
                }

                if (nx.Equals(ny))
                {
                    if (nx.Equals(0))
                    {
                        // +0 !== -0
                        return NumberInstance.IsNegativeZero(nx) == NumberInstance.IsNegativeZero(ny);
                    }

                    return true;
                }

                return false;
            }
            if (typea == Types.String)
            {
                return TypeConverter.ToString(x) == TypeConverter.ToString(y);
            }
            if (typea == Types.Boolean)
            {
                return TypeConverter.ToBoolean(x) == TypeConverter.ToBoolean(y);
            }
            return x == y;
        }

        public static JsValue Compare(JsValue x, JsValue y, bool leftFirst = true)
        {
            JsValue px, py;
            if (leftFirst)
            {
                px = TypeConverter.ToPrimitive(x, Types.Number);
                py = TypeConverter.ToPrimitive(y, Types.Number);
            }
            else
            {
                py = TypeConverter.ToPrimitive(y, Types.Number);
                px = TypeConverter.ToPrimitive(x, Types.Number);
            }

            var typea = px.Type;
            var typeb = py.Type;

            if (typea != Types.String || typeb != Types.String)
            {
                var nx = TypeConverter.ToNumber(px);
                var ny = TypeConverter.ToNumber(py);

                if (double.IsNaN(nx) || double.IsNaN(ny))
                {
                    return Undefined.Instance;
                }

                if (nx.Equals(ny))
                {
                    return false;
                }

                if (double.IsPositiveInfinity(nx))
                {
                    return false;
                }

                if (double.IsPositiveInfinity(ny))
                {
                    return true;
                }

                if (double.IsNegativeInfinity(ny))
                {
                    return false;
                }

                if (double.IsNegativeInfinity(nx))
                {
                    return true;
                }

                return nx < ny;
            }
            else
            {
                return String.CompareOrdinal(TypeConverter.ToString(x), TypeConverter.ToString(y)) < 0;
            }
        }

        public Reference EvaluateIdentifier(Identifier identifier)
        {
            var env = _engine.ExecutionContext.LexicalEnvironment;
            var strict = StrictModeScope.IsStrictModeCode;

            return LexicalEnvironment.GetIdentifierReference(env, identifier.Name, strict);
        }

        public JsValue EvaluateLiteral(Literal literal)
        {
            if(literal.Cached)
            {
                return literal.CachedValue;
            }

            if (literal.Type == SyntaxNodes.RegularExpressionLiteral)
            {
				var regexp = _engine.RegExp.Construct(literal.Raw);

				if (regexp.Global)
				{
					// A Global regexp literal can't be cached or its state would evolve
					return regexp;
				}

				literal.CachedValue = regexp;
            }
            else
            {
                literal.CachedValue = JsValue.FromObject(_engine, literal.Value);
            }

            literal.Cached = true;
            return literal.CachedValue;
        }

        public JsValue EvaluateObjectExpression(ObjectExpression objectExpression)
        {
            // http://www.ecma-international.org/ecma-262/5.1/#sec-11.1.5

            var obj = _engine.Object.Construct(Arguments.Empty);
            foreach (var property in objectExpression.Properties)
            {
                var propName = property.Key.GetKey();
                var previous = obj.GetOwnProperty(propName);
                PropertyDescriptor propDesc;

                switch (property.Kind)
                {
                    case PropertyKind.Data:
                        var exprValue = _engine.EvaluateExpression(property.Value);
                        var propValue = _engine.GetValue(exprValue);
                        propDesc = new PropertyDescriptor(propValue, true, true, true);
                        break;

                    case PropertyKind.Get:
                        var getter = property.Value as FunctionExpression;

                        if (getter == null)
                        {
                            throw new JavaScriptException(_engine.SyntaxError);
                        }

                        ScriptFunctionInstance get;
                        using (new StrictModeScope(getter.Strict))
                        {
                            get = new ScriptFunctionInstance(
                                _engine,
                                getter,
                                _engine.ExecutionContext.LexicalEnvironment,
                                StrictModeScope.IsStrictModeCode
                            );
                        }

                        propDesc = new PropertyDescriptor(get: get, set: null, enumerable: true, configurable:true);
                        break;

                    case PropertyKind.Set:
                        var setter = property.Value as FunctionExpression;

                        if (setter == null)
                        {
                            throw new JavaScriptException(_engine.SyntaxError);
                        }

                        ScriptFunctionInstance set;
                        using (new StrictModeScope(setter.Strict))
                        {

                            set = new ScriptFunctionInstance(
                                _engine,
                                setter,
                                _engine.ExecutionContext.LexicalEnvironment,
                                StrictModeScope.IsStrictModeCode
                                );
                        }
                        propDesc = new PropertyDescriptor(get:null, set: set, enumerable: true, configurable: true);
                        break;

                    default:
                        throw new ArgumentOutOfRangeException();
                }

                if (previous != PropertyDescriptor.Undefined)
                {
                    if (StrictModeScope.IsStrictModeCode && previous.IsDataDescriptor() && propDesc.IsDataDescriptor())
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }

                    if (previous.IsDataDescriptor() && propDesc.IsAccessorDescriptor())
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }

                    if (previous.IsAccessorDescriptor() && propDesc.IsDataDescriptor())
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }

                    if (previous.IsAccessorDescriptor() && propDesc.IsAccessorDescriptor())
                    {
                        if (propDesc.Set != null && previous.Set != null)
                        {
                            throw new JavaScriptException(_engine.SyntaxError);
                        }

                        if (propDesc.Get != null && previous.Get != null)
                        {
                            throw new JavaScriptException(_engine.SyntaxError);
                        }
                    }
                }

                obj.DefineOwnProperty(propName, propDesc, false);
            }

            return obj;
        }

        /// <summary>
        /// http://www.ecma-international.org/ecma-262/5.1/#sec-11.2.1
        /// </summary>
        /// <param name="memberExpression"></param>
        /// <returns></returns>
        public Reference EvaluateMemberExpression(MemberExpression memberExpression)
        {
            var baseReference = EvaluateExpression(memberExpression.Object);
            var baseValue = _engine.GetValue(baseReference);
            Expression expression = memberExpression.Property;


            if (!memberExpression.Computed) // index accessor ?
            {
                expression = new Literal { Type = SyntaxNodes.Literal, Value = memberExpression.Property.As<Identifier>().Name };
            }

            var propertyNameReference = EvaluateExpression(expression);
            var propertyNameValue = _engine.GetValue(propertyNameReference);
            TypeConverter.CheckObjectCoercible(_engine, baseValue);
            var propertyNameString = TypeConverter.ToString(propertyNameValue);

            return new Reference(baseValue, propertyNameString, StrictModeScope.IsStrictModeCode);
        }

        public JsValue EvaluateFunctionExpression(FunctionExpression functionExpression)
        {
            var funcEnv = LexicalEnvironment.NewDeclarativeEnvironment(_engine, _engine.ExecutionContext.LexicalEnvironment);
            var envRec = (DeclarativeEnvironmentRecord)funcEnv.Record;

            if (functionExpression.Id != null && !String.IsNullOrEmpty(functionExpression.Id.Name))
            {
                envRec.CreateMutableBinding(functionExpression.Id.Name);
            }

            var closure = new ScriptFunctionInstance(
                _engine,
                functionExpression,
                funcEnv,
                functionExpression.Strict
                );

            if (functionExpression.Id != null && !String.IsNullOrEmpty(functionExpression.Id.Name))
            {
                envRec.InitializeImmutableBinding(functionExpression.Id.Name, closure);
            }

            return closure;
        }

        public JsValue EvaluateCallExpression(CallExpression callExpression)
        {
            var callee = EvaluateExpression(callExpression.Callee);

            if (_engine.Options._IsDebugMode)
            {
                _engine.DebugHandler.AddToDebugCallStack(callExpression);
            }

            JsValue thisObject;

            // todo: implement as in http://www.ecma-international.org/ecma-262/5.1/#sec-11.2.4


            JsValue[] arguments;

            if (callExpression.Cached)
            {
                arguments = callExpression.CachedArguments;
            }
            else
            {
                arguments = callExpression.Arguments.Select(EvaluateExpression).Select(_engine.GetValue).ToArray();

                if (callExpression.CanBeCached)
                {
                    // The arguments array can be cached if they are all literals
                    if (callExpression.Arguments.All(x => x is Literal))
                    {
                        callExpression.CachedArguments = arguments;
                        callExpression.Cached = true;
                    }
                    else
                    {
                        callExpression.CanBeCached = false;
                    }
                }
            }

            var func = _engine.GetValue(callee);

            var r = callee as Reference;

            if (_engine.Options._MaxRecursionDepth >= 0)
            {
                var stackItem = new CallStackElement(callExpression, func, r != null ? r.GetReferencedName() : "anonymous function");

                var recursionDepth = _engine.CallStack.Push(stackItem);

                if (recursionDepth > _engine.Options._MaxRecursionDepth)
                {
                    _engine.CallStack.Pop();
                    throw new RecursionDepthOverflowException(_engine.CallStack, stackItem.ToString());
                }
            }

            if (func == Undefined.Instance)
            {
                throw new JavaScriptException(_engine.TypeError, r == null ? "" : string.Format("Object has no method '{0}'", (callee as Reference).GetReferencedName()));
            }

            if (!func.IsObject())
            {
                throw new JavaScriptException(_engine.TypeError, r == null ? "" : string.Format("Property '{0}' of object is not a function", (callee as Reference).GetReferencedName()));
            }

            var callable = func.TryCast<ICallable>();
            if (callable == null)
            {
                throw new JavaScriptException(_engine.TypeError);
            }

            if (r != null)
            {
                if (r.IsPropertyReference())
                {
                    thisObject = r.GetBase();
                }
                else
                {
                    var env = r.GetBase().TryCast<EnvironmentRecord>();
                    thisObject = env.ImplicitThisValue();
                }
            }
            else
            {
                thisObject = Undefined.Instance;
            }

            // is it a direct call to eval ? http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.2.1.1
            if (r != null && r.GetReferencedName() == "eval" && callable is EvalFunctionInstance)
            {
                return ((EvalFunctionInstance) callable).Call(thisObject, arguments, true);
            }

            var result = callable.Call(thisObject, arguments);

            if (_engine.Options._IsDebugMode)
            {
                _engine.DebugHandler.PopDebugCallStack();
            }

            if (_engine.Options._MaxRecursionDepth >= 0)
            {
                _engine.CallStack.Pop();
            }

            return result;
        }

        public JsValue EvaluateSequenceExpression(SequenceExpression sequenceExpression)
        {
            var result = Undefined.Instance;
            foreach (var expression in sequenceExpression.Expressions)
            {
                result = _engine.GetValue(_engine.EvaluateExpression(expression));
            }

            return result;
        }

        public JsValue EvaluateUpdateExpression(UpdateExpression updateExpression)
        {
            var value = _engine.EvaluateExpression(updateExpression.Argument);
            Reference r;

            switch (updateExpression.Operator)
            {
                case UnaryOperator.Increment:
                    r = value as Reference;
                    if (r != null
                        && r.IsStrict()
                        && (r.GetBase().TryCast<EnvironmentRecord>() != null)
                        && (Array.IndexOf(new[] { "eval", "arguments" }, r.GetReferencedName()) != -1))
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }

                    var oldValue = TypeConverter.ToNumber(_engine.GetValue(value));
                    var newValue = oldValue + 1;
                    _engine.PutValue(r, newValue);

                    return updateExpression.Prefix ? newValue : oldValue;

                case UnaryOperator.Decrement:
                    r = value as Reference;
                    if (r != null
                        && r.IsStrict()
                        && (r.GetBase().TryCast<EnvironmentRecord>() != null)
                        && (Array.IndexOf(new[] { "eval", "arguments" }, r.GetReferencedName()) != -1))
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }

                    oldValue = TypeConverter.ToNumber(_engine.GetValue(value));
                    newValue = oldValue - 1;
                    _engine.PutValue(r, newValue);

                    return updateExpression.Prefix ? newValue : oldValue;
                default:
                    throw new ArgumentException();
            }

        }

        public JsValue EvaluateThisExpression(ThisExpression thisExpression)
        {
            return _engine.ExecutionContext.ThisBinding;
        }

        public JsValue EvaluateNewExpression(NewExpression newExpression)
        {
            var arguments = newExpression.Arguments.Select(EvaluateExpression).Select(_engine.GetValue).ToArray();

            // todo: optimize by defining a common abstract class or interface
            var callee = _engine.GetValue(EvaluateExpression(newExpression.Callee)).TryCast<IConstructor>();

            if (callee == null)
            {
                throw new JavaScriptException(_engine.TypeError, "The object can't be used as constructor.");
            }

            // construct the new instance using the Function's constructor method
            var instance = callee.Construct(arguments);

            return instance;
        }

        public JsValue EvaluateArrayExpression(ArrayExpression arrayExpression)
        {
            var a = _engine.Array.Construct(new JsValue[] { arrayExpression.Elements.Count() });
            var n = 0;
            foreach (var expr in arrayExpression.Elements)
            {
                if (expr != null)
                {
                    var value = _engine.GetValue(EvaluateExpression(expr));
                    a.DefineOwnProperty(n.ToString(),
                        new PropertyDescriptor(value, true, true, true), false);
                }
                n++;
            }

            return a;
        }

        public JsValue EvaluateUnaryExpression(UnaryExpression unaryExpression)
        {
            var value = _engine.EvaluateExpression(unaryExpression.Argument);
            Reference r;

            switch (unaryExpression.Operator)
            {
                case UnaryOperator.Plus:
                    return TypeConverter.ToNumber(_engine.GetValue(value));

                case UnaryOperator.Minus:
                    var n = TypeConverter.ToNumber(_engine.GetValue(value));
                    return double.IsNaN(n) ? double.NaN : n*-1;

                case UnaryOperator.BitwiseNot:
                    return ~TypeConverter.ToInt32(_engine.GetValue(value));

                case UnaryOperator.LogicalNot:
                    return !TypeConverter.ToBoolean(_engine.GetValue(value));

                case UnaryOperator.Delete:
                    r = value as Reference;
                    if (r == null)
                    {
                        return true;
                    }
                    if (r.IsUnresolvableReference())
                    {
                        if (r.IsStrict())
                        {
                            throw new JavaScriptException(_engine.SyntaxError);
                        }

                        return true;
                    }
                    if (r.IsPropertyReference())
                    {
                        var o = TypeConverter.ToObject(_engine, r.GetBase());
                        return o.Delete(r.GetReferencedName(), r.IsStrict());
                    }
                    if (r.IsStrict())
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }
                    var bindings = r.GetBase().TryCast<EnvironmentRecord>();
                    return bindings.DeleteBinding(r.GetReferencedName());

                case UnaryOperator.Void:
                    _engine.GetValue(value);
                    return Undefined.Instance;

                case UnaryOperator.TypeOf:
                    r = value as Reference;
                    if (r != null)
                    {
                        if (r.IsUnresolvableReference())
                        {
                            return "undefined";
                        }
                    }
                    var v = _engine.GetValue(value);
                    if (v == Undefined.Instance)
                    {
                        return "undefined";
                    }
                    if (v == Null.Instance)
                    {
                        return "object";
                    }
                    switch (v.Type)
                    {
                        case Types.Boolean: return "boolean";
                        case Types.Number: return "number";
                        case Types.String: return "string";
                    }
                    if (v.TryCast<ICallable>() != null)
                    {
                        return "function";
                    }
                    return "object";

                default:
                    throw new ArgumentException();
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Linq;
using Jint.Native;
using Jint.Native.Function;
using Jint.Native.Number;
using Jint.Parser.Ast;
using Jint.Runtime.Descriptors;
using Jint.Runtime.Environments;
using Jint.Runtime.Interop;
using Jint.Runtime.References;

namespace Jint.Runtime
{
    public class ExpressionInterpreter
    {
        private readonly Engine _engine;

        public ExpressionInterpreter(Engine engine)
        {
            _engine = engine;
        }

        private object EvaluateExpression(Expression expression)
        {
            return _engine.EvaluateExpression(expression);
        }

        public JsValue EvaluateConditionalExpression(ConditionalExpression conditionalExpression)
        {
            var lref = _engine.EvaluateExpression(conditionalExpression.Test);
            if (TypeConverter.ToBoolean(_engine.GetValue(lref)))
            {
                var trueRef = _engine.EvaluateExpression(conditionalExpression.Consequent);
                return _engine.GetValue(trueRef);
            }
            else
            {
                var falseRef = _engine.EvaluateExpression(conditionalExpression.Alternate);
                return _engine.GetValue(falseRef);
            }
        }

        public JsValue EvaluateAssignmentExpression(AssignmentExpression assignmentExpression)
        {
            var lref = EvaluateExpression(assignmentExpression.Left) as Reference;
            JsValue rval = _engine.GetValue(EvaluateExpression(assignmentExpression.Right));

            if (lref == null)
            {
                throw new JavaScriptException(_engine.ReferenceError);
            }

            if (assignmentExpression.Operator == AssignmentOperator.Assign) // "="
            {

                if(lref.IsStrict() && lref.GetBase().TryCast<EnvironmentRecord>() != null && (lref.GetReferencedName() == "eval" || lref.GetReferencedName() == "arguments"))
                {
                    throw new JavaScriptException(_engine.SyntaxError);
                }

                _engine.PutValue(lref, rval);
                return rval;
            }

            JsValue lval = _engine.GetValue(lref);

            switch (assignmentExpression.Operator)
            {
                case AssignmentOperator.PlusAssign:
                    var lprim = TypeConverter.ToPrimitive(lval);
                    var rprim = TypeConverter.ToPrimitive(rval);
                    if (lprim.IsString() || rprim.IsString())
                    {
                        lval = TypeConverter.ToString(lprim) + TypeConverter.ToString(rprim);
                    }
                    else
                    {
                        lval = TypeConverter.ToNumber(lprim) + TypeConverter.ToNumber(rprim);
                    }
                    break;

                case AssignmentOperator.MinusAssign:
                    lval = TypeConverter.ToNumber(lval) - TypeConverter.ToNumber(rval);
                    break;

                case AssignmentOperator.TimesAssign:
                    if (lval == Undefined.Instance || rval == Undefined.Instance)
                    {
                        lval = Undefined.Instance;
                    }
                    else
                    {
                        lval = TypeConverter.ToNumber(lval) * TypeConverter.ToNumber(rval);
                    }
                    break;

                case AssignmentOperator.DivideAssign:
                    lval = Divide(lval, rval);
                    break;

                case AssignmentOperator.ModuloAssign:
                    if (lval == Undefined.Instance || rval == Undefined.Instance)
                    {
                        lval = Undefined.Instance;
                    }
                    else
                    {
                        lval = TypeConverter.ToNumber(lval) % TypeConverter.ToNumber(rval);
                    }
                    break;

                case AssignmentOperator.BitwiseAndAssign:
                    lval = TypeConverter.ToInt32(lval) & TypeConverter.ToInt32(rval);
                    break;

                case AssignmentOperator.BitwiseOrAssign:
                    lval = TypeConverter.ToInt32(lval) | TypeConverter.ToInt32(rval);
                    break;

                case AssignmentOperator.BitwiseXOrAssign:
                    lval = TypeConverter.ToInt32(lval) ^ TypeConverter.ToInt32(rval);
                    break;

                case AssignmentOperator.LeftShiftAssign:
                    lval = TypeConverter.ToInt32(lval) << (int)(TypeConverter.ToUint32(rval) & 0x1F);
                    break;

                case AssignmentOperator.RightShiftAssign:
                    lval = TypeConverter.ToInt32(lval) >> (int)(TypeConverter.ToUint32(rval) & 0x1F);
                    break;

                case AssignmentOperator.UnsignedRightShiftAssign:
                    lval = (uint)TypeConverter.ToInt32(lval) >> (int)(TypeConverter.ToUint32(rval) & 0x1F);
                    break;

                default:
                    throw new NotImplementedException();

            }

            _engine.PutValue(lref, lval);

            return lval;
        }

        private JsValue Divide(JsValue lval, JsValue rval)
        {
            if (lval == Undefined.Instance || rval == Undefined.Instance)
            {
                return Undefined.Instance;
            }
            else
            {
                var lN = TypeConverter.ToNumber(lval);
                var rN = TypeConverter.ToNumber(rval);

                if (double.IsNaN(rN) || double.IsNaN(lN))
                {
                    return double.NaN;
                }

                if (double.IsInfinity(lN) && double.IsInfinity(rN))
                {
                    return double.NaN;
                }

                if (double.IsInfinity(lN) && rN.Equals(0))
                {
                    if (NumberInstance.IsNegativeZero(rN))
                    {
                        return -lN;
                    }

                    return lN;
                }

                if (lN.Equals(0) && rN.Equals(0))
                {
                    return double.NaN;
                }

                if (rN.Equals(0))
                {
                    if (NumberInstance.IsNegativeZero(rN))
                    {
                        return lN > 0 ? -double.PositiveInfinity : -double.NegativeInfinity;
                    }

                    return lN > 0 ? double.PositiveInfinity : double.NegativeInfinity;
                }

                return lN/rN;
            }
        }

        public JsValue EvaluateBinaryExpression(BinaryExpression expression)
        {
            var leftExpression = EvaluateExpression(expression.Left);
            JsValue left = _engine.GetValue(leftExpression);

            var rightExpression = EvaluateExpression(expression.Right);
            JsValue right = _engine.GetValue(rightExpression);

            JsValue value;

            switch (expression.Operator)
            {
                case BinaryOperator.Plus:
                    var lprim = TypeConverter.ToPrimitive(left);
                    var rprim = TypeConverter.ToPrimitive(right);
                    if (lprim.IsString() || rprim.IsString())
                    {
                        value = TypeConverter.ToString(lprim) + TypeConverter.ToString(rprim);
                    }
                    else
                    {
                        value = TypeConverter.ToNumber(lprim) + TypeConverter.ToNumber(rprim);
                    }
                    break;

                case BinaryOperator.Minus:
                    value = TypeConverter.ToNumber(left) - TypeConverter.ToNumber(right);
                    break;

                case BinaryOperator.Times:
                    if (left == Undefined.Instance || right == Undefined.Instance)
                    {
                        value = Undefined.Instance;
                    }
                    else
                    {
                        value = TypeConverter.ToNumber(left) * TypeConverter.ToNumber(right);
                    }
                    break;

                case BinaryOperator.Divide:
                    value = Divide(left, right);
                    break;

                case BinaryOperator.Modulo:
                    if (left == Undefined.Instance || right == Undefined.Instance)
                    {
                        value = Undefined.Instance;
                    }
                    else
                    {
                        value = TypeConverter.ToNumber(left) % TypeConverter.ToNumber(right);
                    }
                    break;

                case BinaryOperator.Equal:
                    value = Equal(left, right);
                    break;

                case BinaryOperator.NotEqual:
                    value = !Equal(left, right);
                    break;

                case BinaryOperator.Greater:
                    value = Compare(right, left, false);
                    if (value == Undefined.Instance)
                    {
                        value = false;
                    }
                    break;

                case BinaryOperator.GreaterOrEqual:
                    value = Compare(left, right);
                    if (value == Undefined.Instance || value.AsBoolean())
                    {
                        value = false;
                    }
                    else
                    {
                        value = true;
                    }
                    break;

                case BinaryOperator.Less:
                    value = Compare(left, right);
                    if (value == Undefined.Instance)
                    {
                        value = false;
                    }
                    break;

                case BinaryOperator.LessOrEqual:
                    value = Compare(right, left, false);
                    if (value == Undefined.Instance || value.AsBoolean())
                    {
                        value = false;
                    }
                    else
                    {
                        value = true;
                    }
                    break;

                case BinaryOperator.StrictlyEqual:
                    return StrictlyEqual(left, right);

                case BinaryOperator.StricltyNotEqual:
                    return !StrictlyEqual(left, right);

                case BinaryOperator.BitwiseAnd:
                    return TypeConverter.ToInt32(left) & TypeConverter.ToInt32(right);

                case BinaryOperator.BitwiseOr:
                    return TypeConverter.ToInt32(left) | TypeConverter.ToInt32(right);

                case BinaryOperator.BitwiseXOr:
                    return TypeConverter.ToInt32(left) ^ TypeConverter.ToInt32(right);

                case BinaryOperator.LeftShift:
                    return TypeConverter.ToInt32(left) << (int)(TypeConverter.ToUint32(right) & 0x1F);

                case BinaryOperator.RightShift:
                    return TypeConverter.ToInt32(left) >> (int)(TypeConverter.ToUint32(right) & 0x1F);

                case BinaryOperator.UnsignedRightShift:
                    return (uint)TypeConverter.ToInt32(left) >> (int)(TypeConverter.ToUint32(right) & 0x1F);

                case BinaryOperator.InstanceOf:
                    var f = right.TryCast<FunctionInstance>();

                    if (f == null)
                    {
                        throw new JavaScriptException(_engine.TypeError, "instanceof can only be used with a function object");
                    }

                    value = f.HasInstance(left);
                    break;

                case BinaryOperator.In:
                    if (!right.IsObject())
                    {
                        throw new JavaScriptException(_engine.TypeError, "in can only be used with an object");
                    }

                    value = right.AsObject().HasProperty(TypeConverter.ToString(left));
                    break;

                default:
                    throw new NotImplementedException();
            }

            return value;
        }

        public JsValue EvaluateLogicalExpression(LogicalExpression logicalExpression)
        {
            var left = _engine.GetValue(EvaluateExpression(logicalExpression.Left));

            switch (logicalExpression.Operator)
            {

                case LogicalOperator.LogicalAnd:
                    if (!TypeConverter.ToBoolean(left))
                    {
                        return left;
                    }

                    return _engine.GetValue(EvaluateExpression(logicalExpression.Right));

                case LogicalOperator.LogicalOr:
                    if (TypeConverter.ToBoolean(left))
                    {
                        return left;
                    }

                    return _engine.GetValue(EvaluateExpression(logicalExpression.Right));

                default:
                    throw new NotImplementedException();
            }
        }

        public static bool Equal(JsValue x, JsValue y)
        {
            var typex = x.Type;
            var typey = y.Type;

            if (typex == typey)
            {
				return StrictlyEqual(x, y);
            }

            if (x == Null.Instance && y == Undefined.Instance)
            {
                return true;
            }

            if (x == Undefined.Instance && y == Null.Instance)
            {
                return true;
            }

            if (typex == Types.Number && typey == Types.String)
            {
                return Equal(x, TypeConverter.ToNumber(y));
            }

            if (typex == Types.String && typey == Types.Number)
            {
                return Equal(TypeConverter.ToNumber(x), y);
            }

            if (typex == Types.Boolean)
            {
                return Equal(TypeConverter.ToNumber(x), y);
            }

            if (typey == Types.Boolean)
            {
                return Equal(x, TypeConverter.ToNumber(y));
            }

            if (typey == Types.Object && (typex == Types.String || typex == Types.Number))
            {
                return Equal(x, TypeConverter.ToPrimitive(y));
            }

            if (typex == Types.Object && (typey == Types.String || typey == Types.Number))
            {
                return Equal(TypeConverter.ToPrimitive(x), y);
            }

            return false;
        }

        public static bool StrictlyEqual(JsValue x, JsValue y)
        {
            var typea = x.Type;
            var typeb = y.Type;

            if (typea != typeb)
            {
                return false;
            }

            if (typea == Types.Undefined || typea == Types.Null)
            {
                return true;
            }

            if (typea == Types.None)
            {
                return true;
            }

            if (typea == Types.Number)
            {
                var nx = x.AsNumber();
                var ny = y.AsNumber();

                if (double.IsNaN(nx) || double.IsNaN(ny))
                {
                    return false;
                }

                if (nx.Equals(ny))
                {
                    return true;
                }

                return false;
            }

            if (typea == Types.String)
            {
                return x.AsString() == y.AsString();
            }

            if (typea == Types.Boolean)
            {
                return x.AsBoolean() == y.AsBoolean();
            }

			if (typea == Types.Object)
			{
				if (x.AsObject() is IObjectWrapper xw)
				{
					var yw = y.AsObject() as IObjectWrapper;
					return Object.Equals(xw.Target, yw.Target);
				}
			}

            return x == y;
        }

        public static bool SameValue(JsValue x, JsValue y)
        {
            var typea = TypeConverter.GetPrimitiveType(x);
            var typeb = TypeConverter.GetPrimitiveType(y);

            if (typea != typeb)
            {
                return false;
            }

            if (typea == Types.None)
            {
                return true;
            }
            if (typea == Types.Number)
            {
                var nx = TypeConverter.ToNumber(x);
                var ny = TypeConverter.ToNumber(y);

                if (double.IsNaN(nx) && double.IsNaN(ny))
                {
                    return true;
                }

                if (nx.Equals(ny))
                {
                    if (nx.Equals(0))
                    {
                        // +0 !== -0
                        return NumberInstance.IsNegativeZero(nx) == NumberInstance.IsNegativeZero(ny);
                    }

                    return true;
                }

                return false;
            }
            if (typea == Types.String)
            {
                return TypeConverter.ToString(x) == TypeConverter.ToString(y);
            }
            if (typea == Types.Boolean)
            {
                return TypeConverter.ToBoolean(x) == TypeConverter.ToBoolean(y);
            }
            return x == y;
        }

        public static JsValue Compare(JsValue x, JsValue y, bool leftFirst = true)
        {
            JsValue px, py;
            if (leftFirst)
            {
                px = TypeConverter.ToPrimitive(x, Types.Number);
                py = TypeConverter.ToPrimitive(y, Types.Number);
            }
            else
            {
                py = TypeConverter.ToPrimitive(y, Types.Number);
                px = TypeConverter.ToPrimitive(x, Types.Number);
            }

            var typea = px.Type;
            var typeb = py.Type;

            if (typea != Types.String || typeb != Types.String)
            {
                var nx = TypeConverter.ToNumber(px);
                var ny = TypeConverter.ToNumber(py);

                if (double.IsNaN(nx) || double.IsNaN(ny))
                {
                    return Undefined.Instance;
                }

                if (nx.Equals(ny))
                {
                    return false;
                }

                if (double.IsPositiveInfinity(nx))
                {
                    return false;
                }

                if (double.IsPositiveInfinity(ny))
                {
                    return true;
                }

                if (double.IsNegativeInfinity(ny))
                {
                    return false;
                }

                if (double.IsNegativeInfinity(nx))
                {
                    return true;
                }

                return nx < ny;
            }
            else
            {
                return String.CompareOrdinal(TypeConverter.ToString(x), TypeConverter.ToString(y)) < 0;
            }
        }

        public Reference EvaluateIdentifier(Identifier identifier)
        {
            var env = _engine.ExecutionContext.LexicalEnvironment;
            var strict = StrictModeScope.IsStrictModeCode;

            return LexicalEnvironment.GetIdentifierReference(env, identifier.Name, strict);
        }

        public JsValue EvaluateLiteral(Literal literal)
        {
            if(literal.Cached)
            {
                return literal.CachedValue;
            }

            if (literal.Type == SyntaxNodes.RegularExpressionLiteral)
            {
				var regexp = _engine.RegExp.Construct(literal.Raw);

				if (regexp.Global)
				{
					// A Global regexp literal can't be cached or its state would evolve
					return regexp;
				}

				literal.CachedValue = regexp;
            }
            else
            {
                literal.CachedValue = JsValue.FromObject(_engine, literal.Value);
            }

            literal.Cached = true;
            return literal.CachedValue;
        }

        public JsValue EvaluateObjectExpression(ObjectExpression objectExpression)
        {
            // http://www.ecma-international.org/ecma-262/5.1/#sec-11.1.5

            var obj = _engine.Object.Construct(Arguments.Empty);
            foreach (var property in objectExpression.Properties)
            {
                var propName = property.Key.GetKey();
                var previous = obj.GetOwnProperty(propName);
                PropertyDescriptor propDesc;

                switch (property.Kind)
                {
                    case PropertyKind.Data:
                        var exprValue = _engine.EvaluateExpression(property.Value);
                        var propValue = _engine.GetValue(exprValue);
                        propDesc = new PropertyDescriptor(propValue, true, true, true);
                        break;

                    case PropertyKind.Get:
                        var getter = property.Value as FunctionExpression;

                        if (getter == null)
                        {
                            throw new JavaScriptException(_engine.SyntaxError);
                        }

                        ScriptFunctionInstance get;
                        using (new StrictModeScope(getter.Strict))
                        {
                            get = new ScriptFunctionInstance(
                                _engine,
                                getter,
                                _engine.ExecutionContext.LexicalEnvironment,
                                StrictModeScope.IsStrictModeCode
                            );
                        }

                        propDesc = new PropertyDescriptor(get: get, set: null, enumerable: true, configurable:true);
                        break;

                    case PropertyKind.Set:
                        var setter = property.Value as FunctionExpression;

                        if (setter == null)
                        {
                            throw new JavaScriptException(_engine.SyntaxError);
                        }

                        ScriptFunctionInstance set;
                        using (new StrictModeScope(setter.Strict))
                        {

                            set = new ScriptFunctionInstance(
                                _engine,
                                setter,
                                _engine.ExecutionContext.LexicalEnvironment,
                                StrictModeScope.IsStrictModeCode
                                );
                        }
                        propDesc = new PropertyDescriptor(get:null, set: set, enumerable: true, configurable: true);
                        break;

                    default:
                        throw new ArgumentOutOfRangeException();
                }

                if (previous != PropertyDescriptor.Undefined)
                {
                    if (StrictModeScope.IsStrictModeCode && previous.IsDataDescriptor() && propDesc.IsDataDescriptor())
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }

                    if (previous.IsDataDescriptor() && propDesc.IsAccessorDescriptor())
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }

                    if (previous.IsAccessorDescriptor() && propDesc.IsDataDescriptor())
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }

                    if (previous.IsAccessorDescriptor() && propDesc.IsAccessorDescriptor())
                    {
                        if (propDesc.Set != null && previous.Set != null)
                        {
                            throw new JavaScriptException(_engine.SyntaxError);
                        }

                        if (propDesc.Get != null && previous.Get != null)
                        {
                            throw new JavaScriptException(_engine.SyntaxError);
                        }
                    }
                }

                obj.DefineOwnProperty(propName, propDesc, false);
            }

            return obj;
        }

        /// <summary>
        /// http://www.ecma-international.org/ecma-262/5.1/#sec-11.2.1
        /// </summary>
        /// <param name="memberExpression"></param>
        /// <returns></returns>
        public Reference EvaluateMemberExpression(MemberExpression memberExpression)
        {
            var baseReference = EvaluateExpression(memberExpression.Object);
            var baseValue = _engine.GetValue(baseReference);
            Expression expression = memberExpression.Property;


            if (!memberExpression.Computed) // index accessor ?
            {
                expression = new Literal { Type = SyntaxNodes.Literal, Value = memberExpression.Property.As<Identifier>().Name };
            }

            var propertyNameReference = EvaluateExpression(expression);
            var propertyNameValue = _engine.GetValue(propertyNameReference);
            TypeConverter.CheckObjectCoercible(_engine, baseValue);
            var propertyNameString = TypeConverter.ToString(propertyNameValue);

            return new Reference(baseValue, propertyNameString, StrictModeScope.IsStrictModeCode);
        }

        public JsValue EvaluateFunctionExpression(FunctionExpression functionExpression)
        {
            var funcEnv = LexicalEnvironment.NewDeclarativeEnvironment(_engine, _engine.ExecutionContext.LexicalEnvironment);
            var envRec = (DeclarativeEnvironmentRecord)funcEnv.Record;

            if (functionExpression.Id != null && !String.IsNullOrEmpty(functionExpression.Id.Name))
            {
                envRec.CreateMutableBinding(functionExpression.Id.Name);
            }

            var closure = new ScriptFunctionInstance(
                _engine,
                functionExpression,
                funcEnv,
                functionExpression.Strict
                );

            if (functionExpression.Id != null && !String.IsNullOrEmpty(functionExpression.Id.Name))
            {
                envRec.InitializeImmutableBinding(functionExpression.Id.Name, closure);
            }

            return closure;
        }

        public JsValue EvaluateCallExpression(CallExpression callExpression)
        {
            var callee = EvaluateExpression(callExpression.Callee);

            if (_engine.Options._IsDebugMode)
            {
                _engine.DebugHandler.AddToDebugCallStack(callExpression);
            }

            JsValue thisObject;

            // todo: implement as in http://www.ecma-international.org/ecma-262/5.1/#sec-11.2.4


            JsValue[] arguments;

            if (callExpression.Cached)
            {
                arguments = callExpression.CachedArguments;
            }
            else
            {
                arguments = callExpression.Arguments.Select(EvaluateExpression).Select(_engine.GetValue).ToArray();

                if (callExpression.CanBeCached)
                {
                    // The arguments array can be cached if they are all literals
                    if (callExpression.Arguments.All(x => x is Literal))
                    {
                        callExpression.CachedArguments = arguments;
                        callExpression.Cached = true;
                    }
                    else
                    {
                        callExpression.CanBeCached = false;
                    }
                }
            }

            var func = _engine.GetValue(callee);

            if (_engine.Options._MaxRecursionDepth >= 0)
            {
                var stackItem = new CallStackElement(callExpression, func, callee is Reference r ? r.GetReferencedName() : "anonymous function");

                var recursionDepth = _engine.CallStack.Push(stackItem);

                if (recursionDepth > _engine.Options._MaxRecursionDepth)
                {
                    _engine.CallStack.Pop();
                    throw new RecursionDepthOverflowException(_engine.CallStack, stackItem.ToString());
                }
            }

            if (func == Undefined.Instance)
            {
                throw new JavaScriptException(_engine.TypeError, r == null ? "" : string.Format("Object has no method '{0}'", (callee as Reference).GetReferencedName()));
            }

            if (!func.IsObject())
            {
                throw new JavaScriptException(_engine.TypeError, r == null ? "" : string.Format("Property '{0}' of object is not a function", (callee as Reference).GetReferencedName()));
            }

            var callable = func.TryCast<ICallable>();
            if (callable == null)
            {
                throw new JavaScriptException(_engine.TypeError);
            }

            if (callee is Reference r)
            {
                if (r.IsPropertyReference())
                {
                    thisObject = r.GetBase();
                }
                else
                {
                    var env = r.GetBase().TryCast<EnvironmentRecord>();
                    thisObject = env.ImplicitThisValue();
                }
            }
            else
            {
                thisObject = Undefined.Instance;
            }

            // is it a direct call to eval ? http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.2.1.1
            if (callee is Reference r && r.GetReferencedName() == "eval" && callable is EvalFunctionInstance)
            {
                return ((EvalFunctionInstance) callable).Call(thisObject, arguments, true);
            }

            var result = callable.Call(thisObject, arguments);

            if (_engine.Options._IsDebugMode)
            {
                _engine.DebugHandler.PopDebugCallStack();
            }

            if (_engine.Options._MaxRecursionDepth >= 0)
            {
                _engine.CallStack.Pop();
            }

            return result;
        }

        public JsValue EvaluateSequenceExpression(SequenceExpression sequenceExpression)
        {
            var result = Undefined.Instance;
            foreach (var expression in sequenceExpression.Expressions)
            {
                result = _engine.GetValue(_engine.EvaluateExpression(expression));
            }

            return result;
        }

        public JsValue EvaluateUpdateExpression(UpdateExpression updateExpression)
        {
            var value = _engine.EvaluateExpression(updateExpression.Argument);
            Reference r;

            switch (updateExpression.Operator)
            {
                case UnaryOperator.Increment:
                    r = value as Reference;
                    if (r != null
                        && r.IsStrict()
                        && (r.GetBase().TryCast<EnvironmentRecord>() != null)
                        && (Array.IndexOf(new[] { "eval", "arguments" }, r.GetReferencedName()) != -1))
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }

                    var oldValue = TypeConverter.ToNumber(_engine.GetValue(value));
                    var newValue = oldValue + 1;
                    _engine.PutValue(r, newValue);

                    return updateExpression.Prefix ? newValue : oldValue;

                case UnaryOperator.Decrement:
                    r = value as Reference;
                    if (r != null
                        && r.IsStrict()
                        && (r.GetBase().TryCast<EnvironmentRecord>() != null)
                        && (Array.IndexOf(new[] { "eval", "arguments" }, r.GetReferencedName()) != -1))
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }

                    oldValue = TypeConverter.ToNumber(_engine.GetValue(value));
                    newValue = oldValue - 1;
                    _engine.PutValue(r, newValue);

                    return updateExpression.Prefix ? newValue : oldValue;
                default:
                    throw new ArgumentException();
            }

        }

        public JsValue EvaluateThisExpression(ThisExpression thisExpression)
        {
            return _engine.ExecutionContext.ThisBinding;
        }

        public JsValue EvaluateNewExpression(NewExpression newExpression)
        {
            var arguments = newExpression.Arguments.Select(EvaluateExpression).Select(_engine.GetValue).ToArray();

            // todo: optimize by defining a common abstract class or interface
            var callee = _engine.GetValue(EvaluateExpression(newExpression.Callee)).TryCast<IConstructor>();

            if (callee == null)
            {
                throw new JavaScriptException(_engine.TypeError, "The object can't be used as constructor.");
            }

            // construct the new instance using the Function's constructor method
            var instance = callee.Construct(arguments);

            return instance;
        }

        public JsValue EvaluateArrayExpression(ArrayExpression arrayExpression)
        {
            var a = _engine.Array.Construct(new JsValue[] { arrayExpression.Elements.Count() });
            var n = 0;
            foreach (var expr in arrayExpression.Elements)
            {
                if (expr != null)
                {
                    var value = _engine.GetValue(EvaluateExpression(expr));
                    a.DefineOwnProperty(n.ToString(),
                        new PropertyDescriptor(value, true, true, true), false);
                }
                n++;
            }

            return a;
        }

        public JsValue EvaluateUnaryExpression(UnaryExpression unaryExpression)
        {
            var value = _engine.EvaluateExpression(unaryExpression.Argument);
            Reference r;

            switch (unaryExpression.Operator)
            {
                case UnaryOperator.Plus:
                    return TypeConverter.ToNumber(_engine.GetValue(value));

                case UnaryOperator.Minus:
                    var n = TypeConverter.ToNumber(_engine.GetValue(value));
                    return double.IsNaN(n) ? double.NaN : n*-1;

                case UnaryOperator.BitwiseNot:
                    return ~TypeConverter.ToInt32(_engine.GetValue(value));

                case UnaryOperator.LogicalNot:
                    return !TypeConverter.ToBoolean(_engine.GetValue(value));

                case UnaryOperator.Delete:
                    r = value as Reference;
                    if (r == null)
                    {
                        return true;
                    }
                    if (r.IsUnresolvableReference())
                    {
                        if (r.IsStrict())
                        {
                            throw new JavaScriptException(_engine.SyntaxError);
                        }

                        return true;
                    }
                    if (r.IsPropertyReference())
                    {
                        var o = TypeConverter.ToObject(_engine, r.GetBase());
                        return o.Delete(r.GetReferencedName(), r.IsStrict());
                    }
                    if (r.IsStrict())
                    {
                        throw new JavaScriptException(_engine.SyntaxError);
                    }
                    var bindings = r.GetBase().TryCast<EnvironmentRecord>();
                    return bindings.DeleteBinding(r.GetReferencedName());

                case UnaryOperator.Void:
                    _engine.GetValue(value);
                    return Undefined.Instance;

                case UnaryOperator.TypeOf:
                    r = value as Reference;
                    if (r != null)
                    {
                        if (r.IsUnresolvableReference())
                        {
                            return "undefined";
                        }
                    }
                    var v = _engine.GetValue(value);
                    if (v == Undefined.Instance)
                    {
                        return "undefined";
                    }
                    if (v == Null.Instance)
                    {
                        return "object";
                    }
                    switch (v.Type)
                    {
                        case Types.Boolean: return "boolean";
                        case Types.Number: return "number";
                        case Types.String: return "string";
                    }
                    if (v.TryCast<ICallable>() != null)
                    {
                        return "function";
                    }
                    return "object";

                default:
                    throw new ArgumentException();
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\Jint\Runtime\ExpressionIntepreter.cs(832,96): error CS0136: A local or parameter named 'r' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Kooboo.Lib\Jint\Runtime\ExpressionIntepreter.cs(845,66): error CS0841: Cannot use local variable 'r' before it is declared,D:\a\1\s\Kooboo.Lib\Jint\Runtime\ExpressionIntepreter.cs(850,66): error CS0841: Cannot use local variable 'r' before it is declared,D:\a\1\s\Kooboo.Lib\Jint\Runtime\ExpressionIntepreter.cs(877,37): error CS0128: A local variable or function named 'r' is already defined in this scope
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\Less\Parser\Infrastructure\Nodes\Node.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using dotless.Core.Plugins;

namespace dotless.Core.Parser.Infrastructure.Nodes
{
    using System;

    public abstract class Node
    {
        public NodeLocation Location { get; set; }

        public NodeList PreComments { get; set; }
        public NodeList PostComments { get; set; }

        #region Boolean Operators

        public static implicit operator bool(Node node)
        {
            return node != null;
        }

        public static bool operator true(Node n)
        {
            return n != null;
        }

        public static bool operator false(Node n)
        {
            return n == null;
        }

        public static bool operator !(Node n)
        {
            return n == null;
        }

        public static Node operator &(Node n1, Node n2)
        {
            return n1 != null ? n2 : null;
        }

        public static Node operator |(Node n1, Node n2)
        {
            return n1 ?? n2;
        }

        #endregion

        /// <summary>
        ///  Copies common properties when evaluating multiple nodes into one
        /// </summary>
        /// <typeparam name="T">Type to return - for convenience</typeparam>
        /// <param name="nodes">The nodes this new node is derived from</param>
        /// <returns>The new node</returns>
        public T ReducedFrom<T>(params Node[] nodes) where T : Node
        {
            foreach (var node in nodes)
            {
                if (node == this)
                {
                    continue;
                }

                Location = node.Location;

                if (node.PreComments)
                {
                    if (PreComments)
                    {
                        PreComments.AddRange(node.PreComments);
                    }
                    else
                    {
                        PreComments = node.PreComments;
                    }
                }

                if (node.PostComments)
                {
                    if (PostComments)
                    {
                        PostComments.AddRange(node.PostComments);
                    }
                    else
                    {
                        PostComments = node.PostComments;
                    }
                }
            }
            
            return (T)this;
        }

        public virtual void AppendCSS(Env env)
        {
            //if there is no implementation then it will be a node that
            //evalutes to something.
            //ideally this shouldn't be called, but when creating error message it may be
            Evaluate(env).AppendCSS(env);
        }

        public virtual string ToCSS(Env env)
        {
            return env.Output
                .Push()
                .Append(this)
                .Pop()
                .ToString();
        }

        public virtual Node Evaluate(Env env)
        {
            return this;
        }

        public bool IgnoreOutput()
        {
            return
                this is RegexMatchResult ||
                this is CharMatchResult;
        }

        public virtual void Accept(IVisitor visitor) {}

        /// <summary>
        /// Visits the node and throw an exception if the replacement mode isn't the right type, or the replacement is null
        /// </summary>
        public T VisitAndReplace<T>(T nodeToVisit, IVisitor visitor) where T : Node
        {
            return VisitAndReplace(nodeToVisit, visitor, false);
        }

        /// <summary>
        /// Visits the node and throw an exception if the replacement mode isn't the right type
        /// The allowNull parameter determines if a null is allowed to be returned
        /// </summary>
        public T VisitAndReplace<T>(T nodeToVisit, IVisitor visitor, bool allowNull) where T : Node
        {
            if (nodeToVisit == null)
            {
                return null;
            }

            Node replacement = visitor.Visit(nodeToVisit);

            T typedReplacement = replacement as T;
            if (typedReplacement != null || (allowNull && replacement == null))
            {
                return typedReplacement;
            }

            throw new Exception("Not allowed null for node of type "+typeof(T).ToString());
        }
    }
}
---- Transformed Tree ----
using dotless.Core.Plugins;

namespace dotless.Core.Parser.Infrastructure.Nodes
{
    using System;

    public abstract class Node
    {
        public NodeLocation Location { get; set; }

        public NodeList PreComments { get; set; }
        public NodeList PostComments { get; set; }

        #region Boolean Operators

        public static implicit operator bool(Node node)
        {
            return node != null;
        }

        public static bool operator true(Node n)
        {
            return n != null;
        }

        public static bool operator false(Node n)
        {
            return n == null;
        }

        public static bool operator !(Node n)
        {
            return n == null;
        }

        public static Node operator &(Node n1, Node n2)
        {
            return n1 != null ? n2 : null;
        }

        public static Node operator |(Node n1, Node n2)
        {
            return n1 ?? n2;
        }

        #endregion

        /// <summary>
        ///  Copies common properties when evaluating multiple nodes into one
        /// </summary>
        /// <typeparam name="T">Type to return - for convenience</typeparam>
        /// <param name="nodes">The nodes this new node is derived from</param>
        /// <returns>The new node</returns>
        public T ReducedFrom<T>(params Node[] nodes) where T : Node
        {
            foreach (var node in nodes)
            {
                if (node == this)
                {
                    continue;
                }

                Location = node.Location;

                if (node.PreComments)
                {
                    if (PreComments)
                    {
                        PreComments.AddRange(node.PreComments);
                    }
                    else
                    {
                        PreComments = node.PreComments;
                    }
                }

                if (node.PostComments)
                {
                    if (PostComments)
                    {
                        PostComments.AddRange(node.PostComments);
                    }
                    else
                    {
                        PostComments = node.PostComments;
                    }
                }
            }
            
            return (T)this;
        }

        public virtual void AppendCSS(Env env)
        {
            //if there is no implementation then it will be a node that
            //evalutes to something.
            //ideally this shouldn't be called, but when creating error message it may be
            Evaluate(env).AppendCSS(env);
        }

        public virtual string ToCSS(Env env)
        {
            return env.Output
                .Push()
                .Append(this)
                .Pop()
                .ToString();
        }

        public virtual Node Evaluate(Env env)
        {
            return this;
        }

        public bool IgnoreOutput()
        {
            return
                this is RegexMatchResult ||
                this is CharMatchResult;
        }

        public virtual void Accept(IVisitor visitor) {}

        /// <summary>
        /// Visits the node and throw an exception if the replacement mode isn't the right type, or the replacement is null
        /// </summary>
        public T VisitAndReplace<T>(T nodeToVisit, IVisitor visitor) where T : Node
        {
            return VisitAndReplace(nodeToVisit, visitor, false);
        }

        /// <summary>
        /// Visits the node and throw an exception if the replacement mode isn't the right type
        /// The allowNull parameter determines if a null is allowed to be returned
        /// </summary>
        public T VisitAndReplace<T>(T nodeToVisit, IVisitor visitor, bool allowNull) where T : Node
        {
            if (nodeToVisit == null)
            {
                return null;
            }

            Node replacement = visitor.Visit(nodeToVisit);

            if (replacement is T typedReplacement || (allowNull && replacement == null))
            {
                return typedReplacement;
            }

            throw new Exception("Not allowed null for node of type "+typeof(T).ToString());
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\Less\Parser\Infrastructure\Nodes\Node.cs(147,24): error CS0165: Use of unassigned local variable 'typedReplacement'
######################################################################


######################################################################
Nr: 7 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\MixinCall.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace dotless.Core.Parser.Tree
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Exceptions;
    using Infrastructure;
    using Infrastructure.Nodes;
    using Utils;
    using Plugins;

    public class MixinCall : Node
    {
        public List<NamedArgument> Arguments { get; set; }
        public Selector Selector { get; set; }
        public bool Important { get; set; }

        public MixinCall(NodeList<Element> elements, List<NamedArgument> arguments, bool important)
        {
            Important = important;
            Selector = new Selector(elements);
            Arguments = arguments;
        }

        public override Node Evaluate(Env env)
        {
            var found = false;

            var closures = env.FindRulesets(Selector);
            if (closures == null)
                throw new ParsingException(Selector.ToCSS(env).Trim() + " is undefined", Location);

            env.Rule = this;

            var rules = new NodeList();

            if (PreComments)
                rules.AddRange(PreComments);

            var rulesetList = closures.ToList();

            // To address bug https://github.com/dotless/dotless/issues/136, where a mixin and ruleset selector may have the same name, we
            // need to favour matching a MixinDefinition with the required Selector and only fall back to considering other Ruleset types
            // if no match is found.
            // However, in order to support having a regular ruleset with the same name as a parameterized
            // mixin (see https://github.com/dotless/dotless/issues/387), we need to take argument counts into account, so we make the
            // decision after evaluating for argument match.

            var mixins = rulesetList.Where(c => c.Ruleset is MixinDefinition).ToList();

            foreach (var closure in mixins)
            {
                var ruleset = (MixinDefinition)closure.Ruleset;
                var matchType = ruleset.MatchArguments(Arguments, env);
                if (matchType == MixinMatch.ArgumentMismatch)
                {
                    continue;
                }

                found = true;

                if (matchType == MixinMatch.GuardFail)
                {
                    continue;
                }

                try
                {
                    var closureEnvironment = env.CreateChildEnvWithClosure(closure);
                    rules.AddRange(ruleset.Evaluate(Arguments, closureEnvironment).Rules);
                }
                catch (ParsingException e)
                {
                    throw new ParsingException(e.Message, e.Location, Location);
                }
            }

            if (!found)
            {
                var regularRulesets = rulesetList.Except(mixins);

                foreach (var closure in regularRulesets)
                {
                    if (closure.Ruleset.Rules != null)
                    {
                        var nodes = new NodeList(closure.Ruleset.Rules);
                        NodeHelper.ExpandNodes<MixinCall>(env, nodes);

                        rules.AddRange(nodes);
                    }

                    found = true;
                }
            }

            if (PostComments)
                rules.AddRange(PostComments);

            env.Rule = null;

            if (!found)
            {
                var message = String.Format("No matching definition was found for `{0}({1})`",
                                            Selector.ToCSS(env).Trim(),
                                            Arguments.Select(a => a.Value.ToCSS(env)).JoinStrings(env.Compress ? "," : ", "));
                throw new ParsingException(message, Location);
            }

            if (Important)
            {
                var importantRules = new NodeList();

                foreach (Node node in rules)
                {
                    if (node is Rule)
                    {
                        importantRules.Add(MakeRuleImportant(node as Rule));
                    }
                    else if (node is Ruleset)
                    {
                        importantRules.Add(MakeRulesetImportant(node as Ruleset));
                    }
                    else
                    {
                        importantRules.Add(node);
                    }
                }

                return importantRules;
            }

            return rules;
        }

        public override void Accept(IVisitor visitor)
        {
            Selector = VisitAndReplace(Selector, visitor);

            foreach (var a in Arguments)
            {
                a.Value = VisitAndReplace(a.Value, visitor);
            }
        }

        private Ruleset MakeRulesetImportant(Ruleset ruleset)
        {
            var importantRules = new NodeList();
            foreach (var x in ruleset.Rules)
            {
                if (x is Rule)
                {
                    importantRules.Add(MakeRuleImportant((Rule) x));
                }
                else if (x is Ruleset)
                {
                    importantRules.Add(MakeRulesetImportant((Ruleset) x));
                }
                else
                {
                    importantRules.Add(x);
                }
            }
            var importantRuleset = new Ruleset(ruleset.Selectors, importantRules).ReducedFrom<Ruleset>(ruleset);
            return importantRuleset;
        }

        private Rule MakeRuleImportant(Rule rule)
        {
            var valueNode = rule.Value;
            var value = valueNode as Value;
            value = value != null
                        ? new Value(value.Values, "!important").ReducedFrom<Value>(value)
                        : new Value(new NodeList {valueNode}, "!important");

            var importantRule = new Rule(rule.Name, value).ReducedFrom<Rule>(rule);
            return importantRule;
        }
    }
}
---- Transformed Tree ----
namespace dotless.Core.Parser.Tree
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Exceptions;
    using Infrastructure;
    using Infrastructure.Nodes;
    using Utils;
    using Plugins;

    public class MixinCall : Node
    {
        public List<NamedArgument> Arguments { get; set; }
        public Selector Selector { get; set; }
        public bool Important { get; set; }

        public MixinCall(NodeList<Element> elements, List<NamedArgument> arguments, bool important)
        {
            Important = important;
            Selector = new Selector(elements);
            Arguments = arguments;
        }

        public override Node Evaluate(Env env)
        {
            var found = false;

            var closures = env.FindRulesets(Selector);
            if (closures == null)
                throw new ParsingException(Selector.ToCSS(env).Trim() + " is undefined", Location);

            env.Rule = this;

            var rules = new NodeList();

            if (PreComments)
                rules.AddRange(PreComments);

            var rulesetList = closures.ToList();

            // To address bug https://github.com/dotless/dotless/issues/136, where a mixin and ruleset selector may have the same name, we
            // need to favour matching a MixinDefinition with the required Selector and only fall back to considering other Ruleset types
            // if no match is found.
            // However, in order to support having a regular ruleset with the same name as a parameterized
            // mixin (see https://github.com/dotless/dotless/issues/387), we need to take argument counts into account, so we make the
            // decision after evaluating for argument match.

            var mixins = rulesetList.Where(c => c.Ruleset is MixinDefinition).ToList();

            foreach (var closure in mixins)
            {
                var ruleset = (MixinDefinition)closure.Ruleset;
                var matchType = ruleset.MatchArguments(Arguments, env);
                if (matchType == MixinMatch.ArgumentMismatch)
                {
                    continue;
                }

                found = true;

                if (matchType == MixinMatch.GuardFail)
                {
                    continue;
                }

                try
                {
                    var closureEnvironment = env.CreateChildEnvWithClosure(closure);
                    rules.AddRange(ruleset.Evaluate(Arguments, closureEnvironment).Rules);
                }
                catch (ParsingException e)
                {
                    throw new ParsingException(e.Message, e.Location, Location);
                }
            }

            if (!found)
            {
                var regularRulesets = rulesetList.Except(mixins);

                foreach (var closure in regularRulesets)
                {
                    if (closure.Ruleset.Rules != null)
                    {
                        var nodes = new NodeList(closure.Ruleset.Rules);
                        NodeHelper.ExpandNodes<MixinCall>(env, nodes);

                        rules.AddRange(nodes);
                    }

                    found = true;
                }
            }

            if (PostComments)
                rules.AddRange(PostComments);

            env.Rule = null;

            if (!found)
            {
                var message = String.Format("No matching definition was found for `{0}({1})`",
                                            Selector.ToCSS(env).Trim(),
                                            Arguments.Select(a => a.Value.ToCSS(env)).JoinStrings(env.Compress ? "," : ", "));
                throw new ParsingException(message, Location);
            }

            if (Important)
            {
                var importantRules = new NodeList();

                foreach (Node node in rules)
                {
                    if (node is Rule)
                    {
                        importantRules.Add(MakeRuleImportant(node as Rule));
                    }
                    else if (node is Ruleset)
                    {
                        importantRules.Add(MakeRulesetImportant(node as Ruleset));
                    }
                    else
                    {
                        importantRules.Add(node);
                    }
                }

                return importantRules;
            }

            return rules;
        }

        public override void Accept(IVisitor visitor)
        {
            Selector = VisitAndReplace(Selector, visitor);

            foreach (var a in Arguments)
            {
                a.Value = VisitAndReplace(a.Value, visitor);
            }
        }

        private Ruleset MakeRulesetImportant(Ruleset ruleset)
        {
            var importantRules = new NodeList();
            foreach (var x in ruleset.Rules)
            {
                if (x is Rule rule)
                {
                    importantRules.Add(MakeRuleImportant(rule));
                }
                else if (x is Ruleset ruleset)
                {
                    importantRules.Add(MakeRulesetImportant(ruleset));
                }
                else
                {
                    importantRules.Add(x);
                }
            }
            var importantRuleset = new Ruleset(ruleset.Selectors, importantRules).ReducedFrom<Ruleset>(ruleset);
            return importantRuleset;
        }

        private Rule MakeRuleImportant(Rule rule)
        {
            var valueNode = rule.Value;
            var value = valueNode as Value;
            value = value != null
                        ? new Value(value.Values, "!important").ReducedFrom<Value>(value)
                        : new Value(new NodeList {valueNode}, "!important");

            var importantRule = new Rule(rule.Name, value).ReducedFrom<Rule>(rule);
            return importantRule;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\MixinCall.cs(154,39): error CS0136: A local or parameter named 'ruleset' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 8 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Ruleset.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace dotless.Core.Parser.Tree
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Infrastructure;
    using Infrastructure.Nodes;
    using Utils;
    using Plugins;

    public class Ruleset : Node
    {
        public NodeList<Selector> Selectors { get; set; }
        public NodeList Rules { get; set; }
        public bool Evaluated { get; protected set; }
        public bool IsRoot { get; set; }
        public bool MultiMedia { get; set; }

        /// <summary>
        ///  The original Ruleset this was cloned from during evaluation
        ///   (may == this if this is the orginal)
        /// </summary>
        public Ruleset OriginalRuleset
        {
            get;
            set;
        }

        private Dictionary<string, List<Closure>> _lookups;

        public Ruleset(NodeList<Selector> selectors, NodeList rules)
            : this(selectors, rules, null)
        {
        }

        protected Ruleset(NodeList<Selector> selectors, NodeList rules, Ruleset originalRuleset)
            : this()
        {
            Selectors = selectors;
            Rules = rules;
            OriginalRuleset = originalRuleset ?? this;
        }

        protected Ruleset()
        {
            _lookups = new Dictionary<string, List<Closure>>();
            OriginalRuleset = this;
        }

        /// <summary>
        ///  returns whether this rulset is equal to or cloned from another node
        /// </summary>
        public bool IsEqualOrClonedFrom(Node node)
        {
            Ruleset ruleset = node as Ruleset;
            if (ruleset)
            {
                return IsEqualOrClonedFrom(ruleset);
            }
            return false;
        }

        /// <summary>
        ///  returns whether this rulset is equal to or cloned from another ruleset
        /// </summary>
        public bool IsEqualOrClonedFrom(Ruleset ruleset)
        {
            return ruleset.OriginalRuleset == OriginalRuleset;
        }

        public Rule Variable(string name, Node startNode)
        {
            Ruleset startNodeRuleset = startNode as Ruleset;

            return Rules
                .TakeWhile(r => r != startNode && (startNodeRuleset == null || !startNodeRuleset.IsEqualOrClonedFrom(r)))
                .OfType<Rule>()
                .Where(r => r.Variable)
                .Reverse()
                .FirstOrDefault(r => r.Name == name);
        }

        public List<Ruleset> Rulesets()
        {
            return Rules.OfType<Ruleset>().ToList();
        }

        public List<Closure> Find<TRuleset>(Env env, Selector selector, Ruleset self) where TRuleset : Ruleset
        {
            self = self ?? this;
            var rules = new List<Closure>();

            var key = typeof(TRuleset).ToString() + ":" + selector.ToCSS(env);
            if (_lookups.ContainsKey(key))
                return _lookups[key];

            var validRulesets = Rulesets().Where(rule =>
                {
                    if (!typeof(TRuleset).IsAssignableFrom(rule.GetType()))
                        return false;

                    if (rule != self)
                        return true;

                    MixinDefinition mixinRule = rule as MixinDefinition;

                    if (mixinRule != null)
                    {
                        return mixinRule.Condition != null;
                    }

                    return false;
                });

            foreach (var rule in validRulesets)
            {
                if (rule.Selectors && rule.Selectors.Any(selector.Match))
                {
                    if ((selector.Elements.Count == 1) || rule.Selectors.Any(s => s.ToCSS(new Env()) == selector.ToCSS(new Env())))
                        rules.Add(new Closure { Ruleset = rule, Context = new List<Ruleset> { rule } });
                    else if (selector.Elements.Count > 1)
                    {
                        var remainingSelectors = new Selector(new NodeList<Element>(selector.Elements.Skip(1)));
                        var closures = rule.Find<Ruleset>(env, remainingSelectors, self);

                        foreach (var closure in closures)
                        {
                            closure.Context.Insert(0, rule);
                        }

                        rules.AddRange(closures);
                    }
                }
            }
            return _lookups[key] = rules;
        }

        public virtual MixinMatch MatchArguments(List<NamedArgument> arguments, Env env)
        {
            return (arguments == null || arguments.Count == 0) ? MixinMatch.Pass : MixinMatch.ArgumentMismatch;
        }

        public override Node Evaluate(Env env)
        {
            if (Evaluated) return this;

            // create a clone so it is non destructive
            var clone = new Ruleset(new NodeList<Selector>(Selectors), new NodeList(Rules), OriginalRuleset).ReducedFrom<Ruleset>(this);

            clone.EvaluateRules(env);
            clone.Evaluated = true;

            return clone;
        }

        public override void Accept(IVisitor visitor)
        {
            Selectors = VisitAndReplace(Selectors, visitor);

            Rules = VisitAndReplace(Rules, visitor);
        }

        /// <summary>
        ///  Evaluate Rules. Must only be run on a copy of the ruleset otherwise it will
        ///  overwrite defintions that might be required later..
        /// </summary>
        protected void EvaluateRules(Env env)
        {
            env.Frames.Push(this);

            for (var i = 0; i < Selectors.Count; i++)
            {
                Selectors[i] = Selectors[i].Evaluate(env) as Selector;
            }

            int mediaBlocks = env.MediaBlocks.Count;

            NodeHelper.ExpandNodes<MixinCall>(env, Rules);

            foreach (var r in Rules.OfType<Extend>().ToArray())
            {
                foreach (var s in this.Selectors)
                {
                    //If we're in a media block, then extenders can only apply to that media block
                    if (env.MediaPath.Any())
                    {
                        env.MediaPath.Peek().AddExtension(s, (Extend) r.Evaluate(env), env);
                    }
                    else //Global extend
                    {
                        env.AddExtension(s, (Extend) r.Evaluate(env), env);
                    }
                }
                
                Rules.Remove(r);
            }

            for (var i = Rules.Count - 1; i >= 0; i--)
            {
                Rules[i] = Rules[i].Evaluate(env);
            }

            // if media blocks are inside this ruleset we have to "catch" the bubbling and
            // make sure they get this rulesets selectors
            for (var j = mediaBlocks; j < env.MediaBlocks.Count; j++)
            {
                env.MediaBlocks[j].BubbleSelectors(Selectors);
            }

            env.Frames.Pop();
        }

        public override void AppendCSS(Env env)
        {
            if (Rules == null || !Rules.Any())
                return;

            ((Ruleset) Evaluate(env)).AppendCSS(env, new Context());
        }

        /// <summary>
        ///  Append the rules in a {} block. Used by sub classes.
        /// </summary>
        protected void AppendRules(Env env)
        {
            if (env.Compress && Rules.Count == 0)
            {
                return;
            }

            env.Output
                .Append(env.Compress ? "{" : " {\n")

                .Push()
                .AppendMany(Rules, "\n")
                .Trim()
                .Indent(env.Compress ? 0 : 2)
                .PopAndAppend();

            if (env.Compress)
            {
                env.Output.TrimRight(';');
            }

            env.Output.Append(env.Compress ? "}" : "\n}");
        }

        public virtual void AppendCSS(Env env, Context context)
        {
            var rules = new List<StringBuilder>(); // node.Ruleset instances
            int nonCommentRules = 0;
            var paths = new Context(); // Current selectors

            if (!IsRoot)
            {
                if (!env.Compress && env.Debug && Location != null)
                {
                    env.Output.Append(string.Format("/* {0}:L{1} */\n", Location.FileName, Zone.GetLineNumber(Location)));
                }
                paths.AppendSelectors(context, Selectors);
            }

            env.Output.Push();

            foreach (var node in Rules)
            {
                if (node.IgnoreOutput())
                    continue;

                var comment = node as Comment;
                if (comment != null && !comment.IsValidCss)
                    continue;

                var ruleset = node as Ruleset;
                if (ruleset != null)
                {
                    ruleset.AppendCSS(env, paths);
                }
                else
                {
                    var rule = node as Rule;

                    if (rule && rule.Variable)
                        continue;

                    if (!IsRoot)
                    {
                        if (!comment)
                            nonCommentRules++;

                        env.Output.Push()
                            .Append(node);
                        rules.Add(env.Output.Pop());
                    }
                    else
                    {
                        env.Output
                            .Append(node);

                        if (!env.Compress)
                        {
                            env.Output
                                .Append("\n");
                        }
                    }
                }
            }

            var rulesetOutput = env.Output.Pop();

            // If this is the root node, we don't render
            // a selector, or {}.
            // Otherwise, only output if this ruleset has rules.
            if (IsRoot)
            {
                env.Output.AppendMany(rules, env.Compress ? "" : "\n");
            }
            else
            {
                if (nonCommentRules > 0)
                {

                    foreach (var s in Selectors.Where(s => s.Elements.First().Value != null))
                    {
                        var local = context.Clone();
                        local.AppendSelectors(context, new[] { s });
                        var finalString = local.ToCss(env);
                        var extensions = env.FindExactExtension(finalString);
                        if (extensions != null)
                        {
                            paths.AppendSelectors(context.Clone(), extensions.ExtendedBy);
                        }

                        var partials = env.FindPartialExtensions(local);
                        if (partials != null)
                        {
                            paths.AppendSelectors(context.Clone(), partials.SelectMany(p => p.Replacements(finalString)));
                        }
                    }


                    paths.AppendCSS(env);

                    env.Output.Append(env.Compress ? "{" : " {\n  ");

                    env.Output.AppendMany(rules.ConvertAll(stringBuilder => stringBuilder.ToString()).Distinct(), env.Compress ? "" : "\n  ");

                    if (env.Compress)
                    {
                        env.Output.TrimRight(';');
                    }

                    env.Output.Append(env.Compress ? "}" : "\n}\n");
                }
            }

            env.Output.Append(rulesetOutput);
        }

        public override string ToString()
        {
            var format = "{0}{{{1}}}";
            return Selectors != null && Selectors.Count > 0
                       ? string.Format(format, Selectors.Select(s => s.ToCSS(new Env())).JoinStrings(""), Rules.Count)
                       : string.Format(format, "*", Rules.Count);
        }
    }
}
---- Transformed Tree ----
namespace dotless.Core.Parser.Tree
{
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Infrastructure;
    using Infrastructure.Nodes;
    using Utils;
    using Plugins;

    public class Ruleset : Node
    {
        public NodeList<Selector> Selectors { get; set; }
        public NodeList Rules { get; set; }
        public bool Evaluated { get; protected set; }
        public bool IsRoot { get; set; }
        public bool MultiMedia { get; set; }

        /// <summary>
        ///  The original Ruleset this was cloned from during evaluation
        ///   (may == this if this is the orginal)
        /// </summary>
        public Ruleset OriginalRuleset
        {
            get;
            set;
        }

        private Dictionary<string, List<Closure>> _lookups;

        public Ruleset(NodeList<Selector> selectors, NodeList rules)
            : this(selectors, rules, null)
        {
        }

        protected Ruleset(NodeList<Selector> selectors, NodeList rules, Ruleset originalRuleset)
            : this()
        {
            Selectors = selectors;
            Rules = rules;
            OriginalRuleset = originalRuleset ?? this;
        }

        protected Ruleset()
        {
            _lookups = new Dictionary<string, List<Closure>>();
            OriginalRuleset = this;
        }

        /// <summary>
        ///  returns whether this rulset is equal to or cloned from another node
        /// </summary>
        public bool IsEqualOrClonedFrom(Node node)
        {
            Ruleset ruleset = node as Ruleset;
            if (ruleset)
            {
                return IsEqualOrClonedFrom(ruleset);
            }
            return false;
        }

        /// <summary>
        ///  returns whether this rulset is equal to or cloned from another ruleset
        /// </summary>
        public bool IsEqualOrClonedFrom(Ruleset ruleset)
        {
            return ruleset.OriginalRuleset == OriginalRuleset;
        }

        public Rule Variable(string name, Node startNode)
        {
            Ruleset startNodeRuleset = startNode as Ruleset;

            return Rules
                .TakeWhile(r => r != startNode && (startNodeRuleset == null || !startNodeRuleset.IsEqualOrClonedFrom(r)))
                .OfType<Rule>()
                .Where(r => r.Variable)
                .Reverse()
                .FirstOrDefault(r => r.Name == name);
        }

        public List<Ruleset> Rulesets()
        {
            return Rules.OfType<Ruleset>().ToList();
        }

        public List<Closure> Find<TRuleset>(Env env, Selector selector, Ruleset self) where TRuleset : Ruleset
        {
            self = self ?? this;
            var rules = new List<Closure>();

            var key = typeof(TRuleset).ToString() + ":" + selector.ToCSS(env);
            if (_lookups.ContainsKey(key))
                return _lookups[key];

            var validRulesets = Rulesets().Where(rule =>
                {
                    if (!typeof(TRuleset).IsAssignableFrom(rule.GetType()))
                        return false;

                    if (rule != self)
                        return true;

                    if (rule is MixinDefinition mixinRule)
                    {
                        return mixinRule.Condition != null;
                    }

                    return false;
                });

            foreach (var rule in validRulesets)
            {
                if (rule.Selectors && rule.Selectors.Any(selector.Match))
                {
                    if ((selector.Elements.Count == 1) || rule.Selectors.Any(s => s.ToCSS(new Env()) == selector.ToCSS(new Env())))
                        rules.Add(new Closure { Ruleset = rule, Context = new List<Ruleset> { rule } });
                    else if (selector.Elements.Count > 1)
                    {
                        var remainingSelectors = new Selector(new NodeList<Element>(selector.Elements.Skip(1)));
                        var closures = rule.Find<Ruleset>(env, remainingSelectors, self);

                        foreach (var closure in closures)
                        {
                            closure.Context.Insert(0, rule);
                        }

                        rules.AddRange(closures);
                    }
                }
            }
            return _lookups[key] = rules;
        }

        public virtual MixinMatch MatchArguments(List<NamedArgument> arguments, Env env)
        {
            return (arguments == null || arguments.Count == 0) ? MixinMatch.Pass : MixinMatch.ArgumentMismatch;
        }

        public override Node Evaluate(Env env)
        {
            if (Evaluated) return this;

            // create a clone so it is non destructive
            var clone = new Ruleset(new NodeList<Selector>(Selectors), new NodeList(Rules), OriginalRuleset).ReducedFrom<Ruleset>(this);

            clone.EvaluateRules(env);
            clone.Evaluated = true;

            return clone;
        }

        public override void Accept(IVisitor visitor)
        {
            Selectors = VisitAndReplace(Selectors, visitor);

            Rules = VisitAndReplace(Rules, visitor);
        }

        /// <summary>
        ///  Evaluate Rules. Must only be run on a copy of the ruleset otherwise it will
        ///  overwrite defintions that might be required later..
        /// </summary>
        protected void EvaluateRules(Env env)
        {
            env.Frames.Push(this);

            for (var i = 0; i < Selectors.Count; i++)
            {
                Selectors[i] = Selectors[i].Evaluate(env) as Selector;
            }

            int mediaBlocks = env.MediaBlocks.Count;

            NodeHelper.ExpandNodes<MixinCall>(env, Rules);

            foreach (var r in Rules.OfType<Extend>().ToArray())
            {
                foreach (var s in this.Selectors)
                {
                    //If we're in a media block, then extenders can only apply to that media block
                    if (env.MediaPath.Any())
                    {
                        env.MediaPath.Peek().AddExtension(s, (Extend) r.Evaluate(env), env);
                    }
                    else //Global extend
                    {
                        env.AddExtension(s, (Extend) r.Evaluate(env), env);
                    }
                }
                
                Rules.Remove(r);
            }

            for (var i = Rules.Count - 1; i >= 0; i--)
            {
                Rules[i] = Rules[i].Evaluate(env);
            }

            // if media blocks are inside this ruleset we have to "catch" the bubbling and
            // make sure they get this rulesets selectors
            for (var j = mediaBlocks; j < env.MediaBlocks.Count; j++)
            {
                env.MediaBlocks[j].BubbleSelectors(Selectors);
            }

            env.Frames.Pop();
        }

        public override void AppendCSS(Env env)
        {
            if (Rules == null || !Rules.Any())
                return;

            ((Ruleset) Evaluate(env)).AppendCSS(env, new Context());
        }

        /// <summary>
        ///  Append the rules in a {} block. Used by sub classes.
        /// </summary>
        protected void AppendRules(Env env)
        {
            if (env.Compress && Rules.Count == 0)
            {
                return;
            }

            env.Output
                .Append(env.Compress ? "{" : " {\n")

                .Push()
                .AppendMany(Rules, "\n")
                .Trim()
                .Indent(env.Compress ? 0 : 2)
                .PopAndAppend();

            if (env.Compress)
            {
                env.Output.TrimRight(';');
            }

            env.Output.Append(env.Compress ? "}" : "\n}");
        }

        public virtual void AppendCSS(Env env, Context context)
        {
            var rules = new List<StringBuilder>(); // node.Ruleset instances
            int nonCommentRules = 0;
            var paths = new Context(); // Current selectors

            if (!IsRoot)
            {
                if (!env.Compress && env.Debug && Location != null)
                {
                    env.Output.Append(string.Format("/* {0}:L{1} */\n", Location.FileName, Zone.GetLineNumber(Location)));
                }
                paths.AppendSelectors(context, Selectors);
            }

            env.Output.Push();

            foreach (var node in Rules)
            {
                if (node.IgnoreOutput())
                    continue;

                if (node is Comment comment && !comment.IsValidCss)
                    continue;

                if (node is Ruleset ruleset)
                {
                    ruleset.AppendCSS(env, paths);
                }
                else
                {
                    var rule = node as Rule;

                    if (rule && rule.Variable)
                        continue;

                    if (!IsRoot)
                    {
                        if (!comment)
                            nonCommentRules++;

                        env.Output.Push()
                            .Append(node);
                        rules.Add(env.Output.Pop());
                    }
                    else
                    {
                        env.Output
                            .Append(node);

                        if (!env.Compress)
                        {
                            env.Output
                                .Append("\n");
                        }
                    }
                }
            }

            var rulesetOutput = env.Output.Pop();

            // If this is the root node, we don't render
            // a selector, or {}.
            // Otherwise, only output if this ruleset has rules.
            if (IsRoot)
            {
                env.Output.AppendMany(rules, env.Compress ? "" : "\n");
            }
            else
            {
                if (nonCommentRules > 0)
                {

                    foreach (var s in Selectors.Where(s => s.Elements.First().Value != null))
                    {
                        var local = context.Clone();
                        local.AppendSelectors(context, new[] { s });
                        var finalString = local.ToCss(env);
                        var extensions = env.FindExactExtension(finalString);
                        if (extensions != null)
                        {
                            paths.AppendSelectors(context.Clone(), extensions.ExtendedBy);
                        }

                        var partials = env.FindPartialExtensions(local);
                        if (partials != null)
                        {
                            paths.AppendSelectors(context.Clone(), partials.SelectMany(p => p.Replacements(finalString)));
                        }
                    }


                    paths.AppendCSS(env);

                    env.Output.Append(env.Compress ? "{" : " {\n  ");

                    env.Output.AppendMany(rules.ConvertAll(stringBuilder => stringBuilder.ToString()).Distinct(), env.Compress ? "" : "\n  ");

                    if (env.Compress)
                    {
                        env.Output.TrimRight(';');
                    }

                    env.Output.Append(env.Compress ? "}" : "\n}\n");
                }
            }

            env.Output.Append(rulesetOutput);
        }

        public override string ToString()
        {
            var format = "{0}{{{1}}}";
            return Selectors != null && Selectors.Count > 0
                       ? string.Format(format, Selectors.Select(s => s.ToCSS(new Env())).JoinStrings(""), Rules.Count)
                       : string.Format(format, "*", Rules.Count);
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\Less\Parser\Tree\Ruleset.cs(284,30): error CS0165: Use of unassigned local variable 'comment'
######################################################################


######################################################################
Nr: 9 - UseStringIsNullOrEmptyRewriterR10
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\Css\CssParser.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using Kooboo.Lib.NUglify.Css;
using NUglify.Helpers;
using NUglify.JavaScript;
using NUglify.JavaScript.Visitors;

namespace NUglify.Css
{
    /// <summary>
    /// Parser takes Tokens and parses them into rules and statements
    /// </summary>
    public class CssParser
    {
        #region state fields

        private CssScanner m_scanner;
        private CssToken m_currentToken;
        private bool m_noOutput;
        private string m_lastOutputString;
        private bool m_mightNeedSpace;
        private bool m_skippedSpace;
        private int m_lineLength;
        private bool m_noColorAbbreviation;
        private bool m_encounteredNewLine;
        private Stack<StringBuilder> m_builders;

        // this is used to make sure we don't output two newlines in a row.
        // start it as true so we don't start off with a blank line
        private bool m_outputNewLine = true;

        // set this to true to force a newline before any other output
        private bool m_forceNewLine = false;

        public CssSettings Settings
        {
            get; set;
        }

        // sets a text writer that gets raw tokens written to it
        public TextWriter EchoWriter { get; set; }

        private readonly HashSet<string> m_namespaces;

        public string FileContext { get; set; }

        private CodeSettings m_jsSettings;
        public CodeSettings JSSettings
        {
            get
            {
                return m_jsSettings;
            }
            set
            {
                if (value != null)
                {
                    // clone the settings
                    m_jsSettings = value.Clone();

                    // and then make SURE the source format is Expression
                    m_jsSettings.SourceMode = JavaScriptSourceMode.Expression;
                }
                else
                {
                    m_jsSettings = new CodeSettings()
                        {
                            KillSwitch = (long)TreeModifications.MinifyStringLiterals,
                            SourceMode = JavaScriptSourceMode.Expression
                        };
                }
            }
        }

        #endregion

        private static Regex s_vendorSpecific = new Regex(
            @"^(\-(?<vendor>[^\-]+)\-)?(?<root>.+)$",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        // IE8 @font-face directive has an issue with src properties that are URLs ending with .EOT
        // that don't have any querystring. They end up sending a malformed HTTP request to the server,
        // which is bad for the server. So we want to automatically fix this for developers: if ANY URL
        // ends in .EOT without a querystring parameters, just add a question mark in the appropriate 
        // location. This fixes the IE8 issue.
        private static Regex s_eotIE8Fix = new Regex(
            @"\.eot([^?\\/\w])",
            RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled | RegexOptions.CultureInvariant);

        #region Comment-related fields

        /// <summary>
        /// regular expression for matching css comments
        /// Format: /*(anything or nothing inside)*/
        /// </summary>
        ////private static Regex s_regexComments = new Regex(
        ////    @"/\*([^*]|(\*+[^*/]))*\*+/",
        ////    RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// regular expression for matching first comment hack
        /// This is the MacIE ignore bug: /*(anything or nothing inside)\*/.../*(anything or nothing inside)*/
        /// </summary>
        private static Regex s_regexHack1 = new Regex(
            @"/\*([^*]|(\*+[^*/]))*\**\\\*/(?<inner>.*?)/\*([^*]|(\*+[^*/]))*\*+/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for matching second comment hack
        /// Hide from everything EXCEPT Netscape 4 and Opera 5
        /// Format: /*/*//*/.../*(anything or nothing inside)*/
        /// </summary>
        private static Regex s_regexHack2 = new Regex(
            @"/\*/\*//\*/(?<inner>.*?)/\*([^*]|(\*+[^*/]))*\*+/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for matching third comment hack
        /// Hide from Netscape 4
        /// Format: /*/*/.../*(anything or nothing inside)*/
        /// </summary>
        private static Regex s_regexHack3 = new Regex(
            @"/\*/\*/(?<inner>.*?)/\*([^*]|(\*+[^*/]))*\*+/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for matching fourth comment hack
        /// Hide from IE6
        /// Format: property /*(anything or nothing inside)*/:value
        /// WARNING: This does not actually parse the property/value -- it simply looks for a
        /// word character followed by at least one whitespace character, followed
        /// by a simple comment, followed by optional space, followed by a colon.
        /// Does not match the simple word, the space or the colon (just the comment) 
        /// </summary>
        private static Regex s_regexHack4 = new Regex(
            @"(?<=\w\s+)/\*([^*]|(\*+[^*/]))*\*+/\s*(?=:)",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for matching fifth comment hack
        /// Hide from IE5.5
        /// Format: property:/* (anything or nothing inside) */value
        /// WARNING: This does not actually parse the property/value -- it simply looks for a
        /// word character followed by optional whitespace character, followed
        /// by a colon, followed by optional whitespace, followed by a simple comment.
        /// Does not match initial word or the colon, just the comment.
        /// </summary>
        private static Regex s_regexHack5 = new Regex(
            @"(?<=[\w/]\s*:)\s*/\*([^*]|(\*+[^*/]))*\*+/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for matching sixth comment hack -- although not a real hack
        /// Hide from IE6, NOT
        /// Format: property/*(anything or nothing inside)*/:value
        /// NOTE: This doesn't actually hide from IE6; it needs a space before the comment to actually work.
        /// but enoough people code this in their CSS and expect it to be output that I recieved enough
        /// requests to add it to the allowed "hacks"
        /// WARNING: This does not actually parse the property/value -- it simply looks for a
        /// word character followed by a simple comment, followed by optional space, followed by a colon.
        /// Does not match the simple word or the colon (just initial whitespace and comment) 
        /// </summary>
        private static Regex s_regexHack6 = new Regex(
            @"(?<=\w)/\*([^*]|(\*+[^*/]))*\*+/\s*(?=:)",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for empty comments
        /// These comments don't really do anything. But if the developer wrote an empty
        /// comment (/**/ or /* */), then it has no documentation value and might possibly be
        /// an attempted comment hack.
        /// Format: /**/ or /* */ (single space)
        /// </summary>
        private static Regex s_regexHack7 = new Regex(
            @"/\*(\s?)\*/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        #endregion

        #region color-related fields

        /// <summary>
        /// matches 6-digit RGB color value where both r digits are the same, both
        /// g digits are the same, and both b digits are the same (but r, g, and b
        /// values are not necessarily the same). Used to identify #rrggbb values
        /// that can be collapsed to #rgb
        /// </summary>
        private static Regex s_rrggbb = new Regex(
            @"^\#(?<r>[0-9a-fA-F])\k<r>(?<g>[0-9a-fA-F])\k<g>(?<b>[0-9a-fA-F])\k<b>$",
            RegexOptions.CultureInvariant | RegexOptions.Compiled);

        // whether we are currently parsing the value for a property that might
        // use color names
        private bool m_parsingColorValue;

        #endregion

        #region value-replacement fields

        /// <summary>
        /// regular expression for matching css comments containing special formatted identifiers
        /// for value-replacement matching
        /// Format: /* [id] */
        /// </summary>
        private static Regex s_valueReplacement = new Regex(
            @"/\*\s*\[(?<id>\w+)\]\s*\*/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        // this variable will be set whenever we encounter a value-replacement comment
        // and have a string to replace it with
        private string m_valueReplacement;// = null;

        #endregion

        #region Sharepoint replacement comment regex

        /// <summary>
        /// regular expression for matching Sharepoint Theme css comments
        /// Format: /* [ReplaceBGImage] */
        ///         /* [id(parameters)] */
        ///     where id is one of: ReplaceColor, ReplaceFont, or RecolorImage
        ///     and parameters is anything other than a close square-bracket
        /// </summary>
        private static Regex s_sharepointReplacement = new Regex(
            @"/\*\s*\[(ReplaceBGImage|((ReplaceColor|ReplaceFont|RecolorImage)\([^\]]*))\]\s*\*/",
            RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled | RegexOptions.CultureInvariant);

        #endregion

        #region token-related properties

        private TokenType CurrentTokenType
        {
            get
            {
                return m_currentToken != null
                    ? m_currentToken.TokenType
                    : TokenType.None;
            }
        }

        private string CurrentTokenText
        {
            get
            {
                return m_currentToken != null
                    ? m_currentToken.Text
                    : string.Empty;
            }
        }

        #endregion

        public CssParser()
        {
            // default settings
            Settings = new CssSettings();

            // create the default settings we'll use for JS expression minification
            // use the defaults, other than to set the kill switch so that it leaves
            // string literals alone (so we don't inadvertently change any delimiter chars)
            JSSettings = null;

            // create a list of strings that represent the namespaces declared
            // in a @namespace statement. We will clear this every time we parse a new source string.
            m_namespaces = new HashSet<string>();
        }

        public string Parse(string source)
        {
            // clear out the list of namespaces
            m_namespaces.Clear();

            if (source.IsNullOrWhiteSpace())
            {
                // null or blank - return an empty string
                source = string.Empty;
            }
            else
            {
                // pre-process the comments
                var resetToHacks = false;
                try
                {
                    // see if we need to re-encode the text based on a @charset rule
                    // at the front.
                    source = HandleCharset(source);

                    if (Settings.CommentMode == CssComment.Hacks)
                    {
                        // change the various hacks to important comments so they will be kept
                        // in the output
                        source = s_regexHack1.Replace(source, "/*! \\*/${inner}/*!*/");
                        source = s_regexHack2.Replace(source, "/*!/*//*/${inner}/**/");
                        source = s_regexHack3.Replace(source, "/*!/*/${inner}/*!*/");
                        source = s_regexHack4.Replace(source, "/*!*/");
                        source = s_regexHack5.Replace(source, "/*!*/");
                        source = s_regexHack6.Replace(source, "/*!*/");
                        source = s_regexHack7.Replace(source, "/*!*/");

                        // now that we've changed all our hack comments to important comments, we can
                        // change the flag to Important so all non-important hacks are removed. 
                        // And set a flag to remind us to change it back before we exit, or the NEXT
                        // file we process will have the wrong setting.
                        Settings.CommentMode = CssComment.Important;
                        resetToHacks = true;
                    }

                    // set up for the parse
                    using (StringReader reader = new StringReader(source))
                    {
                        m_scanner = new CssScanner(reader);
                        m_scanner.AllowEmbeddedAspNetBlocks = this.Settings.AllowEmbeddedAspNetBlocks;
                        m_scanner.IgnoreRazorEscapeSequence = this.Settings.IgnoreRazorEscapeSequence;
                        m_scanner.DecodeEscapes = this.Settings.DecodeEscapes;
                        m_scanner.ScannerError += (sender, ea) =>
                            {
                                ea.Error.File = this.FileContext;
                                OnCssError(ea.Error);
                            };
                        m_scanner.ContextChange += (sender, ea) =>
                            {
                                FileContext = ea.FileContext;
                            };

                        // create the initial string builder into which we will be 
                        // building our crunched stylesheet.
                        m_builders = new Stack<StringBuilder>();
                        m_builders.Push(StringBuilderPool.Acquire(source.Length / 2));

                        // get the first token
                        NextToken();

                        switch (Settings.CssType)
                        {
                            case CssType.FullStyleSheet:
                                // parse a style sheet!
                                ParseStylesheet();
                                break;

                            case CssType.DeclarationList:
                                SkipIfSpace();
                                ParseDeclarationList(false);
                                break;

                            default:
                                Debug.Fail("UNEXPECTED CSS TYPE");
                                goto case CssType.FullStyleSheet;
                        }

                        if (!m_scanner.EndOfFile)
                        {
                            int errorNumber = (int)CssErrorCode.ExpectedEndOfFile;
                            OnCssError(new UglifyError()
                                {
                                    IsError = true,
                                    Severity = 0,
                                    Subcategory = UglifyError.GetSubcategory(0),
                                    File = FileContext,
                                    ErrorNumber = errorNumber,
                                    ErrorCode = "CSS{0}".FormatInvariant(errorNumber & (0xffff)),
                                    StartLine = m_currentToken.Context.Start.Line,
                                    StartColumn = m_currentToken.Context.Start.Char,
                                    Message = CssStrings.ExpectedEndOfFile,
                                });
                        }

                        // get the crunched string and dump the string builder
                        // (we don't need it anymore)
                        source = UnwindStackCompletely();
                        m_builders = null;
                    }
                }
                finally
                {
                    // if we had changed our setting object...
                    if (resetToHacks)
                    {
                        // ...be sure to change it BACK for next time.
                        Settings.CommentMode = CssComment.Hacks;
                    }
                }
            }

            return source;
        }

        #region output builders stack methods

        /// <summary>
        /// Push a new string builder onto the builders stack
        /// </summary>
        private void PushWaypoint()
        {
            m_builders.Push(StringBuilderPool.Acquire());
        }

        /// <summary>
        /// Pop the top waypoint off the stack.
        /// If the Settings RemoveEmptyBlocks property is false, will keep the text, regardless of the passed-in setting.
        /// </summary>
        /// <param name="keepText">true if push the text of the popped waypoint onto the new top waypoint; false to discard</param>
        /// <returns>true if the popped builder has any text within it</returns>
        private bool PopWaypoint(bool keepText)
        {
            var topBuilder = m_builders.Pop();
            if (keepText || !Settings.RemoveEmptyBlocks)
            {
                m_builders.Peek().Append(topBuilder.ToString());
            }

            var isNotEmpty = topBuilder.Length > 0;
            topBuilder.Release();
            return isNotEmpty;
        }

        /// <summary>
        /// Get all the text that has been accumulting in the string builders
        /// on the stack, unwinding the stack until it's empty
        /// </summary>
        /// <returns>string representation of all parsed text</returns>
        private string UnwindStackCompletely()
        {
            if (m_builders == null || m_builders.Count == 0)
            {
                // no builders - return an empty string
                return string.Empty;
            }

            if (m_builders.Count == 1)
            {
                // just one builder - return it's string after releasing it.
                var topBuilder = m_builders.Pop();
                var code = topBuilder.ToString();
                topBuilder.Release();
                return code;
            }

            // multiple builders in the stack. Rather than unwinding the stack and
            // pushing each builder onto the previous one, which could add take extra 
            // buffer allocations for each one, instead create an array (we know how big it should be),
            // and stuff each builder's string into the array in reverse order. Then use 
            // string.concat for a single new string allocation.
            var codeList = new string[m_builders.Count];
            var ndx = codeList.Length - 1;
            while(ndx >= 0)
            {
                // pop the topmost builder from the stack and get the text that
                // has been built up inside it and add it to the array in reverse order.
                var topBuilder = m_builders.Pop();
                codeList[ndx--] = topBuilder.ToString();
                topBuilder.Release();
            }

            return string.Concat(codeList);
        }

        #endregion

        #region Character set rule handling

        private string HandleCharset(string source)
        {
            // normally we let the encoding switch decode the input file for us, so every character in
            // the source string has already been decoded into the proper UNICODE character point.
            // HOWEVER, that doesn't mean the person passing us the source string has used the right encoding
            // to read the file. Check to see if there's a BOM that hasn't been decoded properly. If so, then
            // that indicates a potential error condition. And if we have a proper BOM, then everything was okay,
            // but we want to strip it off the source so it doesn't interfere with the parsing.
            // We SHOULD also check for a @charset rule to see if we need to re-decode the string. But for now, just
            // throw a low-pri warning if we see an improperly-decided BOM.

            // but first, if it starts with a source comment that we probably added, then we need to pull it off
            // and save it for later.
            var initialSourceDirective = string.Empty;
            if (source.StartsWith("/*/#SOURCE", StringComparison.OrdinalIgnoreCase))
            {
                // find the end of the comment
                var endOfComment = source.IndexOf("*/", 10, StringComparison.Ordinal);
                if (endOfComment > 0)
                {
                    // now skip the first line break if there is one
                    endOfComment += 2;
                    if (source[endOfComment] == '\r')
                    {
                        ++endOfComment;
                        if (source[endOfComment] == '\n')
                        {
                            ++endOfComment;
                        }
                    }
                    else if (source[endOfComment] == '\n' || source[endOfComment] == '\f')
                    {
                        ++endOfComment;
                    }

                    // save the comment and strip it off the source (for now)
                    initialSourceDirective = source.Substring(0, endOfComment);
                    source = source.Substring(endOfComment);
                }
            }

            if (source.StartsWith("\u00ef\u00bb\u00bf", StringComparison.Ordinal))
            {
                // if the first three characters are EF BB BF, then the source file had a UTF-8 BOM in it, but 
                // the BOM didn't get stripped. We MIGHT have some issues: the file indicated it's UTF-8 encoded,
                // but if we didn't properly decode the BOM, then other non-ASCII character sequences might also be
                // improperly decoded. Because that's an IF, we will only throw a pri-1 "programmer may not have intended this"
                // error. However, first check to see if there's a @charset "ascii"; statement at the front. If so,
                // then don't throw any error at all because everything should be ascii, in which case we're most-likely
                // good to go. The quote may be single or double, and the ASCII part should be case-insensentive.
                var charsetAscii = "@charset ";
                if (string.CompareOrdinal(source, 3, charsetAscii, 0, charsetAscii.Length) != 0
                    || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')
                    || string.Compare(source, 4 + charsetAscii.Length, "ascii", 0, 5, StringComparison.OrdinalIgnoreCase) != 0)
                {
                    // we either don't have a @charset statement, or it's pointing to something other than ASCII, in which
                    // case we might have a problem here. But because that's a "MIGHT," let's make it a pri-1 instead of
                    // a pri-0. If there are any problems, the output will be wonky and the developer can up the warning-level
                    // and see this error, then use the proper encoding to read the source. 
                    ReportError(1, CssErrorCode.PossibleCharsetError);
                }

                // remove the BOM
                source = source.Substring(3);
            }
            else if (source.StartsWith("\u00fe\u00ff\u0000\u0000", StringComparison.Ordinal)
                || source.StartsWith("\u0000\u0000\u00ff\u00fe", StringComparison.Ordinal))
            {
                // apparently we had a UTF-32 BOM (either BE or LE) that wasn't stripped. Remove it now.
                // throw a syntax-level error because the rest of the file is probably whack.
                ReportError(0, CssErrorCode.PossibleCharsetError);
                source = source.Substring(4);
            }
            else if (source.StartsWith("\u00fe\u00ff", StringComparison.Ordinal)
                || source.StartsWith("\u00ff\u00fe", StringComparison.Ordinal))
            {
                // apparently we had a UTF-16 BOM (either BE or LE) that wasn't stripped. Remove it now.
                // throw a syntax-level error because the rest of the file is probably whack.
                ReportError(0, CssErrorCode.PossibleCharsetError);
                source = source.Substring(2);
            }
            else if (source.Length > 0 && source[0] == '\ufeff')
            {
                // properly-decoded UNICODE BOM was at the front. Everything should be okay, but strip it
                // so it doesn't interfere with the rest of the processing.
                source = source.Substring(1);
            }

            return string.Concat(initialSourceDirective, source);
        }

        /// <summary>
        /// Returns true if the given property is vendor-specific and the vendor prefix
        /// is in the list of excluded prefixes.
        /// </summary>
        /// <param name="propertyName">The property name</param>
        /// <returns>true if excluded; false otherwise</returns>
        private bool IsExcludedVendorPrefix(string propertyName)
        {
            bool isExcluded = false;
            var match = s_vendorSpecific.Match(propertyName);
            if (match.Success)
            {
                isExcluded = Settings.ExcludeVendorPrefixes.Contains(match.Result("$vendor"));
            }

            return isExcluded;
        }

        #endregion

        #region Parse... methods

        private Parsed ParseStylesheet()
        {
            Parsed parsed = Parsed.False;

            // ignore any semicolons that may be the result of concatenation on the part of NUglify
            SkipSemicolons();

            // the @charset token can ONLY be at the top of the file
            if (CurrentTokenType == TokenType.CharacterSetSymbol)
            {
                ParseCharset();
            }

            // any number of S, Comment, CDO, or CDC elements
            // (or semicolons possibly introduced via concatenation)
            ParseSCDOCDCComments();

            // any number of imports followed by S, Comment, CDO or CDC
            while (ParseImport() == Parsed.True)
            {
                // any number of S, Comment, CDO, or CDC elements
                // (or semicolons possibly introduced via concatenation)
                ParseSCDOCDCComments();
            }

            // any number of namespaces followed by S, Comment, CDO or CDC
            while (ParseNamespace() == Parsed.True)
            {
                // any number of S, Comment, CDO, or CDC elements
                // (or semicolons possibly introduced via concatenation)
                ParseSCDOCDCComments();
            }

            // the main guts of stuff
            while (ParseRule() == Parsed.True
              || ParseMedia() == Parsed.True
              || ParsePage() == Parsed.True
              || ParseFontFace() == Parsed.True
              || ParseKeyFrames() == Parsed.True
              || ParseAtKeyword() == Parsed.True
              || ParseAspNetBlock() == Parsed.True)
            {
                // any number of S, Comment, CDO or CDC elements
                // (or semicolons possibly introduced via concatenation)
                ParseSCDOCDCComments();
            }

            // if there weren't any errors, we SHOULD be at the EOF state right now.
            // if we're not, we may have encountered an invalid, unexpected character.
            while (!m_scanner.EndOfFile)
            {
                // throw an exception
                ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);

                // skip the token
                NextToken();

                // might be a comment again; check just in case
                // (or semicolons possibly introduced via concatenation)
                ParseSCDOCDCComments();

                // try the guts again
                while (ParseRule() == Parsed.True
                  || ParseMedia() == Parsed.True
                  || ParsePage() == Parsed.True
                  || ParseFontFace() == Parsed.True
                  || ParseAtKeyword() == Parsed.True
                  || ParseAspNetBlock() == Parsed.True)
                {
                    // any number of S, Comment, CDO or CDC elements
                    // (or semicolons possibly introduced via concatenation)
                    ParseSCDOCDCComments();
                }
            }

            return parsed;
        }

        private Parsed ParseCharset()
        {
            AppendCurrent();
            SkipSpace();

            if (CurrentTokenType != TokenType.String)
            {
                ReportError(0, CssErrorCode.ExpectedCharset, CurrentTokenText);
                SkipToEndOfStatement();
                AppendCurrent();
            }
            else
            {
                Append(' ');
                AppendCurrent();
                SkipSpace();

                if (CurrentTokenType != TokenType.Character || CurrentTokenText != ";")
                {
                    ReportError(0, CssErrorCode.ExpectedSemicolon, CurrentTokenText);
                    SkipToEndOfStatement();
                    // be sure to append the closing token (; or })
                    AppendCurrent();
                }
                else
                {
                    Append(';');
                    NextToken();
                }
            }

            return Parsed.True;
        }

        private void ParseSCDOCDCComments()
        {
            while (CurrentTokenType == TokenType.Space
              || CurrentTokenType == TokenType.Comment
              || CurrentTokenType == TokenType.CommentOpen
              || CurrentTokenType == TokenType.CommentClose
              || (CurrentTokenType == TokenType.Character && CurrentTokenText == ";"))
            {
                // don't output any space we encounter here, but do output comments.
                // we also want to skip over any semicolons we may encounter at this point
                if (CurrentTokenType != TokenType.Space && CurrentTokenType != TokenType.Character)
                {
                    AppendCurrent();
                }
                NextToken();
            }
        }

        /*
        private void ParseUnknownBlock()
        {
            // output the opening brace and move to the next
            AppendCurrent();
            // skip space -- there shouldn't need to be space after the opening brace
            SkipSpace();

            // loop until we find the closing breace
            while (!m_scanner.EndOfFile
              && (CurrentTokenType != TokenType.Character || CurrentTokenText != "}"))
            {
                // see if we are recursing unknown blocks
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "{")
                {
                    // recursive block
                    ParseUnknownBlock();
                }
                else if (CurrentTokenType == TokenType.AtKeyword)
                {
                    // parse the at-keyword
                    ParseAtKeyword();
                }
                else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ";")
                {
                    // append a semi-colon and skip any space after it
                    AppendCurrent();
                    SkipSpace();
                }
                else
                {
                    // whatever -- just append the token and move on
                    AppendCurrent();
                    NextToken();
                }
            }

            // output the closing brace and skip any trailing space
            AppendCurrent();
            SkipSpace();
        }
        */

        private Parsed ParseAtKeyword()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.AtKeyword)
            {
                // only report an unexpected at-keyword IF the identifier doesn't start 
                // with a hyphen, because that would be a vendor-specific at-keyword,
                // which is theoretically okay.
                if (!CurrentTokenText.StartsWith("@-", StringComparison.OrdinalIgnoreCase))
                {
                    ReportError(2, CssErrorCode.UnexpectedAtKeyword, CurrentTokenText);
                }

                SkipToEndOfStatement();
                AppendCurrent();
                SkipSpace();
                NewLine();
                parsed = Parsed.True;
            }
            else if(CurrentTokenType == TokenType.Supports)
            {
                parsed = ParseSupports();
            }
            else if (CurrentTokenType == TokenType.CharacterSetSymbol)
            {
                // we found a charset at-rule. Problem is, @charset can only be the VERY FIRST token
                // in the file, and we process it special. So if we get here, then it's NOT the first
                // token, and clients will ignore it. Throw a warning, but still process it.
                ReportError(2, CssErrorCode.UnexpectedCharset, CurrentTokenText);
                parsed = ParseCharset();
            }
            return parsed;
        }

        private Parsed ParseSupportsCondition(bool notOperatorAllowed, bool andOrOperatorsNeeded)
        {
            bool foundSupportsCondition = false;
            //more operators? no let parent finish ')'
            if (CurrentTokenType == TokenType.Character && andOrOperatorsNeeded)
            {
                if (CurrentTokenText == ")")
                {
                    return Parsed.Empty;
                }
            }

            bool operatorFound = false;
            if (CurrentTokenType == TokenType.Identifier)
            {
                operatorFound =
                ParseSupportsOperator(notOperatorAllowed, andOrOperatorsNeeded) == Parsed.True;
                if (!operatorFound) //no operator should be declaration then let parent finish that...
                {
                    return Parsed.Empty;
                }
            }

            if (CurrentTokenType == TokenType.Character && CurrentTokenText == "(")
            {
                AppendCurrent();
                SkipSpace();
                if (ParseSupportsCondition(true, false) == Parsed.True)
                {
                    foundSupportsCondition = true;
                }
                if (CurrentTokenType == TokenType.Identifier)
                {
                    if (ParseDeclaration() == Parsed.True)
                    {
                        foundSupportsCondition = true;
                        SkipIfSpace();
                        if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                        {
                            AppendCurrent();
                            SkipSpace();
                            ParseSupportsCondition(false, true);
                        }
                    }
                }
                else if (foundSupportsCondition && CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {//found a condition somewere so we can close up 
                    AppendCurrent();
                    SkipSpace(); //finish up
                }
                else
                {
                    ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                    return Parsed.False;
                }

            }
            return foundSupportsCondition ? Parsed.True : Parsed.False;
        }
        
        private Parsed ParseSupportsOperator(bool notOperatorAllowed, bool andOrOperatorsNeeded)
        {
            var parsed = Parsed.False;
            if (notOperatorAllowed)
            {
                if (CurrentTokenText.ToUpperInvariant() == "NOT")
                {
                    Append("not");
                    Append(' ');
                    SkipSpace();
                    parsed = Parsed.True;
                }
            }
            if (andOrOperatorsNeeded)
            {
                var upper = CurrentTokenText.ToUpperInvariant();
                if (upper == "AND" || upper == "OR")
                {
                    Append(' ');
                    Append(upper.ToLower());
                    Append(' ');
                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                    return Parsed.False;
                }
            }
            return parsed;
        }
        
        private Parsed ParseSupports()
        {
            bool notOperatorAllowed = false;
            bool andOrOperatorsNeeded = false;

            var keepDirective = true;
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Supports)
            {
                PushWaypoint();
                NewLine();
                AppendCurrent();
                Append(' ');
                SkipSpace();


                if (CurrentTokenType == TokenType.Identifier)
                {
                    if (CurrentTokenText.ToUpperInvariant() == "NOT")
                    {
                        notOperatorAllowed = true;
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                        return Parsed.False;
                    }
                }

                if (ParseSupportsCondition(notOperatorAllowed, andOrOperatorsNeeded) == Parsed.True)
                {
                    // expect current token to be the opening brace when calling
                    if (CurrentTokenType != TokenType.Character || CurrentTokenText != "{")
                    {
                        ReportError(0, CssErrorCode.ExpectedOpenBrace, CurrentTokenText);
                        SkipToEndOfStatement();
                        AppendCurrent();
                        SkipSpace();
                    }
                    else
                    {
                        NewLine();
                        AppendCurrent();
                        SkipSpace();


                        PushWaypoint();

                        // the main guts of stuff (copied from stylesheet)
                        while (ParseRule() == Parsed.True
                          || ParseMedia() == Parsed.True
                          || ParsePage() == Parsed.True
                          || ParseFontFace() == Parsed.True
                          || ParseKeyFrames() == Parsed.True
                          || ParseAtKeyword() == Parsed.True
                          || ParseAspNetBlock() == Parsed.True)
                        {
                            // any number of S, Comment, CDO or CDC elements
                            // (or semicolons possibly introduced via concatenation)
                            ParseSCDOCDCComments();
                        }
                        SkipIfSpace();

                        keepDirective = PopWaypoint(true);

                        if (CurrentTokenType != TokenType.Character || CurrentTokenText != "}")
                        {
                            ReportError(0, CssErrorCode.ExpectedClosingBrace, CurrentTokenText);
                            SkipToEndOfStatement();
                        }
                        else
                        {
                            AppendCurrent();
                            SkipSpace();
                            parsed = Parsed.True;
                        }
                    }
                }
                PopWaypoint(keepDirective);
            }
            return parsed;
        }

        private Parsed ParseAspNetBlock()
        {
            Parsed parsed = Parsed.False;
            if (Settings.AllowEmbeddedAspNetBlocks &&
                CurrentTokenType == TokenType.AspNetBlock)
            {
                AppendCurrent();
                SkipSpace();
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParseNamespace()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.NamespaceSymbol)
            {
                NewLine();
                AppendCurrent();
                SkipSpace();

                if (CurrentTokenType == TokenType.Identifier)
                {
                    Append(' ');
                    AppendCurrent();

                    // if the namespace is not already in the list, 
                    // save current text as a declared namespace value 
                    // that can be used in the rest of the code
                    if (!m_namespaces.Add(CurrentTokenText))
                    {
                        // error -- we already have this namespace in the list
                        ReportError(1, CssErrorCode.DuplicateNamespaceDeclaration, CurrentTokenText);
                    }

                    SkipSpace();
                }

                if (CurrentTokenType != TokenType.String
                  && CurrentTokenType != TokenType.Uri)
                {
                    ReportError(0, CssErrorCode.ExpectedNamespace, CurrentTokenText);
                    SkipToEndOfStatement();
                    AppendCurrent();
                }
                else
                {
                    Append(' ');
                    AppendCurrent();
                    SkipSpace();

                    if (CurrentTokenType == TokenType.Character
                      && CurrentTokenText == ";")
                    {
                        Append(';');
                        SkipSpace();
                        NewLine();
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.ExpectedSemicolon, CurrentTokenText);
                        SkipToEndOfStatement();
                        AppendCurrent();
                    }
                }

                parsed = Parsed.True;
            }
            return parsed;
        }

        private void ValidateNamespace(string namespaceIdent)
        {
            // check it against list of all declared @namespace names
            if (!string.IsNullOrEmpty(namespaceIdent)
                && namespaceIdent != "*"
                && !m_namespaces.Contains(namespaceIdent))
            {
                ReportError(0, CssErrorCode.UndeclaredNamespace, namespaceIdent);
            }
        }

        private Parsed ParseKeyFrames()
        {
            // '@keyframes' IDENT '{' keyframes-blocks '}'
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.KeyFramesSymbol)
            {
                // found the @keyframes at-rule
                parsed = Parsed.True;

                NewLine();
                AppendCurrent();
                SkipSpace();

                // needs to be followed by an identifier
                if (CurrentTokenType == TokenType.Identifier || CurrentTokenType == TokenType.String)
                {
                    // if this is an identifier, then we need to make sure we output a space
                    // character so the identifier doesn't get attached to the previous @-rule
                    if (CurrentTokenType == TokenType.Identifier || Settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Append(' ');
                    }

                    AppendCurrent();
                    SkipSpace();
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                }

                // followed by keyframe blocks surrounded with curly-braces
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "{")
                {
                    if (Settings.BlocksStartOnSameLine == BlockStart.NewLine
                        || Settings.BlocksStartOnSameLine == BlockStart.UseSource && m_encounteredNewLine)
                    {
                        NewLine();
                    }
                    else if (Settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Append(' ');
                    }

                    AppendCurrent();
                    Indent();
                    NewLine();
                    SkipSpace();

                    ParseKeyFrameBlocks();

                    // better end with a curly-brace
                    Unindent();
                    NewLine();
                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == "}")
                    {
                        NewLine();
                        AppendCurrent();
                        SkipSpace();
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.ExpectedClosingBrace, CurrentTokenText);
                        SkipToEndOfDeclaration();
                    }
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedOpenBrace, CurrentTokenText);
                    SkipToEndOfStatement();
                }
            }
            return parsed;
        }

        private void ParseKeyFrameBlocks()
        {
            // [ keyframe-selectors block ]*
            while (ParseKeyFrameSelectors() == Parsed.True)
            {
                ParseDeclarationBlock(false);

                // set the force-newline flag to true so that any selectors we may find next
                // will start on a new line
                m_forceNewLine = true;
            }

            // reset the flag
            m_forceNewLine = false;
        }

        private Parsed ParseKeyFrameSelectors()
        {
            // [ 'from' | 'to' | PERCENTAGE ] [ ',' [ 'from' | 'to' | PERCENTAGE ] ]*
            Parsed parsed = Parsed.False;

            // see if we start with a percentage or the words "from" or "to"
            if (CurrentTokenType == TokenType.Percentage)
            {
                AppendCurrent();
                SkipSpace();
                parsed = Parsed.True;
            }
            else if (CurrentTokenType == TokenType.Identifier)
            {
                var upperIdent = CurrentTokenText.ToUpperInvariant();
                if (string.CompareOrdinal(upperIdent, "FROM") == 0
                    || string.CompareOrdinal(upperIdent, "TO") == 0)
                {
                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                }
            }

            // if we found one, keep going as long as there are others comma-separated
            while (parsed == Parsed.True && CurrentTokenType == TokenType.Character && CurrentTokenText == ",")
            {
                // append the comma, and if this is multiline mode, follow it with a space for readability
                AppendCurrent();
                if (Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }
                SkipSpace();

                // needs to be either a percentage or "from" or "to"
                if (CurrentTokenType == TokenType.Percentage)
                {
                    AppendCurrent();
                    SkipSpace();
                }
                else if (CurrentTokenType == TokenType.Identifier)
                {
                    var upperIdent = CurrentTokenText.ToUpperInvariant();
                    if (string.CompareOrdinal(upperIdent, "FROM") == 0
                        || string.CompareOrdinal(upperIdent, "TO") == 0)
                    {
                        AppendCurrent();
                        SkipSpace();
                    }
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedPercentageFromOrTo, CurrentTokenText);
                }
            }

            return parsed;
        }

        private Parsed ParseImport()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.ImportSymbol)
            {
                NewLine();
                AppendCurrent();
                SkipSpace();

                if (CurrentTokenType != TokenType.String
                  && CurrentTokenType != TokenType.Uri)
                {
                    ReportError(0, CssErrorCode.ExpectedImport, CurrentTokenText);
                    SkipToEndOfStatement();
                    AppendCurrent();
                }
                else
                {
                    // only need a space if this is a Uri -- a string starts with a quote delimiter
                    // and won't get parsed as teh end of the @import token
                    if (CurrentTokenType == TokenType.Uri || Settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Append(' ');
                    }

                    // append the file (string or uri)
                    AppendCurrent();
                    SkipSpace();

                    // optional comma-separated list of media queries
                    // won't need a space because the ending is either a quote or a paren
                    ParseMediaQueryList(false);

                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ";")
                    {
                        Append(';');
                        NewLine();
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.ExpectedSemicolon, CurrentTokenText);
                        SkipToEndOfStatement();
                        AppendCurrent();
                    }
                }
                SkipSpace();
                parsed = Parsed.True;
            }

            return parsed;
        }

        private Parsed ParseMedia()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.MediaSymbol)
            {
                // push a waypoint. We're not going to want to output this @media directive
                // if the rule collection is empty
                var keepDirective = true;
                PushWaypoint();

                NewLine();
                AppendCurrent();
                SkipSpace();

                var indented = false;

                // might need a space because the last token was @media
                if (ParseMediaQueryList(true) == Parsed.True)
                {
                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == "{")
                    {
                        if (Settings.BlocksStartOnSameLine == BlockStart.NewLine
                            || Settings.BlocksStartOnSameLine == BlockStart.UseSource && m_encounteredNewLine)
                        {
                            NewLine();
                        }
                        else if (Settings.OutputMode == OutputMode.MultipleLines)
                        {
                            Append(' ');
                        }

                        AppendCurrent();
                        Indent();
                        indented = true;
                        SkipSpace();

                        // push a waypoint for the rules inside the @media directive
                        PushWaypoint();

                        // the main guts of stuff
                        while (ParseRule() == Parsed.True
                          || ParseMedia() == Parsed.True
                          || ParsePage() == Parsed.True
                          || ParseFontFace() == Parsed.True
                          || ParseAtKeyword() == Parsed.True
                          || ParseAspNetBlock() == Parsed.True)
                        {
                            // any number of S, Comment, CDO or CDC elements
                            ParseSCDOCDCComments();
                        }

                        // we want to keep this directive if we've actually parsed anything;
                        // otherwise we'll throw out the whole thing.
                        keepDirective = PopWaypoint(true);
                    }
                    else
                    {
                        SkipToEndOfStatement();
                    }

                    if (CurrentTokenType == TokenType.Character)
                    {
                        if (CurrentTokenText == ";")
                        {
                            AppendCurrent();
                            if (indented)
                            {
                                Unindent();
                            }
                            
                            NewLine();
                        }
                        else if (CurrentTokenText == "}")
                        {
                            if (indented)
                            {
                                Unindent();
                            }

                            NewLine();
                            AppendCurrent();
                        }
                        else
                        {
                            SkipToEndOfStatement();
                            AppendCurrent();
                        }
                    }
                    else
                    {
                        SkipToEndOfStatement();
                        AppendCurrent();
                    }

                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    SkipToEndOfStatement();
                }

                PopWaypoint(keepDirective);
            }

            return parsed;
        }

        private Parsed ParseMediaQueryList(bool mightNeedSpace)
        {
            // see if we have a media query
            Parsed parsed = ParseMediaQuery(mightNeedSpace);

            // it's a comma-separated list, so as long as we find a comma, keep parsing queries
            while(CurrentTokenType == TokenType.Character && CurrentTokenText == ",")
            {
                // output the comma and skip any space
                AppendCurrent();
                SkipSpace();

                if (ParseMediaQuery(false) != Parsed.True)
                {
                    // fail
                    ReportError(0, CssErrorCode.ExpectedMediaQuery, CurrentTokenText);
                }
            }

            return parsed;
        }

        private Parsed ParseMediaQuery(bool firstQuery)
        {
            var parsed = Parsed.False;
            var mightNeedSpace = firstQuery;

            // we have an optional word ONLY or NOT -- they will show up as identifiers here
            if (CurrentTokenType == TokenType.Identifier &&
                (string.Compare(CurrentTokenText, "ONLY", StringComparison.OrdinalIgnoreCase) == 0
                || string.Compare(CurrentTokenText, "NOT", StringComparison.OrdinalIgnoreCase) == 0))
            {
                // if this is the first query, the last thing we output was @media, which will need a separator.
                // if it's not the first, the last thing was a comma, so no space is needed.
                // but if we're expanding the output, we always want a space
                if (firstQuery || Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }

                // output the only/not string and skip any subsequent space
                AppendCurrent();
                SkipSpace();
                
                // we might need a space since the last thing was the only/not
                mightNeedSpace = true;
            }

            // we should be at a either a media type or an expression
            if (CurrentTokenType == TokenType.Identifier)
            {
                // media type
                // if we might need a space, output it now
                if (mightNeedSpace || Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }

                // output the media type
                AppendCurrent();
                SkipSpace();

                // the media type is an identifier, so we might need a space
                mightNeedSpace = true;

                // the next item should be either AND or the start of the block
                parsed = Parsed.True;
            }
            else if (CurrentTokenType == TokenType.Character && CurrentTokenText == "(")
            {
                // no media type -- straight to an expression
                ParseMediaQueryExpression();

                // The straight-up spec says the whitespace is optional, so at this point you'd
                // THINK we wouldn't need whitespace between a close-paren and the word "and."
                // However, there is an errata published:
                // http://www.w3.org/Style/2012/REC-mediaqueries-20120619-errata.html
                // that makes whitespace before the AND mandatory.
                // The errata is completely correct with regards to making the whitespace AFTER
                // the "and" mandatory -- we need to be disambiguous: is it "and" followed by a "(",
                // or is it the FUNCTION "and("? Not sure the before is strictly mandatory, but
                // let's roll with it.
                mightNeedSpace = true;

                // the next item should be either AND or the start of the block
                parsed = Parsed.True;
            }
            else if (CurrentTokenType != TokenType.Character || CurrentTokenText != ";")
            {
                // expected a media type
                ReportError(0, CssErrorCode.ExpectedMediaIdentifier, CurrentTokenText);
            }

            // either we have no more and-delimited expressions,
            // OR we have an *identifier* AND (and followed by space)
            // OR we have a *function* AND (and followed by the opening paren, scanned as a function)
            while ((CurrentTokenType == TokenType.Identifier
                && string.Compare(CurrentTokenText, "AND", StringComparison.OrdinalIgnoreCase) == 0)
                || (CurrentTokenType == TokenType.Function
                && string.Compare(CurrentTokenText, "AND(", StringComparison.OrdinalIgnoreCase) == 0))
            {
                // if we might need a space, output it now
                if (mightNeedSpace || Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }

                // output the AND text.
                // MIGHT be AND( if it was a function, so first set a flag so we will know
                // wether or not to expect the opening paren
                if (CurrentTokenType == TokenType.Function)
                {
                    // this is not strictly allowed by the CSS3 spec!
                    // we are going to throw an error
                    ReportError(1, CssErrorCode.MediaQueryRequiresSpace, CurrentTokenText);

                    //and then fix what the developer wrote and make sure there is a space
                    // between the AND and the (. The CSS3 spec says it is invalid to not have a
                    // space there.
                    Append("and (");
                    SkipSpace();

                    // included the paren
                    ParseMediaQueryExpression();
                }
                else
                {
                    // didn't include the paren -- it BETTER be the next token 
                    // (after we output the AND token)
                    AppendCurrent();
                    SkipSpace();
                    if (CurrentTokenType == TokenType.Character
                        && CurrentTokenText == "(")
                    {
                        // put a space between the AND and the (
                        Append(' ');

                        ParseMediaQueryExpression();
                    }
                    else
                    {
                        // error -- we expected another media query expression
                        ReportError(0, CssErrorCode.ExpectedMediaQueryExpression, CurrentTokenText);

                        // break out of the loop so we can exit
                        break;
                    }
                }
            }

            return parsed;
        }

        private void ParseMediaQueryExpression()
        {
            // expect current token to be the opening paren when calling
            if (CurrentTokenType == TokenType.Character && CurrentTokenText == "(")
            {
                // output the paren and skip any space
                AppendCurrent();
                SkipSpace();
            }

            // media feature is required, and it's an ident
            if (CurrentTokenType == TokenType.Identifier)
            {
                // output the media feature and skip any space
                AppendCurrent();
                SkipSpace();

                // the next token should either be a colon (followed by an expression) or the closing paren
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ":")
                {
                    // got an expression.
                    // output the colon and skip any whitespace
                    AppendCurrent();
                    SkipSpace();

                    // if we are expanding the output, we want a space after the colon
                    if (Settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Append(' ');
                    }

                    // parse the expression -- it's not optional
                    if (ParseExpr() != Parsed.True)
                    {
                        ReportError(0, CssErrorCode.ExpectedExpression, CurrentTokenText);
                    }

                    // better be the closing paren
                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                    {
                        // output the closing paren and skip any whitespace
                        AppendCurrent();
                        SkipSpace();
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                    }
                }
                else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {
                    // end of the expressions -- output the closing paren and skip any whitespace
                    AppendCurrent();
                    SkipSpace();
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                }
            }
            else
            {
                ReportError(0, CssErrorCode.ExpectedMediaFeature, CurrentTokenText);
            }
        }

        private Parsed ParseDeclarationBlock(bool allowMargins)
        {
            var parsed = Parsed.True;

            // expect current token to be the opening brace when calling
            if (CurrentTokenType != TokenType.Character || CurrentTokenText != "{")
            {
                ReportError(0, CssErrorCode.ExpectedOpenBrace, CurrentTokenText);
                SkipToEndOfStatement();
                AppendCurrent();
                SkipSpace();
            }
            else
            {
                if (Settings.BlocksStartOnSameLine == BlockStart.NewLine
                    || Settings.BlocksStartOnSameLine == BlockStart.UseSource && m_encounteredNewLine)
                {
                    NewLine();
                }
                else if (Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }

                Append('{');

                Indent();
                SkipSpace();

                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "}")
                {
                    // shortcut nothing in the block to have the close on the same line
                    Unindent();
                    AppendCurrent();
                    SkipSpace();

                    // return parsed empty to indicate that the block is a valid, empty block
                    parsed = Parsed.Empty;
                }
                else
                {
                    ParseDeclarationList(allowMargins);
                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == "}")
                    {
                        // append the closing brace
                        Unindent();
                        NewLine();
                        Append('}');
                        // skip past it
                        SkipSpace();
                    }
                    else if (m_scanner.EndOfFile)
                    {
                        // no closing brace, just the end of the file
                        ReportError(0, CssErrorCode.UnexpectedEndOfFile);
                    }
                    else
                    {
                        // I'm pretty sure ParseDeclarationList will only return on two situations:
                        //   1. closing brace (}), or
                        //   2. EOF.
                        // shouldn't get here, but just in case.
                        ReportError(0, CssErrorCode.ExpectedClosingBrace, CurrentTokenText);
                        Debug.Fail("UNEXPECTED CODE");
                    }
                }
            }

            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private Parsed ParseDeclarationList(bool allowMargins)
        {
            var parsed = Parsed.Empty;
            while (!m_scanner.EndOfFile)
            {
                // check the line length before each new declaration -- if we're past the threshold, start a new line
                if (m_lineLength >= Settings.LineBreakThreshold)
                {
                    AddNewLine();
                }

                Parsed parsedDecl = ParseDeclaration();
                if (parsed == Parsed.Empty && parsedDecl != Parsed.Empty)
                {
                    parsed = parsedDecl;
                }

                // if we are allowed to have margin at-keywords in this block, and
                // we didn't find a declaration, check to see if it's a margin
                var parsedMargin = false;
                if (allowMargins && parsedDecl == Parsed.Empty)
                {
                    parsedMargin = ParseMargin() == Parsed.True;
                }

                // if we parsed a margin, we DON'T expect there to be a semi-colon.
                // if we didn't parse a margin, then there better be either a semicolon or a closing brace.
                if (!parsedMargin)
                {
                    if ((CurrentTokenType != TokenType.Character
                        || (CurrentTokenText != ";" && CurrentTokenText != "}"))
                        && !m_scanner.EndOfFile)
                    {
                        ReportError(0, CssErrorCode.ExpectedSemicolonOrClosingBrace, CurrentTokenText);

                        // we'll get here if we decide to ignore the error and keep trudging along. But we still
                        // need to skip to the end of the declaration.
                        SkipToEndOfDeclaration();
                    }
                }

                // if we're at the end, close it out
                if (m_scanner.EndOfFile)
                {
                    // if we want to force a terminating semicolon, add it now
                    if (Settings.TermSemicolons)
                    {
                        Append(';');
                    }
                }
                else if (CurrentTokenText == "}")
                {
                    // if we want terminating semicolons but the source
                    // didn't have one (evidenced by a non-empty declaration)...
                    if (Settings.TermSemicolons && parsedDecl == Parsed.True)
                    {
                        // ...then add one now.
                        Append(';');
                    }

                    break;
                }
                else if (CurrentTokenText == ";")
                {
                    // token is a semi-colon
                    // if we always want to add the semicolons, add it now
                    if (Settings.TermSemicolons)
                    {
                        Append(';');
                        SkipSpace();
                    }
                    else
                    {
                        // we have a semicolon, but we don't know if we can
                        // crunch it out or not. If the NEXT token is a closing brace, then
                        // we can crunch out the semicolon.
                        // PROBLEM: if there's a significant comment AFTER the semicolon, then the 
                        // comment gets output before we output the semicolon, which could
                        // reverse the intended code.

                        // skip any whitespace to see if we need to add a semicolon
                        // to the end, or if we can crunch it out, but use a special function
                        // that doesn't send any comments to the stream yet -- it batches them
                        // up and returns them (if any)
                        string comments = NextSignificantToken();

                        if (m_scanner.EndOfFile)
                        {
                            // if we have an EOF after the semicolon and no comments, then we don't want
                            // to output anything else.
                            if (comments.Length > 0)
                            {
                                // but if we have comments after the semicolon....
                                // if there's a non-empty comment, it might be a significant hack, so add the semi-colon just in case.
                                if (comments != "/* */" && comments != "/**/")
                                {
                                    Append(';');
                                }

                                // and comments always end on a new line
                                Append(comments);
                                m_outputNewLine = true;
                                m_lineLength = 0;
                            }
                            break;
                        }
                        else if (CurrentTokenType != TokenType.Character
                            || (CurrentTokenText != "}" && CurrentTokenText != ";")
                            || (comments.Length > 0 && comments != "/* */" && comments != "/**/"))
                        {
                            // if the significant token after the 
                            // semicolon is not a cosing brace, then we'll add the semicolon.
                            // if there are two semi-colons in a row, don't add it because we'll double it.
                            // if there's a non-empty comment, it might be a significant hack, so add the semi-colon just in case.
                            Append(';');
                        }

                        // now that we've possibly added our semi-colon, we're safe
                        // to add any comments we may have found before the current token
                        if (comments.Length > 0)
                        {
                            Append(comments);

                            // and comments always end on a new line
                            m_outputNewLine = true;
                            m_lineLength = 0;
                        }
                    }
                }
            }

            return parsed;
        }

        private Parsed ParsePage()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.PageSymbol)
            {
                var keepDirective = true;
                PushWaypoint();

                NewLine();
                AppendCurrent();
                SkipSpace();

                if (CurrentTokenType == TokenType.Identifier)
                {
                    Append(' ');
                    AppendCurrent();
                    NextToken();
                }
                // optional
                ParsePseudoPage();

                if (CurrentTokenType == TokenType.Space)
                {
                    SkipSpace();
                }

                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "{")
                {
                    // allow margin at-keywords
                    parsed = ParseDeclarationBlock(true);
                    if (parsed == Parsed.Empty)
                    {
                        keepDirective = false;
                        parsed = Parsed.True;
                    }

                    NewLine();
                }
                else
                {
                    SkipToEndOfStatement();
                    AppendCurrent();
                    SkipSpace();
                }

                PopWaypoint(keepDirective);
            }
            return parsed;
        }

        private Parsed ParsePseudoPage()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Character && CurrentTokenText == ":")
            {
                Append(':');
                NextToken();

                if (CurrentTokenType != TokenType.Identifier)
                {
                    ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                }

                AppendCurrent();
                NextToken();
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParseMargin()
        {
            var parsed = Parsed.Empty;
            var keepDirective = true;
            switch (CurrentTokenType)
            {
                case TokenType.TopLeftCornerSymbol:
                case TokenType.TopLeftSymbol:
                case TokenType.TopCenterSymbol:
                case TokenType.TopRightSymbol:
                case TokenType.TopRightCornerSymbol:
                case TokenType.BottomLeftCornerSymbol:
                case TokenType.BottomLeftSymbol:
                case TokenType.BottomCenterSymbol:
                case TokenType.BottomRightSymbol:
                case TokenType.BottomRightCornerSymbol:
                case TokenType.LeftTopSymbol:
                case TokenType.LeftMiddleSymbol:
                case TokenType.LeftBottomSymbol:
                case TokenType.RightTopSymbol:
                case TokenType.RightMiddleSymbol:
                case TokenType.RightBottomSymbol:
                    // these are the margin at-keywords
                    PushWaypoint();
                    NewLine();
                    AppendCurrent();
                    SkipSpace();

                    // don't allow margin at-keywords
                    parsed = ParseDeclarationBlock(false);
                    if (parsed == Parsed.Empty)
                    {
                        keepDirective = false;
                        parsed = Parsed.True;
                    }

                    NewLine();
                    PopWaypoint(keepDirective);
                    break;

                default:
                    // we're not interested
                    break;
            }
            return parsed;
        }

        private Parsed ParseFontFace()
        {
            var parsed = Parsed.False;
            if (CurrentTokenType == TokenType.FontFaceSymbol)
            {
                var keepDirective = true;
                PushWaypoint();

                NewLine();
                AppendCurrent();
                SkipSpace();

                // don't allow margin at-keywords
                parsed = ParseDeclarationBlock(false);
                if (parsed == Parsed.Empty)
                {
                    keepDirective = false;
                    parsed = Parsed.True;
                }

                NewLine();
                PopWaypoint(keepDirective);
            }
            return parsed;
        }

        private Parsed ParseOperator()
        {
            Parsed parsed = Parsed.Empty;
            if (CurrentTokenType == TokenType.Character
              && (CurrentTokenText == "/" || CurrentTokenText == ","))
            {
                AppendCurrent();
                SkipSpace();
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParseCombinator()
        {
            Parsed parsed = Parsed.Empty;
            if (CurrentTokenType == TokenType.Character
              && (CurrentTokenText == "+" || CurrentTokenText == ">" || CurrentTokenText == "~"))
            {
                AppendCurrent();
                SkipSpace();
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParseRule()
        {
            var keepRule = true;
            PushWaypoint();

            // check the line length before each new declaration -- if we're past the threshold, start a new line
            if (m_lineLength >= Settings.LineBreakThreshold)
            {
                AddNewLine();
            }

            m_forceNewLine = true;
            Parsed parsed = ParseSelector();
            if (parsed == Parsed.True)
            {
                if (m_scanner.EndOfFile)
                {
                    // we parsed a selector expecting this to be a rule, but then WHAM! we hit
                    // the end of the file. That isn't correct. Throw an error.
                    ReportError(0, CssErrorCode.UnexpectedEndOfFile);
                }

                while (!m_scanner.EndOfFile)
                {
                    if (CurrentTokenType != TokenType.Character
                        || (CurrentTokenText != "," && CurrentTokenText != "{"))
                    {
                        ReportError(0, CssErrorCode.ExpectedCommaOrOpenBrace, CurrentTokenText);
                        SkipToEndOfStatement();
                        AppendCurrent();
                        SkipSpace();
                        break;
                    }

                    if (CurrentTokenText == "{")
                    {
                        // REVIEW: IE6 has an issue where the "first-letter" and "first-line" 
                        // pseudo-classes need to be separated from the opening curly-brace 
                        // of the following rule set by a space or it doesn't get picked up. 
                        // So if the last-outputted word was "first-letter" or "first-line",
                        // add a space now (since we know the next character at this point 
                        // is the opening brace of a rule-set).
                        // Maybe some day this should be removed or put behind an "IE6-compat" switch.
                        if (m_lastOutputString == "first-letter" || m_lastOutputString == "first-line")
                        {
                            Append(' ');
                        }

                        // don't allow margin at-keywords
                        parsed = ParseDeclarationBlock(false);
                        if (parsed == Parsed.Empty)
                        {
                            keepRule = false;
                            parsed = Parsed.True;
                        }

                        break;
                    }

                    Append(',');

                    // check the line length before each new declaration -- if we're past the threshold, start a new line
                    if (m_lineLength >= Settings.LineBreakThreshold)
                    {
                        AddNewLine();
                    }
                    else if (Settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Append(' ');
                    }

                    SkipSpace();

                    if (ParseSelector() != Parsed.True)
                    {
                        if (CurrentTokenType == TokenType.Character && CurrentTokenText == "{")
                        {
                            // the author ended the last selector with a comma, but didn't include
                            // the next selector before starting the declaration block. Or maybe it's there,
                            // but commented out. Still okay, but flag a style warning.
                            ReportError(4, CssErrorCode.ExpectedSelector, CurrentTokenText);
                            continue;
                        }
                        else
                        {
                            // not something we know about -- skip the whole statement
                            ReportError(0, CssErrorCode.ExpectedSelector, CurrentTokenText);
                            SkipToEndOfStatement();
                        }
                        AppendCurrent();
                        SkipSpace();
                        break;
                    }
                }
            }

            PopWaypoint(keepRule);
            return parsed;
        }

        private Parsed ParseSelectorList()
        {
            var parsed = ParseSelector();
            while (CurrentTokenType == TokenType.Character && CurrentTokenText == ",")
            {
                // append the comma to the output and skip it any any other
                // space following it
                AppendCurrent();
                SkipSpace();

                // parse another selector. Don't save the parsed result because this
                // function should return true now, since we parsed at least one selected
                // successfully
                if (ParseSelector() != Parsed.True)
                {
                    // but if we fail for any reason, then break out of the loop after reporting
                    // an error
                    ReportError(0, CssErrorCode.ExpectedSelector, CurrentTokenText);
                    break;
                }
            }

            return parsed;
        }

        private Parsed ParseSelector()
        {
            // should start with a selector
            Parsed parsed = ParseSimpleSelector();
            if (parsed == Parsed.False && CurrentTokenType != TokenType.None)
            {
                // no selector? See if it starts with a combinator.
                // common IE-7 hack to start with a combinator, because that browser will assume a beginning *
                var currentContext = m_currentToken.Context;
                var possibleCombinator = CurrentTokenText;
                parsed = ParseCombinator();
                if (parsed == Parsed.True)
                {
                    ReportError(4, CssErrorCode.HackGeneratesInvalidCss, currentContext, possibleCombinator);
                }
            }

            if (parsed == Parsed.True)
            {
                // save whether or not we are skipping anything by checking the type before we skip
                bool spaceWasSkipped = SkipIfSpace();

                while (!m_scanner.EndOfFile)
                {
                    Parsed parsedCombinator = ParseCombinator();
                    if (parsedCombinator != Parsed.True)
                    {
                        // we know the selector ends with a comma or an open brace,
                        // so if the next token is one of those, we're done.
                        // otherwise we're going to slap a space in the stream (if we found one)
                        // and look for the next selector
                        if (CurrentTokenType == TokenType.Character
                          && (CurrentTokenText == "," || CurrentTokenText == "{" || CurrentTokenText == ")"))
                        {
                            break;
                        }
                        else if (spaceWasSkipped)
                        {
                            Append(' ');
                        }
                    }

                    if (ParseSimpleSelector() == Parsed.False)
                    {
                        ReportError(0, CssErrorCode.ExpectedSelector, CurrentTokenText);
                        break;
                    }
                    else
                    {
                        // save the "we skipped whitespace" flag before skipping the whitespace
                        spaceWasSkipped = SkipIfSpace();
                    }
                }
            }
            return parsed;
        }

        // does NOT skip whitespace after the selector
        private Parsed ParseSimpleSelector()
        {
            // the element name is optional
            Parsed parsed = ParseElementName();
            while (!m_scanner.EndOfFile)
            {
                if (CurrentTokenType == TokenType.Hash)
                {
                    AppendCurrent();
                    NextToken();
                    parsed = Parsed.True;
                }
                else if (ParseClass() == Parsed.True)
                {
                    parsed = Parsed.True;
                }
                else if (ParseAttrib() == Parsed.True)
                {
                    parsed = Parsed.True;
                }
                else if (ParsePseudo() == Parsed.True)
                {
                    parsed = Parsed.True;
                }
                else
                {
                    break;
                }
            }
            return parsed;
        }

        private Parsed ParseClass()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Character
              && CurrentTokenText == ".")
            {
                AppendCurrent();
                NextToken();

                if (CurrentTokenType == TokenType.Identifier)
                {
                    AppendCurrent();
                    NextToken();
                    parsed = Parsed.True;
                }
                else if (CurrentTokenType == TokenType.Character && CurrentTokenText == "%")
                {
                    UpdateIfReplacementToken();
                    if (CurrentTokenType == TokenType.ReplacementToken)
                    {
                        AppendCurrent();
                        NextToken();
                        parsed = Parsed.True;
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                    }
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                }
            }
            else if (CurrentTokenType == TokenType.Dimension || CurrentTokenType == TokenType.Number)
            {
                string rawNumber = m_scanner.RawNumber;
                if (rawNumber != null && rawNumber.StartsWith(".", StringComparison.Ordinal))
                {
                    // if we are expecting a class but we got dimension or number that starts with a period,
                    // then what we REALLY have is a class name that starts with a digit. If it's all digits,
                    // it will be a number, and it it's just an identifier that starts with a digit, it will
                    // be a dimension.
                    // The problem here is that both of those those token type format the number, eg: 
                    // .000foo would get shrunk to 0foo.
                    // Be sure to use the RawNumber property on the scanner to get the raw text exactly as
                    // it was from the input
                    parsed = Parsed.True;

                    // but check the next token to see if it's an identifier.
                    // if the next token is an identifier with no whitespace between it and the previous
                    // "number," then it's part of this identifier
                    NextToken();
                    if (CurrentTokenType == TokenType.Identifier)
                    {
                        // add that identifier to the raw number
                        rawNumber += CurrentTokenText;
                        NextToken();
                    }

                    // report a low-sev warning before outputting the raw number text and advancing
                    ReportError(2, CssErrorCode.PossibleInvalidClassName, rawNumber);
                    Append(rawNumber);
                }
            }
            return parsed;
        }

        private Parsed ParseElementName()
        {
            Parsed parsed = Parsed.False;
            bool foundNamespace = false;

            // if the next character is a pipe, then we have an empty namespace prefix
            if (CurrentTokenType == TokenType.Character && CurrentTokenText == "|")
            {
                foundNamespace = true;
                AppendCurrent();
                NextToken();
            }

            if (CurrentTokenType == TokenType.Identifier
                || (CurrentTokenType == TokenType.Character && CurrentTokenText == "*"))
            {
                // if we already found a namespace, then there was none specified and the
                // element name started with |. Otherwise, save the current ident as a possible
                // namespace identifier
                string identifier = foundNamespace ? null : CurrentTokenText;

                AppendCurrent();
                NextToken();
                parsed = Parsed.True;

                // if the next character is a pipe, then that previous identifier or asterisk
                // was the namespace prefix
                if (!foundNamespace
                    && CurrentTokenType == TokenType.Character && CurrentTokenText == "|")
                {
                    // throw an error if identifier wasn't prevously defined by @namespace statement
                    ValidateNamespace(identifier);

                    // output the pipe and move to the true element name
                    AppendCurrent();
                    NextToken();

                    // a namespace and the bar character should ALWAYS be followed by
                    // either an identifier or an asterisk
                    if (CurrentTokenType == TokenType.Identifier
                        || (CurrentTokenType == TokenType.Character && CurrentTokenText == "*"))
                    {
                        AppendCurrent();
                        NextToken();
                    }
                    else
                    {
                        // we have an error condition
                        parsed = Parsed.False;
                        // handle the error
                        ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                    }
                }
            }
            else if (foundNamespace)
            {
                // we had found an empty namespace, but no element or universal following it!
                // handle the error
                ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
            }

            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private Parsed ParseAttrib()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Character
              && CurrentTokenText == "[")
            {
                Append('[');
                SkipSpace();

                bool foundNamespace = false;
                
                // must be either an identifier, an asterisk, or a namespace separator
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "|")
                {
                    // has an empty namespace
                    foundNamespace = true;
                    AppendCurrent();
                    NextToken();
                }

                if (CurrentTokenType == TokenType.Identifier
                    || (CurrentTokenType == TokenType.Character && CurrentTokenText == "*"))
                {
                    // if we already found a namespace, then there was none specified and the
                    // element name started with |. Otherwise, save the current ident as a possible
                    // namespace identifier
                    string identifier = foundNamespace ? null : CurrentTokenText;

                    AppendCurrent();
                    SkipSpace();

                    // check to see if that identifier is actually a namespace because the current
                    // token is a namespace separator
                    if (!foundNamespace 
                        && CurrentTokenType == TokenType.Character && CurrentTokenText == "|")
                    {
                        // namespaced attribute
                        // throw an error if the namespace hasn't previously been defined by a @namespace statement
                        ValidateNamespace(identifier);

                        // output the pipe and move to the next token,
                        // which should be the attribute name
                        AppendCurrent();
                        SkipSpace();

                        // must be either an identifier or an asterisk
                        if (CurrentTokenType == TokenType.Identifier
                            || (CurrentTokenType == TokenType.Character && CurrentTokenText == "*"))
                        {
                            // output the namespaced attribute name
                            AppendCurrent();
                            SkipSpace();
                        }
                        else
                        {
                            ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                        }
                    }
                }
                else
                {
                    // neither an identifier nor an asterisk
                    ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                }

                // check to see if there's an (optional) attribute operator
                if ((CurrentTokenType == TokenType.Character && CurrentTokenText == "=")
                  || (CurrentTokenType == TokenType.Includes)
                  || (CurrentTokenType == TokenType.DashMatch)
                  || (CurrentTokenType == TokenType.PrefixMatch)
                  || (CurrentTokenType == TokenType.SuffixMatch)
                  || (CurrentTokenType == TokenType.SubstringMatch))
                {
                    AppendCurrent();
                    SkipSpace();

                    if (CurrentTokenType == TokenType.Character
                        && CurrentTokenText == "%")
                    {
                        UpdateIfReplacementToken();
                        if (CurrentTokenType != TokenType.ReplacementToken)
                        {
                            ReportError(0, CssErrorCode.ExpectedIdentifierOrString, CurrentTokenText);
                        }
                    }
                    else if (CurrentTokenType != TokenType.Identifier
                      && CurrentTokenType != TokenType.String)
                    {
                        ReportError(0, CssErrorCode.ExpectedIdentifierOrString, CurrentTokenText);
                    }

                    AppendCurrent();
                    SkipSpace();
                }

                if (CurrentTokenType != TokenType.Character
                  || CurrentTokenText != "]")
                {
                    ReportError(0, CssErrorCode.ExpectedClosingBracket, CurrentTokenText);
                }

                // we're done!
                Append(']');
                NextToken();
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParsePseudo()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Character
              && CurrentTokenText == ":")
            {
                Append(':');
                NextToken();

                // CSS3 has pseudo-ELEMENTS that are specified with a double-colon.
                // IF we find a double-colon, we will treat it exactly the same as if it were a pseudo-CLASS.
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ":")
                {
                    Append(':');
                    NextToken();
                }

                switch (CurrentTokenType)
                {
                    case TokenType.Identifier:
                        AppendCurrent();
                        NextToken();
                        break;

                    case TokenType.Not:
                    case TokenType.Any:
                    case TokenType.Matches:
                        AppendCurrent();
                        SkipSpace();

                        // the argument of an ANY/MATCHES pseudo function is a selector list,
                        // and Selectors 4 standards say NOT is also a selector list. Selectors 3
                        // says NOT is only a simple selector, but let's go with the later standard
                        parsed = ParseSelectorList();
                        if (parsed != Parsed.True)
                        {
                            // TODO: error? shouldn't we ALWAYS have a selector list inside a not()/matches()/any() function?
                        }

                        // skip any whitespace if we have it
                        SkipIfSpace();

                        // don't forget the closing paren
                        if (CurrentTokenType != TokenType.Character
                          || CurrentTokenText != ")")
                        {
                            ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                        }
                        AppendCurrent();
                        NextToken();
                        break;

                    case TokenType.Function:
                        AppendCurrent();
                        SkipSpace();

                        // parse the function argument expression
                        ParseExpression();

                        // IE extends CSS3 grammar to provide for multiple arguments to pseudo-class
                        // functions. So as long as the current token is a comma, keep on parsing
                        // expressions.
                        while (CurrentTokenType == TokenType.Character
                            && CurrentTokenText == ",")
                        {
                            AppendCurrent();
                            NextToken();
                            ParseExpression();
                        }

                        if (CurrentTokenType != TokenType.Character
                          || CurrentTokenText != ")")
                        {
                            ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                        }
                        AppendCurrent();
                        NextToken();
                        break;

                    default:
                        ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                        break;
                }
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParseExpression()
        {
            Parsed parsed = Parsed.Empty;
            while(true)
            {
                switch(CurrentTokenType)
                {
                    case TokenType.Dimension:
                    case TokenType.Number:
                    case TokenType.String:
                    case TokenType.Identifier:
                        // just output these token types
                        parsed = Parsed.True;
                        AppendCurrent();
                        NextToken();
                        break;

                    case TokenType.Space:
                        // ignore spaces
                        NextToken();
                        break;

                    case TokenType.Character:
                        if (CurrentTokenText == "+" || CurrentTokenText == "-")
                        {
                            parsed = Parsed.True;
                            AppendCurrent();
                            NextToken();
                        }
                        else
                        {
                            // anything else and we exit
                            return parsed;
                        }
                        break;

                    default:
                        // anything else and we bail
                        return parsed;
                }
            }
        }

        private Parsed ParseDeclaration()
        {
            Parsed parsed = Parsed.Empty;

            // see if the developer is using an IE hack of prefacing property names
            // with an asterisk -- IE seems to ignore it; other browsers will recognize
            // the invalid property name and ignore it.
            string prefix = null;
            if (CurrentTokenType == TokenType.Character 
                && (CurrentTokenText == "*" || CurrentTokenText == "."))
            {
                // spot a low-pri error because this is actually invalid CSS
                // taking advantage of an IE "feature"
                ReportError(4, CssErrorCode.HackGeneratesInvalidCss, CurrentTokenText);

                // save the prefix and skip it
                prefix = CurrentTokenText;
                NextToken();
            }

            if (CurrentTokenType == TokenType.Identifier)
            {
                // save the property name
                string propertyName = CurrentTokenText;

                // if this is an excluded property name, then set the no-output flag
                // so the declaration is not outputted (we'll always reset this flag at
                // the end of the function)
                if (Settings.ExcludeVendorPrefixes.Count > 0 && IsExcludedVendorPrefix(propertyName))
                {
                    m_noOutput = true;
                }

                NewLine();
                if (prefix != null)
                {
                    Append(prefix);
                }
                AppendCurrent();

                // we want to skip space BUT we want to preserve a space if there is a whitespace character
                // followed by a comment. So don't call the simple SkipSpace method -- that will output the
                // comment but ignore all whitespace.
                SkipSpaceComment();

                if (CurrentTokenType != TokenType.Character
                  || CurrentTokenText != ":")
                {
                    ReportError(0, CssErrorCode.ExpectedColon, CurrentTokenText);
                    SkipToEndOfDeclaration();
                    return Parsed.True;
                }
                Append(':');
                if (Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }
                SkipSpace();

                if (m_valueReplacement != null)
                {
                    // output the replacement string
                    Append(m_valueReplacement);

                    // clear the replacement string
                    m_valueReplacement = null;

                    // set the no-output flag, parse the value, the reset the flag.
                    // we don't care if it actually finds a value or not
                    var notOutputting = m_noOutput;
                    m_noOutput = true;
                    ParseExpr();
                    m_noOutput = notOutputting;
                }
                else 
                {
                    m_parsingColorValue = MightContainColorNames(propertyName);
                    parsed = ParseExpr();
                    m_parsingColorValue = false;

                    if (parsed != Parsed.True)
                    {
                        ReportError(0, CssErrorCode.ExpectedExpression, CurrentTokenText);
                        SkipToEndOfDeclaration();
                        return Parsed.True;
                    }
                }

                // optional
                ParsePrio();

                parsed = Parsed.True;
                m_noOutput = false;
            }
            return parsed;
        }

        private Parsed ParsePrio()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.ImportantSymbol)
            {
                // issue #21057 - do not trip space before !important keyword.
                if (m_skippedSpace)
                {
                    Append(' ');
                }

                AppendCurrent();
                SkipSpace();

                // a common IE7-and-below hack is to append another ! at the end of !important.
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "!")
                {
                    ReportError(4, CssErrorCode.HackGeneratesInvalidCss, CurrentTokenText);
                    AppendCurrent();
                    SkipSpace();
                }

                parsed = Parsed.True;
            }
            else if (CurrentTokenType == TokenType.Character && CurrentTokenText == "!")
            {
                // another common IE7-and-below hack is to use an identifier OTHER than "important". All other browsers will see this
                // as an error, but IE7 and below will keep on processing. A common thing is to put !ie at the end to mark
                // the declaration as only for IE.
                if (Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }

                AppendCurrent();
                NextToken();
                if (CurrentTokenType == TokenType.Identifier)
                {
                    ReportError(4, CssErrorCode.HackGeneratesInvalidCss, CurrentTokenText);

                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    // but we need SOME identifier here....
                    ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                }
            }
            return parsed;
        }

        private Parsed ParseExpr()
        {
            Parsed parsed = ParseTerm(false);
            if (parsed == Parsed.True)
            {
                while (!m_scanner.EndOfFile)
                {
                    Parsed parsedOp = ParseOperator();
                    if (parsedOp != Parsed.False)
                    {
                        if (ParseTerm(parsedOp == Parsed.Empty) == Parsed.False)
                        {
                            break;
                        }
                    }
                }
            }
            return parsed;
        }

        private Parsed ParseFunctionParameters()
        {
            Parsed parsed = ParseTerm(false);
            if (parsed == Parsed.True)
            {
                while (!m_scanner.EndOfFile)
                {
                    if (CurrentTokenType == TokenType.Character
                      && CurrentTokenText == "=")
                    {
                        AppendCurrent();
                        SkipSpace();
                        ParseTerm(false);
                    }

                    Parsed parsedOp = ParseOperator();
                    if (parsedOp != Parsed.False)
                    {
                        if (ParseTerm(parsedOp == Parsed.Empty) == Parsed.False)
                        {
                            break;
                        }
                    }
                }
            }
            else if (parsed == Parsed.False
              && CurrentTokenType == TokenType.Character
              && CurrentTokenText == ")")
            {
                // it's okay to have no parameters in functions
                parsed = Parsed.Empty;
            }
            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private Parsed ParseTerm(bool wasEmpty)
        {
            Parsed parsed = Parsed.False;
            bool hasUnary = false;
            if (CurrentTokenType == TokenType.Character
                && (CurrentTokenText == "-" || CurrentTokenText == "+"))
            {
                if (wasEmpty)
                {
                    if (m_skippedSpace)
                    {
                        Append(' ');
                    }

                    wasEmpty = false;
                }

                AppendCurrent();
                NextToken();
                hasUnary = true;
            }

            switch (CurrentTokenType)
            {
                case TokenType.Hash:
                    if (hasUnary)
                    {
                        ReportError(0, CssErrorCode.HashAfterUnaryNotAllowed, CurrentTokenText);
                    }

                    if (wasEmpty)
                    {
                        Append(' ');
                        wasEmpty = false;
                    }
                    if (ParseHexcolor() == Parsed.False)
                    {
                        ReportError(0, CssErrorCode.ExpectedHexColor, CurrentTokenText);

                        // we expected the hash token to be a proper color -- but it's not.
                        // we threw an error -- go ahead and output the token as-is and keep going.
                        AppendCurrent();
                        SkipSpace();
                    }
                    parsed = Parsed.True;
                    break;

                case TokenType.String:
                case TokenType.Identifier:
                case TokenType.Uri:
                //case TokenType.RGB:
                case TokenType.UnicodeRange:
                    if (hasUnary)
                    {
                        ReportError(0, CssErrorCode.TokenAfterUnaryNotAllowed, CurrentTokenText);
                    }

                    // wasEmpty will be false if we DIDN'T find an operator
                    // as the last token. If we had an operator, then we can ignore
                    // any whitespace; but if we DIDN'T find an operator, then we
                    // will need to preserve a whitespace character to keep them 
                    // separated.
                    if (wasEmpty)
                    {
                        // if we had skipped any space, then add one now
                        if (m_skippedSpace)
                        {
                            Append(' ');
                        }

                        wasEmpty = false;
                    }

                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                    break;

                case TokenType.Dimension:
                    ReportError(2, CssErrorCode.UnexpectedDimension, CurrentTokenText);
                    goto case TokenType.Number;

                case TokenType.Number:
                case TokenType.Percentage:
                case TokenType.AbsoluteLength:
                case TokenType.RelativeLength:
                case TokenType.Angle:
                case TokenType.Time:
                case TokenType.Frequency:
                case TokenType.Resolution:
                    if (wasEmpty)
                    {
                        Append(' ');
                        wasEmpty = false;
                    }

                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                    break;

                case TokenType.ProgId:
                    if (wasEmpty)
                    {
                        Append(' ');
                        wasEmpty = false;
                    }
                    if (ParseProgId() == Parsed.False)
                    {
                        ReportError(0, CssErrorCode.ExpectedProgId, CurrentTokenText);
                    }
                    parsed = Parsed.True;
                    break;

                case TokenType.Function:
                    if (wasEmpty)
                    {
                        Append(' ');
                        wasEmpty = false;
                    }
                    if (ParseFunction() == Parsed.False)
                    {
                        ReportError(0, CssErrorCode.ExpectedFunction, CurrentTokenText);
                    }
                    parsed = Parsed.True;
                    break;

                case TokenType.Character:
                    if (CurrentTokenText == "(")
                    {
                        // the term starts with an opening paren.
                        // parse an expression followed by the close paren.
                        if (wasEmpty)
                        {
                            if (m_skippedSpace)
                            {
                                Append(' ');
                            }

                            wasEmpty = false;
                        }

                        AppendCurrent();
                        SkipSpace();

                        if (ParseExpr() == Parsed.False)
                        {
                            ReportError(0, CssErrorCode.ExpectedExpression, CurrentTokenText);
                        }

                        if (CurrentTokenType == TokenType.Character
                            && CurrentTokenText == ")")
                        {
                            AppendCurrent();
                            parsed = Parsed.True;

                            // the closing paren can only be followed IMMEDIATELY by the opening brace
                            // without any space if it's a repeat syntax.
                            m_skippedSpace = false;
                            NextRawToken();
                            if (CurrentTokenType == TokenType.Space)
                            {
                                m_skippedSpace = true;
                            }

                            // if the next token is an opening brace, then this might be
                            // a repeat operator
                            if (CurrentTokenType == TokenType.Character
                                && CurrentTokenText == "[")
                            {
                                AppendCurrent();
                                SkipSpace();

                                if (CurrentTokenType == TokenType.Number)
                                {
                                    AppendCurrent();
                                    SkipSpace();

                                    if (CurrentTokenType == TokenType.Character
                                        && CurrentTokenText == "]")
                                    {
                                        AppendCurrent();
                                        SkipSpace();
                                    }
                                    else
                                    {
                                        ReportError(0, CssErrorCode.ExpectedClosingBracket, CurrentTokenText);
                                        parsed = Parsed.False;
                                    }
                                }
                                else
                                {
                                    ReportError(0, CssErrorCode.ExpectedNumber, CurrentTokenText);
                                    parsed = Parsed.False;
                                }
                            }
                        }
                        else
                        {
                            ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                        }
                    }
                    else if ( CurrentTokenText == "%")
                    {
                        // see if this is the start of a replacement token
                        UpdateIfReplacementToken();
                        if (CurrentTokenType == TokenType.ReplacementToken)
                        {
                            // it was -- output it and move along
                            if (wasEmpty)
                            {
                                Append(' ');
                                wasEmpty = false;
                            }

                            AppendCurrent();
                            SkipSpace();
                            parsed = Parsed.True;
                        }
                        else
                        {
                            // nope; just a percent. 
                            goto default;
                        }
                    }
                    else
                    {
                        goto default;
                    }
                    break;

                default:
                    if (hasUnary)
                    {
                        ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                    }
                    break;
            }
            return parsed;
        }

        private Parsed ParseProgId()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.ProgId)
            {
                ReportError(4, CssErrorCode.ProgIdIEOnly);

                // set the state flag that tells us we should NOT abbreviate color
                // hash values as we are parsing our parameters
                m_noColorAbbreviation = true;

                // comma-separated lists of progid expressions should have a space after
                // the comma, or IE will ignore all but the last
                if (m_lastOutputString == ",")
                {
                    Append(" ");
                }

                // append the progid and opening paren
                AppendCurrent();
                SkipSpace();

                // the rest is a series of parameters: name=value, separated
                // by commas and ending with a close paren
                while (CurrentTokenType == TokenType.Identifier)
                {
                    AppendCurrent();
                    SkipSpace();

                    if (CurrentTokenType != TokenType.Character
                      && CurrentTokenText != "=")
                    {
                        ReportError(0, CssErrorCode.ExpectedEqualSign, CurrentTokenText);
                    }

                    Append('=');
                    SkipSpace();

                    if (ParseTerm(false) != Parsed.True)
                    {
                        ReportError(0, CssErrorCode.ExpectedTerm, CurrentTokenText);
                    }

                    if (CurrentTokenType == TokenType.Character
                      && CurrentTokenText == ",")
                    {
                        Append(',');
                        SkipSpace();
                    }
                }

                // reset the color-abbreviation flag
                m_noColorAbbreviation = false;

                // make sure we're at the close paren
                if (CurrentTokenType == TokenType.Character
                  && CurrentTokenText == ")")
                {
                    Append(')');
                    SkipSpace();
                }
                else
                {
                    ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                }
                parsed = Parsed.True;
            }
            return parsed;
        }

        private static string GetRoot(string text)
        {
            if (text.StartsWith("-", StringComparison.Ordinal))
            {
                var match = s_vendorSpecific.Match(text);
                if (match.Success)
                {
                    text = match.Result("${root}");
                }
            }

            return text;
        }

        private Parsed ParseFunction()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Function)
            {
                var functionText = GetRoot(CurrentTokenText);
                switch (functionText.ToUpperInvariant())
                {
                    case "RGB(":
                        parsed = ParseRgb();
                        break;

                    case "EXPRESSION(":
                        parsed = ParseExpressionFunction();
                        break;

                    case "CALC(":
                        parsed = ParseCalc();
                        break;

                    case "MIN(":
                    case "MAX(":
                        parsed = ParseMinMax();
                        break;

                    default:
                        // generic function parsing
                        AppendCurrent();
                        SkipSpace();

                        if (ParseFunctionParameters() == Parsed.False)
                        {
                            ReportError(0, CssErrorCode.ExpectedExpression, CurrentTokenText);
                        }

                        if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                        {
                            AppendCurrent();
                            SkipSpace();
                            parsed = Parsed.True;
                        }
                        else
                        {
                            ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                        }
                        break;
                }
            }
            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "we want lower-case output")]
        private Parsed ParseRgb()
        {
            var parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Function
                && string.Compare(CurrentTokenText, "rgb(", StringComparison.OrdinalIgnoreCase) == 0)
            {
                // rgb function parsing
                var useRGB = false;
                var crunchedRGB = false;
                // converting to #rrggbb or #rgb IF we don't find any significant comments!
                // skip any space or comments
                var rgb = new int[3];

                // we're going to be building up the rgb function just in case we need it
                var sbRGB = StringBuilderPool.Acquire();
                try
                {
                    sbRGB.Append(CurrentTokenText.ToLowerInvariant());

                    var comments = NextSignificantToken();
                    if (comments.Length > 0)
                    {
                        // add the comments
                        sbRGB.Append(comments);
                        // and signal that we need to use the RGB function because of them
                        useRGB = true;
                    }

                    for (var ndx = 0; ndx < 3; ++ndx)
                    {
                        // if this isn't the first number, we better find a comma separator
                        if (ndx > 0)
                        {
                            if (CurrentTokenType == TokenType.Character && CurrentTokenText == ",")
                            {
                                // add it to the rgb string builder
                                sbRGB.Append(',');
                            }
                            else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                            {
                                ReportError(0, CssErrorCode.ExpectedComma, CurrentTokenText);

                                // closing paren is the end of the function! exit the loop
                                useRGB = true;
                                break;
                            }
                            else
                            {
                                ReportError(0, CssErrorCode.ExpectedComma, CurrentTokenText);
                                sbRGB.Append(CurrentTokenText);
                                useRGB = true;
                            }

                            // skip to the next significant
                            comments = NextSignificantToken();
                            if (comments.Length > 0)
                            {
                                // add the comments
                                sbRGB.Append(comments);
                                // and signal that we need to use the RGB function because of them
                                useRGB = true;
                            }
                        }

                        // although we ALLOW negative numbers here, we'll trim them
                        // later. But in the mean time, save a negation flag.
                        var negateNumber = false;
                        if (CurrentTokenType == TokenType.Character && CurrentTokenText == "-")
                        {
                            negateNumber = true;
                            comments = NextSignificantToken();
                            if (comments.Length > 0)
                            {
                                // add the comments
                                sbRGB.Append(comments);
                                // and signal that we need to use the RGB function because of them
                                useRGB = true;
                            }
                        }

                        // we might adjust the value, so save the token text
                        var tokenText = CurrentTokenText;

                        if (CurrentTokenType != TokenType.Number && CurrentTokenType != TokenType.Percentage)
                        {
                            ReportError(0, CssErrorCode.ExpectedRgbNumberOrPercentage, CurrentTokenText);
                            useRGB = true;
                        }
                        else
                        {
                            if (CurrentTokenType == TokenType.Number)
                            {
                                // get the number value
                                float numberValue;
                                if (tokenText.TryParseSingleInvariant(out numberValue))
                                {
                                    numberValue *= (negateNumber ? -1 : 1);
                                    // make sure it's between 0 and 255
                                    if (numberValue < 0)
                                    {
                                        tokenText = "0";
                                        rgb[ndx] = 0;
                                    }
                                    else if (numberValue > 255)
                                    {
                                        tokenText = "255";
                                        rgb[ndx] = 255;
                                    }
                                    else
                                    {
                                        rgb[ndx] = System.Convert.ToInt32(numberValue);
                                    }
                                }
                                else
                                {
                                    // error -- not even a number. Keep the rgb function
                                    // (and don't change the token)
                                    useRGB = true;
                                }
                            }
                            else
                            {
                                // percentage
                                float percentageValue;
                                if (tokenText.Substring(0, tokenText.Length - 1).TryParseSingleInvariant(out percentageValue))
                                {
                                    percentageValue *= (negateNumber ? -1 : 1);
                                    if (percentageValue < 0)
                                    {
                                        tokenText = "0%";
                                        rgb[ndx] = 0;
                                    }
                                    else if (percentageValue > 100)
                                    {
                                        tokenText = "100%";
                                        rgb[ndx] = 255;
                                    }
                                    else
                                    {
                                        rgb[ndx] = System.Convert.ToInt32(percentageValue * 255 / 100);
                                    }
                                }
                                else
                                {
                                    // error -- not even a number. Keep the rgb function
                                    // (and don't change the token)
                                    useRGB = true;
                                }
                            }
                        }

                        // add the number to the rgb string builder
                        sbRGB.Append(tokenText);

                        // skip to the next significant
                        comments = NextSignificantToken();
                        if (comments.Length > 0)
                        {
                            // add the comments
                            sbRGB.Append(comments);
                            // and signal that we need to use the RGB function because of them
                            useRGB = true;
                        }
                    }

                    if (useRGB)
                    {
                        // something prevented us from collapsing the rgb function
                        // just output the rgb function we've been building up
                        Append(sbRGB.ToString());
                    }
                    else
                    {
                        // we can collapse it to either #rrggbb or #rgb
                        // calculate the full hex string and crunch it
                        var fullCode = "#{0:x2}{1:x2}{2:x2}".FormatInvariant(rgb[0], rgb[1], rgb[2]);
                        var hexString = CrunchHexColor(fullCode, Settings.ColorNames, m_noColorAbbreviation);
                        Append(hexString);

                        // set the flag so we know we don't want to add the closing paren
                        crunchedRGB = true;
                    }
                }
                finally
                {
                    sbRGB.Release();
                }

                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {
                    if (!crunchedRGB)
                    {
                        AppendCurrent();
                    }

                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                }
            }

            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "we want lower-case output")]
        private Parsed ParseExpressionFunction()
        {
            var parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Function
                && string.Compare(CurrentTokenText, "expression(", StringComparison.OrdinalIgnoreCase) == 0)
            {
                Append(CurrentTokenText.ToLowerInvariant());
                NextToken();

                // for now, just echo out everything up to the matching closing paren, 
                // taking into account that there will probably be other nested paren pairs. 
                // The content of the expression is JavaScript, so we'd really
                // need a full-blown JS-parser to crunch it properly. Kinda scary.
                // Start the parenLevel at 0 because the "expression(" token contains the first paren.
                string expressionCode = null;
                var jsBuilder = StringBuilderPool.Acquire();
                try
                {
                    int parenLevel = 0;

                    while (!m_scanner.EndOfFile
                      && (CurrentTokenType != TokenType.Character
                        || CurrentTokenText != ")"
                        || parenLevel > 0))
                    {
                        if (CurrentTokenType == TokenType.Function)
                        {
                            // the function token INCLUDES the opening parenthesis,
                            // so up the paren level whenever we find a function.
                            // AND this includes the actual expression( token -- so we'll
                            // hit this branch at the beginning. Make sure the parenLevel
                            // is initialized to take that into account
                            ++parenLevel;
                        }
                        else if (CurrentTokenType == TokenType.Character)
                        {
                            switch (CurrentTokenText)
                            {
                                case "(":
                                    // start a nested paren
                                    ++parenLevel;
                                    break;

                                case ")":
                                    // end a nested paren 
                                    // (we know it's nested because if it wasn't, we wouldn't
                                    // have entered the loop)
                                    --parenLevel;
                                    break;
                            }
                        }
                        jsBuilder.Append(CurrentTokenText);
                        NextToken();
                    }

                    // create a JSParser object with the source we found, crunch it, and send 
                    // the minified script to the output
                    expressionCode = jsBuilder.ToString();
                }
                finally
                {
                    jsBuilder.Release();
                }

                if (Settings.MinifyExpressions)
                {
                    // we want to minify the javascript expressions
                    JSParser jsParser = new JSParser();

                    // hook the error handler and set the "contains errors" flag to false.
                    // the handler will set the value to true if it encounters any errors
                    var containsErrors = false;
                    jsParser.CompilerError += (sender, ea) =>
                    {
                        ReportError(0, CssErrorCode.ExpressionError, ea.Error.Message);
                        containsErrors = true;
                    };

                    // parse the source as an expression using our common JS settings
                    var block = jsParser.Parse(new DocumentContext(expressionCode) { FileContext = this.FileContext }, m_jsSettings);

                    // if we got back a parsed block and there were no errors, output the minified code.
                    // if we didn't get back the block, or if there were any errors at all, just output
                    // the raw expression source.
                    if (block != null && !containsErrors)
                    {
                        Append(OutputVisitor.Apply(block, jsParser.Settings));
                    }
                    else
                    {
                        Append(expressionCode);
                    }
                }
                else
                {
                    // we don't want to minify expression code for some reason.
                    // just output the code exactly as we parsed it
                    Append(expressionCode);
                }

                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {
                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                }
            }

            return parsed;
        }

        private Parsed ParseHexcolor()
        {
            Parsed parsed = Parsed.False;

            if (CurrentTokenType == TokenType.Hash)
            {
                var colorHash = CurrentTokenText;
                var appendEscapedTab = false;

                // valid hash colors are #rgb, #rrggbb, and #aarrggbb.
                // but there is a commonly-used IE hack that puts \9 at the end of properties, so
                // if we have 5, 8, or 10 characters, let's first check to see if the color
                // ends in a tab.
                if ((colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)
                    && colorHash.EndsWith("\t", StringComparison.Ordinal))
                {
                    // it is -- strip that last character and set a flag
                    colorHash = colorHash.Substring(0, colorHash.Length - 1);
                    appendEscapedTab = true;
                }

                if (colorHash.Length == 4 || colorHash.Length == 7 || colorHash.Length == 9)
                {
                    parsed = Parsed.True;

                    // we won't do any conversion on the #aarrggbb formats to make them smaller.
                    string hexColor = CrunchHexColor(colorHash, Settings.ColorNames, m_noColorAbbreviation);
                    Append(hexColor);

                    if (appendEscapedTab)
                    {
                        Append("\\9");
                    }

                    SkipSpace();
                }
            }
            return parsed;
        }

        private Parsed ParseUnit()
        {
            var parsed = Parsed.Empty;

            // optional sign
            if (CurrentTokenType == TokenType.Character
                && (CurrentTokenText == "+" || CurrentTokenText == "-"))
            {
                AppendCurrent();
                NextToken();

                // set the parsed flag to false -- if we don't get a valid token
                // next and set it to true, then we know we had an error
                parsed = Parsed.False;
            }

            // followed by a number, a percentage, a dimension, a min(, a max(, or a parenthesized sum
            switch (CurrentTokenType)
            {
                case TokenType.Number:
                case TokenType.Percentage:
                case TokenType.Dimension:
                case TokenType.RelativeLength:
                case TokenType.AbsoluteLength:
                case TokenType.Angle:
                case TokenType.Time:
                case TokenType.Resolution:
                case TokenType.Frequency:
                    // output it, skip any whitespace, and mark us as okay
                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                    break;

                case TokenType.Function:
                    // calc( or attr( are allowed here.
                    parsed = ParseFunction();

                    // if parsed is false, then we encountered an error with the function
                    // and probably already output an error message. So only output an error
                    // message if we didn't find ANYTHING
                    if (parsed == Parsed.Empty)
                    {
                        ReportError(0, CssErrorCode.UnexpectedFunction, CurrentTokenText);
                        parsed = Parsed.False;
                    }
                    break;

                case TokenType.Character:
                    // only open parenthesis allowed
                    if (CurrentTokenText == "(")
                    {
                        // TODO: make sure there is whitespace before the ( if it would cause
                        // it to be the opening paren of a function token

                        AppendCurrent();
                        SkipSpace();

                        // better be a sum inside the parens
                        parsed = ParseSum();
                        if (parsed != Parsed.True)
                        {
                            // report error and change the parsed flag to false so we know there was an error
                            ReportError(0, CssErrorCode.ExpectedSum, CurrentTokenText);
                            parsed = Parsed.False;
                        }
                        else if (CurrentTokenType != TokenType.Character || CurrentTokenText != ")")
                        {
                            // needs to be a closing paren here
                            ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                            parsed = Parsed.False;
                        }
                        else
                        {
                            // we're at the closing paren, so output it now, advance past any
                            // subsequent whitespace, and mark us as okay
                            AppendCurrent();
                            SkipSpace();
                            parsed = Parsed.True;
                        }
                    }
                    break;
            }

            return parsed;
        }

        private Parsed ParseProduct()
        {
            // there needs to be at least one unit here
            var parsed = ParseUnit();
            if (parsed == Parsed.True)
            {
                // keep going while we have product operators
                // "mod" isn't a final operator, but it was in earlier drafts so keep allowing it.
                while ((CurrentTokenType == TokenType.Character && (CurrentTokenText == "*" || CurrentTokenText == "/"))
                    || (CurrentTokenType == TokenType.Identifier && string.Compare(CurrentTokenText, "mod", StringComparison.OrdinalIgnoreCase) == 0))
                {
                    if (CurrentTokenText == "*" || CurrentTokenText == "/")
                    {
                        // multiplication and dicision operators don't need spaces around them
                        // UNLESS we are outputting multi-line mode
                        if (Settings.OutputMode == OutputMode.MultipleLines)
                        {
                            Append(' ');
                        }

                        AppendCurrent();
                        if (Settings.OutputMode == OutputMode.MultipleLines)
                        {
                            Append(' ');
                        }
                    }
                    else
                    {
                        // the mod-operator usually needs space around it.
                        // and keep it lower-case.
                        Append(" mod ");
                    }

                    // skip any whitespace
                    SkipSpace();

                    // grab the next unit -- and there better be one
                    // technically the candidate spec says / can only be followed by NUMBER, not a UNIT, but
                    // let's let this slide and just parse a unit for both.
                    parsed = ParseUnit();
                    if (parsed != Parsed.True)
                    {
                        ReportError(0, CssErrorCode.ExpectedUnit, CurrentTokenText);
                        parsed = Parsed.False;
                    }
                }
            }
            else
            {
                // report an error and make sure we return false
                ReportError(0, CssErrorCode.ExpectedUnit, CurrentTokenText);
                parsed = Parsed.False;
            }

            return parsed;
        }

        private Parsed ParseSum()
        {
            // there needs to be at least one product here
            var parsed = ParseProduct();
            if (parsed == Parsed.True)
            {
                // keep going while we have sum operators
                while (CurrentTokenType == TokenType.Character && (CurrentTokenText == "+" || CurrentTokenText == "-"))
                {
                    // plus and minus operators need space around them.
                    Append(' ');
                    AppendCurrent();

                    // plus and minus operators both need spaces after them.
                    // the minus needs to not be an identifier.
                    Append(' ');

                    SkipSpace();

                    // grab the next product -- and there better be one
                    parsed = ParseProduct();
                    if (parsed != Parsed.True)
                    {
                        ReportError(0, CssErrorCode.ExpectedProduct, CurrentTokenText);
                        parsed = Parsed.False;
                    }
                }
            }
            else
            {
                // report an error and make sure we return false
                ReportError(0, CssErrorCode.ExpectedProduct, CurrentTokenText);
                parsed = Parsed.False;
            }

            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification="we want lower-case output")]
        private Parsed ParseMinMax()
        {
            // return false if the function isn't min or max
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Function
                && (string.Compare(CurrentTokenText, "min(", StringComparison.OrdinalIgnoreCase) == 0
                || string.Compare(CurrentTokenText, "max(", StringComparison.OrdinalIgnoreCase) == 0))
            {
                // output lower-case version and skip any space
                Append(CurrentTokenText.ToLowerInvariant());
                SkipSpace();

                // must be at least one sum
                parsed = ParseSum();

                // comma-delimited sums continue
                while (parsed == Parsed.True
                    && CurrentTokenType == TokenType.Character
                    && CurrentTokenText == ",")
                {
                    AppendCurrent();
                    SkipSpace();

                    parsed = ParseSum();
                }

                // end with the closing paren
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {
                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                    parsed = Parsed.False;
                }
            }

            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "we want lower-case output")]
        private Parsed ParseCalc()
        {
            var parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Function
                && string.Compare(GetRoot(CurrentTokenText), "calc(", StringComparison.OrdinalIgnoreCase) == 0)
            {
                Append(CurrentTokenText.ToLowerInvariant());
                SkipSpace();

                // contains one sum
                if (ParseSum() != Parsed.True)
                {
                    ReportError(0, CssErrorCode.ExpectedSum, CurrentTokenText);
                }

                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {
                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                }
            }

            return parsed;
        }

        #endregion

        #region Next... methods

        // skip to the next token, but output any comments we may find as we go along
        private TokenType NextToken()
        {
            m_currentToken = m_scanner.NextToken();
            EchoWriter?.Write(CurrentTokenText);

            m_encounteredNewLine = m_scanner.GotEndOfLine;
            while (CurrentTokenType == TokenType.Comment)
            {
                // the append statement might not actually append anything.
                // if it doesn't, we don't need to output a newline
                if (AppendCurrent())
                {
                    NewLine();
                }
                m_currentToken = m_scanner.NextToken();
                EchoWriter?.Write(CurrentTokenText);

                m_encounteredNewLine = m_encounteredNewLine || m_scanner.GotEndOfLine;
            }
            return CurrentTokenType;
        }

        // just skip to the next token; don't skip over comments
        private TokenType NextRawToken()
        {
            m_currentToken = m_scanner.NextToken();
            EchoWriter?.Write(CurrentTokenText);

            m_encounteredNewLine = m_scanner.GotEndOfLine;
            return CurrentTokenType;
        }

        private string NextSignificantToken()
        {
            // MOST of the time we won't need to save anything,
            // so don't bother allocating a string builder unless we need it
            string text = null;
            StringBuilder sb = null;
            try
            {
                // get the next token
                m_currentToken = m_scanner.NextToken();
                EchoWriter?.Write(CurrentTokenText);

                m_encounteredNewLine = m_scanner.GotEndOfLine;
                while (CurrentTokenType == TokenType.Space || CurrentTokenType == TokenType.Comment)
                {
                    // if this token is a comment, add it to the builder
                    if (CurrentTokenType == TokenType.Comment)
                    {
                        // check for important comment
                        string commentText = CurrentTokenText;
                        bool importantComment = commentText.StartsWith("/*!", StringComparison.Ordinal);
                        if (importantComment)
                        {
                            // get rid of the exclamation mark in some situations
                            commentText = NormalizeImportantComment(commentText);
                        }

                        // if the comment mode is none, don't ever output it.
                        // if the comment mode is all, always output it.
                        // otherwise only output it if it is an important comment.
                        bool writeComment = Settings.CommentMode == CssComment.All
                            || (importantComment && Settings.CommentMode != CssComment.None);

                        if (!importantComment)
                        {
                            if (s_sharepointReplacement.IsMatch(commentText))
                            {
                                // we ALWAYS want to output sharepoint styling comments
                                // (unless settings say NO comments)
                                writeComment = Settings.CommentMode != CssComment.None;
                            }
                            else
                            {
                                // see if this is a value-replacement id
                                Match match = s_valueReplacement.Match(commentText);
                                if (match.Success)
                                {
                                    // check all the resource strings objects to see if one is a match.
                                    m_valueReplacement = null;

                                    var resourceList = Settings.ResourceStrings;
                                    if (resourceList.Count > 0)
                                    {
                                        // get the id of the string we want to substitute
                                        string ident = match.Result("${id}");

                                        // walk the list BACKWARDS so later resource string objects override previous ones
                                        for (var ndx = resourceList.Count - 1; ndx >= 0; --ndx)
                                        {
                                            m_valueReplacement = resourceList[ndx][ident];
                                            if (m_valueReplacement != null)
                                            {
                                                break;
                                            }
                                        }
                                    }

                                    // if there is such a string, we will have saved the value in the value replacement
                                    // variable so it will be substituted for the next value.
                                    // if there is no such string, we ALWAYS want to output the comment so we know 
                                    // there was a problem (even if the comments mode is to output none)
                                    writeComment = m_valueReplacement == null;
                                    if (writeComment)
                                    {
                                        // make sure the comment is normalized
                                        commentText = NormalizedValueReplacementComment(commentText);
                                    }
                                }
                            }
                        }

                        if (writeComment)
                        {
                            // if we haven't yet allocated a string builder, do it now
                            if (sb == null)
                            {
                                sb = StringBuilderPool.Acquire();
                            }

                            // add the comment to the builder
                            sb.Append(commentText);
                        }
                    }

                    // next token
                    m_currentToken = m_scanner.NextToken();
                    EchoWriter?.Write(CurrentTokenText);

                    m_encounteredNewLine = m_encounteredNewLine || m_scanner.GotEndOfLine;
                }

                text = sb == null ? string.Empty : sb.ToString();
            }
            finally
            {
                sb.Release();
            }

            // return any comments we found in the mean time
            return text;
        }

        private void UpdateIfReplacementToken()
        {
            m_currentToken = m_scanner.ScanReplacementToken() ?? m_currentToken;
        }

        #endregion

        #region Skip... methods

        /// <summary>
        /// This method advances to the next token FIRST -- effectively skipping the current one -- 
        /// and then skips any space tokens that FOLLOW it.
        /// </summary>
        private void SkipSpace()
        {
            // reset the skipped-space flag
            m_skippedSpace = false;

            // move to the next token
            NextToken();

            // we need to collate this flag for this method call
            var encounteredNewLine = m_encounteredNewLine;

            // while space, keep stepping
            while (CurrentTokenType == TokenType.Space)
            {
                m_skippedSpace = true;
                NextToken();
                encounteredNewLine = encounteredNewLine || m_encounteredNewLine;
            }

            m_encounteredNewLine = encounteredNewLine;
        }

        private void SkipSpaceComment()
        {
            // reset the skipped-space flag
            m_skippedSpace = false;

            // move to the next token
            if (NextRawToken() == TokenType.Space)
            {
                // starts with whitespace! If the next token is a comment, we want to make sure that
                // whitespace is preserved. Keep going until we find something that isn't a space
                m_skippedSpace = true;
                var encounteredNewLine = m_encounteredNewLine;
                while (NextRawToken() == TokenType.Space)
                {
                    // iteration is in the condition
                    encounteredNewLine = encounteredNewLine || m_encounteredNewLine;
                }

                // now, if the first thing after space is a comment....
                if (CurrentTokenType == TokenType.Comment)
                {
                    // preserve the space character IF we're going to keep the comment.
                    // SO, if the comment mode is ALL, or if this is an important comment,
                    // (if the comment mode is hacks, then this comment will probably have already
                    // been changed into an important comment), then we output the space
                    // and the comment (don't bother outputting the comment if we already know we
                    // aren't going to)
                    if (Settings.CommentMode == CssComment.All
                        || CurrentTokenText.StartsWith("/*!", StringComparison.Ordinal))
                    {
                        Append(' ');

                        // output the comment
                        AppendCurrent();
                    }

                    // and do normal skip-space logic
                    SkipSpace();
                    encounteredNewLine = encounteredNewLine || m_encounteredNewLine;
                }

                m_encounteredNewLine = encounteredNewLine;
            }
            else if (CurrentTokenType == TokenType.Comment)
            {
                // doesn't start with whitespace.
                // append the comment and then do the normal skip-space logic
                var encounteredNewLine = m_encounteredNewLine;
                AppendCurrent();
                SkipSpace();
                m_encounteredNewLine = m_encounteredNewLine || encounteredNewLine;
            }
        }

        /// <summary>
        /// This method only skips the space that is already the current token.
        /// </summary>
        /// <returns>true if space was skipped; false if the current token is not space</returns>
        private bool SkipIfSpace()
        {
            // reset the skipped-space flag
            m_skippedSpace = false;

            bool tokenIsSpace = CurrentTokenType == TokenType.Space;
            var encounteredNewLine = m_encounteredNewLine;
            // while space, keep stepping
            while (CurrentTokenType == TokenType.Space)
            {
                m_skippedSpace = true;
                NextToken();
                encounteredNewLine = encounteredNewLine || m_encounteredNewLine;
            }

            m_encounteredNewLine = encounteredNewLine;
            return tokenIsSpace;
        }

        private void SkipToEndOfStatement()
        {
            bool possibleSpace = false;
            // skip to next semicolon or next block
            // AND honor opening/closing pairs of (), [], and {}
            while (!m_scanner.EndOfFile
                && (CurrentTokenType != TokenType.Character || CurrentTokenText != ";"))
            {
                // if the token is one of the characters we need to match closing characters...
                if (CurrentTokenType == TokenType.Character
                    && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{"))
                {
                    // see if this is this a block -- if so, we'll bail when we're done
                    bool isBlock = (CurrentTokenText == "{");

                    SkipToClose();

                    // if that was a block, bail now
                    if (isBlock)
                    {
                        return;
                    }
                    possibleSpace = false;
                }
                if (CurrentTokenType == TokenType.Space)
                {
                    possibleSpace = true;
                }
                else
                {
                    if (possibleSpace && NeedsSpaceBefore(CurrentTokenText)
                        && NeedsSpaceAfter(m_lastOutputString))
                    {
                        Append(' ');
                    }
                    AppendCurrent();
                    possibleSpace = false;
                }
                NextToken();
            }
        }

        private void SkipToEndOfDeclaration()
        {
            bool possibleSpace = false;
            // skip to end of declaration: ; or }
            // BUT honor opening/closing pairs of (), [], and {}
            while (!m_scanner.EndOfFile
                && (CurrentTokenType != TokenType.Character
                  || (CurrentTokenText != ";" && CurrentTokenText != "}")))
            {
                // if the token is one of the characters we need to match closing characters...
                if (CurrentTokenType == TokenType.Character
                    && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{"))
                {
                    if (possibleSpace)
                    {
                        Append(' ');
                    }

                    SkipToClose();
                    possibleSpace = false;
                }

                if (CurrentTokenType == TokenType.Space)
                {
                    possibleSpace = true;
                }
                else
                {
                    if (possibleSpace && NeedsSpaceBefore(CurrentTokenText)
                        && NeedsSpaceAfter(m_lastOutputString))
                    {
                        Append(' ');
                    }

                    AppendCurrent();
                    possibleSpace = false;
                }

                m_skippedSpace = false;
                NextToken();
                if (CurrentTokenType == TokenType.Space)
                {
                    m_skippedSpace = true;
                }
            }

            // make sure we reset this flag
            m_noOutput = false;
        }

        private void SkipToClose()
        {
            bool possibleSpace = false;
            string closingText;
            switch (CurrentTokenText)
            {
                case "(":
                    closingText = ")";
                    break;

                case "[":
                    closingText = "]";
                    break;

                case "{":
                    closingText = "}";
                    break;

                default:
                    throw new ArgumentException("invalid closing match");
            }

            if (m_skippedSpace && CurrentTokenText != "{")
            {
                Append(' ');
            }

            AppendCurrent();

            m_skippedSpace = false;
            NextToken();
            if (CurrentTokenType == TokenType.Space)
            {
                m_skippedSpace = true;
            }

            while (!m_scanner.EndOfFile
                && (CurrentTokenType != TokenType.Character || CurrentTokenText != closingText))
            {
                // if the token is one of the characters we need to match closing characters...
                if (CurrentTokenType == TokenType.Character
                    && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{"))
                {
                    SkipToClose();
                    possibleSpace = false;
                }

                if (CurrentTokenType == TokenType.Space)
                {
                    possibleSpace = true;
                }
                else
                {
                    if (possibleSpace && NeedsSpaceBefore(CurrentTokenText)
                        && NeedsSpaceAfter(m_lastOutputString))
                    {
                        Append(' ');
                    }

                    AppendCurrent();
                    possibleSpace = false;
                }

                m_skippedSpace = false;
                NextToken();
                if (CurrentTokenType == TokenType.Space)
                {
                    m_skippedSpace = true;
                }
            }
        }

        private void SkipSemicolons()
        {
            while (CurrentTokenType == TokenType.Character && CurrentTokenText == ";")
            {
                NextToken();
            }
        }

        private static bool NeedsSpaceBefore(string text)
        {
            return text == null ? false : !("{}()[],;".Contains(text));
        }

        private static bool NeedsSpaceAfter(string text)
        {
            return text == null ? false : !("{}()[],;:".Contains(text));
        }

        #endregion

        #region output methods

        private bool AppendCurrent()
        {
            return Append(
                CurrentTokenText, 
                CurrentTokenType);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity"),
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode"),
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase")]
        private bool Append(object obj, TokenType tokenType)
        {
            bool outputText = false;
            bool textEndsInEscapeSequence = false;

            // if the no-output flag is true, don't output anything
            // or process value replacement comments
            if (!m_noOutput)
            {
                var parsed = m_builders.Peek();
                var text = obj.ToString();

                // first if there are replacement tokens in the settings, then we'll want to
                // replace any tokens with the appropriate replacement values
                if (Settings.ReplacementTokens.Count > 0)
                {
                    text = CommonData.ReplacementToken.Replace(text, GetReplacementValue);
                }

                if (tokenType == TokenType.Identifier || tokenType == TokenType.Dimension)
                {
                    // need to make sure invalid identifier characters are properly escaped
                    StringBuilder escapedBuilder = null;
                    try
                    {
                        var startIndex = 0;
                        var protectNextHexCharacter = false;
                        var firstIndex = 0;

                        // if the token type is an identifier, we need to make sure the first character
                        // is a proper identifier start, or is escaped. But if it's a dimension, the first
                        // character will be a numeric digit -- which wouldn't be a valid identifier. So
                        // for dimensions, skip the first character -- subsequent numeric characters will
                        // be okay.
                        if (tokenType == TokenType.Identifier)
                        {
                            // for identifiers, if the first character is a hyphen or an underscore, then it's a prefix
                            // and we want to look at the next character for nmstart.
                            firstIndex = text[0] == '_' || text[0] == '-' ? 1 : 0;

                            var isCssVariable = text.StartsWith("--") && text.Length >= 3;
                            if (isCssVariable)
                            {
                                firstIndex = 2;
                            }
                            
                            if (firstIndex < text.Length)
                            {
                                // the only valid non-escaped first characters are A-Z (and a-z)
                                var firstChar = text[firstIndex];

                                // anything at or above 0x80 is okay for identifiers
                                if (firstChar < 0x80)
                                {
                                    // if it's not an a-z or A-Z, we want to escape it
                                    // also leave literal back-slashes as-is, too. The identifier might start with an escape
                                    // sequence that we didn't decode to its Unicode character for whatever reason.
                                    if ((firstChar < 'A' || 'Z' < firstChar)
                                        && (firstChar < 'a' || 'z' < firstChar)
                                        && firstChar != '\\')
                                    {
                                        // invalid first character -- create the string builder
                                        escapedBuilder = StringBuilderPool.Acquire();

                                        // if we had a prefix, output it
                                        if (firstIndex > 0)
                                        {
                                            escapedBuilder.Append(text[0]);
                                        }

                                        // output the escaped first character
                                        protectNextHexCharacter = EscapeCharacter(escapedBuilder, text[firstIndex]);
                                        textEndsInEscapeSequence = true;
                                        startIndex = firstIndex + 1;
                                    }
                                }
                            }
                        }
                        else
                        {
                            // for dimensions, we want to skip over the numeric part. So any sign, then decimal
                            // digits, then a decimal point (period), then decimal digits. The rest will be the identifier
                            // part that we want to escape.
                            if (text[0] == '+' || text[0] == '-')
                            {
                                ++firstIndex;
                            }

                            while ('0' <= text[firstIndex] && text[firstIndex] <= '9')
                            {
                                ++firstIndex;
                            }

                            if (text[firstIndex] == '.')
                            {
                                ++firstIndex;
                            }

                            while ('0' <= text[firstIndex] && text[firstIndex] <= '9')
                            {
                                ++firstIndex;
                            }

                            // since we start at the first character AFTER firstIndex, subtract
                            // one so we get back to the first character that isn't a part of
                            // the number portion
                            --firstIndex;
                        }

                        // loop through remaining characters, escaping any invalid nmchar characters
                        for (var ndx = firstIndex + 1; ndx < text.Length; ++ndx)
                        {
                            char nextChar = text[ndx];

                            // anything at or above 0x80, then it's okay and doesnt need to be escaped
                            if (nextChar < 0x80)
                            {
                                // only -, _, 0-9, a-z, A-Z are allowed without escapes
                                // but we also want to NOT escape \ or space characters. If the identifier had
                                // an escaped space character, it will still be escaped -- so any spaces would
                                // be necessary whitespace for the end of unicode escapes.
                                if (nextChar == '\\')
                                {
                                    // escape characters cause the next character -- no matter what it is -- to
                                    // be part of the escape and not escaped itself. Even if this is part of a
                                    // unicode or character escape, this will hold true. Increment the index and
                                    // loop around again so that we skip over both the backslash and the following
                                    // character.
                                    ++ndx;
                                }
                                else if (nextChar != '-'
                                    && nextChar != '_'
                                    && nextChar != ' '
                                    && ('0' > nextChar || nextChar > '9')
                                    && ('a' > nextChar || nextChar > 'z')
                                    && ('A' > nextChar || nextChar > 'Z'))
                                {
                                    // need to escape this character -- create the builder if we haven't already
                                    if (escapedBuilder == null)
                                    {
                                        escapedBuilder = StringBuilderPool.Acquire();
                                    }

                                    // output any okay characters we have so far
                                    if (startIndex < ndx)
                                    {
                                        // if the first character of the unescaped string is a valid hex digit,
                                        // then we need to add a space so that characer doesn't get parsed as a
                                        // digit in the previous escaped sequence.
                                        // and if the first character is a space, we need to protect it from the
                                        // previous escaped sequence with another space, too.
                                        string unescapedSubstring = text.Substring(startIndex, ndx - startIndex);
                                        if ((protectNextHexCharacter && CssScanner.IsH(unescapedSubstring[0]))
                                            || (textEndsInEscapeSequence && unescapedSubstring[0] == ' '))
                                        {
                                            escapedBuilder.Append(' ');
                                        }

                                        escapedBuilder.Append(unescapedSubstring);
                                    }

                                    // output the escape sequence for the current character
                                    protectNextHexCharacter = EscapeCharacter(escapedBuilder, text[ndx]);
                                    textEndsInEscapeSequence = true;

                                    // update the start pointer to the next character
                                    startIndex = ndx + 1;
                                }
                            }
                        }

                        // if we escaped anything, get the text from what we built
                        if (escapedBuilder != null)
                        {
                            // append whatever is left over
                            if (startIndex < text.Length)
                            {
                                // if the first character of the unescaped string is a valid hex digit,
                                // then we need to add a space so that characer doesn't get parsed as a
                                // digit in the previous escaped sequence.
                                // same for spaces! a trailing space will be part of the escape, so if we need
                                // a real space to follow, need to make sure there are TWO.
                                string unescapedSubstring = text.Substring(startIndex);
                                if ((protectNextHexCharacter && CssScanner.IsH(unescapedSubstring[0]))
                                    || unescapedSubstring[0] == ' ')
                                {
                                    escapedBuilder.Append(' ');
                                }

                                escapedBuilder.Append(unescapedSubstring);
                                textEndsInEscapeSequence = false;
                            }

                            // get the full string
                            text = escapedBuilder.ToString();
                        }
                    }
                    finally
                    {
                        escapedBuilder.Release();
                    }
                }
                else if (tokenType == TokenType.String)
                {
                    // we need to make sure that control codes are properly escaped
                    StringBuilder sb = null;
                    try
                    {
                        var startRaw = 0;
                        for (var ndx = 0; ndx < text.Length; ++ndx)
                        {
                            // if it's a control code...
                            var ch = text[ndx];
                            if (ch < ' ')
                            {
                                // if we haven't created our string builder yet, do it now
                                if (sb == null)
                                {
                                    sb = StringBuilderPool.Acquire();
                                }

                                // add the raw text up to but not including the current character.
                                // but only if start raw is BEFORE the current index
                                if (startRaw < ndx)
                                {
                                    sb.Append(text.Substring(startRaw, ndx - startRaw));
                                }

                                // regular unicode escape
                                sb.Append("\\{0:x}".FormatInvariant(char.ConvertToUtf32(text, ndx)));

                                // if the NEXT character (if there is one) is a hex digit, 
                                // we will need to append a space to signify the end of the escape sequence, since this
                                // will never have more than two digits (0 - 1f).
                                if (ndx + 1 < text.Length
                                    && CssScanner.IsH(text[ndx + 1]))
                                {
                                    sb.Append(' ');
                                }

                                // and update the raw pointer to the next character
                                startRaw = ndx + 1;
                            }
                        }

                        // if we have something left over, add the rest now
                        if (sb != null && startRaw < text.Length)
                        {
                            sb.Append(text.Substring(startRaw));
                        }

                        // if we built up a string, use it. Otherwise just use what we have.
                        text = sb == null ? text : sb.ToString();
                    }
                    finally
                    {
                        sb.Release();
                    }
                }
                else if (tokenType == TokenType.Uri && Settings.FixIE8Fonts)
                {
                    // IE8 @font-face directive has an issue with src properties that are URLs ending with .EOT
                    // that don't have any querystring. They end up sending a malformed HTTP request to the server,
                    // which is bad for the server. So we want to automatically fix this for developers: if ANY URL
                    // ends in .EOT without a querystring parameters, just add a question mark in the appropriate 
                    // location. This fixes the IE8 issue.
                    text = s_eotIE8Fix.Replace(text, ".eot?$1");
                }

                // if it's not a comment, we're going to output it.
                // if it is a comment, we're not going to SAY we've output anything,
                // even if we end up outputting the comment
                var isImportant = false;
                outputText = (tokenType != TokenType.Comment);
                if (!outputText)
                {
                    // if the comment mode is none, we never want to output it.
                    // if the comment mode is all, then we always want to output it.
                    // otherwise we only want to output if it's an important /*! */ comment
                    if (text.StartsWith("/*!", StringComparison.Ordinal))
                    {
                        // this is an important comment. We will always output it
                        // UNLESS the comment mode is none. If it IS none, bail now.
                        if (Settings.CommentMode == CssComment.None)
                        {
                            return false;    
                        }

                        // this is an important comment that we always want to output
                        // (after we get rid of the exclamation point in some situations)
                        text = NormalizeImportantComment(text);

                        // find the index of the initial / character
                        var indexSlash = text.IndexOf('/');
                        if (indexSlash > 0)
                        {
                            // it's not the first character!
                            // the only time that should happen is if we put a line-feed in front.
                            // if the string builder is empty, or if the LAST character is a \r or \n,
                            // then trim off everything before that opening slash
                            if (m_outputNewLine)
                            {
                                // trim off everything before it
                                text = text.Substring(indexSlash);
                            }
                        }
                    }
                    else if (s_sharepointReplacement.IsMatch(text))
                    {
                        // if it's a sharepoint replacement comment, then  always output it
                        // (unless settings say NO comments)
                        if (Settings.CommentMode == CssComment.None)
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // not important, and not sharepoint.
                        // check to see if it's a special value-replacement comment
                        Match match = s_valueReplacement.Match(CurrentTokenText);
                        if (match.Success)
                        {
                            m_valueReplacement = null;

                            var resourceList = Settings.ResourceStrings;
                            if (resourceList.Count > 0)
                            {
                                // it is! see if we have a replacement string
                                string id = match.Result("${id}");

                                // if we have resource strings in the settings, check each one for the
                                // id and set the value replacement field to the value.
                                // walk backwards so later objects override earlier ones.
                                for (var ndx = resourceList.Count - 1; ndx >= 0; --ndx)
                                {
                                    m_valueReplacement = resourceList[ndx][id];
                                    if (m_valueReplacement != null)
                                    {
                                        break;
                                    }
                                }
                            }

                            if (m_valueReplacement != null)
                            {
                                // we do. Don't output the comment. Instead, save the value replacement
                                // for the next time we encounter a value
                                return false;
                            }
                            else
                            {
                                // make sure the comment is normalized
                                text = NormalizedValueReplacementComment(text);
                            }
                        }
                        else if (Settings.CommentMode != CssComment.All)
                        {
                            // don't want to output, bail now
                            return false;
                        }
                    }

                    // see if it's still important
                    isImportant = text.StartsWith("/*!", StringComparison.Ordinal);
                }
                else if (m_parsingColorValue
                    && (tokenType == TokenType.Identifier || tokenType == TokenType.ReplacementToken))
                {
                    if (!text.StartsWith("#", StringComparison.Ordinal))
                    {
                        bool nameConvertedToHex = false;
                        string lowerCaseText = text.ToLowerInvariant();
                        string rgbString;

                        switch (Settings.ColorNames)
                        {
                            case CssColor.Hex:
                                // we don't want any color names in our code.
                                // convert ALL known color names to hex, so see if there is a match on
                                // the set containing all the name-to-hex values
                                if (ColorSlice.AllColorNames.TryGetValue(lowerCaseText, out rgbString))
                                {
                                    text = rgbString;
                                    nameConvertedToHex = true;
                                }
                                break;

                            case CssColor.Strict:
                                // we only want strict names in our css.
                                // convert all non-strict name to hex, AND any strict names to hex if the hex is
                                // shorter than the name. So check the set that contains all non-strict name-to-hex
                                // values and all the strict name-to-hex values where hex is shorter than name.
                                if (ColorSlice.StrictHexShorterThanNameAndAllNonStrict.TryGetValue(lowerCaseText, out rgbString))
                                {
                                    text = rgbString;
                                    nameConvertedToHex = true;
                                }
                                break;

                            case CssColor.Major:
                                // we don't care if there are non-strict color name. So check the set that only
                                // contains name-to-hex pairs where the hex is shorter than the name.
                                if (ColorSlice.HexShorterThanName.TryGetValue(lowerCaseText, out rgbString))
                                {
                                    text = rgbString;
                                    nameConvertedToHex = true;
                                }
                                break;

                            case CssColor.NoSwap:
                                // nope; leave it a name and don't swap it with the equivalent hex value
                                break;
                        }

                        // if we didn't convert the color name to hex, let's see if it is a color
                        // name -- if so, we want to make it lower-case for readability. We don't need
                        // to do this check if our color name setting is hex-only, because we would
                        // have already converted the name if we know about it
                        if (Settings.ColorNames != CssColor.Hex && !nameConvertedToHex
                            && ColorSlice.AllColorNames.TryGetValue(lowerCaseText, out rgbString))
                        {
                            // the color exists in the table, so we're pretty sure this is a color.
                            // make sure it's lower case
                            text = lowerCaseText;
                        }
                    }
                    else if (CurrentTokenType == TokenType.ReplacementToken)
                    {
                        // a replacement token is a color hash -- make sure we trim it to #RGB if it matches #RRGGBB
                        text = CrunchHexColor(text, Settings.ColorNames, m_noColorAbbreviation);
                    }
                }

                // if the global might-need-space flag is set and the first character we're going to
                // output if a hex digit or a space, we will need to add a space before our text
                if (m_mightNeedSpace
                    && (CssScanner.IsH(text[0]) || text[0] == ' '))
                {
                    if (m_lineLength >= Settings.LineBreakThreshold)
                    {
                        // we want to add whitespace, but we're over the line-length threshold, so
                        // output a line break instead
                        AddNewLine();
                    }
                    else
                    {
                        // output a space on the same line
                        parsed.Append(' ');
                        ++m_lineLength;
                    }
                }

                if (tokenType == TokenType.Comment && isImportant)
                {
                    // don't bother resetting line length after this because 
                    // we're going to follow the comment with another blank line
                    // and we'll reset the length at that time
                    AddNewLine();
                }

                if (text == " ")
                {
                    // we are asking to output a space character. At this point, if we are
                    // over the line-length threshold, we can substitute a line break for a space.
                    if (m_lineLength >= Settings.LineBreakThreshold)
                    {
                        AddNewLine();
                    }
                    else
                    {
                        // just output a space, and don't change the newline flag
                        parsed.Append(' ');
                        ++m_lineLength;
                    }
                }
                else
                {
                    // normal text
                    // see if we wanted to force a newline
                    if (m_forceNewLine)
                    {
                        // only output a newline if we aren't already on a new line
                        // AND we are in multiple-line mode
                        if (!m_outputNewLine && Settings.OutputMode == OutputMode.MultipleLines)
                        {
                            AddNewLine();
                        }
                        
                        // reset the flag
                        m_forceNewLine = false;
                    }

                    parsed.Append(text);
                    m_outputNewLine = false;

                    if (tokenType == TokenType.Comment && isImportant)
                    {
                        AddNewLine();
                        m_lineLength = 0;
                        m_outputNewLine = true;
                    }
                    else
                    {
                        m_lineLength += text.Length;
                    }
                }

                // if the text we just output ENDS in an escape, we might need a space later
                m_mightNeedSpace = textEndsInEscapeSequence;

                // save a copy of the string so we can check the last output
                // string later if we need to
                m_lastOutputString = text;
            }

            return outputText;
        }

        private string GetReplacementValue(Match match)
        {
            string tokenValue = null;
            var tokenName = match.Result("${token}");
            if (!tokenName.IsNullOrWhiteSpace())
            {
                if (!Settings.ReplacementTokens.TryGetValue(tokenName, out tokenValue))
                {
                    // no match. Check for a fallback
                    var fallbackClass = match.Result("${fallback}");
                    if (!fallbackClass.IsNullOrWhiteSpace())
                    {
                        Settings.ReplacementFallbacks.TryGetValue(fallbackClass, out tokenValue);
                    }
                }
            }

            // if we found a replacement, use it. Otherwise use a blank string to remove the token
            return tokenValue.IfNullOrWhiteSpace(string.Empty);
        }

        private static bool EscapeCharacter(StringBuilder sb, char character)
        {
            // output the hex value of the escaped character. If it's less than seven digits
            // (the slash followed by six hex digits), we might
            // need to append a space before the next valid character if it is a valid hex digit.
            // (we will always need to append another space after an escape sequence if the next valid character is a space)
            var hex = "\\{0:x}".FormatInvariant((int)character);
            sb.Append(hex);
            return hex.Length < 7;
        }

        private bool Append(object obj)
        {
            return Append(obj, TokenType.None);
        }

        private void NewLine()
        {
            // if we've output something other than a newline, output one now
            if (Settings.OutputMode == OutputMode.MultipleLines && !m_outputNewLine)
            {
                AddNewLine();
                m_lineLength = 0;
                m_outputNewLine = true;
            }
        }

        /// <summary>
        /// Always add new line to the stream
        /// </summary>
        /// <param name="sb"></param>
        private void AddNewLine()
        {
            if (!m_outputNewLine)
            {
                var parsed = m_builders.Peek();
                parsed.Append(Settings.LineTerminator);
                if (Settings.OutputMode == OutputMode.MultipleLines)
                {

                    var indentSpaces = Settings.TabSpaces;
                    m_lineLength = indentSpaces.Length;
                    if (m_lineLength > 0)
                    {
                        parsed.Append(indentSpaces);
                    }
                }
                else
                {
                    m_lineLength = 0;
                }

                m_outputNewLine = true;
            }
        }

        private void Indent()
        {
            // increase the indent level by one
            Settings.Indent();
        }

        private void Unindent()
        {
            // only decrease the indent level by one IF it's greater than zero
            Settings.Unindent();
        }

        #endregion

        #region color methods

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase")]
        private static string CrunchHexColor(string hexColor, CssColor colorNames, bool noAbbr)
        {
            if (!noAbbr)
            {
                hexColor = s_rrggbb.Replace(hexColor, "#${r}${g}${b}").ToLowerInvariant();
            }

            if (colorNames == CssColor.Strict || colorNames == CssColor.Major)
            {
                // check for the hex values that can be swapped with the W3C color names to save bytes?
                //      #808080 - gray
                //      #008000 - green
                //      #800000 - maroon
                //      #000080 - navy
                //      #808000 - olive
                //      #ffa500 - orange
                //      #800080 - purple
                //      #f00    - red
                //      #c0c0c0 - silver
                //      #008080 - teal
                // (these are the only colors we can use and still validate)
                // if we don't care about validating, there are even more colors that work in all
                // major browsers that would save up some bytes. But if we convert to those names,
                // we'd really need to be able to convert back to make it validate again.
                //
                // if the map contains an entry for this color, then we
                // should use the name instead because it's smaller.
                string colorName;
                if (ColorSlice.StrictNameShorterThanHex.TryGetValue(hexColor, out colorName))
                {
                    hexColor = colorName;
                }
                else if (colorNames == CssColor.Major)
                {
                    if (ColorSlice.NameShorterThanHex.TryGetValue(hexColor, out colorName))
                    {
                        hexColor = colorName;
                    }
                }
            }

            return hexColor;
        }

        private static bool MightContainColorNames(string propertyName)
        {
            bool hasColor = (propertyName.EndsWith("color", StringComparison.Ordinal));
            if (!hasColor)
            {
                switch (propertyName)
                {
                    case "background":
                    case "border-top":
                    case "border-right":
                    case "border-bottom":
                    case "border-left":
                    case "border":
                    case "outline":
                        hasColor = true;
                        break;
                }
            }
            return hasColor;
        }

        #endregion

        #region Error methods

        public static string ErrorFormat(CssErrorCode errorCode)
        {
            return CssStrings.ResourceManager.GetString(errorCode.ToString(), CssStrings.Culture);
        }

        private void ReportError(int severity, CssErrorCode errorNumber, CssContext context, params object[] arguments)
        {
            // guide: 0 == syntax error
            //        1 == the programmer probably did not intend to do this
            //        2 == this can lead to problems in the future.
            //        3 == this can lead to performance problems
            //        4 == this is just not right

            string message = ErrorFormat(errorNumber).FormatInvariant(arguments);
            Debug.Assert(!message.IsNullOrWhiteSpace());
            var error = new UglifyError()
                {
                    IsError = severity < 2,
                    Severity = severity,
                    Subcategory = UglifyError.GetSubcategory(severity),
                    File = FileContext,
                    ErrorNumber = (int)errorNumber,
                    ErrorCode = "CSS{0}".FormatInvariant(((int)errorNumber) & (0xffff)),
                    Message = message,
                };

            if (context != null)
            {
                error.StartLine = context.Start.Line;
                error.StartColumn = context.Start.Char;
            }

            // but warnings we want to just report and carry on
            OnCssError(error);
        }

        // just use the current context for the error
        private void ReportError(int severity, CssErrorCode errorNumber, params object[] arguments)
        {
            ReportError(severity, errorNumber, m_currentToken != null ? m_currentToken.Context : null, arguments);
        }

        public event EventHandler<ContextErrorEventArgs> CssError;

        protected void OnCssError(UglifyError cssError)
        {
            if (CssError != null && cssError != null && !Settings.IgnoreAllErrors)
            {
                // if we have no errors in our error ignore list, or if we do but this error code is not in
                // that list, fire the event to whomever is listening for it.
                if (!Settings.IgnoreErrorCollection.Contains(cssError.ErrorCode))
                {
                    CssError(this, new ContextErrorEventArgs()
                        {
                            Error = cssError
                        });
                }
            }
        }

        #endregion

        #region comment methods

        /// <summary>
        /// regular expression for matching newline characters
        /// </summary>
        ////private static Regex s_regexNewlines = new Regex(
        ////    @"\r\n|\f|\r|\n",
        ////    RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        static string NormalizedValueReplacementComment(string source)
        {
            return s_valueReplacement.Replace(source, "/*[${id}]*/");
        }

        static bool CommentContainsText(string comment)
        {
            for (var ndx = 0; ndx < comment.Length; ++ndx)
            {
                if (char.IsLetterOrDigit(comment[ndx]))
                {
                    return true;
                }
            }

            // if we get here, we didn't find any text characters
            return false;
        }

        string NormalizeImportantComment(string source)
        {
            // if this important comment does not contain any text, assume it's for a comment hack
            // and return a normalized string without the exclamation mark.
            if (CommentContainsText(source))
            {
                // first check to see if the comment is in the form /*!/ ...text... /**/
                // if so, then it's probably a part of the Opera5&NS4-only comment hack and we want
                // to make SURE that exclamation point does not get in the output because it would
                // mess up the results.
                if (source[3] == '/' && source.EndsWith("/**/", StringComparison.Ordinal))
                {
                    // it is. output the comment as-is EXCEPT without the exclamation mark
                    // (and don't put any line-feeds around it)
                    source = "/*" + source.Substring(3);
                }
            }
            else
            {
                // important comment, but it doesn't contain text. So instead, leave it inline
                // (don't add a newline character before it) but take out the exclamation mark.
                source = "/*" + source.Substring(3);
            }

            // if this is single-line mode, make sure CRLF-pairs are all converted to just CR
            if (Settings.OutputMode == OutputMode.SingleLine)
            {
                source = source.Replace("\r\n", "\n");
            }
            return source;
        }
        #endregion

        #region private enums

        private enum Parsed
        {
            True,
            False,
            Empty
        }

        #endregion
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using Kooboo.Lib.NUglify.Css;
using NUglify.Helpers;
using NUglify.JavaScript;
using NUglify.JavaScript.Visitors;

namespace NUglify.Css
{
    /// <summary>
    /// Parser takes Tokens and parses them into rules and statements
    /// </summary>
    public class CssParser
    {
        #region state fields

        private CssScanner m_scanner;
        private CssToken m_currentToken;
        private bool m_noOutput;
        private string m_lastOutputString;
        private bool m_mightNeedSpace;
        private bool m_skippedSpace;
        private int m_lineLength;
        private bool m_noColorAbbreviation;
        private bool m_encounteredNewLine;
        private Stack<StringBuilder> m_builders;

        // this is used to make sure we don't output two newlines in a row.
        // start it as true so we don't start off with a blank line
        private bool m_outputNewLine = true;

        // set this to true to force a newline before any other output
        private bool m_forceNewLine = false;

        public CssSettings Settings
        {
            get; set;
        }

        // sets a text writer that gets raw tokens written to it
        public TextWriter EchoWriter { get; set; }

        private readonly HashSet<string> m_namespaces;

        public string FileContext { get; set; }

        private CodeSettings m_jsSettings;
        public CodeSettings JSSettings
        {
            get
            {
                return m_jsSettings;
            }
            set
            {
                if (value != null)
                {
                    // clone the settings
                    m_jsSettings = value.Clone();

                    // and then make SURE the source format is Expression
                    m_jsSettings.SourceMode = JavaScriptSourceMode.Expression;
                }
                else
                {
                    m_jsSettings = new CodeSettings()
                        {
                            KillSwitch = (long)TreeModifications.MinifyStringLiterals,
                            SourceMode = JavaScriptSourceMode.Expression
                        };
                }
            }
        }

        #endregion

        private static Regex s_vendorSpecific = new Regex(
            @"^(\-(?<vendor>[^\-]+)\-)?(?<root>.+)$",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        // IE8 @font-face directive has an issue with src properties that are URLs ending with .EOT
        // that don't have any querystring. They end up sending a malformed HTTP request to the server,
        // which is bad for the server. So we want to automatically fix this for developers: if ANY URL
        // ends in .EOT without a querystring parameters, just add a question mark in the appropriate 
        // location. This fixes the IE8 issue.
        private static Regex s_eotIE8Fix = new Regex(
            @"\.eot([^?\\/\w])",
            RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled | RegexOptions.CultureInvariant);

        #region Comment-related fields

        /// <summary>
        /// regular expression for matching css comments
        /// Format: /*(anything or nothing inside)*/
        /// </summary>
        ////private static Regex s_regexComments = new Regex(
        ////    @"/\*([^*]|(\*+[^*/]))*\*+/",
        ////    RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// regular expression for matching first comment hack
        /// This is the MacIE ignore bug: /*(anything or nothing inside)\*/.../*(anything or nothing inside)*/
        /// </summary>
        private static Regex s_regexHack1 = new Regex(
            @"/\*([^*]|(\*+[^*/]))*\**\\\*/(?<inner>.*?)/\*([^*]|(\*+[^*/]))*\*+/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for matching second comment hack
        /// Hide from everything EXCEPT Netscape 4 and Opera 5
        /// Format: /*/*//*/.../*(anything or nothing inside)*/
        /// </summary>
        private static Regex s_regexHack2 = new Regex(
            @"/\*/\*//\*/(?<inner>.*?)/\*([^*]|(\*+[^*/]))*\*+/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for matching third comment hack
        /// Hide from Netscape 4
        /// Format: /*/*/.../*(anything or nothing inside)*/
        /// </summary>
        private static Regex s_regexHack3 = new Regex(
            @"/\*/\*/(?<inner>.*?)/\*([^*]|(\*+[^*/]))*\*+/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for matching fourth comment hack
        /// Hide from IE6
        /// Format: property /*(anything or nothing inside)*/:value
        /// WARNING: This does not actually parse the property/value -- it simply looks for a
        /// word character followed by at least one whitespace character, followed
        /// by a simple comment, followed by optional space, followed by a colon.
        /// Does not match the simple word, the space or the colon (just the comment) 
        /// </summary>
        private static Regex s_regexHack4 = new Regex(
            @"(?<=\w\s+)/\*([^*]|(\*+[^*/]))*\*+/\s*(?=:)",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for matching fifth comment hack
        /// Hide from IE5.5
        /// Format: property:/* (anything or nothing inside) */value
        /// WARNING: This does not actually parse the property/value -- it simply looks for a
        /// word character followed by optional whitespace character, followed
        /// by a colon, followed by optional whitespace, followed by a simple comment.
        /// Does not match initial word or the colon, just the comment.
        /// </summary>
        private static Regex s_regexHack5 = new Regex(
            @"(?<=[\w/]\s*:)\s*/\*([^*]|(\*+[^*/]))*\*+/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for matching sixth comment hack -- although not a real hack
        /// Hide from IE6, NOT
        /// Format: property/*(anything or nothing inside)*/:value
        /// NOTE: This doesn't actually hide from IE6; it needs a space before the comment to actually work.
        /// but enoough people code this in their CSS and expect it to be output that I recieved enough
        /// requests to add it to the allowed "hacks"
        /// WARNING: This does not actually parse the property/value -- it simply looks for a
        /// word character followed by a simple comment, followed by optional space, followed by a colon.
        /// Does not match the simple word or the colon (just initial whitespace and comment) 
        /// </summary>
        private static Regex s_regexHack6 = new Regex(
            @"(?<=\w)/\*([^*]|(\*+[^*/]))*\*+/\s*(?=:)",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        /// <summary>
        /// Regular expression for empty comments
        /// These comments don't really do anything. But if the developer wrote an empty
        /// comment (/**/ or /* */), then it has no documentation value and might possibly be
        /// an attempted comment hack.
        /// Format: /**/ or /* */ (single space)
        /// </summary>
        private static Regex s_regexHack7 = new Regex(
            @"/\*(\s?)\*/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        #endregion

        #region color-related fields

        /// <summary>
        /// matches 6-digit RGB color value where both r digits are the same, both
        /// g digits are the same, and both b digits are the same (but r, g, and b
        /// values are not necessarily the same). Used to identify #rrggbb values
        /// that can be collapsed to #rgb
        /// </summary>
        private static Regex s_rrggbb = new Regex(
            @"^\#(?<r>[0-9a-fA-F])\k<r>(?<g>[0-9a-fA-F])\k<g>(?<b>[0-9a-fA-F])\k<b>$",
            RegexOptions.CultureInvariant | RegexOptions.Compiled);

        // whether we are currently parsing the value for a property that might
        // use color names
        private bool m_parsingColorValue;

        #endregion

        #region value-replacement fields

        /// <summary>
        /// regular expression for matching css comments containing special formatted identifiers
        /// for value-replacement matching
        /// Format: /* [id] */
        /// </summary>
        private static Regex s_valueReplacement = new Regex(
            @"/\*\s*\[(?<id>\w+)\]\s*\*/",
            RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        // this variable will be set whenever we encounter a value-replacement comment
        // and have a string to replace it with
        private string m_valueReplacement;// = null;

        #endregion

        #region Sharepoint replacement comment regex

        /// <summary>
        /// regular expression for matching Sharepoint Theme css comments
        /// Format: /* [ReplaceBGImage] */
        ///         /* [id(parameters)] */
        ///     where id is one of: ReplaceColor, ReplaceFont, or RecolorImage
        ///     and parameters is anything other than a close square-bracket
        /// </summary>
        private static Regex s_sharepointReplacement = new Regex(
            @"/\*\s*\[(ReplaceBGImage|((ReplaceColor|ReplaceFont|RecolorImage)\([^\]]*))\]\s*\*/",
            RegexOptions.IgnoreCase | RegexOptions.Singleline | RegexOptions.Compiled | RegexOptions.CultureInvariant);

        #endregion

        #region token-related properties

        private TokenType CurrentTokenType
        {
            get
            {
                return m_currentToken != null
                    ? m_currentToken.TokenType
                    : TokenType.None;
            }
        }

        private string CurrentTokenText
        {
            get
            {
                return m_currentToken != null
                    ? m_currentToken.Text
                    : string.Empty;
            }
        }

        #endregion

        public CssParser()
        {
            // default settings
            Settings = new CssSettings();

            // create the default settings we'll use for JS expression minification
            // use the defaults, other than to set the kill switch so that it leaves
            // string literals alone (so we don't inadvertently change any delimiter chars)
            JSSettings = null;

            // create a list of strings that represent the namespaces declared
            // in a @namespace statement. We will clear this every time we parse a new source string.
            m_namespaces = new HashSet<string>();
        }

        public string Parse(string source)
        {
            // clear out the list of namespaces
            m_namespaces.Clear();

            if (source.IsNullOrWhiteSpace())
            {
                // null or blank - return an empty string
                source = string.Empty;
            }
            else
            {
                // pre-process the comments
                var resetToHacks = false;
                try
                {
                    // see if we need to re-encode the text based on a @charset rule
                    // at the front.
                    source = HandleCharset(source);

                    if (Settings.CommentMode == CssComment.Hacks)
                    {
                        // change the various hacks to important comments so they will be kept
                        // in the output
                        source = s_regexHack1.Replace(source, "/*! \\*/${inner}/*!*/");
                        source = s_regexHack2.Replace(source, "/*!/*//*/${inner}/**/");
                        source = s_regexHack3.Replace(source, "/*!/*/${inner}/*!*/");
                        source = s_regexHack4.Replace(source, "/*!*/");
                        source = s_regexHack5.Replace(source, "/*!*/");
                        source = s_regexHack6.Replace(source, "/*!*/");
                        source = s_regexHack7.Replace(source, "/*!*/");

                        // now that we've changed all our hack comments to important comments, we can
                        // change the flag to Important so all non-important hacks are removed. 
                        // And set a flag to remind us to change it back before we exit, or the NEXT
                        // file we process will have the wrong setting.
                        Settings.CommentMode = CssComment.Important;
                        resetToHacks = true;
                    }

                    // set up for the parse
                    using (StringReader reader = new StringReader(source))
                    {
                        m_scanner = new CssScanner(reader);
                        m_scanner.AllowEmbeddedAspNetBlocks = this.Settings.AllowEmbeddedAspNetBlocks;
                        m_scanner.IgnoreRazorEscapeSequence = this.Settings.IgnoreRazorEscapeSequence;
                        m_scanner.DecodeEscapes = this.Settings.DecodeEscapes;
                        m_scanner.ScannerError += (sender, ea) =>
                            {
                                ea.Error.File = this.FileContext;
                                OnCssError(ea.Error);
                            };
                        m_scanner.ContextChange += (sender, ea) =>
                            {
                                FileContext = ea.FileContext;
                            };

                        // create the initial string builder into which we will be 
                        // building our crunched stylesheet.
                        m_builders = new Stack<StringBuilder>();
                        m_builders.Push(StringBuilderPool.Acquire(source.Length / 2));

                        // get the first token
                        NextToken();

                        switch (Settings.CssType)
                        {
                            case CssType.FullStyleSheet:
                                // parse a style sheet!
                                ParseStylesheet();
                                break;

                            case CssType.DeclarationList:
                                SkipIfSpace();
                                ParseDeclarationList(false);
                                break;

                            default:
                                Debug.Fail("UNEXPECTED CSS TYPE");
                                goto case CssType.FullStyleSheet;
                        }

                        if (!m_scanner.EndOfFile)
                        {
                            int errorNumber = (int)CssErrorCode.ExpectedEndOfFile;
                            OnCssError(new UglifyError()
                                {
                                    IsError = true,
                                    Severity = 0,
                                    Subcategory = UglifyError.GetSubcategory(0),
                                    File = FileContext,
                                    ErrorNumber = errorNumber,
                                    ErrorCode = "CSS{0}".FormatInvariant(errorNumber & (0xffff)),
                                    StartLine = m_currentToken.Context.Start.Line,
                                    StartColumn = m_currentToken.Context.Start.Char,
                                    Message = CssStrings.ExpectedEndOfFile,
                                });
                        }

                        // get the crunched string and dump the string builder
                        // (we don't need it anymore)
                        source = UnwindStackCompletely();
                        m_builders = null;
                    }
                }
                finally
                {
                    // if we had changed our setting object...
                    if (resetToHacks)
                    {
                        // ...be sure to change it BACK for next time.
                        Settings.CommentMode = CssComment.Hacks;
                    }
                }
            }

            return source;
        }

        #region output builders stack methods

        /// <summary>
        /// Push a new string builder onto the builders stack
        /// </summary>
        private void PushWaypoint()
        {
            m_builders.Push(StringBuilderPool.Acquire());
        }

        /// <summary>
        /// Pop the top waypoint off the stack.
        /// If the Settings RemoveEmptyBlocks property is false, will keep the text, regardless of the passed-in setting.
        /// </summary>
        /// <param name="keepText">true if push the text of the popped waypoint onto the new top waypoint; false to discard</param>
        /// <returns>true if the popped builder has any text within it</returns>
        private bool PopWaypoint(bool keepText)
        {
            var topBuilder = m_builders.Pop();
            if (keepText || !Settings.RemoveEmptyBlocks)
            {
                m_builders.Peek().Append(topBuilder.ToString());
            }

            var isNotEmpty = topBuilder.Length > 0;
            topBuilder.Release();
            return isNotEmpty;
        }

        /// <summary>
        /// Get all the text that has been accumulting in the string builders
        /// on the stack, unwinding the stack until it's empty
        /// </summary>
        /// <returns>string representation of all parsed text</returns>
        private string UnwindStackCompletely()
        {
            if (m_builders == null || m_builders.Count == 0)
            {
                // no builders - return an empty string
                return string.Empty;
            }

            if (m_builders.Count == 1)
            {
                // just one builder - return it's string after releasing it.
                var topBuilder = m_builders.Pop();
                var code = topBuilder.ToString();
                topBuilder.Release();
                return code;
            }

            // multiple builders in the stack. Rather than unwinding the stack and
            // pushing each builder onto the previous one, which could add take extra 
            // buffer allocations for each one, instead create an array (we know how big it should be),
            // and stuff each builder's string into the array in reverse order. Then use 
            // string.concat for a single new string allocation.
            var codeList = new string[m_builders.Count];
            var ndx = codeList.Length - 1;
            while(ndx >= 0)
            {
                // pop the topmost builder from the stack and get the text that
                // has been built up inside it and add it to the array in reverse order.
                var topBuilder = m_builders.Pop();
                codeList[ndx--] = topBuilder.ToString();
                topBuilder.Release();
            }

            return string.Concat(codeList);
        }

        #endregion

        #region Character set rule handling

        private string HandleCharset(string source)
        {
            // normally we let the encoding switch decode the input file for us, so every character in
            // the source string has already been decoded into the proper UNICODE character point.
            // HOWEVER, that doesn't mean the person passing us the source string has used the right encoding
            // to read the file. Check to see if there's a BOM that hasn't been decoded properly. If so, then
            // that indicates a potential error condition. And if we have a proper BOM, then everything was okay,
            // but we want to strip it off the source so it doesn't interfere with the parsing.
            // We SHOULD also check for a @charset rule to see if we need to re-decode the string. But for now, just
            // throw a low-pri warning if we see an improperly-decided BOM.

            // but first, if it starts with a source comment that we probably added, then we need to pull it off
            // and save it for later.
            var initialSourceDirective = string.Empty;
            if (source.StartsWith("/*/#SOURCE", StringComparison.OrdinalIgnoreCase))
            {
                // find the end of the comment
                var endOfComment = source.IndexOf("*/", 10, StringComparison.Ordinal);
                if (endOfComment > 0)
                {
                    // now skip the first line break if there is one
                    endOfComment += 2;
                    if (source[endOfComment] == '\r')
                    {
                        ++endOfComment;
                        if (source[endOfComment] == '\n')
                        {
                            ++endOfComment;
                        }
                    }
                    else if (source[endOfComment] == '\n' || source[endOfComment] == '\f')
                    {
                        ++endOfComment;
                    }

                    // save the comment and strip it off the source (for now)
                    initialSourceDirective = source.Substring(0, endOfComment);
                    source = source.Substring(endOfComment);
                }
            }

            if (source.StartsWith("\u00ef\u00bb\u00bf", StringComparison.Ordinal))
            {
                // if the first three characters are EF BB BF, then the source file had a UTF-8 BOM in it, but 
                // the BOM didn't get stripped. We MIGHT have some issues: the file indicated it's UTF-8 encoded,
                // but if we didn't properly decode the BOM, then other non-ASCII character sequences might also be
                // improperly decoded. Because that's an IF, we will only throw a pri-1 "programmer may not have intended this"
                // error. However, first check to see if there's a @charset "ascii"; statement at the front. If so,
                // then don't throw any error at all because everything should be ascii, in which case we're most-likely
                // good to go. The quote may be single or double, and the ASCII part should be case-insensentive.
                var charsetAscii = "@charset ";
                if (string.CompareOrdinal(source, 3, charsetAscii, 0, charsetAscii.Length) != 0
                    || (source[3 + charsetAscii.Length] != '"' && source[3 + charsetAscii.Length] != '\'')
                    || string.Compare(source, 4 + charsetAscii.Length, "ascii", 0, 5, StringComparison.OrdinalIgnoreCase) != 0)
                {
                    // we either don't have a @charset statement, or it's pointing to something other than ASCII, in which
                    // case we might have a problem here. But because that's a "MIGHT," let's make it a pri-1 instead of
                    // a pri-0. If there are any problems, the output will be wonky and the developer can up the warning-level
                    // and see this error, then use the proper encoding to read the source. 
                    ReportError(1, CssErrorCode.PossibleCharsetError);
                }

                // remove the BOM
                source = source.Substring(3);
            }
            else if (source.StartsWith("\u00fe\u00ff\u0000\u0000", StringComparison.Ordinal)
                || source.StartsWith("\u0000\u0000\u00ff\u00fe", StringComparison.Ordinal))
            {
                // apparently we had a UTF-32 BOM (either BE or LE) that wasn't stripped. Remove it now.
                // throw a syntax-level error because the rest of the file is probably whack.
                ReportError(0, CssErrorCode.PossibleCharsetError);
                source = source.Substring(4);
            }
            else if (source.StartsWith("\u00fe\u00ff", StringComparison.Ordinal)
                || source.StartsWith("\u00ff\u00fe", StringComparison.Ordinal))
            {
                // apparently we had a UTF-16 BOM (either BE or LE) that wasn't stripped. Remove it now.
                // throw a syntax-level error because the rest of the file is probably whack.
                ReportError(0, CssErrorCode.PossibleCharsetError);
                source = source.Substring(2);
            }
            else if (source.Length > 0 && source[0] == '\ufeff')
            {
                // properly-decoded UNICODE BOM was at the front. Everything should be okay, but strip it
                // so it doesn't interfere with the rest of the processing.
                source = source.Substring(1);
            }

            return string.Concat(initialSourceDirective, source);
        }

        /// <summary>
        /// Returns true if the given property is vendor-specific and the vendor prefix
        /// is in the list of excluded prefixes.
        /// </summary>
        /// <param name="propertyName">The property name</param>
        /// <returns>true if excluded; false otherwise</returns>
        private bool IsExcludedVendorPrefix(string propertyName)
        {
            bool isExcluded = false;
            var match = s_vendorSpecific.Match(propertyName);
            if (match.Success)
            {
                isExcluded = Settings.ExcludeVendorPrefixes.Contains(match.Result("$vendor"));
            }

            return isExcluded;
        }

        #endregion

        #region Parse... methods

        private Parsed ParseStylesheet()
        {
            Parsed parsed = Parsed.False;

            // ignore any semicolons that may be the result of concatenation on the part of NUglify
            SkipSemicolons();

            // the @charset token can ONLY be at the top of the file
            if (CurrentTokenType == TokenType.CharacterSetSymbol)
            {
                ParseCharset();
            }

            // any number of S, Comment, CDO, or CDC elements
            // (or semicolons possibly introduced via concatenation)
            ParseSCDOCDCComments();

            // any number of imports followed by S, Comment, CDO or CDC
            while (ParseImport() == Parsed.True)
            {
                // any number of S, Comment, CDO, or CDC elements
                // (or semicolons possibly introduced via concatenation)
                ParseSCDOCDCComments();
            }

            // any number of namespaces followed by S, Comment, CDO or CDC
            while (ParseNamespace() == Parsed.True)
            {
                // any number of S, Comment, CDO, or CDC elements
                // (or semicolons possibly introduced via concatenation)
                ParseSCDOCDCComments();
            }

            // the main guts of stuff
            while (ParseRule() == Parsed.True
              || ParseMedia() == Parsed.True
              || ParsePage() == Parsed.True
              || ParseFontFace() == Parsed.True
              || ParseKeyFrames() == Parsed.True
              || ParseAtKeyword() == Parsed.True
              || ParseAspNetBlock() == Parsed.True)
            {
                // any number of S, Comment, CDO or CDC elements
                // (or semicolons possibly introduced via concatenation)
                ParseSCDOCDCComments();
            }

            // if there weren't any errors, we SHOULD be at the EOF state right now.
            // if we're not, we may have encountered an invalid, unexpected character.
            while (!m_scanner.EndOfFile)
            {
                // throw an exception
                ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);

                // skip the token
                NextToken();

                // might be a comment again; check just in case
                // (or semicolons possibly introduced via concatenation)
                ParseSCDOCDCComments();

                // try the guts again
                while (ParseRule() == Parsed.True
                  || ParseMedia() == Parsed.True
                  || ParsePage() == Parsed.True
                  || ParseFontFace() == Parsed.True
                  || ParseAtKeyword() == Parsed.True
                  || ParseAspNetBlock() == Parsed.True)
                {
                    // any number of S, Comment, CDO or CDC elements
                    // (or semicolons possibly introduced via concatenation)
                    ParseSCDOCDCComments();
                }
            }

            return parsed;
        }

        private Parsed ParseCharset()
        {
            AppendCurrent();
            SkipSpace();

            if (CurrentTokenType != TokenType.String)
            {
                ReportError(0, CssErrorCode.ExpectedCharset, CurrentTokenText);
                SkipToEndOfStatement();
                AppendCurrent();
            }
            else
            {
                Append(' ');
                AppendCurrent();
                SkipSpace();

                if (CurrentTokenType != TokenType.Character || CurrentTokenText != ";")
                {
                    ReportError(0, CssErrorCode.ExpectedSemicolon, CurrentTokenText);
                    SkipToEndOfStatement();
                    // be sure to append the closing token (; or })
                    AppendCurrent();
                }
                else
                {
                    Append(';');
                    NextToken();
                }
            }

            return Parsed.True;
        }

        private void ParseSCDOCDCComments()
        {
            while (CurrentTokenType == TokenType.Space
              || CurrentTokenType == TokenType.Comment
              || CurrentTokenType == TokenType.CommentOpen
              || CurrentTokenType == TokenType.CommentClose
              || (CurrentTokenType == TokenType.Character && CurrentTokenText == ";"))
            {
                // don't output any space we encounter here, but do output comments.
                // we also want to skip over any semicolons we may encounter at this point
                if (CurrentTokenType != TokenType.Space && CurrentTokenType != TokenType.Character)
                {
                    AppendCurrent();
                }
                NextToken();
            }
        }

        /*
        private void ParseUnknownBlock()
        {
            // output the opening brace and move to the next
            AppendCurrent();
            // skip space -- there shouldn't need to be space after the opening brace
            SkipSpace();

            // loop until we find the closing breace
            while (!m_scanner.EndOfFile
              && (CurrentTokenType != TokenType.Character || CurrentTokenText != "}"))
            {
                // see if we are recursing unknown blocks
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "{")
                {
                    // recursive block
                    ParseUnknownBlock();
                }
                else if (CurrentTokenType == TokenType.AtKeyword)
                {
                    // parse the at-keyword
                    ParseAtKeyword();
                }
                else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ";")
                {
                    // append a semi-colon and skip any space after it
                    AppendCurrent();
                    SkipSpace();
                }
                else
                {
                    // whatever -- just append the token and move on
                    AppendCurrent();
                    NextToken();
                }
            }

            // output the closing brace and skip any trailing space
            AppendCurrent();
            SkipSpace();
        }
        */

        private Parsed ParseAtKeyword()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.AtKeyword)
            {
                // only report an unexpected at-keyword IF the identifier doesn't start 
                // with a hyphen, because that would be a vendor-specific at-keyword,
                // which is theoretically okay.
                if (!CurrentTokenText.StartsWith("@-", StringComparison.OrdinalIgnoreCase))
                {
                    ReportError(2, CssErrorCode.UnexpectedAtKeyword, CurrentTokenText);
                }

                SkipToEndOfStatement();
                AppendCurrent();
                SkipSpace();
                NewLine();
                parsed = Parsed.True;
            }
            else if(CurrentTokenType == TokenType.Supports)
            {
                parsed = ParseSupports();
            }
            else if (CurrentTokenType == TokenType.CharacterSetSymbol)
            {
                // we found a charset at-rule. Problem is, @charset can only be the VERY FIRST token
                // in the file, and we process it special. So if we get here, then it's NOT the first
                // token, and clients will ignore it. Throw a warning, but still process it.
                ReportError(2, CssErrorCode.UnexpectedCharset, CurrentTokenText);
                parsed = ParseCharset();
            }
            return parsed;
        }

        private Parsed ParseSupportsCondition(bool notOperatorAllowed, bool andOrOperatorsNeeded)
        {
            bool foundSupportsCondition = false;
            //more operators? no let parent finish ')'
            if (CurrentTokenType == TokenType.Character && andOrOperatorsNeeded)
            {
                if (CurrentTokenText == ")")
                {
                    return Parsed.Empty;
                }
            }

            bool operatorFound = false;
            if (CurrentTokenType == TokenType.Identifier)
            {
                operatorFound =
                ParseSupportsOperator(notOperatorAllowed, andOrOperatorsNeeded) == Parsed.True;
                if (!operatorFound) //no operator should be declaration then let parent finish that...
                {
                    return Parsed.Empty;
                }
            }

            if (CurrentTokenType == TokenType.Character && CurrentTokenText == "(")
            {
                AppendCurrent();
                SkipSpace();
                if (ParseSupportsCondition(true, false) == Parsed.True)
                {
                    foundSupportsCondition = true;
                }
                if (CurrentTokenType == TokenType.Identifier)
                {
                    if (ParseDeclaration() == Parsed.True)
                    {
                        foundSupportsCondition = true;
                        SkipIfSpace();
                        if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                        {
                            AppendCurrent();
                            SkipSpace();
                            ParseSupportsCondition(false, true);
                        }
                    }
                }
                else if (foundSupportsCondition && CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {//found a condition somewere so we can close up 
                    AppendCurrent();
                    SkipSpace(); //finish up
                }
                else
                {
                    ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                    return Parsed.False;
                }

            }
            return foundSupportsCondition ? Parsed.True : Parsed.False;
        }
        
        private Parsed ParseSupportsOperator(bool notOperatorAllowed, bool andOrOperatorsNeeded)
        {
            var parsed = Parsed.False;
            if (notOperatorAllowed)
            {
                if (CurrentTokenText.ToUpperInvariant() == "NOT")
                {
                    Append("not");
                    Append(' ');
                    SkipSpace();
                    parsed = Parsed.True;
                }
            }
            if (andOrOperatorsNeeded)
            {
                var upper = CurrentTokenText.ToUpperInvariant();
                if (upper == "AND" || upper == "OR")
                {
                    Append(' ');
                    Append(upper.ToLower());
                    Append(' ');
                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                    return Parsed.False;
                }
            }
            return parsed;
        }
        
        private Parsed ParseSupports()
        {
            bool notOperatorAllowed = false;
            bool andOrOperatorsNeeded = false;

            var keepDirective = true;
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Supports)
            {
                PushWaypoint();
                NewLine();
                AppendCurrent();
                Append(' ');
                SkipSpace();


                if (CurrentTokenType == TokenType.Identifier)
                {
                    if (CurrentTokenText.ToUpperInvariant() == "NOT")
                    {
                        notOperatorAllowed = true;
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                        return Parsed.False;
                    }
                }

                if (ParseSupportsCondition(notOperatorAllowed, andOrOperatorsNeeded) == Parsed.True)
                {
                    // expect current token to be the opening brace when calling
                    if (CurrentTokenType != TokenType.Character || CurrentTokenText != "{")
                    {
                        ReportError(0, CssErrorCode.ExpectedOpenBrace, CurrentTokenText);
                        SkipToEndOfStatement();
                        AppendCurrent();
                        SkipSpace();
                    }
                    else
                    {
                        NewLine();
                        AppendCurrent();
                        SkipSpace();


                        PushWaypoint();

                        // the main guts of stuff (copied from stylesheet)
                        while (ParseRule() == Parsed.True
                          || ParseMedia() == Parsed.True
                          || ParsePage() == Parsed.True
                          || ParseFontFace() == Parsed.True
                          || ParseKeyFrames() == Parsed.True
                          || ParseAtKeyword() == Parsed.True
                          || ParseAspNetBlock() == Parsed.True)
                        {
                            // any number of S, Comment, CDO or CDC elements
                            // (or semicolons possibly introduced via concatenation)
                            ParseSCDOCDCComments();
                        }
                        SkipIfSpace();

                        keepDirective = PopWaypoint(true);

                        if (CurrentTokenType != TokenType.Character || CurrentTokenText != "}")
                        {
                            ReportError(0, CssErrorCode.ExpectedClosingBrace, CurrentTokenText);
                            SkipToEndOfStatement();
                        }
                        else
                        {
                            AppendCurrent();
                            SkipSpace();
                            parsed = Parsed.True;
                        }
                    }
                }
                PopWaypoint(keepDirective);
            }
            return parsed;
        }

        private Parsed ParseAspNetBlock()
        {
            Parsed parsed = Parsed.False;
            if (Settings.AllowEmbeddedAspNetBlocks &&
                CurrentTokenType == TokenType.AspNetBlock)
            {
                AppendCurrent();
                SkipSpace();
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParseNamespace()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.NamespaceSymbol)
            {
                NewLine();
                AppendCurrent();
                SkipSpace();

                if (CurrentTokenType == TokenType.Identifier)
                {
                    Append(' ');
                    AppendCurrent();

                    // if the namespace is not already in the list, 
                    // save current text as a declared namespace value 
                    // that can be used in the rest of the code
                    if (!m_namespaces.Add(CurrentTokenText))
                    {
                        // error -- we already have this namespace in the list
                        ReportError(1, CssErrorCode.DuplicateNamespaceDeclaration, CurrentTokenText);
                    }

                    SkipSpace();
                }

                if (CurrentTokenType != TokenType.String
                  && CurrentTokenType != TokenType.Uri)
                {
                    ReportError(0, CssErrorCode.ExpectedNamespace, CurrentTokenText);
                    SkipToEndOfStatement();
                    AppendCurrent();
                }
                else
                {
                    Append(' ');
                    AppendCurrent();
                    SkipSpace();

                    if (CurrentTokenType == TokenType.Character
                      && CurrentTokenText == ";")
                    {
                        Append(';');
                        SkipSpace();
                        NewLine();
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.ExpectedSemicolon, CurrentTokenText);
                        SkipToEndOfStatement();
                        AppendCurrent();
                    }
                }

                parsed = Parsed.True;
            }
            return parsed;
        }

        private void ValidateNamespace(string namespaceIdent)
        {
            // check it against list of all declared @namespace names
            if (!string.IsNullOrEmpty(namespaceIdent)
                && namespaceIdent != "*"
                && !m_namespaces.Contains(namespaceIdent))
            {
                ReportError(0, CssErrorCode.UndeclaredNamespace, namespaceIdent);
            }
        }

        private Parsed ParseKeyFrames()
        {
            // '@keyframes' IDENT '{' keyframes-blocks '}'
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.KeyFramesSymbol)
            {
                // found the @keyframes at-rule
                parsed = Parsed.True;

                NewLine();
                AppendCurrent();
                SkipSpace();

                // needs to be followed by an identifier
                if (CurrentTokenType == TokenType.Identifier || CurrentTokenType == TokenType.String)
                {
                    // if this is an identifier, then we need to make sure we output a space
                    // character so the identifier doesn't get attached to the previous @-rule
                    if (CurrentTokenType == TokenType.Identifier || Settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Append(' ');
                    }

                    AppendCurrent();
                    SkipSpace();
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                }

                // followed by keyframe blocks surrounded with curly-braces
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "{")
                {
                    if (Settings.BlocksStartOnSameLine == BlockStart.NewLine
                        || Settings.BlocksStartOnSameLine == BlockStart.UseSource && m_encounteredNewLine)
                    {
                        NewLine();
                    }
                    else if (Settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Append(' ');
                    }

                    AppendCurrent();
                    Indent();
                    NewLine();
                    SkipSpace();

                    ParseKeyFrameBlocks();

                    // better end with a curly-brace
                    Unindent();
                    NewLine();
                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == "}")
                    {
                        NewLine();
                        AppendCurrent();
                        SkipSpace();
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.ExpectedClosingBrace, CurrentTokenText);
                        SkipToEndOfDeclaration();
                    }
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedOpenBrace, CurrentTokenText);
                    SkipToEndOfStatement();
                }
            }
            return parsed;
        }

        private void ParseKeyFrameBlocks()
        {
            // [ keyframe-selectors block ]*
            while (ParseKeyFrameSelectors() == Parsed.True)
            {
                ParseDeclarationBlock(false);

                // set the force-newline flag to true so that any selectors we may find next
                // will start on a new line
                m_forceNewLine = true;
            }

            // reset the flag
            m_forceNewLine = false;
        }

        private Parsed ParseKeyFrameSelectors()
        {
            // [ 'from' | 'to' | PERCENTAGE ] [ ',' [ 'from' | 'to' | PERCENTAGE ] ]*
            Parsed parsed = Parsed.False;

            // see if we start with a percentage or the words "from" or "to"
            if (CurrentTokenType == TokenType.Percentage)
            {
                AppendCurrent();
                SkipSpace();
                parsed = Parsed.True;
            }
            else if (CurrentTokenType == TokenType.Identifier)
            {
                var upperIdent = CurrentTokenText.ToUpperInvariant();
                if (string.CompareOrdinal(upperIdent, "FROM") == 0
                    || string.CompareOrdinal(upperIdent, "TO") == 0)
                {
                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                }
            }

            // if we found one, keep going as long as there are others comma-separated
            while (parsed == Parsed.True && CurrentTokenType == TokenType.Character && CurrentTokenText == ",")
            {
                // append the comma, and if this is multiline mode, follow it with a space for readability
                AppendCurrent();
                if (Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }
                SkipSpace();

                // needs to be either a percentage or "from" or "to"
                if (CurrentTokenType == TokenType.Percentage)
                {
                    AppendCurrent();
                    SkipSpace();
                }
                else if (CurrentTokenType == TokenType.Identifier)
                {
                    var upperIdent = CurrentTokenText.ToUpperInvariant();
                    if (string.CompareOrdinal(upperIdent, "FROM") == 0
                        || string.CompareOrdinal(upperIdent, "TO") == 0)
                    {
                        AppendCurrent();
                        SkipSpace();
                    }
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedPercentageFromOrTo, CurrentTokenText);
                }
            }

            return parsed;
        }

        private Parsed ParseImport()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.ImportSymbol)
            {
                NewLine();
                AppendCurrent();
                SkipSpace();

                if (CurrentTokenType != TokenType.String
                  && CurrentTokenType != TokenType.Uri)
                {
                    ReportError(0, CssErrorCode.ExpectedImport, CurrentTokenText);
                    SkipToEndOfStatement();
                    AppendCurrent();
                }
                else
                {
                    // only need a space if this is a Uri -- a string starts with a quote delimiter
                    // and won't get parsed as teh end of the @import token
                    if (CurrentTokenType == TokenType.Uri || Settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Append(' ');
                    }

                    // append the file (string or uri)
                    AppendCurrent();
                    SkipSpace();

                    // optional comma-separated list of media queries
                    // won't need a space because the ending is either a quote or a paren
                    ParseMediaQueryList(false);

                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ";")
                    {
                        Append(';');
                        NewLine();
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.ExpectedSemicolon, CurrentTokenText);
                        SkipToEndOfStatement();
                        AppendCurrent();
                    }
                }
                SkipSpace();
                parsed = Parsed.True;
            }

            return parsed;
        }

        private Parsed ParseMedia()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.MediaSymbol)
            {
                // push a waypoint. We're not going to want to output this @media directive
                // if the rule collection is empty
                var keepDirective = true;
                PushWaypoint();

                NewLine();
                AppendCurrent();
                SkipSpace();

                var indented = false;

                // might need a space because the last token was @media
                if (ParseMediaQueryList(true) == Parsed.True)
                {
                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == "{")
                    {
                        if (Settings.BlocksStartOnSameLine == BlockStart.NewLine
                            || Settings.BlocksStartOnSameLine == BlockStart.UseSource && m_encounteredNewLine)
                        {
                            NewLine();
                        }
                        else if (Settings.OutputMode == OutputMode.MultipleLines)
                        {
                            Append(' ');
                        }

                        AppendCurrent();
                        Indent();
                        indented = true;
                        SkipSpace();

                        // push a waypoint for the rules inside the @media directive
                        PushWaypoint();

                        // the main guts of stuff
                        while (ParseRule() == Parsed.True
                          || ParseMedia() == Parsed.True
                          || ParsePage() == Parsed.True
                          || ParseFontFace() == Parsed.True
                          || ParseAtKeyword() == Parsed.True
                          || ParseAspNetBlock() == Parsed.True)
                        {
                            // any number of S, Comment, CDO or CDC elements
                            ParseSCDOCDCComments();
                        }

                        // we want to keep this directive if we've actually parsed anything;
                        // otherwise we'll throw out the whole thing.
                        keepDirective = PopWaypoint(true);
                    }
                    else
                    {
                        SkipToEndOfStatement();
                    }

                    if (CurrentTokenType == TokenType.Character)
                    {
                        if (CurrentTokenText == ";")
                        {
                            AppendCurrent();
                            if (indented)
                            {
                                Unindent();
                            }
                            
                            NewLine();
                        }
                        else if (CurrentTokenText == "}")
                        {
                            if (indented)
                            {
                                Unindent();
                            }

                            NewLine();
                            AppendCurrent();
                        }
                        else
                        {
                            SkipToEndOfStatement();
                            AppendCurrent();
                        }
                    }
                    else
                    {
                        SkipToEndOfStatement();
                        AppendCurrent();
                    }

                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    SkipToEndOfStatement();
                }

                PopWaypoint(keepDirective);
            }

            return parsed;
        }

        private Parsed ParseMediaQueryList(bool mightNeedSpace)
        {
            // see if we have a media query
            Parsed parsed = ParseMediaQuery(mightNeedSpace);

            // it's a comma-separated list, so as long as we find a comma, keep parsing queries
            while(CurrentTokenType == TokenType.Character && CurrentTokenText == ",")
            {
                // output the comma and skip any space
                AppendCurrent();
                SkipSpace();

                if (ParseMediaQuery(false) != Parsed.True)
                {
                    // fail
                    ReportError(0, CssErrorCode.ExpectedMediaQuery, CurrentTokenText);
                }
            }

            return parsed;
        }

        private Parsed ParseMediaQuery(bool firstQuery)
        {
            var parsed = Parsed.False;
            var mightNeedSpace = firstQuery;

            // we have an optional word ONLY or NOT -- they will show up as identifiers here
            if (CurrentTokenType == TokenType.Identifier &&
                (string.Compare(CurrentTokenText, "ONLY", StringComparison.OrdinalIgnoreCase) == 0
                || string.Compare(CurrentTokenText, "NOT", StringComparison.OrdinalIgnoreCase) == 0))
            {
                // if this is the first query, the last thing we output was @media, which will need a separator.
                // if it's not the first, the last thing was a comma, so no space is needed.
                // but if we're expanding the output, we always want a space
                if (firstQuery || Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }

                // output the only/not string and skip any subsequent space
                AppendCurrent();
                SkipSpace();
                
                // we might need a space since the last thing was the only/not
                mightNeedSpace = true;
            }

            // we should be at a either a media type or an expression
            if (CurrentTokenType == TokenType.Identifier)
            {
                // media type
                // if we might need a space, output it now
                if (mightNeedSpace || Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }

                // output the media type
                AppendCurrent();
                SkipSpace();

                // the media type is an identifier, so we might need a space
                mightNeedSpace = true;

                // the next item should be either AND or the start of the block
                parsed = Parsed.True;
            }
            else if (CurrentTokenType == TokenType.Character && CurrentTokenText == "(")
            {
                // no media type -- straight to an expression
                ParseMediaQueryExpression();

                // The straight-up spec says the whitespace is optional, so at this point you'd
                // THINK we wouldn't need whitespace between a close-paren and the word "and."
                // However, there is an errata published:
                // http://www.w3.org/Style/2012/REC-mediaqueries-20120619-errata.html
                // that makes whitespace before the AND mandatory.
                // The errata is completely correct with regards to making the whitespace AFTER
                // the "and" mandatory -- we need to be disambiguous: is it "and" followed by a "(",
                // or is it the FUNCTION "and("? Not sure the before is strictly mandatory, but
                // let's roll with it.
                mightNeedSpace = true;

                // the next item should be either AND or the start of the block
                parsed = Parsed.True;
            }
            else if (CurrentTokenType != TokenType.Character || CurrentTokenText != ";")
            {
                // expected a media type
                ReportError(0, CssErrorCode.ExpectedMediaIdentifier, CurrentTokenText);
            }

            // either we have no more and-delimited expressions,
            // OR we have an *identifier* AND (and followed by space)
            // OR we have a *function* AND (and followed by the opening paren, scanned as a function)
            while ((CurrentTokenType == TokenType.Identifier
                && string.Compare(CurrentTokenText, "AND", StringComparison.OrdinalIgnoreCase) == 0)
                || (CurrentTokenType == TokenType.Function
                && string.Compare(CurrentTokenText, "AND(", StringComparison.OrdinalIgnoreCase) == 0))
            {
                // if we might need a space, output it now
                if (mightNeedSpace || Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }

                // output the AND text.
                // MIGHT be AND( if it was a function, so first set a flag so we will know
                // wether or not to expect the opening paren
                if (CurrentTokenType == TokenType.Function)
                {
                    // this is not strictly allowed by the CSS3 spec!
                    // we are going to throw an error
                    ReportError(1, CssErrorCode.MediaQueryRequiresSpace, CurrentTokenText);

                    //and then fix what the developer wrote and make sure there is a space
                    // between the AND and the (. The CSS3 spec says it is invalid to not have a
                    // space there.
                    Append("and (");
                    SkipSpace();

                    // included the paren
                    ParseMediaQueryExpression();
                }
                else
                {
                    // didn't include the paren -- it BETTER be the next token 
                    // (after we output the AND token)
                    AppendCurrent();
                    SkipSpace();
                    if (CurrentTokenType == TokenType.Character
                        && CurrentTokenText == "(")
                    {
                        // put a space between the AND and the (
                        Append(' ');

                        ParseMediaQueryExpression();
                    }
                    else
                    {
                        // error -- we expected another media query expression
                        ReportError(0, CssErrorCode.ExpectedMediaQueryExpression, CurrentTokenText);

                        // break out of the loop so we can exit
                        break;
                    }
                }
            }

            return parsed;
        }

        private void ParseMediaQueryExpression()
        {
            // expect current token to be the opening paren when calling
            if (CurrentTokenType == TokenType.Character && CurrentTokenText == "(")
            {
                // output the paren and skip any space
                AppendCurrent();
                SkipSpace();
            }

            // media feature is required, and it's an ident
            if (CurrentTokenType == TokenType.Identifier)
            {
                // output the media feature and skip any space
                AppendCurrent();
                SkipSpace();

                // the next token should either be a colon (followed by an expression) or the closing paren
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ":")
                {
                    // got an expression.
                    // output the colon and skip any whitespace
                    AppendCurrent();
                    SkipSpace();

                    // if we are expanding the output, we want a space after the colon
                    if (Settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Append(' ');
                    }

                    // parse the expression -- it's not optional
                    if (ParseExpr() != Parsed.True)
                    {
                        ReportError(0, CssErrorCode.ExpectedExpression, CurrentTokenText);
                    }

                    // better be the closing paren
                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                    {
                        // output the closing paren and skip any whitespace
                        AppendCurrent();
                        SkipSpace();
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                    }
                }
                else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {
                    // end of the expressions -- output the closing paren and skip any whitespace
                    AppendCurrent();
                    SkipSpace();
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                }
            }
            else
            {
                ReportError(0, CssErrorCode.ExpectedMediaFeature, CurrentTokenText);
            }
        }

        private Parsed ParseDeclarationBlock(bool allowMargins)
        {
            var parsed = Parsed.True;

            // expect current token to be the opening brace when calling
            if (CurrentTokenType != TokenType.Character || CurrentTokenText != "{")
            {
                ReportError(0, CssErrorCode.ExpectedOpenBrace, CurrentTokenText);
                SkipToEndOfStatement();
                AppendCurrent();
                SkipSpace();
            }
            else
            {
                if (Settings.BlocksStartOnSameLine == BlockStart.NewLine
                    || Settings.BlocksStartOnSameLine == BlockStart.UseSource && m_encounteredNewLine)
                {
                    NewLine();
                }
                else if (Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }

                Append('{');

                Indent();
                SkipSpace();

                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "}")
                {
                    // shortcut nothing in the block to have the close on the same line
                    Unindent();
                    AppendCurrent();
                    SkipSpace();

                    // return parsed empty to indicate that the block is a valid, empty block
                    parsed = Parsed.Empty;
                }
                else
                {
                    ParseDeclarationList(allowMargins);
                    if (CurrentTokenType == TokenType.Character && CurrentTokenText == "}")
                    {
                        // append the closing brace
                        Unindent();
                        NewLine();
                        Append('}');
                        // skip past it
                        SkipSpace();
                    }
                    else if (m_scanner.EndOfFile)
                    {
                        // no closing brace, just the end of the file
                        ReportError(0, CssErrorCode.UnexpectedEndOfFile);
                    }
                    else
                    {
                        // I'm pretty sure ParseDeclarationList will only return on two situations:
                        //   1. closing brace (}), or
                        //   2. EOF.
                        // shouldn't get here, but just in case.
                        ReportError(0, CssErrorCode.ExpectedClosingBrace, CurrentTokenText);
                        Debug.Fail("UNEXPECTED CODE");
                    }
                }
            }

            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private Parsed ParseDeclarationList(bool allowMargins)
        {
            var parsed = Parsed.Empty;
            while (!m_scanner.EndOfFile)
            {
                // check the line length before each new declaration -- if we're past the threshold, start a new line
                if (m_lineLength >= Settings.LineBreakThreshold)
                {
                    AddNewLine();
                }

                Parsed parsedDecl = ParseDeclaration();
                if (parsed == Parsed.Empty && parsedDecl != Parsed.Empty)
                {
                    parsed = parsedDecl;
                }

                // if we are allowed to have margin at-keywords in this block, and
                // we didn't find a declaration, check to see if it's a margin
                var parsedMargin = false;
                if (allowMargins && parsedDecl == Parsed.Empty)
                {
                    parsedMargin = ParseMargin() == Parsed.True;
                }

                // if we parsed a margin, we DON'T expect there to be a semi-colon.
                // if we didn't parse a margin, then there better be either a semicolon or a closing brace.
                if (!parsedMargin)
                {
                    if ((CurrentTokenType != TokenType.Character
                        || (CurrentTokenText != ";" && CurrentTokenText != "}"))
                        && !m_scanner.EndOfFile)
                    {
                        ReportError(0, CssErrorCode.ExpectedSemicolonOrClosingBrace, CurrentTokenText);

                        // we'll get here if we decide to ignore the error and keep trudging along. But we still
                        // need to skip to the end of the declaration.
                        SkipToEndOfDeclaration();
                    }
                }

                // if we're at the end, close it out
                if (m_scanner.EndOfFile)
                {
                    // if we want to force a terminating semicolon, add it now
                    if (Settings.TermSemicolons)
                    {
                        Append(';');
                    }
                }
                else if (CurrentTokenText == "}")
                {
                    // if we want terminating semicolons but the source
                    // didn't have one (evidenced by a non-empty declaration)...
                    if (Settings.TermSemicolons && parsedDecl == Parsed.True)
                    {
                        // ...then add one now.
                        Append(';');
                    }

                    break;
                }
                else if (CurrentTokenText == ";")
                {
                    // token is a semi-colon
                    // if we always want to add the semicolons, add it now
                    if (Settings.TermSemicolons)
                    {
                        Append(';');
                        SkipSpace();
                    }
                    else
                    {
                        // we have a semicolon, but we don't know if we can
                        // crunch it out or not. If the NEXT token is a closing brace, then
                        // we can crunch out the semicolon.
                        // PROBLEM: if there's a significant comment AFTER the semicolon, then the 
                        // comment gets output before we output the semicolon, which could
                        // reverse the intended code.

                        // skip any whitespace to see if we need to add a semicolon
                        // to the end, or if we can crunch it out, but use a special function
                        // that doesn't send any comments to the stream yet -- it batches them
                        // up and returns them (if any)
                        string comments = NextSignificantToken();

                        if (m_scanner.EndOfFile)
                        {
                            // if we have an EOF after the semicolon and no comments, then we don't want
                            // to output anything else.
                            if (comments.Length > 0)
                            {
                                // but if we have comments after the semicolon....
                                // if there's a non-empty comment, it might be a significant hack, so add the semi-colon just in case.
                                if (comments != "/* */" && comments != "/**/")
                                {
                                    Append(';');
                                }

                                // and comments always end on a new line
                                Append(comments);
                                m_outputNewLine = true;
                                m_lineLength = 0;
                            }
                            break;
                        }
                        else if (CurrentTokenType != TokenType.Character
                            || (CurrentTokenText != "}" && CurrentTokenText != ";")
                            || (comments.Length > 0 && comments != "/* */" && comments != "/**/"))
                        {
                            // if the significant token after the 
                            // semicolon is not a cosing brace, then we'll add the semicolon.
                            // if there are two semi-colons in a row, don't add it because we'll double it.
                            // if there's a non-empty comment, it might be a significant hack, so add the semi-colon just in case.
                            Append(';');
                        }

                        // now that we've possibly added our semi-colon, we're safe
                        // to add any comments we may have found before the current token
                        if (comments.Length > 0)
                        {
                            Append(comments);

                            // and comments always end on a new line
                            m_outputNewLine = true;
                            m_lineLength = 0;
                        }
                    }
                }
            }

            return parsed;
        }

        private Parsed ParsePage()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.PageSymbol)
            {
                var keepDirective = true;
                PushWaypoint();

                NewLine();
                AppendCurrent();
                SkipSpace();

                if (CurrentTokenType == TokenType.Identifier)
                {
                    Append(' ');
                    AppendCurrent();
                    NextToken();
                }
                // optional
                ParsePseudoPage();

                if (CurrentTokenType == TokenType.Space)
                {
                    SkipSpace();
                }

                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "{")
                {
                    // allow margin at-keywords
                    parsed = ParseDeclarationBlock(true);
                    if (parsed == Parsed.Empty)
                    {
                        keepDirective = false;
                        parsed = Parsed.True;
                    }

                    NewLine();
                }
                else
                {
                    SkipToEndOfStatement();
                    AppendCurrent();
                    SkipSpace();
                }

                PopWaypoint(keepDirective);
            }
            return parsed;
        }

        private Parsed ParsePseudoPage()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Character && CurrentTokenText == ":")
            {
                Append(':');
                NextToken();

                if (CurrentTokenType != TokenType.Identifier)
                {
                    ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                }

                AppendCurrent();
                NextToken();
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParseMargin()
        {
            var parsed = Parsed.Empty;
            var keepDirective = true;
            switch (CurrentTokenType)
            {
                case TokenType.TopLeftCornerSymbol:
                case TokenType.TopLeftSymbol:
                case TokenType.TopCenterSymbol:
                case TokenType.TopRightSymbol:
                case TokenType.TopRightCornerSymbol:
                case TokenType.BottomLeftCornerSymbol:
                case TokenType.BottomLeftSymbol:
                case TokenType.BottomCenterSymbol:
                case TokenType.BottomRightSymbol:
                case TokenType.BottomRightCornerSymbol:
                case TokenType.LeftTopSymbol:
                case TokenType.LeftMiddleSymbol:
                case TokenType.LeftBottomSymbol:
                case TokenType.RightTopSymbol:
                case TokenType.RightMiddleSymbol:
                case TokenType.RightBottomSymbol:
                    // these are the margin at-keywords
                    PushWaypoint();
                    NewLine();
                    AppendCurrent();
                    SkipSpace();

                    // don't allow margin at-keywords
                    parsed = ParseDeclarationBlock(false);
                    if (parsed == Parsed.Empty)
                    {
                        keepDirective = false;
                        parsed = Parsed.True;
                    }

                    NewLine();
                    PopWaypoint(keepDirective);
                    break;

                default:
                    // we're not interested
                    break;
            }
            return parsed;
        }

        private Parsed ParseFontFace()
        {
            var parsed = Parsed.False;
            if (CurrentTokenType == TokenType.FontFaceSymbol)
            {
                var keepDirective = true;
                PushWaypoint();

                NewLine();
                AppendCurrent();
                SkipSpace();

                // don't allow margin at-keywords
                parsed = ParseDeclarationBlock(false);
                if (parsed == Parsed.Empty)
                {
                    keepDirective = false;
                    parsed = Parsed.True;
                }

                NewLine();
                PopWaypoint(keepDirective);
            }
            return parsed;
        }

        private Parsed ParseOperator()
        {
            Parsed parsed = Parsed.Empty;
            if (CurrentTokenType == TokenType.Character
              && (CurrentTokenText == "/" || CurrentTokenText == ","))
            {
                AppendCurrent();
                SkipSpace();
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParseCombinator()
        {
            Parsed parsed = Parsed.Empty;
            if (CurrentTokenType == TokenType.Character
              && (CurrentTokenText == "+" || CurrentTokenText == ">" || CurrentTokenText == "~"))
            {
                AppendCurrent();
                SkipSpace();
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParseRule()
        {
            var keepRule = true;
            PushWaypoint();

            // check the line length before each new declaration -- if we're past the threshold, start a new line
            if (m_lineLength >= Settings.LineBreakThreshold)
            {
                AddNewLine();
            }

            m_forceNewLine = true;
            Parsed parsed = ParseSelector();
            if (parsed == Parsed.True)
            {
                if (m_scanner.EndOfFile)
                {
                    // we parsed a selector expecting this to be a rule, but then WHAM! we hit
                    // the end of the file. That isn't correct. Throw an error.
                    ReportError(0, CssErrorCode.UnexpectedEndOfFile);
                }

                while (!m_scanner.EndOfFile)
                {
                    if (CurrentTokenType != TokenType.Character
                        || (CurrentTokenText != "," && CurrentTokenText != "{"))
                    {
                        ReportError(0, CssErrorCode.ExpectedCommaOrOpenBrace, CurrentTokenText);
                        SkipToEndOfStatement();
                        AppendCurrent();
                        SkipSpace();
                        break;
                    }

                    if (CurrentTokenText == "{")
                    {
                        // REVIEW: IE6 has an issue where the "first-letter" and "first-line" 
                        // pseudo-classes need to be separated from the opening curly-brace 
                        // of the following rule set by a space or it doesn't get picked up. 
                        // So if the last-outputted word was "first-letter" or "first-line",
                        // add a space now (since we know the next character at this point 
                        // is the opening brace of a rule-set).
                        // Maybe some day this should be removed or put behind an "IE6-compat" switch.
                        if (m_lastOutputString == "first-letter" || m_lastOutputString == "first-line")
                        {
                            Append(' ');
                        }

                        // don't allow margin at-keywords
                        parsed = ParseDeclarationBlock(false);
                        if (parsed == Parsed.Empty)
                        {
                            keepRule = false;
                            parsed = Parsed.True;
                        }

                        break;
                    }

                    Append(',');

                    // check the line length before each new declaration -- if we're past the threshold, start a new line
                    if (m_lineLength >= Settings.LineBreakThreshold)
                    {
                        AddNewLine();
                    }
                    else if (Settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Append(' ');
                    }

                    SkipSpace();

                    if (ParseSelector() != Parsed.True)
                    {
                        if (CurrentTokenType == TokenType.Character && CurrentTokenText == "{")
                        {
                            // the author ended the last selector with a comma, but didn't include
                            // the next selector before starting the declaration block. Or maybe it's there,
                            // but commented out. Still okay, but flag a style warning.
                            ReportError(4, CssErrorCode.ExpectedSelector, CurrentTokenText);
                            continue;
                        }
                        else
                        {
                            // not something we know about -- skip the whole statement
                            ReportError(0, CssErrorCode.ExpectedSelector, CurrentTokenText);
                            SkipToEndOfStatement();
                        }
                        AppendCurrent();
                        SkipSpace();
                        break;
                    }
                }
            }

            PopWaypoint(keepRule);
            return parsed;
        }

        private Parsed ParseSelectorList()
        {
            var parsed = ParseSelector();
            while (CurrentTokenType == TokenType.Character && CurrentTokenText == ",")
            {
                // append the comma to the output and skip it any any other
                // space following it
                AppendCurrent();
                SkipSpace();

                // parse another selector. Don't save the parsed result because this
                // function should return true now, since we parsed at least one selected
                // successfully
                if (ParseSelector() != Parsed.True)
                {
                    // but if we fail for any reason, then break out of the loop after reporting
                    // an error
                    ReportError(0, CssErrorCode.ExpectedSelector, CurrentTokenText);
                    break;
                }
            }

            return parsed;
        }

        private Parsed ParseSelector()
        {
            // should start with a selector
            Parsed parsed = ParseSimpleSelector();
            if (parsed == Parsed.False && CurrentTokenType != TokenType.None)
            {
                // no selector? See if it starts with a combinator.
                // common IE-7 hack to start with a combinator, because that browser will assume a beginning *
                var currentContext = m_currentToken.Context;
                var possibleCombinator = CurrentTokenText;
                parsed = ParseCombinator();
                if (parsed == Parsed.True)
                {
                    ReportError(4, CssErrorCode.HackGeneratesInvalidCss, currentContext, possibleCombinator);
                }
            }

            if (parsed == Parsed.True)
            {
                // save whether or not we are skipping anything by checking the type before we skip
                bool spaceWasSkipped = SkipIfSpace();

                while (!m_scanner.EndOfFile)
                {
                    Parsed parsedCombinator = ParseCombinator();
                    if (parsedCombinator != Parsed.True)
                    {
                        // we know the selector ends with a comma or an open brace,
                        // so if the next token is one of those, we're done.
                        // otherwise we're going to slap a space in the stream (if we found one)
                        // and look for the next selector
                        if (CurrentTokenType == TokenType.Character
                          && (CurrentTokenText == "," || CurrentTokenText == "{" || CurrentTokenText == ")"))
                        {
                            break;
                        }
                        else if (spaceWasSkipped)
                        {
                            Append(' ');
                        }
                    }

                    if (ParseSimpleSelector() == Parsed.False)
                    {
                        ReportError(0, CssErrorCode.ExpectedSelector, CurrentTokenText);
                        break;
                    }
                    else
                    {
                        // save the "we skipped whitespace" flag before skipping the whitespace
                        spaceWasSkipped = SkipIfSpace();
                    }
                }
            }
            return parsed;
        }

        // does NOT skip whitespace after the selector
        private Parsed ParseSimpleSelector()
        {
            // the element name is optional
            Parsed parsed = ParseElementName();
            while (!m_scanner.EndOfFile)
            {
                if (CurrentTokenType == TokenType.Hash)
                {
                    AppendCurrent();
                    NextToken();
                    parsed = Parsed.True;
                }
                else if (ParseClass() == Parsed.True)
                {
                    parsed = Parsed.True;
                }
                else if (ParseAttrib() == Parsed.True)
                {
                    parsed = Parsed.True;
                }
                else if (ParsePseudo() == Parsed.True)
                {
                    parsed = Parsed.True;
                }
                else
                {
                    break;
                }
            }
            return parsed;
        }

        private Parsed ParseClass()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Character
              && CurrentTokenText == ".")
            {
                AppendCurrent();
                NextToken();

                if (CurrentTokenType == TokenType.Identifier)
                {
                    AppendCurrent();
                    NextToken();
                    parsed = Parsed.True;
                }
                else if (CurrentTokenType == TokenType.Character && CurrentTokenText == "%")
                {
                    UpdateIfReplacementToken();
                    if (CurrentTokenType == TokenType.ReplacementToken)
                    {
                        AppendCurrent();
                        NextToken();
                        parsed = Parsed.True;
                    }
                    else
                    {
                        ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                    }
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                }
            }
            else if (CurrentTokenType == TokenType.Dimension || CurrentTokenType == TokenType.Number)
            {
                string rawNumber = m_scanner.RawNumber;
                if (rawNumber != null && rawNumber.StartsWith(".", StringComparison.Ordinal))
                {
                    // if we are expecting a class but we got dimension or number that starts with a period,
                    // then what we REALLY have is a class name that starts with a digit. If it's all digits,
                    // it will be a number, and it it's just an identifier that starts with a digit, it will
                    // be a dimension.
                    // The problem here is that both of those those token type format the number, eg: 
                    // .000foo would get shrunk to 0foo.
                    // Be sure to use the RawNumber property on the scanner to get the raw text exactly as
                    // it was from the input
                    parsed = Parsed.True;

                    // but check the next token to see if it's an identifier.
                    // if the next token is an identifier with no whitespace between it and the previous
                    // "number," then it's part of this identifier
                    NextToken();
                    if (CurrentTokenType == TokenType.Identifier)
                    {
                        // add that identifier to the raw number
                        rawNumber += CurrentTokenText;
                        NextToken();
                    }

                    // report a low-sev warning before outputting the raw number text and advancing
                    ReportError(2, CssErrorCode.PossibleInvalidClassName, rawNumber);
                    Append(rawNumber);
                }
            }
            return parsed;
        }

        private Parsed ParseElementName()
        {
            Parsed parsed = Parsed.False;
            bool foundNamespace = false;

            // if the next character is a pipe, then we have an empty namespace prefix
            if (CurrentTokenType == TokenType.Character && CurrentTokenText == "|")
            {
                foundNamespace = true;
                AppendCurrent();
                NextToken();
            }

            if (CurrentTokenType == TokenType.Identifier
                || (CurrentTokenType == TokenType.Character && CurrentTokenText == "*"))
            {
                // if we already found a namespace, then there was none specified and the
                // element name started with |. Otherwise, save the current ident as a possible
                // namespace identifier
                string identifier = foundNamespace ? null : CurrentTokenText;

                AppendCurrent();
                NextToken();
                parsed = Parsed.True;

                // if the next character is a pipe, then that previous identifier or asterisk
                // was the namespace prefix
                if (!foundNamespace
                    && CurrentTokenType == TokenType.Character && CurrentTokenText == "|")
                {
                    // throw an error if identifier wasn't prevously defined by @namespace statement
                    ValidateNamespace(identifier);

                    // output the pipe and move to the true element name
                    AppendCurrent();
                    NextToken();

                    // a namespace and the bar character should ALWAYS be followed by
                    // either an identifier or an asterisk
                    if (CurrentTokenType == TokenType.Identifier
                        || (CurrentTokenType == TokenType.Character && CurrentTokenText == "*"))
                    {
                        AppendCurrent();
                        NextToken();
                    }
                    else
                    {
                        // we have an error condition
                        parsed = Parsed.False;
                        // handle the error
                        ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                    }
                }
            }
            else if (foundNamespace)
            {
                // we had found an empty namespace, but no element or universal following it!
                // handle the error
                ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
            }

            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private Parsed ParseAttrib()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Character
              && CurrentTokenText == "[")
            {
                Append('[');
                SkipSpace();

                bool foundNamespace = false;
                
                // must be either an identifier, an asterisk, or a namespace separator
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "|")
                {
                    // has an empty namespace
                    foundNamespace = true;
                    AppendCurrent();
                    NextToken();
                }

                if (CurrentTokenType == TokenType.Identifier
                    || (CurrentTokenType == TokenType.Character && CurrentTokenText == "*"))
                {
                    // if we already found a namespace, then there was none specified and the
                    // element name started with |. Otherwise, save the current ident as a possible
                    // namespace identifier
                    string identifier = foundNamespace ? null : CurrentTokenText;

                    AppendCurrent();
                    SkipSpace();

                    // check to see if that identifier is actually a namespace because the current
                    // token is a namespace separator
                    if (!foundNamespace 
                        && CurrentTokenType == TokenType.Character && CurrentTokenText == "|")
                    {
                        // namespaced attribute
                        // throw an error if the namespace hasn't previously been defined by a @namespace statement
                        ValidateNamespace(identifier);

                        // output the pipe and move to the next token,
                        // which should be the attribute name
                        AppendCurrent();
                        SkipSpace();

                        // must be either an identifier or an asterisk
                        if (CurrentTokenType == TokenType.Identifier
                            || (CurrentTokenType == TokenType.Character && CurrentTokenText == "*"))
                        {
                            // output the namespaced attribute name
                            AppendCurrent();
                            SkipSpace();
                        }
                        else
                        {
                            ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                        }
                    }
                }
                else
                {
                    // neither an identifier nor an asterisk
                    ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                }

                // check to see if there's an (optional) attribute operator
                if ((CurrentTokenType == TokenType.Character && CurrentTokenText == "=")
                  || (CurrentTokenType == TokenType.Includes)
                  || (CurrentTokenType == TokenType.DashMatch)
                  || (CurrentTokenType == TokenType.PrefixMatch)
                  || (CurrentTokenType == TokenType.SuffixMatch)
                  || (CurrentTokenType == TokenType.SubstringMatch))
                {
                    AppendCurrent();
                    SkipSpace();

                    if (CurrentTokenType == TokenType.Character
                        && CurrentTokenText == "%")
                    {
                        UpdateIfReplacementToken();
                        if (CurrentTokenType != TokenType.ReplacementToken)
                        {
                            ReportError(0, CssErrorCode.ExpectedIdentifierOrString, CurrentTokenText);
                        }
                    }
                    else if (CurrentTokenType != TokenType.Identifier
                      && CurrentTokenType != TokenType.String)
                    {
                        ReportError(0, CssErrorCode.ExpectedIdentifierOrString, CurrentTokenText);
                    }

                    AppendCurrent();
                    SkipSpace();
                }

                if (CurrentTokenType != TokenType.Character
                  || CurrentTokenText != "]")
                {
                    ReportError(0, CssErrorCode.ExpectedClosingBracket, CurrentTokenText);
                }

                // we're done!
                Append(']');
                NextToken();
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParsePseudo()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Character
              && CurrentTokenText == ":")
            {
                Append(':');
                NextToken();

                // CSS3 has pseudo-ELEMENTS that are specified with a double-colon.
                // IF we find a double-colon, we will treat it exactly the same as if it were a pseudo-CLASS.
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ":")
                {
                    Append(':');
                    NextToken();
                }

                switch (CurrentTokenType)
                {
                    case TokenType.Identifier:
                        AppendCurrent();
                        NextToken();
                        break;

                    case TokenType.Not:
                    case TokenType.Any:
                    case TokenType.Matches:
                        AppendCurrent();
                        SkipSpace();

                        // the argument of an ANY/MATCHES pseudo function is a selector list,
                        // and Selectors 4 standards say NOT is also a selector list. Selectors 3
                        // says NOT is only a simple selector, but let's go with the later standard
                        parsed = ParseSelectorList();
                        if (parsed != Parsed.True)
                        {
                            // TODO: error? shouldn't we ALWAYS have a selector list inside a not()/matches()/any() function?
                        }

                        // skip any whitespace if we have it
                        SkipIfSpace();

                        // don't forget the closing paren
                        if (CurrentTokenType != TokenType.Character
                          || CurrentTokenText != ")")
                        {
                            ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                        }
                        AppendCurrent();
                        NextToken();
                        break;

                    case TokenType.Function:
                        AppendCurrent();
                        SkipSpace();

                        // parse the function argument expression
                        ParseExpression();

                        // IE extends CSS3 grammar to provide for multiple arguments to pseudo-class
                        // functions. So as long as the current token is a comma, keep on parsing
                        // expressions.
                        while (CurrentTokenType == TokenType.Character
                            && CurrentTokenText == ",")
                        {
                            AppendCurrent();
                            NextToken();
                            ParseExpression();
                        }

                        if (CurrentTokenType != TokenType.Character
                          || CurrentTokenText != ")")
                        {
                            ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                        }
                        AppendCurrent();
                        NextToken();
                        break;

                    default:
                        ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                        break;
                }
                parsed = Parsed.True;
            }
            return parsed;
        }

        private Parsed ParseExpression()
        {
            Parsed parsed = Parsed.Empty;
            while(true)
            {
                switch(CurrentTokenType)
                {
                    case TokenType.Dimension:
                    case TokenType.Number:
                    case TokenType.String:
                    case TokenType.Identifier:
                        // just output these token types
                        parsed = Parsed.True;
                        AppendCurrent();
                        NextToken();
                        break;

                    case TokenType.Space:
                        // ignore spaces
                        NextToken();
                        break;

                    case TokenType.Character:
                        if (CurrentTokenText == "+" || CurrentTokenText == "-")
                        {
                            parsed = Parsed.True;
                            AppendCurrent();
                            NextToken();
                        }
                        else
                        {
                            // anything else and we exit
                            return parsed;
                        }
                        break;

                    default:
                        // anything else and we bail
                        return parsed;
                }
            }
        }

        private Parsed ParseDeclaration()
        {
            Parsed parsed = Parsed.Empty;

            // see if the developer is using an IE hack of prefacing property names
            // with an asterisk -- IE seems to ignore it; other browsers will recognize
            // the invalid property name and ignore it.
            string prefix = null;
            if (CurrentTokenType == TokenType.Character 
                && (CurrentTokenText == "*" || CurrentTokenText == "."))
            {
                // spot a low-pri error because this is actually invalid CSS
                // taking advantage of an IE "feature"
                ReportError(4, CssErrorCode.HackGeneratesInvalidCss, CurrentTokenText);

                // save the prefix and skip it
                prefix = CurrentTokenText;
                NextToken();
            }

            if (CurrentTokenType == TokenType.Identifier)
            {
                // save the property name
                string propertyName = CurrentTokenText;

                // if this is an excluded property name, then set the no-output flag
                // so the declaration is not outputted (we'll always reset this flag at
                // the end of the function)
                if (Settings.ExcludeVendorPrefixes.Count > 0 && IsExcludedVendorPrefix(propertyName))
                {
                    m_noOutput = true;
                }

                NewLine();
                if (prefix != null)
                {
                    Append(prefix);
                }
                AppendCurrent();

                // we want to skip space BUT we want to preserve a space if there is a whitespace character
                // followed by a comment. So don't call the simple SkipSpace method -- that will output the
                // comment but ignore all whitespace.
                SkipSpaceComment();

                if (CurrentTokenType != TokenType.Character
                  || CurrentTokenText != ":")
                {
                    ReportError(0, CssErrorCode.ExpectedColon, CurrentTokenText);
                    SkipToEndOfDeclaration();
                    return Parsed.True;
                }
                Append(':');
                if (Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }
                SkipSpace();

                if (m_valueReplacement != null)
                {
                    // output the replacement string
                    Append(m_valueReplacement);

                    // clear the replacement string
                    m_valueReplacement = null;

                    // set the no-output flag, parse the value, the reset the flag.
                    // we don't care if it actually finds a value or not
                    var notOutputting = m_noOutput;
                    m_noOutput = true;
                    ParseExpr();
                    m_noOutput = notOutputting;
                }
                else 
                {
                    m_parsingColorValue = MightContainColorNames(propertyName);
                    parsed = ParseExpr();
                    m_parsingColorValue = false;

                    if (parsed != Parsed.True)
                    {
                        ReportError(0, CssErrorCode.ExpectedExpression, CurrentTokenText);
                        SkipToEndOfDeclaration();
                        return Parsed.True;
                    }
                }

                // optional
                ParsePrio();

                parsed = Parsed.True;
                m_noOutput = false;
            }
            return parsed;
        }

        private Parsed ParsePrio()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.ImportantSymbol)
            {
                // issue #21057 - do not trip space before !important keyword.
                if (m_skippedSpace)
                {
                    Append(' ');
                }

                AppendCurrent();
                SkipSpace();

                // a common IE7-and-below hack is to append another ! at the end of !important.
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == "!")
                {
                    ReportError(4, CssErrorCode.HackGeneratesInvalidCss, CurrentTokenText);
                    AppendCurrent();
                    SkipSpace();
                }

                parsed = Parsed.True;
            }
            else if (CurrentTokenType == TokenType.Character && CurrentTokenText == "!")
            {
                // another common IE7-and-below hack is to use an identifier OTHER than "important". All other browsers will see this
                // as an error, but IE7 and below will keep on processing. A common thing is to put !ie at the end to mark
                // the declaration as only for IE.
                if (Settings.OutputMode == OutputMode.MultipleLines)
                {
                    Append(' ');
                }

                AppendCurrent();
                NextToken();
                if (CurrentTokenType == TokenType.Identifier)
                {
                    ReportError(4, CssErrorCode.HackGeneratesInvalidCss, CurrentTokenText);

                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    // but we need SOME identifier here....
                    ReportError(0, CssErrorCode.ExpectedIdentifier, CurrentTokenText);
                }
            }
            return parsed;
        }

        private Parsed ParseExpr()
        {
            Parsed parsed = ParseTerm(false);
            if (parsed == Parsed.True)
            {
                while (!m_scanner.EndOfFile)
                {
                    Parsed parsedOp = ParseOperator();
                    if (parsedOp != Parsed.False)
                    {
                        if (ParseTerm(parsedOp == Parsed.Empty) == Parsed.False)
                        {
                            break;
                        }
                    }
                }
            }
            return parsed;
        }

        private Parsed ParseFunctionParameters()
        {
            Parsed parsed = ParseTerm(false);
            if (parsed == Parsed.True)
            {
                while (!m_scanner.EndOfFile)
                {
                    if (CurrentTokenType == TokenType.Character
                      && CurrentTokenText == "=")
                    {
                        AppendCurrent();
                        SkipSpace();
                        ParseTerm(false);
                    }

                    Parsed parsedOp = ParseOperator();
                    if (parsedOp != Parsed.False)
                    {
                        if (ParseTerm(parsedOp == Parsed.Empty) == Parsed.False)
                        {
                            break;
                        }
                    }
                }
            }
            else if (parsed == Parsed.False
              && CurrentTokenType == TokenType.Character
              && CurrentTokenText == ")")
            {
                // it's okay to have no parameters in functions
                parsed = Parsed.Empty;
            }
            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private Parsed ParseTerm(bool wasEmpty)
        {
            Parsed parsed = Parsed.False;
            bool hasUnary = false;
            if (CurrentTokenType == TokenType.Character
                && (CurrentTokenText == "-" || CurrentTokenText == "+"))
            {
                if (wasEmpty)
                {
                    if (m_skippedSpace)
                    {
                        Append(' ');
                    }

                    wasEmpty = false;
                }

                AppendCurrent();
                NextToken();
                hasUnary = true;
            }

            switch (CurrentTokenType)
            {
                case TokenType.Hash:
                    if (hasUnary)
                    {
                        ReportError(0, CssErrorCode.HashAfterUnaryNotAllowed, CurrentTokenText);
                    }

                    if (wasEmpty)
                    {
                        Append(' ');
                        wasEmpty = false;
                    }
                    if (ParseHexcolor() == Parsed.False)
                    {
                        ReportError(0, CssErrorCode.ExpectedHexColor, CurrentTokenText);

                        // we expected the hash token to be a proper color -- but it's not.
                        // we threw an error -- go ahead and output the token as-is and keep going.
                        AppendCurrent();
                        SkipSpace();
                    }
                    parsed = Parsed.True;
                    break;

                case TokenType.String:
                case TokenType.Identifier:
                case TokenType.Uri:
                //case TokenType.RGB:
                case TokenType.UnicodeRange:
                    if (hasUnary)
                    {
                        ReportError(0, CssErrorCode.TokenAfterUnaryNotAllowed, CurrentTokenText);
                    }

                    // wasEmpty will be false if we DIDN'T find an operator
                    // as the last token. If we had an operator, then we can ignore
                    // any whitespace; but if we DIDN'T find an operator, then we
                    // will need to preserve a whitespace character to keep them 
                    // separated.
                    if (wasEmpty)
                    {
                        // if we had skipped any space, then add one now
                        if (m_skippedSpace)
                        {
                            Append(' ');
                        }

                        wasEmpty = false;
                    }

                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                    break;

                case TokenType.Dimension:
                    ReportError(2, CssErrorCode.UnexpectedDimension, CurrentTokenText);
                    goto case TokenType.Number;

                case TokenType.Number:
                case TokenType.Percentage:
                case TokenType.AbsoluteLength:
                case TokenType.RelativeLength:
                case TokenType.Angle:
                case TokenType.Time:
                case TokenType.Frequency:
                case TokenType.Resolution:
                    if (wasEmpty)
                    {
                        Append(' ');
                        wasEmpty = false;
                    }

                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                    break;

                case TokenType.ProgId:
                    if (wasEmpty)
                    {
                        Append(' ');
                        wasEmpty = false;
                    }
                    if (ParseProgId() == Parsed.False)
                    {
                        ReportError(0, CssErrorCode.ExpectedProgId, CurrentTokenText);
                    }
                    parsed = Parsed.True;
                    break;

                case TokenType.Function:
                    if (wasEmpty)
                    {
                        Append(' ');
                        wasEmpty = false;
                    }
                    if (ParseFunction() == Parsed.False)
                    {
                        ReportError(0, CssErrorCode.ExpectedFunction, CurrentTokenText);
                    }
                    parsed = Parsed.True;
                    break;

                case TokenType.Character:
                    if (CurrentTokenText == "(")
                    {
                        // the term starts with an opening paren.
                        // parse an expression followed by the close paren.
                        if (wasEmpty)
                        {
                            if (m_skippedSpace)
                            {
                                Append(' ');
                            }

                            wasEmpty = false;
                        }

                        AppendCurrent();
                        SkipSpace();

                        if (ParseExpr() == Parsed.False)
                        {
                            ReportError(0, CssErrorCode.ExpectedExpression, CurrentTokenText);
                        }

                        if (CurrentTokenType == TokenType.Character
                            && CurrentTokenText == ")")
                        {
                            AppendCurrent();
                            parsed = Parsed.True;

                            // the closing paren can only be followed IMMEDIATELY by the opening brace
                            // without any space if it's a repeat syntax.
                            m_skippedSpace = false;
                            NextRawToken();
                            if (CurrentTokenType == TokenType.Space)
                            {
                                m_skippedSpace = true;
                            }

                            // if the next token is an opening brace, then this might be
                            // a repeat operator
                            if (CurrentTokenType == TokenType.Character
                                && CurrentTokenText == "[")
                            {
                                AppendCurrent();
                                SkipSpace();

                                if (CurrentTokenType == TokenType.Number)
                                {
                                    AppendCurrent();
                                    SkipSpace();

                                    if (CurrentTokenType == TokenType.Character
                                        && CurrentTokenText == "]")
                                    {
                                        AppendCurrent();
                                        SkipSpace();
                                    }
                                    else
                                    {
                                        ReportError(0, CssErrorCode.ExpectedClosingBracket, CurrentTokenText);
                                        parsed = Parsed.False;
                                    }
                                }
                                else
                                {
                                    ReportError(0, CssErrorCode.ExpectedNumber, CurrentTokenText);
                                    parsed = Parsed.False;
                                }
                            }
                        }
                        else
                        {
                            ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                        }
                    }
                    else if ( CurrentTokenText == "%")
                    {
                        // see if this is the start of a replacement token
                        UpdateIfReplacementToken();
                        if (CurrentTokenType == TokenType.ReplacementToken)
                        {
                            // it was -- output it and move along
                            if (wasEmpty)
                            {
                                Append(' ');
                                wasEmpty = false;
                            }

                            AppendCurrent();
                            SkipSpace();
                            parsed = Parsed.True;
                        }
                        else
                        {
                            // nope; just a percent. 
                            goto default;
                        }
                    }
                    else
                    {
                        goto default;
                    }
                    break;

                default:
                    if (hasUnary)
                    {
                        ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                    }
                    break;
            }
            return parsed;
        }

        private Parsed ParseProgId()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.ProgId)
            {
                ReportError(4, CssErrorCode.ProgIdIEOnly);

                // set the state flag that tells us we should NOT abbreviate color
                // hash values as we are parsing our parameters
                m_noColorAbbreviation = true;

                // comma-separated lists of progid expressions should have a space after
                // the comma, or IE will ignore all but the last
                if (m_lastOutputString == ",")
                {
                    Append(" ");
                }

                // append the progid and opening paren
                AppendCurrent();
                SkipSpace();

                // the rest is a series of parameters: name=value, separated
                // by commas and ending with a close paren
                while (CurrentTokenType == TokenType.Identifier)
                {
                    AppendCurrent();
                    SkipSpace();

                    if (CurrentTokenType != TokenType.Character
                      && CurrentTokenText != "=")
                    {
                        ReportError(0, CssErrorCode.ExpectedEqualSign, CurrentTokenText);
                    }

                    Append('=');
                    SkipSpace();

                    if (ParseTerm(false) != Parsed.True)
                    {
                        ReportError(0, CssErrorCode.ExpectedTerm, CurrentTokenText);
                    }

                    if (CurrentTokenType == TokenType.Character
                      && CurrentTokenText == ",")
                    {
                        Append(',');
                        SkipSpace();
                    }
                }

                // reset the color-abbreviation flag
                m_noColorAbbreviation = false;

                // make sure we're at the close paren
                if (CurrentTokenType == TokenType.Character
                  && CurrentTokenText == ")")
                {
                    Append(')');
                    SkipSpace();
                }
                else
                {
                    ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                }
                parsed = Parsed.True;
            }
            return parsed;
        }

        private static string GetRoot(string text)
        {
            if (text.StartsWith("-", StringComparison.Ordinal))
            {
                var match = s_vendorSpecific.Match(text);
                if (match.Success)
                {
                    text = match.Result("${root}");
                }
            }

            return text;
        }

        private Parsed ParseFunction()
        {
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Function)
            {
                var functionText = GetRoot(CurrentTokenText);
                switch (functionText.ToUpperInvariant())
                {
                    case "RGB(":
                        parsed = ParseRgb();
                        break;

                    case "EXPRESSION(":
                        parsed = ParseExpressionFunction();
                        break;

                    case "CALC(":
                        parsed = ParseCalc();
                        break;

                    case "MIN(":
                    case "MAX(":
                        parsed = ParseMinMax();
                        break;

                    default:
                        // generic function parsing
                        AppendCurrent();
                        SkipSpace();

                        if (ParseFunctionParameters() == Parsed.False)
                        {
                            ReportError(0, CssErrorCode.ExpectedExpression, CurrentTokenText);
                        }

                        if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                        {
                            AppendCurrent();
                            SkipSpace();
                            parsed = Parsed.True;
                        }
                        else
                        {
                            ReportError(0, CssErrorCode.UnexpectedToken, CurrentTokenText);
                        }
                        break;
                }
            }
            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "we want lower-case output")]
        private Parsed ParseRgb()
        {
            var parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Function
                && string.Compare(CurrentTokenText, "rgb(", StringComparison.OrdinalIgnoreCase) == 0)
            {
                // rgb function parsing
                var useRGB = false;
                var crunchedRGB = false;
                // converting to #rrggbb or #rgb IF we don't find any significant comments!
                // skip any space or comments
                var rgb = new int[3];

                // we're going to be building up the rgb function just in case we need it
                var sbRGB = StringBuilderPool.Acquire();
                try
                {
                    sbRGB.Append(CurrentTokenText.ToLowerInvariant());

                    var comments = NextSignificantToken();
                    if (comments.Length > 0)
                    {
                        // add the comments
                        sbRGB.Append(comments);
                        // and signal that we need to use the RGB function because of them
                        useRGB = true;
                    }

                    for (var ndx = 0; ndx < 3; ++ndx)
                    {
                        // if this isn't the first number, we better find a comma separator
                        if (ndx > 0)
                        {
                            if (CurrentTokenType == TokenType.Character && CurrentTokenText == ",")
                            {
                                // add it to the rgb string builder
                                sbRGB.Append(',');
                            }
                            else if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                            {
                                ReportError(0, CssErrorCode.ExpectedComma, CurrentTokenText);

                                // closing paren is the end of the function! exit the loop
                                useRGB = true;
                                break;
                            }
                            else
                            {
                                ReportError(0, CssErrorCode.ExpectedComma, CurrentTokenText);
                                sbRGB.Append(CurrentTokenText);
                                useRGB = true;
                            }

                            // skip to the next significant
                            comments = NextSignificantToken();
                            if (comments.Length > 0)
                            {
                                // add the comments
                                sbRGB.Append(comments);
                                // and signal that we need to use the RGB function because of them
                                useRGB = true;
                            }
                        }

                        // although we ALLOW negative numbers here, we'll trim them
                        // later. But in the mean time, save a negation flag.
                        var negateNumber = false;
                        if (CurrentTokenType == TokenType.Character && CurrentTokenText == "-")
                        {
                            negateNumber = true;
                            comments = NextSignificantToken();
                            if (comments.Length > 0)
                            {
                                // add the comments
                                sbRGB.Append(comments);
                                // and signal that we need to use the RGB function because of them
                                useRGB = true;
                            }
                        }

                        // we might adjust the value, so save the token text
                        var tokenText = CurrentTokenText;

                        if (CurrentTokenType != TokenType.Number && CurrentTokenType != TokenType.Percentage)
                        {
                            ReportError(0, CssErrorCode.ExpectedRgbNumberOrPercentage, CurrentTokenText);
                            useRGB = true;
                        }
                        else
                        {
                            if (CurrentTokenType == TokenType.Number)
                            {
                                // get the number value
                                float numberValue;
                                if (tokenText.TryParseSingleInvariant(out numberValue))
                                {
                                    numberValue *= (negateNumber ? -1 : 1);
                                    // make sure it's between 0 and 255
                                    if (numberValue < 0)
                                    {
                                        tokenText = "0";
                                        rgb[ndx] = 0;
                                    }
                                    else if (numberValue > 255)
                                    {
                                        tokenText = "255";
                                        rgb[ndx] = 255;
                                    }
                                    else
                                    {
                                        rgb[ndx] = System.Convert.ToInt32(numberValue);
                                    }
                                }
                                else
                                {
                                    // error -- not even a number. Keep the rgb function
                                    // (and don't change the token)
                                    useRGB = true;
                                }
                            }
                            else
                            {
                                // percentage
                                float percentageValue;
                                if (tokenText.Substring(0, tokenText.Length - 1).TryParseSingleInvariant(out percentageValue))
                                {
                                    percentageValue *= (negateNumber ? -1 : 1);
                                    if (percentageValue < 0)
                                    {
                                        tokenText = "0%";
                                        rgb[ndx] = 0;
                                    }
                                    else if (percentageValue > 100)
                                    {
                                        tokenText = "100%";
                                        rgb[ndx] = 255;
                                    }
                                    else
                                    {
                                        rgb[ndx] = System.Convert.ToInt32(percentageValue * 255 / 100);
                                    }
                                }
                                else
                                {
                                    // error -- not even a number. Keep the rgb function
                                    // (and don't change the token)
                                    useRGB = true;
                                }
                            }
                        }

                        // add the number to the rgb string builder
                        sbRGB.Append(tokenText);

                        // skip to the next significant
                        comments = NextSignificantToken();
                        if (comments.Length > 0)
                        {
                            // add the comments
                            sbRGB.Append(comments);
                            // and signal that we need to use the RGB function because of them
                            useRGB = true;
                        }
                    }

                    if (useRGB)
                    {
                        // something prevented us from collapsing the rgb function
                        // just output the rgb function we've been building up
                        Append(sbRGB.ToString());
                    }
                    else
                    {
                        // we can collapse it to either #rrggbb or #rgb
                        // calculate the full hex string and crunch it
                        var fullCode = "#{0:x2}{1:x2}{2:x2}".FormatInvariant(rgb[0], rgb[1], rgb[2]);
                        var hexString = CrunchHexColor(fullCode, Settings.ColorNames, m_noColorAbbreviation);
                        Append(hexString);

                        // set the flag so we know we don't want to add the closing paren
                        crunchedRGB = true;
                    }
                }
                finally
                {
                    sbRGB.Release();
                }

                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {
                    if (!crunchedRGB)
                    {
                        AppendCurrent();
                    }

                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                }
            }

            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "we want lower-case output")]
        private Parsed ParseExpressionFunction()
        {
            var parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Function
                && string.Compare(CurrentTokenText, "expression(", StringComparison.OrdinalIgnoreCase) == 0)
            {
                Append(CurrentTokenText.ToLowerInvariant());
                NextToken();

                // for now, just echo out everything up to the matching closing paren, 
                // taking into account that there will probably be other nested paren pairs. 
                // The content of the expression is JavaScript, so we'd really
                // need a full-blown JS-parser to crunch it properly. Kinda scary.
                // Start the parenLevel at 0 because the "expression(" token contains the first paren.
                string expressionCode = null;
                var jsBuilder = StringBuilderPool.Acquire();
                try
                {
                    int parenLevel = 0;

                    while (!m_scanner.EndOfFile
                      && (CurrentTokenType != TokenType.Character
                        || CurrentTokenText != ")"
                        || parenLevel > 0))
                    {
                        if (CurrentTokenType == TokenType.Function)
                        {
                            // the function token INCLUDES the opening parenthesis,
                            // so up the paren level whenever we find a function.
                            // AND this includes the actual expression( token -- so we'll
                            // hit this branch at the beginning. Make sure the parenLevel
                            // is initialized to take that into account
                            ++parenLevel;
                        }
                        else if (CurrentTokenType == TokenType.Character)
                        {
                            switch (CurrentTokenText)
                            {
                                case "(":
                                    // start a nested paren
                                    ++parenLevel;
                                    break;

                                case ")":
                                    // end a nested paren 
                                    // (we know it's nested because if it wasn't, we wouldn't
                                    // have entered the loop)
                                    --parenLevel;
                                    break;
                            }
                        }
                        jsBuilder.Append(CurrentTokenText);
                        NextToken();
                    }

                    // create a JSParser object with the source we found, crunch it, and send 
                    // the minified script to the output
                    expressionCode = jsBuilder.ToString();
                }
                finally
                {
                    jsBuilder.Release();
                }

                if (Settings.MinifyExpressions)
                {
                    // we want to minify the javascript expressions
                    JSParser jsParser = new JSParser();

                    // hook the error handler and set the "contains errors" flag to false.
                    // the handler will set the value to true if it encounters any errors
                    var containsErrors = false;
                    jsParser.CompilerError += (sender, ea) =>
                    {
                        ReportError(0, CssErrorCode.ExpressionError, ea.Error.Message);
                        containsErrors = true;
                    };

                    // parse the source as an expression using our common JS settings
                    var block = jsParser.Parse(new DocumentContext(expressionCode) { FileContext = this.FileContext }, m_jsSettings);

                    // if we got back a parsed block and there were no errors, output the minified code.
                    // if we didn't get back the block, or if there were any errors at all, just output
                    // the raw expression source.
                    if (block != null && !containsErrors)
                    {
                        Append(OutputVisitor.Apply(block, jsParser.Settings));
                    }
                    else
                    {
                        Append(expressionCode);
                    }
                }
                else
                {
                    // we don't want to minify expression code for some reason.
                    // just output the code exactly as we parsed it
                    Append(expressionCode);
                }

                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {
                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                }
            }

            return parsed;
        }

        private Parsed ParseHexcolor()
        {
            Parsed parsed = Parsed.False;

            if (CurrentTokenType == TokenType.Hash)
            {
                var colorHash = CurrentTokenText;
                var appendEscapedTab = false;

                // valid hash colors are #rgb, #rrggbb, and #aarrggbb.
                // but there is a commonly-used IE hack that puts \9 at the end of properties, so
                // if we have 5, 8, or 10 characters, let's first check to see if the color
                // ends in a tab.
                if ((colorHash.Length == 5 || colorHash.Length == 8 || colorHash.Length == 10)
                    && colorHash.EndsWith("\t", StringComparison.Ordinal))
                {
                    // it is -- strip that last character and set a flag
                    colorHash = colorHash.Substring(0, colorHash.Length - 1);
                    appendEscapedTab = true;
                }

                if (colorHash.Length == 4 || colorHash.Length == 7 || colorHash.Length == 9)
                {
                    parsed = Parsed.True;

                    // we won't do any conversion on the #aarrggbb formats to make them smaller.
                    string hexColor = CrunchHexColor(colorHash, Settings.ColorNames, m_noColorAbbreviation);
                    Append(hexColor);

                    if (appendEscapedTab)
                    {
                        Append("\\9");
                    }

                    SkipSpace();
                }
            }
            return parsed;
        }

        private Parsed ParseUnit()
        {
            var parsed = Parsed.Empty;

            // optional sign
            if (CurrentTokenType == TokenType.Character
                && (CurrentTokenText == "+" || CurrentTokenText == "-"))
            {
                AppendCurrent();
                NextToken();

                // set the parsed flag to false -- if we don't get a valid token
                // next and set it to true, then we know we had an error
                parsed = Parsed.False;
            }

            // followed by a number, a percentage, a dimension, a min(, a max(, or a parenthesized sum
            switch (CurrentTokenType)
            {
                case TokenType.Number:
                case TokenType.Percentage:
                case TokenType.Dimension:
                case TokenType.RelativeLength:
                case TokenType.AbsoluteLength:
                case TokenType.Angle:
                case TokenType.Time:
                case TokenType.Resolution:
                case TokenType.Frequency:
                    // output it, skip any whitespace, and mark us as okay
                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                    break;

                case TokenType.Function:
                    // calc( or attr( are allowed here.
                    parsed = ParseFunction();

                    // if parsed is false, then we encountered an error with the function
                    // and probably already output an error message. So only output an error
                    // message if we didn't find ANYTHING
                    if (parsed == Parsed.Empty)
                    {
                        ReportError(0, CssErrorCode.UnexpectedFunction, CurrentTokenText);
                        parsed = Parsed.False;
                    }
                    break;

                case TokenType.Character:
                    // only open parenthesis allowed
                    if (CurrentTokenText == "(")
                    {
                        // TODO: make sure there is whitespace before the ( if it would cause
                        // it to be the opening paren of a function token

                        AppendCurrent();
                        SkipSpace();

                        // better be a sum inside the parens
                        parsed = ParseSum();
                        if (parsed != Parsed.True)
                        {
                            // report error and change the parsed flag to false so we know there was an error
                            ReportError(0, CssErrorCode.ExpectedSum, CurrentTokenText);
                            parsed = Parsed.False;
                        }
                        else if (CurrentTokenType != TokenType.Character || CurrentTokenText != ")")
                        {
                            // needs to be a closing paren here
                            ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                            parsed = Parsed.False;
                        }
                        else
                        {
                            // we're at the closing paren, so output it now, advance past any
                            // subsequent whitespace, and mark us as okay
                            AppendCurrent();
                            SkipSpace();
                            parsed = Parsed.True;
                        }
                    }
                    break;
            }

            return parsed;
        }

        private Parsed ParseProduct()
        {
            // there needs to be at least one unit here
            var parsed = ParseUnit();
            if (parsed == Parsed.True)
            {
                // keep going while we have product operators
                // "mod" isn't a final operator, but it was in earlier drafts so keep allowing it.
                while ((CurrentTokenType == TokenType.Character && (CurrentTokenText == "*" || CurrentTokenText == "/"))
                    || (CurrentTokenType == TokenType.Identifier && string.Compare(CurrentTokenText, "mod", StringComparison.OrdinalIgnoreCase) == 0))
                {
                    if (CurrentTokenText == "*" || CurrentTokenText == "/")
                    {
                        // multiplication and dicision operators don't need spaces around them
                        // UNLESS we are outputting multi-line mode
                        if (Settings.OutputMode == OutputMode.MultipleLines)
                        {
                            Append(' ');
                        }

                        AppendCurrent();
                        if (Settings.OutputMode == OutputMode.MultipleLines)
                        {
                            Append(' ');
                        }
                    }
                    else
                    {
                        // the mod-operator usually needs space around it.
                        // and keep it lower-case.
                        Append(" mod ");
                    }

                    // skip any whitespace
                    SkipSpace();

                    // grab the next unit -- and there better be one
                    // technically the candidate spec says / can only be followed by NUMBER, not a UNIT, but
                    // let's let this slide and just parse a unit for both.
                    parsed = ParseUnit();
                    if (parsed != Parsed.True)
                    {
                        ReportError(0, CssErrorCode.ExpectedUnit, CurrentTokenText);
                        parsed = Parsed.False;
                    }
                }
            }
            else
            {
                // report an error and make sure we return false
                ReportError(0, CssErrorCode.ExpectedUnit, CurrentTokenText);
                parsed = Parsed.False;
            }

            return parsed;
        }

        private Parsed ParseSum()
        {
            // there needs to be at least one product here
            var parsed = ParseProduct();
            if (parsed == Parsed.True)
            {
                // keep going while we have sum operators
                while (CurrentTokenType == TokenType.Character && (CurrentTokenText == "+" || CurrentTokenText == "-"))
                {
                    // plus and minus operators need space around them.
                    Append(' ');
                    AppendCurrent();

                    // plus and minus operators both need spaces after them.
                    // the minus needs to not be an identifier.
                    Append(' ');

                    SkipSpace();

                    // grab the next product -- and there better be one
                    parsed = ParseProduct();
                    if (parsed != Parsed.True)
                    {
                        ReportError(0, CssErrorCode.ExpectedProduct, CurrentTokenText);
                        parsed = Parsed.False;
                    }
                }
            }
            else
            {
                // report an error and make sure we return false
                ReportError(0, CssErrorCode.ExpectedProduct, CurrentTokenText);
                parsed = Parsed.False;
            }

            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification="we want lower-case output")]
        private Parsed ParseMinMax()
        {
            // return false if the function isn't min or max
            Parsed parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Function
                && (string.Compare(CurrentTokenText, "min(", StringComparison.OrdinalIgnoreCase) == 0
                || string.Compare(CurrentTokenText, "max(", StringComparison.OrdinalIgnoreCase) == 0))
            {
                // output lower-case version and skip any space
                Append(CurrentTokenText.ToLowerInvariant());
                SkipSpace();

                // must be at least one sum
                parsed = ParseSum();

                // comma-delimited sums continue
                while (parsed == Parsed.True
                    && CurrentTokenType == TokenType.Character
                    && CurrentTokenText == ",")
                {
                    AppendCurrent();
                    SkipSpace();

                    parsed = ParseSum();
                }

                // end with the closing paren
                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {
                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                    parsed = Parsed.False;
                }
            }

            return parsed;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "we want lower-case output")]
        private Parsed ParseCalc()
        {
            var parsed = Parsed.False;
            if (CurrentTokenType == TokenType.Function
                && string.Compare(GetRoot(CurrentTokenText), "calc(", StringComparison.OrdinalIgnoreCase) == 0)
            {
                Append(CurrentTokenText.ToLowerInvariant());
                SkipSpace();

                // contains one sum
                if (ParseSum() != Parsed.True)
                {
                    ReportError(0, CssErrorCode.ExpectedSum, CurrentTokenText);
                }

                if (CurrentTokenType == TokenType.Character && CurrentTokenText == ")")
                {
                    AppendCurrent();
                    SkipSpace();
                    parsed = Parsed.True;
                }
                else
                {
                    ReportError(0, CssErrorCode.ExpectedClosingParenthesis, CurrentTokenText);
                }
            }

            return parsed;
        }

        #endregion

        #region Next... methods

        // skip to the next token, but output any comments we may find as we go along
        private TokenType NextToken()
        {
            m_currentToken = m_scanner.NextToken();
            EchoWriter?.Write(CurrentTokenText);

            m_encounteredNewLine = m_scanner.GotEndOfLine;
            while (CurrentTokenType == TokenType.Comment)
            {
                // the append statement might not actually append anything.
                // if it doesn't, we don't need to output a newline
                if (AppendCurrent())
                {
                    NewLine();
                }
                m_currentToken = m_scanner.NextToken();
                EchoWriter?.Write(CurrentTokenText);

                m_encounteredNewLine = m_encounteredNewLine || m_scanner.GotEndOfLine;
            }
            return CurrentTokenType;
        }

        // just skip to the next token; don't skip over comments
        private TokenType NextRawToken()
        {
            m_currentToken = m_scanner.NextToken();
            EchoWriter?.Write(CurrentTokenText);

            m_encounteredNewLine = m_scanner.GotEndOfLine;
            return CurrentTokenType;
        }

        private string NextSignificantToken()
        {
            // MOST of the time we won't need to save anything,
            // so don't bother allocating a string builder unless we need it
            string text = null;
            StringBuilder sb = null;
            try
            {
                // get the next token
                m_currentToken = m_scanner.NextToken();
                EchoWriter?.Write(CurrentTokenText);

                m_encounteredNewLine = m_scanner.GotEndOfLine;
                while (CurrentTokenType == TokenType.Space || CurrentTokenType == TokenType.Comment)
                {
                    // if this token is a comment, add it to the builder
                    if (CurrentTokenType == TokenType.Comment)
                    {
                        // check for important comment
                        string commentText = CurrentTokenText;
                        bool importantComment = commentText.StartsWith("/*!", StringComparison.Ordinal);
                        if (importantComment)
                        {
                            // get rid of the exclamation mark in some situations
                            commentText = NormalizeImportantComment(commentText);
                        }

                        // if the comment mode is none, don't ever output it.
                        // if the comment mode is all, always output it.
                        // otherwise only output it if it is an important comment.
                        bool writeComment = Settings.CommentMode == CssComment.All
                            || (importantComment && Settings.CommentMode != CssComment.None);

                        if (!importantComment)
                        {
                            if (s_sharepointReplacement.IsMatch(commentText))
                            {
                                // we ALWAYS want to output sharepoint styling comments
                                // (unless settings say NO comments)
                                writeComment = Settings.CommentMode != CssComment.None;
                            }
                            else
                            {
                                // see if this is a value-replacement id
                                Match match = s_valueReplacement.Match(commentText);
                                if (match.Success)
                                {
                                    // check all the resource strings objects to see if one is a match.
                                    m_valueReplacement = null;

                                    var resourceList = Settings.ResourceStrings;
                                    if (resourceList.Count > 0)
                                    {
                                        // get the id of the string we want to substitute
                                        string ident = match.Result("${id}");

                                        // walk the list BACKWARDS so later resource string objects override previous ones
                                        for (var ndx = resourceList.Count - 1; ndx >= 0; --ndx)
                                        {
                                            m_valueReplacement = resourceList[ndx][ident];
                                            if (m_valueReplacement != null)
                                            {
                                                break;
                                            }
                                        }
                                    }

                                    // if there is such a string, we will have saved the value in the value replacement
                                    // variable so it will be substituted for the next value.
                                    // if there is no such string, we ALWAYS want to output the comment so we know 
                                    // there was a problem (even if the comments mode is to output none)
                                    writeComment = m_valueReplacement == null;
                                    if (writeComment)
                                    {
                                        // make sure the comment is normalized
                                        commentText = NormalizedValueReplacementComment(commentText);
                                    }
                                }
                            }
                        }

                        if (writeComment)
                        {
                            // if we haven't yet allocated a string builder, do it now
                            if (sb == null)
                            {
                                sb = StringBuilderPool.Acquire();
                            }

                            // add the comment to the builder
                            sb.Append(commentText);
                        }
                    }

                    // next token
                    m_currentToken = m_scanner.NextToken();
                    EchoWriter?.Write(CurrentTokenText);

                    m_encounteredNewLine = m_encounteredNewLine || m_scanner.GotEndOfLine;
                }

                text = sb == null ? string.Empty : sb.ToString();
            }
            finally
            {
                sb.Release();
            }

            // return any comments we found in the mean time
            return text;
        }

        private void UpdateIfReplacementToken()
        {
            m_currentToken = m_scanner.ScanReplacementToken() ?? m_currentToken;
        }

        #endregion

        #region Skip... methods

        /// <summary>
        /// This method advances to the next token FIRST -- effectively skipping the current one -- 
        /// and then skips any space tokens that FOLLOW it.
        /// </summary>
        private void SkipSpace()
        {
            // reset the skipped-space flag
            m_skippedSpace = false;

            // move to the next token
            NextToken();

            // we need to collate this flag for this method call
            var encounteredNewLine = m_encounteredNewLine;

            // while space, keep stepping
            while (CurrentTokenType == TokenType.Space)
            {
                m_skippedSpace = true;
                NextToken();
                encounteredNewLine = encounteredNewLine || m_encounteredNewLine;
            }

            m_encounteredNewLine = encounteredNewLine;
        }

        private void SkipSpaceComment()
        {
            // reset the skipped-space flag
            m_skippedSpace = false;

            // move to the next token
            if (NextRawToken() == TokenType.Space)
            {
                // starts with whitespace! If the next token is a comment, we want to make sure that
                // whitespace is preserved. Keep going until we find something that isn't a space
                m_skippedSpace = true;
                var encounteredNewLine = m_encounteredNewLine;
                while (NextRawToken() == TokenType.Space)
                {
                    // iteration is in the condition
                    encounteredNewLine = encounteredNewLine || m_encounteredNewLine;
                }

                // now, if the first thing after space is a comment....
                if (CurrentTokenType == TokenType.Comment)
                {
                    // preserve the space character IF we're going to keep the comment.
                    // SO, if the comment mode is ALL, or if this is an important comment,
                    // (if the comment mode is hacks, then this comment will probably have already
                    // been changed into an important comment), then we output the space
                    // and the comment (don't bother outputting the comment if we already know we
                    // aren't going to)
                    if (Settings.CommentMode == CssComment.All
                        || CurrentTokenText.StartsWith("/*!", StringComparison.Ordinal))
                    {
                        Append(' ');

                        // output the comment
                        AppendCurrent();
                    }

                    // and do normal skip-space logic
                    SkipSpace();
                    encounteredNewLine = encounteredNewLine || m_encounteredNewLine;
                }

                m_encounteredNewLine = encounteredNewLine;
            }
            else if (CurrentTokenType == TokenType.Comment)
            {
                // doesn't start with whitespace.
                // append the comment and then do the normal skip-space logic
                var encounteredNewLine = m_encounteredNewLine;
                AppendCurrent();
                SkipSpace();
                m_encounteredNewLine = m_encounteredNewLine || encounteredNewLine;
            }
        }

        /// <summary>
        /// This method only skips the space that is already the current token.
        /// </summary>
        /// <returns>true if space was skipped; false if the current token is not space</returns>
        private bool SkipIfSpace()
        {
            // reset the skipped-space flag
            m_skippedSpace = false;

            bool tokenIsSpace = CurrentTokenType == TokenType.Space;
            var encounteredNewLine = m_encounteredNewLine;
            // while space, keep stepping
            while (CurrentTokenType == TokenType.Space)
            {
                m_skippedSpace = true;
                NextToken();
                encounteredNewLine = encounteredNewLine || m_encounteredNewLine;
            }

            m_encounteredNewLine = encounteredNewLine;
            return tokenIsSpace;
        }

        private void SkipToEndOfStatement()
        {
            bool possibleSpace = false;
            // skip to next semicolon or next block
            // AND honor opening/closing pairs of (), [], and {}
            while (!m_scanner.EndOfFile
                && (CurrentTokenType != TokenType.Character || CurrentTokenText != ";"))
            {
                // if the token is one of the characters we need to match closing characters...
                if (CurrentTokenType == TokenType.Character
                    && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{"))
                {
                    // see if this is this a block -- if so, we'll bail when we're done
                    bool isBlock = (CurrentTokenText == "{");

                    SkipToClose();

                    // if that was a block, bail now
                    if (isBlock)
                    {
                        return;
                    }
                    possibleSpace = false;
                }
                if (CurrentTokenType == TokenType.Space)
                {
                    possibleSpace = true;
                }
                else
                {
                    if (possibleSpace && NeedsSpaceBefore(CurrentTokenText)
                        && NeedsSpaceAfter(m_lastOutputString))
                    {
                        Append(' ');
                    }
                    AppendCurrent();
                    possibleSpace = false;
                }
                NextToken();
            }
        }

        private void SkipToEndOfDeclaration()
        {
            bool possibleSpace = false;
            // skip to end of declaration: ; or }
            // BUT honor opening/closing pairs of (), [], and {}
            while (!m_scanner.EndOfFile
                && (CurrentTokenType != TokenType.Character
                  || (CurrentTokenText != ";" && CurrentTokenText != "}")))
            {
                // if the token is one of the characters we need to match closing characters...
                if (CurrentTokenType == TokenType.Character
                    && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{"))
                {
                    if (possibleSpace)
                    {
                        Append(' ');
                    }

                    SkipToClose();
                    possibleSpace = false;
                }

                if (CurrentTokenType == TokenType.Space)
                {
                    possibleSpace = true;
                }
                else
                {
                    if (possibleSpace && NeedsSpaceBefore(CurrentTokenText)
                        && NeedsSpaceAfter(m_lastOutputString))
                    {
                        Append(' ');
                    }

                    AppendCurrent();
                    possibleSpace = false;
                }

                m_skippedSpace = false;
                NextToken();
                if (CurrentTokenType == TokenType.Space)
                {
                    m_skippedSpace = true;
                }
            }

            // make sure we reset this flag
            m_noOutput = false;
        }

        private void SkipToClose()
        {
            bool possibleSpace = false;
            string closingText;
            switch (CurrentTokenText)
            {
                case "(":
                    closingText = ")";
                    break;

                case "[":
                    closingText = "]";
                    break;

                case "{":
                    closingText = "}";
                    break;

                default:
                    throw new ArgumentException("invalid closing match");
            }

            if (m_skippedSpace && CurrentTokenText != "{")
            {
                Append(' ');
            }

            AppendCurrent();

            m_skippedSpace = false;
            NextToken();
            if (CurrentTokenType == TokenType.Space)
            {
                m_skippedSpace = true;
            }

            while (!m_scanner.EndOfFile
                && (CurrentTokenType != TokenType.Character || CurrentTokenText != closingText))
            {
                // if the token is one of the characters we need to match closing characters...
                if (CurrentTokenType == TokenType.Character
                    && (CurrentTokenText == "(" || CurrentTokenText == "[" || CurrentTokenText == "{"))
                {
                    SkipToClose();
                    possibleSpace = false;
                }

                if (CurrentTokenType == TokenType.Space)
                {
                    possibleSpace = true;
                }
                else
                {
                    if (possibleSpace && NeedsSpaceBefore(CurrentTokenText)
                        && NeedsSpaceAfter(m_lastOutputString))
                    {
                        Append(' ');
                    }

                    AppendCurrent();
                    possibleSpace = false;
                }

                m_skippedSpace = false;
                NextToken();
                if (CurrentTokenType == TokenType.Space)
                {
                    m_skippedSpace = true;
                }
            }
        }

        private void SkipSemicolons()
        {
            while (CurrentTokenType == TokenType.Character && CurrentTokenText == ";")
            {
                NextToken();
            }
        }

        private static bool NeedsSpaceBefore(string text)
        {
            return text == null ? false : !("{}()[],;".Contains(text));
        }

        private static bool NeedsSpaceAfter(string text)
        {
            return text == null ? false : !("{}()[],;:".Contains(text));
        }

        #endregion

        #region output methods

        private bool AppendCurrent()
        {
            return Append(
                CurrentTokenText, 
                CurrentTokenType);
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity"),
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode"),
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase")]
        private bool Append(object obj, TokenType tokenType)
        {
            bool outputText = false;
            bool textEndsInEscapeSequence = false;

            // if the no-output flag is true, don't output anything
            // or process value replacement comments
            if (!m_noOutput)
            {
                var parsed = m_builders.Peek();
                var text = obj.ToString();

                // first if there are replacement tokens in the settings, then we'll want to
                // replace any tokens with the appropriate replacement values
                if (Settings.ReplacementTokens.Count > 0)
                {
                    text = CommonData.ReplacementToken.Replace(text, GetReplacementValue);
                }

                if (tokenType == TokenType.Identifier || tokenType == TokenType.Dimension)
                {
                    // need to make sure invalid identifier characters are properly escaped
                    StringBuilder escapedBuilder = null;
                    try
                    {
                        var startIndex = 0;
                        var protectNextHexCharacter = false;
                        var firstIndex = 0;

                        // if the token type is an identifier, we need to make sure the first character
                        // is a proper identifier start, or is escaped. But if it's a dimension, the first
                        // character will be a numeric digit -- which wouldn't be a valid identifier. So
                        // for dimensions, skip the first character -- subsequent numeric characters will
                        // be okay.
                        if (tokenType == TokenType.Identifier)
                        {
                            // for identifiers, if the first character is a hyphen or an underscore, then it's a prefix
                            // and we want to look at the next character for nmstart.
                            firstIndex = text[0] == '_' || text[0] == '-' ? 1 : 0;

                            var isCssVariable = text.StartsWith("--") && text.Length >= 3;
                            if (isCssVariable)
                            {
                                firstIndex = 2;
                            }
                            
                            if (firstIndex < text.Length)
                            {
                                // the only valid non-escaped first characters are A-Z (and a-z)
                                var firstChar = text[firstIndex];

                                // anything at or above 0x80 is okay for identifiers
                                if (firstChar < 0x80)
                                {
                                    // if it's not an a-z or A-Z, we want to escape it
                                    // also leave literal back-slashes as-is, too. The identifier might start with an escape
                                    // sequence that we didn't decode to its Unicode character for whatever reason.
                                    if ((firstChar < 'A' || 'Z' < firstChar)
                                        && (firstChar < 'a' || 'z' < firstChar)
                                        && firstChar != '\\')
                                    {
                                        // invalid first character -- create the string builder
                                        escapedBuilder = StringBuilderPool.Acquire();

                                        // if we had a prefix, output it
                                        if (firstIndex > 0)
                                        {
                                            escapedBuilder.Append(text[0]);
                                        }

                                        // output the escaped first character
                                        protectNextHexCharacter = EscapeCharacter(escapedBuilder, text[firstIndex]);
                                        textEndsInEscapeSequence = true;
                                        startIndex = firstIndex + 1;
                                    }
                                }
                            }
                        }
                        else
                        {
                            // for dimensions, we want to skip over the numeric part. So any sign, then decimal
                            // digits, then a decimal point (period), then decimal digits. The rest will be the identifier
                            // part that we want to escape.
                            if (text[0] == '+' || text[0] == '-')
                            {
                                ++firstIndex;
                            }

                            while ('0' <= text[firstIndex] && text[firstIndex] <= '9')
                            {
                                ++firstIndex;
                            }

                            if (text[firstIndex] == '.')
                            {
                                ++firstIndex;
                            }

                            while ('0' <= text[firstIndex] && text[firstIndex] <= '9')
                            {
                                ++firstIndex;
                            }

                            // since we start at the first character AFTER firstIndex, subtract
                            // one so we get back to the first character that isn't a part of
                            // the number portion
                            --firstIndex;
                        }

                        // loop through remaining characters, escaping any invalid nmchar characters
                        for (var ndx = firstIndex + 1; ndx < text.Length; ++ndx)
                        {
                            char nextChar = text[ndx];

                            // anything at or above 0x80, then it's okay and doesnt need to be escaped
                            if (nextChar < 0x80)
                            {
                                // only -, _, 0-9, a-z, A-Z are allowed without escapes
                                // but we also want to NOT escape \ or space characters. If the identifier had
                                // an escaped space character, it will still be escaped -- so any spaces would
                                // be necessary whitespace for the end of unicode escapes.
                                if (nextChar == '\\')
                                {
                                    // escape characters cause the next character -- no matter what it is -- to
                                    // be part of the escape and not escaped itself. Even if this is part of a
                                    // unicode or character escape, this will hold true. Increment the index and
                                    // loop around again so that we skip over both the backslash and the following
                                    // character.
                                    ++ndx;
                                }
                                else if (nextChar != '-'
                                    && nextChar != '_'
                                    && nextChar != ' '
                                    && ('0' > nextChar || nextChar > '9')
                                    && ('a' > nextChar || nextChar > 'z')
                                    && ('A' > nextChar || nextChar > 'Z'))
                                {
                                    // need to escape this character -- create the builder if we haven't already
                                    if (escapedBuilder == null)
                                    {
                                        escapedBuilder = StringBuilderPool.Acquire();
                                    }

                                    // output any okay characters we have so far
                                    if (startIndex < ndx)
                                    {
                                        // if the first character of the unescaped string is a valid hex digit,
                                        // then we need to add a space so that characer doesn't get parsed as a
                                        // digit in the previous escaped sequence.
                                        // and if the first character is a space, we need to protect it from the
                                        // previous escaped sequence with another space, too.
                                        string unescapedSubstring = text.Substring(startIndex, ndx - startIndex);
                                        if ((protectNextHexCharacter && CssScanner.IsH(unescapedSubstring[0]))
                                            || (textEndsInEscapeSequence && unescapedSubstring[0] == ' '))
                                        {
                                            escapedBuilder.Append(' ');
                                        }

                                        escapedBuilder.Append(unescapedSubstring);
                                    }

                                    // output the escape sequence for the current character
                                    protectNextHexCharacter = EscapeCharacter(escapedBuilder, text[ndx]);
                                    textEndsInEscapeSequence = true;

                                    // update the start pointer to the next character
                                    startIndex = ndx + 1;
                                }
                            }
                        }

                        // if we escaped anything, get the text from what we built
                        if (escapedBuilder != null)
                        {
                            // append whatever is left over
                            if (startIndex < text.Length)
                            {
                                // if the first character of the unescaped string is a valid hex digit,
                                // then we need to add a space so that characer doesn't get parsed as a
                                // digit in the previous escaped sequence.
                                // same for spaces! a trailing space will be part of the escape, so if we need
                                // a real space to follow, need to make sure there are TWO.
                                string unescapedSubstring = text.Substring(startIndex);
                                if ((protectNextHexCharacter && CssScanner.IsH(unescapedSubstring[0]))
                                    || unescapedSubstring[0] == ' ')
                                {
                                    escapedBuilder.Append(' ');
                                }

                                escapedBuilder.Append(unescapedSubstring);
                                textEndsInEscapeSequence = false;
                            }

                            // get the full string
                            text = escapedBuilder.ToString();
                        }
                    }
                    finally
                    {
                        escapedBuilder.Release();
                    }
                }
                else if (tokenType == TokenType.String)
                {
                    // we need to make sure that control codes are properly escaped
                    StringBuilder sb = null;
                    try
                    {
                        var startRaw = 0;
                        for (var ndx = 0; ndx < text.Length; ++ndx)
                        {
                            // if it's a control code...
                            var ch = text[ndx];
                            if (ch < ' ')
                            {
                                // if we haven't created our string builder yet, do it now
                                if (sb == null)
                                {
                                    sb = StringBuilderPool.Acquire();
                                }

                                // add the raw text up to but not including the current character.
                                // but only if start raw is BEFORE the current index
                                if (startRaw < ndx)
                                {
                                    sb.Append(text.Substring(startRaw, ndx - startRaw));
                                }

                                // regular unicode escape
                                sb.Append("\\{0:x}".FormatInvariant(char.ConvertToUtf32(text, ndx)));

                                // if the NEXT character (if there is one) is a hex digit, 
                                // we will need to append a space to signify the end of the escape sequence, since this
                                // will never have more than two digits (0 - 1f).
                                if (ndx + 1 < text.Length
                                    && CssScanner.IsH(text[ndx + 1]))
                                {
                                    sb.Append(' ');
                                }

                                // and update the raw pointer to the next character
                                startRaw = ndx + 1;
                            }
                        }

                        // if we have something left over, add the rest now
                        if (sb != null && startRaw < text.Length)
                        {
                            sb.Append(text.Substring(startRaw));
                        }

                        // if we built up a string, use it. Otherwise just use what we have.
                        text = sb == null ? text : sb.ToString();
                    }
                    finally
                    {
                        sb.Release();
                    }
                }
                else if (tokenType == TokenType.Uri && Settings.FixIE8Fonts)
                {
                    // IE8 @font-face directive has an issue with src properties that are URLs ending with .EOT
                    // that don't have any querystring. They end up sending a malformed HTTP request to the server,
                    // which is bad for the server. So we want to automatically fix this for developers: if ANY URL
                    // ends in .EOT without a querystring parameters, just add a question mark in the appropriate 
                    // location. This fixes the IE8 issue.
                    text = s_eotIE8Fix.Replace(text, ".eot?$1");
                }

                // if it's not a comment, we're going to output it.
                // if it is a comment, we're not going to SAY we've output anything,
                // even if we end up outputting the comment
                var isImportant = false;
                outputText = (tokenType != TokenType.Comment);
                if (!outputText)
                {
                    // if the comment mode is none, we never want to output it.
                    // if the comment mode is all, then we always want to output it.
                    // otherwise we only want to output if it's an important /*! */ comment
                    if (text.StartsWith("/*!", StringComparison.Ordinal))
                    {
                        // this is an important comment. We will always output it
                        // UNLESS the comment mode is none. If it IS none, bail now.
                        if (Settings.CommentMode == CssComment.None)
                        {
                            return false;    
                        }

                        // this is an important comment that we always want to output
                        // (after we get rid of the exclamation point in some situations)
                        text = NormalizeImportantComment(text);

                        // find the index of the initial / character
                        var indexSlash = text.IndexOf('/');
                        if (indexSlash > 0)
                        {
                            // it's not the first character!
                            // the only time that should happen is if we put a line-feed in front.
                            // if the string builder is empty, or if the LAST character is a \r or \n,
                            // then trim off everything before that opening slash
                            if (m_outputNewLine)
                            {
                                // trim off everything before it
                                text = text.Substring(indexSlash);
                            }
                        }
                    }
                    else if (s_sharepointReplacement.IsMatch(text))
                    {
                        // if it's a sharepoint replacement comment, then  always output it
                        // (unless settings say NO comments)
                        if (Settings.CommentMode == CssComment.None)
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // not important, and not sharepoint.
                        // check to see if it's a special value-replacement comment
                        Match match = s_valueReplacement.Match(CurrentTokenText);
                        if (match.Success)
                        {
                            m_valueReplacement = null;

                            var resourceList = Settings.ResourceStrings;
                            if (resourceList.Count > 0)
                            {
                                // it is! see if we have a replacement string
                                string id = match.Result("${id}");

                                // if we have resource strings in the settings, check each one for the
                                // id and set the value replacement field to the value.
                                // walk backwards so later objects override earlier ones.
                                for (var ndx = resourceList.Count - 1; ndx >= 0; --ndx)
                                {
                                    m_valueReplacement = resourceList[ndx][id];
                                    if (m_valueReplacement != null)
                                    {
                                        break;
                                    }
                                }
                            }

                            if (m_valueReplacement != null)
                            {
                                // we do. Don't output the comment. Instead, save the value replacement
                                // for the next time we encounter a value
                                return false;
                            }
                            else
                            {
                                // make sure the comment is normalized
                                text = NormalizedValueReplacementComment(text);
                            }
                        }
                        else if (Settings.CommentMode != CssComment.All)
                        {
                            // don't want to output, bail now
                            return false;
                        }
                    }

                    // see if it's still important
                    isImportant = text.StartsWith("/*!", StringComparison.Ordinal);
                }
                else if (m_parsingColorValue
                    && (tokenType == TokenType.Identifier || tokenType == TokenType.ReplacementToken))
                {
                    if (!text.StartsWith("#", StringComparison.Ordinal))
                    {
                        bool nameConvertedToHex = false;
                        string lowerCaseText = text.ToLowerInvariant();
                        string rgbString;

                        switch (Settings.ColorNames)
                        {
                            case CssColor.Hex:
                                // we don't want any color names in our code.
                                // convert ALL known color names to hex, so see if there is a match on
                                // the set containing all the name-to-hex values
                                if (ColorSlice.AllColorNames.TryGetValue(lowerCaseText, out rgbString))
                                {
                                    text = rgbString;
                                    nameConvertedToHex = true;
                                }
                                break;

                            case CssColor.Strict:
                                // we only want strict names in our css.
                                // convert all non-strict name to hex, AND any strict names to hex if the hex is
                                // shorter than the name. So check the set that contains all non-strict name-to-hex
                                // values and all the strict name-to-hex values where hex is shorter than name.
                                if (ColorSlice.StrictHexShorterThanNameAndAllNonStrict.TryGetValue(lowerCaseText, out rgbString))
                                {
                                    text = rgbString;
                                    nameConvertedToHex = true;
                                }
                                break;

                            case CssColor.Major:
                                // we don't care if there are non-strict color name. So check the set that only
                                // contains name-to-hex pairs where the hex is shorter than the name.
                                if (ColorSlice.HexShorterThanName.TryGetValue(lowerCaseText, out rgbString))
                                {
                                    text = rgbString;
                                    nameConvertedToHex = true;
                                }
                                break;

                            case CssColor.NoSwap:
                                // nope; leave it a name and don't swap it with the equivalent hex value
                                break;
                        }

                        // if we didn't convert the color name to hex, let's see if it is a color
                        // name -- if so, we want to make it lower-case for readability. We don't need
                        // to do this check if our color name setting is hex-only, because we would
                        // have already converted the name if we know about it
                        if (Settings.ColorNames != CssColor.Hex && !nameConvertedToHex
                            && ColorSlice.AllColorNames.TryGetValue(lowerCaseText, out rgbString))
                        {
                            // the color exists in the table, so we're pretty sure this is a color.
                            // make sure it's lower case
                            text = lowerCaseText;
                        }
                    }
                    else if (CurrentTokenType == TokenType.ReplacementToken)
                    {
                        // a replacement token is a color hash -- make sure we trim it to #RGB if it matches #RRGGBB
                        text = CrunchHexColor(text, Settings.ColorNames, m_noColorAbbreviation);
                    }
                }

                // if the global might-need-space flag is set and the first character we're going to
                // output if a hex digit or a space, we will need to add a space before our text
                if (m_mightNeedSpace
                    && (CssScanner.IsH(text[0]) || text[0] == ' '))
                {
                    if (m_lineLength >= Settings.LineBreakThreshold)
                    {
                        // we want to add whitespace, but we're over the line-length threshold, so
                        // output a line break instead
                        AddNewLine();
                    }
                    else
                    {
                        // output a space on the same line
                        parsed.Append(' ');
                        ++m_lineLength;
                    }
                }

                if (tokenType == TokenType.Comment && isImportant)
                {
                    // don't bother resetting line length after this because 
                    // we're going to follow the comment with another blank line
                    // and we'll reset the length at that time
                    AddNewLine();
                }

                if (text == " ")
                {
                    // we are asking to output a space character. At this point, if we are
                    // over the line-length threshold, we can substitute a line break for a space.
                    if (m_lineLength >= Settings.LineBreakThreshold)
                    {
                        AddNewLine();
                    }
                    else
                    {
                        // just output a space, and don't change the newline flag
                        parsed.Append(' ');
                        ++m_lineLength;
                    }
                }
                else
                {
                    // normal text
                    // see if we wanted to force a newline
                    if (m_forceNewLine)
                    {
                        // only output a newline if we aren't already on a new line
                        // AND we are in multiple-line mode
                        if (!m_outputNewLine && Settings.OutputMode == OutputMode.MultipleLines)
                        {
                            AddNewLine();
                        }
                        
                        // reset the flag
                        m_forceNewLine = false;
                    }

                    parsed.Append(text);
                    m_outputNewLine = false;

                    if (tokenType == TokenType.Comment && isImportant)
                    {
                        AddNewLine();
                        m_lineLength = 0;
                        m_outputNewLine = true;
                    }
                    else
                    {
                        m_lineLength += text.Length;
                    }
                }

                // if the text we just output ENDS in an escape, we might need a space later
                m_mightNeedSpace = textEndsInEscapeSequence;

                // save a copy of the string so we can check the last output
                // string later if we need to
                m_lastOutputString = text;
            }

            return outputText;
        }

        private string GetReplacementValue(Match match)
        {
            string tokenValue = null;
            var tokenName = match.Result("${token}");
            if (!tokenName.IsNullOrWhiteSpace())
            {
                if (!Settings.ReplacementTokens.TryGetValue(tokenName, out tokenValue))
                {
                    // no match. Check for a fallback
                    var fallbackClass = match.Result("${fallback}");
                    if (!fallbackClass.IsNullOrWhiteSpace())
                    {
                        Settings.ReplacementFallbacks.TryGetValue(fallbackClass, out tokenValue);
                    }
                }
            }

            // if we found a replacement, use it. Otherwise use a blank string to remove the token
            return string.IsNullOrEmpty(tokenValue);
        }

        private static bool EscapeCharacter(StringBuilder sb, char character)
        {
            // output the hex value of the escaped character. If it's less than seven digits
            // (the slash followed by six hex digits), we might
            // need to append a space before the next valid character if it is a valid hex digit.
            // (we will always need to append another space after an escape sequence if the next valid character is a space)
            var hex = "\\{0:x}".FormatInvariant((int)character);
            sb.Append(hex);
            return hex.Length < 7;
        }

        private bool Append(object obj)
        {
            return Append(obj, TokenType.None);
        }

        private void NewLine()
        {
            // if we've output something other than a newline, output one now
            if (Settings.OutputMode == OutputMode.MultipleLines && !m_outputNewLine)
            {
                AddNewLine();
                m_lineLength = 0;
                m_outputNewLine = true;
            }
        }

        /// <summary>
        /// Always add new line to the stream
        /// </summary>
        /// <param name="sb"></param>
        private void AddNewLine()
        {
            if (!m_outputNewLine)
            {
                var parsed = m_builders.Peek();
                parsed.Append(Settings.LineTerminator);
                if (Settings.OutputMode == OutputMode.MultipleLines)
                {

                    var indentSpaces = Settings.TabSpaces;
                    m_lineLength = indentSpaces.Length;
                    if (m_lineLength > 0)
                    {
                        parsed.Append(indentSpaces);
                    }
                }
                else
                {
                    m_lineLength = 0;
                }

                m_outputNewLine = true;
            }
        }

        private void Indent()
        {
            // increase the indent level by one
            Settings.Indent();
        }

        private void Unindent()
        {
            // only decrease the indent level by one IF it's greater than zero
            Settings.Unindent();
        }

        #endregion

        #region color methods

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase")]
        private static string CrunchHexColor(string hexColor, CssColor colorNames, bool noAbbr)
        {
            if (!noAbbr)
            {
                hexColor = s_rrggbb.Replace(hexColor, "#${r}${g}${b}").ToLowerInvariant();
            }

            if (colorNames == CssColor.Strict || colorNames == CssColor.Major)
            {
                // check for the hex values that can be swapped with the W3C color names to save bytes?
                //      #808080 - gray
                //      #008000 - green
                //      #800000 - maroon
                //      #000080 - navy
                //      #808000 - olive
                //      #ffa500 - orange
                //      #800080 - purple
                //      #f00    - red
                //      #c0c0c0 - silver
                //      #008080 - teal
                // (these are the only colors we can use and still validate)
                // if we don't care about validating, there are even more colors that work in all
                // major browsers that would save up some bytes. But if we convert to those names,
                // we'd really need to be able to convert back to make it validate again.
                //
                // if the map contains an entry for this color, then we
                // should use the name instead because it's smaller.
                string colorName;
                if (ColorSlice.StrictNameShorterThanHex.TryGetValue(hexColor, out colorName))
                {
                    hexColor = colorName;
                }
                else if (colorNames == CssColor.Major)
                {
                    if (ColorSlice.NameShorterThanHex.TryGetValue(hexColor, out colorName))
                    {
                        hexColor = colorName;
                    }
                }
            }

            return hexColor;
        }

        private static bool MightContainColorNames(string propertyName)
        {
            bool hasColor = (propertyName.EndsWith("color", StringComparison.Ordinal));
            if (!hasColor)
            {
                switch (propertyName)
                {
                    case "background":
                    case "border-top":
                    case "border-right":
                    case "border-bottom":
                    case "border-left":
                    case "border":
                    case "outline":
                        hasColor = true;
                        break;
                }
            }
            return hasColor;
        }

        #endregion

        #region Error methods

        public static string ErrorFormat(CssErrorCode errorCode)
        {
            return CssStrings.ResourceManager.GetString(errorCode.ToString(), CssStrings.Culture);
        }

        private void ReportError(int severity, CssErrorCode errorNumber, CssContext context, params object[] arguments)
        {
            // guide: 0 == syntax error
            //        1 == the programmer probably did not intend to do this
            //        2 == this can lead to problems in the future.
            //        3 == this can lead to performance problems
            //        4 == this is just not right

            string message = ErrorFormat(errorNumber).FormatInvariant(arguments);
            Debug.Assert(!message.IsNullOrWhiteSpace());
            var error = new UglifyError()
                {
                    IsError = severity < 2,
                    Severity = severity,
                    Subcategory = UglifyError.GetSubcategory(severity),
                    File = FileContext,
                    ErrorNumber = (int)errorNumber,
                    ErrorCode = "CSS{0}".FormatInvariant(((int)errorNumber) & (0xffff)),
                    Message = message,
                };

            if (context != null)
            {
                error.StartLine = context.Start.Line;
                error.StartColumn = context.Start.Char;
            }

            // but warnings we want to just report and carry on
            OnCssError(error);
        }

        // just use the current context for the error
        private void ReportError(int severity, CssErrorCode errorNumber, params object[] arguments)
        {
            ReportError(severity, errorNumber, m_currentToken != null ? m_currentToken.Context : null, arguments);
        }

        public event EventHandler<ContextErrorEventArgs> CssError;

        protected void OnCssError(UglifyError cssError)
        {
            if (CssError != null && cssError != null && !Settings.IgnoreAllErrors)
            {
                // if we have no errors in our error ignore list, or if we do but this error code is not in
                // that list, fire the event to whomever is listening for it.
                if (!Settings.IgnoreErrorCollection.Contains(cssError.ErrorCode))
                {
                    CssError(this, new ContextErrorEventArgs()
                        {
                            Error = cssError
                        });
                }
            }
        }

        #endregion

        #region comment methods

        /// <summary>
        /// regular expression for matching newline characters
        /// </summary>
        ////private static Regex s_regexNewlines = new Regex(
        ////    @"\r\n|\f|\r|\n",
        ////    RegexOptions.CultureInvariant | RegexOptions.Singleline | RegexOptions.Compiled);

        static string NormalizedValueReplacementComment(string source)
        {
            return s_valueReplacement.Replace(source, "/*[${id}]*/");
        }

        static bool CommentContainsText(string comment)
        {
            for (var ndx = 0; ndx < comment.Length; ++ndx)
            {
                if (char.IsLetterOrDigit(comment[ndx]))
                {
                    return true;
                }
            }

            // if we get here, we didn't find any text characters
            return false;
        }

        string NormalizeImportantComment(string source)
        {
            // if this important comment does not contain any text, assume it's for a comment hack
            // and return a normalized string without the exclamation mark.
            if (CommentContainsText(source))
            {
                // first check to see if the comment is in the form /*!/ ...text... /**/
                // if so, then it's probably a part of the Opera5&NS4-only comment hack and we want
                // to make SURE that exclamation point does not get in the output because it would
                // mess up the results.
                if (source[3] == '/' && source.EndsWith("/**/", StringComparison.Ordinal))
                {
                    // it is. output the comment as-is EXCEPT without the exclamation mark
                    // (and don't put any line-feeds around it)
                    source = "/*" + source.Substring(3);
                }
            }
            else
            {
                // important comment, but it doesn't contain text. So instead, leave it inline
                // (don't add a newline character before it) but take out the exclamation mark.
                source = "/*" + source.Substring(3);
            }

            // if this is single-line mode, make sure CRLF-pairs are all converted to just CR
            if (Settings.OutputMode == OutputMode.SingleLine)
            {
                source = source.Replace("\r\n", "\n");
            }
            return source;
        }
        #endregion

        #region private enums

        private enum Parsed
        {
            True,
            False,
            Empty
        }

        #endregion
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\Css\CssParser.cs(4752,20): error CS0029: Cannot implicitly convert type 'bool' to 'string'
######################################################################


######################################################################
Nr: 10 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\Html\HtmlMinifier.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using NUglify.Css;
using NUglify.Helpers;

namespace NUglify.Html
{
    public class HtmlMinifier
    {
        private readonly HtmlDocument html;
        private int pendingTagNonCollapsibleWithSpaces;
        private readonly List<HtmlText> pendingTexts;
        private readonly HtmlSettings settings;
        private readonly CssSettings attributeCssSettings;
        private int xmlNamespaceCount;

        private static readonly Dictionary<string, bool> AttributesRemovedIfEmpty = new[]
        {
            "class",
            "id",
            "style",
            "title",
            "lang",
            "dir",
            "onfocus",
            "onblur",
            "onchange",
            "onclick",
            "ondblclick",
            "onmousedown",
            "onmouseup",
            "onmouseover",
            "onmousemove",
            "onmouseout",
            "onkeypress",
            "onkeydown",
            "onkeyup",
        }.ToDictionaryBool(false);

        private static readonly Dictionary<string, bool> ScriptAttributes = new string[]
        {
            "onAbort",
            "onBlur",
            "onChange",
            "onClick",
            "onDblClick",
            "onDragDrop",
            "onError",
            "onFocus",
            "onKeyDown",
            "onKeyPress",
            "onKeyUp",
            "onLoad",
            "onMouseDown",
            "onMouseMove",
            "onMouseOut",
            "onMouseOver",
            "onMouseUp",
            "onMove",
            "onReset",
            "onResize",
            "onSelect",
            "onSubmit",
            "onUnload",
        }.ToDictionaryBool(false);

        public HtmlMinifier(HtmlDocument html, HtmlSettings settings = null)
        {
            if (html == null) throw new ArgumentNullException(nameof(html));
            this.settings = settings ?? new HtmlSettings();
            attributeCssSettings = this.settings.CssSettings.Clone();
            attributeCssSettings.CssType = CssType.DeclarationList;

            this.html = html;
            pendingTexts = new List<HtmlText>();
            Errors = new List<UglifyError>();
        }

        public bool HasErrors { get; private set; }

        public List<UglifyError> Errors { get; private set; }

        public void Minify()
        {
            ProcessChildren(html);
            if (settings.CollapseWhitespaces)
            {
                TrimPendingTextNodes();
            }
        }

        private void ProcessNode(HtmlNode node)
        {
            var element = node as HtmlElement;
            bool isInXml = element?.Descriptor != null && (element.Descriptor.Category & ContentKind.Xml) != 0;
            if (isInXml)
            {
                xmlNamespaceCount++;
            }

            TrimNodeOnStart(node);
            
            bool isContentNonCollapsible = false;
            if (element != null && settings.TagsWithNonCollapsableWhitespaces.ContainsKey(element.Name))
            {
                pendingTagNonCollapsibleWithSpaces++;
                isContentNonCollapsible = true;
            }

            ProcessChildren(node);

            TrimNodeOnEnd(node);

            if (isInXml)
            {
                xmlNamespaceCount--;
            }

            if (isContentNonCollapsible)
            {
                pendingTagNonCollapsibleWithSpaces--;
            }
        }
        private void ProcessChildren(HtmlNode node)
        {
            foreach (var subNode in node.Children)
            {
                ProcessNode(subNode);
            }            
        }

        private void TrimNodeOnStart(HtmlNode node)
        {
            var textNode = node as HtmlText;
            if (textNode != null)
            {
                TrimNodeOnStart(textNode);
            }

            if (node is HtmlComment && settings.RemoveComments)
            {
                var comment = (HtmlComment) node;
                bool keepComment = false;
                foreach (var regex in settings.KeepCommentsRegex)
                {
                    var result = regex.Match(comment.Slice.Text, comment.Slice.Start, comment.Slice.Length);
                    if (result.Success)
                    {
                        keepComment = true;
                        break;
                    }
                }

                // Don't remove special ignoring comments
                if (!keepComment)
                {
                    node.Remove();
                }
            }

            // Remove HTML script
            if (settings.RemoveJavaScript && node is HtmlElement && ((HtmlElement) node).Descriptor?.Name == "script")
            {
                node.Remove();
            }
        }

        private void TrimNodeOnEnd(HtmlNode node)
        {
            if (node is HtmlElement htmlElement)
            {
                TrimNodeOnEnd(htmlElement);
            }
        }

        private void TrimNodeOnStart(HtmlText textNode)
        {
            // If we need to decode entities
            if (settings.DecodeEntityCharacters)
            {
                if (textNode.Slice.IndexOf('&') >= 0)
                {
                    var text = textNode.Slice.ToString();
                    textNode.Slice = new StringSlice(EntityHelper.Unescape(text));
                }
            }

            // If we don't do anything for TextNode, we can early exit
            if (!settings.CollapseWhitespaces)
            {
                return;
            }

            // Find the first non-transparent parent
            var parent = textNode.Parent;
            while (parent != null &&
                   (parent.Descriptor == null || parent.Descriptor.Category == ContentKind.Transparent))
            {
                parent = parent.Parent;
            }

            if (!textNode.Slice.IsEmptyOrWhiteSpace() || (parent?.Descriptor != null && xmlNamespaceCount == 0))
            {
                pendingTexts.Add(textNode);
            }
            else
            {
                textNode.Remove();
            }
        }

        private void TrimNodeOnEnd(HtmlElement element)
        {
            // If the element is a valid HTML descriptor, we can safely turn-it all lowercase
            if (xmlNamespaceCount == 0)
            {
                element.Name = element.Name.ToLowerInvariant();
            }

            // If the element being visited is not an inline tag, we need to clear the previous text node
            if (settings.CollapseWhitespaces && !settings.InlineTagsPreservingSpacesAround.ContainsKey(element.Name) && element.Descriptor != null && element.Kind != ElementKind.SelfClosing)
            {
                TrimPendingTextNodes();
            }

            // Remove invalid closing tags
            if (settings.RemoveInvalidClosingTags && element.Kind == ElementKind.Closing)
            {
                element.Remove();
            }

            if (element.Attributes != null)
            {
                for (int i = element.Attributes.Count - 1; i >= 0; i--)
                {
                    var attribute = element.Attributes[i];
                    if (TrimAttribute(element, attribute))
                    {
                        element.Attributes.RemoveAt(i);
                    }
                }
            }

            // Remove optional tags
            if (settings.RemoveOptionalTags && !settings.KeepTags.Contains(element.Name))
            {
                var nextElement = element.FindNextSibling<HtmlElement>();

                // Handle end tag omit
                var canOmitEndTag = element.Descriptor?.CanOmitEndTag;
                if (element.Kind == ElementKind.OpeningClosing && canOmitEndTag != null && canOmitEndTag(element, nextElement, false))
                {
                    element.Kind = ElementKind.Opening;
                }

                // Handle start tag omit
                var canOmitStartTag = element.Descriptor?.CanOmitStartTag;
                if ((element.Attributes == null || element.Attributes.Count == 0) && element.Kind == ElementKind.Opening && canOmitStartTag != null && canOmitStartTag(element, nextElement, false))
                {
                    element.Kind = ElementKind.None;
                }
            }

            var isJavaScript = IsJavaScript(element);
            var isCssScript = !isJavaScript && IsCssStyle(element);
            if (isJavaScript || isCssScript)
            {
                TrimScriptOrStyle(element, isJavaScript);
            }
        }

        private void TrimPendingTextNodes()
        {
            if (pendingTagNonCollapsibleWithSpaces == 0)
            {
                HtmlText previousTextNode = null;
                HtmlText firstTextNode = null;
                for (int i = 0; i < pendingTexts.Count; i++)
                {
                    var textNode = pendingTexts[i];
                    if (firstTextNode == null)
                    {
                        firstTextNode = textNode;
                    }

                    var previousElement = textNode.PreviousSibling as HtmlElement;
                    var nextElement = textNode.NextSibling as HtmlElement;

                    var isPreviousElementPreservingSpace = previousElement != null &&
                                                           settings.InlineTagsPreservingSpacesAround.ContainsKey(
                                                               previousElement.Name);
                    var isNextElementPreservingSpace = nextElement != null &&
                                                       settings.InlineTagsPreservingSpacesAround.ContainsKey(nextElement
                                                           .Name);

                    // If we expect to keep one space after collapsing
                    var isFirstText = textNode == firstTextNode;
                    var isLastText = i + 1 == pendingTexts.Count;
                    if (!settings.KeepOneSpaceWhenCollapsing || isFirstText || isLastText)
                    {
                        var isPreviousTrailing = previousTextNode != null && previousTextNode.Slice.HasTrailingSpaces();
                        var isNextStartsBySpace = i + 1 >= pendingTexts.Count ||
                                                  pendingTexts[i + 1].Slice.StartsBySpace();

                        // We can trim the heading whitespaces if:
                        // - we don't have a previous element (either inline or parent container)
                        // - OR the previous element (sibling or parent) is not a tag that require preserving spaces around
                        // - OR the previous text node has already some trailing spaces
                        if (!isPreviousElementPreservingSpace && (previousTextNode == null || isPreviousTrailing) &&
                            (previousElement == null || isFirstText))
                        {
                            textNode.Slice.TrimStart();
                        }

                        // We can trim the traling whitespaces if:
                        // - we don't have a next element (either inline or parent container)
                        // - OR the next element (sibling or parent) is not a tag that require preserving spaces around
                        if (!isNextElementPreservingSpace && isNextStartsBySpace)
                        {
                            textNode.Slice.TrimEnd();
                        }
                    }

                    // If we are not in the context of a tag that doesn't accept to collapse whitespaces, 
                    // we can collapse them for this text node
                    textNode.Slice.CollapseSpaces();

                    // If the text node is empty, remove it from the tree
                    if (textNode.Slice.IsEmpty() || (textNode.Slice.IsEmptyOrWhiteSpace() &&
                                                     !isPreviousElementPreservingSpace &&
                                                     !isNextElementPreservingSpace))
                    {
                        textNode.Remove();
                        if (firstTextNode == textNode)
                        {
                            firstTextNode = null;
                        }
                    }
                    else
                    {
                        // Replace the previous textnode
                        previousTextNode = textNode;
                    }
                }

                // Trim any trailing spaces of the last known text node if we are moving to a block level
                if (previousTextNode != null && previousTextNode.NextSibling == null)
                {
                    previousTextNode.Slice.TrimEnd();
                    if (previousTextNode.Slice.IsEmpty())
                    {
                        previousTextNode.Remove();
                    }
                }
            }

            pendingTexts.Clear();
        }
        private void TrimScriptOrStyle(HtmlElement element, bool isJs)
        {
            // We remove the type attribute, as it default to text/css and text/javascript
            if (settings.RemoveScriptStyleTypeAttribute)
            {
                element.RemoveAttribute("type");
            }

            if ((isJs && !settings.MinifyJs) || (!isJs && !settings.MinifyCss))
            {
                return;
            }

            var raw = element.FirstChild as HtmlRaw;
            if (raw == null)
            {
                return;
            }

            var slice = raw.Slice;

            slice.TrimStart();
            slice.TrimEnd();

            // If the text has a comment or CDATA, we won't try to minify it
            if (slice.StartsWith("<!--") || slice.StartsWithIgnoreCase("<![CDATA["))
            {
                return;
            }

            var text = slice.ToString();

            var textMinified = MinifyJsOrCss(text, isJs);
            if (textMinified == null)
            {
                return;
            }
            raw.Slice = new StringSlice(textMinified);
        }


        private string MinifyJsOrCss(string text, bool isJs)
        {
            var result = isJs
                ? Uglify.Js(text, "inner_js", settings.JsSettings)
                : Uglify.Css(text, "inner_css", settings.CssSettings);

            if (result.Errors != null)
            {
                Errors.AddRange(result.Errors);
            }

            if (result.HasErrors)
            {
                HasErrors = true;
                return text;
            }

            return result.Code;
        }

        private string MinifyCssAttribute(string text)
        {
            var result = Uglify.Css(text, "inner_css", attributeCssSettings);
            if (result.Errors != null)
            {
                Errors.AddRange(result.Errors);
            }

            if (result.HasErrors)
            {
                HasErrors = true;
                return text;
            }

            return result.Code;
        }

        private bool TrimAttribute(HtmlElement element, HtmlAttribute attribute)
        {
            var tag = element.Name.ToLowerInvariant();
            var attr = attribute.Name.ToLowerInvariant();

            if (attribute.Value != null)
            {
                if (settings.RemoveJavaScript)
                {
                    if (ScriptAttributes.ContainsKey(attr) || attribute.Value.Trim().StartsWith("javascript:", StringComparison.OrdinalIgnoreCase))
                    {
                        return true;
                    }
                }

                if (IsUriTypeAttribute(element.Name, attribute.Name))
                {
                    attribute.Value = attribute.Value.Trim();
                    return false;
                }
                if (attr == "class")
                {
                    attribute.Value = attribute.Value.Trim();
                    //if (options.sortClassName)
                    //{
                    //    attrValue = options.sortClassName(attrValue);
                    //}
                    // else
                    {
                        attribute.Value = CharHelper.CollapseWhitespaces(attribute.Value);
                    }
                    return attribute.Value == string.Empty;
                }
                else if (attr == "style" && element.Descriptor != null && settings.MinifyCssAttributes)
                {
                    attribute.Value = MinifyCssAttribute(attribute.Value);
                    return attribute.Value == string.Empty;
                }
            }

            if (settings.ShortBooleanAttribute && attribute.Value == "true")
            {
                attribute.Value = null;
            }

            if (settings.RemoveEmptyAttributes)
            {
                if ((attribute.Value != null || (attribute.Value == null && AttributesRemovedIfEmpty.ContainsKey(attr))) && attribute.Value.IsNullOrWhiteSpace())
                {
                    attribute.Value = string.Empty;

                    return (tag == "input" && attr == "value") || AttributesRemovedIfEmpty.ContainsKey(attr);
                }
            }

            if (!settings.AttributesCaseSensitive && xmlNamespaceCount == 0)
            {
                attribute.Name = attr;
            }

            return false;
        }

        private static bool IsJavaScript(HtmlElement element)
        {
            if (!element.Name.Equals("script", StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }
            return IsAttributeValueJs(element.FindAttribute("type")?.Value);
        }

        private static bool IsCssStyle(HtmlElement element)
        {
            if (!element.Name.Equals("style", StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }
            return IsAttributeValueCss(element.FindAttribute("type")?.Value);
        }

        private static bool IsAttributeValueCss(string value)
        {
            return string.IsNullOrEmpty(value) || value.Equals("text/css", StringComparison.OrdinalIgnoreCase);
        }

        private static bool IsUriTypeAttribute(string tag, string attr)
        {
            // Code from https://github.com/kangax/html-minifier/blob/gh-pages/src/htmlminifier.js
            return ((tag == "a" || tag == "area" || tag == "base") && attr == "href") ||
                   (tag == "img" && (attr == "src" || attr == "longdesc" || attr == "usemap")) ||
                   (tag == "object" &&
                    (attr == "classid" || attr == "codebase" || attr == "data" || attr == "usemap")) ||
                   (tag == "q" && attr == "cite") ||
                   (tag == "blockquote" && attr == "cite") ||
                   ((tag == "ins" || tag == "del") && attr == "cite") ||
                   (tag == "form" && attr == "action") ||
                   (tag == "input" && (attr == "src" || attr == "usemap")) ||
                   (tag == "head" && attr == "profile") ||
                   (tag == "script" && (attr == "src" || attr == "for"));
        }

        private static bool IsAttributeValueJs(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return true;
            }

            var text = value.Split(';')[0].ToLowerInvariant();
            switch (text)
            {
                case "text/javascript":
                case "text/ecmascript":
                case "text/jscript":
                case "application/javascript":
                case "application/x-javascript":
                case "application/ecmascript":
                    return true;
            }
            return false;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using NUglify.Css;
using NUglify.Helpers;

namespace NUglify.Html
{
    public class HtmlMinifier
    {
        private readonly HtmlDocument html;
        private int pendingTagNonCollapsibleWithSpaces;
        private readonly List<HtmlText> pendingTexts;
        private readonly HtmlSettings settings;
        private readonly CssSettings attributeCssSettings;
        private int xmlNamespaceCount;

        private static readonly Dictionary<string, bool> AttributesRemovedIfEmpty = new[]
        {
            "class",
            "id",
            "style",
            "title",
            "lang",
            "dir",
            "onfocus",
            "onblur",
            "onchange",
            "onclick",
            "ondblclick",
            "onmousedown",
            "onmouseup",
            "onmouseover",
            "onmousemove",
            "onmouseout",
            "onkeypress",
            "onkeydown",
            "onkeyup",
        }.ToDictionaryBool(false);

        private static readonly Dictionary<string, bool> ScriptAttributes = new string[]
        {
            "onAbort",
            "onBlur",
            "onChange",
            "onClick",
            "onDblClick",
            "onDragDrop",
            "onError",
            "onFocus",
            "onKeyDown",
            "onKeyPress",
            "onKeyUp",
            "onLoad",
            "onMouseDown",
            "onMouseMove",
            "onMouseOut",
            "onMouseOver",
            "onMouseUp",
            "onMove",
            "onReset",
            "onResize",
            "onSelect",
            "onSubmit",
            "onUnload",
        }.ToDictionaryBool(false);

        public HtmlMinifier(HtmlDocument html, HtmlSettings settings = null)
        {
            if (html == null) throw new ArgumentNullException(nameof(html));
            this.settings = settings ?? new HtmlSettings();
            attributeCssSettings = this.settings.CssSettings.Clone();
            attributeCssSettings.CssType = CssType.DeclarationList;

            this.html = html;
            pendingTexts = new List<HtmlText>();
            Errors = new List<UglifyError>();
        }

        public bool HasErrors { get; private set; }

        public List<UglifyError> Errors { get; private set; }

        public void Minify()
        {
            ProcessChildren(html);
            if (settings.CollapseWhitespaces)
            {
                TrimPendingTextNodes();
            }
        }

        private void ProcessNode(HtmlNode node)
        {
            var element = node as HtmlElement;
            bool isInXml = element?.Descriptor != null && (element.Descriptor.Category & ContentKind.Xml) != 0;
            if (isInXml)
            {
                xmlNamespaceCount++;
            }

            TrimNodeOnStart(node);
            
            bool isContentNonCollapsible = false;
            if (element != null && settings.TagsWithNonCollapsableWhitespaces.ContainsKey(element.Name))
            {
                pendingTagNonCollapsibleWithSpaces++;
                isContentNonCollapsible = true;
            }

            ProcessChildren(node);

            TrimNodeOnEnd(node);

            if (isInXml)
            {
                xmlNamespaceCount--;
            }

            if (isContentNonCollapsible)
            {
                pendingTagNonCollapsibleWithSpaces--;
            }
        }
        private void ProcessChildren(HtmlNode node)
        {
            foreach (var subNode in node.Children)
            {
                ProcessNode(subNode);
            }            
        }

        private void TrimNodeOnStart(HtmlNode node)
        {
            if (node is HtmlText textNode)
            {
                TrimNodeOnStart(textNode);
            }

            if (node is HtmlComment && settings.RemoveComments)
            {
                var comment = (HtmlComment) node;
                bool keepComment = false;
                foreach (var regex in settings.KeepCommentsRegex)
                {
                    var result = regex.Match(comment.Slice.Text, comment.Slice.Start, comment.Slice.Length);
                    if (result.Success)
                    {
                        keepComment = true;
                        break;
                    }
                }

                // Don't remove special ignoring comments
                if (!keepComment)
                {
                    node.Remove();
                }
            }

            // Remove HTML script
            if (settings.RemoveJavaScript && node is HtmlElement && ((HtmlElement) node).Descriptor?.Name == "script")
            {
                node.Remove();
            }
        }

        private void TrimNodeOnEnd(HtmlNode node)
        {
            if (node is HtmlElement htmlElement)
            {
                TrimNodeOnEnd(htmlElement);
            }
        }

        private void TrimNodeOnStart(HtmlText textNode)
        {
            // If we need to decode entities
            if (settings.DecodeEntityCharacters)
            {
                if (textNode.Slice.IndexOf('&') >= 0)
                {
                    var text = textNode.Slice.ToString();
                    textNode.Slice = new StringSlice(EntityHelper.Unescape(text));
                }
            }

            // If we don't do anything for TextNode, we can early exit
            if (!settings.CollapseWhitespaces)
            {
                return;
            }

            // Find the first non-transparent parent
            var parent = textNode.Parent;
            while (parent != null &&
                   (parent.Descriptor == null || parent.Descriptor.Category == ContentKind.Transparent))
            {
                parent = parent.Parent;
            }

            if (!textNode.Slice.IsEmptyOrWhiteSpace() || (parent?.Descriptor != null && xmlNamespaceCount == 0))
            {
                pendingTexts.Add(textNode);
            }
            else
            {
                textNode.Remove();
            }
        }

        private void TrimNodeOnEnd(HtmlElement element)
        {
            // If the element is a valid HTML descriptor, we can safely turn-it all lowercase
            if (xmlNamespaceCount == 0)
            {
                element.Name = element.Name.ToLowerInvariant();
            }

            // If the element being visited is not an inline tag, we need to clear the previous text node
            if (settings.CollapseWhitespaces && !settings.InlineTagsPreservingSpacesAround.ContainsKey(element.Name) && element.Descriptor != null && element.Kind != ElementKind.SelfClosing)
            {
                TrimPendingTextNodes();
            }

            // Remove invalid closing tags
            if (settings.RemoveInvalidClosingTags && element.Kind == ElementKind.Closing)
            {
                element.Remove();
            }

            if (element.Attributes != null)
            {
                for (int i = element.Attributes.Count - 1; i >= 0; i--)
                {
                    var attribute = element.Attributes[i];
                    if (TrimAttribute(element, attribute))
                    {
                        element.Attributes.RemoveAt(i);
                    }
                }
            }

            // Remove optional tags
            if (settings.RemoveOptionalTags && !settings.KeepTags.Contains(element.Name))
            {
                var nextElement = element.FindNextSibling<HtmlElement>();

                // Handle end tag omit
                var canOmitEndTag = element.Descriptor?.CanOmitEndTag;
                if (element.Kind == ElementKind.OpeningClosing && canOmitEndTag != null && canOmitEndTag(element, nextElement, false))
                {
                    element.Kind = ElementKind.Opening;
                }

                // Handle start tag omit
                var canOmitStartTag = element.Descriptor?.CanOmitStartTag;
                if ((element.Attributes == null || element.Attributes.Count == 0) && element.Kind == ElementKind.Opening && canOmitStartTag != null && canOmitStartTag(element, nextElement, false))
                {
                    element.Kind = ElementKind.None;
                }
            }

            var isJavaScript = IsJavaScript(element);
            var isCssScript = !isJavaScript && IsCssStyle(element);
            if (isJavaScript || isCssScript)
            {
                TrimScriptOrStyle(element, isJavaScript);
            }
        }

        private void TrimPendingTextNodes()
        {
            if (pendingTagNonCollapsibleWithSpaces == 0)
            {
                HtmlText previousTextNode = null;
                HtmlText firstTextNode = null;
                for (int i = 0; i < pendingTexts.Count; i++)
                {
                    var textNode = pendingTexts[i];
                    if (firstTextNode == null)
                    {
                        firstTextNode = textNode;
                    }

                    var isPreviousElementPreservingSpace = textNode.PreviousSibling is HtmlElement previousElement &&
                                                           settings.InlineTagsPreservingSpacesAround.ContainsKey(
                                                               previousElement.Name);
                    var isNextElementPreservingSpace = textNode.NextSibling is HtmlElement nextElement &&
                                                       settings.InlineTagsPreservingSpacesAround.ContainsKey(nextElement
                                                           .Name);

                    // If we expect to keep one space after collapsing
                    var isFirstText = textNode == firstTextNode;
                    var isLastText = i + 1 == pendingTexts.Count;
                    if (!settings.KeepOneSpaceWhenCollapsing || isFirstText || isLastText)
                    {
                        var isPreviousTrailing = previousTextNode != null && previousTextNode.Slice.HasTrailingSpaces();
                        var isNextStartsBySpace = i + 1 >= pendingTexts.Count ||
                                                  pendingTexts[i + 1].Slice.StartsBySpace();

                        // We can trim the heading whitespaces if:
                        // - we don't have a previous element (either inline or parent container)
                        // - OR the previous element (sibling or parent) is not a tag that require preserving spaces around
                        // - OR the previous text node has already some trailing spaces
                        if (!isPreviousElementPreservingSpace && (previousTextNode == null || isPreviousTrailing) &&
                            (previousElement == null || isFirstText))
                        {
                            textNode.Slice.TrimStart();
                        }

                        // We can trim the traling whitespaces if:
                        // - we don't have a next element (either inline or parent container)
                        // - OR the next element (sibling or parent) is not a tag that require preserving spaces around
                        if (!isNextElementPreservingSpace && isNextStartsBySpace)
                        {
                            textNode.Slice.TrimEnd();
                        }
                    }

                    // If we are not in the context of a tag that doesn't accept to collapse whitespaces, 
                    // we can collapse them for this text node
                    textNode.Slice.CollapseSpaces();

                    // If the text node is empty, remove it from the tree
                    if (textNode.Slice.IsEmpty() || (textNode.Slice.IsEmptyOrWhiteSpace() &&
                                                     !isPreviousElementPreservingSpace &&
                                                     !isNextElementPreservingSpace))
                    {
                        textNode.Remove();
                        if (firstTextNode == textNode)
                        {
                            firstTextNode = null;
                        }
                    }
                    else
                    {
                        // Replace the previous textnode
                        previousTextNode = textNode;
                    }
                }

                // Trim any trailing spaces of the last known text node if we are moving to a block level
                if (previousTextNode != null && previousTextNode.NextSibling == null)
                {
                    previousTextNode.Slice.TrimEnd();
                    if (previousTextNode.Slice.IsEmpty())
                    {
                        previousTextNode.Remove();
                    }
                }
            }

            pendingTexts.Clear();
        }
        private void TrimScriptOrStyle(HtmlElement element, bool isJs)
        {
            // We remove the type attribute, as it default to text/css and text/javascript
            if (settings.RemoveScriptStyleTypeAttribute)
            {
                element.RemoveAttribute("type");
            }

            if ((isJs && !settings.MinifyJs) || (!isJs && !settings.MinifyCss))
            {
                return;
            }

            var raw = element.FirstChild as HtmlRaw;
            if (raw == null)
            {
                return;
            }

            var slice = raw.Slice;

            slice.TrimStart();
            slice.TrimEnd();

            // If the text has a comment or CDATA, we won't try to minify it
            if (slice.StartsWith("<!--") || slice.StartsWithIgnoreCase("<![CDATA["))
            {
                return;
            }

            var text = slice.ToString();

            var textMinified = MinifyJsOrCss(text, isJs);
            if (textMinified == null)
            {
                return;
            }
            raw.Slice = new StringSlice(textMinified);
        }


        private string MinifyJsOrCss(string text, bool isJs)
        {
            var result = isJs
                ? Uglify.Js(text, "inner_js", settings.JsSettings)
                : Uglify.Css(text, "inner_css", settings.CssSettings);

            if (result.Errors != null)
            {
                Errors.AddRange(result.Errors);
            }

            if (result.HasErrors)
            {
                HasErrors = true;
                return text;
            }

            return result.Code;
        }

        private string MinifyCssAttribute(string text)
        {
            var result = Uglify.Css(text, "inner_css", attributeCssSettings);
            if (result.Errors != null)
            {
                Errors.AddRange(result.Errors);
            }

            if (result.HasErrors)
            {
                HasErrors = true;
                return text;
            }

            return result.Code;
        }

        private bool TrimAttribute(HtmlElement element, HtmlAttribute attribute)
        {
            var tag = element.Name.ToLowerInvariant();
            var attr = attribute.Name.ToLowerInvariant();

            if (attribute.Value != null)
            {
                if (settings.RemoveJavaScript)
                {
                    if (ScriptAttributes.ContainsKey(attr) || attribute.Value.Trim().StartsWith("javascript:", StringComparison.OrdinalIgnoreCase))
                    {
                        return true;
                    }
                }

                if (IsUriTypeAttribute(element.Name, attribute.Name))
                {
                    attribute.Value = attribute.Value.Trim();
                    return false;
                }
                if (attr == "class")
                {
                    attribute.Value = attribute.Value.Trim();
                    //if (options.sortClassName)
                    //{
                    //    attrValue = options.sortClassName(attrValue);
                    //}
                    // else
                    {
                        attribute.Value = CharHelper.CollapseWhitespaces(attribute.Value);
                    }
                    return attribute.Value == string.Empty;
                }
                else if (attr == "style" && element.Descriptor != null && settings.MinifyCssAttributes)
                {
                    attribute.Value = MinifyCssAttribute(attribute.Value);
                    return attribute.Value == string.Empty;
                }
            }

            if (settings.ShortBooleanAttribute && attribute.Value == "true")
            {
                attribute.Value = null;
            }

            if (settings.RemoveEmptyAttributes)
            {
                if ((attribute.Value != null || (attribute.Value == null && AttributesRemovedIfEmpty.ContainsKey(attr))) && attribute.Value.IsNullOrWhiteSpace())
                {
                    attribute.Value = string.Empty;

                    return (tag == "input" && attr == "value") || AttributesRemovedIfEmpty.ContainsKey(attr);
                }
            }

            if (!settings.AttributesCaseSensitive && xmlNamespaceCount == 0)
            {
                attribute.Name = attr;
            }

            return false;
        }

        private static bool IsJavaScript(HtmlElement element)
        {
            if (!element.Name.Equals("script", StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }
            return IsAttributeValueJs(element.FindAttribute("type")?.Value);
        }

        private static bool IsCssStyle(HtmlElement element)
        {
            if (!element.Name.Equals("style", StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }
            return IsAttributeValueCss(element.FindAttribute("type")?.Value);
        }

        private static bool IsAttributeValueCss(string value)
        {
            return string.IsNullOrEmpty(value) || value.Equals("text/css", StringComparison.OrdinalIgnoreCase);
        }

        private static bool IsUriTypeAttribute(string tag, string attr)
        {
            // Code from https://github.com/kangax/html-minifier/blob/gh-pages/src/htmlminifier.js
            return ((tag == "a" || tag == "area" || tag == "base") && attr == "href") ||
                   (tag == "img" && (attr == "src" || attr == "longdesc" || attr == "usemap")) ||
                   (tag == "object" &&
                    (attr == "classid" || attr == "codebase" || attr == "data" || attr == "usemap")) ||
                   (tag == "q" && attr == "cite") ||
                   (tag == "blockquote" && attr == "cite") ||
                   ((tag == "ins" || tag == "del") && attr == "cite") ||
                   (tag == "form" && attr == "action") ||
                   (tag == "input" && (attr == "src" || attr == "usemap")) ||
                   (tag == "head" && attr == "profile") ||
                   (tag == "script" && (attr == "src" || attr == "for"));
        }

        private static bool IsAttributeValueJs(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                return true;
            }

            var text = value.Split(';')[0].ToLowerInvariant();
            switch (text)
            {
                case "text/javascript":
                case "text/ecmascript":
                case "text/jscript":
                case "application/javascript":
                case "application/x-javascript":
                case "application/ecmascript":
                    return true;
            }
            return false;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\Html\HtmlMinifier.cs(310,30): error CS0165: Use of unassigned local variable 'previousElement'
######################################################################


######################################################################
Nr: 11 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\JSParser.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using Kooboo.Lib.NUglify.JavaScript;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript
{
    public enum ScriptVersion
    {
        None = 0,
        EcmaScript5,
        EcmaScript6,
    }

    /// <summary>
    /// Class used to parse JavaScript source code into an abstract syntax tree.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
    public class JSParser
    {
        #region private fields

        private static bool[] s_skippableTokens = InitializeSkippableTokens();

        private GlobalScope m_globalScope;
        private JSScanner m_scanner;
        private SourceContext m_currentToken;

        private bool m_newModule;

        private CodeSettings m_settings;// = null;

        private bool m_foundEndOfLine;
        private IList<SourceContext> m_importantComments;

        private Dictionary<string, LabelInfo> m_labelInfo;

        #endregion

        #region private properties

        private SourceContext CurrentPositionContext
        {
            get
            {
                return m_currentToken.FlattenToStart();
            }
        }

        #endregion

        #region public properties

        // we're going to copy the debug lookups from the settings passed to us,
        // then use this collection, because we might programmatically add more
        // as we process the code, and we don't want to change the settings object.
        public ICollection<string> DebugLookups { get; private set; }

        public ScriptVersion ParsedVersion { get; private set; }

        public CodeSettings Settings
        {
            get
            {
                // if it's null....
                if (m_settings == null)
                {
                    // just use the default settings
                    m_settings = new CodeSettings();
                }
                return m_settings;
            }
            set
            {
                // if setting null, use the default settings object
                m_settings = value ?? new CodeSettings();
            }
        }

        /// <summary>
        /// Gets or sets a TextWriter instance to which raw preprocessed input will be
        /// written when Parse is called.
        /// </summary>
        public TextWriter EchoWriter { get; set; }

        public GlobalScope GlobalScope
        {
            get
            {
                // if we don't have one yet, create a new one
                if (m_globalScope == null)
                {
                    m_globalScope = new GlobalScope(m_settings);
                }

                return m_globalScope;
            }
            set
            {
                // if we are setting the global scope, we are using a shared global scope.
                m_globalScope = value;

                // mark all existing child scopes as existing so we don't go through
                // them again and re-optimize
                if (m_globalScope != null)
                {
                    foreach (var childScope in m_globalScope.ChildScopes)
                    {
                        childScope.Existing = true;
                    }
                }
            }
        }

        /// <summary>
        /// Gets the array of timing points from a Parse run
        /// </summary>
        private long[] m_timingPoints;
        public IList<long> TimingPoints { get { return m_timingPoints; } }

        #endregion

        #region public events

        /// <summary>
        /// Event sent whenever an error or warning is encountered during parsing
        /// </summary>
        public event EventHandler<ContextErrorEventArgs> CompilerError;

        /// <summary>
        /// Sent for undefined references found during parsing
        /// </summary>
        public event EventHandler<UndefinedReferenceEventArgs> UndefinedReference;

        #endregion

        #region public constructor

        /// <summary>
        /// Creates an instance of the JavaScript parser object
        /// </summary>
        public JSParser()
        {
            m_importantComments = new List<SourceContext>();
            m_labelInfo = new Dictionary<string, LabelInfo>();
        }

        /// <summary>
        /// Creates an instance of the JSParser class that can be used to parse the given source code.
        /// </summary>
        /// <param name="source">Source code to parse.</param>
        [Obsolete("This Constructor will be removed in version 6. Please use the default constructor.", false)]
        public JSParser(string source) : this()
        {
            // set the source now using an empty context
            SetDocumentContext(new DocumentContext(source));
        }

        #endregion

        #region public methods

        /// <summary>
        /// Parse the given source context into an abstract syntax tree
        /// </summary>
        /// <param name="sourceContext">source code with context</param>
        /// <returns>a Block object representing the series of statements in abstract syntax tree form</returns>
        public BlockStatement Parse(DocumentContext sourceContext)
        {
            SetDocumentContext(sourceContext);

            // if a settings object hasn't been set yet, create a default settings object now
            if (m_settings == null)
            {
                m_settings = new CodeSettings();
            }

            // clear out some collections in case there was stuff left over from
            // a previous parse run
            m_importantComments.Clear();
            m_labelInfo.Clear();

            return InternalParse();
        }

        /// <summary>
        /// Parse the given source with context into an abstract syntax tree using the given settings
        /// </summary>
        /// <param name="sourceContext">source code with context</param>
        /// <param name="settings">settings to use for the parse operation</param>
        /// <returns>a Block object representing the series of statements in abstract syntax tree form</returns>
        public BlockStatement Parse(DocumentContext sourceContext, CodeSettings settings)
        {
            this.Settings = settings;
            return Parse(sourceContext);
        }

        /// <summary>
        /// Parse the given source into an abstract syntax tree with no context
        /// </summary>
        /// <param name="source">source code with no context</param>
        /// <returns>a Block object representing the series of statements in abstract syntax tree form</returns>
        public BlockStatement Parse(string source)
        {
            return Parse(new DocumentContext(source));
        }

        /// <summary>
        /// Parse the given source into an abstract syntax tree using the given settings
        /// </summary>
        /// <param name="source">source code to parse</param>
        /// <param name="settings">settings to use for the parse operation</param>
        /// <returns>a Block object representing the series of statements in abstract syntax tree form</returns>
        public BlockStatement Parse(string source, CodeSettings settings)
        {
            this.Settings = settings;
            return Parse(source);
        }

        /// <summary>
        /// Parse the source code using the given settings, getting back an abstract syntax tree Block node as the root
        /// representing the list of statements in the source code.
        /// </summary>
        /// <param name="settings">code settings to use to process the source code</param>
        /// <returns>root Block node representing the top-level statements</returns>
        [Obsolete("This method will be removed in version 6. Please use the default constructor and use a Parse override that is passed the source.", false)]
        public BlockStatement Parse(CodeSettings settings)
        {
            if (m_scanner == null)
            {
                throw new InvalidOperationException(JScript.NoSource);
            }

            // initialize the scanner with our settings
            // make sure the RawTokens setting is OFF or we won't be able to create our AST
            // save the settings
            // if we are passed null, just create a default settings object
            m_settings = settings = settings ?? new CodeSettings();

            return InternalParse();
        }

        #endregion

        #region common parse entry point

        /// <summary>
        /// Parse the document source using the scanner and settings that have all been set up already
        /// through various combinations of constructor/properties/Parse methods.
        /// </summary>
        /// <returns>Parsed Block node</returns>
        private BlockStatement InternalParse()
        {
            // if the settings list is not null, use it to initialize a new list
            // with the same settings. If it is null, initialize an empty list 
            // because we already determined that we want to strip debug statements,
            // and the scanner might add items to the list as it scans the source.
            DebugLookups = new HashSet<string>(m_settings.DebugLookupCollection);

            // pass our list to the scanner -- it might add more as we encounter special comments
            m_scanner.DebugLookupCollection = DebugLookups;

            m_scanner.AllowEmbeddedAspNetBlocks = m_settings.AllowEmbeddedAspNetBlocks;
            m_scanner.IgnoreConditionalCompilation = m_settings.IgnoreConditionalCompilation;

            // set any defines
            m_scanner.UsePreprocessorDefines = !m_settings.IgnorePreprocessorDefines;
            if (m_scanner.UsePreprocessorDefines)
            {
                m_scanner.SetPreprocessorDefines(m_settings.PreprocessorValues);
            }

            // if we want to strip debug statements, let's also strip ///#DEBUG comment
            // blocks for legacy reasons. ///#DEBUG will get stripped ONLY is this
            // flag is true AND the name "DEBUG" is not in the preprocessor defines.
            // Alternately, we will keep those blocks in the output is this flag is
            // set to false OR we define "DEBUG" in the preprocessor defines.
            m_scanner.StripDebugCommentBlocks = m_settings.StripDebugStatements;

            // assume ES5 unless we find ES6-specific constructs
            ParsedVersion = ScriptVersion.EcmaScript5;

            // make sure we initialize the global scope's strict mode to our flag, whether or not it
            // is true. This means if the setting is false, we will RESET the flag to false if we are 
            // reusing the scope and a previous Parse call had code that set it to strict with a 
            // program directive. 
            GlobalScope.UseStrict = m_settings.StrictMode;

            // make sure the global scope knows about our known global names
            GlobalScope.SetAssumedGlobals(m_settings);

            // start of a new module
            m_newModule = true;

            var timePoints = m_timingPoints = new long[9];
            var timeIndex = timePoints.Length;
            var stopWatch = new Stopwatch();
            stopWatch.Start();

            // get the first token.
            GetNextToken();

            BlockStatement scriptBlock = null;
            BlockStatement returnBlock = null;
            switch (m_settings.SourceMode)
            {
                case JavaScriptSourceMode.Program:
                    // simply parse a block of statements.
                    // however, when parsing this block, we mght determine it's really part of
                    // a larger structure, and we could return a different block that we would need
                    // to continue processing.
                    scriptBlock = returnBlock = ParseStatements(new BlockStatement(CurrentPositionContext)
                        {
                            EnclosingScope = this.GlobalScope
                        });
                    break;

                case JavaScriptSourceMode.Module:
                    // an implicit module as referenced by an import statement.
                    // create a root block with the global scope, add a module with its module body,
                    // then parse the input as statements into the module body.
                    returnBlock = scriptBlock = new BlockStatement(CurrentPositionContext)
                        {
                            EnclosingScope = this.GlobalScope
                        };
                    var module = new ModuleDeclaration(CurrentPositionContext)
                        {
                            IsImplicit = true,
                            Body = new BlockStatement(CurrentPositionContext)
                                {
                                    IsModule = true
                                }
                        };
                    scriptBlock.Append(module);

                    // we just created an implicit ES6 module, so we are already parsing as ES6
                    ParsedVersion = ScriptVersion.EcmaScript6;

                    // we don't need to worry about this function returning a different block, because
                    // we've already created the module structure.
                    ParseStatements(module.Body);
                    break;

                case JavaScriptSourceMode.Expression:
                    // create a block, get the first token, add in the parse of a single expression, 
                    // and we'll go fron there.
                    returnBlock = scriptBlock = new BlockStatement(CurrentPositionContext)
                        {
                            EnclosingScope = this.GlobalScope
                        };
                    try
                    {
                        var expr = ParseExpression();
                        if (expr != null)
                        {
                            scriptBlock.Append(expr);
                            scriptBlock.UpdateWith(expr.Context);
                        }
                    }
                    catch (EndOfStreamException)
                    {
                        Debug.WriteLine("EOF");
                    }
                    break;

                case JavaScriptSourceMode.EventHandler:
                    // we're going to create the global block, add in a function expression with a single
                    // parameter named "event", and then we're going to parse the input as the body of that
                    // function expression. We're going to resolve the global block, but only return the body
                    // of the function.
                    scriptBlock = new BlockStatement(CurrentPositionContext)
                        {
                            EnclosingScope = this.GlobalScope
                        };

                    var parameters = new AstNodeList(CurrentPositionContext);
                    parameters.Append(new ParameterDeclaration(CurrentPositionContext)
                        {
                            Binding = new BindingIdentifier(CurrentPositionContext)
                            {
                                Name = "event",
                                RenameNotAllowed = true
                            }
                        });

                    var funcExpression = new FunctionObject(CurrentPositionContext)
                        {
                            FunctionType = FunctionType.Expression,
                            ParameterDeclarations = parameters,
                            Body = new BlockStatement(CurrentPositionContext)
                        };
                    scriptBlock.Append(funcExpression);
                    ParseFunctionBody(funcExpression.Body);

                    // but we ONLY want to return the body
                    returnBlock = funcExpression.Body;
                    break;

                default:
                    Debug.Fail("Unexpected source mode enumeration");
                    return null;
            }

            timePoints[--timeIndex] = stopWatch.ElapsedTicks;

            // resolve everything
            ResolutionVisitor.Apply(scriptBlock, GlobalScope, this);
            timePoints[--timeIndex] = stopWatch.ElapsedTicks;

            if (Settings.AmdSupport)
            {
                // we're doing some AMD support. At this time, walk through the top-level
                // statements and if there are any duplicate define(name... calls, remove all
                // but the last one.
                RemoveDuplicateDefines(scriptBlock);
            }

            if (scriptBlock != null && Settings.MinifyCode && !Settings.PreprocessOnly)
            {
                // this visitor doesn't just reorder scopes. It also combines the adjacent var variables,
                // unnests blocks, identifies prologue directives, and sets the strict mode on scopes. 
                ReorderScopeVisitor.Apply(scriptBlock, this);

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // analyze the entire node tree (needed for hypercrunch)
                // root to leaf (top down)
                var analyzeVisitor = new AnalyzeNodeVisitor(this);
                scriptBlock.Accept(analyzeVisitor);

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // analyze the scope chain (also needed for hypercrunch)
                // root to leaf (top down)
                GlobalScope.AnalyzeScope();

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // if we want to crunch any names....
                if (m_settings.LocalRenaming != LocalRenaming.KeepAll
                    && m_settings.IsModificationAllowed(TreeModifications.LocalRenaming))
                {
                    // then do a top-down traversal of the scope tree. For each field that had not
                    // already been crunched (globals and outers will already be crunched), crunch
                    // the name with a crunch iterator that does not use any names in the verboten set.
                    GlobalScope.AutoRenameFields();
                }

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // if we want to evaluate literal expressions, do so now
                if (m_settings.EvalLiteralExpressions)
                {
                    var visitor = new EvaluateLiteralVisitor(this);
                    scriptBlock.Accept(visitor);
                }

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // make the final cleanup pass
                FinalPassVisitor.Apply(scriptBlock, m_settings);

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // we want to walk all the scopes to make sure that any generated
                // variables that haven't been crunched have been assigned valid
                // variable names that don't collide with any existing variables.
                GlobalScope.ValidateGeneratedNames();

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;
                stopWatch.Stop();
            }

            // mark all child scopes under the global scope as existing so we don't go and re-optimize
            // them again should we parse another piece of source code using the same parser
            foreach (var childScope in GlobalScope.ChildScopes)
            {
                childScope.Existing = true;
            }

            // if the return block is not the entire script block, then we don't want to include
            // any thing we must've generated in the process of building our code. Take the scope
            // from the parent, but break the tree relationship.
            if (returnBlock != scriptBlock)
            {
                returnBlock.EnclosingScope = returnBlock.Parent.EnclosingScope;
                returnBlock.Parent = null;
            }

            return returnBlock;
        }

        /// <summary>
        /// Remove duplicate define calls, defined as defines with the same module name specified as the first
        /// parameter, if it's a string literal. Only the last define with a given name is preserved.
        /// </summary>
        /// <param name="scriptBlock">script block to remove defines from; not recursed</param>
        private static void RemoveDuplicateDefines(BlockStatement scriptBlock)
        {
            var defines = new HashSet<string>();

            // walk backwards so we keep the last one
            for(var ndx = scriptBlock.Count - 1; ndx >= 0; --ndx)
            {
                var callNode = scriptBlock[ndx] as CallExpression;
                if (callNode != null)
                {
                    if (callNode.Function.IsGlobalNamed("define") 
                        && callNode.Arguments.IfNotNull(args => args.Count) > 0)
                    {
                        var firstArg = callNode.Arguments[0] as ConstantWrapper;
                        if (firstArg != null && firstArg.PrimitiveType == PrimitiveType.String)
                        {
                            var moduleName = firstArg.ToString();
                            if (!defines.Add(moduleName))
                            {
                                // couldn't add the name to the set -- must be a dupe!
                                // remove it altogether
                                scriptBlock.RemoveAt(ndx);
                            }
                        }
                    }
                }
            }
        }

        #endregion

        #region event methods

        internal void OnUndefinedReference(UndefinedReference ex)
        {
            if (UndefinedReference != null)
            {
                UndefinedReference(this, new UndefinedReferenceEventArgs(ex));
            }
        }

        internal void OnCompilerError(UglifyError se)
        {
            if (CompilerError != null && !m_settings.IgnoreAllErrors)
            {
                // format the error code
                if (m_settings != null && !m_settings.IgnoreErrorCollection.Contains(se.ErrorCode))
                {
                    CompilerError(this, new ContextErrorEventArgs()
                        {
                            Error = se
                        });
                }
            }
        }

        #endregion

        #region ParseStatements

        //---------------------------------------------------------------------------------------
        // ParseStatements
        //
        // statements :
        //   <empty> |
        //   statement statements
        //
        //---------------------------------------------------------------------------------------
        private BlockStatement ParseStatements(BlockStatement block)
        {
            // by default we should return the block we were passed in.
            // the only time we might return a different block is if we decide later on if
            // this block is really an implicit module body, in which case we will return a
            // different block that contains the module declaration with the passed-in block
            // as the body.
            var returnBlock = block;
            try
            {
                var possibleDirectivePrologue = true;
                int lastEndPosition = m_currentToken.EndPosition;
                while (m_currentToken.IsNot(JSToken.EndOfFile))
                {
                    AstNode ast = null;
                    // parse a statement -- pass true because we really want a SourceElement,
                    // which is a Statement OR a FunctionDeclaration. Technically, FunctionDeclarations
                    // are not statements!
                    ast = ParseStatement(true);

                    // if we are still possibly looking for directive prologues
                    if (possibleDirectivePrologue)
                    {
                        var constantWrapper = ast as ConstantWrapper;
                        if (constantWrapper != null && constantWrapper.PrimitiveType == PrimitiveType.String)
                        {
                            if (!(constantWrapper is DirectivePrologue))
                            {
                                // use a directive prologue node instead
                                ast = new DirectivePrologue(constantWrapper.Value.ToString(), ast.Context)
                                    {
                                        MayHaveIssues = constantWrapper.MayHaveIssues
                                    };
                            }
                        }
                        else if (!m_newModule)
                        {
                            // nope -- no longer finding directive prologues
                            possibleDirectivePrologue = false;
                        }
                    }
                    else if (m_newModule)
                    {
                        // we aren't looking for directive prologues anymore, but we did scan
                        // into a new module after that last AST, so reset the flag because that
                        // new module might have directive prologues for next time
                        possibleDirectivePrologue = true;
                    }

                    if (ast != null)
                    {
                        // append the statement to the program
                        block.Append(ast);

                        // if this was an export statement, then we know the block as a module.
                        // if we didn't know that before, then we have some conversion to take
                        // care of.
                        if (ast is ExportStatement && !block.IsModule)
                        {
                            // this block will be the module body
                            block.IsModule = true;

                            // should only happen if we are processing a root program
                            if (block.Parent == null)
                            {
                                // create a new block that has the global scope and remove the
                                // global scope from this block
                                returnBlock = new BlockStatement(block.Context.Clone())
                                    {
                                        EnclosingScope = block.EnclosingScope
                                    };
                                block.EnclosingScope = null;

                                // add a new implicit module declaration to the new global block, with the block
                                // we've been processing as its body. we'll return the new global block.
                                returnBlock.Append(new ModuleDeclaration(new SourceContext(m_currentToken.Document))
                                    {
                                        IsImplicit = true,
                                        Body = block,
                                    });
                            }
                        }

                        // set the last end position to be the start of the current token.
                        // if we parse the next statement and the end is still the start, we know
                        // something is up and might get into an infinite loop.
                        lastEndPosition = m_currentToken.EndPosition;
                    }
                    else if (!m_scanner.IsEndOfFile && m_currentToken.StartLinePosition == lastEndPosition)
                    {
                        // didn't parse a statement, we're not at the EOF, and we didn't move
                        // anywhere in the input stream. If we just keep looping around, we're going
                        // to get into an infinite loop. Break it.
                        m_currentToken.HandleError(JSError.ApplicationError, true);
                        break;
                    }
                }

                AppendImportantComments(block);

            }
            catch (EndOfStreamException)
            {
                // we're done
            }

            block.UpdateWith(CurrentPositionContext);
            return returnBlock;
        }

        //---------------------------------------------------------------------------------------
        // ParseStatement
        //
        //  OptionalStatement:
        //    Statement |
        //    <empty>
        //
        //  Statement :
        //    Block |
        //  VariableStatement |
        //  EmptyStatement |
        //  ExpressionStatement |
        //  IfStatement |
        //  IterationStatement |
        //  ContinueStatement |
        //  BreakStatement |
        //  ReturnStatement |
        //  WithStatement |
        //  LabeledStatement |
        //  SwitchStatement |
        //  ThrowStatement |
        //  TryStatement |
        //  FunctionDeclaration
        //
        // IterationStatement :
        //    'for' '(' ForLoopControl ')' |                  ===> ForStatement
        //    'do' Statement 'while' '(' Expression ')' |     ===> DoStatement
        //    'while' '(' Expression ')' Statement            ===> WhileStatement
        //
        //---------------------------------------------------------------------------------------

        // ParseStatement deals with the end of statement issue (EOL vs ';') so if any of the
        // ParseXXX routine does it as well, it should return directly from the switch statement
        // without any further execution in the ParseStatement
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private AstNode ParseStatement(bool fSourceElement, bool skipImportantComment = false)
        {
            AstNode statement = null;

            // if we want to skip important comments, now is a good time to clear anything we may 
            // have picked up already.
            if (skipImportantComment)
            {
                m_importantComments.Clear();
            }

            if (m_importantComments.Count > 0
                && m_settings.PreserveImportantComments
                && m_settings.IsModificationAllowed(TreeModifications.PreserveImportantComments))
            {
                // we have at least one important comment before the upcoming statement.
                // pop the first important comment off the queue, return that node instead.
                // don't advance the token -- we'll probably be coming back again for the next one (if any)
                statement = new ImportantComment(m_importantComments[0]);
                m_importantComments.RemoveAt(0);
            }
            else
            {
                switch (m_currentToken.Token)
                {
                    case JSToken.EndOfFile:
                        ReportError(JSError.ErrorEndOfFile);
                        return null; // abort parsing, get back to the main parse routine

                    case JSToken.Semicolon:
                        // make an empty statement
                        statement = new EmptyStatement(m_currentToken.Clone());
                        GetNextToken();
                        return statement;

                    case JSToken.RightCurly:
                        ReportError(JSError.SyntaxError);
                        GetNextToken();
                        break;

                    case JSToken.LeftCurly:
                        return ParseBlock();

                    case JSToken.Debugger:
                        return ParseDebuggerStatement();

                    case JSToken.Var:
                    case JSToken.Const:
                    case JSToken.Let:
                        return ParseVariableStatement();

                    case JSToken.If:
                        return ParseIfStatement();

                    case JSToken.For:
                        return ParseForStatement();

                    case JSToken.Do:
                        return ParseDoStatement();

                    case JSToken.While:
                        return ParseWhileStatement();

                    case JSToken.Continue:
                        return ParseContinueStatement();

                    case JSToken.Break:
                        return ParseBreakStatement();

                    case JSToken.Return:
                        return ParseReturnStatement();

                    case JSToken.With:
                        return ParseWithStatement();

                    case JSToken.Switch:
                        return ParseSwitchStatement();

                    case JSToken.Throw:
                        return ParseThrowStatement();

                    case JSToken.Try:
                        return ParseTryStatement();

                    case JSToken.Async:
                        // Treat `async(` as if its a normal expression
                        if (PeekToken() == JSToken.LeftParenthesis)
                        {
                            goto default;
                        }
                        else
                        {
                            // Treat 'async function' as a function declaration
                            goto case (JSToken.Function);
                        }
                    case JSToken.Function:
                        {
                            // parse a function declaration
                            var function = ParseFunction(FunctionType.Declaration, m_currentToken.Clone());
                            function.IsSourceElement = fSourceElement;
                            return function;
                        }
                    case JSToken.Class:
                        return ParseClassNode(ClassType.Declaration);

                    case JSToken.Else:
                        ReportError(JSError.InvalidElse);
                        GetNextToken();
                        break;

                    case JSToken.ConditionalCommentStart:
                        return ParseStatementLevelConditionalComment(fSourceElement);

                    case JSToken.ConditionalCompilationOn:
                        var ccOn = new ConditionalCompilationOn(m_currentToken.Clone());
                        GetNextToken();
                        return ccOn;

                    case JSToken.ConditionalCompilationSet:
                        return ParseConditionalCompilationSet();

                    case JSToken.ConditionalCompilationIf:
                        return ParseConditionalCompilationIf(false);

                    case JSToken.ConditionalCompilationElseIf:
                        return ParseConditionalCompilationIf(true);

                    case JSToken.ConditionalCompilationElse:
                        var elseStatement = new ConditionalCompilationElse(m_currentToken.Clone());
                        GetNextToken();
                        return elseStatement;

                    case JSToken.ConditionalCompilationEnd:
                        var endStatement = new ConditionalCompilationEnd(m_currentToken.Clone());
                        GetNextToken();
                        return endStatement;

                    case JSToken.Import:
                        // import can't be an identifier name, so it must be an import statement
                        return ParseImport();

                    case JSToken.Export:
                        // export can't be an identifier name, so it must be an export statement
                        return ParseExport();

                    case JSToken.Identifier:
                        if (m_currentToken.Is("module"))
                        {
                            goto case JSToken.Module;
                        }
                        goto default;

                    case JSToken.Module:
                        if (PeekCanBeModule())
                        {
                            return ParseModule();
                        }
                        goto default;

                    default:
                        statement = ParseExpressionStatement(fSourceElement);
                        break;
                }
            }

            return statement;
        }

        private AstNode ParseExpressionStatement(bool fSourceElement)
        {
            bool bAssign;
            var isNewModule = m_newModule;
            var statement = ParseUnaryExpression(out bAssign, false);
            if (statement != null)
            {
                // look for labels
                var lookup = statement as LookupExpression;
                if (lookup != null && m_currentToken.Is(JSToken.Colon))
                {
                    statement = ParseLabeledStatement(lookup, fSourceElement);
                }
                else
                {
                    // finish off the expression using the unary as teh starting point
                    statement = ParseExpression(statement, false, bAssign, JSToken.None);

                    // if we just started a new module and this statement happens to be an expression statement...
                    if (isNewModule && statement.IsExpression)
                    {
                        // see if it's a constant wrapper
                        var constantWrapper = statement as ConstantWrapper;
                        if (constantWrapper != null && constantWrapper.PrimitiveType == PrimitiveType.String)
                        {
                            // we found a string constant expression statement right after the start of a new
                            // module. Let's make it a DirectivePrologue if it isn't already
                            if (!(statement is DirectivePrologue))
                            {
                                statement = new DirectivePrologue(constantWrapper.Value.ToString(), constantWrapper.Context)
                                {
                                    MayHaveIssues = constantWrapper.MayHaveIssues
                                };
                            }
                        }
                    }

                    var binaryOp = statement as BinaryExpression;
                    if (binaryOp != null
                        && (binaryOp.OperatorToken == JSToken.Equal || binaryOp.OperatorToken == JSToken.StrictEqual))
                    {
                        // an expression statement with equality operator? Doesn't really do anything.
                        // Did the developer intend this to be an assignment operator instead? Low-pri warning.
                        binaryOp.OperatorContext.IfNotNull(c => c.HandleError(JSError.SuspectEquality, false));
                    }

                    lookup = statement as LookupExpression;
                    if (lookup != null
                        && lookup.Name.StartsWith("<%=", StringComparison.Ordinal) && lookup.Name.EndsWith("%>", StringComparison.Ordinal))
                    {
                        // single lookup, but it's actually one or more ASP.NET blocks.
                        // convert back to an asp.net block node
                        statement = new AspNetBlockNode(statement.Context)
                        {
                            AspNetBlockText = lookup.Name
                        };
                    }

                    var aspNetBlock = statement as AspNetBlockNode;
                    if (aspNetBlock != null && m_currentToken.Is(JSToken.Semicolon))
                    {
                        aspNetBlock.IsTerminatedByExplicitSemicolon = true;
                        statement.IfNotNull(s => s.TerminatingContext = m_currentToken.Clone());
                        GetNextToken();
                    }

                    // we just parsed an expression statement. Now see if we have an appropriate
                    // semicolon to terminate it.
                    ExpectSemicolon(statement);
                }
            }
            else
            {
                // couldn't parse a statement and couldn't parse an expression; skip it
                // TODO: error node?
                GetNextToken();
            }

            return statement;
        }

        private LabeledStatement ParseLabeledStatement(LookupExpression lookup, bool fSourceElement)
        {
            // can be a label
            var id = lookup.Name;
            var colonContext = m_currentToken.Clone();

            LabelInfo labelInfo;
            var removeInfo = true;
            if (m_labelInfo.TryGetValue(id, out labelInfo))
            {
                // already exists! throw an error and mark this label as having an error
                labelInfo.HasIssues = true;
                removeInfo = false;
                lookup.Context.HandleError(JSError.BadLabel, true);
            }
            else
            {
                // zero-based nest level corresponds to how many labels we are working with
                // so far. and a zero reference count
                labelInfo = new LabelInfo { NestLevel = m_labelInfo.Count, RefCount = 0 };
                m_labelInfo.Add(id, labelInfo);
            }

            GetNextToken();
            LabeledStatement labeledStatement;
            if (m_currentToken.IsNot(JSToken.EndOfFile))
            {
                // ignore any important comments between the label and its statement
                // because important comments are treated like statements, and we want
                // to make sure the label is attached to the right REAL statement.
                labeledStatement = new LabeledStatement(lookup.Context.Clone())
                {
                    Label = id,
                    LabelContext = lookup.Context,
                    LabelInfo = labelInfo,
                    ColonContext = colonContext,
                    Statement = ParseStatement(fSourceElement, true)
                };
            }
            else
            {
                // end of the file!
                // just pass null for the labeled statement
                labeledStatement = new LabeledStatement(lookup.Context.Clone())
                {
                    Label = id,
                    LabelContext = lookup.Context,
                    LabelInfo = labelInfo,
                    ColonContext = colonContext,
                };
            }

            if (removeInfo)
            {
                m_labelInfo.Remove(id);
            }

            return labeledStatement;
        }

        private AstNode ParseStatementLevelConditionalComment(bool fSourceElement)
        {
            SourceContext context = m_currentToken.Clone();
            ConditionalCompilationComment conditionalComment = new ConditionalCompilationComment(context);

            GetNextToken();
            while (m_currentToken.IsNot(JSToken.ConditionalCommentEnd) && m_currentToken.IsNot(JSToken.EndOfFile))
            {
                // if we get ANOTHER start token, it's superfluous and we should ignore it.
                // otherwise parse another statement and keep going
                if (m_currentToken.Is(JSToken.ConditionalCommentStart))
                {
                    GetNextToken();
                }
                else
                {
                    conditionalComment.Append(ParseStatement(fSourceElement));
                }
            }

            GetNextToken();

            // if the conditional comment is empty (for whatever reason), then
            // we don't want to return anything -- we found nothing.
            return conditionalComment.Statements.Count > 0 ? conditionalComment : null;
        }

        private ConditionalCompilationSet ParseConditionalCompilationSet()
        {
            SourceContext context = m_currentToken.Clone();
            string variableName = null;
            AstNode value = null;
            GetNextToken();
            if (m_currentToken.Is(JSToken.ConditionalCompilationVariable))
            {
                context.UpdateWith(m_currentToken);
                variableName = m_currentToken.Code;
                GetNextToken();
                if (m_currentToken.Is(JSToken.Assign))
                {
                    context.UpdateWith(m_currentToken);
                    GetNextToken();
                    value = ParseExpression(false);
                    if (value != null)
                    {
                        context.UpdateWith(value.Context);
                    }
                    else
                    {
                        m_currentToken.HandleError(JSError.ExpressionExpected);
                    }
                }
                else
                {
                    m_currentToken.HandleError(JSError.NoEqual);
                }
            }
            else
            {
                m_currentToken.HandleError(JSError.NoIdentifier);
            }

            return new ConditionalCompilationSet(context)
                {
                    VariableName = variableName,
                    Value = value
                };
        }

        private ConditionalCompilationStatement ParseConditionalCompilationIf(bool isElseIf)
        {
            SourceContext context = m_currentToken.Clone();
            AstNode condition = null;
            GetNextToken();
            if (m_currentToken.Is(JSToken.LeftParenthesis))
            {
                context.UpdateWith(m_currentToken);
                GetNextToken();
                condition = ParseExpression(false);
                if (condition != null)
                {
                    context.UpdateWith(condition.Context);
                }
                else
                {
                    m_currentToken.HandleError(JSError.ExpressionExpected);
                }

                if (m_currentToken.Is(JSToken.RightParenthesis))
                {
                    context.UpdateWith(m_currentToken);
                    GetNextToken();
                }
                else
                {
                    m_currentToken.HandleError(JSError.NoRightParenthesis);
                }
            }
            else
            {
                m_currentToken.HandleError(JSError.NoLeftParenthesis);
            }

            if (isElseIf)
            {
                return new ConditionalCompilationElseIf(context)
                    {
                        Condition = condition
                    };
            }

            return new ConditionalCompilationIf(context)
                {
                    Condition = condition
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseBlock
        //
        //  Block :
        //    '{' OptionalStatements '}'
        //---------------------------------------------------------------------------------------
        private BlockStatement ParseBlock()
        {
            // set the force-braces property to true because we are assuming this is only called
            // when we encounter a left-brace and we will want to keep it going forward. If we are optimizing
            // the code, we will reset these properties as we encounter them so that unneeded curly-braces 
            // can be removed.
            BlockStatement codeBlock = new BlockStatement(m_currentToken.Clone())
                {
                    ForceBraces = true
                };
            codeBlock.BraceOnNewLine = m_foundEndOfLine;
            GetNextToken();

            while (m_currentToken.IsNot(JSToken.RightCurly) && m_currentToken.IsNot(JSToken.EndOfFile))
            {
                // pass false because we really only want Statements, and FunctionDeclarations
                // are technically not statements. We'll still handle them, but we'll issue a warning.
                codeBlock.Append(ParseStatement(false));
            }

            // make sure any important comments before the closing brace are kept
            AppendImportantComments(codeBlock);

            if (m_currentToken.IsNot(JSToken.RightCurly))
            {
                ReportError(JSError.NoRightCurly);
                if (m_currentToken.Is(JSToken.EndOfFile))
                {
                    ReportError(JSError.ErrorEndOfFile);
                }
            }

            codeBlock.TerminatingContext = m_currentToken.Clone();
            // update the block context
            codeBlock.Context.UpdateWith(m_currentToken);
            GetNextToken();
            return codeBlock;
        }

        //---------------------------------------------------------------------------------------
        // ParseDebuggerStatement
        //
        //  DebuggerStatement :
        //    'debugger'
        //
        // This function may return a null AST under error condition. The caller should handle
        // that case.
        // Regardless of error conditions, on exit the parser points to the first token after
        // the debugger statement
        //---------------------------------------------------------------------------------------
        private AstNode ParseDebuggerStatement()
        {
            // clone the current context and skip it
            var node = new DebuggerNode(m_currentToken.Clone());
            GetNextToken();

            // this token can only be a stand-alone statement
            ExpectSemicolon(node);

            // return the new AST object
            return node;
        }

        //---------------------------------------------------------------------------------------
        // ParseVariableStatement
        //
        //  VariableStatement :
        //    'var' VariableDeclarationList
        //    or
        //    'const' VariableDeclarationList
        //    or
        //    'let' VariableDeclarationList
        //
        //  VariableDeclarationList :
        //    VariableDeclaration |
        //    VariableDeclaration ',' VariableDeclarationList
        //
        //  VariableDeclaration :
        //    Binding |
        //    Binding Initializer
        //
        //  Initializer :
        //    <empty> |
        //    '=' AssignmentExpression
        //---------------------------------------------------------------------------------------
        private AstNode ParseVariableStatement()
        {
            // create the appropriate statement: var- or const-statement
            Declaration varList;
            if (m_currentToken.Is(JSToken.Var))
            {
                varList = new VarDeclaration(m_currentToken.Clone())
                    {
                        StatementToken = m_currentToken.Token,
                        KeywordContext = m_currentToken.Clone()
                    };
            }
            else if (m_currentToken.IsEither(JSToken.Const, JSToken.Let))
            {
                if (m_currentToken.Is(JSToken.Const) && m_settings.ConstStatementsMozilla)
                {
                    varList = new ConstStatement(m_currentToken.Clone())
                        {
                            StatementToken = m_currentToken.Token,
                            KeywordContext = m_currentToken.Clone()
                        };
                }
                else
                {
                    // this is EcmaScript6-specific statement
                    ParsedVersion = ScriptVersion.EcmaScript6;
                    varList = new LexicalDeclaration(m_currentToken.Clone())
                        {
                            StatementToken = m_currentToken.Token,
                            KeywordContext = m_currentToken.Clone()
                        };
                }
            }
            else
            {
                Debug.Fail("shouldn't get here");
                return null;
            }

            do
            {
                GetNextToken();
                var varDecl = ParseVarDecl(JSToken.None);
                if (varDecl != null)
                {
                    varList.Append(varDecl);
                    varList.Context.UpdateWith(varDecl.Context);
                }
            }
            while (m_currentToken.Is(JSToken.Comma));

            ExpectSemicolon(varList);
            return varList;
        }

        private VariableDeclaration ParseVarDecl(JSToken inToken)
        {
            SourceContext context = m_currentToken.Clone();
            VariableDeclaration varDecl = null;
            var binding = ParseBinding();
            if (binding != null)
            {
                SourceContext assignContext = null;
                AstNode initializer = null;

                bool ccSpecialCase = false;
                bool ccOn = false;

                if (m_currentToken.Is(JSToken.ConditionalCommentStart))
                {
                    ccSpecialCase = true;

                    GetNextToken();
                    if (m_currentToken.Is(JSToken.ConditionalCompilationOn))
                    {
                        GetNextToken();
                        if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                        {
                            // forget about it; just ignore the whole thing because it's empty
                            ccSpecialCase = false;
                        }
                        else
                        {
                            ccOn = true;
                        }
                    }
                }

                if (m_currentToken.IsEither(JSToken.Assign, JSToken.Equal))
                {
                    assignContext = m_currentToken.Clone();
                    if (m_currentToken.Is(JSToken.Equal))
                    {
                        ReportError(JSError.NoEqual);
                    }

                    // move past the equals sign
                    GetNextToken();
                    if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                    {
                        // so we have var id/*@ =@*/ or var id//@=<EOL>
                        // we only support the equal sign inside conditional comments IF
                        // the initializer value is there as well.
                        ccSpecialCase = false;
                        m_currentToken.HandleError(JSError.ConditionalCompilationTooComplex);
                        GetNextToken();
                    }

                    initializer = ParseExpression(true, inToken);
                    if (null != initializer)
                    {
                        context.UpdateWith(initializer.Context);
                    }
                }
                else if (ccSpecialCase)
                {
                    // so we have "var id /*@" or "var id //@", but the next character is NOT an equal sign.
                    // we don't support this structure, either.
                    ccSpecialCase = false;
                    m_currentToken.HandleError(JSError.ConditionalCompilationTooComplex);

                    // skip to end of conditional comment
                    while (m_currentToken.IsNot(JSToken.EndOfFile) && m_currentToken.IsNot(JSToken.ConditionalCommentEnd))
                    {
                        GetNextToken();
                    }
                    GetNextToken();
                }

                // if the current token is not an end-of-conditional-comment token now,
                // then we're not in our special case scenario
                if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                {
                    GetNextToken();
                }
                else if (ccSpecialCase)
                {
                    // we have "var id/*@=expr" but the next token is not the closing comment.
                    // we don't support this structure, either.
                    ccSpecialCase = false;
                    m_currentToken.HandleError(JSError.ConditionalCompilationTooComplex);

                    // the assignment expression was apparently within the conditional compilation
                    // comment, but we're going to ignore it. So clear it out.
                    initializer = null;

                    // skip to end of conditional comment
                    while (m_currentToken.IsNot(JSToken.EndOfFile) && m_currentToken.IsNot(JSToken.ConditionalCommentEnd))
                    {
                        GetNextToken();
                    }
                    GetNextToken();
                }

                varDecl = new VariableDeclaration(context)
                    {
                        Binding = binding,
                        AssignContext = assignContext,
                        Initializer = initializer,
                        IsCCSpecialCase = ccSpecialCase,
                        UseCCOn = ccOn
                    };
            }

            return varDecl;
        }

        //---------------------------------------------------------------------------------------
        // ParseBinding
        //
        //  Does the real work of parsing a single binding.
        //  inToken is JSToken.In whenever the potential expression that initialize a variable
        //  cannot contain an 'in', as in the for statement. inToken is JSToken.None otherwise
        //---------------------------------------------------------------------------------------
        private AstNode ParseBinding()
        {
            AstNode binding = null;
            if (m_currentToken.Is(JSToken.Identifier))
            {
                binding = new BindingIdentifier(m_currentToken.Clone())
                    {
                        Name = m_scanner.Identifier
                    };
                GetNextToken();
            }
            else if (m_currentToken.Is(JSToken.LeftBracket))
            {
                ParsedVersion = ScriptVersion.EcmaScript6;
                binding = ParseArrayLiteral(true);
            }
            else if (m_currentToken.Is(JSToken.LeftCurly))
            {
                ParsedVersion = ScriptVersion.EcmaScript6;
                binding = ParseObjectLiteral(true);
            }
            else
            {
                var identifier = JSKeyword.CanBeIdentifier(m_currentToken.Token);
                if (null != identifier)
                {
                    binding = new BindingIdentifier(m_currentToken.Clone())
                        {
                            Name = identifier
                        };
                    GetNextToken();
                }
                else if (JSScanner.IsValidIdentifier(identifier = m_currentToken.Code))
                {
                    // it's probably just a keyword
                    ReportError(JSError.NoIdentifier);
                    binding = new BindingIdentifier(m_currentToken.Clone())
                        {
                            Name = identifier
                        };
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoIdentifier);
                    return null;
                }
            }

            return binding;
        }

        //---------------------------------------------------------------------------------------
        // ParseIfStatement
        //
        //  IfStatement :
        //    'if' '(' Expression ')' Statement ElseStatement
        //
        //  ElseStatement :
        //    <empty> |
        //    'else' Statement
        //---------------------------------------------------------------------------------------
        private IfStatement ParseIfStatement()
        {
            SourceContext ifCtx = m_currentToken.Clone();
            AstNode condition = null;
            AstNode trueBranch = null;
            AstNode falseBranch = null;
            SourceContext elseCtx = null;

            // parse condition
            GetNextToken();
            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis);
            }
            else
            {
                // skip the opening paren
                GetNextToken();
            }

            // get the condition
            condition = ParseExpression();

            // parse statements
            if (m_currentToken.Is(JSToken.RightParenthesis))
            {
                ifCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }
            else
            {
                condition.IfNotNull(c => ifCtx.UpdateWith(c.Context));
                ReportError(JSError.NoRightParenthesis);
            }

            // if this is an assignment, throw a warning in case the developer
            // meant to use == instead of =
            // but no warning if the condition is wrapped in parens.
            var binOp = condition as BinaryExpression;
            if (binOp != null && binOp.OperatorToken == JSToken.Assign)
            {
                condition.Context.HandleError(JSError.SuspectAssignment);
            }

            if (m_currentToken.Is(JSToken.Semicolon))
            {
                // if the next token is just a .semicolon, that's weird to have
                // an empty true-block. flag a low-sev warning
                m_currentToken.HandleError(JSError.SuspectSemicolon);
            }
            else if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                // if the statements aren't withing curly-braces, throw a possible error
                ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
            }

            // parse a Statement, not a SourceElement
            // and ignore any important comments that spring up right here.
            trueBranch = ParseStatement(false, true);
            if (trueBranch != null)
            {
                ifCtx.UpdateWith(trueBranch.Context);
            }

            // parse else, if any
            if (m_currentToken.Is(JSToken.Else))
            {
                elseCtx = m_currentToken.Clone();
                GetNextToken();
                if (m_currentToken.Is(JSToken.Semicolon))
                {
                    // again, an empty else-block is kinda weird.
                    m_currentToken.HandleError(JSError.SuspectSemicolon);
                }
                else if (m_currentToken.IsNot(JSToken.LeftCurly) && m_currentToken.IsNot(JSToken.If))
                {
                    // if the statements aren't withing curly-braces (or start another if-statement), throw a possible error
                    ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
                }

                // parse a Statement, not a SourceElement
                // and ignore any important comments that spring up right here.
                falseBranch = ParseStatement(false, true);
                if (falseBranch != null)
                {
                    ifCtx.UpdateWith(falseBranch.Context);
                }
            }

            return new IfStatement(ifCtx)
                {
                    Condition = condition,
                    TrueBlock = AstNode.ForceToBlock(trueBranch),
                    ElseContext = elseCtx,
                    FalseBlock = AstNode.ForceToBlock(falseBranch)
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseForStatement
        //
        //  ForStatement :
        //    'for' '(' OptionalExpressionNoIn ';' OptionalExpression ';' OptionalExpression ')'
        //    'for' '(' 'var' VariableDeclarationListNoIn ';' OptionalExpression ';' OptionalExpression ')'
        //    'for' '(' LeftHandSideExpression 'in' Expression')'
        //    'for' '(' 'var' Identifier OptionalInitializerNoIn 'in' Expression')'
        //
        //  OptionalExpressionNoIn :
        //    <empty> |
        //    ExpressionNoIn // same as Expression but does not process 'in' as an operator
        //
        //  OptionalInitializerNoIn :
        //    <empty> |
        //    InitializerNoIn // same as initializer but does not process 'in' as an operator
        //---------------------------------------------------------------------------------------
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private AstNode ParseForStatement()
        {
            AstNode forNode = null;
            SourceContext forCtx = m_currentToken.Clone();
            GetNextToken();
            if (m_currentToken.Is(JSToken.LeftParenthesis))
            {
                GetNextToken();
            }
            else
            {
                ReportError(JSError.NoLeftParenthesis);
            }

            AstNode initializer = null, condOrColl = null, increment = null;
            SourceContext operatorContext = null;
            SourceContext separator1Context = null;
            SourceContext separator2Context = null;

            if (m_currentToken.IsOne(JSToken.Var, JSToken.Let, JSToken.Const))
            {
                Declaration declaration;
                if (m_currentToken.Is(JSToken.Var))
                {
                    declaration = new VarDeclaration(m_currentToken.Clone())
                        {
                            StatementToken = m_currentToken.Token,
                            KeywordContext = m_currentToken.Clone()
                        };
                }
                else
                {
                    ParsedVersion = ScriptVersion.EcmaScript6;
                    declaration = new LexicalDeclaration(m_currentToken.Clone())
                        {
                            StatementToken = m_currentToken.Token,
                            KeywordContext = m_currentToken.Clone()
                        };
                }

                GetNextToken();
                declaration.Append(ParseVarDecl(JSToken.In));

                while (m_currentToken.Is(JSToken.Comma))
                {
                    // a list of variable initializers is ONLY allowed in a for(;;) statement,
                    // so we now know we are NOT a for..in or for..of statement.
                    GetNextToken();
                    declaration.Append(ParseVarDecl(JSToken.In));
                    //initializer = new Comma(initializer.context.CombineWith(var.context), initializer, var);
                }

                initializer = declaration;
            }
            else if (m_currentToken.IsNot(JSToken.Semicolon))
            {
                // not a declaration (var, const, let), so parse an expression with the no-in target
                initializer = ParseExpression(false, JSToken.In);
            }

            // either we are at a semicolon or an in/of token
            var isForIn = m_currentToken.Is(JSToken.In) || m_currentToken.Is("of");
            if (isForIn)
            {
                // this IS a for..in or for..of statement
                if (m_currentToken.IsNot(JSToken.In))
                {
                    ParsedVersion = ScriptVersion.EcmaScript6;
                }

                operatorContext = m_currentToken.Clone();
                GetNextToken();

                // parse the collection expression
                condOrColl = ParseExpression();
            }
            else
            {
                // NOT a for..in/for..of; this is a for(;;) statement
                if (m_currentToken.Is(JSToken.Semicolon))
                {
                    separator1Context = m_currentToken.Clone();
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoSemicolon);
                }

                if (m_currentToken.IsNot(JSToken.Semicolon))
                {
                    condOrColl = ParseExpression();
                }

                if (m_currentToken.Is(JSToken.Semicolon))
                {
                    separator2Context = m_currentToken.Clone();
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoSemicolon);
                }

                if (m_currentToken.IsNot(JSToken.RightParenthesis))
                {
                    increment = ParseExpression();
                }
            }

            if (m_currentToken.Is(JSToken.RightParenthesis))
            {
                forCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }
            else
            {
                ReportError(JSError.NoRightParenthesis);
            }

            // if the statements aren't withing curly-braces, throw a possible error
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
            }

            // parse a Statement, not a SourceElement
            // and ignore any important comments that spring up right here.
            var body = ParseStatement(false, true);
            if (isForIn)
            {
                forNode = new ForInStatement(forCtx)
                    {
                        Variable = initializer,
                        OperatorContext = operatorContext,
                        Collection = condOrColl,
                        Body = AstNode.ForceToBlock(body),
                    };
            }
            else
            {
                // if the condition is an assignment, throw a warning in case the developer
                // meant to use == instead of =
                // but no warning if the condition is wrapped in parens.
                var binOp = condOrColl as BinaryExpression;
                if (binOp != null && binOp.OperatorToken == JSToken.Assign)
                {
                    condOrColl.Context.HandleError(JSError.SuspectAssignment);
                }

                forNode = new ForStatement(forCtx)
                    {
                        Initializer = initializer,
                        Separator1Context = separator1Context,
                        Condition = condOrColl,
                        Separator2Context = separator2Context,
                        Incrementer = increment,
                        Body = AstNode.ForceToBlock(body)
                    };
            }

            return forNode;
        }

        //---------------------------------------------------------------------------------------
        // ParseDoStatement
        //
        //  DoStatement:
        //    'do' Statement 'while' '(' Expression ')'
        //---------------------------------------------------------------------------------------
        private DoWhileStatement ParseDoStatement()
        {
            var doCtx = m_currentToken.Clone();
            SourceContext whileContext = null;
            SourceContext terminatorContext = null;
            AstNode body = null;
            AstNode condition = null;

            // skip the do-token
            GetNextToken();

            // if the statements aren't withing curly-braces, throw a possible error
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
            }

            // parse a Statement, not a SourceElement
            // and ignore any important comments that spring up right here.
            body = ParseStatement(false, true);

            if (m_currentToken.IsNot(JSToken.While))
            {
                ReportError(JSError.NoWhile);
            }
            else
            {
                whileContext = m_currentToken.Clone();
                doCtx.UpdateWith(whileContext);
                GetNextToken();
            }

            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis);
            }
            else
            {
                GetNextToken();
            }

            // catch here so the body of the do_while is not thrown away
            condition = ParseExpression();
            if (m_currentToken.IsNot(JSToken.RightParenthesis))
            {
                ReportError(JSError.NoRightParenthesis);
                doCtx.UpdateWith(condition.Context);
            }
            else
            {
                doCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }

            if (m_currentToken.Is(JSToken.Semicolon))
            {
                // JScript 5 allowed statements like
                //   do{print(++x)}while(x<10) print(0)
                // even though that does not strictly follow the automatic semicolon insertion
                // rules for the required semi after the while().  For backwards compatibility
                // we should continue to support this.
                terminatorContext = m_currentToken.Clone();
                GetNextToken();
            }

            // if this is an assignment, throw a warning in case the developer
            // meant to use == instead of =
            // but no warning if the condition is wrapped in parens.
            var binOp = condition as BinaryExpression;
            if (binOp != null && binOp.OperatorToken == JSToken.Assign)
            {
                condition.Context.HandleError(JSError.SuspectAssignment);
            }

            return new DoWhileStatement(doCtx)
                {
                    Body = AstNode.ForceToBlock(body),
                    WhileContext = whileContext,
                    Condition = condition,
                    TerminatingContext = terminatorContext
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseWhileStatement
        //
        //  WhileStatement :
        //    'while' '(' Expression ')' Statement
        //---------------------------------------------------------------------------------------
        private WhileStatement ParseWhileStatement()
        {
            SourceContext whileCtx = m_currentToken.Clone();
            AstNode condition = null;
            AstNode body = null;

            GetNextToken();
            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis);
            }
            else
            {
                GetNextToken();
            }

            condition = ParseExpression();
            if (m_currentToken.IsNot(JSToken.RightParenthesis))
            {
                ReportError(JSError.NoRightParenthesis);
                whileCtx.UpdateWith(condition.Context);
            }
            else
            {
                whileCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }

            // if this is an assignment, throw a warning in case the developer
            // meant to use == instead of =
            // but no warning if the condition is wrapped in parens.
            var binOp = condition as BinaryExpression;
            if (binOp != null && binOp.OperatorToken == JSToken.Assign)
            {
                condition.Context.HandleError(JSError.SuspectAssignment);
            }

            // if the statements aren't withing curly-braces, throw a possible error
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
            }

            // parse a Statement, not a SourceElement
            // and ignore any important comments that spring up right here.
            body = ParseStatement(false, true);

            return new WhileStatement(whileCtx)
                {
                    Condition = condition,
                    Body = AstNode.ForceToBlock(body)
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseContinueStatement
        //
        //  ContinueStatement :
        //    'continue' OptionalLabel
        //
        //  OptionalLabel :
        //    <empty> |
        //    Identifier
        //
        // This function may return a null AST under error condition. The caller should handle
        // that case.
        // Regardless of error conditions, on exit the parser points to the first token after
        // the continue statement
        //---------------------------------------------------------------------------------------
        private ContinueStatement ParseContinueStatement()
        {
            var continueNode = new ContinueStatement(m_currentToken.Clone());
            GetNextToken();

            string label = null;
            if (!m_foundEndOfLine && (m_currentToken.Is(JSToken.Identifier) || (label = JSKeyword.CanBeIdentifier(m_currentToken.Token)) != null))
            {
                continueNode.UpdateWith(m_currentToken);
                continueNode.LabelContext = m_currentToken.Clone();
                continueNode.Label = label ?? m_scanner.Identifier;

                // see if the label is already known
                LabelInfo labelInfo;
                if (m_labelInfo.TryGetValue(continueNode.Label, out labelInfo))
                {
                    // increment the refcount so we know this label is referenced
                    // and save a reference to the label info in this node.
                    ++labelInfo.RefCount;
                    continueNode.LabelInfo = labelInfo;
                }
                else
                {
                    // no such label!
                    continueNode.LabelContext.HandleError(JSError.NoLabel, true);
                }

                GetNextToken();
            }

            ExpectSemicolon(continueNode);
            return continueNode;
        }

        //---------------------------------------------------------------------------------------
        // ParseBreakStatement
        //
        //  BreakStatement :
        //    'break' OptionalLabel
        //
        // This function may return a null AST under error condition. The caller should handle
        // that case.
        // Regardless of error conditions, on exit the parser points to the first token after
        // the break statement.
        //---------------------------------------------------------------------------------------
        private BreakStatement ParseBreakStatement()
        {
            var breakNode = new BreakStatement(m_currentToken.Clone());
            GetNextToken();

            string label = null;
            if (!m_foundEndOfLine && (m_currentToken.Is(JSToken.Identifier) || (label = JSKeyword.CanBeIdentifier(m_currentToken.Token)) != null))
            {
                breakNode.UpdateWith(m_currentToken);
                breakNode.LabelContext = m_currentToken.Clone();
                breakNode.Label = label ?? m_scanner.Identifier;

                // see if the label is already known
                LabelInfo labelInfo;
                if (m_labelInfo.TryGetValue(breakNode.Label, out labelInfo))
                {
                    // increment the refcount so we know this label is referenced
                    // and save a reference to the label info in this node.
                    ++labelInfo.RefCount;
                    breakNode.LabelInfo = labelInfo;
                }
                else
                {
                    // no such label!
                    breakNode.LabelContext.HandleError(JSError.NoLabel, true);
                }

                GetNextToken();
            }

            ExpectSemicolon(breakNode);
            return breakNode;
        }

        //---------------------------------------------------------------------------------------
        // ParseReturnStatement
        //
        //  ReturnStatement :
        //    'return' Expression
        //
        // This function may return a null AST under error condition. The caller should handle
        // that case.
        // Regardless of error conditions, on exit the parser points to the first token after
        // the return statement.
        //---------------------------------------------------------------------------------------
        private ReturnStatement ParseReturnStatement()
        {
            var returnNode = new ReturnStatement(m_currentToken.Clone());
            GetNextToken();

            // CAN'T have a line-break between the "return" and its expression.
            if (!m_foundEndOfLine)
            {
                if (m_currentToken.IsNot(JSToken.Semicolon) && m_currentToken.IsNot(JSToken.RightCurly))
                {
                    returnNode.Operand = ParseExpression();
                    if (returnNode.Operand != null)
                    {
                        returnNode.UpdateWith(returnNode.Operand.Context);
                    }
                }

                ExpectSemicolon(returnNode);
            }
            else
            {
                // but we did find a line-break -- semicolon-insertion rules have kicked in
                ReportError(JSError.SemicolonInsertion, returnNode.Context.FlattenToEnd());
            }

            return returnNode;
        }

        //---------------------------------------------------------------------------------------
        // ParseWithStatement
        //
        //  WithStatement :
        //    'with' '(' Expression ')' Statement
        //---------------------------------------------------------------------------------------
        private WithStatement ParseWithStatement()
        {
            SourceContext withCtx = m_currentToken.Clone();
            AstNode obj = null;

            GetNextToken();
            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis);
            }
            else
            {
                GetNextToken();
            }

            obj = ParseExpression();
            if (m_currentToken.IsNot(JSToken.RightParenthesis))
            {
                withCtx.UpdateWith(obj.Context);
                ReportError(JSError.NoRightParenthesis);
            }
            else
            {
                withCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }

            // if the statements aren't withing curly-braces, throw a possible error
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
            }

            // parse a Statement, not a SourceElement
            // and ignore any important comments that spring up right here.
            var statement = ParseStatement(false, true);

            return new WithStatement(withCtx)
                {
                    WithObject = obj,
                    Body = AstNode.ForceToBlock(statement)
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseSwitchStatement
        //
        //  SwitchStatement :
        //    'switch' '(' Expression ')' '{' CaseBlock '}'
        //
        //  CaseBlock :
        //    CaseList DefaultCaseClause CaseList
        //
        //  CaseList :
        //    <empty> |
        //    CaseClause CaseList
        //
        //  CaseClause :
        //    'case' Expression ':' OptionalStatements
        //
        //  DefaultCaseClause :
        //    <empty> |
        //    'default' ':' OptionalStatements
        //---------------------------------------------------------------------------------------
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private AstNode ParseSwitchStatement()
        {
            SourceContext switchCtx = m_currentToken.Clone();
            AstNode expr = null;
            AstNodeList cases = null;
            var braceOnNewLine = false;
            SourceContext braceContext = null;

            // read switch(expr)
            GetNextToken();
            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis);
            }
            else
            {
                GetNextToken();
            }

            expr = ParseExpression();

            if (m_currentToken.IsNot(JSToken.RightParenthesis))
            {
                ReportError(JSError.NoRightParenthesis);
            }
            else
            {
                GetNextToken();
            }

            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.NoLeftCurly);
            }
            else
            {
                braceOnNewLine = m_foundEndOfLine;
                braceContext = m_currentToken.Clone();
                GetNextToken();
            }

            // parse the switch body
            cases = new AstNodeList(CurrentPositionContext);
            bool defaultStatement = false;
            while (m_currentToken.IsNot(JSToken.RightCurly))
            {
                SwitchCase caseClause = null;
                AstNode caseValue = null;
                var caseCtx = m_currentToken.Clone();
                SourceContext colonContext = null;
                if (m_currentToken.Is(JSToken.Case))
                {
                    // get the case
                    GetNextToken();
                    caseValue = ParseExpression();
                }
                else if (m_currentToken.Is(JSToken.Default))
                {
                    // get the default
                    if (defaultStatement)
                    {
                        // we report an error but we still accept the default
                        ReportError(JSError.DupDefault);
                    }
                    else
                    {
                        defaultStatement = true;
                    }
                    GetNextToken();
                }
                else
                {
                    // This is an error, there is no case or default. Assume a default was missing and keep going
                    defaultStatement = true;
                    ReportError(JSError.BadSwitch);
                }

                if (m_currentToken.IsNot(JSToken.Colon))
                {
                    ReportError(JSError.NoColon);
                }
                else
                {
                    colonContext = m_currentToken.Clone();
                    GetNextToken();
                }

                // read the statements inside the case or default
                var statements = new BlockStatement(m_currentToken.Clone());
                while (m_currentToken.IsNotAny(JSToken.RightCurly, JSToken.Case, JSToken.Default, JSToken.EndOfFile))
                {
                    // parse a Statement, not a SourceElement
                    statements.Append(ParseStatement(false));
                }

                caseCtx.UpdateWith(statements.Context);
                caseClause = new SwitchCase(caseCtx)
                    {
                        CaseValue = caseValue,
                        ColonContext = colonContext,
                        Statements = statements
                    };
                cases.Append(caseClause);
            }

            switchCtx.UpdateWith(m_currentToken);
            GetNextToken();

            return new SwitchStatement(switchCtx)
                {
                    Expression = expr,
                    BraceContext = braceContext,
                    Cases = cases,
                    BraceOnNewLine = braceOnNewLine
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseThrowStatement
        //
        //  ThrowStatement :
        //    throw |
        //    throw Expression
        //---------------------------------------------------------------------------------------
        private AstNode ParseThrowStatement()
        {
            var throwNode = new ThrowStatement(m_currentToken.Clone());
            GetNextToken();

            // cannot have a line break between "throw" and it's expression
            if (!m_foundEndOfLine)
            {
                if (m_currentToken.IsNot(JSToken.Semicolon))
                {
                    throwNode.Operand = ParseExpression();
                    if (throwNode.Operand != null)
                    {
                        throwNode.UpdateWith(throwNode.Operand.Context);
                    }
                }

                ExpectSemicolon(throwNode);
            }
            else
            {
                ReportError(JSError.SemicolonInsertion, throwNode.Context.FlattenToEnd());
            }

            return throwNode;
        }

        //---------------------------------------------------------------------------------------
        // ParseTryStatement
        //
        //  TryStatement :
        //    'try' Block Catch Finally
        //
        //  Catch :
        //    <empty> | 'catch' '(' Identifier ')' Block
        //
        //  Finally :
        //    <empty> |
        //    'finally' Block
        //---------------------------------------------------------------------------------------
        private AstNode ParseTryStatement()
        {
            SourceContext tryCtx = m_currentToken.Clone();
            BlockStatement body = null;
            SourceContext catchContext = null;
            ParameterDeclaration catchParameter = null;
            BlockStatement catchBlock = null;
            SourceContext finallyContext = null;
            BlockStatement finallyBlock = null;

            bool catchOrFinally = false;
            GetNextToken();
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.NoLeftCurly);
            }

            body = ParseBlock();

            if (m_currentToken.Is(JSToken.Catch))
            {
                catchOrFinally = true;
                catchContext = m_currentToken.Clone();
                GetNextToken();
                if (m_currentToken.IsNot(JSToken.LeftParenthesis))
                {
                    ReportError(JSError.NoLeftParenthesis);
                }
                else
                {
                    GetNextToken();
                }

                var catchBinding = ParseBinding();
                if (catchBinding == null)
                {
                    ReportError(JSError.NoBinding);
                }
                else
                {
                    catchParameter = new ParameterDeclaration(catchBinding.Context.Clone())
                    {
                        Binding = catchBinding
                    };
                }

                if (m_currentToken.IsNot(JSToken.RightParenthesis))
                {
                    ReportError(JSError.NoRightParenthesis);
                }
                else
                {
                    GetNextToken();
                }

                if (m_currentToken.IsNot(JSToken.LeftCurly))
                {
                    ReportError(JSError.NoLeftCurly);
                }

                // parse the block
                catchBlock = ParseBlock();

                tryCtx.UpdateWith(catchBlock.Context);
            }

            if (m_currentToken.Is(JSToken.Finally))
            {
                catchOrFinally = true;
                finallyContext = m_currentToken.Clone();
                GetNextToken();

                if (m_currentToken.IsNot(JSToken.LeftCurly))
                {
                    ReportError(JSError.NoLeftCurly);
                }

                finallyBlock = ParseBlock();
                tryCtx.UpdateWith(finallyBlock.Context);
            }

            if (!catchOrFinally)
            {
                ReportError(JSError.NoCatch);
            }

            return new TryStatement(tryCtx)
                {
                    TryBlock = body,
                    CatchContext = catchContext,
                    CatchParameter = catchParameter,
                    CatchBlock = catchBlock,
                    FinallyContext = finallyContext,
                    FinallyBlock = finallyBlock
                };
        }

        private AstNode ParseModule()
        {
            // we know we're parsing an ES6 module
            ParsedVersion = ScriptVersion.EcmaScript6;
            var context = m_currentToken.Clone();
            GetNextToken();

            string moduleName = null;
            SourceContext moduleContext = null;
            BlockStatement body = null;
            BindingIdentifier binding = null;
            SourceContext fromContext = null;
            if (m_currentToken.Is(JSToken.StringLiteral))
            {
                if (m_foundEndOfLine)
                {
                    // throw an error, but keep on parsing
                    ReportError(JSError.NewLineNotAllowed, null, true);
                }

                moduleName = m_scanner.StringLiteralValue;
                moduleContext = m_currentToken.Clone();
                context.UpdateWith(moduleContext);
                GetNextToken();

                if (m_currentToken.IsNot(JSToken.LeftCurly))
                {
                    ReportError(JSError.NoLeftCurly);
                }
                else
                {
                    body = ParseBlock();
                    if (body != null)
                    {
                        context.UpdateWith(body.Context);
                        body.IsModule = true;
                    }
                }
            }
            else if (m_currentToken.Is(JSToken.Identifier) || JSKeyword.CanBeIdentifier(m_currentToken.Token) != null)
            {
                binding = (BindingIdentifier)ParseBinding();
                context.UpdateWith(binding.Context);

                if (m_currentToken.Is("from"))
                {
                    fromContext = m_currentToken.Clone();
                    context.UpdateWith(fromContext);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoExpectedFrom);
                }

                if (m_currentToken.Is(JSToken.StringLiteral))
                {
                    moduleName = m_scanner.StringLiteralValue;
                    moduleContext = m_currentToken.Clone();
                    context.UpdateWith(moduleContext);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoStringLiteral);
                }
            }
            else
            {
                ReportError(JSError.NoIdentifier);
            }

            var moduleDecl = new ModuleDeclaration(context)
                {
                    ModuleName = moduleName,
                    ModuleContext = moduleContext,
                    Body = body,
                    Binding = binding,
                    FromContext = fromContext
                };

            if (binding != null)
            {
                ExpectSemicolon(moduleDecl);
            }

            return moduleDecl;
        }

        private AstNode ParseExport()
        {
            // we know we're parsing an ES6 export
            ParsedVersion = ScriptVersion.EcmaScript6;
            var exportNode = new ExportStatement(m_currentToken.Clone())
                {
                    KeywordContext = m_currentToken.Clone(),
                };
            GetNextToken();
            if (m_currentToken.IsOne(JSToken.Var, JSToken.Const, JSToken.Let, JSToken.Function, JSToken.Class))
            {
                // export var/const/let/funcdecl/classdecl
                var declaration = ParseStatement(true, true);
                if (declaration != null)
                {
                    exportNode.Append(declaration);
                }
                else
                {
                    // this shouldn't happen -- we already had the right token, so why didn't it parse???
                    // we probably already output another error, but throw a syntax error here, just in case.
                    ReportError(JSError.SyntaxError);
                }
            }
            else if (m_currentToken.Is(JSToken.Default))
            {
                // export default assignmentexpression ;
                exportNode.IsDefault = true;
                exportNode.DefaultContext = m_currentToken.Clone();
                exportNode.Context.UpdateWith(m_currentToken);
                GetNextToken();

                var expression = ParseExpression(true);
                if (expression != null)
                {
                    exportNode.Append(expression);
                }
                else
                {
                    ReportError(JSError.ExpressionExpected);
                }

                ExpectSemicolon(exportNode);
            }
            else 
            {
                if (m_currentToken.Is(JSToken.Identifier) || JSKeyword.CanBeIdentifier(m_currentToken.Token) != null)
                {
                    // export identifier ;
                    var lookup = new LookupExpression(m_currentToken.Clone())
                    {
                        Name = m_scanner.Identifier
                    };
                    exportNode.Append(lookup);
                    GetNextToken();
                } 
                else if (m_currentToken.Is(JSToken.Multiply))
                {
                    // export * (from "module")?
                    exportNode.OpenContext = m_currentToken.Clone();
                    exportNode.UpdateWith(exportNode.OpenContext);
                    GetNextToken();
                }
                else if (m_currentToken.Is(JSToken.LeftCurly))
                {
                    // export { specifier (, specifier)* ,? } (from "module")?
                    exportNode.OpenContext = m_currentToken.Clone();
                    exportNode.UpdateWith(exportNode.OpenContext);

                    do
                    {
                        GetNextToken();
                        if (m_currentToken.IsNot(JSToken.RightCurly))
                        {
                            string identifier = null;
                            if (m_currentToken.Is(JSToken.Identifier) || (identifier = JSKeyword.CanBeIdentifier(m_currentToken.Token)) != null)
                            {
                                var specifierContext = m_currentToken.Clone();
                                var lookup = new LookupExpression(m_currentToken.Clone())
                                    {
                                        Name = identifier ?? m_scanner.Identifier
                                    };
                                GetNextToken();

                                SourceContext asContext = null;
                                SourceContext nameContext = null;
                                string externalName = null;
                                if (m_currentToken.Is("as"))
                                {
                                    asContext = m_currentToken.Clone();
                                    specifierContext.UpdateWith(asContext);
                                    GetNextToken();

                                    externalName = m_scanner.Identifier;
                                    if (externalName != null)
                                    {
                                        nameContext = m_currentToken.Clone();
                                        specifierContext.UpdateWith(nameContext);
                                        GetNextToken();
                                    }
                                    else
                                    {
                                        ReportError(JSError.NoIdentifier);
                                    }
                                }

                                var specifier = new ImportExportSpecifier(specifierContext)
                                    {
                                        LocalIdentifier = lookup,
                                        AsContext = asContext,
                                        ExternalName = externalName,
                                        NameContext = nameContext
                                    };
                                exportNode.Append(specifier);

                                if (m_currentToken.Is(JSToken.Comma))
                                {
                                    specifier.TerminatingContext = m_currentToken.Clone();
                                }
                            }
                            else
                            {
                                ReportError(JSError.NoIdentifier);
                            }
                        }
                    }
                    while (m_currentToken.Is(JSToken.Comma));

                    if (m_currentToken.Is(JSToken.RightCurly))
                    {
                        exportNode.CloseContext = m_currentToken.Clone();
                        exportNode.UpdateWith(exportNode.CloseContext);
                        GetNextToken();
                    }
                    else
                    {
                        ReportError(JSError.NoRightCurly);
                    }
                }
                else
                {
                    ReportError(JSError.NoSpecifierSet);
                }

                if (m_currentToken.Is("from"))
                {
                    // re-exporting from another module.
                    exportNode.FromContext = m_currentToken.Clone();
                    exportNode.UpdateWith(exportNode.FromContext);
                    GetNextToken();

                    if (m_currentToken.Is(JSToken.StringLiteral))
                    {
                        exportNode.ModuleContext = m_currentToken.Clone();
                        exportNode.UpdateWith(exportNode.ModuleContext);
                        exportNode.ModuleName = m_scanner.StringLiteralValue;
                        GetNextToken();
                    }
                    else
                    {
                        ReportError(JSError.NoStringLiteral);
                    }
                }

                ExpectSemicolon(exportNode);
            }

            return exportNode;
        }

        private AstNode ParseImport()
        {
            // we know we're parsing an ES6 import
            ParsedVersion = ScriptVersion.EcmaScript6;
            var importNode = new ImportStatement(m_currentToken.Clone())
                {
                    KeywordContext = m_currentToken.Clone(),
                };
            GetNextToken();
            if (m_currentToken.Is(JSToken.StringLiteral))
            {
                // import "module" ;
                importNode.ModuleName = m_scanner.StringLiteralValue;
                importNode.ModuleContext = m_currentToken.Clone();
                GetNextToken();
            }
            else
            {
                if (m_currentToken.Is(JSToken.LeftCurly))
                {
                    // import { specifier (, specifier)* ,? } from "module"
                    importNode.OpenContext = m_currentToken.Clone();
                    importNode.UpdateWith(importNode.OpenContext);

                    do
                    {
                        GetNextToken();
                        if (m_currentToken.IsNot(JSToken.RightCurly))
                        {
                            var externalName = m_scanner.Identifier;
                            if (externalName != null)
                            {
                                var nameContext = m_currentToken.Clone();
                                var specifierContext = nameContext.Clone();
                                GetNextToken();

                                SourceContext asContext = null;
                                AstNode localIdentifier = null;
                                if (m_currentToken.Is("as"))
                                {
                                    asContext = m_currentToken.Clone();
                                    GetNextToken();

                                    if (m_currentToken.Is(JSToken.Identifier) || JSKeyword.CanBeIdentifier(m_currentToken.Token) != null)
                                    {
                                        localIdentifier = ParseBinding();
                                    }
                                    else
                                    {
                                        ReportError(JSError.NoIdentifier);
                                    }
                                }
                                else
                                {
                                    // the external name is also the local binding
                                    localIdentifier = new BindingIdentifier(nameContext)
                                        {
                                            Name = externalName
                                        };
                                    externalName = null;
                                    nameContext = null;
                                }

                                var specifier = new ImportExportSpecifier(specifierContext)
                                {
                                    ExternalName = externalName,
                                    NameContext = nameContext,
                                    AsContext = asContext,
                                    LocalIdentifier = localIdentifier,
                                };
                                importNode.Append(specifier);

                                if (m_currentToken.Is(JSToken.Comma))
                                {
                                    importNode.TerminatingContext = m_currentToken.Clone();
                                }
                            }
                            else
                            {
                                ReportError(JSError.NoIdentifier);
                            }
                        }
                    }
                    while (m_currentToken.Is(JSToken.Comma));

                    if (m_currentToken.Is(JSToken.RightCurly))
                    {
                        importNode.CloseContext = m_currentToken.Clone();
                        importNode.UpdateWith(importNode.CloseContext);
                        GetNextToken();
                    }
                    else
                    {
                        ReportError(JSError.NoRightCurly);
                    }
                }
                else if (m_currentToken.Is(JSToken.Identifier) || JSKeyword.CanBeIdentifier(m_currentToken.Token) != null)
                {
                    // import identifier from "module"
                    importNode.Append(ParseBinding());
                }

                if (m_currentToken.Is("from"))
                {
                    importNode.FromContext = m_currentToken.Clone();
                    importNode.UpdateWith(importNode.FromContext);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoExpectedFrom);
                }

                if (m_currentToken.Is(JSToken.StringLiteral))
                {
                    importNode.ModuleName = m_scanner.StringLiteralValue;
                    importNode.ModuleContext = m_currentToken.Clone();
                    importNode.UpdateWith(importNode.ModuleContext);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoStringLiteral);
                }
            }

            ExpectSemicolon(importNode);
            return importNode;
        }

        #endregion

        #region ParseFunction

        //---------------------------------------------------------------------------------------
        // ParseFunction
        //
        //  FunctionDeclaration :
        //    VisibilityModifier 'function' Identifier '('
        //                          FormalParameterList ')' '{' FunctionBody '}'
        //
        //  FormalParameterList :
        //    <empty> |
        //    IdentifierList Identifier
        //
        //  IdentifierList :
        //    <empty> |
        //    Identifier, IdentifierList
        //---------------------------------------------------------------------------------------
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private FunctionObject ParseFunction(FunctionType functionType, SourceContext fncCtx)
        {
            BindingIdentifier name = null;
            AstNodeList formalParameters = null;
            BlockStatement body = null;
            bool inExpression = (functionType == FunctionType.Expression);

            var isAsync = m_currentToken.Is(JSToken.Async);
            if (isAsync)
            {
                // skip the async keyword
                GetNextToken();
                ParsedVersion = ScriptVersion.EcmaScript6;
            }
            // skip the opening token (function, get, or set).
            // methods will start off with no prefix -- right to the name.
            if (functionType != FunctionType.Method)
            {
                GetNextToken();
            }

            var isGenerator = m_currentToken.Is(JSToken.Multiply);
            if (isGenerator)
            {
                // skip the asterisk
                GetNextToken();
                ParsedVersion = ScriptVersion.EcmaScript6;
            }

            // get the function name or make an anonymous function if in expression "position"
            if (m_currentToken.Is(JSToken.Identifier))
            {
                name = new BindingIdentifier(m_currentToken.Clone())
                    {
                        Name = m_scanner.Identifier
                    };
                GetNextToken();
            }
            else
            {
                string identifier = JSKeyword.CanBeIdentifier(m_currentToken.Token);
                if (null != identifier)
                {
                    name = new BindingIdentifier(m_currentToken.Clone())
                        {
                            Name = identifier
                        };
                    GetNextToken();
                }
                else
                {
                    if (!inExpression)
                    {
                        // if this isn't a function expression, then we need to throw an error because
                        // function DECLARATIONS always need a valid identifier name
                        ReportError(JSError.NoIdentifier);

                        // BUT if the current token is a left paren, we don't want to use it as the name.
                        // (fix for issue #14152)
                        if (m_currentToken.IsNot(JSToken.LeftParenthesis)
                            && m_currentToken.IsNot(JSToken.LeftCurly))
                        {
                            identifier = m_currentToken.Code;
                            name = new BindingIdentifier(CurrentPositionContext)
                                {
                                    Name = identifier
                                };
                            GetNextToken();
                        }
                    }
                }
            }

            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                // we expect a left paren at this point for standard cross-browser support.
                // BUT -- some versions of IE allow an object property expression to be a function name, like window.onclick. 
                // we still want to throw the error, because it syntax errors on most browsers, but we still want to
                // be able to parse it and return the intended results. 
                // Skip to the open paren and use whatever is in-between as the function name. Doesn't matter that it's 
                // an invalid identifier; it won't be accessible as a valid field anyway.
                bool expandedIndentifier = false;
                while (m_currentToken.IsNot(JSToken.LeftParenthesis)
                    && m_currentToken.IsNot(JSToken.LeftCurly)
                    && m_currentToken.IsNot(JSToken.Semicolon)
                    && m_currentToken.IsNot(JSToken.EndOfFile))
                {
                    name.Context.UpdateWith(m_currentToken);
                    GetNextToken();
                    expandedIndentifier = true;
                }

                // if we actually expanded the identifier context, then we want to report that
                // the function name needs to be an identifier. Otherwise we didn't expand the 
                // name, so just report that we expected an open paren at this point.
                if (expandedIndentifier)
                {
                    name.Name = name.Context.Code;
                    name.Context.HandleError(JSError.FunctionNameMustBeIdentifier, false);
                }
                else
                {
                    ReportError(JSError.NoLeftParenthesis);
                }
            }

            // get the formal parameters
            formalParameters = ParseFormalParameters();
            fncCtx.UpdateWith(formalParameters.IfNotNull(p => p.Context));

            // read the function body of non-abstract functions.
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.NoLeftCurly);
            }

            try
            {
                // parse the block locally to get the exact end of function
                body = new BlockStatement(m_currentToken.Clone());
                body.BraceOnNewLine = m_foundEndOfLine;
                GetNextToken();

                // parse the function body statements
                ParseFunctionBody(body);

                if (m_currentToken.Is(JSToken.RightCurly))
                {
                    body.Context.UpdateWith(m_currentToken);
                    GetNextToken();
                }
                else
                {
                    if (m_currentToken.Is(JSToken.EndOfFile))
                    {
                        fncCtx.HandleError(JSError.UnclosedFunction, true);
                        ReportError(JSError.ErrorEndOfFile);
                    }
                    else
                    {
                        ReportError(JSError.NoRightCurly);
                    }
                }

                fncCtx.UpdateWith(body.Context);
            }
            catch (EndOfStreamException)
            {
                // if we get an EOF here, we never had a chance to find the closing curly-brace
                fncCtx.HandleError(JSError.UnclosedFunction, true);
            }

            return new FunctionObject(fncCtx)
                {
                    FunctionType = functionType,
                    Binding = name,
                    ParameterDeclarations = formalParameters,
                    Body = body,
                    IsGenerator = isGenerator,
                    IsAsync = isAsync
                };
        }

        private void ParseFunctionBody(BlockStatement body)
        {
            var possibleDirectivePrologue = true;
            while (m_currentToken.IsNot(JSToken.RightCurly)
                && m_currentToken.IsNot(JSToken.EndOfFile))
            {
                // function body's are SourceElements (Statements + FunctionDeclarations)
                var statement = ParseStatement(true);
                if (possibleDirectivePrologue)
                {
                    var constantWrapper = statement as ConstantWrapper;
                    if (constantWrapper != null && constantWrapper.PrimitiveType == PrimitiveType.String)
                    {
                        // if it's already a directive prologues, we're good to go
                        if (!(constantWrapper is DirectivePrologue))
                        {
                            // make the statement a directive prologue instead of a constant wrapper
                            statement = new DirectivePrologue(constantWrapper.Value.ToString(), constantWrapper.Context)
                            {
                                MayHaveIssues = constantWrapper.MayHaveIssues
                            };
                        }
                    }
                    else if (!m_newModule)
                    {
                        // no longer considering constant wrappers
                        possibleDirectivePrologue = false;
                    }
                }
                else if (m_newModule)
                {
                    // we scanned into a new module -- we might find directive prologues again
                    possibleDirectivePrologue = true;
                }

                // add it to the body
                body.Append(statement);
            }

            // make sure any important comments before the closing brace are kept
            AppendImportantComments(body);
        }

        private AstNodeList ParseFormalParameters()
        {
            AstNodeList formalParameters = null;
            if (m_currentToken.Is(JSToken.LeftParenthesis))
            {
                // create the parameter list
                formalParameters = new AstNodeList(m_currentToken.Clone());

                // create the list of arguments and update the context
                var token = JSToken.Comma;
                while (token == JSToken.Comma)
                {
                    ParameterDeclaration paramDecl = null;
                    GetNextToken();
                    if (m_currentToken.IsNot(JSToken.RightParenthesis))
                    {
                        SourceContext restContext = null;
                        if (m_currentToken.Is(JSToken.RestSpread))
                        {
                            ParsedVersion = ScriptVersion.EcmaScript6;
                            restContext = m_currentToken.Clone();
                            GetNextToken();
                        }

                        var binding = ParseBinding();
                        if (binding != null)
                        {
                            paramDecl = new ParameterDeclaration(binding.Context.Clone())
                            {
                                Binding = binding,
                                Position = formalParameters.Count,
                                HasRest = restContext != null,
                                RestContext = restContext,
                            };
                            formalParameters.Append(paramDecl);
                        }
                        else
                        {
                            // We're missing an argument (or previous argument was malformed and
                            // we skipped to the comma.)  Keep trying to parse the argument list --
                            // we will skip the comma below.
                            ReportError(JSError.NoBinding);
                        }

                        // see if we have an optional default value
                        if (m_currentToken.Is(JSToken.Assign))
                        {
                            ParsedVersion = ScriptVersion.EcmaScript6;
                            paramDecl.IfNotNull(p => p.AssignContext = m_currentToken.Clone());
                            GetNextToken();

                            // parse an assignment expression
                            var initializer = ParseExpression(true);
                            paramDecl.IfNotNull(p => p.Initializer = initializer);
                        }
                    }

                    // by now we should have either a comma, which means we need to parse another parameter,
                    // or a right-parentheses, which means we are done. Anything else and it's an error.
                    token = m_currentToken.Token;
                    if (token == JSToken.Comma)
                    {
                        // append the comma context as the terminator for the parameter
                        if (paramDecl != null)
                        {
                            paramDecl.TerminatingContext = m_currentToken.Clone();
                        }
                    }
                    else if (token != JSToken.RightParenthesis)
                    {
                        ReportError(JSError.NoRightParenthesisOrComma);
                    }
                }

                if (m_currentToken.Is(JSToken.RightParenthesis))
                {
                    formalParameters.UpdateWith(m_currentToken);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoRightParenthesis);
                }
            }

            return formalParameters;
        }

        private ClassNode ParseClassNode(ClassType classType)
        {
            ClassNode classNode = null;
            var classContext = m_currentToken.Clone();
            var context = classContext.Clone();
            GetNextToken();

            // [ or { will get parsed as a binding array/object, so we don't REALLY want to do that.
            // besides, if '{' is right after class, then there is no name or heritage.
            AstNode binding = null;
            if (m_currentToken.IsNot(JSToken.LeftCurly) && m_currentToken.IsNot(JSToken.Extends))
            {
                binding = ParseBinding();
            }

            var bindingIdentifier = binding as BindingIdentifier;
            if (bindingIdentifier == null && classType == ClassType.Declaration)
            {
                ReportError(JSError.NoIdentifier, binding.IfNotNull(b => b.Context));
            }

            SourceContext extendsContext = null;
            AstNode heritage = null;
            SourceContext openBrace = null;
            SourceContext closeBrace = null;
            if (m_currentToken.Is(JSToken.Extends))
            {
                extendsContext = m_currentToken.Clone();
                context.UpdateWith(extendsContext);
                GetNextToken();

                heritage = ParseExpression(true);
                if (heritage != null)
                {
                    context.UpdateWith(heritage.Context);
                }
                else
                {
                    ReportError(JSError.ExpressionExpected);
                }
            }

            AstNodeList elements = null;
            if (m_currentToken.Is(JSToken.LeftCurly))
            {
                openBrace = m_currentToken.Clone();
                context.UpdateWith(openBrace);
                GetNextToken();

                elements = new AstNodeList(m_currentToken.FlattenToStart());
                while (m_currentToken.IsNot(JSToken.EndOfFile) && m_currentToken.IsNot(JSToken.RightCurly))
                {
                    if (m_currentToken.Is(JSToken.Semicolon))
                    {
                        // skip the semicolon
                        GetNextToken();
                    }
                    else
                    {
                        var element = ParseClassElement();
                        if (element != null)
                        {
                            elements.Append(element);
                            context.UpdateWith(element.Context);
                        }
                        else
                        {
                            ReportError(JSError.ClassElementExpected);
                        }
                    }
                }

                if (m_currentToken.Is(JSToken.RightCurly))
                {
                    closeBrace = m_currentToken.Clone();
                    context.UpdateWith(closeBrace);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoRightCurly);
                }
            }
            else
            {
                ReportError(JSError.NoLeftCurly);
            }

            // create the class
            classNode = new ClassNode(context)
                {
                    ClassType = classType,
                    ClassContext = classContext,
                    Binding = binding,
                    ExtendsContext = extendsContext,
                    Heritage = heritage,
                    OpenBrace = openBrace,
                    Elements = elements,
                    CloseBrace = closeBrace,
                };

            return classNode;
        }

        private AstNode ParseClassElement()
        {
            // see if we're a static method
            var staticContext = m_currentToken.Is(JSToken.Static)
                ? m_currentToken.Clone()
                : null;
            if (staticContext != null)
            {
                GetNextToken();
            }

            // see if this is a getter/setter or a regular method
            var funcType = m_currentToken.Is(JSToken.Get)
                ? FunctionType.Getter
                : m_currentToken.Is(JSToken.Set) ? FunctionType.Setter : FunctionType.Method;

            // right now the ES6 spec just has method declarations.
            var method = ParseFunction(funcType, m_currentToken.FlattenToStart());
            if (method != null && staticContext != null)
            {
                method.IsStatic = true;
                method.StaticContext = staticContext;
            }

            return method;
        }

        #endregion

        #region ParseExpression

        //---------------------------------------------------------------------------------------
        // ParseExpression
        //
        //  Expression :
        //    AssignmentExpressionList AssignmentExpression
        //
        //  AssignmentExpressionList :
        //    <empty> |
        //    AssignmentExpression ',' AssignmentExpressionList
        //
        //  AssignmentExpression :
        //    ConditionalExpression |
        //    LeftHandSideExpression AssignmentOperator AssignmentExpression
        //
        //  ConditionalExpression :
        //    LogicalORExpression OptionalConditionalExpression
        //
        //  OptionalConditionalExpression :
        //    <empty> |
        //    '?' AssignmentExpression ':' AssignmentExpression
        //
        //  LogicalORExpression :
        //    LogicalANDExpression OptionalLogicalOrExpression
        //
        //  OptionalLogicalOrExpression :
        //    <empty> |
        //    '||' LogicalANDExpression OptionalLogicalOrExpression
        //
        //  LogicalANDExpression :
        //    BitwiseORExpression OptionalLogicalANDExpression
        //
        //  OptionalLogicalANDExpression :
        //    <empty> |
        //    '&&' BitwiseORExpression OptionalLogicalANDExpression
        //
        //  BitwiseORExpression :
        //    BitwiseXORExpression OptionalBitwiseORExpression
        //
        //  OptionalBitwiseORExpression :
        //    <empty> |
        //    '|' BitwiseXORExpression OptionalBitwiseORExpression
        //
        //  BitwiseXORExpression :
        //    BitwiseANDExpression OptionalBitwiseXORExpression
        //
        //  OptionalBitwiseXORExpression :
        //    <empty> |
        //    '^' BitwiseANDExpression OptionalBitwiseXORExpression
        //
        //  BitwiseANDExpression :
        //    EqualityExpression OptionalBitwiseANDExpression
        //
        //  OptionalBitwiseANDExpression :
        //    <empty> |
        //    '&' EqualityExpression OptionalBitwiseANDExpression
        //
        //  EqualityExpression :
        //    RelationalExpression |
        //    RelationalExpression '==' EqualityExpression |
        //    RelationalExpression '!=' EqualityExpression |
        //    RelationalExpression '===' EqualityExpression |
        //    RelationalExpression '!==' EqualityExpression
        //
        //  RelationalExpression :
        //    ShiftExpression |
        //    ShiftExpression '<' RelationalExpression |
        //    ShiftExpression '>' RelationalExpression |
        //    ShiftExpression '<=' RelationalExpression |
        //    ShiftExpression '>=' RelationalExpression
        //
        //  ShiftExpression :
        //    AdditiveExpression |
        //    AdditiveExpression '<<' ShiftExpression |
        //    AdditiveExpression '>>' ShiftExpression |
        //    AdditiveExpression '>>>' ShiftExpression
        //
        //  AdditiveExpression :
        //    MultiplicativeExpression |
        //    MultiplicativeExpression '+' AdditiveExpression |
        //    MultiplicativeExpression '-' AdditiveExpression
        //
        //  MultiplicativeExpression :
        //    UnaryExpression |
        //    UnaryExpression '*' MultiplicativeExpression |
        //    UnaryExpression '/' MultiplicativeExpression |
        //    UnaryExpression '%' MultiplicativeExpression
        //---------------------------------------------------------------------------------------
        private AstNode ParseExpression(bool single = false, JSToken inToken = JSToken.None)
        {
            bool bAssign;
            AstNode lhs = ParseUnaryExpression(out bAssign, false);
            return ParseExpression(lhs, single, bAssign, inToken);
        }

        private AstNode ParseExpression(AstNode leftHandSide, bool single, bool bCanAssign, JSToken inToken)
        {
            // new op stack with dummy op
            Stack<SourceContext> opsStack = null;

            // term stack, push left-hand side onto it
            Stack<AstNode> termStack = null;

            AstNode expr = null;
            for (; ; )
            {
                // if 'binary op' or 'conditional'
                // if we are looking for a single expression, then also bail when we hit a comma
                // inToken is a special case because of the for..in syntax. When ParseExpression is called from
                // for, inToken = JSToken.In which excludes JSToken.In from the list of operators, otherwise
                // inToken = JSToken.None which is always true if the first condition is true
                if (JSScanner.IsProcessableOperator(m_currentToken.Token)
                    && m_currentToken.IsNot(inToken)
                    && (!single || m_currentToken.IsNot(JSToken.Comma)))
                {
                    if (opsStack == null)
                    {
                        opsStack = new Stack<SourceContext>();
                        opsStack.Push(null);

                        termStack = new Stack<AstNode>();
                        termStack.Push(leftHandSide);
                    }

                    // for the current token, get the operator precedence and whether it's a right-association operator
                    var prec = JSScanner.GetOperatorPrecedence(m_currentToken);
                    bool rightAssoc = JSScanner.IsRightAssociativeOperator(m_currentToken.Token);

                    // while the current operator has lower precedence than the operator at the top of the stack
                    // or it has the same precedence and it is left associative (that is, no 'assign op' or 'conditional')
                    var stackPrec = JSScanner.GetOperatorPrecedence(opsStack.Peek());
                    while (prec < stackPrec || prec == stackPrec && !rightAssoc)
                    {
                        // pop the top two elements off the stack along with the current operator, 
                        // combine them, then push the results back onto the term stack
                        AstNode operand2 = termStack.Pop();
                        AstNode operand1 = termStack.Pop();
                        expr = CreateExpressionNode(opsStack.Pop(), operand1, operand2);
                        termStack.Push(expr);

                        // get the precendence of the current item on the top of the op stack
                        stackPrec = JSScanner.GetOperatorPrecedence(opsStack.Peek());
                    }

                    // now the current operator has higher precedence that every scanned operators on the stack, or
                    // it has the same precedence as the one at the top of the stack and it is right associative
                    // push operator and next term

                    // but first: special case conditional '?:'
                    if (m_currentToken.Is(JSToken.ConditionalIf))
                    {
                        // pop term stack
                        AstNode condition = termStack.Pop();

                        // if this is an assignment, throw a warning in case the developer
                        // meant to use == instead of =
                        // but no warning if the condition is wrapped in parens.
                        var binOp = condition as BinaryExpression;
                        if (binOp != null && binOp.OperatorToken == JSToken.Assign)
                        {
                            condition.Context.HandleError(JSError.SuspectAssignment);
                        }

                        var questionCtx = m_currentToken.Clone();
                        GetNextToken();

                        // get expr1 in logOrExpr ? expr1 : expr2
                        AstNode operand1 = ParseExpression(true);

                        SourceContext colonCtx = null;
                        if (m_currentToken.IsNot(JSToken.Colon))
                        {
                            ReportError(JSError.NoColon);
                        }
                        else
                        {
                            colonCtx = m_currentToken.Clone();
                        }

                        GetNextToken();

                        // get expr2 in logOrExpr ? expr1 : expr2
                        AstNode operand2 = ParseExpression(true, inToken);

                        expr = new Conditional(condition.Context.CombineWith(operand2.Context))
                            {
                                Condition = condition,
                                QuestionContext = questionCtx,
                                TrueExpression = operand1,
                                ColonContext = colonCtx,
                                FalseExpression = operand2
                            };
                        termStack.Push(expr);
                    }
                    else
                    {
                        if (JSScanner.IsAssignmentOperator(m_currentToken.Token))
                        {
                            if (!bCanAssign)
                            {
                                ReportError(JSError.IllegalAssignment);
                            }
                        }
                        else
                        {
                            // if the operator is a comma, we can get another assign; otherwise we can't
                            bCanAssign = (m_currentToken.Is(JSToken.Comma));
                        }

                        // push the operator onto the operators stack
                        opsStack.Push(m_currentToken.Clone());

                        // push new term
                        GetNextToken();
                        if (bCanAssign)
                        {
                            termStack.Push(ParseUnaryExpression(out bCanAssign, false));
                        }
                        else
                        {
                            bool dummy;
                            termStack.Push(ParseUnaryExpression(out dummy, false));
                        }
                    }
                }
                else
                {
                    // done with expression; go and unwind the stack of expressions/operators.
                    break;
                }
            }

            if (opsStack != null)
            {
                // there are still operators to be processed
                while (opsStack.Peek() != null)
                {
                    // pop the top two term and the top operator, combine them into a new term,
                    // and push the results back onto the term stacck
                    AstNode operand2 = termStack.Pop();
                    AstNode operand1 = termStack.Pop();
                    expr = CreateExpressionNode(opsStack.Pop(), operand1, operand2);

                    // push node onto the stack
                    termStack.Push(expr);
                }
            }

            AstNode term = leftHandSide;

            if (termStack != null)
            {
                Debug.Assert(termStack.Count == 1);

                // see if the one remaining term is "yield". If so, that means we had a lone
                // yield token -- it might be a Mozilla yield operator
                term = termStack.Pop();
            }

            if (term != null)
            {
                if ((term.Context.Token == JSToken.Yield || term.Context.Token == JSToken.Await)
                    && term is LookupExpression)
                {
                    var expression = ParseExpression(true);
                    if (expression != null)
                    {
                        // yield expression
                        term = new UnaryExpression(term.Context.CombineWith(expression.Context))
                            {
                                OperatorToken = term.Context.Token,
                                OperatorContext = term.Context,
                                Operand = expression
                            };
                    }
                }
            }

            return term;
        }

        //---------------------------------------------------------------------------------------
        // ParseUnaryExpression
        //
        //  UnaryExpression :
        //    PostfixExpression |
        //    'delete' UnaryExpression |
        //    'void' UnaryExpression |
        //    'typeof' UnaryExpression |
        //    '++' UnaryExpression |
        //    '--' UnaryExpression |
        //    '+' UnaryExpression |
        //    '-' UnaryExpression |
        //    '~' UnaryExpression |
        //    '!' UnaryExpression
        //
        //---------------------------------------------------------------------------------------
        private AstNode ParseUnaryExpression(out bool isLeftHandSideExpr, bool isMinus)
        {
            isLeftHandSideExpr = false;
            bool dummy = false;
            SourceContext exprCtx = null;
            AstNode expr = null;

        TryItAgain:
            AstNode ast = null;
            var opToken = m_currentToken.Token;
            switch (opToken)
            {
                case JSToken.RestSpread:
                    // technically, we don't want rest operators ANYWHERE. But we need to handle them
                    // here specifically for formal parameter lists for arrow functions. 
                    // TODO: we want to error if we aren't immediately preceeded by a comma operator,
                    // and if after parsing the next unary expression, we're aren't at a closing parenthesis.
                    ParsedVersion = ScriptVersion.EcmaScript6;
                    goto case JSToken.Void;

                case JSToken.Void:
                case JSToken.TypeOf:
                case JSToken.Plus:
                case JSToken.Minus:
                case JSToken.BitwiseNot:
                case JSToken.LogicalNot:
                case JSToken.Delete:
                case JSToken.Increment:
                case JSToken.Decrement:
                    // normal unary operators all follow the same pattern
                    exprCtx = m_currentToken.Clone();
                    GetNextToken();
                    expr = ParseUnaryExpression(out dummy, false);
                    ast = new UnaryExpression(exprCtx.CombineWith(expr.Context))
                        {
                            Operand = expr,
                            OperatorContext = exprCtx,
                            OperatorToken = opToken
                        };
                    break;

                case JSToken.ConditionalCommentStart:
                    // skip past the start to the next token
                    exprCtx = m_currentToken.Clone();
                    GetNextToken();
                    if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                    {
                        // empty conditional-compilation comment -- ignore
                        GetNextToken();
                        goto TryItAgain;
                    }
                    else if (m_currentToken.Is(JSToken.ConditionalCompilationOn))
                    {
                        // /*@cc_on -- check for @IDENT@*/ or !@*/
                        GetNextToken();
                        if (m_currentToken.Is(JSToken.ConditionalCompilationVariable))
                        {
                            // /*@cc_on@IDENT -- check for @*/
                            ast = new ConstantWrapperPP(m_currentToken.Clone())
                                {
                                    VarName = m_currentToken.Code,
                                    ForceComments = true
                                };

                            GetNextToken();

                            if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                            {
                                // skip the close and keep going
                                GetNextToken();
                            }
                            else
                            {
                                // too complicated
                                CCTooComplicated(null);
                                goto TryItAgain;
                            }
                        }
                        else if (m_currentToken.Is(JSToken.LogicalNot))
                        {
                            // /*@cc_on! -- check for @*/
                            var operatorContext = m_currentToken.Clone();
                            GetNextToken();
                            if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                            {
                                // we have /*@cc_on!@*/
                                GetNextToken();
                                expr = ParseUnaryExpression(out dummy, false);
                                exprCtx.UpdateWith(expr.Context);

                                var unary = new UnaryExpression(exprCtx)
                                    {
                                        Operand = expr,
                                        OperatorContext = operatorContext,
                                        OperatorToken = JSToken.LogicalNot
                                    };
                                unary.OperatorInConditionalCompilationComment = true;
                                unary.ConditionalCommentContainsOn = true;
                                ast = unary;
                            }
                            else
                            {
                                // too complicated
                                CCTooComplicated(null);
                                goto TryItAgain;
                            }
                        }
                        else
                        {
                            // too complicated
                            CCTooComplicated(null);
                            goto TryItAgain;
                        }
                    }
                    else if (m_currentToken.Is(JSToken.LogicalNot))
                    {
                        // /*@! -- check for @*/
                        var operatorContext = m_currentToken.Clone();
                        GetNextToken();
                        if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                        {
                            // we have /*@!@*/
                            GetNextToken();
                            expr = ParseUnaryExpression(out dummy, false);
                            exprCtx.UpdateWith(expr.Context);

                            var unary = new UnaryExpression(exprCtx)
                                {
                                    Operand = expr,
                                    OperatorContext = operatorContext,
                                    OperatorToken = JSToken.LogicalNot
                                };
                            unary.OperatorInConditionalCompilationComment = true;
                            ast = unary;
                        }
                        else
                        {
                            // too complicated
                            CCTooComplicated(null);
                            goto TryItAgain;
                        }
                    }
                    else if (m_currentToken.Is(JSToken.ConditionalCompilationVariable))
                    {
                        // @IDENT -- check for @*/
                        ast = new ConstantWrapperPP(m_currentToken.Clone())
                            {
                                VarName = m_currentToken.Code,
                                ForceComments = true
                            };
                        GetNextToken();

                        if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                        {
                            // skip the close and keep going
                            GetNextToken();
                        }
                        else
                        {
                            // too complicated
                            CCTooComplicated(null);
                            goto TryItAgain;
                        }
                    }
                    else
                    {
                        // we ONLY support /*@id@*/ or /*@cc_on@id@*/ or /*@!@*/ or /*@cc_on!@*/ in expressions right now. 
                        // throw an error, skip to the end of the comment, then ignore it and start
                        // looking for the next token.
                        CCTooComplicated(null);
                        goto TryItAgain;
                    }
                    break;

                default:
                    ast = ParseLeftHandSideExpression(isMinus);
                    ast = ParsePostfixExpression(ast, out isLeftHandSideExpr);
                    break;
            }

            return ast;
        }

        //---------------------------------------------------------------------------------------
        // ParsePostfixExpression
        //
        //  PostfixExpression:
        //    LeftHandSideExpression |
        //    LeftHandSideExpression '++' |
        //    LeftHandSideExpression  '--'
        //
        //---------------------------------------------------------------------------------------
        private AstNode ParsePostfixExpression(AstNode ast, out bool isLeftHandSideExpr)
        {
            isLeftHandSideExpr = true;
            SourceContext exprCtx = null;
            if (null != ast)
            {
                if (!m_foundEndOfLine)
                {
                    if (m_currentToken.Is(JSToken.Increment))
                    {
                        isLeftHandSideExpr = false;
                        exprCtx = ast.Context.Clone();
                        exprCtx.UpdateWith(m_currentToken);
                        ast = new UnaryExpression(exprCtx)
                            {
                                Operand = ast,
                                OperatorToken = m_currentToken.Token,
                                OperatorContext = m_currentToken.Clone(),
                                IsPostfix = true
                            };
                        GetNextToken();
                    }
                    else if (m_currentToken.Is(JSToken.Decrement))
                    {
                        isLeftHandSideExpr = false;
                        exprCtx = ast.Context.Clone();
                        exprCtx.UpdateWith(m_currentToken);
                        ast = new UnaryExpression(exprCtx)
                            {
                                Operand = ast,
                                OperatorToken = m_currentToken.Token,
                                OperatorContext = m_currentToken.Clone(),
                                IsPostfix = true
                            };
                        GetNextToken();
                    }
                }
            }

            return ast;
        }

        //---------------------------------------------------------------------------------------
        // ParseLeftHandSideExpression
        //
        //  LeftHandSideExpression :
        //    PrimaryExpression Accessor  |
        //    'new' LeftHandSideExpression |
        //    FunctionExpression
        //
        //  PrimaryExpression :
        //    'this' |
        //    Identifier |
        //    Literal |
        //    '(' Expression ')'
        //
        //  FunctionExpression :
        //    'function' OptionalFuncName '(' FormalParameterList ')' { FunctionBody }
        //
        //  OptionalFuncName :
        //    <empty> |
        //    Identifier
        //---------------------------------------------------------------------------------------
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode"), 
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private AstNode ParseLeftHandSideExpression(bool isMinus)
        {
            AstNode ast = null;
            List<SourceContext> newContexts = null;

        TryItAgain:

            // new expression
            while (m_currentToken.Is(JSToken.New))
            {
                if (null == newContexts)
                    newContexts = new List<SourceContext>(4);
                newContexts.Add(m_currentToken.Clone());
                GetNextToken();
            }
            JSToken token = m_currentToken.Token;
            switch (token)
            {
                // primary expression
                case JSToken.Identifier:
                    ast = new LookupExpression(m_currentToken.Clone())
                        {
                            Name = m_scanner.Identifier
                        };
                    GetNextToken();
                    break;

                case JSToken.TemplateLiteral:
                    ast = ParseTemplateLiteral();
                    break;

                case JSToken.ConditionalCommentStart:
                    // skip past the start to the next token
                    GetNextToken();
                    if (m_currentToken.Is(JSToken.ConditionalCompilationVariable))
                    {
                        // we have /*@id
                        ast = new ConstantWrapperPP(m_currentToken.Clone())
                            {
                                VarName = m_currentToken.Code,
                                ForceComments = true
                            };

                        GetNextToken();

                        if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                        {
                            // skip past the closing comment
                            GetNextToken();
                        }
                        else
                        {
                            // we ONLY support /*@id@*/ in expressions right now. If there's not
                            // a closing comment after the ID, then we don't support it.
                            // throw an error, skip to the end of the comment, then ignore it and start
                            // looking for the next token.
                            CCTooComplicated(null);
                            goto TryItAgain;
                        }
                    }
                    else if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                    {
                        // empty conditional comment! Ignore.
                        GetNextToken();
                        goto TryItAgain;
                    }
                    else
                    {
                        // we DON'T have "/*@IDENT". We only support "/*@IDENT @*/", so since this isn't
                        // and id, throw the error, skip to the end of the comment, and ignore it
                        // by looping back and looking for the NEXT token.
                        m_currentToken.HandleError(JSError.ConditionalCompilationTooComplex);

                        // skip to end of conditional comment
                        while (m_currentToken.IsNot(JSToken.EndOfFile) && m_currentToken.IsNot(JSToken.ConditionalCommentEnd))
                        {
                            GetNextToken();
                        }
                        GetNextToken();
                        goto TryItAgain;
                    }
                    break;

                case JSToken.This:
                    ast = new ThisLiteral(m_currentToken.Clone());
                    GetNextToken();
                    break;

                case JSToken.StringLiteral:
                    ast = new ConstantWrapper(m_scanner.StringLiteralValue, PrimitiveType.String, m_currentToken.Clone())
                        {
                            MayHaveIssues = m_scanner.LiteralHasIssues
                        };
                    GetNextToken();
                    break;

                case JSToken.IntegerLiteral:
                case JSToken.NumericLiteral:
                    {
                        SourceContext numericContext = m_currentToken.Clone();
                        double doubleValue;
                        if (ConvertNumericLiteralToDouble(m_currentToken.Code, (token == JSToken.IntegerLiteral), out doubleValue))
                        {
                            // conversion worked fine
                            // check for some boundary conditions
                            var mayHaveIssues = m_scanner.LiteralHasIssues;
                            if (doubleValue == double.MaxValue)
                            {
                                ReportError(JSError.NumericMaximum, numericContext);
                            }
                            else if (isMinus && -doubleValue == double.MinValue)
                            {
                                ReportError(JSError.NumericMinimum, numericContext);
                            }

                            // create the constant wrapper from the value
                            ast = new ConstantWrapper(doubleValue, PrimitiveType.Number, numericContext)
                                {
                                    MayHaveIssues = mayHaveIssues
                                };
                        }
                        else
                        {
                            // if we went overflow or are not a number, then we will use the "Other"
                            // primitive type so we don't try doing any numeric calcs with it. 
                            if (double.IsInfinity(doubleValue))
                            {
                                // overflow
                                // and if we ARE an overflow, report it
                                ReportError(JSError.NumericOverflow, numericContext);
                            }

                            // regardless, we're going to create a special constant wrapper
                            // that simply echos the input as-is
                            ast = new ConstantWrapper(m_currentToken.Code, PrimitiveType.Other, numericContext)
                            {
                                MayHaveIssues = true
                            };
                        }

                        GetNextToken();
                        break;
                    }

                case JSToken.True:
                    ast = new ConstantWrapper(true, PrimitiveType.Boolean, m_currentToken.Clone());
                    GetNextToken();
                    break;

                case JSToken.False:
                    ast = new ConstantWrapper(false, PrimitiveType.Boolean, m_currentToken.Clone());
                    GetNextToken();
                    break;

                case JSToken.Null:
                    ast = new ConstantWrapper(null, PrimitiveType.Null, m_currentToken.Clone());
                    GetNextToken();
                    break;

                case JSToken.ConditionalCompilationVariable:
                    ast = new ConstantWrapperPP(m_currentToken.Clone())
                        {
                            VarName = m_currentToken.Code,
                            ForceComments = false
                        };
                    GetNextToken();
                    break;

                // normally this token is not allowed on the left-hand side of an expression.
                // BUT, this might be the start of a regular expression that begins with an equals sign!
                // we need to test to see if we can parse a regular expression, and if not, THEN
                // we can fail the parse.
                case JSToken.DivideAssign:
                case JSToken.Divide:
                    // could it be a regexp?
                    ast = ScanRegularExpression();
                    if (ast != null)
                    {
                        // yup -- we're done here
                        break;
                    }

                    // nope -- go to the default branch
                    goto default;

                case JSToken.Modulo:
                    // could it be a replacement token in the format %name%? If so, we 
                    // want to treat that as a constant wrapper.
                    ast = ScanReplacementToken();
                    if (ast != null)
                    {
                        break;
                    }

                    goto default;

                // expression
                case JSToken.LeftParenthesis:
                    {
                        var leftParen = m_currentToken.Clone();
                        var parentAst = ast;
                        GetNextToken();
                        if (m_currentToken.Is(JSToken.For))
                        {
                            // generator comprehension in ES6 format
                            ast = ParseComprehension(false, leftParen, null);
                        }
                        else
                        {
                            if (m_currentToken.Is(JSToken.RightParenthesis))
                            {
                                // shortcut the empty parenthetical grouping
                                // normally not allowed; however this might be the (empty) parameter list
                                // to an arrow function.
                                // add the closing paren to the expression context
                                ast = new GroupingOperator(leftParen);
                                ast.UpdateWith(m_currentToken);
                                GetNextToken();
                            }
                            else if (m_currentToken.Is(JSToken.RestSpread))
                            {
                                // we have (...
                                // parse an assignment expression, make it the operand of a unary with the rest.
                                var restContext = m_currentToken.Clone();
                                GetNextToken();
                                ast = ParseExpression(true);
                                if (ast != null)
                                {
                                    ast = new UnaryExpression(restContext.CombineWith(ast.Context))
                                        {
                                            OperatorContext = restContext,
                                            OperatorToken = JSToken.RestSpread,
                                            Operand = ast
                                        };
                                }

                                // now, we want to continue parsing if there is a comma
                                if (m_currentToken.Is(JSToken.Comma))
                                {
                                    ast = ParseExpression(ast, false, true, JSToken.None);
                                }

                                if (m_currentToken.Is(JSToken.RightParenthesis))
                                {
                                    ast = new GroupingOperator(leftParen)
                                        {
                                            Operand = ast
                                        };
                                    ast.UpdateWith(m_currentToken);
                                    GetNextToken();
                                }
                                else
                                {
                                    ReportError(JSError.NoRightParenthesis);
                                }
                            }
                            else
                            {
                                // parse an expression
                                var operand = ParseExpression();
                                if (m_currentToken.Is(JSToken.For))
                                {
                                    // generator comprehension in Mozille format
                                    ast = ParseComprehension(false, leftParen, operand);
                                }
                                else
                                {
                                    ast = new GroupingOperator(leftParen)
                                        {
                                            Operand = operand
                                        };
                                    ast.UpdateWith(operand.Context);

                                    if (m_currentToken.IsNot(JSToken.RightParenthesis))
                                    {
                                        ReportError(JSError.NoRightParenthesis);
                                    }
                                    else
                                    {
                                        // add the closing paren to the expression context
                                        ast.UpdateWith(m_currentToken);
                                        GetNextToken();
                                    }
                                }
                            }

                            ast.Parent = parentAst;
                        }
                    }
                    break;

                // array initializer
                case JSToken.LeftBracket:
                    ast = ParseArrayLiteral(false);
                    break;

                // object initializer
                case JSToken.LeftCurly:
                    ast = ParseObjectLiteral(false);
                    break;

                // async function expression
                case JSToken.Async:
                    var nextToken = PeekToken();
                    if (nextToken == JSToken.Function)
                    {
                        // treat 'async function' as a function expression
                        goto case (JSToken.Function); 
                    }
                    else if (nextToken == JSToken.LeftParenthesis)
                    {
                        ast = new LookupExpression(m_currentToken.Clone())
                        {
                            Name = JSKeyword.CanBeIdentifier(m_currentToken.Token)
                        };
                        
                        GetNextToken();

                        nextToken = PeekToken();
                        if (nextToken == JSToken.Function)
                            break;

                        goto case (JSToken.LeftParenthesis);
                    }
                    else
                    {
                        // 'async' as an identifier
                        goto default;
                    }

                // function expression
                case JSToken.Function:
                    ast = ParseFunction(FunctionType.Expression, m_currentToken.Clone());
                    break;

                // class expression
                case JSToken.Class:
                    ast = ParseClassNode(ClassType.Expression);
                    break;

                case JSToken.AspNetBlock:
                    ast = new AspNetBlockNode(m_currentToken.Clone())
                        {
                            AspNetBlockText = m_currentToken.Code
                        };
                    GetNextToken();
                    break;

                case JSToken.Await:
                    {
                        if (ParsedVersion == ScriptVersion.EcmaScript6 || m_settings.ScriptVersion == ScriptVersion.EcmaScript6)
                        {
                            ast = ParseAwaitExpression();
                        }
                        else
                        {
                            // we need to protect against non-ES6 code using "await" as a variable name
                            ast = new LookupExpression(m_currentToken.Clone())
                            {
                                Name = "await"
                            };
                            GetNextToken();
                        }
                    }
                    break;
                case JSToken.Yield:
                    {
                        // TODO: not sure if this is the right place to hook for the ES6 YieldExpression semantics!
                        if (ParsedVersion == ScriptVersion.EcmaScript6 || m_settings.ScriptVersion == ScriptVersion.EcmaScript6)
                        {
                            // we already KNOW we're ES6 code, so just parse this as a yield expression.
                            // in fact, we SHOULD already know, since yield should only be used within a generator
                            // function, which for ES6 code should have the "*" generator indicator, which when
                            // parsed should have already set the ES6 flag.
                            ast = ParseYieldExpression();
                        }
                        else
                        {
                            // we need to protect against non-ES6 code using "yield" as a variable name versus the
                            // Mozilla yield syntax. We'll do that further upstream.
                            ast = new LookupExpression(m_currentToken.Clone())
                                {
                                    Name = "yield"
                                };
                            GetNextToken();
                        }
                    }
                    break;

                default:
                    var identifier = JSKeyword.CanBeIdentifier(m_currentToken.Token);
                    if (identifier != null)
                    {
                        ast = new LookupExpression(m_currentToken.Clone())
                            {
                                Name = identifier
                            };
                        GetNextToken();
                    }
                    else
                    {
                        ReportError(JSError.ExpressionExpected);
                    }
                    break;
            }

            if (m_currentToken.Is(JSToken.ArrowFunction))
            {
                ParsedVersion = ScriptVersion.EcmaScript6;
                ast = ParseArrowFunction(ast);
            }

            // can be a CallExpression, that is, followed by '.' or '(' or '['
            return ParseMemberExpression(ast, newContexts);
        }

        private RegExpLiteral ScanRegularExpression()
        {
            RegExpLiteral regExp = null;
            m_currentToken = m_scanner.UpdateToken(UpdateHint.RegularExpression);
            if (m_currentToken.Is(JSToken.RegularExpression))
            {
                var regexContext = m_currentToken.Clone();
                GetNextToken();

                var literal = regexContext.Code;
                var lastSlash = literal.LastIndexOf('/');

                // flags are everything AFTER the last slash
                var flags = literal.Substring(lastSlash + 1);

                // don't include the leading or trailing slash in the pattern
                var pattern = literal.Substring(1, lastSlash - 1);

                // create the regexp node. 
                regExp = new RegExpLiteral(regexContext)
                {
                    Pattern = pattern,
                    PatternSwitches = flags
                };
            }

            // if we get here, there isn't a regular expression at the current position
            return regExp;
        }

        private ConstantWrapper ScanReplacementToken()
        {
            ConstantWrapper constWrapper = null;
            m_currentToken = m_scanner.UpdateToken(UpdateHint.ReplacementToken);
            if (m_currentToken.Is(JSToken.ReplacementToken))
            {
                constWrapper = new ConstantWrapper(m_currentToken.Code, PrimitiveType.Other, m_currentToken.Clone());
                GetNextToken();
            }

            return constWrapper;
        }

        private TemplateLiteral ParseTemplateLiteral()
        {
            // create the root literal node
            ParsedVersion = ScriptVersion.EcmaScript6;
            var literalContext = m_currentToken.Clone();
            var textContext = m_currentToken.Clone();

            LookupExpression lookup = null;
            var text = m_scanner.StringLiteralValue;

            // see if it starts with an identifier
            var indexBackquote = text.IndexOf('`');
            if (indexBackquote != 0)
            {
                var literalName = text.Substring(0, indexBackquote);
                text = text.Substring(indexBackquote);
                var tagContext = textContext.SplitStart(indexBackquote);

                // TODO: figure out how to get a context on just the literal part!
                lookup = new LookupExpression(tagContext)
                    {
                        Name = literalName
                    };
            }

            // if the token doesn't end with a terminator, then we'll need to parse replacement expressions
            var isContinue = text[text.Length - 1] != '`';

            // create the literal node
            var templateLiteral = new TemplateLiteral(literalContext)
            {
                Function = lookup,
                Text = text,
                TextContext = textContext,
                Expressions = isContinue ? new AstNodeList(literalContext.FlattenToEnd()) : null
            };

            GetNextToken();
            if (isContinue)
            {
                // keep going until we hit the final segment
                do
                {
                    isContinue = false;

                    // expression needs to be closed with a right-curly (whether or not we actually found an expression)
                    var expression = ParseExpression();
                    if (m_currentToken.Is(JSToken.RightCurly))
                    {
                        m_scanner.UpdateToken(UpdateHint.TemplateLiteral);
                        if (m_currentToken.Is(JSToken.TemplateLiteral))
                        {
                            text = m_scanner.StringLiteralValue;
                            var templateExpression = new TemplateLiteralExpression(expression.Context.Clone())
                                {
                                    Expression = expression,
                                    Text = text
                                };
                            templateLiteral.UpdateWith(templateExpression.Context);
                            templateLiteral.Expressions.Append(templateExpression);
                            GetNextToken();

                            isContinue = text[text.Length - 1] != '`';
                        }
                    }
                    else
                    {
                        ReportError(JSError.NoRightCurly);
                    }
                }
                while (isContinue);
            }

            return templateLiteral;
        }

        private AstNode ParseYieldExpression()
        {
            ParsedVersion = ScriptVersion.EcmaScript6;

            // save the context of the yield operator, then skip past it
            var context = m_currentToken.Clone();
            var operatorContext = context.Clone();
            GetNextToken();

            var isDelegator = m_currentToken.Is(JSToken.Multiply);
            if (isDelegator)
            {
                // delegator - move past the yield and the delegator token
                GetNextToken();
            }

            // must be followed by an expression
            var expression = ParseExpression(true);
            if (expression == null)
            {
                // we only call this method if we KNOW we are ES6, so if there is no expression,
                // then throw an error.
                ReportError(JSError.ExpressionExpected);
            }
            else
            {
                context.UpdateWith(expression.Context);
            }

            return new UnaryExpression(context)
                {
                    OperatorContext = operatorContext,
                    OperatorToken = JSToken.Yield,
                    Operand = expression,
                    IsDelegator = isDelegator
                };
        }

        private AstNode ParseAwaitExpression()
        {
            ParsedVersion = ScriptVersion.EcmaScript6;

            // save the context of the await operator, then skip past it
            var context = m_currentToken.Clone();
            var operatorContext = context.Clone();
            GetNextToken();

            bool bAssign;
            AstNode expression = ParseUnaryExpression(out bAssign, false);
            expression = new UnaryExpression(expression.Context.CombineWith(operatorContext))
                {
                    OperatorContext = operatorContext,
                    OperatorToken = JSToken.Await,
                    Operand = expression
                };

            return expression;
        }

        private FunctionObject ParseArrowFunction(AstNode parameters)
        {
            // we are on the arrow-function operator now
            var arrowContext = m_currentToken.Clone();
            GetNextToken();
            ParsedVersion = ScriptVersion.EcmaScript6;

            var functionObject = new FunctionObject(parameters.Context.Clone())
                {
                    ParameterDeclarations = BindingTransform.ToParameters(parameters),
                    FunctionType = FunctionType.ArrowFunction,
                    IsAsync = parameters.Parent is LookupExpression lookupExpression && lookupExpression.Name == JSKeyword.CanBeIdentifier(JSToken.Async)
            };
            functionObject.UpdateWith(arrowContext);
            if (m_currentToken.Is(JSToken.LeftCurly))
            {
                functionObject.Body = ParseBlock();
            }
            else
            {
                // parse an assignment expression as a concise block
                functionObject.Body = BlockStatement.ForceToBlock(ParseExpression(true));
                functionObject.Body.IsConcise = true;
            }

            functionObject.Body.IfNotNull(b => functionObject.UpdateWith(b.Context));
            return functionObject;
        }

        private AstNode ParseArrayLiteral(bool isBindingPattern)
        {
            var openDelimiter = m_currentToken.Clone();
            var listCtx = openDelimiter.Clone();
            var list = new AstNodeList(CurrentPositionContext);
            var hasTrailingCommas = false;

            SourceContext commaContext = null;
            do
            {
                GetNextToken();
                AstNode element = null;
                if (m_currentToken.Is(JSToken.Comma))
                {
                    // comma -- missing array item in the list
                    element = new ConstantWrapper(Missing.Value, PrimitiveType.Other, m_currentToken.FlattenToStart());
                }
                else if (m_currentToken.Is(JSToken.RightBracket))
                {
                    // empty list just bails now
                    if (list.Count == 0)
                    {
                        break;
                    }

                    // if we're parsing a binding pattern, we don't care about the final trailing comma
                    if (!isBindingPattern)
                    {
                        // if the current token is the closing brace, then we ended with a comma -- and we need to
                        // add ANOTHER missing value to make sure this last comma doesn't get left off.
                        // TECHNICALLY, that puts an extra item into the array for most modern browsers, but not ALL.
                        hasTrailingCommas = true;
                        element = new ConstantWrapper(Missing.Value, PrimitiveType.Other, m_currentToken.FlattenToStart());

                        // throw a cross-browser warning about trailing commas
                        commaContext.HandleError(JSError.ArrayLiteralTrailingComma);
                    }
                }
                else if (m_currentToken.Is(JSToken.For))
                {
                    // array comprehension
                    return ParseComprehension(true, openDelimiter, null);
                }
                else
                {
                    // see if we have a spread token
                    SourceContext spreadContext = null;
                    if (m_currentToken.Is(JSToken.RestSpread))
                    {
                        ParsedVersion = ScriptVersion.EcmaScript6;
                        spreadContext = m_currentToken.Clone();
                        GetNextToken();
                    }

                    if (isBindingPattern)
                    {
                        element = ParseBinding();
                        if (m_currentToken.Is(JSToken.Assign))
                        {
                            var assignContext = m_currentToken.Clone();
                            GetNextToken();
                            element = new InitializerNode(assignContext.Clone())
                            {
                                Binding = element,
                                AssignContext = assignContext,
                                Initializer = ParseExpression(true)
                            };
                        }
                    }
                    else
                    {
                        element = ParseExpression(true);
                    }

                    // if we had a spread operator on this item, wrap it in a special unary node
                    if (spreadContext != null)
                    {
                        element = new UnaryExpression(spreadContext.CombineWith(element.Context))
                            {
                                Operand = element,
                                OperatorToken = JSToken.RestSpread,
                                OperatorContext = spreadContext
                            };
                    }
                }

                if (m_currentToken.Is(JSToken.For))
                {
                    // mozilla-style array comprehension!
                    return ParseComprehension(true, openDelimiter, element);
                }

                list.Append(element);
                if (m_currentToken.Is(JSToken.Comma))
                {
                    commaContext = m_currentToken.Clone();

                    if (element != null)
                    {
                        element.TerminatingContext = commaContext;
                    }
                }
            }
            while (m_currentToken.Is(JSToken.Comma));

            if (m_currentToken.Is(JSToken.RightBracket))
            {
                listCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }
            else
            {
                m_currentToken.HandleError(JSError.NoRightBracketOrComma, true);
            }

            return new ArrayLiteral(listCtx)
                {
                    Elements = list,
                    MayHaveIssues = hasTrailingCommas
                };
        }

        private ComprehensionNode ParseComprehension(bool isArray, SourceContext openDelimiter, AstNode expression)
        {
            // we will be on the first FOR token, but Mozilla-style will have already
            // parsed the expression node
            var isMozilla = expression != null;
            var context = openDelimiter.Clone();
            SourceContext closeDelimiter = null;
            expression.IfNotNull(e => context.UpdateWith(e.Context));

            var clauseList = new AstNodeList(m_currentToken.Clone());
            do
            {
                if (m_currentToken.IsEither(JSToken.For, JSToken.If))
                {
                    var clause = ParseComprehensionClause();
                    clause.IfNotNull(c => context.UpdateWith(c.Context));
                    clauseList.Append(clause);
                }
                else
                {
                    ReportError(JSError.NoForOrIf);
                }
            }
            while (m_currentToken.IsEither(JSToken.For, JSToken.If));
            
            context.UpdateWith(clauseList.Context);

            // if we didn't get an expression yet (and we shouldn't for ES6-spec comprehensions), 
            // parse one now
            if (expression == null)
            {
                expression = ParseExpression(true);
                expression.IfNotNull(e => context.UpdateWith(e.Context));
            }

            // should be at the closing delimiter now
            if (m_currentToken.IsNot(isArray ? JSToken.RightBracket : JSToken.RightParenthesis))
            {
                ReportError(isArray ? JSError.NoRightBracket : JSError.NoRightParenthesis);
            }
            else
            {
                closeDelimiter = m_currentToken.Clone();
                context.UpdateWith(closeDelimiter);
                GetNextToken();
            }

            ParsedVersion = ScriptVersion.EcmaScript6;
            return new ComprehensionNode(context)
                {
                    OpenDelimiter = openDelimiter,
                    Expression = expression,
                    Clauses = clauseList,
                    CloseDelimiter = closeDelimiter,
                    ComprehensionType = isArray ? ComprehensionType.Array : ComprehensionType.Generator,
                    MozillaOrdering = isMozilla
                };
        }

        private ComprehensionClause ParseComprehensionClause()
        {
            // save the token
            var forOrIfContext = m_currentToken.Clone();
            var clauseContext = forOrIfContext.Clone();
            GetNextToken();

            // open parenthesis
            SourceContext leftParen = null;
            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis, forOrIfContext);
            }
            else
            {
                leftParen = m_currentToken.Clone();
                clauseContext.UpdateWith(leftParen);
                GetNextToken();
            }

            AstNode expression = null;
            AstNode binding = null;
            SourceContext ofContext = null;
            var isInOperation = false;
            if (forOrIfContext.Is(JSToken.For))
            {
                // for-clause
                binding = ParseBinding();
                binding.IfNotNull(b => clauseContext.UpdateWith(b.Context));

                if (m_currentToken.Is(JSToken.In) || m_currentToken.Is("of"))
                {
                    isInOperation = m_currentToken.Is(JSToken.In);
                    ofContext = m_currentToken.Clone();
                    GetNextToken();
                    clauseContext.UpdateWith(ofContext);
                }
                else
                {
                    ReportError(JSError.NoForOrIf);
                }

                expression = ParseExpression(true);
                expression.IfNotNull(e => clauseContext.UpdateWith(e.Context));
            }
            else
            {
                // if-clause
                expression = ParseExpression(true);
                expression.IfNotNull(e => clauseContext.UpdateWith(e.Context));
            }

            // close paren
            SourceContext rightParen = null;
            if (m_currentToken.IsNot(JSToken.RightParenthesis))
            {
                ReportError(JSError.NoRightParenthesis);
            }
            else
            {
                rightParen = m_currentToken.Clone();
                clauseContext.UpdateWith(rightParen);
                GetNextToken();
            }

            if (forOrIfContext.Is(JSToken.For))
            {
                // for-clause
                return new ComprehensionForClause(clauseContext)
                    {
                        OperatorContext = forOrIfContext,
                        OpenContext = leftParen,
                        Binding = binding,
                        IsInOperation = isInOperation,
                        OfContext = ofContext,
                        Expression = expression,
                        CloseContext = rightParen,
                    };
            }
            else //if (tokenContext.Is(JSToken.If))
            {
                // if-clause
                return new ComprehensionIfClause(clauseContext)
                    {
                        OperatorContext = forOrIfContext,
                        OpenContext = leftParen,
                        Condition = expression,
                        CloseContext = rightParen,
                    };
            }
        }

        private ObjectLiteral ParseObjectLiteral(bool isBindingPattern)
        {
            SourceContext objCtx = m_currentToken.Clone();
            var propertyList = new AstNodeList(CurrentPositionContext);

            do
            {
                GetNextToken();

                // a trailing comma after the last property gets ignored
                if (m_currentToken.IsNot(JSToken.RightCurly))
                {
                    var property = ParseObjectLiteralProperty(isBindingPattern);
                    propertyList.Append(property);
                }
            }
            while (m_currentToken.Is(JSToken.Comma));

            if (m_currentToken.Is(JSToken.RightCurly))
            {
                objCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }
            else
            {
                ReportError(JSError.NoRightCurly);
            }

            return new ObjectLiteral(objCtx) { Properties = propertyList };
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private ObjectLiteralProperty ParseObjectLiteralProperty(bool isBindingPattern)
        {
            ObjectLiteralProperty property = null;
            ObjectLiteralField field = null;
            AstNode value = null;

            // peek at the NEXT token so we can check if we have name followed by ':'
            var nextToken = PeekToken();
            SourceContext propertyContext = m_currentToken.Clone();
            if (nextToken == JSToken.Colon)
            {
                // regular field name followed by a colon
                field = ParseObjectLiteralFieldName();
                if (m_currentToken.Is(JSToken.Colon))
                {
                    if (field != null)
                    {
                        field.ColonContext = m_currentToken.Clone();
                    }

                    GetNextToken();
                    value = ParseObjectPropertyValue(isBindingPattern);

                    if (isBindingPattern && m_currentToken.Is(JSToken.Assign))
                    {
                        var assignContext = m_currentToken.Clone();
                        GetNextToken();
                        value = new InitializerNode(assignContext.Clone())
                        {
                            Binding = value,
                            AssignContext = assignContext,
                            Initializer = ParseExpression(true)
                        };
                    }
                }
            }
            else if (nextToken == JSToken.Comma || nextToken == JSToken.RightCurly || nextToken == JSToken.Assign)
            {
                // just a name lookup; the property name is implicit
                ParsedVersion = ScriptVersion.EcmaScript6;
                value = ParseObjectPropertyValue(isBindingPattern);

                if (isBindingPattern && m_currentToken.Is(JSToken.Assign))
                {
                    var assignContext = m_currentToken.Clone();
                    GetNextToken();
                    value = new InitializerNode(assignContext.Clone())
                    {
                        Binding = value,
                        AssignContext = assignContext,
                        Initializer = ParseExpression(true)
                    };
                }
            }
            else if (m_currentToken.Is(JSToken.RestSpread))
            {
                // spread operator used in creating objects in ES6
                ParsedVersion = ScriptVersion.EcmaScript6;
                var restContext = m_currentToken.Clone();
                GetNextToken();

                value = ParseExpression(true);

                if (value != null)
                {
                    value = new UnaryExpression(restContext.CombineWith(value.Context))
                    {
                        OperatorContext = restContext,
                        OperatorToken = JSToken.RestSpread,
                        Operand = value
                    };
                }
            }
            else if (m_currentToken.IsEither(JSToken.Get, JSToken.Set))
            {
                bool isGet = (m_currentToken.Is(JSToken.Get));
                var funcContext = m_currentToken.Clone();
                var funcExpr = ParseFunction(isGet ? FunctionType.Getter : FunctionType.Setter, funcContext);
                
                if (funcExpr != null)
                {
                    // getter/setter is just the literal name with a get/set flag
                    field = new GetterSetter(funcExpr.Binding.Name, isGet, funcExpr.Binding.Context.Clone());
                    value = funcExpr;

                    if (isBindingPattern)
                    {
                        funcContext.HandleError(JSError.MethodsNotAllowedInBindings, true);
                    }
                }
                else
                {
                    ReportError(JSError.FunctionExpressionExpected);
                }
            }
            else if (m_currentToken.Is(JSToken.Multiply) || nextToken == JSToken.LeftParenthesis)
            {
                // method declaration in ES6
                // starts off right with the name. Don't set the name field -- the method
                // itself takes care of it, like an implicit-named property
                value = ParseFunction(FunctionType.Method, m_currentToken.Clone());
                if (value != null)
                {
                    // definitely an ES6 construct
                    ParsedVersion = ScriptVersion.EcmaScript6;
                }
            }
            else if (m_currentToken.Is(JSToken.LeftBracket))
            {
                var computedValue = ParseExpression() as ArrayLiteral;
                field = new ComputedPropertyField(computedValue, computedValue.Context);
                if( field != null)
                {
                    ParsedVersion = ScriptVersion.EcmaScript6;
                    field.ColonContext = m_currentToken.Clone();
                }
                if ( m_currentToken.Token != JSToken.Colon)
                {
                    ReportError(JSError.NoColon);
                }

                GetNextToken();
                value = ParseObjectPropertyValue(isBindingPattern);
                if (isBindingPattern && m_currentToken.Is(JSToken.Assign))
                {
                    var assignContext = m_currentToken.Clone();
                    GetNextToken();
                    value = new InitializerNode(assignContext.Clone())
                    {
                        Binding = value,
                        AssignContext = assignContext,
                        Initializer = ParseExpression(true)
                    };
                }
            }

            if (field != null || value != null)
            {
                // bundle the name/value pair into a property
                field.IfNotNull(f => propertyContext.UpdateWith(f.Context));
                value.IfNotNull(v => propertyContext.UpdateWith(v.Context));

                property = new ObjectLiteralProperty(propertyContext)
                {
                    Name = field,
                    Value = value,
                };

                if (m_currentToken.Is(JSToken.Comma))
                {
                    // skip the comma after adding it to the property as a terminating context
                    property.IfNotNull(p => p.TerminatingContext = m_currentToken.Clone());
                }
            }

            return property;
        }

        private ObjectLiteralField ParseObjectLiteralFieldName()
        {
            // simple property name
            ObjectLiteralField field = null;
            switch (m_currentToken.Token)
            {
                case JSToken.Identifier:
                case JSToken.Get:
                case JSToken.Set:
                    field = new ObjectLiteralField(m_scanner.Identifier, PrimitiveType.String, m_currentToken.Clone())
                        {
                            IsIdentifier = true
                        };
                    break;

                case JSToken.StringLiteral:
                    field = new ObjectLiteralField(m_scanner.StringLiteralValue, PrimitiveType.String, m_currentToken.Clone())
                        {
                            MayHaveIssues = m_scanner.LiteralHasIssues
                        };
                    break;

                case JSToken.IntegerLiteral:
                case JSToken.NumericLiteral:
                    {
                        double doubleValue;
                        if (ConvertNumericLiteralToDouble(m_currentToken.Code, (m_currentToken.Is(JSToken.IntegerLiteral)), out doubleValue))
                        {
                            // conversion worked fine
                            field = new ObjectLiteralField(doubleValue, PrimitiveType.Number, m_currentToken.Clone());
                        }
                        else
                        {
                            // something went wrong and we're not sure the string representation in the source is 
                            // going to convert to a numeric value well
                            if (double.IsInfinity(doubleValue))
                            {
                                ReportError(JSError.NumericOverflow);
                            }

                            // use the source as the field name, not the numeric value
                            field = new ObjectLiteralField(m_currentToken.Code, PrimitiveType.Other, m_currentToken.Clone());
                        }
                        break;
                    }

                default:
                    // NOT: identifier token, string, number, or getter/setter.
                    // see if it's a token that COULD be an identifierName.
                    var ident = m_scanner.Identifier;
                    if (JSScanner.IsValidIdentifier(ident))
                    {
                        // BY THE SPEC, if it's a valid identifierName -- which includes reserved words -- then it's
                        // okay for object literal syntax. However, reserved words here won't work in all browsers,
                        // so if it is a reserved word, let's throw a low-sev cross-browser warning on the code.
                        if (JSKeyword.CanBeIdentifier(m_currentToken.Token) == null)
                        {
                            ReportError(JSError.ObjectLiteralKeyword);
                        }

                        field = new ObjectLiteralField(ident, PrimitiveType.String, m_currentToken.Clone());
                    }
                    else
                    {
                        // throw an error but use it anyway, since that's what the developer has going on
                        ReportError(JSError.NoMemberIdentifier);
                        field = new ObjectLiteralField(m_currentToken.Code, PrimitiveType.String, m_currentToken.Clone());
                    }
                    break;
            }

            GetNextToken();
            return field;
        }

        private AstNode ParseObjectPropertyValue(bool isBindingPattern)
        {
            if (isBindingPattern)
            {
                // binding pattern
                return ParseBinding();
            }
            else
            {
                // parse a single expression
                return ParseExpression(true);
            }
        }

        //---------------------------------------------------------------------------------------
        // ParseMemberExpression
        //
        // Accessor :
        //  <empty> |
        //  Arguments Accessor
        //  '[' Expression ']' Accessor |
        //  '.' Identifier Accessor |
        //
        //  Don't have this function throwing an exception without checking all the calling sites.
        //  There is state in instance variable that is saved on the calling stack in some function
        //  (i.e ParseFunction and ParseClass) and you don't want to blow up the stack
        //---------------------------------------------------------------------------------------
        private AstNode ParseMemberExpression(AstNode expression, List<SourceContext> newContexts)
        {
            for (; ; )
            {
                switch (m_currentToken.Token)
                {
                    case JSToken.LeftParenthesis:
                        AstNodeList args = null;
                        args = ParseExpressionList(JSToken.RightParenthesis);

                        expression = new CallExpression(expression.Context.CombineWith(args.Context))
                            {
                                Function = expression,
                                Arguments = args,
                                InBrackets = false
                            };

                        if (null != newContexts && newContexts.Count > 0)
                        {
                            (newContexts[newContexts.Count - 1]).UpdateWith(expression.Context);
                            if (!(expression is CallExpression))
                            {
                                expression = new CallExpression(newContexts[newContexts.Count - 1])
                                    {
                                        Function = expression,
                                        Arguments = new AstNodeList(CurrentPositionContext)
                                    };
                            }
                            else
                            {
                                expression.Context = newContexts[newContexts.Count - 1];
                            }

                            ((CallExpression)expression).IsConstructor = true;
                            newContexts.RemoveAt(newContexts.Count - 1);
                        }

                        GetNextToken();
                        break;

                    case JSToken.LeftBracket:
                        //
                        // ROTOR parses a[b,c] as a call to a, passing in the arguments b and c.
                        // the correct parse is a member lookup on a of c -- the "b,c" should be
                        // a single expression with a comma operator that evaluates b but only
                        // returns c.
                        // So we'll change the default behavior from parsing an expression list to
                        // parsing a single expression, but returning a single-item list (or an empty
                        // list if there is no expression) so the rest of the code will work.
                        //
                        //args = ParseExpressionList(JSToken.RightBracket);
                        GetNextToken();
                        args = new AstNodeList(CurrentPositionContext);

                        AstNode accessor = ParseExpression();
                        if (accessor != null)
                        {
                            args.Append(accessor);
                        }

                        expression = new CallExpression(expression.Context.CombineWith(m_currentToken))
                            {
                                Function = expression,
                                Arguments = args,
                                InBrackets = true
                            };

                        // there originally was code here in the ROTOR sources that checked the new context list and
                        // changed this member call to a constructor call, effectively combining the two. I believe they
                        // need to remain separate.

                        // remove the close bracket token
                        GetNextToken();
                        break;

                    case JSToken.AccessField:
                        ConstantWrapper id = null;

                        string name = null;
                        // we want the name context to start with the dot
                        SourceContext nameContext = m_currentToken.Clone();
                        GetNextToken();
                        if (m_currentToken.IsNot(JSToken.Identifier))
                        {
                            name = JSKeyword.CanBeIdentifier(m_currentToken.Token);
                            if (null != name)
                            {
                                // don't report an error here -- it's actually okay to have a property name
                                // that is a keyword which is okay to be an identifier. For instance,
                                // jQuery has a commonly-used method named "get" to make an ajax request
                                //ForceReportInfo(JSError.KeywordUsedAsIdentifier);
                                id = new ConstantWrapper(name, PrimitiveType.String, m_currentToken.Clone());
                            }
                            else if (JSScanner.IsValidIdentifier(m_currentToken.Code))
                            {
                                // it must be a keyword, because it can't technically be an identifier,
                                // but it IS a valid identifier format. Throw a warning but still
                                // create the constant wrapper so we can output it as-is
                                ReportError(JSError.KeywordUsedAsIdentifier);
                                name = m_currentToken.Code;
                                id = new ConstantWrapper(name, PrimitiveType.String, m_currentToken.Clone());
                            }
                            else
                            {
                                ReportError(JSError.NoIdentifier);
                            }
                        }
                        else
                        {
                            name = m_scanner.Identifier;
                            id = new ConstantWrapper(name, PrimitiveType.String, m_currentToken.Clone());
                        }

                        if (id != null)
                        {
                            nameContext.UpdateWith(id.Context);
                        }

                        GetNextToken();
                        expression = new MemberExpression(expression != null ? expression.Context.CombineWith(nameContext) : nameContext.Clone())
                            {
                                Root = expression,
                                Name = name,
                                NameContext = nameContext
                            };
                        break;
                    default:
                        if (null != newContexts)
                        {
                            while (newContexts.Count > 0)
                            {
                                (newContexts[newContexts.Count - 1]).UpdateWith(expression.Context);
                                expression = new CallExpression(newContexts[newContexts.Count - 1])
                                    {
                                        Function = expression,
                                        Arguments = new AstNodeList(CurrentPositionContext)
                                    };
                                ((CallExpression)expression).IsConstructor = true;
                                newContexts.RemoveAt(newContexts.Count - 1);
                            }
                        }
                        return expression;
                }
            }
        }

        //---------------------------------------------------------------------------------------
        // ParseExpressionList
        //
        //  Given a starting this.currentToken '(' or '[', parse a list of expression separated by
        //  ',' until matching ')' or ']'
        //---------------------------------------------------------------------------------------
        private AstNodeList ParseExpressionList(JSToken terminator)
        {
            var list = new AstNodeList(m_currentToken.Clone());
            do
            {
                // skip past the opening delimiter or comma
                GetNextToken();
                AstNode item = null;
                if (m_currentToken.Is(JSToken.Comma))
                {
                    // a comma here means a missing element. Not really valid, but
                    // let's be a little flexible here.
                    item = new ConstantWrapper(Missing.Value, PrimitiveType.Other, m_currentToken.FlattenToStart());
                    list.Append(item);
                    list.UpdateWith(m_currentToken);
                }
                else if (m_currentToken.IsNot(terminator))
                {
                    // if there's a spread context, save it now
                    SourceContext spreadContext = null;
                    if (m_currentToken.Is(JSToken.RestSpread))
                    {
                        ParsedVersion = ScriptVersion.EcmaScript6;
                        spreadContext = m_currentToken.Clone();
                        GetNextToken();
                    }

                    // parse an expression
                    item = ParseExpression(true);

                    if (spreadContext != null)
                    {
                        item = new UnaryExpression(spreadContext.CombineWith(item.Context))
                            {
                                Operand = item,
                                OperatorToken = JSToken.RestSpread,
                                OperatorContext = spreadContext
                            };
                    }

                    list.Append(item);
                }

                if (m_currentToken.Is(JSToken.Comma))
                {
                    if (item != null)
                    {
                        item.TerminatingContext = m_currentToken.Clone();
                    }
                }
            }
            while (m_currentToken.Is(JSToken.Comma));

            if (m_currentToken.Is(terminator))
            {
                list.Context.UpdateWith(m_currentToken);
            }
            else if (terminator == JSToken.RightParenthesis)
            {
                //  in ASP+ it's easy to write a semicolon at the end of an expression
                //  not realizing it is going to go inside a function call
                //  (ie. Response.Write()), so make a special check here
                if (m_currentToken.Is(JSToken.Semicolon)
                    && PeekToken() == JSToken.RightParenthesis)
                {
                    ReportError(JSError.UnexpectedSemicolon);
                    GetNextToken();
                }
                else
                {
                    // expected a right-parenthesis but don't have one
                    ReportError(JSError.NoRightParenthesis);
                }
            }
            else
            {
                // expected a right-bracket but didn't have one
                ReportError(JSError.NoRightBracket);
            }

            return list;
        }

        #endregion

        #region helper methods

        /// <summary>
        /// set the source by creating a document from the actual source and its context,
        /// then create and initialize a scanner for that document.
        /// </summary>
        /// <param name="source">source code</param>
        /// <param name="sourceContext">optional context for the source code</param>
        private void SetDocumentContext(DocumentContext documentContext)
        {
            // set the document object to point to this parser.
            documentContext.Parser = this;

            // set up the scanner for the given document context
            m_scanner = new JSScanner(documentContext);
            m_currentToken = m_scanner.CurrentToken;

            // if the scanner encounters a special "globals" comment, it'll fire this event
            // at which point we will define a field with that name in the global scope. 
            m_scanner.GlobalDefine += (sender, ea) =>
            {
                var globalScope = GlobalScope;
                if (globalScope[ea.Name] == null)
                {
                    var field = globalScope.CreateField(ea.Name, null, FieldAttributes.SpecialName);
                    globalScope.AddField(field);
                }
            };

            // this event is fired whenever a ///#SOURCE comment is encountered
            m_scanner.NewModule += (sender, ea) =>
            {
                m_newModule = true;

                // we also want to assume that we found a newline character after
                // the comment
                m_foundEndOfLine = true;
            };
        }

        //---------------------------------------------------------------------------------------
        // CreateExpressionNode
        //
        //  Create the proper AST object according to operator
        //---------------------------------------------------------------------------------------
        private static AstNode CreateExpressionNode(SourceContext operatorContext, AstNode operand1, AstNode operand2)
        {
            Debug.Assert(operatorContext != null);

            // create a context, but protect against one or the other operand being null (syntax error during parsing)
            var context = (operand1.IfNotNull(operand => operand.Context) ?? operatorContext)
                .CombineWith(operand2.IfNotNull(operand => operand.Context));

            switch (operatorContext.Token)
            {
                case JSToken.Assign:
                case JSToken.BitwiseAnd:
                case JSToken.BitwiseAndAssign:
                case JSToken.BitwiseOr:
                case JSToken.BitwiseOrAssign:
                case JSToken.BitwiseXor:
                case JSToken.BitwiseXorAssign:
                case JSToken.Divide:
                case JSToken.DivideAssign:
                case JSToken.Equal:
                case JSToken.GreaterThan:
                case JSToken.GreaterThanEqual:
                case JSToken.In:
                case JSToken.InstanceOf:
                case JSToken.LeftShift:
                case JSToken.LeftShiftAssign:
                case JSToken.LessThan:
                case JSToken.LessThanEqual:
                case JSToken.LogicalAnd:
                case JSToken.LogicalOr:
                case JSToken.Minus:
                case JSToken.MinusAssign:
                case JSToken.Modulo:
                case JSToken.ModuloAssign:
                case JSToken.Multiply:
                case JSToken.MultiplyAssign:
                case JSToken.NotEqual:
                case JSToken.Plus:
                case JSToken.PlusAssign:
                case JSToken.RightShift:
                case JSToken.RightShiftAssign:
                case JSToken.StrictEqual:
                case JSToken.StrictNotEqual:
                case JSToken.UnsignedRightShift:
                case JSToken.UnsignedRightShiftAssign:
                    // regular binary operator
                    return new BinaryExpression(context)
                        {
                            Operand1 = operand1,
                            Operand2 = operand2,
                            OperatorContext = operatorContext,
                            OperatorToken = operatorContext.Token
                        };

                case JSToken.Comma:
                    // use the special comma-operator class derived from binary operator.
                    // it has special logic to combine adjacent comma operators into a single
                    // node with an ast node list rather than nested binary operators
                    return CommaExpression.CombineWithComma(context, operand1, operand2);

                default:
                    // shouldn't get here!
                    Debug.Assert(false);
                    return null;
            }
        }

        /// <summary>
        /// Convert the given numeric string to a double value
        /// </summary>
        /// <param name="str">string representation of a number</param>
        /// <param name="isInteger">we should know alreasdy if it's an integer or not</param>
        /// <param name="doubleValue">output value</param>
        /// <returns>true if there were no problems; false if there were</returns>
        private bool ConvertNumericLiteralToDouble(string str, bool isInteger, out double doubleValue)
        {
            try
            {
                if (isInteger)
                {
                    if (str[0] == '0' && str.Length > 1)
                    {
                        if (str[1] == 'x' || str[1] == 'X')
                        {
                            if (str.Length == 2)
                            {
                                // 0x???? must be a parse error. Just return zero
                                doubleValue = 0;
                                return false;
                            }

                            // parse the number as a hex integer, converted to a double
                            doubleValue = (double)System.Convert.ToInt64(str, 16);
                        }
                        else if (str[1] == 'o' || str[1] == 'O')
                        {
                            if (str.Length == 2)
                            {
                                // 0o???? must be a parse error. Just return zero
                                doubleValue = 0;
                                return false;
                            }

                            // parse the number as an octal integer without the prefix, converted to a double
                            doubleValue = (double)System.Convert.ToInt64(str.Substring(2), 8);
                        }
                        else if (str[1] == 'b' || str[1] == 'B')
                        {
                            if (str.Length == 2)
                            {
                                // 0b???? must be a parse error. Just return zero
                                doubleValue = 0;
                                return false;
                            }

                            // parse the number as a binary integer without the prefix, converted to a double
                            doubleValue = (double)System.Convert.ToInt64(str.Substring(2), 2);
                        }
                        else
                        {
                            // might be an octal value... try converting to octal
                            // and if it fails, just convert to decimal
                            try
                            {
                                doubleValue = (double)System.Convert.ToInt64(str, 8);

                                // if we got here, we successfully converted it to octal.
                                // now, octal literals are deprecated -- not all JS implementations will
                                // decode them. If this decoded as an octal, it can also be a decimal. Check
                                // the decimal value, and if it's the same, then we'll just treat it
                                // as a normal decimal value. Otherwise we'll throw a warning and treat it
                                // as a special no-convert literal.
                                double decimalValue = (double)System.Convert.ToInt64(str, 10);
                                if (decimalValue != doubleValue)
                                {
                                    // throw a warning!
                                    ReportError(JSError.OctalLiteralsDeprecated);

                                    // return false because octals are deprecated and might have
                                    // cross-browser issues
                                    return false;
                                }
                            }
                            catch (FormatException)
                            {
                                // ignore the format exception and fall through to parsing
                                // the value as a base-10 decimal value
                                doubleValue = Convert.ToDouble(str, CultureInfo.InvariantCulture);
                            }
                        }
                    }
                    else
                    {
                        // just parse the integer as a decimal value
                        doubleValue = Convert.ToDouble(str, CultureInfo.InvariantCulture);
                    }

                    // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented
                    // as a double, then we don't want to consider it "successful"
                    if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)
                    {
                        return false;
                    }
                }
                else
                {
                    // use the system to convert the string to a double
                    doubleValue = Convert.ToDouble(str, CultureInfo.InvariantCulture);
                }

                // if we got here, we should have an appropriate value in doubleValue
                return true;
            }
            catch (OverflowException)
            {
                // overflow mean just return one of the infinity values
                doubleValue = (str[0] == '-'
                  ? Double.NegativeInfinity
                  : Double.PositiveInfinity
                  );

                // and it wasn't "successful"
                return false;
            }
            catch (FormatException)
            {
                // format exception converts to NaN
                doubleValue = double.NaN;

                // not successful
                return false;
            }
        }

        private void AppendImportantComments(BlockStatement block)
        {
            if (block != null)
            {
                // make sure any important comments before the closing brace are kept
                if (m_importantComments.Count > 0
                    && m_settings.PreserveImportantComments
                    && m_settings.IsModificationAllowed(TreeModifications.PreserveImportantComments))
                {
                    // we have important comments before the EOF. Add the comment(s) to the program.
                    foreach (var importantComment in m_importantComments)
                    {
                        block.Append(new ImportantComment(importantComment));
                    }

                    m_importantComments.Clear();
                }
            }
        }

        #endregion

        #region get/peek/scan tokens

        //---------------------------------------------------------------------------------------
        // GetNextToken
        //
        //  Return the next token or peeked token if this.errorToken is not null.
        //  Usually this.errorToken is set by AddError even though any code can look ahead
        //  by assigning this.errorToken.
        //  At this point the context is not saved so if position information is needed
        //  they have to be saved explicitely
        //---------------------------------------------------------------------------------------
        private void GetNextToken()
        {
            // the scanner reuses the same context object for performance,
            // so if we ever mean to hold onto it later, we need to clone it.
            m_currentToken = ScanNextToken();
        }

        private static bool[] InitializeSkippableTokens()
        {
            var skippableTokens = new bool[(int)JSToken.Limit];

            skippableTokens[(int)JSToken.WhiteSpace] =
                skippableTokens[(int)JSToken.EndOfLine] =
                skippableTokens[(int)JSToken.SingleLineComment] =
                skippableTokens[(int)JSToken.MultipleLineComment] =
                skippableTokens[(int)JSToken.PreprocessorDirective] =
                skippableTokens[(int)JSToken.Error] = true;

            return skippableTokens;
        }

        private SourceContext ScanNextToken()
        {
            if (EchoWriter != null)
            {
                if (m_currentToken.IsNot(JSToken.None)) EchoWriter.Write(m_currentToken.Code);
            }

            m_newModule = false;
            m_foundEndOfLine = false;
            m_importantComments.Clear();

            var nextToken = m_scanner.ScanNextToken();
            while (nextToken.IsOne(s_skippableTokens))
            {
                if (nextToken.Is(JSToken.EndOfLine))
                {
                    m_foundEndOfLine = true;
                }
                else if (nextToken.IsEither(JSToken.MultipleLineComment, JSToken.SingleLineComment))
                {
                    if (nextToken.HasCode
                        && ((nextToken.Code.Length > 2 && nextToken.Code[2] == '!')
                        || (nextToken.Code.IndexOf("@preserve", StringComparison.OrdinalIgnoreCase) >= 0)
                        || (nextToken.Code.IndexOf("@license", StringComparison.OrdinalIgnoreCase) >= 0)))
                    {
                        // this is an important comment -- save it for later
                        m_importantComments.Add(nextToken.Clone());
                    }
                }

                // if we are preprocess-only, then don't output any preprocessor directive tokens
                if (EchoWriter != null)
                {
                    if (!Settings.PreprocessOnly || nextToken.Token != JSToken.PreprocessorDirective) EchoWriter.Write(nextToken.Code);
                }

                nextToken = m_scanner.ScanNextToken();
            }

            if (nextToken.Is(JSToken.EndOfFile))
            {
                m_foundEndOfLine = true;
            }

            return nextToken;
        }

        private JSToken PeekToken()
        {
            // clone the scanner, turn off any error reporting, and get the next token
            var clonedScanner = m_scanner.PeekClone();
            clonedScanner.SuppressErrors = true;
            var peekToken = clonedScanner.ScanNextToken();

            // there are some tokens we really don't care about when we peek
            // for the next token
            while (peekToken.IsOne(JSToken.WhiteSpace, JSToken.EndOfLine, JSToken.Error, JSToken.SingleLineComment,
                JSToken.MultipleLineComment, JSToken.PreprocessorDirective, JSToken.ConditionalCommentEnd, JSToken.ConditionalCommentStart,
                JSToken.ConditionalCompilationElse, JSToken.ConditionalCompilationElseIf, JSToken.ConditionalCompilationEnd,
                JSToken.ConditionalCompilationIf, JSToken.ConditionalCompilationOn, JSToken.ConditionalCompilationSet,
                JSToken.ConditionalCompilationVariable, JSToken.ConditionalIf))
            {
                peekToken = clonedScanner.ScanNextToken();
            }

            // return the token type
            return peekToken.Token;
        }

        //private IEnumerable<Context> PeekTokens()
        //{
        //    // clone the scanner, turn off any error reporting, and get the next token
        //    var clonedScanner = m_scanner.Clone();
        //    clonedScanner.SuppressErrors = true;

        //    Context peekToken;
        //    while ((peekToken = clonedScanner.ScanNextToken()).IsNot(JSToken.EndOfFile))
        //    {
        //        // there are some tokens we really don't care about when we peek for the next token
        //        while (peekToken.IsOne(JSToken.WhiteSpace, JSToken.EndOfLine, JSToken.Error, JSToken.SingleLineComment,
        //            JSToken.MultipleLineComment, JSToken.PreprocessorDirective, JSToken.ConditionalCommentEnd, JSToken.ConditionalCommentStart,
        //            JSToken.ConditionalCompilationElse, JSToken.ConditionalCompilationElseIf, JSToken.ConditionalCompilationEnd,
        //            JSToken.ConditionalCompilationIf, JSToken.ConditionalCompilationOn, JSToken.ConditionalCompilationSet,
        //            JSToken.ConditionalCompilationVariable, JSToken.ConditionalIf))
        //        {
        //            peekToken = clonedScanner.ScanNextToken();
        //        }

        //        // return the token type
        //        yield return peekToken;
        //    }
        //}

        private bool PeekCanBeModule()
        {
            // shortcut the whole process. If we KNOW we are parsing ES6, then yes: parse a module
            if (ParsedVersion == ScriptVersion.EcmaScript6 || m_settings.ScriptVersion == ScriptVersion.EcmaScript6)
            {
                return true;
            }

            // clone the scanner, turn off any error reporting, and get the next token
            var clonedScanner = m_scanner.PeekClone();
            clonedScanner.SuppressErrors = true;
            var peekToken = clonedScanner.ScanNextToken();

            // skip whitespace, but not linebreaks
            var lineBreak = false;
            while (peekToken.IsOne(JSToken.WhiteSpace, JSToken.EndOfLine, JSToken.Error, JSToken.SingleLineComment,
                JSToken.MultipleLineComment, JSToken.PreprocessorDirective, JSToken.ConditionalCommentEnd, JSToken.ConditionalCommentStart,
                JSToken.ConditionalCompilationElse, JSToken.ConditionalCompilationElseIf, JSToken.ConditionalCompilationEnd,
                JSToken.ConditionalCompilationIf, JSToken.ConditionalCompilationOn, JSToken.ConditionalCompilationSet,
                JSToken.ConditionalCompilationVariable, JSToken.ConditionalIf))
            {
                if (peekToken.Is(JSToken.EndOfLine))
                {
                    lineBreak = true;
                }

                peekToken = clonedScanner.ScanNextToken();
            }

            // if we have a string literal with no linebreaks in between, or an identifier, then we're good to go.
            return (peekToken.Is(JSToken.StringLiteral) && !lineBreak) || peekToken.Is(JSToken.Identifier) || JSKeyword.CanBeIdentifier(peekToken.Token) != null;
        }

        #endregion

        #region error handlers

        /// <summary>
        /// Handle the expected semicolon at the current position for the given node.
        /// </summary>
        /// <param name="node">node that should end with a semicolon</param>
        private void ExpectSemicolon(AstNode node)
        {
            if (m_currentToken.Is(JSToken.Semicolon))
            {
                node.TerminatingContext = m_currentToken.Clone();
                GetNextToken();
            }
            else if (m_foundEndOfLine || m_currentToken.IsEither(JSToken.RightCurly, JSToken.EndOfFile))
            {
                // semicolon insertion rules
                // a right-curly or an end of line is something we don't WANT to throw a warning for. 
                // Just too common and doesn't really warrant a warning (in my opinion)
                if (m_currentToken.IsNot(JSToken.RightCurly) && m_currentToken.IsNot(JSToken.EndOfFile))
                {
                    ReportError(JSError.SemicolonInsertion, node.Context.IfNotNull(c => c.FlattenToEnd()));
                }
            }
            else
            {
                ReportError(JSError.NoSemicolon, node.Context.IfNotNull(c => c.FlattenToEnd()));
            }
        }

        /// <summary>
        ///  Generate a parser error.
        ///  The function is told whether or not next call to GetToken() should return the same
        ///  token or not
        /// </summary>
        /// <param name="errorId">Error to report</param>
        /// <param name="skipToken">true to move to the next token when GetNextToken is called; false to stay on this token</param>
        /// <param name="context">context to report against, or current token if null</param>
        /// <param name="forceToError">whether to force to an error, or use the default severity</param>
        private void ReportError(JSError errorId, SourceContext context = null, bool forceToError = false)
        {
            context = context ?? m_currentToken.Clone();
            // EOF error is special and it's the last error we can possibly get
            if (JSToken.EndOfFile == context.Token)
            {
                context.HandleError(errorId, true); // EOF context is special
            }
            else
            {
                context.HandleError(errorId, forceToError);
            }
        }

        private void CCTooComplicated(SourceContext context)
        {
            // we ONLY support /*@id@*/ or /*@cc_on@id@*/ or /*@!@*/ or /*@cc_on!@*/ in expressions right now. 
            // throw an error, skip to the end of the comment, then ignore it and start
            // looking for the next token.
            (context ?? m_currentToken).HandleError(JSError.ConditionalCompilationTooComplex);

            // skip to end of conditional comment
            while (m_currentToken.IsNot(JSToken.EndOfFile) && m_currentToken.IsNot(JSToken.ConditionalCommentEnd))
            {
                GetNextToken();
            }
            GetNextToken();
        }

        #endregion
    }

    public sealed class UndefinedReference
    {
        private SourceContext m_context;

        private LookupExpression m_lookup;
        public AstNode LookupNode
        {
            get { return m_lookup; }
        }

        private string m_name;
        private ReferenceType m_type;

        public string Name
        {
            get { return m_name; }
        }

        public ReferenceType ReferenceType
        {
            get { return m_type; }
        }

        public int Column
        {
            get
            {
                if (m_context != null)
                {
                    // one-based
                    return m_context.StartColumn + 1;
                }
                else
                {
                    return 0;
                }
            }
        }

        public int Line
        {
            get
            {
                if (m_context != null)
                {
                    return m_context.StartLineNumber;
                }
                else
                {
                    return 0;
                }
            }
        }

        internal UndefinedReference(LookupExpression lookup, SourceContext context)
        {
            m_lookup = lookup;
            m_name = lookup.Name;
            m_type = lookup.RefType;
            m_context = context;
        }

        public override string ToString()
        {
            return m_name;
        }
    }

    public class UndefinedReferenceEventArgs : EventArgs
    {
        public UndefinedReference Reference { get; private set; }

        public UndefinedReferenceEventArgs(UndefinedReference reference)
        {
            Reference = reference;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using Kooboo.Lib.NUglify.JavaScript;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript
{
    public enum ScriptVersion
    {
        None = 0,
        EcmaScript5,
        EcmaScript6,
    }

    /// <summary>
    /// Class used to parse JavaScript source code into an abstract syntax tree.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
    public class JSParser
    {
        #region private fields

        private static bool[] s_skippableTokens = InitializeSkippableTokens();

        private GlobalScope m_globalScope;
        private JSScanner m_scanner;
        private SourceContext m_currentToken;

        private bool m_newModule;

        private CodeSettings m_settings;// = null;

        private bool m_foundEndOfLine;
        private IList<SourceContext> m_importantComments;

        private Dictionary<string, LabelInfo> m_labelInfo;

        #endregion

        #region private properties

        private SourceContext CurrentPositionContext
        {
            get
            {
                return m_currentToken.FlattenToStart();
            }
        }

        #endregion

        #region public properties

        // we're going to copy the debug lookups from the settings passed to us,
        // then use this collection, because we might programmatically add more
        // as we process the code, and we don't want to change the settings object.
        public ICollection<string> DebugLookups { get; private set; }

        public ScriptVersion ParsedVersion { get; private set; }

        public CodeSettings Settings
        {
            get
            {
                // if it's null....
                if (m_settings == null)
                {
                    // just use the default settings
                    m_settings = new CodeSettings();
                }
                return m_settings;
            }
            set
            {
                // if setting null, use the default settings object
                m_settings = value ?? new CodeSettings();
            }
        }

        /// <summary>
        /// Gets or sets a TextWriter instance to which raw preprocessed input will be
        /// written when Parse is called.
        /// </summary>
        public TextWriter EchoWriter { get; set; }

        public GlobalScope GlobalScope
        {
            get
            {
                // if we don't have one yet, create a new one
                if (m_globalScope == null)
                {
                    m_globalScope = new GlobalScope(m_settings);
                }

                return m_globalScope;
            }
            set
            {
                // if we are setting the global scope, we are using a shared global scope.
                m_globalScope = value;

                // mark all existing child scopes as existing so we don't go through
                // them again and re-optimize
                if (m_globalScope != null)
                {
                    foreach (var childScope in m_globalScope.ChildScopes)
                    {
                        childScope.Existing = true;
                    }
                }
            }
        }

        /// <summary>
        /// Gets the array of timing points from a Parse run
        /// </summary>
        private long[] m_timingPoints;
        public IList<long> TimingPoints { get { return m_timingPoints; } }

        #endregion

        #region public events

        /// <summary>
        /// Event sent whenever an error or warning is encountered during parsing
        /// </summary>
        public event EventHandler<ContextErrorEventArgs> CompilerError;

        /// <summary>
        /// Sent for undefined references found during parsing
        /// </summary>
        public event EventHandler<UndefinedReferenceEventArgs> UndefinedReference;

        #endregion

        #region public constructor

        /// <summary>
        /// Creates an instance of the JavaScript parser object
        /// </summary>
        public JSParser()
        {
            m_importantComments = new List<SourceContext>();
            m_labelInfo = new Dictionary<string, LabelInfo>();
        }

        /// <summary>
        /// Creates an instance of the JSParser class that can be used to parse the given source code.
        /// </summary>
        /// <param name="source">Source code to parse.</param>
        [Obsolete("This Constructor will be removed in version 6. Please use the default constructor.", false)]
        public JSParser(string source) : this()
        {
            // set the source now using an empty context
            SetDocumentContext(new DocumentContext(source));
        }

        #endregion

        #region public methods

        /// <summary>
        /// Parse the given source context into an abstract syntax tree
        /// </summary>
        /// <param name="sourceContext">source code with context</param>
        /// <returns>a Block object representing the series of statements in abstract syntax tree form</returns>
        public BlockStatement Parse(DocumentContext sourceContext)
        {
            SetDocumentContext(sourceContext);

            // if a settings object hasn't been set yet, create a default settings object now
            if (m_settings == null)
            {
                m_settings = new CodeSettings();
            }

            // clear out some collections in case there was stuff left over from
            // a previous parse run
            m_importantComments.Clear();
            m_labelInfo.Clear();

            return InternalParse();
        }

        /// <summary>
        /// Parse the given source with context into an abstract syntax tree using the given settings
        /// </summary>
        /// <param name="sourceContext">source code with context</param>
        /// <param name="settings">settings to use for the parse operation</param>
        /// <returns>a Block object representing the series of statements in abstract syntax tree form</returns>
        public BlockStatement Parse(DocumentContext sourceContext, CodeSettings settings)
        {
            this.Settings = settings;
            return Parse(sourceContext);
        }

        /// <summary>
        /// Parse the given source into an abstract syntax tree with no context
        /// </summary>
        /// <param name="source">source code with no context</param>
        /// <returns>a Block object representing the series of statements in abstract syntax tree form</returns>
        public BlockStatement Parse(string source)
        {
            return Parse(new DocumentContext(source));
        }

        /// <summary>
        /// Parse the given source into an abstract syntax tree using the given settings
        /// </summary>
        /// <param name="source">source code to parse</param>
        /// <param name="settings">settings to use for the parse operation</param>
        /// <returns>a Block object representing the series of statements in abstract syntax tree form</returns>
        public BlockStatement Parse(string source, CodeSettings settings)
        {
            this.Settings = settings;
            return Parse(source);
        }

        /// <summary>
        /// Parse the source code using the given settings, getting back an abstract syntax tree Block node as the root
        /// representing the list of statements in the source code.
        /// </summary>
        /// <param name="settings">code settings to use to process the source code</param>
        /// <returns>root Block node representing the top-level statements</returns>
        [Obsolete("This method will be removed in version 6. Please use the default constructor and use a Parse override that is passed the source.", false)]
        public BlockStatement Parse(CodeSettings settings)
        {
            if (m_scanner == null)
            {
                throw new InvalidOperationException(JScript.NoSource);
            }

            // initialize the scanner with our settings
            // make sure the RawTokens setting is OFF or we won't be able to create our AST
            // save the settings
            // if we are passed null, just create a default settings object
            m_settings = settings = settings ?? new CodeSettings();

            return InternalParse();
        }

        #endregion

        #region common parse entry point

        /// <summary>
        /// Parse the document source using the scanner and settings that have all been set up already
        /// through various combinations of constructor/properties/Parse methods.
        /// </summary>
        /// <returns>Parsed Block node</returns>
        private BlockStatement InternalParse()
        {
            // if the settings list is not null, use it to initialize a new list
            // with the same settings. If it is null, initialize an empty list 
            // because we already determined that we want to strip debug statements,
            // and the scanner might add items to the list as it scans the source.
            DebugLookups = new HashSet<string>(m_settings.DebugLookupCollection);

            // pass our list to the scanner -- it might add more as we encounter special comments
            m_scanner.DebugLookupCollection = DebugLookups;

            m_scanner.AllowEmbeddedAspNetBlocks = m_settings.AllowEmbeddedAspNetBlocks;
            m_scanner.IgnoreConditionalCompilation = m_settings.IgnoreConditionalCompilation;

            // set any defines
            m_scanner.UsePreprocessorDefines = !m_settings.IgnorePreprocessorDefines;
            if (m_scanner.UsePreprocessorDefines)
            {
                m_scanner.SetPreprocessorDefines(m_settings.PreprocessorValues);
            }

            // if we want to strip debug statements, let's also strip ///#DEBUG comment
            // blocks for legacy reasons. ///#DEBUG will get stripped ONLY is this
            // flag is true AND the name "DEBUG" is not in the preprocessor defines.
            // Alternately, we will keep those blocks in the output is this flag is
            // set to false OR we define "DEBUG" in the preprocessor defines.
            m_scanner.StripDebugCommentBlocks = m_settings.StripDebugStatements;

            // assume ES5 unless we find ES6-specific constructs
            ParsedVersion = ScriptVersion.EcmaScript5;

            // make sure we initialize the global scope's strict mode to our flag, whether or not it
            // is true. This means if the setting is false, we will RESET the flag to false if we are 
            // reusing the scope and a previous Parse call had code that set it to strict with a 
            // program directive. 
            GlobalScope.UseStrict = m_settings.StrictMode;

            // make sure the global scope knows about our known global names
            GlobalScope.SetAssumedGlobals(m_settings);

            // start of a new module
            m_newModule = true;

            var timePoints = m_timingPoints = new long[9];
            var timeIndex = timePoints.Length;
            var stopWatch = new Stopwatch();
            stopWatch.Start();

            // get the first token.
            GetNextToken();

            BlockStatement scriptBlock = null;
            BlockStatement returnBlock = null;
            switch (m_settings.SourceMode)
            {
                case JavaScriptSourceMode.Program:
                    // simply parse a block of statements.
                    // however, when parsing this block, we mght determine it's really part of
                    // a larger structure, and we could return a different block that we would need
                    // to continue processing.
                    scriptBlock = returnBlock = ParseStatements(new BlockStatement(CurrentPositionContext)
                        {
                            EnclosingScope = this.GlobalScope
                        });
                    break;

                case JavaScriptSourceMode.Module:
                    // an implicit module as referenced by an import statement.
                    // create a root block with the global scope, add a module with its module body,
                    // then parse the input as statements into the module body.
                    returnBlock = scriptBlock = new BlockStatement(CurrentPositionContext)
                        {
                            EnclosingScope = this.GlobalScope
                        };
                    var module = new ModuleDeclaration(CurrentPositionContext)
                        {
                            IsImplicit = true,
                            Body = new BlockStatement(CurrentPositionContext)
                                {
                                    IsModule = true
                                }
                        };
                    scriptBlock.Append(module);

                    // we just created an implicit ES6 module, so we are already parsing as ES6
                    ParsedVersion = ScriptVersion.EcmaScript6;

                    // we don't need to worry about this function returning a different block, because
                    // we've already created the module structure.
                    ParseStatements(module.Body);
                    break;

                case JavaScriptSourceMode.Expression:
                    // create a block, get the first token, add in the parse of a single expression, 
                    // and we'll go fron there.
                    returnBlock = scriptBlock = new BlockStatement(CurrentPositionContext)
                        {
                            EnclosingScope = this.GlobalScope
                        };
                    try
                    {
                        var expr = ParseExpression();
                        if (expr != null)
                        {
                            scriptBlock.Append(expr);
                            scriptBlock.UpdateWith(expr.Context);
                        }
                    }
                    catch (EndOfStreamException)
                    {
                        Debug.WriteLine("EOF");
                    }
                    break;

                case JavaScriptSourceMode.EventHandler:
                    // we're going to create the global block, add in a function expression with a single
                    // parameter named "event", and then we're going to parse the input as the body of that
                    // function expression. We're going to resolve the global block, but only return the body
                    // of the function.
                    scriptBlock = new BlockStatement(CurrentPositionContext)
                        {
                            EnclosingScope = this.GlobalScope
                        };

                    var parameters = new AstNodeList(CurrentPositionContext);
                    parameters.Append(new ParameterDeclaration(CurrentPositionContext)
                        {
                            Binding = new BindingIdentifier(CurrentPositionContext)
                            {
                                Name = "event",
                                RenameNotAllowed = true
                            }
                        });

                    var funcExpression = new FunctionObject(CurrentPositionContext)
                        {
                            FunctionType = FunctionType.Expression,
                            ParameterDeclarations = parameters,
                            Body = new BlockStatement(CurrentPositionContext)
                        };
                    scriptBlock.Append(funcExpression);
                    ParseFunctionBody(funcExpression.Body);

                    // but we ONLY want to return the body
                    returnBlock = funcExpression.Body;
                    break;

                default:
                    Debug.Fail("Unexpected source mode enumeration");
                    return null;
            }

            timePoints[--timeIndex] = stopWatch.ElapsedTicks;

            // resolve everything
            ResolutionVisitor.Apply(scriptBlock, GlobalScope, this);
            timePoints[--timeIndex] = stopWatch.ElapsedTicks;

            if (Settings.AmdSupport)
            {
                // we're doing some AMD support. At this time, walk through the top-level
                // statements and if there are any duplicate define(name... calls, remove all
                // but the last one.
                RemoveDuplicateDefines(scriptBlock);
            }

            if (scriptBlock != null && Settings.MinifyCode && !Settings.PreprocessOnly)
            {
                // this visitor doesn't just reorder scopes. It also combines the adjacent var variables,
                // unnests blocks, identifies prologue directives, and sets the strict mode on scopes. 
                ReorderScopeVisitor.Apply(scriptBlock, this);

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // analyze the entire node tree (needed for hypercrunch)
                // root to leaf (top down)
                var analyzeVisitor = new AnalyzeNodeVisitor(this);
                scriptBlock.Accept(analyzeVisitor);

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // analyze the scope chain (also needed for hypercrunch)
                // root to leaf (top down)
                GlobalScope.AnalyzeScope();

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // if we want to crunch any names....
                if (m_settings.LocalRenaming != LocalRenaming.KeepAll
                    && m_settings.IsModificationAllowed(TreeModifications.LocalRenaming))
                {
                    // then do a top-down traversal of the scope tree. For each field that had not
                    // already been crunched (globals and outers will already be crunched), crunch
                    // the name with a crunch iterator that does not use any names in the verboten set.
                    GlobalScope.AutoRenameFields();
                }

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // if we want to evaluate literal expressions, do so now
                if (m_settings.EvalLiteralExpressions)
                {
                    var visitor = new EvaluateLiteralVisitor(this);
                    scriptBlock.Accept(visitor);
                }

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // make the final cleanup pass
                FinalPassVisitor.Apply(scriptBlock, m_settings);

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;

                // we want to walk all the scopes to make sure that any generated
                // variables that haven't been crunched have been assigned valid
                // variable names that don't collide with any existing variables.
                GlobalScope.ValidateGeneratedNames();

                timePoints[--timeIndex] = stopWatch.ElapsedTicks;
                stopWatch.Stop();
            }

            // mark all child scopes under the global scope as existing so we don't go and re-optimize
            // them again should we parse another piece of source code using the same parser
            foreach (var childScope in GlobalScope.ChildScopes)
            {
                childScope.Existing = true;
            }

            // if the return block is not the entire script block, then we don't want to include
            // any thing we must've generated in the process of building our code. Take the scope
            // from the parent, but break the tree relationship.
            if (returnBlock != scriptBlock)
            {
                returnBlock.EnclosingScope = returnBlock.Parent.EnclosingScope;
                returnBlock.Parent = null;
            }

            return returnBlock;
        }

        /// <summary>
        /// Remove duplicate define calls, defined as defines with the same module name specified as the first
        /// parameter, if it's a string literal. Only the last define with a given name is preserved.
        /// </summary>
        /// <param name="scriptBlock">script block to remove defines from; not recursed</param>
        private static void RemoveDuplicateDefines(BlockStatement scriptBlock)
        {
            var defines = new HashSet<string>();

            // walk backwards so we keep the last one
            for(var ndx = scriptBlock.Count - 1; ndx >= 0; --ndx)
            {
                if (scriptBlock[ndx] is CallExpression callNode)
                {
                    if (callNode.Function.IsGlobalNamed("define") 
                        && callNode.Arguments.IfNotNull(args => args.Count) > 0)
                    {
                        if (callNode.Arguments[0] is ConstantWrapper firstArg && firstArg.PrimitiveType == PrimitiveType.String)
                        {
                            var moduleName = firstArg.ToString();
                            if (!defines.Add(moduleName))
                            {
                                // couldn't add the name to the set -- must be a dupe!
                                // remove it altogether
                                scriptBlock.RemoveAt(ndx);
                            }
                        }
                    }
                }
            }
        }

        #endregion

        #region event methods

        internal void OnUndefinedReference(UndefinedReference ex)
        {
            if (UndefinedReference != null)
            {
                UndefinedReference(this, new UndefinedReferenceEventArgs(ex));
            }
        }

        internal void OnCompilerError(UglifyError se)
        {
            if (CompilerError != null && !m_settings.IgnoreAllErrors)
            {
                // format the error code
                if (m_settings != null && !m_settings.IgnoreErrorCollection.Contains(se.ErrorCode))
                {
                    CompilerError(this, new ContextErrorEventArgs()
                        {
                            Error = se
                        });
                }
            }
        }

        #endregion

        #region ParseStatements

        //---------------------------------------------------------------------------------------
        // ParseStatements
        //
        // statements :
        //   <empty> |
        //   statement statements
        //
        //---------------------------------------------------------------------------------------
        private BlockStatement ParseStatements(BlockStatement block)
        {
            // by default we should return the block we were passed in.
            // the only time we might return a different block is if we decide later on if
            // this block is really an implicit module body, in which case we will return a
            // different block that contains the module declaration with the passed-in block
            // as the body.
            var returnBlock = block;
            try
            {
                var possibleDirectivePrologue = true;
                int lastEndPosition = m_currentToken.EndPosition;
                while (m_currentToken.IsNot(JSToken.EndOfFile))
                {
                    AstNode ast = null;
                    // parse a statement -- pass true because we really want a SourceElement,
                    // which is a Statement OR a FunctionDeclaration. Technically, FunctionDeclarations
                    // are not statements!
                    ast = ParseStatement(true);

                    // if we are still possibly looking for directive prologues
                    if (possibleDirectivePrologue)
                    {
                        if (ast is ConstantWrapper constantWrapper && constantWrapper.PrimitiveType == PrimitiveType.String)
                        {
                            if (!(constantWrapper is DirectivePrologue))
                            {
                                // use a directive prologue node instead
                                ast = new DirectivePrologue(constantWrapper.Value.ToString(), ast.Context)
                                    {
                                        MayHaveIssues = constantWrapper.MayHaveIssues
                                    };
                            }
                        }
                        else if (!m_newModule)
                        {
                            // nope -- no longer finding directive prologues
                            possibleDirectivePrologue = false;
                        }
                    }
                    else if (m_newModule)
                    {
                        // we aren't looking for directive prologues anymore, but we did scan
                        // into a new module after that last AST, so reset the flag because that
                        // new module might have directive prologues for next time
                        possibleDirectivePrologue = true;
                    }

                    if (ast != null)
                    {
                        // append the statement to the program
                        block.Append(ast);

                        // if this was an export statement, then we know the block as a module.
                        // if we didn't know that before, then we have some conversion to take
                        // care of.
                        if (ast is ExportStatement && !block.IsModule)
                        {
                            // this block will be the module body
                            block.IsModule = true;

                            // should only happen if we are processing a root program
                            if (block.Parent == null)
                            {
                                // create a new block that has the global scope and remove the
                                // global scope from this block
                                returnBlock = new BlockStatement(block.Context.Clone())
                                    {
                                        EnclosingScope = block.EnclosingScope
                                    };
                                block.EnclosingScope = null;

                                // add a new implicit module declaration to the new global block, with the block
                                // we've been processing as its body. we'll return the new global block.
                                returnBlock.Append(new ModuleDeclaration(new SourceContext(m_currentToken.Document))
                                    {
                                        IsImplicit = true,
                                        Body = block,
                                    });
                            }
                        }

                        // set the last end position to be the start of the current token.
                        // if we parse the next statement and the end is still the start, we know
                        // something is up and might get into an infinite loop.
                        lastEndPosition = m_currentToken.EndPosition;
                    }
                    else if (!m_scanner.IsEndOfFile && m_currentToken.StartLinePosition == lastEndPosition)
                    {
                        // didn't parse a statement, we're not at the EOF, and we didn't move
                        // anywhere in the input stream. If we just keep looping around, we're going
                        // to get into an infinite loop. Break it.
                        m_currentToken.HandleError(JSError.ApplicationError, true);
                        break;
                    }
                }

                AppendImportantComments(block);

            }
            catch (EndOfStreamException)
            {
                // we're done
            }

            block.UpdateWith(CurrentPositionContext);
            return returnBlock;
        }

        //---------------------------------------------------------------------------------------
        // ParseStatement
        //
        //  OptionalStatement:
        //    Statement |
        //    <empty>
        //
        //  Statement :
        //    Block |
        //  VariableStatement |
        //  EmptyStatement |
        //  ExpressionStatement |
        //  IfStatement |
        //  IterationStatement |
        //  ContinueStatement |
        //  BreakStatement |
        //  ReturnStatement |
        //  WithStatement |
        //  LabeledStatement |
        //  SwitchStatement |
        //  ThrowStatement |
        //  TryStatement |
        //  FunctionDeclaration
        //
        // IterationStatement :
        //    'for' '(' ForLoopControl ')' |                  ===> ForStatement
        //    'do' Statement 'while' '(' Expression ')' |     ===> DoStatement
        //    'while' '(' Expression ')' Statement            ===> WhileStatement
        //
        //---------------------------------------------------------------------------------------

        // ParseStatement deals with the end of statement issue (EOL vs ';') so if any of the
        // ParseXXX routine does it as well, it should return directly from the switch statement
        // without any further execution in the ParseStatement
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private AstNode ParseStatement(bool fSourceElement, bool skipImportantComment = false)
        {
            AstNode statement = null;

            // if we want to skip important comments, now is a good time to clear anything we may 
            // have picked up already.
            if (skipImportantComment)
            {
                m_importantComments.Clear();
            }

            if (m_importantComments.Count > 0
                && m_settings.PreserveImportantComments
                && m_settings.IsModificationAllowed(TreeModifications.PreserveImportantComments))
            {
                // we have at least one important comment before the upcoming statement.
                // pop the first important comment off the queue, return that node instead.
                // don't advance the token -- we'll probably be coming back again for the next one (if any)
                statement = new ImportantComment(m_importantComments[0]);
                m_importantComments.RemoveAt(0);
            }
            else
            {
                switch (m_currentToken.Token)
                {
                    case JSToken.EndOfFile:
                        ReportError(JSError.ErrorEndOfFile);
                        return null; // abort parsing, get back to the main parse routine

                    case JSToken.Semicolon:
                        // make an empty statement
                        statement = new EmptyStatement(m_currentToken.Clone());
                        GetNextToken();
                        return statement;

                    case JSToken.RightCurly:
                        ReportError(JSError.SyntaxError);
                        GetNextToken();
                        break;

                    case JSToken.LeftCurly:
                        return ParseBlock();

                    case JSToken.Debugger:
                        return ParseDebuggerStatement();

                    case JSToken.Var:
                    case JSToken.Const:
                    case JSToken.Let:
                        return ParseVariableStatement();

                    case JSToken.If:
                        return ParseIfStatement();

                    case JSToken.For:
                        return ParseForStatement();

                    case JSToken.Do:
                        return ParseDoStatement();

                    case JSToken.While:
                        return ParseWhileStatement();

                    case JSToken.Continue:
                        return ParseContinueStatement();

                    case JSToken.Break:
                        return ParseBreakStatement();

                    case JSToken.Return:
                        return ParseReturnStatement();

                    case JSToken.With:
                        return ParseWithStatement();

                    case JSToken.Switch:
                        return ParseSwitchStatement();

                    case JSToken.Throw:
                        return ParseThrowStatement();

                    case JSToken.Try:
                        return ParseTryStatement();

                    case JSToken.Async:
                        // Treat `async(` as if its a normal expression
                        if (PeekToken() == JSToken.LeftParenthesis)
                        {
                            goto default;
                        }
                        else
                        {
                            // Treat 'async function' as a function declaration
                            goto case (JSToken.Function);
                        }
                    case JSToken.Function:
                        {
                            // parse a function declaration
                            var function = ParseFunction(FunctionType.Declaration, m_currentToken.Clone());
                            function.IsSourceElement = fSourceElement;
                            return function;
                        }
                    case JSToken.Class:
                        return ParseClassNode(ClassType.Declaration);

                    case JSToken.Else:
                        ReportError(JSError.InvalidElse);
                        GetNextToken();
                        break;

                    case JSToken.ConditionalCommentStart:
                        return ParseStatementLevelConditionalComment(fSourceElement);

                    case JSToken.ConditionalCompilationOn:
                        var ccOn = new ConditionalCompilationOn(m_currentToken.Clone());
                        GetNextToken();
                        return ccOn;

                    case JSToken.ConditionalCompilationSet:
                        return ParseConditionalCompilationSet();

                    case JSToken.ConditionalCompilationIf:
                        return ParseConditionalCompilationIf(false);

                    case JSToken.ConditionalCompilationElseIf:
                        return ParseConditionalCompilationIf(true);

                    case JSToken.ConditionalCompilationElse:
                        var elseStatement = new ConditionalCompilationElse(m_currentToken.Clone());
                        GetNextToken();
                        return elseStatement;

                    case JSToken.ConditionalCompilationEnd:
                        var endStatement = new ConditionalCompilationEnd(m_currentToken.Clone());
                        GetNextToken();
                        return endStatement;

                    case JSToken.Import:
                        // import can't be an identifier name, so it must be an import statement
                        return ParseImport();

                    case JSToken.Export:
                        // export can't be an identifier name, so it must be an export statement
                        return ParseExport();

                    case JSToken.Identifier:
                        if (m_currentToken.Is("module"))
                        {
                            goto case JSToken.Module;
                        }
                        goto default;

                    case JSToken.Module:
                        if (PeekCanBeModule())
                        {
                            return ParseModule();
                        }
                        goto default;

                    default:
                        statement = ParseExpressionStatement(fSourceElement);
                        break;
                }
            }

            return statement;
        }

        private AstNode ParseExpressionStatement(bool fSourceElement)
        {
            bool bAssign;
            var isNewModule = m_newModule;
            var statement = ParseUnaryExpression(out bAssign, false);
            if (statement != null)
            {
                // look for labels
                if (statement is LookupExpression lookup && m_currentToken.Is(JSToken.Colon))
                {
                    statement = ParseLabeledStatement(lookup, fSourceElement);
                }
                else
                {
                    // finish off the expression using the unary as teh starting point
                    statement = ParseExpression(statement, false, bAssign, JSToken.None);

                    // if we just started a new module and this statement happens to be an expression statement...
                    if (isNewModule && statement.IsExpression)
                    {
                        // see if it's a constant wrapper
                        if (statement is ConstantWrapper constantWrapper && constantWrapper.PrimitiveType == PrimitiveType.String)
                        {
                            // we found a string constant expression statement right after the start of a new
                            // module. Let's make it a DirectivePrologue if it isn't already
                            if (!(statement is DirectivePrologue))
                            {
                                statement = new DirectivePrologue(constantWrapper.Value.ToString(), constantWrapper.Context)
                                {
                                    MayHaveIssues = constantWrapper.MayHaveIssues
                                };
                            }
                        }
                    }

                    if (statement is BinaryExpression binaryOp
                        && (binaryOp.OperatorToken == JSToken.Equal || binaryOp.OperatorToken == JSToken.StrictEqual))
                    {
                        // an expression statement with equality operator? Doesn't really do anything.
                        // Did the developer intend this to be an assignment operator instead? Low-pri warning.
                        binaryOp.OperatorContext.IfNotNull(c => c.HandleError(JSError.SuspectEquality, false));
                    }

                    lookup = statement as LookupExpression;
                    if (statement is LookupExpression lookup
                        && lookup.Name.StartsWith("<%=", StringComparison.Ordinal) && lookup.Name.EndsWith("%>", StringComparison.Ordinal))
                    {
                        // single lookup, but it's actually one or more ASP.NET blocks.
                        // convert back to an asp.net block node
                        statement = new AspNetBlockNode(statement.Context)
                        {
                            AspNetBlockText = lookup.Name
                        };
                    }

                    if (statement is AspNetBlockNode aspNetBlock && m_currentToken.Is(JSToken.Semicolon))
                    {
                        aspNetBlock.IsTerminatedByExplicitSemicolon = true;
                        statement.IfNotNull(s => s.TerminatingContext = m_currentToken.Clone());
                        GetNextToken();
                    }

                    // we just parsed an expression statement. Now see if we have an appropriate
                    // semicolon to terminate it.
                    ExpectSemicolon(statement);
                }
            }
            else
            {
                // couldn't parse a statement and couldn't parse an expression; skip it
                // TODO: error node?
                GetNextToken();
            }

            return statement;
        }

        private LabeledStatement ParseLabeledStatement(LookupExpression lookup, bool fSourceElement)
        {
            // can be a label
            var id = lookup.Name;
            var colonContext = m_currentToken.Clone();

            LabelInfo labelInfo;
            var removeInfo = true;
            if (m_labelInfo.TryGetValue(id, out labelInfo))
            {
                // already exists! throw an error and mark this label as having an error
                labelInfo.HasIssues = true;
                removeInfo = false;
                lookup.Context.HandleError(JSError.BadLabel, true);
            }
            else
            {
                // zero-based nest level corresponds to how many labels we are working with
                // so far. and a zero reference count
                labelInfo = new LabelInfo { NestLevel = m_labelInfo.Count, RefCount = 0 };
                m_labelInfo.Add(id, labelInfo);
            }

            GetNextToken();
            LabeledStatement labeledStatement;
            if (m_currentToken.IsNot(JSToken.EndOfFile))
            {
                // ignore any important comments between the label and its statement
                // because important comments are treated like statements, and we want
                // to make sure the label is attached to the right REAL statement.
                labeledStatement = new LabeledStatement(lookup.Context.Clone())
                {
                    Label = id,
                    LabelContext = lookup.Context,
                    LabelInfo = labelInfo,
                    ColonContext = colonContext,
                    Statement = ParseStatement(fSourceElement, true)
                };
            }
            else
            {
                // end of the file!
                // just pass null for the labeled statement
                labeledStatement = new LabeledStatement(lookup.Context.Clone())
                {
                    Label = id,
                    LabelContext = lookup.Context,
                    LabelInfo = labelInfo,
                    ColonContext = colonContext,
                };
            }

            if (removeInfo)
            {
                m_labelInfo.Remove(id);
            }

            return labeledStatement;
        }

        private AstNode ParseStatementLevelConditionalComment(bool fSourceElement)
        {
            SourceContext context = m_currentToken.Clone();
            ConditionalCompilationComment conditionalComment = new ConditionalCompilationComment(context);

            GetNextToken();
            while (m_currentToken.IsNot(JSToken.ConditionalCommentEnd) && m_currentToken.IsNot(JSToken.EndOfFile))
            {
                // if we get ANOTHER start token, it's superfluous and we should ignore it.
                // otherwise parse another statement and keep going
                if (m_currentToken.Is(JSToken.ConditionalCommentStart))
                {
                    GetNextToken();
                }
                else
                {
                    conditionalComment.Append(ParseStatement(fSourceElement));
                }
            }

            GetNextToken();

            // if the conditional comment is empty (for whatever reason), then
            // we don't want to return anything -- we found nothing.
            return conditionalComment.Statements.Count > 0 ? conditionalComment : null;
        }

        private ConditionalCompilationSet ParseConditionalCompilationSet()
        {
            SourceContext context = m_currentToken.Clone();
            string variableName = null;
            AstNode value = null;
            GetNextToken();
            if (m_currentToken.Is(JSToken.ConditionalCompilationVariable))
            {
                context.UpdateWith(m_currentToken);
                variableName = m_currentToken.Code;
                GetNextToken();
                if (m_currentToken.Is(JSToken.Assign))
                {
                    context.UpdateWith(m_currentToken);
                    GetNextToken();
                    value = ParseExpression(false);
                    if (value != null)
                    {
                        context.UpdateWith(value.Context);
                    }
                    else
                    {
                        m_currentToken.HandleError(JSError.ExpressionExpected);
                    }
                }
                else
                {
                    m_currentToken.HandleError(JSError.NoEqual);
                }
            }
            else
            {
                m_currentToken.HandleError(JSError.NoIdentifier);
            }

            return new ConditionalCompilationSet(context)
                {
                    VariableName = variableName,
                    Value = value
                };
        }

        private ConditionalCompilationStatement ParseConditionalCompilationIf(bool isElseIf)
        {
            SourceContext context = m_currentToken.Clone();
            AstNode condition = null;
            GetNextToken();
            if (m_currentToken.Is(JSToken.LeftParenthesis))
            {
                context.UpdateWith(m_currentToken);
                GetNextToken();
                condition = ParseExpression(false);
                if (condition != null)
                {
                    context.UpdateWith(condition.Context);
                }
                else
                {
                    m_currentToken.HandleError(JSError.ExpressionExpected);
                }

                if (m_currentToken.Is(JSToken.RightParenthesis))
                {
                    context.UpdateWith(m_currentToken);
                    GetNextToken();
                }
                else
                {
                    m_currentToken.HandleError(JSError.NoRightParenthesis);
                }
            }
            else
            {
                m_currentToken.HandleError(JSError.NoLeftParenthesis);
            }

            if (isElseIf)
            {
                return new ConditionalCompilationElseIf(context)
                    {
                        Condition = condition
                    };
            }

            return new ConditionalCompilationIf(context)
                {
                    Condition = condition
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseBlock
        //
        //  Block :
        //    '{' OptionalStatements '}'
        //---------------------------------------------------------------------------------------
        private BlockStatement ParseBlock()
        {
            // set the force-braces property to true because we are assuming this is only called
            // when we encounter a left-brace and we will want to keep it going forward. If we are optimizing
            // the code, we will reset these properties as we encounter them so that unneeded curly-braces 
            // can be removed.
            BlockStatement codeBlock = new BlockStatement(m_currentToken.Clone())
                {
                    ForceBraces = true
                };
            codeBlock.BraceOnNewLine = m_foundEndOfLine;
            GetNextToken();

            while (m_currentToken.IsNot(JSToken.RightCurly) && m_currentToken.IsNot(JSToken.EndOfFile))
            {
                // pass false because we really only want Statements, and FunctionDeclarations
                // are technically not statements. We'll still handle them, but we'll issue a warning.
                codeBlock.Append(ParseStatement(false));
            }

            // make sure any important comments before the closing brace are kept
            AppendImportantComments(codeBlock);

            if (m_currentToken.IsNot(JSToken.RightCurly))
            {
                ReportError(JSError.NoRightCurly);
                if (m_currentToken.Is(JSToken.EndOfFile))
                {
                    ReportError(JSError.ErrorEndOfFile);
                }
            }

            codeBlock.TerminatingContext = m_currentToken.Clone();
            // update the block context
            codeBlock.Context.UpdateWith(m_currentToken);
            GetNextToken();
            return codeBlock;
        }

        //---------------------------------------------------------------------------------------
        // ParseDebuggerStatement
        //
        //  DebuggerStatement :
        //    'debugger'
        //
        // This function may return a null AST under error condition. The caller should handle
        // that case.
        // Regardless of error conditions, on exit the parser points to the first token after
        // the debugger statement
        //---------------------------------------------------------------------------------------
        private AstNode ParseDebuggerStatement()
        {
            // clone the current context and skip it
            var node = new DebuggerNode(m_currentToken.Clone());
            GetNextToken();

            // this token can only be a stand-alone statement
            ExpectSemicolon(node);

            // return the new AST object
            return node;
        }

        //---------------------------------------------------------------------------------------
        // ParseVariableStatement
        //
        //  VariableStatement :
        //    'var' VariableDeclarationList
        //    or
        //    'const' VariableDeclarationList
        //    or
        //    'let' VariableDeclarationList
        //
        //  VariableDeclarationList :
        //    VariableDeclaration |
        //    VariableDeclaration ',' VariableDeclarationList
        //
        //  VariableDeclaration :
        //    Binding |
        //    Binding Initializer
        //
        //  Initializer :
        //    <empty> |
        //    '=' AssignmentExpression
        //---------------------------------------------------------------------------------------
        private AstNode ParseVariableStatement()
        {
            // create the appropriate statement: var- or const-statement
            Declaration varList;
            if (m_currentToken.Is(JSToken.Var))
            {
                varList = new VarDeclaration(m_currentToken.Clone())
                    {
                        StatementToken = m_currentToken.Token,
                        KeywordContext = m_currentToken.Clone()
                    };
            }
            else if (m_currentToken.IsEither(JSToken.Const, JSToken.Let))
            {
                if (m_currentToken.Is(JSToken.Const) && m_settings.ConstStatementsMozilla)
                {
                    varList = new ConstStatement(m_currentToken.Clone())
                        {
                            StatementToken = m_currentToken.Token,
                            KeywordContext = m_currentToken.Clone()
                        };
                }
                else
                {
                    // this is EcmaScript6-specific statement
                    ParsedVersion = ScriptVersion.EcmaScript6;
                    varList = new LexicalDeclaration(m_currentToken.Clone())
                        {
                            StatementToken = m_currentToken.Token,
                            KeywordContext = m_currentToken.Clone()
                        };
                }
            }
            else
            {
                Debug.Fail("shouldn't get here");
                return null;
            }

            do
            {
                GetNextToken();
                var varDecl = ParseVarDecl(JSToken.None);
                if (varDecl != null)
                {
                    varList.Append(varDecl);
                    varList.Context.UpdateWith(varDecl.Context);
                }
            }
            while (m_currentToken.Is(JSToken.Comma));

            ExpectSemicolon(varList);
            return varList;
        }

        private VariableDeclaration ParseVarDecl(JSToken inToken)
        {
            SourceContext context = m_currentToken.Clone();
            VariableDeclaration varDecl = null;
            var binding = ParseBinding();
            if (binding != null)
            {
                SourceContext assignContext = null;
                AstNode initializer = null;

                bool ccSpecialCase = false;
                bool ccOn = false;

                if (m_currentToken.Is(JSToken.ConditionalCommentStart))
                {
                    ccSpecialCase = true;

                    GetNextToken();
                    if (m_currentToken.Is(JSToken.ConditionalCompilationOn))
                    {
                        GetNextToken();
                        if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                        {
                            // forget about it; just ignore the whole thing because it's empty
                            ccSpecialCase = false;
                        }
                        else
                        {
                            ccOn = true;
                        }
                    }
                }

                if (m_currentToken.IsEither(JSToken.Assign, JSToken.Equal))
                {
                    assignContext = m_currentToken.Clone();
                    if (m_currentToken.Is(JSToken.Equal))
                    {
                        ReportError(JSError.NoEqual);
                    }

                    // move past the equals sign
                    GetNextToken();
                    if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                    {
                        // so we have var id/*@ =@*/ or var id//@=<EOL>
                        // we only support the equal sign inside conditional comments IF
                        // the initializer value is there as well.
                        ccSpecialCase = false;
                        m_currentToken.HandleError(JSError.ConditionalCompilationTooComplex);
                        GetNextToken();
                    }

                    initializer = ParseExpression(true, inToken);
                    if (null != initializer)
                    {
                        context.UpdateWith(initializer.Context);
                    }
                }
                else if (ccSpecialCase)
                {
                    // so we have "var id /*@" or "var id //@", but the next character is NOT an equal sign.
                    // we don't support this structure, either.
                    ccSpecialCase = false;
                    m_currentToken.HandleError(JSError.ConditionalCompilationTooComplex);

                    // skip to end of conditional comment
                    while (m_currentToken.IsNot(JSToken.EndOfFile) && m_currentToken.IsNot(JSToken.ConditionalCommentEnd))
                    {
                        GetNextToken();
                    }
                    GetNextToken();
                }

                // if the current token is not an end-of-conditional-comment token now,
                // then we're not in our special case scenario
                if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                {
                    GetNextToken();
                }
                else if (ccSpecialCase)
                {
                    // we have "var id/*@=expr" but the next token is not the closing comment.
                    // we don't support this structure, either.
                    ccSpecialCase = false;
                    m_currentToken.HandleError(JSError.ConditionalCompilationTooComplex);

                    // the assignment expression was apparently within the conditional compilation
                    // comment, but we're going to ignore it. So clear it out.
                    initializer = null;

                    // skip to end of conditional comment
                    while (m_currentToken.IsNot(JSToken.EndOfFile) && m_currentToken.IsNot(JSToken.ConditionalCommentEnd))
                    {
                        GetNextToken();
                    }
                    GetNextToken();
                }

                varDecl = new VariableDeclaration(context)
                    {
                        Binding = binding,
                        AssignContext = assignContext,
                        Initializer = initializer,
                        IsCCSpecialCase = ccSpecialCase,
                        UseCCOn = ccOn
                    };
            }

            return varDecl;
        }

        //---------------------------------------------------------------------------------------
        // ParseBinding
        //
        //  Does the real work of parsing a single binding.
        //  inToken is JSToken.In whenever the potential expression that initialize a variable
        //  cannot contain an 'in', as in the for statement. inToken is JSToken.None otherwise
        //---------------------------------------------------------------------------------------
        private AstNode ParseBinding()
        {
            AstNode binding = null;
            if (m_currentToken.Is(JSToken.Identifier))
            {
                binding = new BindingIdentifier(m_currentToken.Clone())
                    {
                        Name = m_scanner.Identifier
                    };
                GetNextToken();
            }
            else if (m_currentToken.Is(JSToken.LeftBracket))
            {
                ParsedVersion = ScriptVersion.EcmaScript6;
                binding = ParseArrayLiteral(true);
            }
            else if (m_currentToken.Is(JSToken.LeftCurly))
            {
                ParsedVersion = ScriptVersion.EcmaScript6;
                binding = ParseObjectLiteral(true);
            }
            else
            {
                var identifier = JSKeyword.CanBeIdentifier(m_currentToken.Token);
                if (null != identifier)
                {
                    binding = new BindingIdentifier(m_currentToken.Clone())
                        {
                            Name = identifier
                        };
                    GetNextToken();
                }
                else if (JSScanner.IsValidIdentifier(identifier = m_currentToken.Code))
                {
                    // it's probably just a keyword
                    ReportError(JSError.NoIdentifier);
                    binding = new BindingIdentifier(m_currentToken.Clone())
                        {
                            Name = identifier
                        };
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoIdentifier);
                    return null;
                }
            }

            return binding;
        }

        //---------------------------------------------------------------------------------------
        // ParseIfStatement
        //
        //  IfStatement :
        //    'if' '(' Expression ')' Statement ElseStatement
        //
        //  ElseStatement :
        //    <empty> |
        //    'else' Statement
        //---------------------------------------------------------------------------------------
        private IfStatement ParseIfStatement()
        {
            SourceContext ifCtx = m_currentToken.Clone();
            AstNode condition = null;
            AstNode trueBranch = null;
            AstNode falseBranch = null;
            SourceContext elseCtx = null;

            // parse condition
            GetNextToken();
            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis);
            }
            else
            {
                // skip the opening paren
                GetNextToken();
            }

            // get the condition
            condition = ParseExpression();

            // parse statements
            if (m_currentToken.Is(JSToken.RightParenthesis))
            {
                ifCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }
            else
            {
                condition.IfNotNull(c => ifCtx.UpdateWith(c.Context));
                ReportError(JSError.NoRightParenthesis);
            }

            // if this is an assignment, throw a warning in case the developer            // meant to use == instead of =            // but no warning if the condition is wrapped in parens.
            if (condition is BinaryExpression binOp && binOp.OperatorToken == JSToken.Assign)
            {
                condition.Context.HandleError(JSError.SuspectAssignment);
            }

            if (m_currentToken.Is(JSToken.Semicolon))
            {
                // if the next token is just a .semicolon, that's weird to have
                // an empty true-block. flag a low-sev warning
                m_currentToken.HandleError(JSError.SuspectSemicolon);
            }
            else if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                // if the statements aren't withing curly-braces, throw a possible error
                ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
            }

            // parse a Statement, not a SourceElement
            // and ignore any important comments that spring up right here.
            trueBranch = ParseStatement(false, true);
            if (trueBranch != null)
            {
                ifCtx.UpdateWith(trueBranch.Context);
            }

            // parse else, if any
            if (m_currentToken.Is(JSToken.Else))
            {
                elseCtx = m_currentToken.Clone();
                GetNextToken();
                if (m_currentToken.Is(JSToken.Semicolon))
                {
                    // again, an empty else-block is kinda weird.
                    m_currentToken.HandleError(JSError.SuspectSemicolon);
                }
                else if (m_currentToken.IsNot(JSToken.LeftCurly) && m_currentToken.IsNot(JSToken.If))
                {
                    // if the statements aren't withing curly-braces (or start another if-statement), throw a possible error
                    ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
                }

                // parse a Statement, not a SourceElement
                // and ignore any important comments that spring up right here.
                falseBranch = ParseStatement(false, true);
                if (falseBranch != null)
                {
                    ifCtx.UpdateWith(falseBranch.Context);
                }
            }

            return new IfStatement(ifCtx)
                {
                    Condition = condition,
                    TrueBlock = AstNode.ForceToBlock(trueBranch),
                    ElseContext = elseCtx,
                    FalseBlock = AstNode.ForceToBlock(falseBranch)
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseForStatement
        //
        //  ForStatement :
        //    'for' '(' OptionalExpressionNoIn ';' OptionalExpression ';' OptionalExpression ')'
        //    'for' '(' 'var' VariableDeclarationListNoIn ';' OptionalExpression ';' OptionalExpression ')'
        //    'for' '(' LeftHandSideExpression 'in' Expression')'
        //    'for' '(' 'var' Identifier OptionalInitializerNoIn 'in' Expression')'
        //
        //  OptionalExpressionNoIn :
        //    <empty> |
        //    ExpressionNoIn // same as Expression but does not process 'in' as an operator
        //
        //  OptionalInitializerNoIn :
        //    <empty> |
        //    InitializerNoIn // same as initializer but does not process 'in' as an operator
        //---------------------------------------------------------------------------------------
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private AstNode ParseForStatement()
        {
            AstNode forNode = null;
            SourceContext forCtx = m_currentToken.Clone();
            GetNextToken();
            if (m_currentToken.Is(JSToken.LeftParenthesis))
            {
                GetNextToken();
            }
            else
            {
                ReportError(JSError.NoLeftParenthesis);
            }

            AstNode initializer = null, condOrColl = null, increment = null;
            SourceContext operatorContext = null;
            SourceContext separator1Context = null;
            SourceContext separator2Context = null;

            if (m_currentToken.IsOne(JSToken.Var, JSToken.Let, JSToken.Const))
            {
                Declaration declaration;
                if (m_currentToken.Is(JSToken.Var))
                {
                    declaration = new VarDeclaration(m_currentToken.Clone())
                        {
                            StatementToken = m_currentToken.Token,
                            KeywordContext = m_currentToken.Clone()
                        };
                }
                else
                {
                    ParsedVersion = ScriptVersion.EcmaScript6;
                    declaration = new LexicalDeclaration(m_currentToken.Clone())
                        {
                            StatementToken = m_currentToken.Token,
                            KeywordContext = m_currentToken.Clone()
                        };
                }

                GetNextToken();
                declaration.Append(ParseVarDecl(JSToken.In));

                while (m_currentToken.Is(JSToken.Comma))
                {
                    // a list of variable initializers is ONLY allowed in a for(;;) statement,
                    // so we now know we are NOT a for..in or for..of statement.
                    GetNextToken();
                    declaration.Append(ParseVarDecl(JSToken.In));
                    //initializer = new Comma(initializer.context.CombineWith(var.context), initializer, var);
                }

                initializer = declaration;
            }
            else if (m_currentToken.IsNot(JSToken.Semicolon))
            {
                // not a declaration (var, const, let), so parse an expression with the no-in target
                initializer = ParseExpression(false, JSToken.In);
            }

            // either we are at a semicolon or an in/of token
            var isForIn = m_currentToken.Is(JSToken.In) || m_currentToken.Is("of");
            if (isForIn)
            {
                // this IS a for..in or for..of statement
                if (m_currentToken.IsNot(JSToken.In))
                {
                    ParsedVersion = ScriptVersion.EcmaScript6;
                }

                operatorContext = m_currentToken.Clone();
                GetNextToken();

                // parse the collection expression
                condOrColl = ParseExpression();
            }
            else
            {
                // NOT a for..in/for..of; this is a for(;;) statement
                if (m_currentToken.Is(JSToken.Semicolon))
                {
                    separator1Context = m_currentToken.Clone();
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoSemicolon);
                }

                if (m_currentToken.IsNot(JSToken.Semicolon))
                {
                    condOrColl = ParseExpression();
                }

                if (m_currentToken.Is(JSToken.Semicolon))
                {
                    separator2Context = m_currentToken.Clone();
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoSemicolon);
                }

                if (m_currentToken.IsNot(JSToken.RightParenthesis))
                {
                    increment = ParseExpression();
                }
            }

            if (m_currentToken.Is(JSToken.RightParenthesis))
            {
                forCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }
            else
            {
                ReportError(JSError.NoRightParenthesis);
            }

            // if the statements aren't withing curly-braces, throw a possible error
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
            }

            // parse a Statement, not a SourceElement
            // and ignore any important comments that spring up right here.
            var body = ParseStatement(false, true);
            if (isForIn)
            {
                forNode = new ForInStatement(forCtx)
                    {
                        Variable = initializer,
                        OperatorContext = operatorContext,
                        Collection = condOrColl,
                        Body = AstNode.ForceToBlock(body),
                    };
            }
            else
            {
                // if the condition is an assignment, throw a warning in case the developer                // meant to use == instead of =                // but no warning if the condition is wrapped in parens.
                if (condOrColl is BinaryExpression binOp && binOp.OperatorToken == JSToken.Assign)
                {
                    condOrColl.Context.HandleError(JSError.SuspectAssignment);
                }

                forNode = new ForStatement(forCtx)
                    {
                        Initializer = initializer,
                        Separator1Context = separator1Context,
                        Condition = condOrColl,
                        Separator2Context = separator2Context,
                        Incrementer = increment,
                        Body = AstNode.ForceToBlock(body)
                    };
            }

            return forNode;
        }

        //---------------------------------------------------------------------------------------
        // ParseDoStatement
        //
        //  DoStatement:
        //    'do' Statement 'while' '(' Expression ')'
        //---------------------------------------------------------------------------------------
        private DoWhileStatement ParseDoStatement()
        {
            var doCtx = m_currentToken.Clone();
            SourceContext whileContext = null;
            SourceContext terminatorContext = null;
            AstNode body = null;
            AstNode condition = null;

            // skip the do-token
            GetNextToken();

            // if the statements aren't withing curly-braces, throw a possible error
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
            }

            // parse a Statement, not a SourceElement
            // and ignore any important comments that spring up right here.
            body = ParseStatement(false, true);

            if (m_currentToken.IsNot(JSToken.While))
            {
                ReportError(JSError.NoWhile);
            }
            else
            {
                whileContext = m_currentToken.Clone();
                doCtx.UpdateWith(whileContext);
                GetNextToken();
            }

            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis);
            }
            else
            {
                GetNextToken();
            }

            // catch here so the body of the do_while is not thrown away
            condition = ParseExpression();
            if (m_currentToken.IsNot(JSToken.RightParenthesis))
            {
                ReportError(JSError.NoRightParenthesis);
                doCtx.UpdateWith(condition.Context);
            }
            else
            {
                doCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }

            if (m_currentToken.Is(JSToken.Semicolon))
            {
                // JScript 5 allowed statements like
                //   do{print(++x)}while(x<10) print(0)
                // even though that does not strictly follow the automatic semicolon insertion
                // rules for the required semi after the while().  For backwards compatibility
                // we should continue to support this.
                terminatorContext = m_currentToken.Clone();
                GetNextToken();
            }

            // if this is an assignment, throw a warning in case the developer            // meant to use == instead of =            // but no warning if the condition is wrapped in parens.
            if (condition is BinaryExpression binOp && binOp.OperatorToken == JSToken.Assign)
            {
                condition.Context.HandleError(JSError.SuspectAssignment);
            }

            return new DoWhileStatement(doCtx)
                {
                    Body = AstNode.ForceToBlock(body),
                    WhileContext = whileContext,
                    Condition = condition,
                    TerminatingContext = terminatorContext
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseWhileStatement
        //
        //  WhileStatement :
        //    'while' '(' Expression ')' Statement
        //---------------------------------------------------------------------------------------
        private WhileStatement ParseWhileStatement()
        {
            SourceContext whileCtx = m_currentToken.Clone();
            AstNode condition = null;
            AstNode body = null;

            GetNextToken();
            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis);
            }
            else
            {
                GetNextToken();
            }

            condition = ParseExpression();
            if (m_currentToken.IsNot(JSToken.RightParenthesis))
            {
                ReportError(JSError.NoRightParenthesis);
                whileCtx.UpdateWith(condition.Context);
            }
            else
            {
                whileCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }

            // if this is an assignment, throw a warning in case the developer            // meant to use == instead of =            // but no warning if the condition is wrapped in parens.
            if (condition is BinaryExpression binOp && binOp.OperatorToken == JSToken.Assign)
            {
                condition.Context.HandleError(JSError.SuspectAssignment);
            }

            // if the statements aren't withing curly-braces, throw a possible error
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
            }

            // parse a Statement, not a SourceElement
            // and ignore any important comments that spring up right here.
            body = ParseStatement(false, true);

            return new WhileStatement(whileCtx)
                {
                    Condition = condition,
                    Body = AstNode.ForceToBlock(body)
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseContinueStatement
        //
        //  ContinueStatement :
        //    'continue' OptionalLabel
        //
        //  OptionalLabel :
        //    <empty> |
        //    Identifier
        //
        // This function may return a null AST under error condition. The caller should handle
        // that case.
        // Regardless of error conditions, on exit the parser points to the first token after
        // the continue statement
        //---------------------------------------------------------------------------------------
        private ContinueStatement ParseContinueStatement()
        {
            var continueNode = new ContinueStatement(m_currentToken.Clone());
            GetNextToken();

            string label = null;
            if (!m_foundEndOfLine && (m_currentToken.Is(JSToken.Identifier) || (label = JSKeyword.CanBeIdentifier(m_currentToken.Token)) != null))
            {
                continueNode.UpdateWith(m_currentToken);
                continueNode.LabelContext = m_currentToken.Clone();
                continueNode.Label = label ?? m_scanner.Identifier;

                // see if the label is already known
                LabelInfo labelInfo;
                if (m_labelInfo.TryGetValue(continueNode.Label, out labelInfo))
                {
                    // increment the refcount so we know this label is referenced
                    // and save a reference to the label info in this node.
                    ++labelInfo.RefCount;
                    continueNode.LabelInfo = labelInfo;
                }
                else
                {
                    // no such label!
                    continueNode.LabelContext.HandleError(JSError.NoLabel, true);
                }

                GetNextToken();
            }

            ExpectSemicolon(continueNode);
            return continueNode;
        }

        //---------------------------------------------------------------------------------------
        // ParseBreakStatement
        //
        //  BreakStatement :
        //    'break' OptionalLabel
        //
        // This function may return a null AST under error condition. The caller should handle
        // that case.
        // Regardless of error conditions, on exit the parser points to the first token after
        // the break statement.
        //---------------------------------------------------------------------------------------
        private BreakStatement ParseBreakStatement()
        {
            var breakNode = new BreakStatement(m_currentToken.Clone());
            GetNextToken();

            string label = null;
            if (!m_foundEndOfLine && (m_currentToken.Is(JSToken.Identifier) || (label = JSKeyword.CanBeIdentifier(m_currentToken.Token)) != null))
            {
                breakNode.UpdateWith(m_currentToken);
                breakNode.LabelContext = m_currentToken.Clone();
                breakNode.Label = label ?? m_scanner.Identifier;

                // see if the label is already known
                LabelInfo labelInfo;
                if (m_labelInfo.TryGetValue(breakNode.Label, out labelInfo))
                {
                    // increment the refcount so we know this label is referenced
                    // and save a reference to the label info in this node.
                    ++labelInfo.RefCount;
                    breakNode.LabelInfo = labelInfo;
                }
                else
                {
                    // no such label!
                    breakNode.LabelContext.HandleError(JSError.NoLabel, true);
                }

                GetNextToken();
            }

            ExpectSemicolon(breakNode);
            return breakNode;
        }

        //---------------------------------------------------------------------------------------
        // ParseReturnStatement
        //
        //  ReturnStatement :
        //    'return' Expression
        //
        // This function may return a null AST under error condition. The caller should handle
        // that case.
        // Regardless of error conditions, on exit the parser points to the first token after
        // the return statement.
        //---------------------------------------------------------------------------------------
        private ReturnStatement ParseReturnStatement()
        {
            var returnNode = new ReturnStatement(m_currentToken.Clone());
            GetNextToken();

            // CAN'T have a line-break between the "return" and its expression.
            if (!m_foundEndOfLine)
            {
                if (m_currentToken.IsNot(JSToken.Semicolon) && m_currentToken.IsNot(JSToken.RightCurly))
                {
                    returnNode.Operand = ParseExpression();
                    if (returnNode.Operand != null)
                    {
                        returnNode.UpdateWith(returnNode.Operand.Context);
                    }
                }

                ExpectSemicolon(returnNode);
            }
            else
            {
                // but we did find a line-break -- semicolon-insertion rules have kicked in
                ReportError(JSError.SemicolonInsertion, returnNode.Context.FlattenToEnd());
            }

            return returnNode;
        }

        //---------------------------------------------------------------------------------------
        // ParseWithStatement
        //
        //  WithStatement :
        //    'with' '(' Expression ')' Statement
        //---------------------------------------------------------------------------------------
        private WithStatement ParseWithStatement()
        {
            SourceContext withCtx = m_currentToken.Clone();
            AstNode obj = null;

            GetNextToken();
            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis);
            }
            else
            {
                GetNextToken();
            }

            obj = ParseExpression();
            if (m_currentToken.IsNot(JSToken.RightParenthesis))
            {
                withCtx.UpdateWith(obj.Context);
                ReportError(JSError.NoRightParenthesis);
            }
            else
            {
                withCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }

            // if the statements aren't withing curly-braces, throw a possible error
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.StatementBlockExpected, CurrentPositionContext);
            }

            // parse a Statement, not a SourceElement
            // and ignore any important comments that spring up right here.
            var statement = ParseStatement(false, true);

            return new WithStatement(withCtx)
                {
                    WithObject = obj,
                    Body = AstNode.ForceToBlock(statement)
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseSwitchStatement
        //
        //  SwitchStatement :
        //    'switch' '(' Expression ')' '{' CaseBlock '}'
        //
        //  CaseBlock :
        //    CaseList DefaultCaseClause CaseList
        //
        //  CaseList :
        //    <empty> |
        //    CaseClause CaseList
        //
        //  CaseClause :
        //    'case' Expression ':' OptionalStatements
        //
        //  DefaultCaseClause :
        //    <empty> |
        //    'default' ':' OptionalStatements
        //---------------------------------------------------------------------------------------
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private AstNode ParseSwitchStatement()
        {
            SourceContext switchCtx = m_currentToken.Clone();
            AstNode expr = null;
            AstNodeList cases = null;
            var braceOnNewLine = false;
            SourceContext braceContext = null;

            // read switch(expr)
            GetNextToken();
            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis);
            }
            else
            {
                GetNextToken();
            }

            expr = ParseExpression();

            if (m_currentToken.IsNot(JSToken.RightParenthesis))
            {
                ReportError(JSError.NoRightParenthesis);
            }
            else
            {
                GetNextToken();
            }

            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.NoLeftCurly);
            }
            else
            {
                braceOnNewLine = m_foundEndOfLine;
                braceContext = m_currentToken.Clone();
                GetNextToken();
            }

            // parse the switch body
            cases = new AstNodeList(CurrentPositionContext);
            bool defaultStatement = false;
            while (m_currentToken.IsNot(JSToken.RightCurly))
            {
                SwitchCase caseClause = null;
                AstNode caseValue = null;
                var caseCtx = m_currentToken.Clone();
                SourceContext colonContext = null;
                if (m_currentToken.Is(JSToken.Case))
                {
                    // get the case
                    GetNextToken();
                    caseValue = ParseExpression();
                }
                else if (m_currentToken.Is(JSToken.Default))
                {
                    // get the default
                    if (defaultStatement)
                    {
                        // we report an error but we still accept the default
                        ReportError(JSError.DupDefault);
                    }
                    else
                    {
                        defaultStatement = true;
                    }
                    GetNextToken();
                }
                else
                {
                    // This is an error, there is no case or default. Assume a default was missing and keep going
                    defaultStatement = true;
                    ReportError(JSError.BadSwitch);
                }

                if (m_currentToken.IsNot(JSToken.Colon))
                {
                    ReportError(JSError.NoColon);
                }
                else
                {
                    colonContext = m_currentToken.Clone();
                    GetNextToken();
                }

                // read the statements inside the case or default
                var statements = new BlockStatement(m_currentToken.Clone());
                while (m_currentToken.IsNotAny(JSToken.RightCurly, JSToken.Case, JSToken.Default, JSToken.EndOfFile))
                {
                    // parse a Statement, not a SourceElement
                    statements.Append(ParseStatement(false));
                }

                caseCtx.UpdateWith(statements.Context);
                caseClause = new SwitchCase(caseCtx)
                    {
                        CaseValue = caseValue,
                        ColonContext = colonContext,
                        Statements = statements
                    };
                cases.Append(caseClause);
            }

            switchCtx.UpdateWith(m_currentToken);
            GetNextToken();

            return new SwitchStatement(switchCtx)
                {
                    Expression = expr,
                    BraceContext = braceContext,
                    Cases = cases,
                    BraceOnNewLine = braceOnNewLine
                };
        }

        //---------------------------------------------------------------------------------------
        // ParseThrowStatement
        //
        //  ThrowStatement :
        //    throw |
        //    throw Expression
        //---------------------------------------------------------------------------------------
        private AstNode ParseThrowStatement()
        {
            var throwNode = new ThrowStatement(m_currentToken.Clone());
            GetNextToken();

            // cannot have a line break between "throw" and it's expression
            if (!m_foundEndOfLine)
            {
                if (m_currentToken.IsNot(JSToken.Semicolon))
                {
                    throwNode.Operand = ParseExpression();
                    if (throwNode.Operand != null)
                    {
                        throwNode.UpdateWith(throwNode.Operand.Context);
                    }
                }

                ExpectSemicolon(throwNode);
            }
            else
            {
                ReportError(JSError.SemicolonInsertion, throwNode.Context.FlattenToEnd());
            }

            return throwNode;
        }

        //---------------------------------------------------------------------------------------
        // ParseTryStatement
        //
        //  TryStatement :
        //    'try' Block Catch Finally
        //
        //  Catch :
        //    <empty> | 'catch' '(' Identifier ')' Block
        //
        //  Finally :
        //    <empty> |
        //    'finally' Block
        //---------------------------------------------------------------------------------------
        private AstNode ParseTryStatement()
        {
            SourceContext tryCtx = m_currentToken.Clone();
            BlockStatement body = null;
            SourceContext catchContext = null;
            ParameterDeclaration catchParameter = null;
            BlockStatement catchBlock = null;
            SourceContext finallyContext = null;
            BlockStatement finallyBlock = null;

            bool catchOrFinally = false;
            GetNextToken();
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.NoLeftCurly);
            }

            body = ParseBlock();

            if (m_currentToken.Is(JSToken.Catch))
            {
                catchOrFinally = true;
                catchContext = m_currentToken.Clone();
                GetNextToken();
                if (m_currentToken.IsNot(JSToken.LeftParenthesis))
                {
                    ReportError(JSError.NoLeftParenthesis);
                }
                else
                {
                    GetNextToken();
                }

                var catchBinding = ParseBinding();
                if (catchBinding == null)
                {
                    ReportError(JSError.NoBinding);
                }
                else
                {
                    catchParameter = new ParameterDeclaration(catchBinding.Context.Clone())
                    {
                        Binding = catchBinding
                    };
                }

                if (m_currentToken.IsNot(JSToken.RightParenthesis))
                {
                    ReportError(JSError.NoRightParenthesis);
                }
                else
                {
                    GetNextToken();
                }

                if (m_currentToken.IsNot(JSToken.LeftCurly))
                {
                    ReportError(JSError.NoLeftCurly);
                }

                // parse the block
                catchBlock = ParseBlock();

                tryCtx.UpdateWith(catchBlock.Context);
            }

            if (m_currentToken.Is(JSToken.Finally))
            {
                catchOrFinally = true;
                finallyContext = m_currentToken.Clone();
                GetNextToken();

                if (m_currentToken.IsNot(JSToken.LeftCurly))
                {
                    ReportError(JSError.NoLeftCurly);
                }

                finallyBlock = ParseBlock();
                tryCtx.UpdateWith(finallyBlock.Context);
            }

            if (!catchOrFinally)
            {
                ReportError(JSError.NoCatch);
            }

            return new TryStatement(tryCtx)
                {
                    TryBlock = body,
                    CatchContext = catchContext,
                    CatchParameter = catchParameter,
                    CatchBlock = catchBlock,
                    FinallyContext = finallyContext,
                    FinallyBlock = finallyBlock
                };
        }

        private AstNode ParseModule()
        {
            // we know we're parsing an ES6 module
            ParsedVersion = ScriptVersion.EcmaScript6;
            var context = m_currentToken.Clone();
            GetNextToken();

            string moduleName = null;
            SourceContext moduleContext = null;
            BlockStatement body = null;
            BindingIdentifier binding = null;
            SourceContext fromContext = null;
            if (m_currentToken.Is(JSToken.StringLiteral))
            {
                if (m_foundEndOfLine)
                {
                    // throw an error, but keep on parsing
                    ReportError(JSError.NewLineNotAllowed, null, true);
                }

                moduleName = m_scanner.StringLiteralValue;
                moduleContext = m_currentToken.Clone();
                context.UpdateWith(moduleContext);
                GetNextToken();

                if (m_currentToken.IsNot(JSToken.LeftCurly))
                {
                    ReportError(JSError.NoLeftCurly);
                }
                else
                {
                    body = ParseBlock();
                    if (body != null)
                    {
                        context.UpdateWith(body.Context);
                        body.IsModule = true;
                    }
                }
            }
            else if (m_currentToken.Is(JSToken.Identifier) || JSKeyword.CanBeIdentifier(m_currentToken.Token) != null)
            {
                binding = (BindingIdentifier)ParseBinding();
                context.UpdateWith(binding.Context);

                if (m_currentToken.Is("from"))
                {
                    fromContext = m_currentToken.Clone();
                    context.UpdateWith(fromContext);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoExpectedFrom);
                }

                if (m_currentToken.Is(JSToken.StringLiteral))
                {
                    moduleName = m_scanner.StringLiteralValue;
                    moduleContext = m_currentToken.Clone();
                    context.UpdateWith(moduleContext);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoStringLiteral);
                }
            }
            else
            {
                ReportError(JSError.NoIdentifier);
            }

            var moduleDecl = new ModuleDeclaration(context)
                {
                    ModuleName = moduleName,
                    ModuleContext = moduleContext,
                    Body = body,
                    Binding = binding,
                    FromContext = fromContext
                };

            if (binding != null)
            {
                ExpectSemicolon(moduleDecl);
            }

            return moduleDecl;
        }

        private AstNode ParseExport()
        {
            // we know we're parsing an ES6 export
            ParsedVersion = ScriptVersion.EcmaScript6;
            var exportNode = new ExportStatement(m_currentToken.Clone())
                {
                    KeywordContext = m_currentToken.Clone(),
                };
            GetNextToken();
            if (m_currentToken.IsOne(JSToken.Var, JSToken.Const, JSToken.Let, JSToken.Function, JSToken.Class))
            {
                // export var/const/let/funcdecl/classdecl
                var declaration = ParseStatement(true, true);
                if (declaration != null)
                {
                    exportNode.Append(declaration);
                }
                else
                {
                    // this shouldn't happen -- we already had the right token, so why didn't it parse???
                    // we probably already output another error, but throw a syntax error here, just in case.
                    ReportError(JSError.SyntaxError);
                }
            }
            else if (m_currentToken.Is(JSToken.Default))
            {
                // export default assignmentexpression ;
                exportNode.IsDefault = true;
                exportNode.DefaultContext = m_currentToken.Clone();
                exportNode.Context.UpdateWith(m_currentToken);
                GetNextToken();

                var expression = ParseExpression(true);
                if (expression != null)
                {
                    exportNode.Append(expression);
                }
                else
                {
                    ReportError(JSError.ExpressionExpected);
                }

                ExpectSemicolon(exportNode);
            }
            else 
            {
                if (m_currentToken.Is(JSToken.Identifier) || JSKeyword.CanBeIdentifier(m_currentToken.Token) != null)
                {
                    // export identifier ;
                    var lookup = new LookupExpression(m_currentToken.Clone())
                    {
                        Name = m_scanner.Identifier
                    };
                    exportNode.Append(lookup);
                    GetNextToken();
                } 
                else if (m_currentToken.Is(JSToken.Multiply))
                {
                    // export * (from "module")?
                    exportNode.OpenContext = m_currentToken.Clone();
                    exportNode.UpdateWith(exportNode.OpenContext);
                    GetNextToken();
                }
                else if (m_currentToken.Is(JSToken.LeftCurly))
                {
                    // export { specifier (, specifier)* ,? } (from "module")?
                    exportNode.OpenContext = m_currentToken.Clone();
                    exportNode.UpdateWith(exportNode.OpenContext);

                    do
                    {
                        GetNextToken();
                        if (m_currentToken.IsNot(JSToken.RightCurly))
                        {
                            string identifier = null;
                            if (m_currentToken.Is(JSToken.Identifier) || (identifier = JSKeyword.CanBeIdentifier(m_currentToken.Token)) != null)
                            {
                                var specifierContext = m_currentToken.Clone();
                                var lookup = new LookupExpression(m_currentToken.Clone())
                                    {
                                        Name = identifier ?? m_scanner.Identifier
                                    };
                                GetNextToken();

                                SourceContext asContext = null;
                                SourceContext nameContext = null;
                                string externalName = null;
                                if (m_currentToken.Is("as"))
                                {
                                    asContext = m_currentToken.Clone();
                                    specifierContext.UpdateWith(asContext);
                                    GetNextToken();

                                    externalName = m_scanner.Identifier;
                                    if (externalName != null)
                                    {
                                        nameContext = m_currentToken.Clone();
                                        specifierContext.UpdateWith(nameContext);
                                        GetNextToken();
                                    }
                                    else
                                    {
                                        ReportError(JSError.NoIdentifier);
                                    }
                                }

                                var specifier = new ImportExportSpecifier(specifierContext)
                                    {
                                        LocalIdentifier = lookup,
                                        AsContext = asContext,
                                        ExternalName = externalName,
                                        NameContext = nameContext
                                    };
                                exportNode.Append(specifier);

                                if (m_currentToken.Is(JSToken.Comma))
                                {
                                    specifier.TerminatingContext = m_currentToken.Clone();
                                }
                            }
                            else
                            {
                                ReportError(JSError.NoIdentifier);
                            }
                        }
                    }
                    while (m_currentToken.Is(JSToken.Comma));

                    if (m_currentToken.Is(JSToken.RightCurly))
                    {
                        exportNode.CloseContext = m_currentToken.Clone();
                        exportNode.UpdateWith(exportNode.CloseContext);
                        GetNextToken();
                    }
                    else
                    {
                        ReportError(JSError.NoRightCurly);
                    }
                }
                else
                {
                    ReportError(JSError.NoSpecifierSet);
                }

                if (m_currentToken.Is("from"))
                {
                    // re-exporting from another module.
                    exportNode.FromContext = m_currentToken.Clone();
                    exportNode.UpdateWith(exportNode.FromContext);
                    GetNextToken();

                    if (m_currentToken.Is(JSToken.StringLiteral))
                    {
                        exportNode.ModuleContext = m_currentToken.Clone();
                        exportNode.UpdateWith(exportNode.ModuleContext);
                        exportNode.ModuleName = m_scanner.StringLiteralValue;
                        GetNextToken();
                    }
                    else
                    {
                        ReportError(JSError.NoStringLiteral);
                    }
                }

                ExpectSemicolon(exportNode);
            }

            return exportNode;
        }

        private AstNode ParseImport()
        {
            // we know we're parsing an ES6 import
            ParsedVersion = ScriptVersion.EcmaScript6;
            var importNode = new ImportStatement(m_currentToken.Clone())
                {
                    KeywordContext = m_currentToken.Clone(),
                };
            GetNextToken();
            if (m_currentToken.Is(JSToken.StringLiteral))
            {
                // import "module" ;
                importNode.ModuleName = m_scanner.StringLiteralValue;
                importNode.ModuleContext = m_currentToken.Clone();
                GetNextToken();
            }
            else
            {
                if (m_currentToken.Is(JSToken.LeftCurly))
                {
                    // import { specifier (, specifier)* ,? } from "module"
                    importNode.OpenContext = m_currentToken.Clone();
                    importNode.UpdateWith(importNode.OpenContext);

                    do
                    {
                        GetNextToken();
                        if (m_currentToken.IsNot(JSToken.RightCurly))
                        {
                            var externalName = m_scanner.Identifier;
                            if (externalName != null)
                            {
                                var nameContext = m_currentToken.Clone();
                                var specifierContext = nameContext.Clone();
                                GetNextToken();

                                SourceContext asContext = null;
                                AstNode localIdentifier = null;
                                if (m_currentToken.Is("as"))
                                {
                                    asContext = m_currentToken.Clone();
                                    GetNextToken();

                                    if (m_currentToken.Is(JSToken.Identifier) || JSKeyword.CanBeIdentifier(m_currentToken.Token) != null)
                                    {
                                        localIdentifier = ParseBinding();
                                    }
                                    else
                                    {
                                        ReportError(JSError.NoIdentifier);
                                    }
                                }
                                else
                                {
                                    // the external name is also the local binding
                                    localIdentifier = new BindingIdentifier(nameContext)
                                        {
                                            Name = externalName
                                        };
                                    externalName = null;
                                    nameContext = null;
                                }

                                var specifier = new ImportExportSpecifier(specifierContext)
                                {
                                    ExternalName = externalName,
                                    NameContext = nameContext,
                                    AsContext = asContext,
                                    LocalIdentifier = localIdentifier,
                                };
                                importNode.Append(specifier);

                                if (m_currentToken.Is(JSToken.Comma))
                                {
                                    importNode.TerminatingContext = m_currentToken.Clone();
                                }
                            }
                            else
                            {
                                ReportError(JSError.NoIdentifier);
                            }
                        }
                    }
                    while (m_currentToken.Is(JSToken.Comma));

                    if (m_currentToken.Is(JSToken.RightCurly))
                    {
                        importNode.CloseContext = m_currentToken.Clone();
                        importNode.UpdateWith(importNode.CloseContext);
                        GetNextToken();
                    }
                    else
                    {
                        ReportError(JSError.NoRightCurly);
                    }
                }
                else if (m_currentToken.Is(JSToken.Identifier) || JSKeyword.CanBeIdentifier(m_currentToken.Token) != null)
                {
                    // import identifier from "module"
                    importNode.Append(ParseBinding());
                }

                if (m_currentToken.Is("from"))
                {
                    importNode.FromContext = m_currentToken.Clone();
                    importNode.UpdateWith(importNode.FromContext);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoExpectedFrom);
                }

                if (m_currentToken.Is(JSToken.StringLiteral))
                {
                    importNode.ModuleName = m_scanner.StringLiteralValue;
                    importNode.ModuleContext = m_currentToken.Clone();
                    importNode.UpdateWith(importNode.ModuleContext);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoStringLiteral);
                }
            }

            ExpectSemicolon(importNode);
            return importNode;
        }

        #endregion

        #region ParseFunction

        //---------------------------------------------------------------------------------------
        // ParseFunction
        //
        //  FunctionDeclaration :
        //    VisibilityModifier 'function' Identifier '('
        //                          FormalParameterList ')' '{' FunctionBody '}'
        //
        //  FormalParameterList :
        //    <empty> |
        //    IdentifierList Identifier
        //
        //  IdentifierList :
        //    <empty> |
        //    Identifier, IdentifierList
        //---------------------------------------------------------------------------------------
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private FunctionObject ParseFunction(FunctionType functionType, SourceContext fncCtx)
        {
            BindingIdentifier name = null;
            AstNodeList formalParameters = null;
            BlockStatement body = null;
            bool inExpression = (functionType == FunctionType.Expression);

            var isAsync = m_currentToken.Is(JSToken.Async);
            if (isAsync)
            {
                // skip the async keyword
                GetNextToken();
                ParsedVersion = ScriptVersion.EcmaScript6;
            }
            // skip the opening token (function, get, or set).
            // methods will start off with no prefix -- right to the name.
            if (functionType != FunctionType.Method)
            {
                GetNextToken();
            }

            var isGenerator = m_currentToken.Is(JSToken.Multiply);
            if (isGenerator)
            {
                // skip the asterisk
                GetNextToken();
                ParsedVersion = ScriptVersion.EcmaScript6;
            }

            // get the function name or make an anonymous function if in expression "position"
            if (m_currentToken.Is(JSToken.Identifier))
            {
                name = new BindingIdentifier(m_currentToken.Clone())
                    {
                        Name = m_scanner.Identifier
                    };
                GetNextToken();
            }
            else
            {
                string identifier = JSKeyword.CanBeIdentifier(m_currentToken.Token);
                if (null != identifier)
                {
                    name = new BindingIdentifier(m_currentToken.Clone())
                        {
                            Name = identifier
                        };
                    GetNextToken();
                }
                else
                {
                    if (!inExpression)
                    {
                        // if this isn't a function expression, then we need to throw an error because
                        // function DECLARATIONS always need a valid identifier name
                        ReportError(JSError.NoIdentifier);

                        // BUT if the current token is a left paren, we don't want to use it as the name.
                        // (fix for issue #14152)
                        if (m_currentToken.IsNot(JSToken.LeftParenthesis)
                            && m_currentToken.IsNot(JSToken.LeftCurly))
                        {
                            identifier = m_currentToken.Code;
                            name = new BindingIdentifier(CurrentPositionContext)
                                {
                                    Name = identifier
                                };
                            GetNextToken();
                        }
                    }
                }
            }

            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                // we expect a left paren at this point for standard cross-browser support.
                // BUT -- some versions of IE allow an object property expression to be a function name, like window.onclick. 
                // we still want to throw the error, because it syntax errors on most browsers, but we still want to
                // be able to parse it and return the intended results. 
                // Skip to the open paren and use whatever is in-between as the function name. Doesn't matter that it's 
                // an invalid identifier; it won't be accessible as a valid field anyway.
                bool expandedIndentifier = false;
                while (m_currentToken.IsNot(JSToken.LeftParenthesis)
                    && m_currentToken.IsNot(JSToken.LeftCurly)
                    && m_currentToken.IsNot(JSToken.Semicolon)
                    && m_currentToken.IsNot(JSToken.EndOfFile))
                {
                    name.Context.UpdateWith(m_currentToken);
                    GetNextToken();
                    expandedIndentifier = true;
                }

                // if we actually expanded the identifier context, then we want to report that
                // the function name needs to be an identifier. Otherwise we didn't expand the 
                // name, so just report that we expected an open paren at this point.
                if (expandedIndentifier)
                {
                    name.Name = name.Context.Code;
                    name.Context.HandleError(JSError.FunctionNameMustBeIdentifier, false);
                }
                else
                {
                    ReportError(JSError.NoLeftParenthesis);
                }
            }

            // get the formal parameters
            formalParameters = ParseFormalParameters();
            fncCtx.UpdateWith(formalParameters.IfNotNull(p => p.Context));

            // read the function body of non-abstract functions.
            if (m_currentToken.IsNot(JSToken.LeftCurly))
            {
                ReportError(JSError.NoLeftCurly);
            }

            try
            {
                // parse the block locally to get the exact end of function
                body = new BlockStatement(m_currentToken.Clone());
                body.BraceOnNewLine = m_foundEndOfLine;
                GetNextToken();

                // parse the function body statements
                ParseFunctionBody(body);

                if (m_currentToken.Is(JSToken.RightCurly))
                {
                    body.Context.UpdateWith(m_currentToken);
                    GetNextToken();
                }
                else
                {
                    if (m_currentToken.Is(JSToken.EndOfFile))
                    {
                        fncCtx.HandleError(JSError.UnclosedFunction, true);
                        ReportError(JSError.ErrorEndOfFile);
                    }
                    else
                    {
                        ReportError(JSError.NoRightCurly);
                    }
                }

                fncCtx.UpdateWith(body.Context);
            }
            catch (EndOfStreamException)
            {
                // if we get an EOF here, we never had a chance to find the closing curly-brace
                fncCtx.HandleError(JSError.UnclosedFunction, true);
            }

            return new FunctionObject(fncCtx)
                {
                    FunctionType = functionType,
                    Binding = name,
                    ParameterDeclarations = formalParameters,
                    Body = body,
                    IsGenerator = isGenerator,
                    IsAsync = isAsync
                };
        }

        private void ParseFunctionBody(BlockStatement body)
        {
            var possibleDirectivePrologue = true;
            while (m_currentToken.IsNot(JSToken.RightCurly)
                && m_currentToken.IsNot(JSToken.EndOfFile))
            {
                // function body's are SourceElements (Statements + FunctionDeclarations)
                var statement = ParseStatement(true);
                if (possibleDirectivePrologue)
                {
                    if (statement is ConstantWrapper constantWrapper && constantWrapper.PrimitiveType == PrimitiveType.String)
                    {
                        // if it's already a directive prologues, we're good to go
                        if (!(constantWrapper is DirectivePrologue))
                        {
                            // make the statement a directive prologue instead of a constant wrapper
                            statement = new DirectivePrologue(constantWrapper.Value.ToString(), constantWrapper.Context)
                            {
                                MayHaveIssues = constantWrapper.MayHaveIssues
                            };
                        }
                    }
                    else if (!m_newModule)
                    {
                        // no longer considering constant wrappers
                        possibleDirectivePrologue = false;
                    }
                }
                else if (m_newModule)
                {
                    // we scanned into a new module -- we might find directive prologues again
                    possibleDirectivePrologue = true;
                }

                // add it to the body
                body.Append(statement);
            }

            // make sure any important comments before the closing brace are kept
            AppendImportantComments(body);
        }

        private AstNodeList ParseFormalParameters()
        {
            AstNodeList formalParameters = null;
            if (m_currentToken.Is(JSToken.LeftParenthesis))
            {
                // create the parameter list
                formalParameters = new AstNodeList(m_currentToken.Clone());

                // create the list of arguments and update the context
                var token = JSToken.Comma;
                while (token == JSToken.Comma)
                {
                    ParameterDeclaration paramDecl = null;
                    GetNextToken();
                    if (m_currentToken.IsNot(JSToken.RightParenthesis))
                    {
                        SourceContext restContext = null;
                        if (m_currentToken.Is(JSToken.RestSpread))
                        {
                            ParsedVersion = ScriptVersion.EcmaScript6;
                            restContext = m_currentToken.Clone();
                            GetNextToken();
                        }

                        var binding = ParseBinding();
                        if (binding != null)
                        {
                            paramDecl = new ParameterDeclaration(binding.Context.Clone())
                            {
                                Binding = binding,
                                Position = formalParameters.Count,
                                HasRest = restContext != null,
                                RestContext = restContext,
                            };
                            formalParameters.Append(paramDecl);
                        }
                        else
                        {
                            // We're missing an argument (or previous argument was malformed and
                            // we skipped to the comma.)  Keep trying to parse the argument list --
                            // we will skip the comma below.
                            ReportError(JSError.NoBinding);
                        }

                        // see if we have an optional default value
                        if (m_currentToken.Is(JSToken.Assign))
                        {
                            ParsedVersion = ScriptVersion.EcmaScript6;
                            paramDecl.IfNotNull(p => p.AssignContext = m_currentToken.Clone());
                            GetNextToken();

                            // parse an assignment expression
                            var initializer = ParseExpression(true);
                            paramDecl.IfNotNull(p => p.Initializer = initializer);
                        }
                    }

                    // by now we should have either a comma, which means we need to parse another parameter,
                    // or a right-parentheses, which means we are done. Anything else and it's an error.
                    token = m_currentToken.Token;
                    if (token == JSToken.Comma)
                    {
                        // append the comma context as the terminator for the parameter
                        if (paramDecl != null)
                        {
                            paramDecl.TerminatingContext = m_currentToken.Clone();
                        }
                    }
                    else if (token != JSToken.RightParenthesis)
                    {
                        ReportError(JSError.NoRightParenthesisOrComma);
                    }
                }

                if (m_currentToken.Is(JSToken.RightParenthesis))
                {
                    formalParameters.UpdateWith(m_currentToken);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoRightParenthesis);
                }
            }

            return formalParameters;
        }

        private ClassNode ParseClassNode(ClassType classType)
        {
            ClassNode classNode = null;
            var classContext = m_currentToken.Clone();
            var context = classContext.Clone();
            GetNextToken();

            // [ or { will get parsed as a binding array/object, so we don't REALLY want to do that.
            // besides, if '{' is right after class, then there is no name or heritage.
            AstNode binding = null;
            if (m_currentToken.IsNot(JSToken.LeftCurly) && m_currentToken.IsNot(JSToken.Extends))
            {
                binding = ParseBinding();
            }

            var bindingIdentifier = binding as BindingIdentifier;
            if (bindingIdentifier == null && classType == ClassType.Declaration)
            {
                ReportError(JSError.NoIdentifier, binding.IfNotNull(b => b.Context));
            }

            SourceContext extendsContext = null;
            AstNode heritage = null;
            SourceContext openBrace = null;
            SourceContext closeBrace = null;
            if (m_currentToken.Is(JSToken.Extends))
            {
                extendsContext = m_currentToken.Clone();
                context.UpdateWith(extendsContext);
                GetNextToken();

                heritage = ParseExpression(true);
                if (heritage != null)
                {
                    context.UpdateWith(heritage.Context);
                }
                else
                {
                    ReportError(JSError.ExpressionExpected);
                }
            }

            AstNodeList elements = null;
            if (m_currentToken.Is(JSToken.LeftCurly))
            {
                openBrace = m_currentToken.Clone();
                context.UpdateWith(openBrace);
                GetNextToken();

                elements = new AstNodeList(m_currentToken.FlattenToStart());
                while (m_currentToken.IsNot(JSToken.EndOfFile) && m_currentToken.IsNot(JSToken.RightCurly))
                {
                    if (m_currentToken.Is(JSToken.Semicolon))
                    {
                        // skip the semicolon
                        GetNextToken();
                    }
                    else
                    {
                        var element = ParseClassElement();
                        if (element != null)
                        {
                            elements.Append(element);
                            context.UpdateWith(element.Context);
                        }
                        else
                        {
                            ReportError(JSError.ClassElementExpected);
                        }
                    }
                }

                if (m_currentToken.Is(JSToken.RightCurly))
                {
                    closeBrace = m_currentToken.Clone();
                    context.UpdateWith(closeBrace);
                    GetNextToken();
                }
                else
                {
                    ReportError(JSError.NoRightCurly);
                }
            }
            else
            {
                ReportError(JSError.NoLeftCurly);
            }

            // create the class
            classNode = new ClassNode(context)
                {
                    ClassType = classType,
                    ClassContext = classContext,
                    Binding = binding,
                    ExtendsContext = extendsContext,
                    Heritage = heritage,
                    OpenBrace = openBrace,
                    Elements = elements,
                    CloseBrace = closeBrace,
                };

            return classNode;
        }

        private AstNode ParseClassElement()
        {
            // see if we're a static method
            var staticContext = m_currentToken.Is(JSToken.Static)
                ? m_currentToken.Clone()
                : null;
            if (staticContext != null)
            {
                GetNextToken();
            }

            // see if this is a getter/setter or a regular method
            var funcType = m_currentToken.Is(JSToken.Get)
                ? FunctionType.Getter
                : m_currentToken.Is(JSToken.Set) ? FunctionType.Setter : FunctionType.Method;

            // right now the ES6 spec just has method declarations.
            var method = ParseFunction(funcType, m_currentToken.FlattenToStart());
            if (method != null && staticContext != null)
            {
                method.IsStatic = true;
                method.StaticContext = staticContext;
            }

            return method;
        }

        #endregion

        #region ParseExpression

        //---------------------------------------------------------------------------------------
        // ParseExpression
        //
        //  Expression :
        //    AssignmentExpressionList AssignmentExpression
        //
        //  AssignmentExpressionList :
        //    <empty> |
        //    AssignmentExpression ',' AssignmentExpressionList
        //
        //  AssignmentExpression :
        //    ConditionalExpression |
        //    LeftHandSideExpression AssignmentOperator AssignmentExpression
        //
        //  ConditionalExpression :
        //    LogicalORExpression OptionalConditionalExpression
        //
        //  OptionalConditionalExpression :
        //    <empty> |
        //    '?' AssignmentExpression ':' AssignmentExpression
        //
        //  LogicalORExpression :
        //    LogicalANDExpression OptionalLogicalOrExpression
        //
        //  OptionalLogicalOrExpression :
        //    <empty> |
        //    '||' LogicalANDExpression OptionalLogicalOrExpression
        //
        //  LogicalANDExpression :
        //    BitwiseORExpression OptionalLogicalANDExpression
        //
        //  OptionalLogicalANDExpression :
        //    <empty> |
        //    '&&' BitwiseORExpression OptionalLogicalANDExpression
        //
        //  BitwiseORExpression :
        //    BitwiseXORExpression OptionalBitwiseORExpression
        //
        //  OptionalBitwiseORExpression :
        //    <empty> |
        //    '|' BitwiseXORExpression OptionalBitwiseORExpression
        //
        //  BitwiseXORExpression :
        //    BitwiseANDExpression OptionalBitwiseXORExpression
        //
        //  OptionalBitwiseXORExpression :
        //    <empty> |
        //    '^' BitwiseANDExpression OptionalBitwiseXORExpression
        //
        //  BitwiseANDExpression :
        //    EqualityExpression OptionalBitwiseANDExpression
        //
        //  OptionalBitwiseANDExpression :
        //    <empty> |
        //    '&' EqualityExpression OptionalBitwiseANDExpression
        //
        //  EqualityExpression :
        //    RelationalExpression |
        //    RelationalExpression '==' EqualityExpression |
        //    RelationalExpression '!=' EqualityExpression |
        //    RelationalExpression '===' EqualityExpression |
        //    RelationalExpression '!==' EqualityExpression
        //
        //  RelationalExpression :
        //    ShiftExpression |
        //    ShiftExpression '<' RelationalExpression |
        //    ShiftExpression '>' RelationalExpression |
        //    ShiftExpression '<=' RelationalExpression |
        //    ShiftExpression '>=' RelationalExpression
        //
        //  ShiftExpression :
        //    AdditiveExpression |
        //    AdditiveExpression '<<' ShiftExpression |
        //    AdditiveExpression '>>' ShiftExpression |
        //    AdditiveExpression '>>>' ShiftExpression
        //
        //  AdditiveExpression :
        //    MultiplicativeExpression |
        //    MultiplicativeExpression '+' AdditiveExpression |
        //    MultiplicativeExpression '-' AdditiveExpression
        //
        //  MultiplicativeExpression :
        //    UnaryExpression |
        //    UnaryExpression '*' MultiplicativeExpression |
        //    UnaryExpression '/' MultiplicativeExpression |
        //    UnaryExpression '%' MultiplicativeExpression
        //---------------------------------------------------------------------------------------
        private AstNode ParseExpression(bool single = false, JSToken inToken = JSToken.None)
        {
            bool bAssign;
            AstNode lhs = ParseUnaryExpression(out bAssign, false);
            return ParseExpression(lhs, single, bAssign, inToken);
        }

        private AstNode ParseExpression(AstNode leftHandSide, bool single, bool bCanAssign, JSToken inToken)
        {
            // new op stack with dummy op
            Stack<SourceContext> opsStack = null;

            // term stack, push left-hand side onto it
            Stack<AstNode> termStack = null;

            AstNode expr = null;
            for (; ; )
            {
                // if 'binary op' or 'conditional'
                // if we are looking for a single expression, then also bail when we hit a comma
                // inToken is a special case because of the for..in syntax. When ParseExpression is called from
                // for, inToken = JSToken.In which excludes JSToken.In from the list of operators, otherwise
                // inToken = JSToken.None which is always true if the first condition is true
                if (JSScanner.IsProcessableOperator(m_currentToken.Token)
                    && m_currentToken.IsNot(inToken)
                    && (!single || m_currentToken.IsNot(JSToken.Comma)))
                {
                    if (opsStack == null)
                    {
                        opsStack = new Stack<SourceContext>();
                        opsStack.Push(null);

                        termStack = new Stack<AstNode>();
                        termStack.Push(leftHandSide);
                    }

                    // for the current token, get the operator precedence and whether it's a right-association operator
                    var prec = JSScanner.GetOperatorPrecedence(m_currentToken);
                    bool rightAssoc = JSScanner.IsRightAssociativeOperator(m_currentToken.Token);

                    // while the current operator has lower precedence than the operator at the top of the stack
                    // or it has the same precedence and it is left associative (that is, no 'assign op' or 'conditional')
                    var stackPrec = JSScanner.GetOperatorPrecedence(opsStack.Peek());
                    while (prec < stackPrec || prec == stackPrec && !rightAssoc)
                    {
                        // pop the top two elements off the stack along with the current operator, 
                        // combine them, then push the results back onto the term stack
                        AstNode operand2 = termStack.Pop();
                        AstNode operand1 = termStack.Pop();
                        expr = CreateExpressionNode(opsStack.Pop(), operand1, operand2);
                        termStack.Push(expr);

                        // get the precendence of the current item on the top of the op stack
                        stackPrec = JSScanner.GetOperatorPrecedence(opsStack.Peek());
                    }

                    // now the current operator has higher precedence that every scanned operators on the stack, or
                    // it has the same precedence as the one at the top of the stack and it is right associative
                    // push operator and next term

                    // but first: special case conditional '?:'
                    if (m_currentToken.Is(JSToken.ConditionalIf))
                    {
                        // pop term stack
                        AstNode condition = termStack.Pop();

                        // if this is an assignment, throw a warning in case the developer                        // meant to use == instead of =                        // but no warning if the condition is wrapped in parens.
                        if (condition is BinaryExpression binOp && binOp.OperatorToken == JSToken.Assign)
                        {
                            condition.Context.HandleError(JSError.SuspectAssignment);
                        }

                        var questionCtx = m_currentToken.Clone();
                        GetNextToken();

                        // get expr1 in logOrExpr ? expr1 : expr2
                        AstNode operand1 = ParseExpression(true);

                        SourceContext colonCtx = null;
                        if (m_currentToken.IsNot(JSToken.Colon))
                        {
                            ReportError(JSError.NoColon);
                        }
                        else
                        {
                            colonCtx = m_currentToken.Clone();
                        }

                        GetNextToken();

                        // get expr2 in logOrExpr ? expr1 : expr2
                        AstNode operand2 = ParseExpression(true, inToken);

                        expr = new Conditional(condition.Context.CombineWith(operand2.Context))
                            {
                                Condition = condition,
                                QuestionContext = questionCtx,
                                TrueExpression = operand1,
                                ColonContext = colonCtx,
                                FalseExpression = operand2
                            };
                        termStack.Push(expr);
                    }
                    else
                    {
                        if (JSScanner.IsAssignmentOperator(m_currentToken.Token))
                        {
                            if (!bCanAssign)
                            {
                                ReportError(JSError.IllegalAssignment);
                            }
                        }
                        else
                        {
                            // if the operator is a comma, we can get another assign; otherwise we can't
                            bCanAssign = (m_currentToken.Is(JSToken.Comma));
                        }

                        // push the operator onto the operators stack
                        opsStack.Push(m_currentToken.Clone());

                        // push new term
                        GetNextToken();
                        if (bCanAssign)
                        {
                            termStack.Push(ParseUnaryExpression(out bCanAssign, false));
                        }
                        else
                        {
                            bool dummy;
                            termStack.Push(ParseUnaryExpression(out dummy, false));
                        }
                    }
                }
                else
                {
                    // done with expression; go and unwind the stack of expressions/operators.
                    break;
                }
            }

            if (opsStack != null)
            {
                // there are still operators to be processed
                while (opsStack.Peek() != null)
                {
                    // pop the top two term and the top operator, combine them into a new term,
                    // and push the results back onto the term stacck
                    AstNode operand2 = termStack.Pop();
                    AstNode operand1 = termStack.Pop();
                    expr = CreateExpressionNode(opsStack.Pop(), operand1, operand2);

                    // push node onto the stack
                    termStack.Push(expr);
                }
            }

            AstNode term = leftHandSide;

            if (termStack != null)
            {
                Debug.Assert(termStack.Count == 1);

                // see if the one remaining term is "yield". If so, that means we had a lone
                // yield token -- it might be a Mozilla yield operator
                term = termStack.Pop();
            }

            if (term != null)
            {
                if ((term.Context.Token == JSToken.Yield || term.Context.Token == JSToken.Await)
                    && term is LookupExpression)
                {
                    var expression = ParseExpression(true);
                    if (expression != null)
                    {
                        // yield expression
                        term = new UnaryExpression(term.Context.CombineWith(expression.Context))
                            {
                                OperatorToken = term.Context.Token,
                                OperatorContext = term.Context,
                                Operand = expression
                            };
                    }
                }
            }

            return term;
        }

        //---------------------------------------------------------------------------------------
        // ParseUnaryExpression
        //
        //  UnaryExpression :
        //    PostfixExpression |
        //    'delete' UnaryExpression |
        //    'void' UnaryExpression |
        //    'typeof' UnaryExpression |
        //    '++' UnaryExpression |
        //    '--' UnaryExpression |
        //    '+' UnaryExpression |
        //    '-' UnaryExpression |
        //    '~' UnaryExpression |
        //    '!' UnaryExpression
        //
        //---------------------------------------------------------------------------------------
        private AstNode ParseUnaryExpression(out bool isLeftHandSideExpr, bool isMinus)
        {
            isLeftHandSideExpr = false;
            bool dummy = false;
            SourceContext exprCtx = null;
            AstNode expr = null;

        TryItAgain:
            AstNode ast = null;
            var opToken = m_currentToken.Token;
            switch (opToken)
            {
                case JSToken.RestSpread:
                    // technically, we don't want rest operators ANYWHERE. But we need to handle them
                    // here specifically for formal parameter lists for arrow functions. 
                    // TODO: we want to error if we aren't immediately preceeded by a comma operator,
                    // and if after parsing the next unary expression, we're aren't at a closing parenthesis.
                    ParsedVersion = ScriptVersion.EcmaScript6;
                    goto case JSToken.Void;

                case JSToken.Void:
                case JSToken.TypeOf:
                case JSToken.Plus:
                case JSToken.Minus:
                case JSToken.BitwiseNot:
                case JSToken.LogicalNot:
                case JSToken.Delete:
                case JSToken.Increment:
                case JSToken.Decrement:
                    // normal unary operators all follow the same pattern
                    exprCtx = m_currentToken.Clone();
                    GetNextToken();
                    expr = ParseUnaryExpression(out dummy, false);
                    ast = new UnaryExpression(exprCtx.CombineWith(expr.Context))
                        {
                            Operand = expr,
                            OperatorContext = exprCtx,
                            OperatorToken = opToken
                        };
                    break;

                case JSToken.ConditionalCommentStart:
                    // skip past the start to the next token
                    exprCtx = m_currentToken.Clone();
                    GetNextToken();
                    if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                    {
                        // empty conditional-compilation comment -- ignore
                        GetNextToken();
                        goto TryItAgain;
                    }
                    else if (m_currentToken.Is(JSToken.ConditionalCompilationOn))
                    {
                        // /*@cc_on -- check for @IDENT@*/ or !@*/
                        GetNextToken();
                        if (m_currentToken.Is(JSToken.ConditionalCompilationVariable))
                        {
                            // /*@cc_on@IDENT -- check for @*/
                            ast = new ConstantWrapperPP(m_currentToken.Clone())
                                {
                                    VarName = m_currentToken.Code,
                                    ForceComments = true
                                };

                            GetNextToken();

                            if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                            {
                                // skip the close and keep going
                                GetNextToken();
                            }
                            else
                            {
                                // too complicated
                                CCTooComplicated(null);
                                goto TryItAgain;
                            }
                        }
                        else if (m_currentToken.Is(JSToken.LogicalNot))
                        {
                            // /*@cc_on! -- check for @*/
                            var operatorContext = m_currentToken.Clone();
                            GetNextToken();
                            if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                            {
                                // we have /*@cc_on!@*/
                                GetNextToken();
                                expr = ParseUnaryExpression(out dummy, false);
                                exprCtx.UpdateWith(expr.Context);

                                var unary = new UnaryExpression(exprCtx)
                                    {
                                        Operand = expr,
                                        OperatorContext = operatorContext,
                                        OperatorToken = JSToken.LogicalNot
                                    };
                                unary.OperatorInConditionalCompilationComment = true;
                                unary.ConditionalCommentContainsOn = true;
                                ast = unary;
                            }
                            else
                            {
                                // too complicated
                                CCTooComplicated(null);
                                goto TryItAgain;
                            }
                        }
                        else
                        {
                            // too complicated
                            CCTooComplicated(null);
                            goto TryItAgain;
                        }
                    }
                    else if (m_currentToken.Is(JSToken.LogicalNot))
                    {
                        // /*@! -- check for @*/
                        var operatorContext = m_currentToken.Clone();
                        GetNextToken();
                        if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                        {
                            // we have /*@!@*/
                            GetNextToken();
                            expr = ParseUnaryExpression(out dummy, false);
                            exprCtx.UpdateWith(expr.Context);

                            var unary = new UnaryExpression(exprCtx)
                                {
                                    Operand = expr,
                                    OperatorContext = operatorContext,
                                    OperatorToken = JSToken.LogicalNot
                                };
                            unary.OperatorInConditionalCompilationComment = true;
                            ast = unary;
                        }
                        else
                        {
                            // too complicated
                            CCTooComplicated(null);
                            goto TryItAgain;
                        }
                    }
                    else if (m_currentToken.Is(JSToken.ConditionalCompilationVariable))
                    {
                        // @IDENT -- check for @*/
                        ast = new ConstantWrapperPP(m_currentToken.Clone())
                            {
                                VarName = m_currentToken.Code,
                                ForceComments = true
                            };
                        GetNextToken();

                        if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                        {
                            // skip the close and keep going
                            GetNextToken();
                        }
                        else
                        {
                            // too complicated
                            CCTooComplicated(null);
                            goto TryItAgain;
                        }
                    }
                    else
                    {
                        // we ONLY support /*@id@*/ or /*@cc_on@id@*/ or /*@!@*/ or /*@cc_on!@*/ in expressions right now. 
                        // throw an error, skip to the end of the comment, then ignore it and start
                        // looking for the next token.
                        CCTooComplicated(null);
                        goto TryItAgain;
                    }
                    break;

                default:
                    ast = ParseLeftHandSideExpression(isMinus);
                    ast = ParsePostfixExpression(ast, out isLeftHandSideExpr);
                    break;
            }

            return ast;
        }

        //---------------------------------------------------------------------------------------
        // ParsePostfixExpression
        //
        //  PostfixExpression:
        //    LeftHandSideExpression |
        //    LeftHandSideExpression '++' |
        //    LeftHandSideExpression  '--'
        //
        //---------------------------------------------------------------------------------------
        private AstNode ParsePostfixExpression(AstNode ast, out bool isLeftHandSideExpr)
        {
            isLeftHandSideExpr = true;
            SourceContext exprCtx = null;
            if (null != ast)
            {
                if (!m_foundEndOfLine)
                {
                    if (m_currentToken.Is(JSToken.Increment))
                    {
                        isLeftHandSideExpr = false;
                        exprCtx = ast.Context.Clone();
                        exprCtx.UpdateWith(m_currentToken);
                        ast = new UnaryExpression(exprCtx)
                            {
                                Operand = ast,
                                OperatorToken = m_currentToken.Token,
                                OperatorContext = m_currentToken.Clone(),
                                IsPostfix = true
                            };
                        GetNextToken();
                    }
                    else if (m_currentToken.Is(JSToken.Decrement))
                    {
                        isLeftHandSideExpr = false;
                        exprCtx = ast.Context.Clone();
                        exprCtx.UpdateWith(m_currentToken);
                        ast = new UnaryExpression(exprCtx)
                            {
                                Operand = ast,
                                OperatorToken = m_currentToken.Token,
                                OperatorContext = m_currentToken.Clone(),
                                IsPostfix = true
                            };
                        GetNextToken();
                    }
                }
            }

            return ast;
        }

        //---------------------------------------------------------------------------------------
        // ParseLeftHandSideExpression
        //
        //  LeftHandSideExpression :
        //    PrimaryExpression Accessor  |
        //    'new' LeftHandSideExpression |
        //    FunctionExpression
        //
        //  PrimaryExpression :
        //    'this' |
        //    Identifier |
        //    Literal |
        //    '(' Expression ')'
        //
        //  FunctionExpression :
        //    'function' OptionalFuncName '(' FormalParameterList ')' { FunctionBody }
        //
        //  OptionalFuncName :
        //    <empty> |
        //    Identifier
        //---------------------------------------------------------------------------------------
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode"), 
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private AstNode ParseLeftHandSideExpression(bool isMinus)
        {
            AstNode ast = null;
            List<SourceContext> newContexts = null;

        TryItAgain:

            // new expression
            while (m_currentToken.Is(JSToken.New))
            {
                if (null == newContexts)
                    newContexts = new List<SourceContext>(4);
                newContexts.Add(m_currentToken.Clone());
                GetNextToken();
            }
            JSToken token = m_currentToken.Token;
            switch (token)
            {
                // primary expression
                case JSToken.Identifier:
                    ast = new LookupExpression(m_currentToken.Clone())
                        {
                            Name = m_scanner.Identifier
                        };
                    GetNextToken();
                    break;

                case JSToken.TemplateLiteral:
                    ast = ParseTemplateLiteral();
                    break;

                case JSToken.ConditionalCommentStart:
                    // skip past the start to the next token
                    GetNextToken();
                    if (m_currentToken.Is(JSToken.ConditionalCompilationVariable))
                    {
                        // we have /*@id
                        ast = new ConstantWrapperPP(m_currentToken.Clone())
                            {
                                VarName = m_currentToken.Code,
                                ForceComments = true
                            };

                        GetNextToken();

                        if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                        {
                            // skip past the closing comment
                            GetNextToken();
                        }
                        else
                        {
                            // we ONLY support /*@id@*/ in expressions right now. If there's not
                            // a closing comment after the ID, then we don't support it.
                            // throw an error, skip to the end of the comment, then ignore it and start
                            // looking for the next token.
                            CCTooComplicated(null);
                            goto TryItAgain;
                        }
                    }
                    else if (m_currentToken.Is(JSToken.ConditionalCommentEnd))
                    {
                        // empty conditional comment! Ignore.
                        GetNextToken();
                        goto TryItAgain;
                    }
                    else
                    {
                        // we DON'T have "/*@IDENT". We only support "/*@IDENT @*/", so since this isn't
                        // and id, throw the error, skip to the end of the comment, and ignore it
                        // by looping back and looking for the NEXT token.
                        m_currentToken.HandleError(JSError.ConditionalCompilationTooComplex);

                        // skip to end of conditional comment
                        while (m_currentToken.IsNot(JSToken.EndOfFile) && m_currentToken.IsNot(JSToken.ConditionalCommentEnd))
                        {
                            GetNextToken();
                        }
                        GetNextToken();
                        goto TryItAgain;
                    }
                    break;

                case JSToken.This:
                    ast = new ThisLiteral(m_currentToken.Clone());
                    GetNextToken();
                    break;

                case JSToken.StringLiteral:
                    ast = new ConstantWrapper(m_scanner.StringLiteralValue, PrimitiveType.String, m_currentToken.Clone())
                        {
                            MayHaveIssues = m_scanner.LiteralHasIssues
                        };
                    GetNextToken();
                    break;

                case JSToken.IntegerLiteral:
                case JSToken.NumericLiteral:
                    {
                        SourceContext numericContext = m_currentToken.Clone();
                        double doubleValue;
                        if (ConvertNumericLiteralToDouble(m_currentToken.Code, (token == JSToken.IntegerLiteral), out doubleValue))
                        {
                            // conversion worked fine
                            // check for some boundary conditions
                            var mayHaveIssues = m_scanner.LiteralHasIssues;
                            if (doubleValue == double.MaxValue)
                            {
                                ReportError(JSError.NumericMaximum, numericContext);
                            }
                            else if (isMinus && -doubleValue == double.MinValue)
                            {
                                ReportError(JSError.NumericMinimum, numericContext);
                            }

                            // create the constant wrapper from the value
                            ast = new ConstantWrapper(doubleValue, PrimitiveType.Number, numericContext)
                                {
                                    MayHaveIssues = mayHaveIssues
                                };
                        }
                        else
                        {
                            // if we went overflow or are not a number, then we will use the "Other"
                            // primitive type so we don't try doing any numeric calcs with it. 
                            if (double.IsInfinity(doubleValue))
                            {
                                // overflow
                                // and if we ARE an overflow, report it
                                ReportError(JSError.NumericOverflow, numericContext);
                            }

                            // regardless, we're going to create a special constant wrapper
                            // that simply echos the input as-is
                            ast = new ConstantWrapper(m_currentToken.Code, PrimitiveType.Other, numericContext)
                            {
                                MayHaveIssues = true
                            };
                        }

                        GetNextToken();
                        break;
                    }

                case JSToken.True:
                    ast = new ConstantWrapper(true, PrimitiveType.Boolean, m_currentToken.Clone());
                    GetNextToken();
                    break;

                case JSToken.False:
                    ast = new ConstantWrapper(false, PrimitiveType.Boolean, m_currentToken.Clone());
                    GetNextToken();
                    break;

                case JSToken.Null:
                    ast = new ConstantWrapper(null, PrimitiveType.Null, m_currentToken.Clone());
                    GetNextToken();
                    break;

                case JSToken.ConditionalCompilationVariable:
                    ast = new ConstantWrapperPP(m_currentToken.Clone())
                        {
                            VarName = m_currentToken.Code,
                            ForceComments = false
                        };
                    GetNextToken();
                    break;

                // normally this token is not allowed on the left-hand side of an expression.
                // BUT, this might be the start of a regular expression that begins with an equals sign!
                // we need to test to see if we can parse a regular expression, and if not, THEN
                // we can fail the parse.
                case JSToken.DivideAssign:
                case JSToken.Divide:
                    // could it be a regexp?
                    ast = ScanRegularExpression();
                    if (ast != null)
                    {
                        // yup -- we're done here
                        break;
                    }

                    // nope -- go to the default branch
                    goto default;

                case JSToken.Modulo:
                    // could it be a replacement token in the format %name%? If so, we 
                    // want to treat that as a constant wrapper.
                    ast = ScanReplacementToken();
                    if (ast != null)
                    {
                        break;
                    }

                    goto default;

                // expression
                case JSToken.LeftParenthesis:
                    {
                        var leftParen = m_currentToken.Clone();
                        var parentAst = ast;
                        GetNextToken();
                        if (m_currentToken.Is(JSToken.For))
                        {
                            // generator comprehension in ES6 format
                            ast = ParseComprehension(false, leftParen, null);
                        }
                        else
                        {
                            if (m_currentToken.Is(JSToken.RightParenthesis))
                            {
                                // shortcut the empty parenthetical grouping
                                // normally not allowed; however this might be the (empty) parameter list
                                // to an arrow function.
                                // add the closing paren to the expression context
                                ast = new GroupingOperator(leftParen);
                                ast.UpdateWith(m_currentToken);
                                GetNextToken();
                            }
                            else if (m_currentToken.Is(JSToken.RestSpread))
                            {
                                // we have (...
                                // parse an assignment expression, make it the operand of a unary with the rest.
                                var restContext = m_currentToken.Clone();
                                GetNextToken();
                                ast = ParseExpression(true);
                                if (ast != null)
                                {
                                    ast = new UnaryExpression(restContext.CombineWith(ast.Context))
                                        {
                                            OperatorContext = restContext,
                                            OperatorToken = JSToken.RestSpread,
                                            Operand = ast
                                        };
                                }

                                // now, we want to continue parsing if there is a comma
                                if (m_currentToken.Is(JSToken.Comma))
                                {
                                    ast = ParseExpression(ast, false, true, JSToken.None);
                                }

                                if (m_currentToken.Is(JSToken.RightParenthesis))
                                {
                                    ast = new GroupingOperator(leftParen)
                                        {
                                            Operand = ast
                                        };
                                    ast.UpdateWith(m_currentToken);
                                    GetNextToken();
                                }
                                else
                                {
                                    ReportError(JSError.NoRightParenthesis);
                                }
                            }
                            else
                            {
                                // parse an expression
                                var operand = ParseExpression();
                                if (m_currentToken.Is(JSToken.For))
                                {
                                    // generator comprehension in Mozille format
                                    ast = ParseComprehension(false, leftParen, operand);
                                }
                                else
                                {
                                    ast = new GroupingOperator(leftParen)
                                        {
                                            Operand = operand
                                        };
                                    ast.UpdateWith(operand.Context);

                                    if (m_currentToken.IsNot(JSToken.RightParenthesis))
                                    {
                                        ReportError(JSError.NoRightParenthesis);
                                    }
                                    else
                                    {
                                        // add the closing paren to the expression context
                                        ast.UpdateWith(m_currentToken);
                                        GetNextToken();
                                    }
                                }
                            }

                            ast.Parent = parentAst;
                        }
                    }
                    break;

                // array initializer
                case JSToken.LeftBracket:
                    ast = ParseArrayLiteral(false);
                    break;

                // object initializer
                case JSToken.LeftCurly:
                    ast = ParseObjectLiteral(false);
                    break;

                // async function expression
                case JSToken.Async:
                    var nextToken = PeekToken();
                    if (nextToken == JSToken.Function)
                    {
                        // treat 'async function' as a function expression
                        goto case (JSToken.Function); 
                    }
                    else if (nextToken == JSToken.LeftParenthesis)
                    {
                        ast = new LookupExpression(m_currentToken.Clone())
                        {
                            Name = JSKeyword.CanBeIdentifier(m_currentToken.Token)
                        };
                        
                        GetNextToken();

                        nextToken = PeekToken();
                        if (nextToken == JSToken.Function)
                            break;

                        goto case (JSToken.LeftParenthesis);
                    }
                    else
                    {
                        // 'async' as an identifier
                        goto default;
                    }

                // function expression
                case JSToken.Function:
                    ast = ParseFunction(FunctionType.Expression, m_currentToken.Clone());
                    break;

                // class expression
                case JSToken.Class:
                    ast = ParseClassNode(ClassType.Expression);
                    break;

                case JSToken.AspNetBlock:
                    ast = new AspNetBlockNode(m_currentToken.Clone())
                        {
                            AspNetBlockText = m_currentToken.Code
                        };
                    GetNextToken();
                    break;

                case JSToken.Await:
                    {
                        if (ParsedVersion == ScriptVersion.EcmaScript6 || m_settings.ScriptVersion == ScriptVersion.EcmaScript6)
                        {
                            ast = ParseAwaitExpression();
                        }
                        else
                        {
                            // we need to protect against non-ES6 code using "await" as a variable name
                            ast = new LookupExpression(m_currentToken.Clone())
                            {
                                Name = "await"
                            };
                            GetNextToken();
                        }
                    }
                    break;
                case JSToken.Yield:
                    {
                        // TODO: not sure if this is the right place to hook for the ES6 YieldExpression semantics!
                        if (ParsedVersion == ScriptVersion.EcmaScript6 || m_settings.ScriptVersion == ScriptVersion.EcmaScript6)
                        {
                            // we already KNOW we're ES6 code, so just parse this as a yield expression.
                            // in fact, we SHOULD already know, since yield should only be used within a generator
                            // function, which for ES6 code should have the "*" generator indicator, which when
                            // parsed should have already set the ES6 flag.
                            ast = ParseYieldExpression();
                        }
                        else
                        {
                            // we need to protect against non-ES6 code using "yield" as a variable name versus the
                            // Mozilla yield syntax. We'll do that further upstream.
                            ast = new LookupExpression(m_currentToken.Clone())
                                {
                                    Name = "yield"
                                };
                            GetNextToken();
                        }
                    }
                    break;

                default:
                    var identifier = JSKeyword.CanBeIdentifier(m_currentToken.Token);
                    if (identifier != null)
                    {
                        ast = new LookupExpression(m_currentToken.Clone())
                            {
                                Name = identifier
                            };
                        GetNextToken();
                    }
                    else
                    {
                        ReportError(JSError.ExpressionExpected);
                    }
                    break;
            }

            if (m_currentToken.Is(JSToken.ArrowFunction))
            {
                ParsedVersion = ScriptVersion.EcmaScript6;
                ast = ParseArrowFunction(ast);
            }

            // can be a CallExpression, that is, followed by '.' or '(' or '['
            return ParseMemberExpression(ast, newContexts);
        }

        private RegExpLiteral ScanRegularExpression()
        {
            RegExpLiteral regExp = null;
            m_currentToken = m_scanner.UpdateToken(UpdateHint.RegularExpression);
            if (m_currentToken.Is(JSToken.RegularExpression))
            {
                var regexContext = m_currentToken.Clone();
                GetNextToken();

                var literal = regexContext.Code;
                var lastSlash = literal.LastIndexOf('/');

                // flags are everything AFTER the last slash
                var flags = literal.Substring(lastSlash + 1);

                // don't include the leading or trailing slash in the pattern
                var pattern = literal.Substring(1, lastSlash - 1);

                // create the regexp node. 
                regExp = new RegExpLiteral(regexContext)
                {
                    Pattern = pattern,
                    PatternSwitches = flags
                };
            }

            // if we get here, there isn't a regular expression at the current position
            return regExp;
        }

        private ConstantWrapper ScanReplacementToken()
        {
            ConstantWrapper constWrapper = null;
            m_currentToken = m_scanner.UpdateToken(UpdateHint.ReplacementToken);
            if (m_currentToken.Is(JSToken.ReplacementToken))
            {
                constWrapper = new ConstantWrapper(m_currentToken.Code, PrimitiveType.Other, m_currentToken.Clone());
                GetNextToken();
            }

            return constWrapper;
        }

        private TemplateLiteral ParseTemplateLiteral()
        {
            // create the root literal node
            ParsedVersion = ScriptVersion.EcmaScript6;
            var literalContext = m_currentToken.Clone();
            var textContext = m_currentToken.Clone();

            LookupExpression lookup = null;
            var text = m_scanner.StringLiteralValue;

            // see if it starts with an identifier
            var indexBackquote = text.IndexOf('`');
            if (indexBackquote != 0)
            {
                var literalName = text.Substring(0, indexBackquote);
                text = text.Substring(indexBackquote);
                var tagContext = textContext.SplitStart(indexBackquote);

                // TODO: figure out how to get a context on just the literal part!
                lookup = new LookupExpression(tagContext)
                    {
                        Name = literalName
                    };
            }

            // if the token doesn't end with a terminator, then we'll need to parse replacement expressions
            var isContinue = text[text.Length - 1] != '`';

            // create the literal node
            var templateLiteral = new TemplateLiteral(literalContext)
            {
                Function = lookup,
                Text = text,
                TextContext = textContext,
                Expressions = isContinue ? new AstNodeList(literalContext.FlattenToEnd()) : null
            };

            GetNextToken();
            if (isContinue)
            {
                // keep going until we hit the final segment
                do
                {
                    isContinue = false;

                    // expression needs to be closed with a right-curly (whether or not we actually found an expression)
                    var expression = ParseExpression();
                    if (m_currentToken.Is(JSToken.RightCurly))
                    {
                        m_scanner.UpdateToken(UpdateHint.TemplateLiteral);
                        if (m_currentToken.Is(JSToken.TemplateLiteral))
                        {
                            text = m_scanner.StringLiteralValue;
                            var templateExpression = new TemplateLiteralExpression(expression.Context.Clone())
                                {
                                    Expression = expression,
                                    Text = text
                                };
                            templateLiteral.UpdateWith(templateExpression.Context);
                            templateLiteral.Expressions.Append(templateExpression);
                            GetNextToken();

                            isContinue = text[text.Length - 1] != '`';
                        }
                    }
                    else
                    {
                        ReportError(JSError.NoRightCurly);
                    }
                }
                while (isContinue);
            }

            return templateLiteral;
        }

        private AstNode ParseYieldExpression()
        {
            ParsedVersion = ScriptVersion.EcmaScript6;

            // save the context of the yield operator, then skip past it
            var context = m_currentToken.Clone();
            var operatorContext = context.Clone();
            GetNextToken();

            var isDelegator = m_currentToken.Is(JSToken.Multiply);
            if (isDelegator)
            {
                // delegator - move past the yield and the delegator token
                GetNextToken();
            }

            // must be followed by an expression
            var expression = ParseExpression(true);
            if (expression == null)
            {
                // we only call this method if we KNOW we are ES6, so if there is no expression,
                // then throw an error.
                ReportError(JSError.ExpressionExpected);
            }
            else
            {
                context.UpdateWith(expression.Context);
            }

            return new UnaryExpression(context)
                {
                    OperatorContext = operatorContext,
                    OperatorToken = JSToken.Yield,
                    Operand = expression,
                    IsDelegator = isDelegator
                };
        }

        private AstNode ParseAwaitExpression()
        {
            ParsedVersion = ScriptVersion.EcmaScript6;

            // save the context of the await operator, then skip past it
            var context = m_currentToken.Clone();
            var operatorContext = context.Clone();
            GetNextToken();

            bool bAssign;
            AstNode expression = ParseUnaryExpression(out bAssign, false);
            expression = new UnaryExpression(expression.Context.CombineWith(operatorContext))
                {
                    OperatorContext = operatorContext,
                    OperatorToken = JSToken.Await,
                    Operand = expression
                };

            return expression;
        }

        private FunctionObject ParseArrowFunction(AstNode parameters)
        {
            // we are on the arrow-function operator now
            var arrowContext = m_currentToken.Clone();
            GetNextToken();
            ParsedVersion = ScriptVersion.EcmaScript6;

            var functionObject = new FunctionObject(parameters.Context.Clone())
                {
                    ParameterDeclarations = BindingTransform.ToParameters(parameters),
                    FunctionType = FunctionType.ArrowFunction,
                    IsAsync = parameters.Parent is LookupExpression lookupExpression && lookupExpression.Name == JSKeyword.CanBeIdentifier(JSToken.Async)
            };
            functionObject.UpdateWith(arrowContext);
            if (m_currentToken.Is(JSToken.LeftCurly))
            {
                functionObject.Body = ParseBlock();
            }
            else
            {
                // parse an assignment expression as a concise block
                functionObject.Body = BlockStatement.ForceToBlock(ParseExpression(true));
                functionObject.Body.IsConcise = true;
            }

            functionObject.Body.IfNotNull(b => functionObject.UpdateWith(b.Context));
            return functionObject;
        }

        private AstNode ParseArrayLiteral(bool isBindingPattern)
        {
            var openDelimiter = m_currentToken.Clone();
            var listCtx = openDelimiter.Clone();
            var list = new AstNodeList(CurrentPositionContext);
            var hasTrailingCommas = false;

            SourceContext commaContext = null;
            do
            {
                GetNextToken();
                AstNode element = null;
                if (m_currentToken.Is(JSToken.Comma))
                {
                    // comma -- missing array item in the list
                    element = new ConstantWrapper(Missing.Value, PrimitiveType.Other, m_currentToken.FlattenToStart());
                }
                else if (m_currentToken.Is(JSToken.RightBracket))
                {
                    // empty list just bails now
                    if (list.Count == 0)
                    {
                        break;
                    }

                    // if we're parsing a binding pattern, we don't care about the final trailing comma
                    if (!isBindingPattern)
                    {
                        // if the current token is the closing brace, then we ended with a comma -- and we need to
                        // add ANOTHER missing value to make sure this last comma doesn't get left off.
                        // TECHNICALLY, that puts an extra item into the array for most modern browsers, but not ALL.
                        hasTrailingCommas = true;
                        element = new ConstantWrapper(Missing.Value, PrimitiveType.Other, m_currentToken.FlattenToStart());

                        // throw a cross-browser warning about trailing commas
                        commaContext.HandleError(JSError.ArrayLiteralTrailingComma);
                    }
                }
                else if (m_currentToken.Is(JSToken.For))
                {
                    // array comprehension
                    return ParseComprehension(true, openDelimiter, null);
                }
                else
                {
                    // see if we have a spread token
                    SourceContext spreadContext = null;
                    if (m_currentToken.Is(JSToken.RestSpread))
                    {
                        ParsedVersion = ScriptVersion.EcmaScript6;
                        spreadContext = m_currentToken.Clone();
                        GetNextToken();
                    }

                    if (isBindingPattern)
                    {
                        element = ParseBinding();
                        if (m_currentToken.Is(JSToken.Assign))
                        {
                            var assignContext = m_currentToken.Clone();
                            GetNextToken();
                            element = new InitializerNode(assignContext.Clone())
                            {
                                Binding = element,
                                AssignContext = assignContext,
                                Initializer = ParseExpression(true)
                            };
                        }
                    }
                    else
                    {
                        element = ParseExpression(true);
                    }

                    // if we had a spread operator on this item, wrap it in a special unary node
                    if (spreadContext != null)
                    {
                        element = new UnaryExpression(spreadContext.CombineWith(element.Context))
                            {
                                Operand = element,
                                OperatorToken = JSToken.RestSpread,
                                OperatorContext = spreadContext
                            };
                    }
                }

                if (m_currentToken.Is(JSToken.For))
                {
                    // mozilla-style array comprehension!
                    return ParseComprehension(true, openDelimiter, element);
                }

                list.Append(element);
                if (m_currentToken.Is(JSToken.Comma))
                {
                    commaContext = m_currentToken.Clone();

                    if (element != null)
                    {
                        element.TerminatingContext = commaContext;
                    }
                }
            }
            while (m_currentToken.Is(JSToken.Comma));

            if (m_currentToken.Is(JSToken.RightBracket))
            {
                listCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }
            else
            {
                m_currentToken.HandleError(JSError.NoRightBracketOrComma, true);
            }

            return new ArrayLiteral(listCtx)
                {
                    Elements = list,
                    MayHaveIssues = hasTrailingCommas
                };
        }

        private ComprehensionNode ParseComprehension(bool isArray, SourceContext openDelimiter, AstNode expression)
        {
            // we will be on the first FOR token, but Mozilla-style will have already
            // parsed the expression node
            var isMozilla = expression != null;
            var context = openDelimiter.Clone();
            SourceContext closeDelimiter = null;
            expression.IfNotNull(e => context.UpdateWith(e.Context));

            var clauseList = new AstNodeList(m_currentToken.Clone());
            do
            {
                if (m_currentToken.IsEither(JSToken.For, JSToken.If))
                {
                    var clause = ParseComprehensionClause();
                    clause.IfNotNull(c => context.UpdateWith(c.Context));
                    clauseList.Append(clause);
                }
                else
                {
                    ReportError(JSError.NoForOrIf);
                }
            }
            while (m_currentToken.IsEither(JSToken.For, JSToken.If));
            
            context.UpdateWith(clauseList.Context);

            // if we didn't get an expression yet (and we shouldn't for ES6-spec comprehensions), 
            // parse one now
            if (expression == null)
            {
                expression = ParseExpression(true);
                expression.IfNotNull(e => context.UpdateWith(e.Context));
            }

            // should be at the closing delimiter now
            if (m_currentToken.IsNot(isArray ? JSToken.RightBracket : JSToken.RightParenthesis))
            {
                ReportError(isArray ? JSError.NoRightBracket : JSError.NoRightParenthesis);
            }
            else
            {
                closeDelimiter = m_currentToken.Clone();
                context.UpdateWith(closeDelimiter);
                GetNextToken();
            }

            ParsedVersion = ScriptVersion.EcmaScript6;
            return new ComprehensionNode(context)
                {
                    OpenDelimiter = openDelimiter,
                    Expression = expression,
                    Clauses = clauseList,
                    CloseDelimiter = closeDelimiter,
                    ComprehensionType = isArray ? ComprehensionType.Array : ComprehensionType.Generator,
                    MozillaOrdering = isMozilla
                };
        }

        private ComprehensionClause ParseComprehensionClause()
        {
            // save the token
            var forOrIfContext = m_currentToken.Clone();
            var clauseContext = forOrIfContext.Clone();
            GetNextToken();

            // open parenthesis
            SourceContext leftParen = null;
            if (m_currentToken.IsNot(JSToken.LeftParenthesis))
            {
                ReportError(JSError.NoLeftParenthesis, forOrIfContext);
            }
            else
            {
                leftParen = m_currentToken.Clone();
                clauseContext.UpdateWith(leftParen);
                GetNextToken();
            }

            AstNode expression = null;
            AstNode binding = null;
            SourceContext ofContext = null;
            var isInOperation = false;
            if (forOrIfContext.Is(JSToken.For))
            {
                // for-clause
                binding = ParseBinding();
                binding.IfNotNull(b => clauseContext.UpdateWith(b.Context));

                if (m_currentToken.Is(JSToken.In) || m_currentToken.Is("of"))
                {
                    isInOperation = m_currentToken.Is(JSToken.In);
                    ofContext = m_currentToken.Clone();
                    GetNextToken();
                    clauseContext.UpdateWith(ofContext);
                }
                else
                {
                    ReportError(JSError.NoForOrIf);
                }

                expression = ParseExpression(true);
                expression.IfNotNull(e => clauseContext.UpdateWith(e.Context));
            }
            else
            {
                // if-clause
                expression = ParseExpression(true);
                expression.IfNotNull(e => clauseContext.UpdateWith(e.Context));
            }

            // close paren
            SourceContext rightParen = null;
            if (m_currentToken.IsNot(JSToken.RightParenthesis))
            {
                ReportError(JSError.NoRightParenthesis);
            }
            else
            {
                rightParen = m_currentToken.Clone();
                clauseContext.UpdateWith(rightParen);
                GetNextToken();
            }

            if (forOrIfContext.Is(JSToken.For))
            {
                // for-clause
                return new ComprehensionForClause(clauseContext)
                    {
                        OperatorContext = forOrIfContext,
                        OpenContext = leftParen,
                        Binding = binding,
                        IsInOperation = isInOperation,
                        OfContext = ofContext,
                        Expression = expression,
                        CloseContext = rightParen,
                    };
            }
            else //if (tokenContext.Is(JSToken.If))
            {
                // if-clause
                return new ComprehensionIfClause(clauseContext)
                    {
                        OperatorContext = forOrIfContext,
                        OpenContext = leftParen,
                        Condition = expression,
                        CloseContext = rightParen,
                    };
            }
        }

        private ObjectLiteral ParseObjectLiteral(bool isBindingPattern)
        {
            SourceContext objCtx = m_currentToken.Clone();
            var propertyList = new AstNodeList(CurrentPositionContext);

            do
            {
                GetNextToken();

                // a trailing comma after the last property gets ignored
                if (m_currentToken.IsNot(JSToken.RightCurly))
                {
                    var property = ParseObjectLiteralProperty(isBindingPattern);
                    propertyList.Append(property);
                }
            }
            while (m_currentToken.Is(JSToken.Comma));

            if (m_currentToken.Is(JSToken.RightCurly))
            {
                objCtx.UpdateWith(m_currentToken);
                GetNextToken();
            }
            else
            {
                ReportError(JSError.NoRightCurly);
            }

            return new ObjectLiteral(objCtx) { Properties = propertyList };
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private ObjectLiteralProperty ParseObjectLiteralProperty(bool isBindingPattern)
        {
            ObjectLiteralProperty property = null;
            ObjectLiteralField field = null;
            AstNode value = null;

            // peek at the NEXT token so we can check if we have name followed by ':'
            var nextToken = PeekToken();
            SourceContext propertyContext = m_currentToken.Clone();
            if (nextToken == JSToken.Colon)
            {
                // regular field name followed by a colon
                field = ParseObjectLiteralFieldName();
                if (m_currentToken.Is(JSToken.Colon))
                {
                    if (field != null)
                    {
                        field.ColonContext = m_currentToken.Clone();
                    }

                    GetNextToken();
                    value = ParseObjectPropertyValue(isBindingPattern);

                    if (isBindingPattern && m_currentToken.Is(JSToken.Assign))
                    {
                        var assignContext = m_currentToken.Clone();
                        GetNextToken();
                        value = new InitializerNode(assignContext.Clone())
                        {
                            Binding = value,
                            AssignContext = assignContext,
                            Initializer = ParseExpression(true)
                        };
                    }
                }
            }
            else if (nextToken == JSToken.Comma || nextToken == JSToken.RightCurly || nextToken == JSToken.Assign)
            {
                // just a name lookup; the property name is implicit
                ParsedVersion = ScriptVersion.EcmaScript6;
                value = ParseObjectPropertyValue(isBindingPattern);

                if (isBindingPattern && m_currentToken.Is(JSToken.Assign))
                {
                    var assignContext = m_currentToken.Clone();
                    GetNextToken();
                    value = new InitializerNode(assignContext.Clone())
                    {
                        Binding = value,
                        AssignContext = assignContext,
                        Initializer = ParseExpression(true)
                    };
                }
            }
            else if (m_currentToken.Is(JSToken.RestSpread))
            {
                // spread operator used in creating objects in ES6
                ParsedVersion = ScriptVersion.EcmaScript6;
                var restContext = m_currentToken.Clone();
                GetNextToken();

                value = ParseExpression(true);

                if (value != null)
                {
                    value = new UnaryExpression(restContext.CombineWith(value.Context))
                    {
                        OperatorContext = restContext,
                        OperatorToken = JSToken.RestSpread,
                        Operand = value
                    };
                }
            }
            else if (m_currentToken.IsEither(JSToken.Get, JSToken.Set))
            {
                bool isGet = (m_currentToken.Is(JSToken.Get));
                var funcContext = m_currentToken.Clone();
                var funcExpr = ParseFunction(isGet ? FunctionType.Getter : FunctionType.Setter, funcContext);
                
                if (funcExpr != null)
                {
                    // getter/setter is just the literal name with a get/set flag
                    field = new GetterSetter(funcExpr.Binding.Name, isGet, funcExpr.Binding.Context.Clone());
                    value = funcExpr;

                    if (isBindingPattern)
                    {
                        funcContext.HandleError(JSError.MethodsNotAllowedInBindings, true);
                    }
                }
                else
                {
                    ReportError(JSError.FunctionExpressionExpected);
                }
            }
            else if (m_currentToken.Is(JSToken.Multiply) || nextToken == JSToken.LeftParenthesis)
            {
                // method declaration in ES6
                // starts off right with the name. Don't set the name field -- the method
                // itself takes care of it, like an implicit-named property
                value = ParseFunction(FunctionType.Method, m_currentToken.Clone());
                if (value != null)
                {
                    // definitely an ES6 construct
                    ParsedVersion = ScriptVersion.EcmaScript6;
                }
            }
            else if (m_currentToken.Is(JSToken.LeftBracket))
            {
                var computedValue = ParseExpression() as ArrayLiteral;
                field = new ComputedPropertyField(computedValue, computedValue.Context);
                if( field != null)
                {
                    ParsedVersion = ScriptVersion.EcmaScript6;
                    field.ColonContext = m_currentToken.Clone();
                }
                if ( m_currentToken.Token != JSToken.Colon)
                {
                    ReportError(JSError.NoColon);
                }

                GetNextToken();
                value = ParseObjectPropertyValue(isBindingPattern);
                if (isBindingPattern && m_currentToken.Is(JSToken.Assign))
                {
                    var assignContext = m_currentToken.Clone();
                    GetNextToken();
                    value = new InitializerNode(assignContext.Clone())
                    {
                        Binding = value,
                        AssignContext = assignContext,
                        Initializer = ParseExpression(true)
                    };
                }
            }

            if (field != null || value != null)
            {
                // bundle the name/value pair into a property
                field.IfNotNull(f => propertyContext.UpdateWith(f.Context));
                value.IfNotNull(v => propertyContext.UpdateWith(v.Context));

                property = new ObjectLiteralProperty(propertyContext)
                {
                    Name = field,
                    Value = value,
                };

                if (m_currentToken.Is(JSToken.Comma))
                {
                    // skip the comma after adding it to the property as a terminating context
                    property.IfNotNull(p => p.TerminatingContext = m_currentToken.Clone());
                }
            }

            return property;
        }

        private ObjectLiteralField ParseObjectLiteralFieldName()
        {
            // simple property name
            ObjectLiteralField field = null;
            switch (m_currentToken.Token)
            {
                case JSToken.Identifier:
                case JSToken.Get:
                case JSToken.Set:
                    field = new ObjectLiteralField(m_scanner.Identifier, PrimitiveType.String, m_currentToken.Clone())
                        {
                            IsIdentifier = true
                        };
                    break;

                case JSToken.StringLiteral:
                    field = new ObjectLiteralField(m_scanner.StringLiteralValue, PrimitiveType.String, m_currentToken.Clone())
                        {
                            MayHaveIssues = m_scanner.LiteralHasIssues
                        };
                    break;

                case JSToken.IntegerLiteral:
                case JSToken.NumericLiteral:
                    {
                        double doubleValue;
                        if (ConvertNumericLiteralToDouble(m_currentToken.Code, (m_currentToken.Is(JSToken.IntegerLiteral)), out doubleValue))
                        {
                            // conversion worked fine
                            field = new ObjectLiteralField(doubleValue, PrimitiveType.Number, m_currentToken.Clone());
                        }
                        else
                        {
                            // something went wrong and we're not sure the string representation in the source is 
                            // going to convert to a numeric value well
                            if (double.IsInfinity(doubleValue))
                            {
                                ReportError(JSError.NumericOverflow);
                            }

                            // use the source as the field name, not the numeric value
                            field = new ObjectLiteralField(m_currentToken.Code, PrimitiveType.Other, m_currentToken.Clone());
                        }
                        break;
                    }

                default:
                    // NOT: identifier token, string, number, or getter/setter.
                    // see if it's a token that COULD be an identifierName.
                    var ident = m_scanner.Identifier;
                    if (JSScanner.IsValidIdentifier(ident))
                    {
                        // BY THE SPEC, if it's a valid identifierName -- which includes reserved words -- then it's
                        // okay for object literal syntax. However, reserved words here won't work in all browsers,
                        // so if it is a reserved word, let's throw a low-sev cross-browser warning on the code.
                        if (JSKeyword.CanBeIdentifier(m_currentToken.Token) == null)
                        {
                            ReportError(JSError.ObjectLiteralKeyword);
                        }

                        field = new ObjectLiteralField(ident, PrimitiveType.String, m_currentToken.Clone());
                    }
                    else
                    {
                        // throw an error but use it anyway, since that's what the developer has going on
                        ReportError(JSError.NoMemberIdentifier);
                        field = new ObjectLiteralField(m_currentToken.Code, PrimitiveType.String, m_currentToken.Clone());
                    }
                    break;
            }

            GetNextToken();
            return field;
        }

        private AstNode ParseObjectPropertyValue(bool isBindingPattern)
        {
            if (isBindingPattern)
            {
                // binding pattern
                return ParseBinding();
            }
            else
            {
                // parse a single expression
                return ParseExpression(true);
            }
        }

        //---------------------------------------------------------------------------------------
        // ParseMemberExpression
        //
        // Accessor :
        //  <empty> |
        //  Arguments Accessor
        //  '[' Expression ']' Accessor |
        //  '.' Identifier Accessor |
        //
        //  Don't have this function throwing an exception without checking all the calling sites.
        //  There is state in instance variable that is saved on the calling stack in some function
        //  (i.e ParseFunction and ParseClass) and you don't want to blow up the stack
        //---------------------------------------------------------------------------------------
        private AstNode ParseMemberExpression(AstNode expression, List<SourceContext> newContexts)
        {
            for (; ; )
            {
                switch (m_currentToken.Token)
                {
                    case JSToken.LeftParenthesis:
                        AstNodeList args = null;
                        args = ParseExpressionList(JSToken.RightParenthesis);

                        expression = new CallExpression(expression.Context.CombineWith(args.Context))
                            {
                                Function = expression,
                                Arguments = args,
                                InBrackets = false
                            };

                        if (null != newContexts && newContexts.Count > 0)
                        {
                            (newContexts[newContexts.Count - 1]).UpdateWith(expression.Context);
                            if (!(expression is CallExpression))
                            {
                                expression = new CallExpression(newContexts[newContexts.Count - 1])
                                    {
                                        Function = expression,
                                        Arguments = new AstNodeList(CurrentPositionContext)
                                    };
                            }
                            else
                            {
                                expression.Context = newContexts[newContexts.Count - 1];
                            }

                            ((CallExpression)expression).IsConstructor = true;
                            newContexts.RemoveAt(newContexts.Count - 1);
                        }

                        GetNextToken();
                        break;

                    case JSToken.LeftBracket:
                        //
                        // ROTOR parses a[b,c] as a call to a, passing in the arguments b and c.
                        // the correct parse is a member lookup on a of c -- the "b,c" should be
                        // a single expression with a comma operator that evaluates b but only
                        // returns c.
                        // So we'll change the default behavior from parsing an expression list to
                        // parsing a single expression, but returning a single-item list (or an empty
                        // list if there is no expression) so the rest of the code will work.
                        //
                        //args = ParseExpressionList(JSToken.RightBracket);
                        GetNextToken();
                        args = new AstNodeList(CurrentPositionContext);

                        AstNode accessor = ParseExpression();
                        if (accessor != null)
                        {
                            args.Append(accessor);
                        }

                        expression = new CallExpression(expression.Context.CombineWith(m_currentToken))
                            {
                                Function = expression,
                                Arguments = args,
                                InBrackets = true
                            };

                        // there originally was code here in the ROTOR sources that checked the new context list and
                        // changed this member call to a constructor call, effectively combining the two. I believe they
                        // need to remain separate.

                        // remove the close bracket token
                        GetNextToken();
                        break;

                    case JSToken.AccessField:
                        ConstantWrapper id = null;

                        string name = null;
                        // we want the name context to start with the dot
                        SourceContext nameContext = m_currentToken.Clone();
                        GetNextToken();
                        if (m_currentToken.IsNot(JSToken.Identifier))
                        {
                            name = JSKeyword.CanBeIdentifier(m_currentToken.Token);
                            if (null != name)
                            {
                                // don't report an error here -- it's actually okay to have a property name
                                // that is a keyword which is okay to be an identifier. For instance,
                                // jQuery has a commonly-used method named "get" to make an ajax request
                                //ForceReportInfo(JSError.KeywordUsedAsIdentifier);
                                id = new ConstantWrapper(name, PrimitiveType.String, m_currentToken.Clone());
                            }
                            else if (JSScanner.IsValidIdentifier(m_currentToken.Code))
                            {
                                // it must be a keyword, because it can't technically be an identifier,
                                // but it IS a valid identifier format. Throw a warning but still
                                // create the constant wrapper so we can output it as-is
                                ReportError(JSError.KeywordUsedAsIdentifier);
                                name = m_currentToken.Code;
                                id = new ConstantWrapper(name, PrimitiveType.String, m_currentToken.Clone());
                            }
                            else
                            {
                                ReportError(JSError.NoIdentifier);
                            }
                        }
                        else
                        {
                            name = m_scanner.Identifier;
                            id = new ConstantWrapper(name, PrimitiveType.String, m_currentToken.Clone());
                        }

                        if (id != null)
                        {
                            nameContext.UpdateWith(id.Context);
                        }

                        GetNextToken();
                        expression = new MemberExpression(expression != null ? expression.Context.CombineWith(nameContext) : nameContext.Clone())
                            {
                                Root = expression,
                                Name = name,
                                NameContext = nameContext
                            };
                        break;
                    default:
                        if (null != newContexts)
                        {
                            while (newContexts.Count > 0)
                            {
                                (newContexts[newContexts.Count - 1]).UpdateWith(expression.Context);
                                expression = new CallExpression(newContexts[newContexts.Count - 1])
                                    {
                                        Function = expression,
                                        Arguments = new AstNodeList(CurrentPositionContext)
                                    };
                                ((CallExpression)expression).IsConstructor = true;
                                newContexts.RemoveAt(newContexts.Count - 1);
                            }
                        }
                        return expression;
                }
            }
        }

        //---------------------------------------------------------------------------------------
        // ParseExpressionList
        //
        //  Given a starting this.currentToken '(' or '[', parse a list of expression separated by
        //  ',' until matching ')' or ']'
        //---------------------------------------------------------------------------------------
        private AstNodeList ParseExpressionList(JSToken terminator)
        {
            var list = new AstNodeList(m_currentToken.Clone());
            do
            {
                // skip past the opening delimiter or comma
                GetNextToken();
                AstNode item = null;
                if (m_currentToken.Is(JSToken.Comma))
                {
                    // a comma here means a missing element. Not really valid, but
                    // let's be a little flexible here.
                    item = new ConstantWrapper(Missing.Value, PrimitiveType.Other, m_currentToken.FlattenToStart());
                    list.Append(item);
                    list.UpdateWith(m_currentToken);
                }
                else if (m_currentToken.IsNot(terminator))
                {
                    // if there's a spread context, save it now
                    SourceContext spreadContext = null;
                    if (m_currentToken.Is(JSToken.RestSpread))
                    {
                        ParsedVersion = ScriptVersion.EcmaScript6;
                        spreadContext = m_currentToken.Clone();
                        GetNextToken();
                    }

                    // parse an expression
                    item = ParseExpression(true);

                    if (spreadContext != null)
                    {
                        item = new UnaryExpression(spreadContext.CombineWith(item.Context))
                            {
                                Operand = item,
                                OperatorToken = JSToken.RestSpread,
                                OperatorContext = spreadContext
                            };
                    }

                    list.Append(item);
                }

                if (m_currentToken.Is(JSToken.Comma))
                {
                    if (item != null)
                    {
                        item.TerminatingContext = m_currentToken.Clone();
                    }
                }
            }
            while (m_currentToken.Is(JSToken.Comma));

            if (m_currentToken.Is(terminator))
            {
                list.Context.UpdateWith(m_currentToken);
            }
            else if (terminator == JSToken.RightParenthesis)
            {
                //  in ASP+ it's easy to write a semicolon at the end of an expression
                //  not realizing it is going to go inside a function call
                //  (ie. Response.Write()), so make a special check here
                if (m_currentToken.Is(JSToken.Semicolon)
                    && PeekToken() == JSToken.RightParenthesis)
                {
                    ReportError(JSError.UnexpectedSemicolon);
                    GetNextToken();
                }
                else
                {
                    // expected a right-parenthesis but don't have one
                    ReportError(JSError.NoRightParenthesis);
                }
            }
            else
            {
                // expected a right-bracket but didn't have one
                ReportError(JSError.NoRightBracket);
            }

            return list;
        }

        #endregion

        #region helper methods

        /// <summary>
        /// set the source by creating a document from the actual source and its context,
        /// then create and initialize a scanner for that document.
        /// </summary>
        /// <param name="source">source code</param>
        /// <param name="sourceContext">optional context for the source code</param>
        private void SetDocumentContext(DocumentContext documentContext)
        {
            // set the document object to point to this parser.
            documentContext.Parser = this;

            // set up the scanner for the given document context
            m_scanner = new JSScanner(documentContext);
            m_currentToken = m_scanner.CurrentToken;

            // if the scanner encounters a special "globals" comment, it'll fire this event
            // at which point we will define a field with that name in the global scope. 
            m_scanner.GlobalDefine += (sender, ea) =>
            {
                var globalScope = GlobalScope;
                if (globalScope[ea.Name] == null)
                {
                    var field = globalScope.CreateField(ea.Name, null, FieldAttributes.SpecialName);
                    globalScope.AddField(field);
                }
            };

            // this event is fired whenever a ///#SOURCE comment is encountered
            m_scanner.NewModule += (sender, ea) =>
            {
                m_newModule = true;

                // we also want to assume that we found a newline character after
                // the comment
                m_foundEndOfLine = true;
            };
        }

        //---------------------------------------------------------------------------------------
        // CreateExpressionNode
        //
        //  Create the proper AST object according to operator
        //---------------------------------------------------------------------------------------
        private static AstNode CreateExpressionNode(SourceContext operatorContext, AstNode operand1, AstNode operand2)
        {
            Debug.Assert(operatorContext != null);

            // create a context, but protect against one or the other operand being null (syntax error during parsing)
            var context = (operand1.IfNotNull(operand => operand.Context) ?? operatorContext)
                .CombineWith(operand2.IfNotNull(operand => operand.Context));

            switch (operatorContext.Token)
            {
                case JSToken.Assign:
                case JSToken.BitwiseAnd:
                case JSToken.BitwiseAndAssign:
                case JSToken.BitwiseOr:
                case JSToken.BitwiseOrAssign:
                case JSToken.BitwiseXor:
                case JSToken.BitwiseXorAssign:
                case JSToken.Divide:
                case JSToken.DivideAssign:
                case JSToken.Equal:
                case JSToken.GreaterThan:
                case JSToken.GreaterThanEqual:
                case JSToken.In:
                case JSToken.InstanceOf:
                case JSToken.LeftShift:
                case JSToken.LeftShiftAssign:
                case JSToken.LessThan:
                case JSToken.LessThanEqual:
                case JSToken.LogicalAnd:
                case JSToken.LogicalOr:
                case JSToken.Minus:
                case JSToken.MinusAssign:
                case JSToken.Modulo:
                case JSToken.ModuloAssign:
                case JSToken.Multiply:
                case JSToken.MultiplyAssign:
                case JSToken.NotEqual:
                case JSToken.Plus:
                case JSToken.PlusAssign:
                case JSToken.RightShift:
                case JSToken.RightShiftAssign:
                case JSToken.StrictEqual:
                case JSToken.StrictNotEqual:
                case JSToken.UnsignedRightShift:
                case JSToken.UnsignedRightShiftAssign:
                    // regular binary operator
                    return new BinaryExpression(context)
                        {
                            Operand1 = operand1,
                            Operand2 = operand2,
                            OperatorContext = operatorContext,
                            OperatorToken = operatorContext.Token
                        };

                case JSToken.Comma:
                    // use the special comma-operator class derived from binary operator.
                    // it has special logic to combine adjacent comma operators into a single
                    // node with an ast node list rather than nested binary operators
                    return CommaExpression.CombineWithComma(context, operand1, operand2);

                default:
                    // shouldn't get here!
                    Debug.Assert(false);
                    return null;
            }
        }

        /// <summary>
        /// Convert the given numeric string to a double value
        /// </summary>
        /// <param name="str">string representation of a number</param>
        /// <param name="isInteger">we should know alreasdy if it's an integer or not</param>
        /// <param name="doubleValue">output value</param>
        /// <returns>true if there were no problems; false if there were</returns>
        private bool ConvertNumericLiteralToDouble(string str, bool isInteger, out double doubleValue)
        {
            try
            {
                if (isInteger)
                {
                    if (str[0] == '0' && str.Length > 1)
                    {
                        if (str[1] == 'x' || str[1] == 'X')
                        {
                            if (str.Length == 2)
                            {
                                // 0x???? must be a parse error. Just return zero
                                doubleValue = 0;
                                return false;
                            }

                            // parse the number as a hex integer, converted to a double
                            doubleValue = (double)System.Convert.ToInt64(str, 16);
                        }
                        else if (str[1] == 'o' || str[1] == 'O')
                        {
                            if (str.Length == 2)
                            {
                                // 0o???? must be a parse error. Just return zero
                                doubleValue = 0;
                                return false;
                            }

                            // parse the number as an octal integer without the prefix, converted to a double
                            doubleValue = (double)System.Convert.ToInt64(str.Substring(2), 8);
                        }
                        else if (str[1] == 'b' || str[1] == 'B')
                        {
                            if (str.Length == 2)
                            {
                                // 0b???? must be a parse error. Just return zero
                                doubleValue = 0;
                                return false;
                            }

                            // parse the number as a binary integer without the prefix, converted to a double
                            doubleValue = (double)System.Convert.ToInt64(str.Substring(2), 2);
                        }
                        else
                        {
                            // might be an octal value... try converting to octal
                            // and if it fails, just convert to decimal
                            try
                            {
                                doubleValue = (double)System.Convert.ToInt64(str, 8);

                                // if we got here, we successfully converted it to octal.
                                // now, octal literals are deprecated -- not all JS implementations will
                                // decode them. If this decoded as an octal, it can also be a decimal. Check
                                // the decimal value, and if it's the same, then we'll just treat it
                                // as a normal decimal value. Otherwise we'll throw a warning and treat it
                                // as a special no-convert literal.
                                double decimalValue = (double)System.Convert.ToInt64(str, 10);
                                if (decimalValue != doubleValue)
                                {
                                    // throw a warning!
                                    ReportError(JSError.OctalLiteralsDeprecated);

                                    // return false because octals are deprecated and might have
                                    // cross-browser issues
                                    return false;
                                }
                            }
                            catch (FormatException)
                            {
                                // ignore the format exception and fall through to parsing
                                // the value as a base-10 decimal value
                                doubleValue = Convert.ToDouble(str, CultureInfo.InvariantCulture);
                            }
                        }
                    }
                    else
                    {
                        // just parse the integer as a decimal value
                        doubleValue = Convert.ToDouble(str, CultureInfo.InvariantCulture);
                    }

                    // check for out-of-bounds integer values -- if the integer can't EXACTLY be represented
                    // as a double, then we don't want to consider it "successful"
                    if (doubleValue < -0x20000000000000 || 0x20000000000000 < doubleValue)
                    {
                        return false;
                    }
                }
                else
                {
                    // use the system to convert the string to a double
                    doubleValue = Convert.ToDouble(str, CultureInfo.InvariantCulture);
                }

                // if we got here, we should have an appropriate value in doubleValue
                return true;
            }
            catch (OverflowException)
            {
                // overflow mean just return one of the infinity values
                doubleValue = (str[0] == '-'
                  ? Double.NegativeInfinity
                  : Double.PositiveInfinity
                  );

                // and it wasn't "successful"
                return false;
            }
            catch (FormatException)
            {
                // format exception converts to NaN
                doubleValue = double.NaN;

                // not successful
                return false;
            }
        }

        private void AppendImportantComments(BlockStatement block)
        {
            if (block != null)
            {
                // make sure any important comments before the closing brace are kept
                if (m_importantComments.Count > 0
                    && m_settings.PreserveImportantComments
                    && m_settings.IsModificationAllowed(TreeModifications.PreserveImportantComments))
                {
                    // we have important comments before the EOF. Add the comment(s) to the program.
                    foreach (var importantComment in m_importantComments)
                    {
                        block.Append(new ImportantComment(importantComment));
                    }

                    m_importantComments.Clear();
                }
            }
        }

        #endregion

        #region get/peek/scan tokens

        //---------------------------------------------------------------------------------------
        // GetNextToken
        //
        //  Return the next token or peeked token if this.errorToken is not null.
        //  Usually this.errorToken is set by AddError even though any code can look ahead
        //  by assigning this.errorToken.
        //  At this point the context is not saved so if position information is needed
        //  they have to be saved explicitely
        //---------------------------------------------------------------------------------------
        private void GetNextToken()
        {
            // the scanner reuses the same context object for performance,
            // so if we ever mean to hold onto it later, we need to clone it.
            m_currentToken = ScanNextToken();
        }

        private static bool[] InitializeSkippableTokens()
        {
            var skippableTokens = new bool[(int)JSToken.Limit];

            skippableTokens[(int)JSToken.WhiteSpace] =
                skippableTokens[(int)JSToken.EndOfLine] =
                skippableTokens[(int)JSToken.SingleLineComment] =
                skippableTokens[(int)JSToken.MultipleLineComment] =
                skippableTokens[(int)JSToken.PreprocessorDirective] =
                skippableTokens[(int)JSToken.Error] = true;

            return skippableTokens;
        }

        private SourceContext ScanNextToken()
        {
            if (EchoWriter != null)
            {
                if (m_currentToken.IsNot(JSToken.None)) EchoWriter.Write(m_currentToken.Code);
            }

            m_newModule = false;
            m_foundEndOfLine = false;
            m_importantComments.Clear();

            var nextToken = m_scanner.ScanNextToken();
            while (nextToken.IsOne(s_skippableTokens))
            {
                if (nextToken.Is(JSToken.EndOfLine))
                {
                    m_foundEndOfLine = true;
                }
                else if (nextToken.IsEither(JSToken.MultipleLineComment, JSToken.SingleLineComment))
                {
                    if (nextToken.HasCode
                        && ((nextToken.Code.Length > 2 && nextToken.Code[2] == '!')
                        || (nextToken.Code.IndexOf("@preserve", StringComparison.OrdinalIgnoreCase) >= 0)
                        || (nextToken.Code.IndexOf("@license", StringComparison.OrdinalIgnoreCase) >= 0)))
                    {
                        // this is an important comment -- save it for later
                        m_importantComments.Add(nextToken.Clone());
                    }
                }

                // if we are preprocess-only, then don't output any preprocessor directive tokens
                if (EchoWriter != null)
                {
                    if (!Settings.PreprocessOnly || nextToken.Token != JSToken.PreprocessorDirective) EchoWriter.Write(nextToken.Code);
                }

                nextToken = m_scanner.ScanNextToken();
            }

            if (nextToken.Is(JSToken.EndOfFile))
            {
                m_foundEndOfLine = true;
            }

            return nextToken;
        }

        private JSToken PeekToken()
        {
            // clone the scanner, turn off any error reporting, and get the next token
            var clonedScanner = m_scanner.PeekClone();
            clonedScanner.SuppressErrors = true;
            var peekToken = clonedScanner.ScanNextToken();

            // there are some tokens we really don't care about when we peek
            // for the next token
            while (peekToken.IsOne(JSToken.WhiteSpace, JSToken.EndOfLine, JSToken.Error, JSToken.SingleLineComment,
                JSToken.MultipleLineComment, JSToken.PreprocessorDirective, JSToken.ConditionalCommentEnd, JSToken.ConditionalCommentStart,
                JSToken.ConditionalCompilationElse, JSToken.ConditionalCompilationElseIf, JSToken.ConditionalCompilationEnd,
                JSToken.ConditionalCompilationIf, JSToken.ConditionalCompilationOn, JSToken.ConditionalCompilationSet,
                JSToken.ConditionalCompilationVariable, JSToken.ConditionalIf))
            {
                peekToken = clonedScanner.ScanNextToken();
            }

            // return the token type
            return peekToken.Token;
        }

        //private IEnumerable<Context> PeekTokens()
        //{
        //    // clone the scanner, turn off any error reporting, and get the next token
        //    var clonedScanner = m_scanner.Clone();
        //    clonedScanner.SuppressErrors = true;

        //    Context peekToken;
        //    while ((peekToken = clonedScanner.ScanNextToken()).IsNot(JSToken.EndOfFile))
        //    {
        //        // there are some tokens we really don't care about when we peek for the next token
        //        while (peekToken.IsOne(JSToken.WhiteSpace, JSToken.EndOfLine, JSToken.Error, JSToken.SingleLineComment,
        //            JSToken.MultipleLineComment, JSToken.PreprocessorDirective, JSToken.ConditionalCommentEnd, JSToken.ConditionalCommentStart,
        //            JSToken.ConditionalCompilationElse, JSToken.ConditionalCompilationElseIf, JSToken.ConditionalCompilationEnd,
        //            JSToken.ConditionalCompilationIf, JSToken.ConditionalCompilationOn, JSToken.ConditionalCompilationSet,
        //            JSToken.ConditionalCompilationVariable, JSToken.ConditionalIf))
        //        {
        //            peekToken = clonedScanner.ScanNextToken();
        //        }

        //        // return the token type
        //        yield return peekToken;
        //    }
        //}

        private bool PeekCanBeModule()
        {
            // shortcut the whole process. If we KNOW we are parsing ES6, then yes: parse a module
            if (ParsedVersion == ScriptVersion.EcmaScript6 || m_settings.ScriptVersion == ScriptVersion.EcmaScript6)
            {
                return true;
            }

            // clone the scanner, turn off any error reporting, and get the next token
            var clonedScanner = m_scanner.PeekClone();
            clonedScanner.SuppressErrors = true;
            var peekToken = clonedScanner.ScanNextToken();

            // skip whitespace, but not linebreaks
            var lineBreak = false;
            while (peekToken.IsOne(JSToken.WhiteSpace, JSToken.EndOfLine, JSToken.Error, JSToken.SingleLineComment,
                JSToken.MultipleLineComment, JSToken.PreprocessorDirective, JSToken.ConditionalCommentEnd, JSToken.ConditionalCommentStart,
                JSToken.ConditionalCompilationElse, JSToken.ConditionalCompilationElseIf, JSToken.ConditionalCompilationEnd,
                JSToken.ConditionalCompilationIf, JSToken.ConditionalCompilationOn, JSToken.ConditionalCompilationSet,
                JSToken.ConditionalCompilationVariable, JSToken.ConditionalIf))
            {
                if (peekToken.Is(JSToken.EndOfLine))
                {
                    lineBreak = true;
                }

                peekToken = clonedScanner.ScanNextToken();
            }

            // if we have a string literal with no linebreaks in between, or an identifier, then we're good to go.
            return (peekToken.Is(JSToken.StringLiteral) && !lineBreak) || peekToken.Is(JSToken.Identifier) || JSKeyword.CanBeIdentifier(peekToken.Token) != null;
        }

        #endregion

        #region error handlers

        /// <summary>
        /// Handle the expected semicolon at the current position for the given node.
        /// </summary>
        /// <param name="node">node that should end with a semicolon</param>
        private void ExpectSemicolon(AstNode node)
        {
            if (m_currentToken.Is(JSToken.Semicolon))
            {
                node.TerminatingContext = m_currentToken.Clone();
                GetNextToken();
            }
            else if (m_foundEndOfLine || m_currentToken.IsEither(JSToken.RightCurly, JSToken.EndOfFile))
            {
                // semicolon insertion rules
                // a right-curly or an end of line is something we don't WANT to throw a warning for. 
                // Just too common and doesn't really warrant a warning (in my opinion)
                if (m_currentToken.IsNot(JSToken.RightCurly) && m_currentToken.IsNot(JSToken.EndOfFile))
                {
                    ReportError(JSError.SemicolonInsertion, node.Context.IfNotNull(c => c.FlattenToEnd()));
                }
            }
            else
            {
                ReportError(JSError.NoSemicolon, node.Context.IfNotNull(c => c.FlattenToEnd()));
            }
        }

        /// <summary>
        ///  Generate a parser error.
        ///  The function is told whether or not next call to GetToken() should return the same
        ///  token or not
        /// </summary>
        /// <param name="errorId">Error to report</param>
        /// <param name="skipToken">true to move to the next token when GetNextToken is called; false to stay on this token</param>
        /// <param name="context">context to report against, or current token if null</param>
        /// <param name="forceToError">whether to force to an error, or use the default severity</param>
        private void ReportError(JSError errorId, SourceContext context = null, bool forceToError = false)
        {
            context = context ?? m_currentToken.Clone();
            // EOF error is special and it's the last error we can possibly get
            if (JSToken.EndOfFile == context.Token)
            {
                context.HandleError(errorId, true); // EOF context is special
            }
            else
            {
                context.HandleError(errorId, forceToError);
            }
        }

        private void CCTooComplicated(SourceContext context)
        {
            // we ONLY support /*@id@*/ or /*@cc_on@id@*/ or /*@!@*/ or /*@cc_on!@*/ in expressions right now. 
            // throw an error, skip to the end of the comment, then ignore it and start
            // looking for the next token.
            (context ?? m_currentToken).HandleError(JSError.ConditionalCompilationTooComplex);

            // skip to end of conditional comment
            while (m_currentToken.IsNot(JSToken.EndOfFile) && m_currentToken.IsNot(JSToken.ConditionalCommentEnd))
            {
                GetNextToken();
            }
            GetNextToken();
        }

        #endregion
    }

    public sealed class UndefinedReference
    {
        private SourceContext m_context;

        private LookupExpression m_lookup;
        public AstNode LookupNode
        {
            get { return m_lookup; }
        }

        private string m_name;
        private ReferenceType m_type;

        public string Name
        {
            get { return m_name; }
        }

        public ReferenceType ReferenceType
        {
            get { return m_type; }
        }

        public int Column
        {
            get
            {
                if (m_context != null)
                {
                    // one-based
                    return m_context.StartColumn + 1;
                }
                else
                {
                    return 0;
                }
            }
        }

        public int Line
        {
            get
            {
                if (m_context != null)
                {
                    return m_context.StartLineNumber;
                }
                else
                {
                    return 0;
                }
            }
        }

        internal UndefinedReference(LookupExpression lookup, SourceContext context)
        {
            m_lookup = lookup;
            m_name = lookup.Name;
            m_type = lookup.RefType;
            m_context = context;
        }

        public override string ToString()
        {
            return m_name;
        }
    }

    public class UndefinedReferenceEventArgs : EventArgs
    {
        public UndefinedReference Reference { get; private set; }

        public UndefinedReferenceEventArgs(UndefinedReference reference)
        {
            Reference = reference;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\JSParser.cs(941,21): error CS0841: Cannot use local variable 'lookup' before it is declared,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\JSParser.cs(942,55): error CS0136: A local or parameter named 'lookup' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 12 - MergeSequentialChecksRewriterR2
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ActivationObject.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using NUglify.Helpers;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public abstract class ActivationObject
    {
        #region private fields

        private bool m_useStrict;//= false;
        private bool m_isKnownAtCompileTime;

        #endregion

        #region internal properties

        /// <summary>
        /// Gets or sets a boolean value for whether this is an existing scope or a new one
        /// generated during the current run.
        /// </summary>
        internal bool Existing { get; set; }

        #endregion

        #region public properties

        public AstNode Owner { get; set; }

        public bool HasSuperBinding { get; set; }

        public bool UseStrict
        {
            get
            {
                return m_useStrict;
            }
            set
            {
                // can set it to true, but can't set it to false
                if (value)
                {
                    // set our value
                    m_useStrict = value;

                    // and all our child scopes (recursive)
                    foreach (var child in ChildScopes)
                    {
                        child.UseStrict = value;
                    }
                }
            }
        }

        public bool IsKnownAtCompileTime
        {
            get { return m_isKnownAtCompileTime; }
            set 
            { 
                m_isKnownAtCompileTime = value;
                if (!value && Settings.EvalTreatment == EvalTreatment.MakeAllSafe)
                {
                    // are we a function scope?
                    var functionObject = this.Owner as FunctionObject;
                    if (functionObject == null)
                    {
                        // we are not a function, so the parent scope is unknown too
                        if (Parent != null)
                        {
                            Parent.IsKnownAtCompileTime = false;
                        }
                    }
                    else
                    {
                        // we are a function, check to see if the function object is actually
                        // referenced. (we don't want to mark the parent as unknown if this function 
                        // isn't even referenced).
                        if (functionObject.IsReferenced)
                        {
                            Parent.IsKnownAtCompileTime = false;
                        }
                    }
                }
            }
        }

        public ActivationObject Parent { get; private set; }
        public bool IsInWithScope { get; set; }

        public IDictionary<string, JSVariableField> NameTable { get; private set; }

        public IList<ActivationObject> ChildScopes { get; private set; }

        public ICollection<LookupExpression> ScopeLookups { get; private set; }
        public ICollection<INameDeclaration> VarDeclaredNames { get; private set; }
        public ICollection<INameDeclaration> LexicallyDeclaredNames { get; private set; }

        public ICollection<BindingIdentifier> GhostedCatchParameters { get; private set; }
        public ICollection<FunctionObject> GhostedFunctions { get; private set; }

        public string ScopeName { get; set; }
        public ScopeType ScopeType { get; protected set; }

        #endregion

        #region protected properties

        protected CodeSettings Settings { get; private set; }

        #endregion

        protected ActivationObject(ActivationObject parent, CodeSettings codeSettings)
        {
            m_isKnownAtCompileTime = true;
            m_useStrict = false;
            Settings = codeSettings;

            Parent = parent;
            NameTable = new Dictionary<string, JSVariableField>();
            ChildScopes = new List<ActivationObject>();

            // if our parent is a scope....
            if (parent != null)
            {
                // add us to the parent's list of child scopes
                parent.ChildScopes.Add(this);

                // if the parent is strict, so are we
                UseStrict = parent.UseStrict;
            }

            // create the two lists of declared items for this scope
            ScopeLookups = new HashSet<LookupExpression>();
            VarDeclaredNames = new HashSet<INameDeclaration>();
            LexicallyDeclaredNames = new HashSet<INameDeclaration>();

            GhostedCatchParameters = new HashSet<BindingIdentifier>();
            GhostedFunctions = new HashSet<FunctionObject>();
        }

        #region public static methods

        /// <summary>
        /// Delete a binding from its parent pattern
        /// </summary>
        /// <param name="binding">binding to delete</param>
        /// <param name="normalizePattern">true to normalize the parent pattern and possibly delete it if now empty</param>
        /// <returns>true if deleted, otherwise false</returns>
        public static bool DeleteFromBindingPattern(AstNode binding, bool normalizePattern)
        {
            var deleted = false;
            if (binding != null)
            {
                // the parent might be an node list under an array literal, or
                // or a property under an object literal 
                ObjectLiteralProperty property = null;
                VariableDeclaration varDecl;
                var nodeList = binding.Parent as AstNodeList;
                if (nodeList != null && nodeList.Parent is ArrayLiteral)
                {
                    // name under an array literal so if this is the LAST element, we can delete it,
                    // otherwise we have to replace it with a missing constant
                    deleted = nodeList.ReplaceChild(
                        binding,
                        new ConstantWrapper(Missing.Value, PrimitiveType.Other, binding.Context.Clone()));
                }
                else if ((property = binding.Parent as ObjectLiteralProperty) != null)
                {
                    // delete the property from the list of properties after saving the list of properties for later
                    nodeList = property.Parent as AstNodeList;
                    deleted = property.Parent.ReplaceChild(property, null);
                }
                else if ((varDecl = binding.Parent as VariableDeclaration) != null)
                {
                    // we're at the top -- the empty binding we are deleting is defined within a vardecl.
                    // IF the declaration is not the variable of a for-in statement, and
                    // IF there are other vardecls in the var, and
                    // IF the initializer is null or constant, 
                    // THEN we can delete it. Otherwise we need to leave the empty pattern.
                    var declaration = varDecl.Parent as Declaration;
                    if (declaration != null)
                    {
                        var forIn = declaration.Parent as ForInStatement;
                        if ((forIn == null || forIn.Variable != declaration)
                            && (varDecl.Initializer == null || varDecl.Initializer.IsConstant))
                        {
                            // NOT in a for-in statement and the initializer is constant. We can delete the
                            // vardecl with the empty binding pattern from its parent and then check to see
                            // if the parent is now empty, and delete it if it is.
                            deleted = varDecl.Parent.ReplaceChild(varDecl, null);
                            if (declaration.Count == 0)
                            {
                                // the whole statement is now empty; whack it too
                                declaration.Parent.ReplaceChild(declaration, null);
                            }
                        }
                    }
                }

                if (deleted)
                {
                    var bindingIdentifier = binding as BindingIdentifier;
                    if (bindingIdentifier != null)
                    {
                        // because this is a binding parameter, the binding should be listed
                        // in the field's declarations collection. Remove it, too
                        bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);

                        // mark the field as deleted IF there are no more references
                        // or declarations
                        if (!bindingIdentifier.VariableField.IsReferenced
                            && bindingIdentifier.VariableField.Declarations.Count == 0)
                        {
                            bindingIdentifier.VariableField.WasRemoved = true;
                        }
                    }

                    // see if we also want to possibly clean up this pattern, now that we've
                    // removed something from it
                    if (normalizePattern && nodeList != null)
                    {
                        // if this nodelist is the child of an array literal, make sure we remove 
                        // any trailing elisions. 
                        if (nodeList.Parent is ArrayLiteral)
                        {
                            for (var ndx = nodeList.Count - 1; ndx >= 0; --ndx)
                            {
                                var constantWrapper = nodeList[ndx] as ConstantWrapper;
                                if (constantWrapper != null && constantWrapper.Value == Missing.Value)
                                {
                                    nodeList.RemoveAt(ndx);
                                }
                                else
                                {
                                    // no longer an elision; stop iterating
                                    break;
                                }
                            }
                        }

                        if (nodeList.Count == 0)
                        {
                            // the list is now empty!
                            // let's recursively get rid of the parent array or object literal
                            // from ITS binding pattern
                            DeleteFromBindingPattern(nodeList.Parent, normalizePattern);
                        }
                    }
                }
            }

            return deleted;
        }

        public static void RemoveBinding(AstNode binding)
        {
            // first unhook all the declarations in the binding pattern
            foreach (var boundName in BindingsVisitor.Bindings(binding))
            {
                var variableField = boundName.VariableField;
                if (variableField != null)
                {
                    variableField.Declarations.Remove(boundName);
                }
            }

            // then remove the binding from it's parent and clean up any cascade
            DeleteFromBindingPattern(binding, true);
        }

        #endregion

        #region scope setup methods

        /// <summary>
        /// Set up this scope's fields from the declarations it contains
        /// </summary>
        public abstract void DeclareScope();

        protected void DefineLexicalDeclarations()
        {
            foreach (var lexDecl in LexicallyDeclaredNames)
            {
                // use the function as the field value if its parent is a function
                // or the class node if its a class
                AstNode fieldValue = lexDecl.Parent as FunctionObject;
                if (fieldValue == null)
                {
                    fieldValue = lexDecl.Parent as ClassNode;
                }

                DefineField(lexDecl, fieldValue);
            }
        }

        protected void DefineVarDeclarations()
        {
            foreach (var varDecl in VarDeclaredNames)
            {
                // var-decls are always initialized to null
                DefineField(varDecl, null);
            }
        }

        private void DefineField(INameDeclaration nameDecl, AstNode fieldValue)
        {
            var field = this[nameDecl.Name];
            if (nameDecl.IsParameter)
            {
                // function parameters are handled separately, so if this is a parameter declaration,
                // then it must be a catch variable. 
                if (field == null)
                {
                    // no collision - create the catch-error field
                    field = new JSVariableField(FieldType.CatchError, nameDecl.Name, 0, null)
                    {
                        OriginalContext = nameDecl.Context,
                        IsDeclared = true
                    };

                    this.AddField(field);
                }
                else
                {
                    // it's an error to declare anything in the catch scope with the same name as the
                    // error variable
                    field.OriginalContext.HandleError(JSError.DuplicateCatch, true);
                }
            }
            else
            {
                if (field == null)
                {
                    // could be global or local depending on the scope, so let the scope create it.
                    field = this.CreateField(nameDecl.Name, null, 0);
                    field.OriginalContext = nameDecl.Context;
                    field.IsDeclared = true;
                    field.IsFunction = (nameDecl is FunctionObject);
                    field.FieldValue = fieldValue;

                    // if this field is a constant or an import, mark it now as initialize only.
                    // Mozilla const statements will be const => vardecl => node
                    // ES6 const statements will be lexdecl(StatementToken == JSToken.Cont) => vardecl => node
                    // imports can be import => 
                    var parentParent = nameDecl.Parent.IfNotNull(p => p.Parent);
                    LexicalDeclaration lexDeclaration;
                    field.InitializationOnly = parentParent is ConstStatement
                        || ((lexDeclaration = parentParent as LexicalDeclaration) != null && lexDeclaration.StatementToken == JSToken.Const);

                    this.AddField(field);
                }
                else
                {
                    // already defined! 
                    // if this is a lexical declaration, then it's an error because we have two
                    // lexical declarations with the same name in the same scope.
                    if (nameDecl.Parent.IfNotNull(p => p.Parent) is LexicalDeclaration)
                    {
                        nameDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, true);
                    }

                    if (nameDecl.Initializer != null)
                    {
                        // if this is an initialized declaration, then the var part is
                        // superfluous and the "initializer" is really a lookup assignment. 
                        // So bump up the ref-count for those cases.
                        var nameReference = nameDecl as INameReference;
                        if (nameReference != null)
                        {
                            field.AddReference(nameReference);
                        }
                    }

                    // don't clobber an existing field value with null. For instance, the last 
                    // function declaration is the winner, so always set the value if we have something,
                    // but a var following a function shouldn't reset it to null.
                    if (fieldValue != null)
                    {
                        field.FieldValue = fieldValue;
                    }
                }

                // if this is a field that was declared with an export statement, then we want to set the
                // IsExported flag. Stop if we get to a block, because that means we aren't in an export
                // statement.
                var parent = (AstNode)nameDecl;
                while ((parent = parent.Parent) != null && !(parent is BlockStatement))
                {
                    if (parent is ExportStatement)
                    {
                        field.IsExported = true;
                        break;
                    }
                    else if (parent is ImportStatement)
                    {
                        // import fields cannot be assigned to.
                        field.InitializationOnly = true;
                        break;
                    }
                }
            }

            nameDecl.VariableField = field;
            field.Declarations.Add(nameDecl);

            // if this scope is within a with-statement, or if the declaration was flagged
            // as not being renamable, then mark the field as not crunchable
            if (IsInWithScope || nameDecl.RenameNotAllowed)
            {
                field.CanCrunch = false;
            }
        }

        #endregion

        #region AnalyzeScope functionality

        internal virtual void AnalyzeScope()
        {
            // global scopes override this and don't call the next
            AnalyzeNonGlobalScope();

            // rename fields if we need to
            ManualRenameFields();

            // recurse 
            foreach (var activationObject in ChildScopes)
            {
                activationObject.AnalyzeScope();
            }
        }

        private void AnalyzeNonGlobalScope()
        {
            foreach (var variableField in NameTable.Values)
            {
                if (variableField.OuterField == null)
                {
                    // not referenced, not generated, and has an original context so not added after the fact.
                    // and we don't care if ghosted, catch-error fields or exports are unreferenced.
                    if (!variableField.IsReferenced
                        && !variableField.IsGenerated
                        && variableField.FieldType != FieldType.CatchError
                        && variableField.FieldType != FieldType.GhostCatch
                        && !variableField.IsExported
                        && variableField.OriginalContext != null)
                    {
                        UnreferencedVariableField(variableField);
                    }
                    else if (variableField.FieldType == FieldType.Local
                        && variableField.RefCount == 1
                        && this.IsKnownAtCompileTime
                        && Settings.RemoveUnneededCode
                        && Settings.IsModificationAllowed(TreeModifications.RemoveUnusedVariables))
                    {
                        SingleReferenceVariableField(variableField);
                    }
                }
            }
        }

        private void UnreferencedVariableField(JSVariableField variableField)
        {
            // see if the value is a function
            var functionObject = variableField.FieldValue as FunctionObject;
            if (functionObject != null)
            {
                UnreferencedFunction(variableField, functionObject);
            }
            else if (variableField.FieldType != FieldType.Argument && !variableField.WasRemoved)
            {
                UnreferencedVariable(variableField);
            }
        }

        private void UnreferencedFunction(JSVariableField variableField, FunctionObject functionObject)
        {
            // if there is no name, then ignore this declaration because it's malformed.
            // (won't be a function expression because those are automatically referenced).
            // also ignore ghosted function fields.
            if (functionObject.Binding != null && variableField.FieldType != FieldType.GhostFunction)
            {
                // if the function name isn't a simple identifier, then leave it there and mark it as
                // not renamable because it's probably one of those darn IE-extension event handlers or something.
                if (JSScanner.IsValidIdentifier(functionObject.Binding.Name))
                {
                    // unreferenced function declaration. fire a warning.
                    var ctx = functionObject.Binding.Context ?? variableField.OriginalContext;
                    ctx.HandleError(JSError.FunctionNotReferenced, false);

                    // hide it from the output if our settings say we can.
                    // we don't want to delete it, per se, because we still want it to 
                    // show up in the scope report so the user can see that it was unreachable
                    // in case they are wondering where it went.
                    // ES6 has the notion of block-scoped function declarations. ES5 says functions can't
                    // be defined inside blocks -- only at the root level of the global scope or function scopes.
                    // so if this is a block scope, don't hide the function, even if it is unreferenced because
                    // of the cross-browser difference.
                    if (this.IsKnownAtCompileTime
                        && Settings.MinifyCode
                        && Settings.RemoveUnneededCode
                        && !(this is BlockScope))
                    {
                        // REMOVE the unreferened function, don't dance around trying to "hide" it
                        //functionObject.HideFromOutput = true;
                        functionObject.Parent.IfNotNull(p => p.ReplaceChild(functionObject, null));
                    }
                }
                else
                {
                    // not a valid identifier name for this function. Don't rename it because it's
                    // malformed and we don't want to mess up the developer's intent.
                    variableField.CanCrunch = false;
                }
            }
        }

        private void UnreferencedVariable(JSVariableField variableField)
        {
            var throwWarning = true;

            // not a function, not an argument, not a catch-arg, not a global.
            // not referenced. If there's a single definition, and it either has no
            // initializer or the initializer is constant, get rid of it. 
            // (unless we aren't removing unneeded code, or the scope is unknown)
            if (variableField.Declarations.Count == 1 && this.IsKnownAtCompileTime)
            {
                BindingIdentifier bindingIdentifier;
                var nameDeclaration = variableField.OnlyDeclaration;
                var varDecl = nameDeclaration.IfNotNull(decl => decl.Parent as VariableDeclaration);
                if (varDecl != null)
                {
                    var declaration = varDecl.Parent as Declaration;
                    if (declaration != null
                        && (varDecl.Initializer == null || varDecl.Initializer.IsConstant))
                    {
                        // if the decl parent is a for-in and the decl is the variable part
                        // of the statement, then just leave it alone. Don't even throw a warning
                        var forInStatement = declaration.Parent as ForInStatement;
                        if (forInStatement != null
                            && declaration == forInStatement.Variable)
                        {
                            // just leave it alone, and don't even throw a warning for it.
                            // TODO: try to reuse some pre-existing variable, or maybe replace
                            // this vardecl with a ref to an unused parameter if this is inside
                            // a function.
                            throwWarning = false;
                        }
                        else if (Settings.RemoveUnneededCode
                            && Settings.IsModificationAllowed(TreeModifications.RemoveUnusedVariables))
                        {
                            variableField.Declarations.Remove(nameDeclaration);

                            // don't "remove" the field if it's a ghost to another field
                            if (variableField.GhostedField == null)
                            {
                                variableField.WasRemoved = true;
                            }

                            // remove the vardecl from the declaration list, and if the
                            // declaration list is now empty, remove it, too
                            declaration.Remove(varDecl);
                            if (declaration.Count == 0)
                            {
                                declaration.Parent.ReplaceChild(declaration, null);
                            }
                        }
                    }
                    else if (varDecl.Parent is ForInStatement)
                    {
                        // then this is okay
                        throwWarning = false;
                    }
                }
                else if ((bindingIdentifier = nameDeclaration as BindingIdentifier) != null)
                {
                    // try deleting the binding pattern declaration
                    DeleteFromBindingPattern(bindingIdentifier, true);
                }
            }

            if (throwWarning && variableField.HasNoReferences)
            {
                // not referenced -- throw a warning, assuming it hasn't been "removed" 
                // via an optimization or something.
                variableField.OriginalContext.HandleError(
                    JSError.VariableDefinedNotReferenced,
                    false);
            }
        }

        private static void SingleReferenceVariableField(JSVariableField variableField)
        {
            // local fields that only have one declaration
            if (variableField.Declarations.Count == 1)
            {
                // there should only be one, it should be a vardecl, and 
                // either no initializer or a constant initializer
                var nameDeclaration = variableField.OnlyDeclaration;
                var varDecl = nameDeclaration.IfNotNull(d => d.Parent as VariableDeclaration);
                if (varDecl != null
                    && varDecl.Initializer != null
                    && varDecl.Initializer.IsConstant)
                {
                    // there should only be one
                    var reference = variableField.OnlyReference;
                    if (reference != null)
                    {
                        // if the reference is not being assigned to, it is not an outer reference
                        // (meaning the lookup is in the same scope as the declaration), and the
                        // lookup is after the declaration
                        if (!reference.IsAssignment
                            && reference.VariableField != null
                            && reference.VariableField.OuterField == null
                            && reference.VariableField.CanCrunch
                            && !reference.VariableField.IsExported
                            && varDecl.Index < reference.Index
                            && !IsIterativeReference(varDecl.Initializer, reference))
                        {
                            // so we have a declaration assigning a constant value, and only one
                            // reference reading that value. replace the reference with the constant
                            // and get rid of the declaration.
                            // transform: var lookup=constant;lookup   ==>   constant
                            // remove the vardecl
                            var declaration = varDecl.Parent as Declaration;
                            if (declaration != null)
                            {
                                // replace the reference with the constant
                                variableField.References.Remove(reference);
                                var refNode = reference as AstNode;
                                refNode.Parent.IfNotNull(p => p.ReplaceChild(refNode, varDecl.Initializer));

                                // we're also going to remove the declaration itself
                                variableField.Declarations.Remove(nameDeclaration);
                                variableField.WasRemoved = true;

                                // remove the vardecl from the declaration list
                                // and if the declaration is now empty, remove it, too
                                declaration.Remove(varDecl);
                                if (declaration.Count == 0)
                                {
                                    declaration.Parent.IfNotNull(p => p.ReplaceChild(declaration, null));
                                }
                            }
                        }
                    }
                }
            }
        }

        private static bool IsIterativeReference(AstNode initializer, INameReference reference)
        {
            // we only care about array and regular expressions with the global switch at this point.
            // if it's not one of those types, then go ahead and assume iterative reference doesn't matter.
            var regExp = initializer as RegExpLiteral;
            if (initializer is ArrayLiteral 
                || initializer is ObjectLiteral
                || (regExp != null && regExp.PatternSwitches != null && regExp.PatternSwitches.IndexOf("g", StringComparison.OrdinalIgnoreCase) >= 0))
            {
                // get the parent block for the initializer. We'll use this as a stopping point in our loop.
                var parentBlock = GetParentBlock(initializer);

                // walk up the parent chain from the reference. If we find a while, a for, or a do-while,
                // then we know this reference is iteratively called.
                // stop when the parent is null, the same block containing the initializer, or a function object.
                // (because a function object will step out of scope, and we know we should be in the same scope)
                var child = reference as AstNode;
                var parent = child.Parent;
                while (parent != null && parent != parentBlock && !(parent is FunctionObject))
                {
                    // while or do-while is iterative -- the condition and the body are both called repeatedly.
                    if (parent is WhileStatement || parent is DoWhileStatement)
                    {
                        return true;
                    }

                    // for-statements call the condition, the incrementer, and the body repeatedly, but not the
                    // initializer.
                    var forNode = parent as ForStatement;
                    if (forNode != null && child != forNode.Initializer)
                    {
                        return true;
                    }

                    // in forin-statements, only the body is repeated, the collection is evaluated only once.
                    var forInStatement = parent as ForInStatement;
                    if (forInStatement != null && child == forInStatement.Body)
                    {
                        return true;
                    }

                    // go up
                    child = parent;
                    parent = parent.Parent;
                }
            }

            return false;
        }

        /// <summary>
        /// Return the first Block node in the tree starting from the given node and working up through the parent nodes.
        /// </summary>
        /// <param name="node">initial node</param>
        /// <returns>first block node in the node tree</returns>
        private static BlockStatement GetParentBlock(AstNode node)
        {
            while(node != null)
            {
                // see if the current node is a block, and if so, return it.
                var block = node as BlockStatement;
                if (block != null)
                {
                    return block;
                }

                // try the parent
                node = node.Parent;
            }

            // if we get here, we never found a parent block.
            return null;
        }

        protected void ManualRenameFields()
        {
            // if the local-renaming kill switch is on, we won't be renaming ANYTHING, so we'll have nothing to do.
            if (Settings.IsModificationAllowed(TreeModifications.LocalRenaming))
            {
                // if the parser settings has a list of rename pairs, we will want to go through and rename
                // any matches
                if (Settings.HasRenamePairs)
                {
                    // go through the list of fields in this scope. Anything defined in the script that
                    // is in the parser rename map should be renamed and the auto-rename flag reset so
                    // we don't change it later.
                    foreach (var varField in NameTable.Values)
                    {
                        // don't rename outer fields (only actual fields), 
                        // and we're only concerned with global or local variables --
                        // those which are defined by the script (not predefined, not the arguments object)
                        if (varField.OuterField == null 
                            && (varField.FieldType != FieldType.Arguments && varField.FieldType != FieldType.Predefined))
                        {
                            // see if the name is in the parser's rename map
                            string newName = Settings.GetNewName(varField.Name);
                            if (!string.IsNullOrEmpty(newName))
                            {
                                // it is! Change the name of the field, but make sure we reset the CanCrunch flag
                                // or setting the "crunched" name won't work.
                                // and don't bother making sure the name doesn't collide with anything else that
                                // already exists -- if it does, that's the developer's fault.
                                // TODO: should we at least throw a warning?
                                varField.CanCrunch = true;
                                varField.CrunchedName = newName;

                                // and make sure we don't crunch it later
                                varField.CanCrunch = false;
                            }
                        }
                    }
                }

                // if the parser settings has a list of no-rename names, then we will want to also mark any
                // fields that match and are still slated to rename as uncrunchable so they won't get renamed.
                // if the settings say we're not going to renaming anything automatically (KeepAll), then we 
                // have nothing to do.
                if (Settings.LocalRenaming != LocalRenaming.KeepAll)
                {
                    foreach (var noRename in Settings.NoAutoRenameCollection)
                    {
                        // don't rename outer fields (only actual fields), 
                        // and we're only concerned with fields that can still
                        // be automatically renamed. If the field is all that AND is listed in
                        // the collection, set the CanCrunch to false
                        JSVariableField varField;
                        if (NameTable.TryGetValue(noRename, out varField)
                            && varField.OuterField == null
                            && varField.CanCrunch)
                        {
                            // no, we don't want to crunch this field
                            varField.CanCrunch = false;
                        }
                    }
                }
            }
        }

        #endregion

        #region crunching methods

        internal void ValidateGeneratedNames()
        {
            // check all the variables defined within this scope.
            // we're looking for uncrunched generated fields.
            foreach (JSVariableField variableField in NameTable.Values)
            {
                if (variableField.IsGenerated
                    && variableField.CrunchedName == null)
                {
                    // we need to rename this field.
                    // first we need to walk all the child scopes depth-first
                    // looking for references to this field. Once we find a reference,
                    // we then need to add all the other variables referenced in those
                    // scopes and all above them (from here) so we know what names we
                    // can't use.
                    var avoidTable = new HashSet<string>();
                    GenerateAvoidList(avoidTable, variableField.Name);

                    // now that we have our avoid list, create a crunch enumerator from it
                    CrunchEnumerator crunchEnum = new CrunchEnumerator(avoidTable);

                    // and use it to generate a new name
                    variableField.CrunchedName = crunchEnum.NextName();
                }
            }

            // recursively traverse through our children
            foreach (ActivationObject scope in ChildScopes)
            {
                if (!scope.Existing)
                {
                    scope.ValidateGeneratedNames();
                }
            }
        }

        private bool GenerateAvoidList(HashSet<string> table, string name)
        {
            // our reference flag is based on what was passed to us
            bool isReferenced = false;

            // depth first, so walk all the children
            foreach (ActivationObject childScope in ChildScopes)
            {
                // if any child returns true, then it or one of its descendents
                // reference this variable. So we reference it, too
                if (childScope.GenerateAvoidList(table, name))
                {
                    // we'll return true because we reference it
                    isReferenced = true;
                }
            }

            if (!isReferenced)
            {
                // none of our children reference the scope, so see if we do
                isReferenced = NameTable.ContainsKey(name);
            }

            if (isReferenced)
            {
                // if we reference the name or are in line to reference the name,
                // we need to add all the variables we reference to the list
                foreach (var variableField in NameTable.Values)
                {
                    table.Add(variableField.ToString());
                }
            }

            // return whether or not we are in the reference chain
            return isReferenced;
        }

        internal virtual void AutoRenameFields()
        {
            // if we're not known at compile time, then we can't crunch
            // the local variables in this scope, because we can't know if
            // something will reference any of it at runtime.
            // eval is something that will make the scope unknown because we
            // don't know what eval will evaluate to until runtime
            if (m_isKnownAtCompileTime)
            {
                // get an array of all the uncrunched local variables defined in this scope
                var localFields = GetUncrunchedLocals();
                if (localFields != null)
                {
                    // create a crunch-name enumerator, taking into account any fields within our
                    // scope that have already been crunched.
                    var avoidSet = new HashSet<string>();
                    foreach (var field in NameTable.Values)
                    {
                        // if the field can't be crunched, or if it can but we've already crunched it,
                        // or if it's an outer variable (that hasn't been generated) and its OWNING scope isn't known 
                        // (and therefore we CANNOT crunch it),
                        // then add it to the avoid list so we don't reuse that name
                        if (!field.CanCrunch || field.CrunchedName != null
                            || (field.OuterField != null && !field.IsGenerated && field.OwningScope != null && !field.OwningScope.IsKnownAtCompileTime))
                        {
                            avoidSet.Add(field.ToString());
                        }
                    }

                    var crunchEnum = new CrunchEnumerator(avoidSet);
                    foreach (var localField in localFields)
                    {
                        // if we are an unambiguous reference to a named function expression and we are not
                        // referenced by anyone else, then we can just skip this variable because the
                        // name will be stripped from the output anyway.
                        // we also always want to crunch "placeholder" fields.
                        if (localField.CanCrunch
                            && (localField.RefCount > 0 || localField.IsDeclared || localField.IsPlaceholder
                            || !(Settings.RemoveFunctionExpressionNames && Settings.IsModificationAllowed(TreeModifications.RemoveFunctionExpressionNames))))
                        {
                            localField.CrunchedName = crunchEnum.NextName();

                            if (localField.Declarations.FirstOrDefault()?.Parent?.Parent?.Parent is ForInStatement forInStatement &&
                                forInStatement.Collection is MemberExpression memberExpression &&
                                memberExpression.Root is INameReference nameReference &&
                                localField.CrunchedName == (nameReference.VariableField.CrunchedName ?? nameReference.VariableField.Name))
                            {
                                localField.CrunchedName = crunchEnum.NextName();
                            }
                        }
                    }
                }
            }

            // then traverse through our children
            foreach (ActivationObject scope in ChildScopes)
            {
                scope.AutoRenameFields();
            }
        }

        internal IEnumerable<JSVariableField> GetUncrunchedLocals()
        {
            // there can't be more uncrunched fields than total fields
            var list = new List<JSVariableField>(NameTable.Count);
            foreach (var variableField in NameTable.Values)
            {
                // if the field is defined in this scope and hasn't been crunched
                // AND can still be crunched AND wasn't removed during the optimization process
                if (variableField != null && variableField.OuterField == null && variableField.CrunchedName == null
                    && variableField.CanCrunch && !variableField.WasRemoved)
                {
                    // if local renaming is not crunch all, then it must be crunch all but localization
                    // (we don't get called if we aren't crunching anything). 
                    // SO for the first clause:
                    // IF we are crunch all, we're good; but if we aren't crunch all, then we're only good if
                    //    the name doesn't start with "L_".
                    // The second clause is only computed IF we already think we're good to go.
                    // IF we aren't preserving function names, then we're good. BUT if we are, we're
                    // only good to go if this field doesn't represent a function object.
                    if ((Settings.LocalRenaming == LocalRenaming.CrunchAll
                        || !variableField.Name.StartsWith("L_", StringComparison.Ordinal))
                        && !(Settings.PreserveFunctionNames && variableField.IsFunction))
                    {
                        list.Add(variableField);
                    }
                }
            }

            if (list.Count == 0)
            {
                return null;
            }

            // sort the array and return it
            list.Sort(ReferenceComparer.Instance);
            return list;
        }

        #endregion

        #region field-management methods

        public virtual JSVariableField this[string name]
        {
            get
            {
                JSVariableField variableField;
                // check to see if this name is already defined in this scope
                if (!NameTable.TryGetValue(name, out variableField))
                {
                    // not in this scope
                    variableField = null;
                }
                return variableField;
            }
        }

        /// <summary>
        /// See if the given name will resolve to a field; do not create any inner fields
        /// or unknown global fields along the way.
        /// </summary>
        /// <param name="name">name to resolve</param>
        /// <returns>an existing resolved field, or null if nothing exists</returns>
        public JSVariableField CanReference(string name)
        {
            // check for this scope.
            var variableField = this[name];

            // if we didn't find anything, go up the chain until we find something.
            if (variableField == null)
            {
                var parentScope = this.Parent;
                while (parentScope != null && variableField == null)
                {
                    variableField = parentScope[name];
                    parentScope = parentScope.Parent;
                }
            }

            return variableField;
        }

        /// <summary>
        /// Resolve the name in this scope, or go up the chain adding inner fields
        /// along the way until the final reference is found, creating an unknown global
        /// field if necessary.
        /// </summary>
        /// <param name="name">name to resolve</param>
        /// <returns>resolved variable field (should never be null)</returns>
        public JSVariableField FindReference(string name)
        {
            // see if we have it
            var variableField = this[name];

            // if we didn't find anything and this scope has a parent
            if (variableField == null && name != null)
            {
                // if this is the super reference and we have one....
                if (string.CompareOrdinal(name, "super") == 0 && this.HasSuperBinding)
                {
                    variableField = new JSVariableField(FieldType.Super, name, 0, null);
                    NameTable.Add(name, variableField);
                }
                else if (this.Parent != null)
                {
                    // recursively go up the scope chain to find a reference,
                    // then create an inner field to point to it and we'll return
                    // that one.
                    variableField = CreateInnerField(this.Parent.FindReference(name));

                    // mark it as a placeholder. we might be going down a chain of scopes,
                    // where we will want to reserve the variable name, but not actually reference it.
                    // at the end where it is actually referenced we will reset the flag.
                    variableField.IsPlaceholder = true;
                }
                else
                {
                    // must be global scope. the field is undefined!
                    variableField = AddField(new JSVariableField(FieldType.UndefinedGlobal, name, 0, null));
                }
            }

            return variableField;
        }

        public virtual JSVariableField DeclareField(string name, object value, FieldAttributes attributes)
        {
            JSVariableField variableField;
            if (!NameTable.TryGetValue(name, out variableField))
            {
                variableField = CreateField(name, value, attributes);
                AddField(variableField);
            }
            return variableField;
        }

        public virtual JSVariableField CreateField(JSVariableField outerField)
        {
            // use the same type as the outer field by default
            return outerField.IfNotNull(o => new JSVariableField(o.FieldType, o));
        }

        public abstract JSVariableField CreateField(string name, object value, FieldAttributes attributes);

        public virtual JSVariableField CreateInnerField(JSVariableField outerField)
        {
            JSVariableField innerField = null;
            if (outerField != null)
            {
                // create a new inner field to be added to our scope
                innerField = CreateField(outerField);
                AddField(innerField);
            }

            return innerField;
        }

        internal JSVariableField AddField(JSVariableField variableField)
        {
            // add it to our name table 
            NameTable[variableField.Name] = variableField;

            // set the owning scope to this is we are the outer field, or the outer field's
            // owning scope if this is an inner field
            variableField.OwningScope = variableField.OuterField == null ? this : variableField.OuterField.OwningScope;
            return variableField;
        }

        public INameDeclaration VarDeclaredName(string name)
        {
            // check each var-decl name from inside this scope
            foreach (var varDecl in this.VarDeclaredNames)
            {
                // if the name matches, return the field
                if (string.CompareOrdinal(varDecl.Name, name) == 0)
                {
                    return varDecl;
                }
            }

            // if we get here, we didn't find a match
            return null;
        }

        public INameDeclaration LexicallyDeclaredName(string name)
        {
            // check each var-decl name from inside this scope
            foreach (var lexDecl in this.LexicallyDeclaredNames)
            {
                // if the name matches, return the field
                if (string.CompareOrdinal(lexDecl.Name, name) == 0)
                {
                    return lexDecl;
                }
            }

            // if we get here, we didn't find a match
            return null;
        }

        public void AddGlobal(string name)
        {
            // first, go up to the global scope
            var scope = this;
            while (scope.Parent != null)
            {
                scope = scope.Parent;
            }

            // now see if there is a field with that name already; 
            // will return a non-null field object if there is.
            var field = scope[name];
            if (field == null)
            {
                // nothing with this name. Add it as a global field
                scope.AddField(scope.CreateField(name, null, 0));
            }
        }

        #endregion
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using NUglify.Helpers;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public abstract class ActivationObject
    {
        #region private fields

        private bool m_useStrict;//= false;
        private bool m_isKnownAtCompileTime;

        #endregion

        #region internal properties

        /// <summary>
        /// Gets or sets a boolean value for whether this is an existing scope or a new one
        /// generated during the current run.
        /// </summary>
        internal bool Existing { get; set; }

        #endregion

        #region public properties

        public AstNode Owner { get; set; }

        public bool HasSuperBinding { get; set; }

        public bool UseStrict
        {
            get
            {
                return m_useStrict;
            }
            set
            {
                // can set it to true, but can't set it to false
                if (value)
                {
                    // set our value
                    m_useStrict = value;

                    // and all our child scopes (recursive)
                    foreach (var child in ChildScopes)
                    {
                        child.UseStrict = value;
                    }
                }
            }
        }

        public bool IsKnownAtCompileTime
        {
            get { return m_isKnownAtCompileTime; }
            set 
            { 
                m_isKnownAtCompileTime = value;
                if (!value && Settings.EvalTreatment == EvalTreatment.MakeAllSafe)
                {
                    // are we a function scope?
                    var functionObject = this.Owner as FunctionObject;
                    if (functionObject == null)
                    {
                        // we are not a function, so the parent scope is unknown too
                        if (Parent != null)
                        {
                            Parent.IsKnownAtCompileTime = false;
                        }
                    }
                    else
                    {
                        // we are a function, check to see if the function object is actually
                        // referenced. (we don't want to mark the parent as unknown if this function 
                        // isn't even referenced).
                        if (functionObject.IsReferenced)
                        {
                            Parent.IsKnownAtCompileTime = false;
                        }
                    }
                }
            }
        }

        public ActivationObject Parent { get; private set; }
        public bool IsInWithScope { get; set; }

        public IDictionary<string, JSVariableField> NameTable { get; private set; }

        public IList<ActivationObject> ChildScopes { get; private set; }

        public ICollection<LookupExpression> ScopeLookups { get; private set; }
        public ICollection<INameDeclaration> VarDeclaredNames { get; private set; }
        public ICollection<INameDeclaration> LexicallyDeclaredNames { get; private set; }

        public ICollection<BindingIdentifier> GhostedCatchParameters { get; private set; }
        public ICollection<FunctionObject> GhostedFunctions { get; private set; }

        public string ScopeName { get; set; }
        public ScopeType ScopeType { get; protected set; }

        #endregion

        #region protected properties

        protected CodeSettings Settings { get; private set; }

        #endregion

        protected ActivationObject(ActivationObject parent, CodeSettings codeSettings)
        {
            m_isKnownAtCompileTime = true;
            m_useStrict = false;
            Settings = codeSettings;

            Parent = parent;
            NameTable = new Dictionary<string, JSVariableField>();
            ChildScopes = new List<ActivationObject>();

            // if our parent is a scope....
            if (parent != null)
            {
                // add us to the parent's list of child scopes
                parent.ChildScopes.Add(this);

                // if the parent is strict, so are we
                UseStrict = parent.UseStrict;
            }

            // create the two lists of declared items for this scope
            ScopeLookups = new HashSet<LookupExpression>();
            VarDeclaredNames = new HashSet<INameDeclaration>();
            LexicallyDeclaredNames = new HashSet<INameDeclaration>();

            GhostedCatchParameters = new HashSet<BindingIdentifier>();
            GhostedFunctions = new HashSet<FunctionObject>();
        }

        #region public static methods

        /// <summary>
        /// Delete a binding from its parent pattern
        /// </summary>
        /// <param name="binding">binding to delete</param>
        /// <param name="normalizePattern">true to normalize the parent pattern and possibly delete it if now empty</param>
        /// <returns>true if deleted, otherwise false</returns>
        public static bool DeleteFromBindingPattern(AstNode binding, bool normalizePattern)
        {
            var deleted = false;
            if (binding != null)
            {
                // the parent might be an node list under an array literal, or
                // or a property under an object literal 
                ObjectLiteralProperty property = null;
                VariableDeclaration varDecl;
                var nodeList = binding.Parent as AstNodeList;
                if (nodeList?.Parent is ArrayLiteral)
                {
                    // name under an array literal so if this is the LAST element, we can delete it,
                    // otherwise we have to replace it with a missing constant
                    deleted = nodeList.ReplaceChild(
                        binding,
                        new ConstantWrapper(Missing.Value, PrimitiveType.Other, binding.Context.Clone()));
                }
                else if ((property = binding.Parent as ObjectLiteralProperty) != null)
                {
                    // delete the property from the list of properties after saving the list of properties for later
                    nodeList = property.Parent as AstNodeList;
                    deleted = property.Parent.ReplaceChild(property, null);
                }
                else if ((varDecl = binding.Parent as VariableDeclaration) != null)
                {
                    // we're at the top -- the empty binding we are deleting is defined within a vardecl.
                    // IF the declaration is not the variable of a for-in statement, and
                    // IF there are other vardecls in the var, and
                    // IF the initializer is null or constant, 
                    // THEN we can delete it. Otherwise we need to leave the empty pattern.
                    var declaration = varDecl.Parent as Declaration;
                    if (declaration != null)
                    {
                        var forIn = declaration.Parent as ForInStatement;
                        if ((forIn == null || forIn.Variable != declaration)
                            && (varDecl.Initializer == null || varDecl.Initializer.IsConstant))
                        {
                            // NOT in a for-in statement and the initializer is constant. We can delete the
                            // vardecl with the empty binding pattern from its parent and then check to see
                            // if the parent is now empty, and delete it if it is.
                            deleted = varDecl.Parent.ReplaceChild(varDecl, null);
                            if (declaration.Count == 0)
                            {
                                // the whole statement is now empty; whack it too
                                declaration.Parent.ReplaceChild(declaration, null);
                            }
                        }
                    }
                }

                if (deleted)
                {
                    var bindingIdentifier = binding as BindingIdentifier;
                    if (bindingIdentifier != null)
                    {
                        // because this is a binding parameter, the binding should be listed
                        // in the field's declarations collection. Remove it, too
                        bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);

                        // mark the field as deleted IF there are no more references
                        // or declarations
                        if (!bindingIdentifier.VariableField.IsReferenced
                            && bindingIdentifier.VariableField.Declarations.Count == 0)
                        {
                            bindingIdentifier.VariableField.WasRemoved = true;
                        }
                    }

                    // see if we also want to possibly clean up this pattern, now that we've
                    // removed something from it
                    if (normalizePattern && nodeList != null)
                    {
                        // if this nodelist is the child of an array literal, make sure we remove 
                        // any trailing elisions. 
                        if (nodeList.Parent is ArrayLiteral)
                        {
                            for (var ndx = nodeList.Count - 1; ndx >= 0; --ndx)
                            {
                                var constantWrapper = nodeList[ndx] as ConstantWrapper;
                                if (constantWrapper != null && constantWrapper.Value == Missing.Value)
                                {
                                    nodeList.RemoveAt(ndx);
                                }
                                else
                                {
                                    // no longer an elision; stop iterating
                                    break;
                                }
                            }
                        }

                        if (nodeList.Count == 0)
                        {
                            // the list is now empty!
                            // let's recursively get rid of the parent array or object literal
                            // from ITS binding pattern
                            DeleteFromBindingPattern(nodeList.Parent, normalizePattern);
                        }
                    }
                }
            }

            return deleted;
        }

        public static void RemoveBinding(AstNode binding)
        {
            // first unhook all the declarations in the binding pattern
            foreach (var boundName in BindingsVisitor.Bindings(binding))
            {
                var variableField = boundName.VariableField;
                if (variableField != null)
                {
                    variableField.Declarations.Remove(boundName);
                }
            }

            // then remove the binding from it's parent and clean up any cascade
            DeleteFromBindingPattern(binding, true);
        }

        #endregion

        #region scope setup methods

        /// <summary>
        /// Set up this scope's fields from the declarations it contains
        /// </summary>
        public abstract void DeclareScope();

        protected void DefineLexicalDeclarations()
        {
            foreach (var lexDecl in LexicallyDeclaredNames)
            {
                // use the function as the field value if its parent is a function
                // or the class node if its a class
                AstNode fieldValue = lexDecl.Parent as FunctionObject;
                if (fieldValue == null)
                {
                    fieldValue = lexDecl.Parent as ClassNode;
                }

                DefineField(lexDecl, fieldValue);
            }
        }

        protected void DefineVarDeclarations()
        {
            foreach (var varDecl in VarDeclaredNames)
            {
                // var-decls are always initialized to null
                DefineField(varDecl, null);
            }
        }

        private void DefineField(INameDeclaration nameDecl, AstNode fieldValue)
        {
            var field = this[nameDecl.Name];
            if (nameDecl.IsParameter)
            {
                // function parameters are handled separately, so if this is a parameter declaration,
                // then it must be a catch variable. 
                if (field == null)
                {
                    // no collision - create the catch-error field
                    field = new JSVariableField(FieldType.CatchError, nameDecl.Name, 0, null)
                    {
                        OriginalContext = nameDecl.Context,
                        IsDeclared = true
                    };

                    this.AddField(field);
                }
                else
                {
                    // it's an error to declare anything in the catch scope with the same name as the
                    // error variable
                    field.OriginalContext.HandleError(JSError.DuplicateCatch, true);
                }
            }
            else
            {
                if (field == null)
                {
                    // could be global or local depending on the scope, so let the scope create it.
                    field = this.CreateField(nameDecl.Name, null, 0);
                    field.OriginalContext = nameDecl.Context;
                    field.IsDeclared = true;
                    field.IsFunction = (nameDecl is FunctionObject);
                    field.FieldValue = fieldValue;

                    // if this field is a constant or an import, mark it now as initialize only.
                    // Mozilla const statements will be const => vardecl => node
                    // ES6 const statements will be lexdecl(StatementToken == JSToken.Cont) => vardecl => node
                    // imports can be import => 
                    var parentParent = nameDecl.Parent.IfNotNull(p => p.Parent);
                    LexicalDeclaration lexDeclaration;
                    field.InitializationOnly = parentParent is ConstStatement
                        || ((lexDeclaration = parentParent as LexicalDeclaration) != null && lexDeclaration.StatementToken == JSToken.Const);

                    this.AddField(field);
                }
                else
                {
                    // already defined! 
                    // if this is a lexical declaration, then it's an error because we have two
                    // lexical declarations with the same name in the same scope.
                    if (nameDecl.Parent.IfNotNull(p => p.Parent) is LexicalDeclaration)
                    {
                        nameDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, true);
                    }

                    if (nameDecl.Initializer != null)
                    {
                        // if this is an initialized declaration, then the var part is
                        // superfluous and the "initializer" is really a lookup assignment. 
                        // So bump up the ref-count for those cases.
                        var nameReference = nameDecl as INameReference;
                        if (nameReference != null)
                        {
                            field.AddReference(nameReference);
                        }
                    }

                    // don't clobber an existing field value with null. For instance, the last 
                    // function declaration is the winner, so always set the value if we have something,
                    // but a var following a function shouldn't reset it to null.
                    if (fieldValue != null)
                    {
                        field.FieldValue = fieldValue;
                    }
                }

                // if this is a field that was declared with an export statement, then we want to set the
                // IsExported flag. Stop if we get to a block, because that means we aren't in an export
                // statement.
                var parent = (AstNode)nameDecl;
                while ((parent = parent.Parent) != null && !(parent is BlockStatement))
                {
                    if (parent is ExportStatement)
                    {
                        field.IsExported = true;
                        break;
                    }
                    else if (parent is ImportStatement)
                    {
                        // import fields cannot be assigned to.
                        field.InitializationOnly = true;
                        break;
                    }
                }
            }

            nameDecl.VariableField = field;
            field.Declarations.Add(nameDecl);

            // if this scope is within a with-statement, or if the declaration was flagged
            // as not being renamable, then mark the field as not crunchable
            if (IsInWithScope || nameDecl.RenameNotAllowed)
            {
                field.CanCrunch = false;
            }
        }

        #endregion

        #region AnalyzeScope functionality

        internal virtual void AnalyzeScope()
        {
            // global scopes override this and don't call the next
            AnalyzeNonGlobalScope();

            // rename fields if we need to
            ManualRenameFields();

            // recurse 
            foreach (var activationObject in ChildScopes)
            {
                activationObject.AnalyzeScope();
            }
        }

        private void AnalyzeNonGlobalScope()
        {
            foreach (var variableField in NameTable.Values)
            {
                if (variableField.OuterField == null)
                {
                    // not referenced, not generated, and has an original context so not added after the fact.
                    // and we don't care if ghosted, catch-error fields or exports are unreferenced.
                    if (!variableField.IsReferenced
                        && !variableField.IsGenerated
                        && variableField.FieldType != FieldType.CatchError
                        && variableField.FieldType != FieldType.GhostCatch
                        && !variableField.IsExported
                        && variableField.OriginalContext != null)
                    {
                        UnreferencedVariableField(variableField);
                    }
                    else if (variableField.FieldType == FieldType.Local
                        && variableField.RefCount == 1
                        && this.IsKnownAtCompileTime
                        && Settings.RemoveUnneededCode
                        && Settings.IsModificationAllowed(TreeModifications.RemoveUnusedVariables))
                    {
                        SingleReferenceVariableField(variableField);
                    }
                }
            }
        }

        private void UnreferencedVariableField(JSVariableField variableField)
        {
            // see if the value is a function
            var functionObject = variableField.FieldValue as FunctionObject;
            if (functionObject != null)
            {
                UnreferencedFunction(variableField, functionObject);
            }
            else if (variableField.FieldType != FieldType.Argument && !variableField.WasRemoved)
            {
                UnreferencedVariable(variableField);
            }
        }

        private void UnreferencedFunction(JSVariableField variableField, FunctionObject functionObject)
        {
            // if there is no name, then ignore this declaration because it's malformed.
            // (won't be a function expression because those are automatically referenced).
            // also ignore ghosted function fields.
            if (functionObject.Binding != null && variableField.FieldType != FieldType.GhostFunction)
            {
                // if the function name isn't a simple identifier, then leave it there and mark it as
                // not renamable because it's probably one of those darn IE-extension event handlers or something.
                if (JSScanner.IsValidIdentifier(functionObject.Binding.Name))
                {
                    // unreferenced function declaration. fire a warning.
                    var ctx = functionObject.Binding.Context ?? variableField.OriginalContext;
                    ctx.HandleError(JSError.FunctionNotReferenced, false);

                    // hide it from the output if our settings say we can.
                    // we don't want to delete it, per se, because we still want it to 
                    // show up in the scope report so the user can see that it was unreachable
                    // in case they are wondering where it went.
                    // ES6 has the notion of block-scoped function declarations. ES5 says functions can't
                    // be defined inside blocks -- only at the root level of the global scope or function scopes.
                    // so if this is a block scope, don't hide the function, even if it is unreferenced because
                    // of the cross-browser difference.
                    if (this.IsKnownAtCompileTime
                        && Settings.MinifyCode
                        && Settings.RemoveUnneededCode
                        && !(this is BlockScope))
                    {
                        // REMOVE the unreferened function, don't dance around trying to "hide" it
                        //functionObject.HideFromOutput = true;
                        functionObject.Parent.IfNotNull(p => p.ReplaceChild(functionObject, null));
                    }
                }
                else
                {
                    // not a valid identifier name for this function. Don't rename it because it's
                    // malformed and we don't want to mess up the developer's intent.
                    variableField.CanCrunch = false;
                }
            }
        }

        private void UnreferencedVariable(JSVariableField variableField)
        {
            var throwWarning = true;

            // not a function, not an argument, not a catch-arg, not a global.
            // not referenced. If there's a single definition, and it either has no
            // initializer or the initializer is constant, get rid of it. 
            // (unless we aren't removing unneeded code, or the scope is unknown)
            if (variableField.Declarations.Count == 1 && this.IsKnownAtCompileTime)
            {
                BindingIdentifier bindingIdentifier;
                var nameDeclaration = variableField.OnlyDeclaration;
                var varDecl = nameDeclaration.IfNotNull(decl => decl.Parent as VariableDeclaration);
                if (varDecl != null)
                {
                    var declaration = varDecl.Parent as Declaration;
                    if (declaration != null
                        && (varDecl.Initializer == null || varDecl.Initializer.IsConstant))
                    {
                        // if the decl parent is a for-in and the decl is the variable part
                        // of the statement, then just leave it alone. Don't even throw a warning
                        var forInStatement = declaration.Parent as ForInStatement;
                        if (forInStatement != null
                            && declaration == forInStatement.Variable)
                        {
                            // just leave it alone, and don't even throw a warning for it.
                            // TODO: try to reuse some pre-existing variable, or maybe replace
                            // this vardecl with a ref to an unused parameter if this is inside
                            // a function.
                            throwWarning = false;
                        }
                        else if (Settings.RemoveUnneededCode
                            && Settings.IsModificationAllowed(TreeModifications.RemoveUnusedVariables))
                        {
                            variableField.Declarations.Remove(nameDeclaration);

                            // don't "remove" the field if it's a ghost to another field
                            if (variableField.GhostedField == null)
                            {
                                variableField.WasRemoved = true;
                            }

                            // remove the vardecl from the declaration list, and if the
                            // declaration list is now empty, remove it, too
                            declaration.Remove(varDecl);
                            if (declaration.Count == 0)
                            {
                                declaration.Parent.ReplaceChild(declaration, null);
                            }
                        }
                    }
                    else if (varDecl.Parent is ForInStatement)
                    {
                        // then this is okay
                        throwWarning = false;
                    }
                }
                else if ((bindingIdentifier = nameDeclaration as BindingIdentifier) != null)
                {
                    // try deleting the binding pattern declaration
                    DeleteFromBindingPattern(bindingIdentifier, true);
                }
            }

            if (throwWarning && variableField.HasNoReferences)
            {
                // not referenced -- throw a warning, assuming it hasn't been "removed" 
                // via an optimization or something.
                variableField.OriginalContext.HandleError(
                    JSError.VariableDefinedNotReferenced,
                    false);
            }
        }

        private static void SingleReferenceVariableField(JSVariableField variableField)
        {
            // local fields that only have one declaration
            if (variableField.Declarations.Count == 1)
            {
                // there should only be one, it should be a vardecl, and 
                // either no initializer or a constant initializer
                var nameDeclaration = variableField.OnlyDeclaration;
                var varDecl = nameDeclaration.IfNotNull(d => d.Parent as VariableDeclaration);
                if (varDecl?.Initializer != null
                    && varDecl.Initializer.IsConstant)
                {
                    // there should only be one
                    var reference = variableField.OnlyReference;
                    if (reference != null)
                    {
                        // if the reference is not being assigned to, it is not an outer reference
                        // (meaning the lookup is in the same scope as the declaration), and the
                        // lookup is after the declaration
                        if (!reference.IsAssignment
                            && reference.VariableField != null
                            && reference.VariableField.OuterField == null
                            && reference.VariableField.CanCrunch
                            && !reference.VariableField.IsExported
                            && varDecl.Index < reference.Index
                            && !IsIterativeReference(varDecl.Initializer, reference))
                        {
                            // so we have a declaration assigning a constant value, and only one
                            // reference reading that value. replace the reference with the constant
                            // and get rid of the declaration.
                            // transform: var lookup=constant;lookup   ==>   constant
                            // remove the vardecl
                            var declaration = varDecl.Parent as Declaration;
                            if (declaration != null)
                            {
                                // replace the reference with the constant
                                variableField.References.Remove(reference);
                                var refNode = reference as AstNode;
                                refNode.Parent.IfNotNull(p => p.ReplaceChild(refNode, varDecl.Initializer));

                                // we're also going to remove the declaration itself
                                variableField.Declarations.Remove(nameDeclaration);
                                variableField.WasRemoved = true;

                                // remove the vardecl from the declaration list
                                // and if the declaration is now empty, remove it, too
                                declaration.Remove(varDecl);
                                if (declaration.Count == 0)
                                {
                                    declaration.Parent.IfNotNull(p => p.ReplaceChild(declaration, null));
                                }
                            }
                        }
                    }
                }
            }
        }

        private static bool IsIterativeReference(AstNode initializer, INameReference reference)
        {
            // we only care about array and regular expressions with the global switch at this point.
            // if it's not one of those types, then go ahead and assume iterative reference doesn't matter.
            var regExp = initializer as RegExpLiteral;
            if (initializer is ArrayLiteral 
                || initializer is ObjectLiteral
                || (regExp?.PatternSwitches != null && regExp.PatternSwitches.IndexOf("g", StringComparison.OrdinalIgnoreCase) >= 0))
            {
                // get the parent block for the initializer. We'll use this as a stopping point in our loop.
                var parentBlock = GetParentBlock(initializer);

                // walk up the parent chain from the reference. If we find a while, a for, or a do-while,
                // then we know this reference is iteratively called.
                // stop when the parent is null, the same block containing the initializer, or a function object.
                // (because a function object will step out of scope, and we know we should be in the same scope)
                var child = reference as AstNode;
                var parent = child.Parent;
                while (parent != null && parent != parentBlock && !(parent is FunctionObject))
                {
                    // while or do-while is iterative -- the condition and the body are both called repeatedly.
                    if (parent is WhileStatement || parent is DoWhileStatement)
                    {
                        return true;
                    }

                    // for-statements call the condition, the incrementer, and the body repeatedly, but not the
                    // initializer.
                    var forNode = parent as ForStatement;
                    if (forNode != null && child != forNode.Initializer)
                    {
                        return true;
                    }

                    // in forin-statements, only the body is repeated, the collection is evaluated only once.
                    var forInStatement = parent as ForInStatement;
                    if (forInStatement != null && child == forInStatement.Body)
                    {
                        return true;
                    }

                    // go up
                    child = parent;
                    parent = parent.Parent;
                }
            }

            return false;
        }

        /// <summary>
        /// Return the first Block node in the tree starting from the given node and working up through the parent nodes.
        /// </summary>
        /// <param name="node">initial node</param>
        /// <returns>first block node in the node tree</returns>
        private static BlockStatement GetParentBlock(AstNode node)
        {
            while(node != null)
            {
                // see if the current node is a block, and if so, return it.
                var block = node as BlockStatement;
                if (block != null)
                {
                    return block;
                }

                // try the parent
                node = node.Parent;
            }

            // if we get here, we never found a parent block.
            return null;
        }

        protected void ManualRenameFields()
        {
            // if the local-renaming kill switch is on, we won't be renaming ANYTHING, so we'll have nothing to do.
            if (Settings.IsModificationAllowed(TreeModifications.LocalRenaming))
            {
                // if the parser settings has a list of rename pairs, we will want to go through and rename
                // any matches
                if (Settings.HasRenamePairs)
                {
                    // go through the list of fields in this scope. Anything defined in the script that
                    // is in the parser rename map should be renamed and the auto-rename flag reset so
                    // we don't change it later.
                    foreach (var varField in NameTable.Values)
                    {
                        // don't rename outer fields (only actual fields), 
                        // and we're only concerned with global or local variables --
                        // those which are defined by the script (not predefined, not the arguments object)
                        if (varField.OuterField == null 
                            && (varField.FieldType != FieldType.Arguments && varField.FieldType != FieldType.Predefined))
                        {
                            // see if the name is in the parser's rename map
                            string newName = Settings.GetNewName(varField.Name);
                            if (!string.IsNullOrEmpty(newName))
                            {
                                // it is! Change the name of the field, but make sure we reset the CanCrunch flag
                                // or setting the "crunched" name won't work.
                                // and don't bother making sure the name doesn't collide with anything else that
                                // already exists -- if it does, that's the developer's fault.
                                // TODO: should we at least throw a warning?
                                varField.CanCrunch = true;
                                varField.CrunchedName = newName;

                                // and make sure we don't crunch it later
                                varField.CanCrunch = false;
                            }
                        }
                    }
                }

                // if the parser settings has a list of no-rename names, then we will want to also mark any
                // fields that match and are still slated to rename as uncrunchable so they won't get renamed.
                // if the settings say we're not going to renaming anything automatically (KeepAll), then we 
                // have nothing to do.
                if (Settings.LocalRenaming != LocalRenaming.KeepAll)
                {
                    foreach (var noRename in Settings.NoAutoRenameCollection)
                    {
                        // don't rename outer fields (only actual fields), 
                        // and we're only concerned with fields that can still
                        // be automatically renamed. If the field is all that AND is listed in
                        // the collection, set the CanCrunch to false
                        JSVariableField varField;
                        if (NameTable.TryGetValue(noRename, out varField)
                            && varField.OuterField == null
                            && varField.CanCrunch)
                        {
                            // no, we don't want to crunch this field
                            varField.CanCrunch = false;
                        }
                    }
                }
            }
        }

        #endregion

        #region crunching methods

        internal void ValidateGeneratedNames()
        {
            // check all the variables defined within this scope.
            // we're looking for uncrunched generated fields.
            foreach (JSVariableField variableField in NameTable.Values)
            {
                if (variableField.IsGenerated
                    && variableField.CrunchedName == null)
                {
                    // we need to rename this field.
                    // first we need to walk all the child scopes depth-first
                    // looking for references to this field. Once we find a reference,
                    // we then need to add all the other variables referenced in those
                    // scopes and all above them (from here) so we know what names we
                    // can't use.
                    var avoidTable = new HashSet<string>();
                    GenerateAvoidList(avoidTable, variableField.Name);

                    // now that we have our avoid list, create a crunch enumerator from it
                    CrunchEnumerator crunchEnum = new CrunchEnumerator(avoidTable);

                    // and use it to generate a new name
                    variableField.CrunchedName = crunchEnum.NextName();
                }
            }

            // recursively traverse through our children
            foreach (ActivationObject scope in ChildScopes)
            {
                if (!scope.Existing)
                {
                    scope.ValidateGeneratedNames();
                }
            }
        }

        private bool GenerateAvoidList(HashSet<string> table, string name)
        {
            // our reference flag is based on what was passed to us
            bool isReferenced = false;

            // depth first, so walk all the children
            foreach (ActivationObject childScope in ChildScopes)
            {
                // if any child returns true, then it or one of its descendents
                // reference this variable. So we reference it, too
                if (childScope.GenerateAvoidList(table, name))
                {
                    // we'll return true because we reference it
                    isReferenced = true;
                }
            }

            if (!isReferenced)
            {
                // none of our children reference the scope, so see if we do
                isReferenced = NameTable.ContainsKey(name);
            }

            if (isReferenced)
            {
                // if we reference the name or are in line to reference the name,
                // we need to add all the variables we reference to the list
                foreach (var variableField in NameTable.Values)
                {
                    table.Add(variableField.ToString());
                }
            }

            // return whether or not we are in the reference chain
            return isReferenced;
        }

        internal virtual void AutoRenameFields()
        {
            // if we're not known at compile time, then we can't crunch
            // the local variables in this scope, because we can't know if
            // something will reference any of it at runtime.
            // eval is something that will make the scope unknown because we
            // don't know what eval will evaluate to until runtime
            if (m_isKnownAtCompileTime)
            {
                // get an array of all the uncrunched local variables defined in this scope
                var localFields = GetUncrunchedLocals();
                if (localFields != null)
                {
                    // create a crunch-name enumerator, taking into account any fields within our
                    // scope that have already been crunched.
                    var avoidSet = new HashSet<string>();
                    foreach (var field in NameTable.Values)
                    {
                        // if the field can't be crunched, or if it can but we've already crunched it,
                        // or if it's an outer variable (that hasn't been generated) and its OWNING scope isn't known 
                        // (and therefore we CANNOT crunch it),
                        // then add it to the avoid list so we don't reuse that name
                        if (!field.CanCrunch || field.CrunchedName != null
                            || (field.OuterField != null && !field.IsGenerated && field.OwningScope != null && !field.OwningScope.IsKnownAtCompileTime))
                        {
                            avoidSet.Add(field.ToString());
                        }
                    }

                    var crunchEnum = new CrunchEnumerator(avoidSet);
                    foreach (var localField in localFields)
                    {
                        // if we are an unambiguous reference to a named function expression and we are not
                        // referenced by anyone else, then we can just skip this variable because the
                        // name will be stripped from the output anyway.
                        // we also always want to crunch "placeholder" fields.
                        if (localField.CanCrunch
                            && (localField.RefCount > 0 || localField.IsDeclared || localField.IsPlaceholder
                            || !(Settings.RemoveFunctionExpressionNames && Settings.IsModificationAllowed(TreeModifications.RemoveFunctionExpressionNames))))
                        {
                            localField.CrunchedName = crunchEnum.NextName();

                            if (localField.Declarations.FirstOrDefault()?.Parent?.Parent?.Parent is ForInStatement forInStatement &&
                                forInStatement.Collection is MemberExpression memberExpression &&
                                memberExpression.Root is INameReference nameReference &&
                                localField.CrunchedName == (nameReference.VariableField.CrunchedName ?? nameReference.VariableField.Name))
                            {
                                localField.CrunchedName = crunchEnum.NextName();
                            }
                        }
                    }
                }
            }

            // then traverse through our children
            foreach (ActivationObject scope in ChildScopes)
            {
                scope.AutoRenameFields();
            }
        }

        internal IEnumerable<JSVariableField> GetUncrunchedLocals()
        {
            // there can't be more uncrunched fields than total fields
            var list = new List<JSVariableField>(NameTable.Count);
            foreach (var variableField in NameTable.Values)
            {
                // if the field is defined in this scope and hasn't been crunched
                // AND can still be crunched AND wasn't removed during the optimization process
                if (variableField != null && variableField.OuterField == null && variableField.CrunchedName == null
                    && variableField.CanCrunch && !variableField.WasRemoved)
                {
                    // if local renaming is not crunch all, then it must be crunch all but localization
                    // (we don't get called if we aren't crunching anything). 
                    // SO for the first clause:
                    // IF we are crunch all, we're good; but if we aren't crunch all, then we're only good if
                    //    the name doesn't start with "L_".
                    // The second clause is only computed IF we already think we're good to go.
                    // IF we aren't preserving function names, then we're good. BUT if we are, we're
                    // only good to go if this field doesn't represent a function object.
                    if ((Settings.LocalRenaming == LocalRenaming.CrunchAll
                        || !variableField.Name.StartsWith("L_", StringComparison.Ordinal))
                        && !(Settings.PreserveFunctionNames && variableField.IsFunction))
                    {
                        list.Add(variableField);
                    }
                }
            }

            if (list.Count == 0)
            {
                return null;
            }

            // sort the array and return it
            list.Sort(ReferenceComparer.Instance);
            return list;
        }

        #endregion

        #region field-management methods

        public virtual JSVariableField this[string name]
        {
            get
            {
                JSVariableField variableField;
                // check to see if this name is already defined in this scope
                if (!NameTable.TryGetValue(name, out variableField))
                {
                    // not in this scope
                    variableField = null;
                }
                return variableField;
            }
        }

        /// <summary>
        /// See if the given name will resolve to a field; do not create any inner fields
        /// or unknown global fields along the way.
        /// </summary>
        /// <param name="name">name to resolve</param>
        /// <returns>an existing resolved field, or null if nothing exists</returns>
        public JSVariableField CanReference(string name)
        {
            // check for this scope.
            var variableField = this[name];

            // if we didn't find anything, go up the chain until we find something.
            if (variableField == null)
            {
                var parentScope = this.Parent;
                while (parentScope != null && variableField == null)
                {
                    variableField = parentScope[name];
                    parentScope = parentScope.Parent;
                }
            }

            return variableField;
        }

        /// <summary>
        /// Resolve the name in this scope, or go up the chain adding inner fields
        /// along the way until the final reference is found, creating an unknown global
        /// field if necessary.
        /// </summary>
        /// <param name="name">name to resolve</param>
        /// <returns>resolved variable field (should never be null)</returns>
        public JSVariableField FindReference(string name)
        {
            // see if we have it
            var variableField = this[name];

            // if we didn't find anything and this scope has a parent
            if (variableField == null && name != null)
            {
                // if this is the super reference and we have one....
                if (string.CompareOrdinal(name, "super") == 0 && this.HasSuperBinding)
                {
                    variableField = new JSVariableField(FieldType.Super, name, 0, null);
                    NameTable.Add(name, variableField);
                }
                else if (this.Parent != null)
                {
                    // recursively go up the scope chain to find a reference,
                    // then create an inner field to point to it and we'll return
                    // that one.
                    variableField = CreateInnerField(this.Parent.FindReference(name));

                    // mark it as a placeholder. we might be going down a chain of scopes,
                    // where we will want to reserve the variable name, but not actually reference it.
                    // at the end where it is actually referenced we will reset the flag.
                    variableField.IsPlaceholder = true;
                }
                else
                {
                    // must be global scope. the field is undefined!
                    variableField = AddField(new JSVariableField(FieldType.UndefinedGlobal, name, 0, null));
                }
            }

            return variableField;
        }

        public virtual JSVariableField DeclareField(string name, object value, FieldAttributes attributes)
        {
            JSVariableField variableField;
            if (!NameTable.TryGetValue(name, out variableField))
            {
                variableField = CreateField(name, value, attributes);
                AddField(variableField);
            }
            return variableField;
        }

        public virtual JSVariableField CreateField(JSVariableField outerField)
        {
            // use the same type as the outer field by default
            return outerField.IfNotNull(o => new JSVariableField(o.FieldType, o));
        }

        public abstract JSVariableField CreateField(string name, object value, FieldAttributes attributes);

        public virtual JSVariableField CreateInnerField(JSVariableField outerField)
        {
            JSVariableField innerField = null;
            if (outerField != null)
            {
                // create a new inner field to be added to our scope
                innerField = CreateField(outerField);
                AddField(innerField);
            }

            return innerField;
        }

        internal JSVariableField AddField(JSVariableField variableField)
        {
            // add it to our name table 
            NameTable[variableField.Name] = variableField;

            // set the owning scope to this is we are the outer field, or the outer field's
            // owning scope if this is an inner field
            variableField.OwningScope = variableField.OuterField == null ? this : variableField.OuterField.OwningScope;
            return variableField;
        }

        public INameDeclaration VarDeclaredName(string name)
        {
            // check each var-decl name from inside this scope
            foreach (var varDecl in this.VarDeclaredNames)
            {
                // if the name matches, return the field
                if (string.CompareOrdinal(varDecl.Name, name) == 0)
                {
                    return varDecl;
                }
            }

            // if we get here, we didn't find a match
            return null;
        }

        public INameDeclaration LexicallyDeclaredName(string name)
        {
            // check each var-decl name from inside this scope
            foreach (var lexDecl in this.LexicallyDeclaredNames)
            {
                // if the name matches, return the field
                if (string.CompareOrdinal(lexDecl.Name, name) == 0)
                {
                    return lexDecl;
                }
            }

            // if we get here, we didn't find a match
            return null;
        }

        public void AddGlobal(string name)
        {
            // first, go up to the global scope
            var scope = this;
            while (scope.Parent != null)
            {
                scope = scope.Parent;
            }

            // now see if there is a field with that name already; 
            // will return a non-null field object if there is.
            var field = scope[name];
            if (field == null)
            {
                // nothing with this name. Add it as a global field
                scope.AddField(scope.CreateField(name, null, 0));
            }
        }

        #endregion
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ActivationObject.cs(178,41): error CS8370: Feature 'type pattern' is not available in C# 7.3. Please use language version 9.0 or greater.
######################################################################


######################################################################
Nr: 13 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ActivationObject.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using NUglify.Helpers;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public abstract class ActivationObject
    {
        #region private fields

        private bool m_useStrict;//= false;
        private bool m_isKnownAtCompileTime;

        #endregion

        #region internal properties

        /// <summary>
        /// Gets or sets a boolean value for whether this is an existing scope or a new one
        /// generated during the current run.
        /// </summary>
        internal bool Existing { get; set; }

        #endregion

        #region public properties

        public AstNode Owner { get; set; }

        public bool HasSuperBinding { get; set; }

        public bool UseStrict
        {
            get
            {
                return m_useStrict;
            }
            set
            {
                // can set it to true, but can't set it to false
                if (value)
                {
                    // set our value
                    m_useStrict = value;

                    // and all our child scopes (recursive)
                    foreach (var child in ChildScopes)
                    {
                        child.UseStrict = value;
                    }
                }
            }
        }

        public bool IsKnownAtCompileTime
        {
            get { return m_isKnownAtCompileTime; }
            set 
            { 
                m_isKnownAtCompileTime = value;
                if (!value && Settings.EvalTreatment == EvalTreatment.MakeAllSafe)
                {
                    // are we a function scope?
                    var functionObject = this.Owner as FunctionObject;
                    if (functionObject == null)
                    {
                        // we are not a function, so the parent scope is unknown too
                        if (Parent != null)
                        {
                            Parent.IsKnownAtCompileTime = false;
                        }
                    }
                    else
                    {
                        // we are a function, check to see if the function object is actually
                        // referenced. (we don't want to mark the parent as unknown if this function 
                        // isn't even referenced).
                        if (functionObject.IsReferenced)
                        {
                            Parent.IsKnownAtCompileTime = false;
                        }
                    }
                }
            }
        }

        public ActivationObject Parent { get; private set; }
        public bool IsInWithScope { get; set; }

        public IDictionary<string, JSVariableField> NameTable { get; private set; }

        public IList<ActivationObject> ChildScopes { get; private set; }

        public ICollection<LookupExpression> ScopeLookups { get; private set; }
        public ICollection<INameDeclaration> VarDeclaredNames { get; private set; }
        public ICollection<INameDeclaration> LexicallyDeclaredNames { get; private set; }

        public ICollection<BindingIdentifier> GhostedCatchParameters { get; private set; }
        public ICollection<FunctionObject> GhostedFunctions { get; private set; }

        public string ScopeName { get; set; }
        public ScopeType ScopeType { get; protected set; }

        #endregion

        #region protected properties

        protected CodeSettings Settings { get; private set; }

        #endregion

        protected ActivationObject(ActivationObject parent, CodeSettings codeSettings)
        {
            m_isKnownAtCompileTime = true;
            m_useStrict = false;
            Settings = codeSettings;

            Parent = parent;
            NameTable = new Dictionary<string, JSVariableField>();
            ChildScopes = new List<ActivationObject>();

            // if our parent is a scope....
            if (parent != null)
            {
                // add us to the parent's list of child scopes
                parent.ChildScopes.Add(this);

                // if the parent is strict, so are we
                UseStrict = parent.UseStrict;
            }

            // create the two lists of declared items for this scope
            ScopeLookups = new HashSet<LookupExpression>();
            VarDeclaredNames = new HashSet<INameDeclaration>();
            LexicallyDeclaredNames = new HashSet<INameDeclaration>();

            GhostedCatchParameters = new HashSet<BindingIdentifier>();
            GhostedFunctions = new HashSet<FunctionObject>();
        }

        #region public static methods

        /// <summary>
        /// Delete a binding from its parent pattern
        /// </summary>
        /// <param name="binding">binding to delete</param>
        /// <param name="normalizePattern">true to normalize the parent pattern and possibly delete it if now empty</param>
        /// <returns>true if deleted, otherwise false</returns>
        public static bool DeleteFromBindingPattern(AstNode binding, bool normalizePattern)
        {
            var deleted = false;
            if (binding != null)
            {
                // the parent might be an node list under an array literal, or
                // or a property under an object literal 
                ObjectLiteralProperty property = null;
                VariableDeclaration varDecl;
                var nodeList = binding.Parent as AstNodeList;
                if (nodeList != null && nodeList.Parent is ArrayLiteral)
                {
                    // name under an array literal so if this is the LAST element, we can delete it,
                    // otherwise we have to replace it with a missing constant
                    deleted = nodeList.ReplaceChild(
                        binding,
                        new ConstantWrapper(Missing.Value, PrimitiveType.Other, binding.Context.Clone()));
                }
                else if ((property = binding.Parent as ObjectLiteralProperty) != null)
                {
                    // delete the property from the list of properties after saving the list of properties for later
                    nodeList = property.Parent as AstNodeList;
                    deleted = property.Parent.ReplaceChild(property, null);
                }
                else if ((varDecl = binding.Parent as VariableDeclaration) != null)
                {
                    // we're at the top -- the empty binding we are deleting is defined within a vardecl.
                    // IF the declaration is not the variable of a for-in statement, and
                    // IF there are other vardecls in the var, and
                    // IF the initializer is null or constant, 
                    // THEN we can delete it. Otherwise we need to leave the empty pattern.
                    var declaration = varDecl.Parent as Declaration;
                    if (declaration != null)
                    {
                        var forIn = declaration.Parent as ForInStatement;
                        if ((forIn == null || forIn.Variable != declaration)
                            && (varDecl.Initializer == null || varDecl.Initializer.IsConstant))
                        {
                            // NOT in a for-in statement and the initializer is constant. We can delete the
                            // vardecl with the empty binding pattern from its parent and then check to see
                            // if the parent is now empty, and delete it if it is.
                            deleted = varDecl.Parent.ReplaceChild(varDecl, null);
                            if (declaration.Count == 0)
                            {
                                // the whole statement is now empty; whack it too
                                declaration.Parent.ReplaceChild(declaration, null);
                            }
                        }
                    }
                }

                if (deleted)
                {
                    var bindingIdentifier = binding as BindingIdentifier;
                    if (bindingIdentifier != null)
                    {
                        // because this is a binding parameter, the binding should be listed
                        // in the field's declarations collection. Remove it, too
                        bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);

                        // mark the field as deleted IF there are no more references
                        // or declarations
                        if (!bindingIdentifier.VariableField.IsReferenced
                            && bindingIdentifier.VariableField.Declarations.Count == 0)
                        {
                            bindingIdentifier.VariableField.WasRemoved = true;
                        }
                    }

                    // see if we also want to possibly clean up this pattern, now that we've
                    // removed something from it
                    if (normalizePattern && nodeList != null)
                    {
                        // if this nodelist is the child of an array literal, make sure we remove 
                        // any trailing elisions. 
                        if (nodeList.Parent is ArrayLiteral)
                        {
                            for (var ndx = nodeList.Count - 1; ndx >= 0; --ndx)
                            {
                                var constantWrapper = nodeList[ndx] as ConstantWrapper;
                                if (constantWrapper != null && constantWrapper.Value == Missing.Value)
                                {
                                    nodeList.RemoveAt(ndx);
                                }
                                else
                                {
                                    // no longer an elision; stop iterating
                                    break;
                                }
                            }
                        }

                        if (nodeList.Count == 0)
                        {
                            // the list is now empty!
                            // let's recursively get rid of the parent array or object literal
                            // from ITS binding pattern
                            DeleteFromBindingPattern(nodeList.Parent, normalizePattern);
                        }
                    }
                }
            }

            return deleted;
        }

        public static void RemoveBinding(AstNode binding)
        {
            // first unhook all the declarations in the binding pattern
            foreach (var boundName in BindingsVisitor.Bindings(binding))
            {
                var variableField = boundName.VariableField;
                if (variableField != null)
                {
                    variableField.Declarations.Remove(boundName);
                }
            }

            // then remove the binding from it's parent and clean up any cascade
            DeleteFromBindingPattern(binding, true);
        }

        #endregion

        #region scope setup methods

        /// <summary>
        /// Set up this scope's fields from the declarations it contains
        /// </summary>
        public abstract void DeclareScope();

        protected void DefineLexicalDeclarations()
        {
            foreach (var lexDecl in LexicallyDeclaredNames)
            {
                // use the function as the field value if its parent is a function
                // or the class node if its a class
                AstNode fieldValue = lexDecl.Parent as FunctionObject;
                if (fieldValue == null)
                {
                    fieldValue = lexDecl.Parent as ClassNode;
                }

                DefineField(lexDecl, fieldValue);
            }
        }

        protected void DefineVarDeclarations()
        {
            foreach (var varDecl in VarDeclaredNames)
            {
                // var-decls are always initialized to null
                DefineField(varDecl, null);
            }
        }

        private void DefineField(INameDeclaration nameDecl, AstNode fieldValue)
        {
            var field = this[nameDecl.Name];
            if (nameDecl.IsParameter)
            {
                // function parameters are handled separately, so if this is a parameter declaration,
                // then it must be a catch variable. 
                if (field == null)
                {
                    // no collision - create the catch-error field
                    field = new JSVariableField(FieldType.CatchError, nameDecl.Name, 0, null)
                    {
                        OriginalContext = nameDecl.Context,
                        IsDeclared = true
                    };

                    this.AddField(field);
                }
                else
                {
                    // it's an error to declare anything in the catch scope with the same name as the
                    // error variable
                    field.OriginalContext.HandleError(JSError.DuplicateCatch, true);
                }
            }
            else
            {
                if (field == null)
                {
                    // could be global or local depending on the scope, so let the scope create it.
                    field = this.CreateField(nameDecl.Name, null, 0);
                    field.OriginalContext = nameDecl.Context;
                    field.IsDeclared = true;
                    field.IsFunction = (nameDecl is FunctionObject);
                    field.FieldValue = fieldValue;

                    // if this field is a constant or an import, mark it now as initialize only.
                    // Mozilla const statements will be const => vardecl => node
                    // ES6 const statements will be lexdecl(StatementToken == JSToken.Cont) => vardecl => node
                    // imports can be import => 
                    var parentParent = nameDecl.Parent.IfNotNull(p => p.Parent);
                    LexicalDeclaration lexDeclaration;
                    field.InitializationOnly = parentParent is ConstStatement
                        || ((lexDeclaration = parentParent as LexicalDeclaration) != null && lexDeclaration.StatementToken == JSToken.Const);

                    this.AddField(field);
                }
                else
                {
                    // already defined! 
                    // if this is a lexical declaration, then it's an error because we have two
                    // lexical declarations with the same name in the same scope.
                    if (nameDecl.Parent.IfNotNull(p => p.Parent) is LexicalDeclaration)
                    {
                        nameDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, true);
                    }

                    if (nameDecl.Initializer != null)
                    {
                        // if this is an initialized declaration, then the var part is
                        // superfluous and the "initializer" is really a lookup assignment. 
                        // So bump up the ref-count for those cases.
                        var nameReference = nameDecl as INameReference;
                        if (nameReference != null)
                        {
                            field.AddReference(nameReference);
                        }
                    }

                    // don't clobber an existing field value with null. For instance, the last 
                    // function declaration is the winner, so always set the value if we have something,
                    // but a var following a function shouldn't reset it to null.
                    if (fieldValue != null)
                    {
                        field.FieldValue = fieldValue;
                    }
                }

                // if this is a field that was declared with an export statement, then we want to set the
                // IsExported flag. Stop if we get to a block, because that means we aren't in an export
                // statement.
                var parent = (AstNode)nameDecl;
                while ((parent = parent.Parent) != null && !(parent is BlockStatement))
                {
                    if (parent is ExportStatement)
                    {
                        field.IsExported = true;
                        break;
                    }
                    else if (parent is ImportStatement)
                    {
                        // import fields cannot be assigned to.
                        field.InitializationOnly = true;
                        break;
                    }
                }
            }

            nameDecl.VariableField = field;
            field.Declarations.Add(nameDecl);

            // if this scope is within a with-statement, or if the declaration was flagged
            // as not being renamable, then mark the field as not crunchable
            if (IsInWithScope || nameDecl.RenameNotAllowed)
            {
                field.CanCrunch = false;
            }
        }

        #endregion

        #region AnalyzeScope functionality

        internal virtual void AnalyzeScope()
        {
            // global scopes override this and don't call the next
            AnalyzeNonGlobalScope();

            // rename fields if we need to
            ManualRenameFields();

            // recurse 
            foreach (var activationObject in ChildScopes)
            {
                activationObject.AnalyzeScope();
            }
        }

        private void AnalyzeNonGlobalScope()
        {
            foreach (var variableField in NameTable.Values)
            {
                if (variableField.OuterField == null)
                {
                    // not referenced, not generated, and has an original context so not added after the fact.
                    // and we don't care if ghosted, catch-error fields or exports are unreferenced.
                    if (!variableField.IsReferenced
                        && !variableField.IsGenerated
                        && variableField.FieldType != FieldType.CatchError
                        && variableField.FieldType != FieldType.GhostCatch
                        && !variableField.IsExported
                        && variableField.OriginalContext != null)
                    {
                        UnreferencedVariableField(variableField);
                    }
                    else if (variableField.FieldType == FieldType.Local
                        && variableField.RefCount == 1
                        && this.IsKnownAtCompileTime
                        && Settings.RemoveUnneededCode
                        && Settings.IsModificationAllowed(TreeModifications.RemoveUnusedVariables))
                    {
                        SingleReferenceVariableField(variableField);
                    }
                }
            }
        }

        private void UnreferencedVariableField(JSVariableField variableField)
        {
            // see if the value is a function
            var functionObject = variableField.FieldValue as FunctionObject;
            if (functionObject != null)
            {
                UnreferencedFunction(variableField, functionObject);
            }
            else if (variableField.FieldType != FieldType.Argument && !variableField.WasRemoved)
            {
                UnreferencedVariable(variableField);
            }
        }

        private void UnreferencedFunction(JSVariableField variableField, FunctionObject functionObject)
        {
            // if there is no name, then ignore this declaration because it's malformed.
            // (won't be a function expression because those are automatically referenced).
            // also ignore ghosted function fields.
            if (functionObject.Binding != null && variableField.FieldType != FieldType.GhostFunction)
            {
                // if the function name isn't a simple identifier, then leave it there and mark it as
                // not renamable because it's probably one of those darn IE-extension event handlers or something.
                if (JSScanner.IsValidIdentifier(functionObject.Binding.Name))
                {
                    // unreferenced function declaration. fire a warning.
                    var ctx = functionObject.Binding.Context ?? variableField.OriginalContext;
                    ctx.HandleError(JSError.FunctionNotReferenced, false);

                    // hide it from the output if our settings say we can.
                    // we don't want to delete it, per se, because we still want it to 
                    // show up in the scope report so the user can see that it was unreachable
                    // in case they are wondering where it went.
                    // ES6 has the notion of block-scoped function declarations. ES5 says functions can't
                    // be defined inside blocks -- only at the root level of the global scope or function scopes.
                    // so if this is a block scope, don't hide the function, even if it is unreferenced because
                    // of the cross-browser difference.
                    if (this.IsKnownAtCompileTime
                        && Settings.MinifyCode
                        && Settings.RemoveUnneededCode
                        && !(this is BlockScope))
                    {
                        // REMOVE the unreferened function, don't dance around trying to "hide" it
                        //functionObject.HideFromOutput = true;
                        functionObject.Parent.IfNotNull(p => p.ReplaceChild(functionObject, null));
                    }
                }
                else
                {
                    // not a valid identifier name for this function. Don't rename it because it's
                    // malformed and we don't want to mess up the developer's intent.
                    variableField.CanCrunch = false;
                }
            }
        }

        private void UnreferencedVariable(JSVariableField variableField)
        {
            var throwWarning = true;

            // not a function, not an argument, not a catch-arg, not a global.
            // not referenced. If there's a single definition, and it either has no
            // initializer or the initializer is constant, get rid of it. 
            // (unless we aren't removing unneeded code, or the scope is unknown)
            if (variableField.Declarations.Count == 1 && this.IsKnownAtCompileTime)
            {
                BindingIdentifier bindingIdentifier;
                var nameDeclaration = variableField.OnlyDeclaration;
                var varDecl = nameDeclaration.IfNotNull(decl => decl.Parent as VariableDeclaration);
                if (varDecl != null)
                {
                    var declaration = varDecl.Parent as Declaration;
                    if (declaration != null
                        && (varDecl.Initializer == null || varDecl.Initializer.IsConstant))
                    {
                        // if the decl parent is a for-in and the decl is the variable part
                        // of the statement, then just leave it alone. Don't even throw a warning
                        var forInStatement = declaration.Parent as ForInStatement;
                        if (forInStatement != null
                            && declaration == forInStatement.Variable)
                        {
                            // just leave it alone, and don't even throw a warning for it.
                            // TODO: try to reuse some pre-existing variable, or maybe replace
                            // this vardecl with a ref to an unused parameter if this is inside
                            // a function.
                            throwWarning = false;
                        }
                        else if (Settings.RemoveUnneededCode
                            && Settings.IsModificationAllowed(TreeModifications.RemoveUnusedVariables))
                        {
                            variableField.Declarations.Remove(nameDeclaration);

                            // don't "remove" the field if it's a ghost to another field
                            if (variableField.GhostedField == null)
                            {
                                variableField.WasRemoved = true;
                            }

                            // remove the vardecl from the declaration list, and if the
                            // declaration list is now empty, remove it, too
                            declaration.Remove(varDecl);
                            if (declaration.Count == 0)
                            {
                                declaration.Parent.ReplaceChild(declaration, null);
                            }
                        }
                    }
                    else if (varDecl.Parent is ForInStatement)
                    {
                        // then this is okay
                        throwWarning = false;
                    }
                }
                else if ((bindingIdentifier = nameDeclaration as BindingIdentifier) != null)
                {
                    // try deleting the binding pattern declaration
                    DeleteFromBindingPattern(bindingIdentifier, true);
                }
            }

            if (throwWarning && variableField.HasNoReferences)
            {
                // not referenced -- throw a warning, assuming it hasn't been "removed" 
                // via an optimization or something.
                variableField.OriginalContext.HandleError(
                    JSError.VariableDefinedNotReferenced,
                    false);
            }
        }

        private static void SingleReferenceVariableField(JSVariableField variableField)
        {
            // local fields that only have one declaration
            if (variableField.Declarations.Count == 1)
            {
                // there should only be one, it should be a vardecl, and 
                // either no initializer or a constant initializer
                var nameDeclaration = variableField.OnlyDeclaration;
                var varDecl = nameDeclaration.IfNotNull(d => d.Parent as VariableDeclaration);
                if (varDecl != null
                    && varDecl.Initializer != null
                    && varDecl.Initializer.IsConstant)
                {
                    // there should only be one
                    var reference = variableField.OnlyReference;
                    if (reference != null)
                    {
                        // if the reference is not being assigned to, it is not an outer reference
                        // (meaning the lookup is in the same scope as the declaration), and the
                        // lookup is after the declaration
                        if (!reference.IsAssignment
                            && reference.VariableField != null
                            && reference.VariableField.OuterField == null
                            && reference.VariableField.CanCrunch
                            && !reference.VariableField.IsExported
                            && varDecl.Index < reference.Index
                            && !IsIterativeReference(varDecl.Initializer, reference))
                        {
                            // so we have a declaration assigning a constant value, and only one
                            // reference reading that value. replace the reference with the constant
                            // and get rid of the declaration.
                            // transform: var lookup=constant;lookup   ==>   constant
                            // remove the vardecl
                            var declaration = varDecl.Parent as Declaration;
                            if (declaration != null)
                            {
                                // replace the reference with the constant
                                variableField.References.Remove(reference);
                                var refNode = reference as AstNode;
                                refNode.Parent.IfNotNull(p => p.ReplaceChild(refNode, varDecl.Initializer));

                                // we're also going to remove the declaration itself
                                variableField.Declarations.Remove(nameDeclaration);
                                variableField.WasRemoved = true;

                                // remove the vardecl from the declaration list
                                // and if the declaration is now empty, remove it, too
                                declaration.Remove(varDecl);
                                if (declaration.Count == 0)
                                {
                                    declaration.Parent.IfNotNull(p => p.ReplaceChild(declaration, null));
                                }
                            }
                        }
                    }
                }
            }
        }

        private static bool IsIterativeReference(AstNode initializer, INameReference reference)
        {
            // we only care about array and regular expressions with the global switch at this point.
            // if it's not one of those types, then go ahead and assume iterative reference doesn't matter.
            var regExp = initializer as RegExpLiteral;
            if (initializer is ArrayLiteral 
                || initializer is ObjectLiteral
                || (regExp != null && regExp.PatternSwitches != null && regExp.PatternSwitches.IndexOf("g", StringComparison.OrdinalIgnoreCase) >= 0))
            {
                // get the parent block for the initializer. We'll use this as a stopping point in our loop.
                var parentBlock = GetParentBlock(initializer);

                // walk up the parent chain from the reference. If we find a while, a for, or a do-while,
                // then we know this reference is iteratively called.
                // stop when the parent is null, the same block containing the initializer, or a function object.
                // (because a function object will step out of scope, and we know we should be in the same scope)
                var child = reference as AstNode;
                var parent = child.Parent;
                while (parent != null && parent != parentBlock && !(parent is FunctionObject))
                {
                    // while or do-while is iterative -- the condition and the body are both called repeatedly.
                    if (parent is WhileStatement || parent is DoWhileStatement)
                    {
                        return true;
                    }

                    // for-statements call the condition, the incrementer, and the body repeatedly, but not the
                    // initializer.
                    var forNode = parent as ForStatement;
                    if (forNode != null && child != forNode.Initializer)
                    {
                        return true;
                    }

                    // in forin-statements, only the body is repeated, the collection is evaluated only once.
                    var forInStatement = parent as ForInStatement;
                    if (forInStatement != null && child == forInStatement.Body)
                    {
                        return true;
                    }

                    // go up
                    child = parent;
                    parent = parent.Parent;
                }
            }

            return false;
        }

        /// <summary>
        /// Return the first Block node in the tree starting from the given node and working up through the parent nodes.
        /// </summary>
        /// <param name="node">initial node</param>
        /// <returns>first block node in the node tree</returns>
        private static BlockStatement GetParentBlock(AstNode node)
        {
            while(node != null)
            {
                // see if the current node is a block, and if so, return it.
                var block = node as BlockStatement;
                if (block != null)
                {
                    return block;
                }

                // try the parent
                node = node.Parent;
            }

            // if we get here, we never found a parent block.
            return null;
        }

        protected void ManualRenameFields()
        {
            // if the local-renaming kill switch is on, we won't be renaming ANYTHING, so we'll have nothing to do.
            if (Settings.IsModificationAllowed(TreeModifications.LocalRenaming))
            {
                // if the parser settings has a list of rename pairs, we will want to go through and rename
                // any matches
                if (Settings.HasRenamePairs)
                {
                    // go through the list of fields in this scope. Anything defined in the script that
                    // is in the parser rename map should be renamed and the auto-rename flag reset so
                    // we don't change it later.
                    foreach (var varField in NameTable.Values)
                    {
                        // don't rename outer fields (only actual fields), 
                        // and we're only concerned with global or local variables --
                        // those which are defined by the script (not predefined, not the arguments object)
                        if (varField.OuterField == null 
                            && (varField.FieldType != FieldType.Arguments && varField.FieldType != FieldType.Predefined))
                        {
                            // see if the name is in the parser's rename map
                            string newName = Settings.GetNewName(varField.Name);
                            if (!string.IsNullOrEmpty(newName))
                            {
                                // it is! Change the name of the field, but make sure we reset the CanCrunch flag
                                // or setting the "crunched" name won't work.
                                // and don't bother making sure the name doesn't collide with anything else that
                                // already exists -- if it does, that's the developer's fault.
                                // TODO: should we at least throw a warning?
                                varField.CanCrunch = true;
                                varField.CrunchedName = newName;

                                // and make sure we don't crunch it later
                                varField.CanCrunch = false;
                            }
                        }
                    }
                }

                // if the parser settings has a list of no-rename names, then we will want to also mark any
                // fields that match and are still slated to rename as uncrunchable so they won't get renamed.
                // if the settings say we're not going to renaming anything automatically (KeepAll), then we 
                // have nothing to do.
                if (Settings.LocalRenaming != LocalRenaming.KeepAll)
                {
                    foreach (var noRename in Settings.NoAutoRenameCollection)
                    {
                        // don't rename outer fields (only actual fields), 
                        // and we're only concerned with fields that can still
                        // be automatically renamed. If the field is all that AND is listed in
                        // the collection, set the CanCrunch to false
                        JSVariableField varField;
                        if (NameTable.TryGetValue(noRename, out varField)
                            && varField.OuterField == null
                            && varField.CanCrunch)
                        {
                            // no, we don't want to crunch this field
                            varField.CanCrunch = false;
                        }
                    }
                }
            }
        }

        #endregion

        #region crunching methods

        internal void ValidateGeneratedNames()
        {
            // check all the variables defined within this scope.
            // we're looking for uncrunched generated fields.
            foreach (JSVariableField variableField in NameTable.Values)
            {
                if (variableField.IsGenerated
                    && variableField.CrunchedName == null)
                {
                    // we need to rename this field.
                    // first we need to walk all the child scopes depth-first
                    // looking for references to this field. Once we find a reference,
                    // we then need to add all the other variables referenced in those
                    // scopes and all above them (from here) so we know what names we
                    // can't use.
                    var avoidTable = new HashSet<string>();
                    GenerateAvoidList(avoidTable, variableField.Name);

                    // now that we have our avoid list, create a crunch enumerator from it
                    CrunchEnumerator crunchEnum = new CrunchEnumerator(avoidTable);

                    // and use it to generate a new name
                    variableField.CrunchedName = crunchEnum.NextName();
                }
            }

            // recursively traverse through our children
            foreach (ActivationObject scope in ChildScopes)
            {
                if (!scope.Existing)
                {
                    scope.ValidateGeneratedNames();
                }
            }
        }

        private bool GenerateAvoidList(HashSet<string> table, string name)
        {
            // our reference flag is based on what was passed to us
            bool isReferenced = false;

            // depth first, so walk all the children
            foreach (ActivationObject childScope in ChildScopes)
            {
                // if any child returns true, then it or one of its descendents
                // reference this variable. So we reference it, too
                if (childScope.GenerateAvoidList(table, name))
                {
                    // we'll return true because we reference it
                    isReferenced = true;
                }
            }

            if (!isReferenced)
            {
                // none of our children reference the scope, so see if we do
                isReferenced = NameTable.ContainsKey(name);
            }

            if (isReferenced)
            {
                // if we reference the name or are in line to reference the name,
                // we need to add all the variables we reference to the list
                foreach (var variableField in NameTable.Values)
                {
                    table.Add(variableField.ToString());
                }
            }

            // return whether or not we are in the reference chain
            return isReferenced;
        }

        internal virtual void AutoRenameFields()
        {
            // if we're not known at compile time, then we can't crunch
            // the local variables in this scope, because we can't know if
            // something will reference any of it at runtime.
            // eval is something that will make the scope unknown because we
            // don't know what eval will evaluate to until runtime
            if (m_isKnownAtCompileTime)
            {
                // get an array of all the uncrunched local variables defined in this scope
                var localFields = GetUncrunchedLocals();
                if (localFields != null)
                {
                    // create a crunch-name enumerator, taking into account any fields within our
                    // scope that have already been crunched.
                    var avoidSet = new HashSet<string>();
                    foreach (var field in NameTable.Values)
                    {
                        // if the field can't be crunched, or if it can but we've already crunched it,
                        // or if it's an outer variable (that hasn't been generated) and its OWNING scope isn't known 
                        // (and therefore we CANNOT crunch it),
                        // then add it to the avoid list so we don't reuse that name
                        if (!field.CanCrunch || field.CrunchedName != null
                            || (field.OuterField != null && !field.IsGenerated && field.OwningScope != null && !field.OwningScope.IsKnownAtCompileTime))
                        {
                            avoidSet.Add(field.ToString());
                        }
                    }

                    var crunchEnum = new CrunchEnumerator(avoidSet);
                    foreach (var localField in localFields)
                    {
                        // if we are an unambiguous reference to a named function expression and we are not
                        // referenced by anyone else, then we can just skip this variable because the
                        // name will be stripped from the output anyway.
                        // we also always want to crunch "placeholder" fields.
                        if (localField.CanCrunch
                            && (localField.RefCount > 0 || localField.IsDeclared || localField.IsPlaceholder
                            || !(Settings.RemoveFunctionExpressionNames && Settings.IsModificationAllowed(TreeModifications.RemoveFunctionExpressionNames))))
                        {
                            localField.CrunchedName = crunchEnum.NextName();

                            if (localField.Declarations.FirstOrDefault()?.Parent?.Parent?.Parent is ForInStatement forInStatement &&
                                forInStatement.Collection is MemberExpression memberExpression &&
                                memberExpression.Root is INameReference nameReference &&
                                localField.CrunchedName == (nameReference.VariableField.CrunchedName ?? nameReference.VariableField.Name))
                            {
                                localField.CrunchedName = crunchEnum.NextName();
                            }
                        }
                    }
                }
            }

            // then traverse through our children
            foreach (ActivationObject scope in ChildScopes)
            {
                scope.AutoRenameFields();
            }
        }

        internal IEnumerable<JSVariableField> GetUncrunchedLocals()
        {
            // there can't be more uncrunched fields than total fields
            var list = new List<JSVariableField>(NameTable.Count);
            foreach (var variableField in NameTable.Values)
            {
                // if the field is defined in this scope and hasn't been crunched
                // AND can still be crunched AND wasn't removed during the optimization process
                if (variableField != null && variableField.OuterField == null && variableField.CrunchedName == null
                    && variableField.CanCrunch && !variableField.WasRemoved)
                {
                    // if local renaming is not crunch all, then it must be crunch all but localization
                    // (we don't get called if we aren't crunching anything). 
                    // SO for the first clause:
                    // IF we are crunch all, we're good; but if we aren't crunch all, then we're only good if
                    //    the name doesn't start with "L_".
                    // The second clause is only computed IF we already think we're good to go.
                    // IF we aren't preserving function names, then we're good. BUT if we are, we're
                    // only good to go if this field doesn't represent a function object.
                    if ((Settings.LocalRenaming == LocalRenaming.CrunchAll
                        || !variableField.Name.StartsWith("L_", StringComparison.Ordinal))
                        && !(Settings.PreserveFunctionNames && variableField.IsFunction))
                    {
                        list.Add(variableField);
                    }
                }
            }

            if (list.Count == 0)
            {
                return null;
            }

            // sort the array and return it
            list.Sort(ReferenceComparer.Instance);
            return list;
        }

        #endregion

        #region field-management methods

        public virtual JSVariableField this[string name]
        {
            get
            {
                JSVariableField variableField;
                // check to see if this name is already defined in this scope
                if (!NameTable.TryGetValue(name, out variableField))
                {
                    // not in this scope
                    variableField = null;
                }
                return variableField;
            }
        }

        /// <summary>
        /// See if the given name will resolve to a field; do not create any inner fields
        /// or unknown global fields along the way.
        /// </summary>
        /// <param name="name">name to resolve</param>
        /// <returns>an existing resolved field, or null if nothing exists</returns>
        public JSVariableField CanReference(string name)
        {
            // check for this scope.
            var variableField = this[name];

            // if we didn't find anything, go up the chain until we find something.
            if (variableField == null)
            {
                var parentScope = this.Parent;
                while (parentScope != null && variableField == null)
                {
                    variableField = parentScope[name];
                    parentScope = parentScope.Parent;
                }
            }

            return variableField;
        }

        /// <summary>
        /// Resolve the name in this scope, or go up the chain adding inner fields
        /// along the way until the final reference is found, creating an unknown global
        /// field if necessary.
        /// </summary>
        /// <param name="name">name to resolve</param>
        /// <returns>resolved variable field (should never be null)</returns>
        public JSVariableField FindReference(string name)
        {
            // see if we have it
            var variableField = this[name];

            // if we didn't find anything and this scope has a parent
            if (variableField == null && name != null)
            {
                // if this is the super reference and we have one....
                if (string.CompareOrdinal(name, "super") == 0 && this.HasSuperBinding)
                {
                    variableField = new JSVariableField(FieldType.Super, name, 0, null);
                    NameTable.Add(name, variableField);
                }
                else if (this.Parent != null)
                {
                    // recursively go up the scope chain to find a reference,
                    // then create an inner field to point to it and we'll return
                    // that one.
                    variableField = CreateInnerField(this.Parent.FindReference(name));

                    // mark it as a placeholder. we might be going down a chain of scopes,
                    // where we will want to reserve the variable name, but not actually reference it.
                    // at the end where it is actually referenced we will reset the flag.
                    variableField.IsPlaceholder = true;
                }
                else
                {
                    // must be global scope. the field is undefined!
                    variableField = AddField(new JSVariableField(FieldType.UndefinedGlobal, name, 0, null));
                }
            }

            return variableField;
        }

        public virtual JSVariableField DeclareField(string name, object value, FieldAttributes attributes)
        {
            JSVariableField variableField;
            if (!NameTable.TryGetValue(name, out variableField))
            {
                variableField = CreateField(name, value, attributes);
                AddField(variableField);
            }
            return variableField;
        }

        public virtual JSVariableField CreateField(JSVariableField outerField)
        {
            // use the same type as the outer field by default
            return outerField.IfNotNull(o => new JSVariableField(o.FieldType, o));
        }

        public abstract JSVariableField CreateField(string name, object value, FieldAttributes attributes);

        public virtual JSVariableField CreateInnerField(JSVariableField outerField)
        {
            JSVariableField innerField = null;
            if (outerField != null)
            {
                // create a new inner field to be added to our scope
                innerField = CreateField(outerField);
                AddField(innerField);
            }

            return innerField;
        }

        internal JSVariableField AddField(JSVariableField variableField)
        {
            // add it to our name table 
            NameTable[variableField.Name] = variableField;

            // set the owning scope to this is we are the outer field, or the outer field's
            // owning scope if this is an inner field
            variableField.OwningScope = variableField.OuterField == null ? this : variableField.OuterField.OwningScope;
            return variableField;
        }

        public INameDeclaration VarDeclaredName(string name)
        {
            // check each var-decl name from inside this scope
            foreach (var varDecl in this.VarDeclaredNames)
            {
                // if the name matches, return the field
                if (string.CompareOrdinal(varDecl.Name, name) == 0)
                {
                    return varDecl;
                }
            }

            // if we get here, we didn't find a match
            return null;
        }

        public INameDeclaration LexicallyDeclaredName(string name)
        {
            // check each var-decl name from inside this scope
            foreach (var lexDecl in this.LexicallyDeclaredNames)
            {
                // if the name matches, return the field
                if (string.CompareOrdinal(lexDecl.Name, name) == 0)
                {
                    return lexDecl;
                }
            }

            // if we get here, we didn't find a match
            return null;
        }

        public void AddGlobal(string name)
        {
            // first, go up to the global scope
            var scope = this;
            while (scope.Parent != null)
            {
                scope = scope.Parent;
            }

            // now see if there is a field with that name already; 
            // will return a non-null field object if there is.
            var field = scope[name];
            if (field == null)
            {
                // nothing with this name. Add it as a global field
                scope.AddField(scope.CreateField(name, null, 0));
            }
        }

        #endregion
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using NUglify.Helpers;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public abstract class ActivationObject
    {
        #region private fields

        private bool m_useStrict;//= false;
        private bool m_isKnownAtCompileTime;

        #endregion

        #region internal properties

        /// <summary>
        /// Gets or sets a boolean value for whether this is an existing scope or a new one
        /// generated during the current run.
        /// </summary>
        internal bool Existing { get; set; }

        #endregion

        #region public properties

        public AstNode Owner { get; set; }

        public bool HasSuperBinding { get; set; }

        public bool UseStrict
        {
            get
            {
                return m_useStrict;
            }
            set
            {
                // can set it to true, but can't set it to false
                if (value)
                {
                    // set our value
                    m_useStrict = value;

                    // and all our child scopes (recursive)
                    foreach (var child in ChildScopes)
                    {
                        child.UseStrict = value;
                    }
                }
            }
        }

        public bool IsKnownAtCompileTime
        {
            get { return m_isKnownAtCompileTime; }
            set 
            { 
                m_isKnownAtCompileTime = value;
                if (!value && Settings.EvalTreatment == EvalTreatment.MakeAllSafe)
                {
                    // are we a function scope?
                    var functionObject = this.Owner as FunctionObject;
                    if (functionObject == null)
                    {
                        // we are not a function, so the parent scope is unknown too
                        if (Parent != null)
                        {
                            Parent.IsKnownAtCompileTime = false;
                        }
                    }
                    else
                    {
                        // we are a function, check to see if the function object is actually
                        // referenced. (we don't want to mark the parent as unknown if this function 
                        // isn't even referenced).
                        if (functionObject.IsReferenced)
                        {
                            Parent.IsKnownAtCompileTime = false;
                        }
                    }
                }
            }
        }

        public ActivationObject Parent { get; private set; }
        public bool IsInWithScope { get; set; }

        public IDictionary<string, JSVariableField> NameTable { get; private set; }

        public IList<ActivationObject> ChildScopes { get; private set; }

        public ICollection<LookupExpression> ScopeLookups { get; private set; }
        public ICollection<INameDeclaration> VarDeclaredNames { get; private set; }
        public ICollection<INameDeclaration> LexicallyDeclaredNames { get; private set; }

        public ICollection<BindingIdentifier> GhostedCatchParameters { get; private set; }
        public ICollection<FunctionObject> GhostedFunctions { get; private set; }

        public string ScopeName { get; set; }
        public ScopeType ScopeType { get; protected set; }

        #endregion

        #region protected properties

        protected CodeSettings Settings { get; private set; }

        #endregion

        protected ActivationObject(ActivationObject parent, CodeSettings codeSettings)
        {
            m_isKnownAtCompileTime = true;
            m_useStrict = false;
            Settings = codeSettings;

            Parent = parent;
            NameTable = new Dictionary<string, JSVariableField>();
            ChildScopes = new List<ActivationObject>();

            // if our parent is a scope....
            if (parent != null)
            {
                // add us to the parent's list of child scopes
                parent.ChildScopes.Add(this);

                // if the parent is strict, so are we
                UseStrict = parent.UseStrict;
            }

            // create the two lists of declared items for this scope
            ScopeLookups = new HashSet<LookupExpression>();
            VarDeclaredNames = new HashSet<INameDeclaration>();
            LexicallyDeclaredNames = new HashSet<INameDeclaration>();

            GhostedCatchParameters = new HashSet<BindingIdentifier>();
            GhostedFunctions = new HashSet<FunctionObject>();
        }

        #region public static methods

        /// <summary>
        /// Delete a binding from its parent pattern
        /// </summary>
        /// <param name="binding">binding to delete</param>
        /// <param name="normalizePattern">true to normalize the parent pattern and possibly delete it if now empty</param>
        /// <returns>true if deleted, otherwise false</returns>
        public static bool DeleteFromBindingPattern(AstNode binding, bool normalizePattern)
        {
            var deleted = false;
            if (binding != null)
            {
                // the parent might be an node list under an array literal, or
                // or a property under an object literal 
                ObjectLiteralProperty property = null;
                VariableDeclaration varDecl;

                if (binding.Parent is AstNodeList nodeList && nodeList.Parent is ArrayLiteral)
                {
                    // name under an array literal so if this is the LAST element, we can delete it,
                    // otherwise we have to replace it with a missing constant
                    deleted = nodeList.ReplaceChild(
                        binding,
                        new ConstantWrapper(Missing.Value, PrimitiveType.Other, binding.Context.Clone()));
                }
                else if ((property = binding.Parent as ObjectLiteralProperty) != null)
                {
                    // delete the property from the list of properties after saving the list of properties for later
                    nodeList = property.Parent as AstNodeList;
                    deleted = property.Parent.ReplaceChild(property, null);
                }
                else if ((varDecl = binding.Parent as VariableDeclaration) != null)
                {
                    // we're at the top -- the empty binding we are deleting is defined within a vardecl.                    // IF the declaration is not the variable of a for-in statement, and                    // IF there are other vardecls in the var, and                    // IF the initializer is null or constant,                     // THEN we can delete it. Otherwise we need to leave the empty pattern.
                    if (varDecl.Parent is Declaration declaration)
                    {
                        var forIn = declaration.Parent as ForInStatement;
                        if ((forIn == null || forIn.Variable != declaration)
                            && (varDecl.Initializer == null || varDecl.Initializer.IsConstant))
                        {
                            // NOT in a for-in statement and the initializer is constant. We can delete the
                            // vardecl with the empty binding pattern from its parent and then check to see
                            // if the parent is now empty, and delete it if it is.
                            deleted = varDecl.Parent.ReplaceChild(varDecl, null);
                            if (declaration.Count == 0)
                            {
                                // the whole statement is now empty; whack it too
                                declaration.Parent.ReplaceChild(declaration, null);
                            }
                        }
                    }
                }

                if (deleted)
                {
                    if (binding is BindingIdentifier bindingIdentifier)
                    {
                        // because this is a binding parameter, the binding should be listed
                        // in the field's declarations collection. Remove it, too
                        bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);

                        // mark the field as deleted IF there are no more references
                        // or declarations
                        if (!bindingIdentifier.VariableField.IsReferenced
                            && bindingIdentifier.VariableField.Declarations.Count == 0)
                        {
                            bindingIdentifier.VariableField.WasRemoved = true;
                        }
                    }

                    // see if we also want to possibly clean up this pattern, now that we've
                    // removed something from it
                    if (normalizePattern && binding.Parent is AstNodeList nodeList)
                    {
                        // if this nodelist is the child of an array literal, make sure we remove 
                        // any trailing elisions. 
                        if (nodeList.Parent is ArrayLiteral)
                        {
                            for (var ndx = nodeList.Count - 1; ndx >= 0; --ndx)
                            {
                                if (nodeList[ndx] is ConstantWrapper constantWrapper && constantWrapper.Value == Missing.Value)
                                {
                                    nodeList.RemoveAt(ndx);
                                }
                                else
                                {
                                    // no longer an elision; stop iterating
                                    break;
                                }
                            }
                        }

                        if (nodeList.Count == 0)
                        {
                            // the list is now empty!
                            // let's recursively get rid of the parent array or object literal
                            // from ITS binding pattern
                            DeleteFromBindingPattern(nodeList.Parent, normalizePattern);
                        }
                    }
                }
            }

            return deleted;
        }

        public static void RemoveBinding(AstNode binding)
        {
            // first unhook all the declarations in the binding pattern
            foreach (var boundName in BindingsVisitor.Bindings(binding))
            {
                var variableField = boundName.VariableField;
                if (variableField != null)
                {
                    variableField.Declarations.Remove(boundName);
                }
            }

            // then remove the binding from it's parent and clean up any cascade
            DeleteFromBindingPattern(binding, true);
        }

        #endregion

        #region scope setup methods

        /// <summary>
        /// Set up this scope's fields from the declarations it contains
        /// </summary>
        public abstract void DeclareScope();

        protected void DefineLexicalDeclarations()
        {
            foreach (var lexDecl in LexicallyDeclaredNames)
            {
                // use the function as the field value if its parent is a function
                // or the class node if its a class
                AstNode fieldValue = lexDecl.Parent as FunctionObject;
                if (fieldValue == null)
                {
                    fieldValue = lexDecl.Parent as ClassNode;
                }

                DefineField(lexDecl, fieldValue);
            }
        }

        protected void DefineVarDeclarations()
        {
            foreach (var varDecl in VarDeclaredNames)
            {
                // var-decls are always initialized to null
                DefineField(varDecl, null);
            }
        }

        private void DefineField(INameDeclaration nameDecl, AstNode fieldValue)
        {
            var field = this[nameDecl.Name];
            if (nameDecl.IsParameter)
            {
                // function parameters are handled separately, so if this is a parameter declaration,
                // then it must be a catch variable. 
                if (field == null)
                {
                    // no collision - create the catch-error field
                    field = new JSVariableField(FieldType.CatchError, nameDecl.Name, 0, null)
                    {
                        OriginalContext = nameDecl.Context,
                        IsDeclared = true
                    };

                    this.AddField(field);
                }
                else
                {
                    // it's an error to declare anything in the catch scope with the same name as the
                    // error variable
                    field.OriginalContext.HandleError(JSError.DuplicateCatch, true);
                }
            }
            else
            {
                if (field == null)
                {
                    // could be global or local depending on the scope, so let the scope create it.
                    field = this.CreateField(nameDecl.Name, null, 0);
                    field.OriginalContext = nameDecl.Context;
                    field.IsDeclared = true;
                    field.IsFunction = (nameDecl is FunctionObject);
                    field.FieldValue = fieldValue;

                    // if this field is a constant or an import, mark it now as initialize only.
                    // Mozilla const statements will be const => vardecl => node
                    // ES6 const statements will be lexdecl(StatementToken == JSToken.Cont) => vardecl => node
                    // imports can be import => 
                    var parentParent = nameDecl.Parent.IfNotNull(p => p.Parent);
                    LexicalDeclaration lexDeclaration;
                    field.InitializationOnly = parentParent is ConstStatement
                        || ((lexDeclaration = parentParent as LexicalDeclaration) != null && lexDeclaration.StatementToken == JSToken.Const);

                    this.AddField(field);
                }
                else
                {
                    // already defined! 
                    // if this is a lexical declaration, then it's an error because we have two
                    // lexical declarations with the same name in the same scope.
                    if (nameDecl.Parent.IfNotNull(p => p.Parent) is LexicalDeclaration)
                    {
                        nameDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, true);
                    }

                    if (nameDecl.Initializer != null)
                    {
                        // if this is an initialized declaration, then the var part is                        // superfluous and the "initializer" is really a lookup assignment.                         // So bump up the ref-count for those cases.
                        if (nameDecl is INameReference nameReference)
                        {
                            field.AddReference(nameReference);
                        }
                    }

                    // don't clobber an existing field value with null. For instance, the last 
                    // function declaration is the winner, so always set the value if we have something,
                    // but a var following a function shouldn't reset it to null.
                    if (fieldValue != null)
                    {
                        field.FieldValue = fieldValue;
                    }
                }

                // if this is a field that was declared with an export statement, then we want to set the
                // IsExported flag. Stop if we get to a block, because that means we aren't in an export
                // statement.
                var parent = (AstNode)nameDecl;
                while ((parent = parent.Parent) != null && !(parent is BlockStatement))
                {
                    if (parent is ExportStatement)
                    {
                        field.IsExported = true;
                        break;
                    }
                    else if (parent is ImportStatement)
                    {
                        // import fields cannot be assigned to.
                        field.InitializationOnly = true;
                        break;
                    }
                }
            }

            nameDecl.VariableField = field;
            field.Declarations.Add(nameDecl);

            // if this scope is within a with-statement, or if the declaration was flagged
            // as not being renamable, then mark the field as not crunchable
            if (IsInWithScope || nameDecl.RenameNotAllowed)
            {
                field.CanCrunch = false;
            }
        }

        #endregion

        #region AnalyzeScope functionality

        internal virtual void AnalyzeScope()
        {
            // global scopes override this and don't call the next
            AnalyzeNonGlobalScope();

            // rename fields if we need to
            ManualRenameFields();

            // recurse 
            foreach (var activationObject in ChildScopes)
            {
                activationObject.AnalyzeScope();
            }
        }

        private void AnalyzeNonGlobalScope()
        {
            foreach (var variableField in NameTable.Values)
            {
                if (variableField.OuterField == null)
                {
                    // not referenced, not generated, and has an original context so not added after the fact.
                    // and we don't care if ghosted, catch-error fields or exports are unreferenced.
                    if (!variableField.IsReferenced
                        && !variableField.IsGenerated
                        && variableField.FieldType != FieldType.CatchError
                        && variableField.FieldType != FieldType.GhostCatch
                        && !variableField.IsExported
                        && variableField.OriginalContext != null)
                    {
                        UnreferencedVariableField(variableField);
                    }
                    else if (variableField.FieldType == FieldType.Local
                        && variableField.RefCount == 1
                        && this.IsKnownAtCompileTime
                        && Settings.RemoveUnneededCode
                        && Settings.IsModificationAllowed(TreeModifications.RemoveUnusedVariables))
                    {
                        SingleReferenceVariableField(variableField);
                    }
                }
            }
        }

        private void UnreferencedVariableField(JSVariableField variableField)
        {
            // see if the value is a function
            if (variableField.FieldValue is FunctionObject functionObject)
            {
                UnreferencedFunction(variableField, functionObject);
            }
            else if (variableField.FieldType != FieldType.Argument && !variableField.WasRemoved)
            {
                UnreferencedVariable(variableField);
            }
        }

        private void UnreferencedFunction(JSVariableField variableField, FunctionObject functionObject)
        {
            // if there is no name, then ignore this declaration because it's malformed.
            // (won't be a function expression because those are automatically referenced).
            // also ignore ghosted function fields.
            if (functionObject.Binding != null && variableField.FieldType != FieldType.GhostFunction)
            {
                // if the function name isn't a simple identifier, then leave it there and mark it as
                // not renamable because it's probably one of those darn IE-extension event handlers or something.
                if (JSScanner.IsValidIdentifier(functionObject.Binding.Name))
                {
                    // unreferenced function declaration. fire a warning.
                    var ctx = functionObject.Binding.Context ?? variableField.OriginalContext;
                    ctx.HandleError(JSError.FunctionNotReferenced, false);

                    // hide it from the output if our settings say we can.
                    // we don't want to delete it, per se, because we still want it to 
                    // show up in the scope report so the user can see that it was unreachable
                    // in case they are wondering where it went.
                    // ES6 has the notion of block-scoped function declarations. ES5 says functions can't
                    // be defined inside blocks -- only at the root level of the global scope or function scopes.
                    // so if this is a block scope, don't hide the function, even if it is unreferenced because
                    // of the cross-browser difference.
                    if (this.IsKnownAtCompileTime
                        && Settings.MinifyCode
                        && Settings.RemoveUnneededCode
                        && !(this is BlockScope))
                    {
                        // REMOVE the unreferened function, don't dance around trying to "hide" it
                        //functionObject.HideFromOutput = true;
                        functionObject.Parent.IfNotNull(p => p.ReplaceChild(functionObject, null));
                    }
                }
                else
                {
                    // not a valid identifier name for this function. Don't rename it because it's
                    // malformed and we don't want to mess up the developer's intent.
                    variableField.CanCrunch = false;
                }
            }
        }

        private void UnreferencedVariable(JSVariableField variableField)
        {
            var throwWarning = true;

            // not a function, not an argument, not a catch-arg, not a global.
            // not referenced. If there's a single definition, and it either has no
            // initializer or the initializer is constant, get rid of it. 
            // (unless we aren't removing unneeded code, or the scope is unknown)
            if (variableField.Declarations.Count == 1 && this.IsKnownAtCompileTime)
            {
                BindingIdentifier bindingIdentifier;
                var nameDeclaration = variableField.OnlyDeclaration;
                var varDecl = nameDeclaration.IfNotNull(decl => decl.Parent as VariableDeclaration);
                if (varDecl != null)
                {
                    if (varDecl.Parent is Declaration declaration
                        && (varDecl.Initializer == null || varDecl.Initializer.IsConstant))
                    {
                        // if the decl parent is a for-in and the decl is the variable part                        // of the statement, then just leave it alone. Don't even throw a warning
                        if (declaration.Parent is ForInStatement forInStatement
                            && declaration == forInStatement.Variable)
                        {
                            // just leave it alone, and don't even throw a warning for it.
                            // TODO: try to reuse some pre-existing variable, or maybe replace
                            // this vardecl with a ref to an unused parameter if this is inside
                            // a function.
                            throwWarning = false;
                        }
                        else if (Settings.RemoveUnneededCode
                            && Settings.IsModificationAllowed(TreeModifications.RemoveUnusedVariables))
                        {
                            variableField.Declarations.Remove(nameDeclaration);

                            // don't "remove" the field if it's a ghost to another field
                            if (variableField.GhostedField == null)
                            {
                                variableField.WasRemoved = true;
                            }

                            // remove the vardecl from the declaration list, and if the
                            // declaration list is now empty, remove it, too
                            declaration.Remove(varDecl);
                            if (declaration.Count == 0)
                            {
                                declaration.Parent.ReplaceChild(declaration, null);
                            }
                        }
                    }
                    else if (varDecl.Parent is ForInStatement)
                    {
                        // then this is okay
                        throwWarning = false;
                    }
                }
                else if ((bindingIdentifier = nameDeclaration as BindingIdentifier) != null)
                {
                    // try deleting the binding pattern declaration
                    DeleteFromBindingPattern(bindingIdentifier, true);
                }
            }

            if (throwWarning && variableField.HasNoReferences)
            {
                // not referenced -- throw a warning, assuming it hasn't been "removed" 
                // via an optimization or something.
                variableField.OriginalContext.HandleError(
                    JSError.VariableDefinedNotReferenced,
                    false);
            }
        }

        private static void SingleReferenceVariableField(JSVariableField variableField)
        {
            // local fields that only have one declaration
            if (variableField.Declarations.Count == 1)
            {
                // there should only be one, it should be a vardecl, and 
                // either no initializer or a constant initializer
                var nameDeclaration = variableField.OnlyDeclaration;
                var varDecl = nameDeclaration.IfNotNull(d => d.Parent as VariableDeclaration);
                if (varDecl != null
                    && varDecl.Initializer != null
                    && varDecl.Initializer.IsConstant)
                {
                    // there should only be one
                    var reference = variableField.OnlyReference;
                    if (reference != null)
                    {
                        // if the reference is not being assigned to, it is not an outer reference
                        // (meaning the lookup is in the same scope as the declaration), and the
                        // lookup is after the declaration
                        if (!reference.IsAssignment
                            && reference.VariableField != null
                            && reference.VariableField.OuterField == null
                            && reference.VariableField.CanCrunch
                            && !reference.VariableField.IsExported
                            && varDecl.Index < reference.Index
                            && !IsIterativeReference(varDecl.Initializer, reference))
                        {
                            // so we have a declaration assigning a constant value, and only one                            // reference reading that value. replace the reference with the constant                            // and get rid of the declaration.                            // transform: var lookup=constant;lookup   ==>   constant                            // remove the vardecl
                            if (varDecl.Parent is Declaration declaration)
                            {
                                // replace the reference with the constant
                                variableField.References.Remove(reference);
                                var refNode = reference as AstNode;
                                refNode.Parent.IfNotNull(p => p.ReplaceChild(refNode, varDecl.Initializer));

                                // we're also going to remove the declaration itself
                                variableField.Declarations.Remove(nameDeclaration);
                                variableField.WasRemoved = true;

                                // remove the vardecl from the declaration list
                                // and if the declaration is now empty, remove it, too
                                declaration.Remove(varDecl);
                                if (declaration.Count == 0)
                                {
                                    declaration.Parent.IfNotNull(p => p.ReplaceChild(declaration, null));
                                }
                            }
                        }
                    }
                }
            }
        }

        private static bool IsIterativeReference(AstNode initializer, INameReference reference)
        {
            // we only care about array and regular expressions with the global switch at this point.            // if it's not one of those types, then go ahead and assume iterative reference doesn't matter.
            if (initializer is ArrayLiteral 
                || initializer is ObjectLiteral
                || (initializer is RegExpLiteral regExp && regExp.PatternSwitches != null && regExp.PatternSwitches.IndexOf("g", StringComparison.OrdinalIgnoreCase) >= 0))
            {
                // get the parent block for the initializer. We'll use this as a stopping point in our loop.
                var parentBlock = GetParentBlock(initializer);

                // walk up the parent chain from the reference. If we find a while, a for, or a do-while,
                // then we know this reference is iteratively called.
                // stop when the parent is null, the same block containing the initializer, or a function object.
                // (because a function object will step out of scope, and we know we should be in the same scope)
                var child = reference as AstNode;
                var parent = child.Parent;
                while (parent != null && parent != parentBlock && !(parent is FunctionObject))
                {
                    // while or do-while is iterative -- the condition and the body are both called repeatedly.
                    if (parent is WhileStatement || parent is DoWhileStatement)
                    {
                        return true;
                    }

                    // for-statements call the condition, the incrementer, and the body repeatedly, but not the                    // initializer.
                    if (parent is ForStatement forNode && child != forNode.Initializer)
                    {
                        return true;
                    }

                    // in forin-statements, only the body is repeated, the collection is evaluated only once.
                    if (parent is ForInStatement forInStatement && child == forInStatement.Body)
                    {
                        return true;
                    }

                    // go up
                    child = parent;
                    parent = parent.Parent;
                }
            }

            return false;
        }

        /// <summary>
        /// Return the first Block node in the tree starting from the given node and working up through the parent nodes.
        /// </summary>
        /// <param name="node">initial node</param>
        /// <returns>first block node in the node tree</returns>
        private static BlockStatement GetParentBlock(AstNode node)
        {
            while(node != null)
            {
                // see if the current node is a block, and if so, return it.
                if (node is BlockStatement block)
                {
                    return block;
                }

                // try the parent
                node = node.Parent;
            }

            // if we get here, we never found a parent block.
            return null;
        }

        protected void ManualRenameFields()
        {
            // if the local-renaming kill switch is on, we won't be renaming ANYTHING, so we'll have nothing to do.
            if (Settings.IsModificationAllowed(TreeModifications.LocalRenaming))
            {
                // if the parser settings has a list of rename pairs, we will want to go through and rename
                // any matches
                if (Settings.HasRenamePairs)
                {
                    // go through the list of fields in this scope. Anything defined in the script that
                    // is in the parser rename map should be renamed and the auto-rename flag reset so
                    // we don't change it later.
                    foreach (var varField in NameTable.Values)
                    {
                        // don't rename outer fields (only actual fields), 
                        // and we're only concerned with global or local variables --
                        // those which are defined by the script (not predefined, not the arguments object)
                        if (varField.OuterField == null 
                            && (varField.FieldType != FieldType.Arguments && varField.FieldType != FieldType.Predefined))
                        {
                            // see if the name is in the parser's rename map
                            string newName = Settings.GetNewName(varField.Name);
                            if (!string.IsNullOrEmpty(newName))
                            {
                                // it is! Change the name of the field, but make sure we reset the CanCrunch flag
                                // or setting the "crunched" name won't work.
                                // and don't bother making sure the name doesn't collide with anything else that
                                // already exists -- if it does, that's the developer's fault.
                                // TODO: should we at least throw a warning?
                                varField.CanCrunch = true;
                                varField.CrunchedName = newName;

                                // and make sure we don't crunch it later
                                varField.CanCrunch = false;
                            }
                        }
                    }
                }

                // if the parser settings has a list of no-rename names, then we will want to also mark any
                // fields that match and are still slated to rename as uncrunchable so they won't get renamed.
                // if the settings say we're not going to renaming anything automatically (KeepAll), then we 
                // have nothing to do.
                if (Settings.LocalRenaming != LocalRenaming.KeepAll)
                {
                    foreach (var noRename in Settings.NoAutoRenameCollection)
                    {
                        // don't rename outer fields (only actual fields), 
                        // and we're only concerned with fields that can still
                        // be automatically renamed. If the field is all that AND is listed in
                        // the collection, set the CanCrunch to false
                        JSVariableField varField;
                        if (NameTable.TryGetValue(noRename, out varField)
                            && varField.OuterField == null
                            && varField.CanCrunch)
                        {
                            // no, we don't want to crunch this field
                            varField.CanCrunch = false;
                        }
                    }
                }
            }
        }

        #endregion

        #region crunching methods

        internal void ValidateGeneratedNames()
        {
            // check all the variables defined within this scope.
            // we're looking for uncrunched generated fields.
            foreach (JSVariableField variableField in NameTable.Values)
            {
                if (variableField.IsGenerated
                    && variableField.CrunchedName == null)
                {
                    // we need to rename this field.
                    // first we need to walk all the child scopes depth-first
                    // looking for references to this field. Once we find a reference,
                    // we then need to add all the other variables referenced in those
                    // scopes and all above them (from here) so we know what names we
                    // can't use.
                    var avoidTable = new HashSet<string>();
                    GenerateAvoidList(avoidTable, variableField.Name);

                    // now that we have our avoid list, create a crunch enumerator from it
                    CrunchEnumerator crunchEnum = new CrunchEnumerator(avoidTable);

                    // and use it to generate a new name
                    variableField.CrunchedName = crunchEnum.NextName();
                }
            }

            // recursively traverse through our children
            foreach (ActivationObject scope in ChildScopes)
            {
                if (!scope.Existing)
                {
                    scope.ValidateGeneratedNames();
                }
            }
        }

        private bool GenerateAvoidList(HashSet<string> table, string name)
        {
            // our reference flag is based on what was passed to us
            bool isReferenced = false;

            // depth first, so walk all the children
            foreach (ActivationObject childScope in ChildScopes)
            {
                // if any child returns true, then it or one of its descendents
                // reference this variable. So we reference it, too
                if (childScope.GenerateAvoidList(table, name))
                {
                    // we'll return true because we reference it
                    isReferenced = true;
                }
            }

            if (!isReferenced)
            {
                // none of our children reference the scope, so see if we do
                isReferenced = NameTable.ContainsKey(name);
            }

            if (isReferenced)
            {
                // if we reference the name or are in line to reference the name,
                // we need to add all the variables we reference to the list
                foreach (var variableField in NameTable.Values)
                {
                    table.Add(variableField.ToString());
                }
            }

            // return whether or not we are in the reference chain
            return isReferenced;
        }

        internal virtual void AutoRenameFields()
        {
            // if we're not known at compile time, then we can't crunch
            // the local variables in this scope, because we can't know if
            // something will reference any of it at runtime.
            // eval is something that will make the scope unknown because we
            // don't know what eval will evaluate to until runtime
            if (m_isKnownAtCompileTime)
            {
                // get an array of all the uncrunched local variables defined in this scope
                var localFields = GetUncrunchedLocals();
                if (localFields != null)
                {
                    // create a crunch-name enumerator, taking into account any fields within our
                    // scope that have already been crunched.
                    var avoidSet = new HashSet<string>();
                    foreach (var field in NameTable.Values)
                    {
                        // if the field can't be crunched, or if it can but we've already crunched it,
                        // or if it's an outer variable (that hasn't been generated) and its OWNING scope isn't known 
                        // (and therefore we CANNOT crunch it),
                        // then add it to the avoid list so we don't reuse that name
                        if (!field.CanCrunch || field.CrunchedName != null
                            || (field.OuterField != null && !field.IsGenerated && field.OwningScope != null && !field.OwningScope.IsKnownAtCompileTime))
                        {
                            avoidSet.Add(field.ToString());
                        }
                    }

                    var crunchEnum = new CrunchEnumerator(avoidSet);
                    foreach (var localField in localFields)
                    {
                        // if we are an unambiguous reference to a named function expression and we are not
                        // referenced by anyone else, then we can just skip this variable because the
                        // name will be stripped from the output anyway.
                        // we also always want to crunch "placeholder" fields.
                        if (localField.CanCrunch
                            && (localField.RefCount > 0 || localField.IsDeclared || localField.IsPlaceholder
                            || !(Settings.RemoveFunctionExpressionNames && Settings.IsModificationAllowed(TreeModifications.RemoveFunctionExpressionNames))))
                        {
                            localField.CrunchedName = crunchEnum.NextName();

                            if (localField.Declarations.FirstOrDefault()?.Parent?.Parent?.Parent is ForInStatement forInStatement &&
                                forInStatement.Collection is MemberExpression memberExpression &&
                                memberExpression.Root is INameReference nameReference &&
                                localField.CrunchedName == (nameReference.VariableField.CrunchedName ?? nameReference.VariableField.Name))
                            {
                                localField.CrunchedName = crunchEnum.NextName();
                            }
                        }
                    }
                }
            }

            // then traverse through our children
            foreach (ActivationObject scope in ChildScopes)
            {
                scope.AutoRenameFields();
            }
        }

        internal IEnumerable<JSVariableField> GetUncrunchedLocals()
        {
            // there can't be more uncrunched fields than total fields
            var list = new List<JSVariableField>(NameTable.Count);
            foreach (var variableField in NameTable.Values)
            {
                // if the field is defined in this scope and hasn't been crunched
                // AND can still be crunched AND wasn't removed during the optimization process
                if (variableField != null && variableField.OuterField == null && variableField.CrunchedName == null
                    && variableField.CanCrunch && !variableField.WasRemoved)
                {
                    // if local renaming is not crunch all, then it must be crunch all but localization
                    // (we don't get called if we aren't crunching anything). 
                    // SO for the first clause:
                    // IF we are crunch all, we're good; but if we aren't crunch all, then we're only good if
                    //    the name doesn't start with "L_".
                    // The second clause is only computed IF we already think we're good to go.
                    // IF we aren't preserving function names, then we're good. BUT if we are, we're
                    // only good to go if this field doesn't represent a function object.
                    if ((Settings.LocalRenaming == LocalRenaming.CrunchAll
                        || !variableField.Name.StartsWith("L_", StringComparison.Ordinal))
                        && !(Settings.PreserveFunctionNames && variableField.IsFunction))
                    {
                        list.Add(variableField);
                    }
                }
            }

            if (list.Count == 0)
            {
                return null;
            }

            // sort the array and return it
            list.Sort(ReferenceComparer.Instance);
            return list;
        }

        #endregion

        #region field-management methods

        public virtual JSVariableField this[string name]
        {
            get
            {
                JSVariableField variableField;
                // check to see if this name is already defined in this scope
                if (!NameTable.TryGetValue(name, out variableField))
                {
                    // not in this scope
                    variableField = null;
                }
                return variableField;
            }
        }

        /// <summary>
        /// See if the given name will resolve to a field; do not create any inner fields
        /// or unknown global fields along the way.
        /// </summary>
        /// <param name="name">name to resolve</param>
        /// <returns>an existing resolved field, or null if nothing exists</returns>
        public JSVariableField CanReference(string name)
        {
            // check for this scope.
            var variableField = this[name];

            // if we didn't find anything, go up the chain until we find something.
            if (variableField == null)
            {
                var parentScope = this.Parent;
                while (parentScope != null && variableField == null)
                {
                    variableField = parentScope[name];
                    parentScope = parentScope.Parent;
                }
            }

            return variableField;
        }

        /// <summary>
        /// Resolve the name in this scope, or go up the chain adding inner fields
        /// along the way until the final reference is found, creating an unknown global
        /// field if necessary.
        /// </summary>
        /// <param name="name">name to resolve</param>
        /// <returns>resolved variable field (should never be null)</returns>
        public JSVariableField FindReference(string name)
        {
            // see if we have it
            var variableField = this[name];

            // if we didn't find anything and this scope has a parent
            if (variableField == null && name != null)
            {
                // if this is the super reference and we have one....
                if (string.CompareOrdinal(name, "super") == 0 && this.HasSuperBinding)
                {
                    variableField = new JSVariableField(FieldType.Super, name, 0, null);
                    NameTable.Add(name, variableField);
                }
                else if (this.Parent != null)
                {
                    // recursively go up the scope chain to find a reference,
                    // then create an inner field to point to it and we'll return
                    // that one.
                    variableField = CreateInnerField(this.Parent.FindReference(name));

                    // mark it as a placeholder. we might be going down a chain of scopes,
                    // where we will want to reserve the variable name, but not actually reference it.
                    // at the end where it is actually referenced we will reset the flag.
                    variableField.IsPlaceholder = true;
                }
                else
                {
                    // must be global scope. the field is undefined!
                    variableField = AddField(new JSVariableField(FieldType.UndefinedGlobal, name, 0, null));
                }
            }

            return variableField;
        }

        public virtual JSVariableField DeclareField(string name, object value, FieldAttributes attributes)
        {
            JSVariableField variableField;
            if (!NameTable.TryGetValue(name, out variableField))
            {
                variableField = CreateField(name, value, attributes);
                AddField(variableField);
            }
            return variableField;
        }

        public virtual JSVariableField CreateField(JSVariableField outerField)
        {
            // use the same type as the outer field by default
            return outerField.IfNotNull(o => new JSVariableField(o.FieldType, o));
        }

        public abstract JSVariableField CreateField(string name, object value, FieldAttributes attributes);

        public virtual JSVariableField CreateInnerField(JSVariableField outerField)
        {
            JSVariableField innerField = null;
            if (outerField != null)
            {
                // create a new inner field to be added to our scope
                innerField = CreateField(outerField);
                AddField(innerField);
            }

            return innerField;
        }

        internal JSVariableField AddField(JSVariableField variableField)
        {
            // add it to our name table 
            NameTable[variableField.Name] = variableField;

            // set the owning scope to this is we are the outer field, or the outer field's
            // owning scope if this is an inner field
            variableField.OwningScope = variableField.OuterField == null ? this : variableField.OuterField.OwningScope;
            return variableField;
        }

        public INameDeclaration VarDeclaredName(string name)
        {
            // check each var-decl name from inside this scope
            foreach (var varDecl in this.VarDeclaredNames)
            {
                // if the name matches, return the field
                if (string.CompareOrdinal(varDecl.Name, name) == 0)
                {
                    return varDecl;
                }
            }

            // if we get here, we didn't find a match
            return null;
        }

        public INameDeclaration LexicallyDeclaredName(string name)
        {
            // check each var-decl name from inside this scope
            foreach (var lexDecl in this.LexicallyDeclaredNames)
            {
                // if the name matches, return the field
                if (string.CompareOrdinal(lexDecl.Name, name) == 0)
                {
                    return lexDecl;
                }
            }

            // if we get here, we didn't find a match
            return null;
        }

        public void AddGlobal(string name)
        {
            // first, go up to the global scope
            var scope = this;
            while (scope.Parent != null)
            {
                scope = scope.Parent;
            }

            // now see if there is a field with that name already; 
            // will return a non-null field object if there is.
            var field = scope[name];
            if (field == null)
            {
                // nothing with this name. Add it as a global field
                scope.AddField(scope.CreateField(name, null, 0));
            }
        }

        #endregion
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ActivationObject.cs(233,75): error CS0136: A local or parameter named 'nodeList' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 14 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\Declaration.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using NUglify.Helpers;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Justification = "AST statement")]
    public abstract class Declaration : Statement, IEnumerable<VariableDeclaration>
    {
        private List<VariableDeclaration> m_list;

        public JSToken StatementToken { get; set; }

        public SourceContext KeywordContext { get; set; }

        public int Count
        {
            get { return m_list.Count; }
        }

        public VariableDeclaration this[int index]
        {
            get { return m_list[index]; }
            set
            {
                UnlinkParent(m_list[index]);
                if (value != null)
                {
                    m_list[index] = value;
                    m_list[index].Parent = this;
                }
                else
                {
                    m_list.RemoveAt(index);
                }
            }
        }

        public ActivationObject Scope { get; set; }

        public override bool IsDeclaration
        {
            get
            {
                // always considered a declaration
                return true;
            }
        }

        protected Declaration(SourceContext context)
            : base(context)
        {
            m_list = new List<VariableDeclaration>();
        }

        public override IEnumerable<AstNode> Children
        {
            get
            {
                return FastEnumerateNonNullNodes(m_list);
            }
        }

        public override bool ReplaceChild(AstNode oldNode, AstNode newNode)
        {
            for (int ndx = 0; ndx < m_list.Count; ++ndx)
            {
                if (m_list[ndx] == oldNode)
                {
                    if (newNode == null)
                    {
                        // found the item, but we just want to remove it after we unhook it
                        m_list[ndx].IfNotNull(n => n.Parent = (n.Parent == this) ? null : n.Parent);
                        m_list.RemoveAt(ndx);
                    }
                    else
                    {
                        // if the new node isn't a variabledeclaration, ignore the call
                        VariableDeclaration newDecl = newNode as VariableDeclaration;
                        if (newNode == null || newDecl != null)
                        {
                            m_list[ndx].IfNotNull(n => n.Parent = (n.Parent == this) ? null : n.Parent);
                            m_list[ndx] = newDecl;
                            newDecl.Parent = this;
                            return true;
                        }
                    }

                    break;
                }
            }

            return false;
        }

        public void Append(AstNode element)
        {
            var decl = element as VariableDeclaration;
            if (decl != null)
            {
                // first check the list for existing instances of this name.
                // if there are no duplicates (indicated by returning true), add it to the list.
                // if there is a dup (indicated by returning false) then that dup
                // has an initializer, and we DON'T want to add this new one if it doesn't
                // have it's own initializer.
                if (HandleDuplicates(decl.Binding) || decl.Initializer != null)
                {
                    // set the parent and add it to the list
                    decl.Parent = this;
                    m_list.Add(decl);
                    UpdateWith(decl.Context);
                }
            }
            else
            {
                // TODO: what should we do if we try to add a const to a var, or a var to a const???
                var otherVar = element as Declaration;
                if (otherVar != null)
                {
                    for (int ndx = 0; ndx < otherVar.m_list.Count; ++ndx)
                    {
                        Append(otherVar.m_list[ndx]);
                    }
                }
            }
        }

        public void InsertAt(int index, AstNode element)
        {
            VariableDeclaration decl = element as VariableDeclaration;
            if (decl != null)
            {
                // first check the list for existing instances of this name.
                // if there are no duplicates (indicated by returning true), add it to the list.
                // if there is a dup (indicated by returning false) then that dup
                // has an initializer, and we DON'T want to add this new one if it doesn't
                // have it's own initializer.
                if (HandleDuplicates(decl.Binding) || decl.Initializer != null)
                {
                    // set the parent and add it to the list
                    decl.Parent = this;
                    m_list.Insert(index, decl);
                }
            }
            else
            {
                // TODO: what should we do if we try to add a const to a var, or a var to a const???
                var otherVar = element as Declaration;
                if (otherVar != null)
                {
                    // walk the source backwards so they end up in the right order
                    for (int ndx = otherVar.m_list.Count - 1; ndx >= 0; --ndx)
                    {
                        InsertAt(index, otherVar.m_list[ndx]);
                    }
                }
            }
        }

        private bool HandleDuplicates(AstNode binding)
        {
            var notDuplicate = true;

            // TODO: for now, just do this logic for simple binding identifiers.
            // would be nice to also remove duplicates if they are in binding patterns (object literal and array literals)
            var testName = (binding as BindingIdentifier).IfNotNull(b => b.Name);
            if (!testName.IsNullOrWhiteSpace())
            {
                // walk backwards because we'll be removing items from the list
                for (var ndx = m_list.Count - 1; ndx >= 0 ; --ndx)
                {
                    var varDecl = m_list[ndx];

                    // if the binding is a simple identifier and the names match
                    var bindingIdentifier = varDecl.Binding as BindingIdentifier;
                    if (bindingIdentifier != null && string.CompareOrdinal(bindingIdentifier.Name, testName) == 0)
                    {
                        // check the initializer. If there is no initializer, then
                        // we want to remove it because we'll be adding a new one.
                        // but if there is an initializer, keep it but return false
                        // to indicate that there is still a duplicate in the list, 
                        // and that dup has an initializer.
                        if (varDecl.Initializer == null)
                        {
                            varDecl.Parent = null;
                            m_list.RemoveAt(ndx);
                        }
                        else
                        {
                            notDuplicate = false;
                        }
                    }
                }
            }

            return notDuplicate;
        }

        public void RemoveAt(int index)
        {
            if (0 <= index & index < m_list.Count)
            {
                UnlinkParent(m_list[index]);
                m_list.RemoveAt(index);
            }
        }

        public void Remove(VariableDeclaration variableDeclaration)
        {
            // remove the vardecl from the list. If it was there and was
            // successfully remove, Remove will return true. At that point, if the
            // vardecl still thinks we are the parent, reset the parent pointer.
            if (variableDeclaration != null && m_list.Remove(variableDeclaration) && variableDeclaration.Parent == this)
            {
                variableDeclaration.Parent = null;
            }
        }

        public bool Contains(string name)
        {
            if (!name.IsNullOrWhiteSpace())
            {
                // look at each vardecl in our list
                foreach (var varDecl in m_list)
                {
                    foreach (var nameDeclaration in BindingsVisitor.Bindings(varDecl))
                    {
                        // if it matches the target name exactly...
                        if (string.CompareOrdinal(name, nameDeclaration.Name) == 0)
                        {
                            // ...we found a match
                            return true;
                        }
                    }
                }
            }

            // if we get here, we didn't find any matches
            return false;
        }

        /// <summary>
        /// Returns true if any of the variable declarations contain initializers using the in-operator
        /// </summary>
        public override bool ContainsInOperator
        {
            get
            {
                // go through each child var-decl
                foreach (var decl in m_list)
                {
                    // if it has an initializer and it contains an in-operator, then we know that
                    // at least one of our decls contain an in-operator, so WE do.
                    if (decl.Initializer != null && decl.Initializer.ContainsInOperator)
                    {
                        return true;
                    }
                }

                // if we get here, we don't have any in-operators
                return false;
            }
        }

        #region IEnumerable<VariableDeclaration> Members

        public IEnumerator<VariableDeclaration> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }

        #endregion

        #region IEnumerable Members

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return m_list.GetEnumerator();
        }

        #endregion
    }
}

---- Transformed Tree ----
using System.Collections.Generic;
using NUglify.Helpers;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Justification = "AST statement")]
    public abstract class Declaration : Statement, IEnumerable<VariableDeclaration>
    {
        private List<VariableDeclaration> m_list;

        public JSToken StatementToken { get; set; }

        public SourceContext KeywordContext { get; set; }

        public int Count
        {
            get { return m_list.Count; }
        }

        public VariableDeclaration this[int index]
        {
            get { return m_list[index]; }
            set
            {
                UnlinkParent(m_list[index]);
                if (value != null)
                {
                    m_list[index] = value;
                    m_list[index].Parent = this;
                }
                else
                {
                    m_list.RemoveAt(index);
                }
            }
        }

        public ActivationObject Scope { get; set; }

        public override bool IsDeclaration
        {
            get
            {
                // always considered a declaration
                return true;
            }
        }

        protected Declaration(SourceContext context)
            : base(context)
        {
            m_list = new List<VariableDeclaration>();
        }

        public override IEnumerable<AstNode> Children
        {
            get
            {
                return FastEnumerateNonNullNodes(m_list);
            }
        }

        public override bool ReplaceChild(AstNode oldNode, AstNode newNode)
        {
            for (int ndx = 0; ndx < m_list.Count; ++ndx)
            {
                if (m_list[ndx] == oldNode)
                {
                    if (newNode == null)
                    {
                        // found the item, but we just want to remove it after we unhook it
                        m_list[ndx].IfNotNull(n => n.Parent = (n.Parent == this) ? null : n.Parent);
                        m_list.RemoveAt(ndx);
                    }
                    else
                    {
                        // if the new node isn't a variabledeclaration, ignore the call
                        if (newNode == null || newNode is VariableDeclaration newDecl)
                        {
                            m_list[ndx].IfNotNull(n => n.Parent = (n.Parent == this) ? null : n.Parent);
                            m_list[ndx] = newDecl;
                            newDecl.Parent = this;
                            return true;
                        }
                    }

                    break;
                }
            }

            return false;
        }

        public void Append(AstNode element)
        {
            if (element is VariableDeclaration decl)
            {
                // first check the list for existing instances of this name.
                // if there are no duplicates (indicated by returning true), add it to the list.
                // if there is a dup (indicated by returning false) then that dup
                // has an initializer, and we DON'T want to add this new one if it doesn't
                // have it's own initializer.
                if (HandleDuplicates(decl.Binding) || decl.Initializer != null)
                {
                    // set the parent and add it to the list
                    decl.Parent = this;
                    m_list.Add(decl);
                    UpdateWith(decl.Context);
                }
            }
            else
            {
                // TODO: what should we do if we try to add a const to a var, or a var to a const???
                if (element is Declaration otherVar)
                {
                    for (int ndx = 0; ndx < otherVar.m_list.Count; ++ndx)
                    {
                        Append(otherVar.m_list[ndx]);
                    }
                }
            }
        }

        public void InsertAt(int index, AstNode element)
        {
            if (element is VariableDeclaration decl)
            {
                // first check the list for existing instances of this name.
                // if there are no duplicates (indicated by returning true), add it to the list.
                // if there is a dup (indicated by returning false) then that dup
                // has an initializer, and we DON'T want to add this new one if it doesn't
                // have it's own initializer.
                if (HandleDuplicates(decl.Binding) || decl.Initializer != null)
                {
                    // set the parent and add it to the list
                    decl.Parent = this;
                    m_list.Insert(index, decl);
                }
            }
            else
            {
                // TODO: what should we do if we try to add a const to a var, or a var to a const???
                if (element is Declaration otherVar)
                {
                    // walk the source backwards so they end up in the right order
                    for (int ndx = otherVar.m_list.Count - 1; ndx >= 0; --ndx)
                    {
                        InsertAt(index, otherVar.m_list[ndx]);
                    }
                }
            }
        }

        private bool HandleDuplicates(AstNode binding)
        {
            var notDuplicate = true;

            // TODO: for now, just do this logic for simple binding identifiers.
            // would be nice to also remove duplicates if they are in binding patterns (object literal and array literals)
            var testName = (binding as BindingIdentifier).IfNotNull(b => b.Name);
            if (!testName.IsNullOrWhiteSpace())
            {
                // walk backwards because we'll be removing items from the list
                for (var ndx = m_list.Count - 1; ndx >= 0 ; --ndx)
                {
                    var varDecl = m_list[ndx];

                    // if the binding is a simple identifier and the names match
                    if (varDecl.Binding is BindingIdentifier bindingIdentifier && string.CompareOrdinal(bindingIdentifier.Name, testName) == 0)
                    {
                        // check the initializer. If there is no initializer, then
                        // we want to remove it because we'll be adding a new one.
                        // but if there is an initializer, keep it but return false
                        // to indicate that there is still a duplicate in the list, 
                        // and that dup has an initializer.
                        if (varDecl.Initializer == null)
                        {
                            varDecl.Parent = null;
                            m_list.RemoveAt(ndx);
                        }
                        else
                        {
                            notDuplicate = false;
                        }
                    }
                }
            }

            return notDuplicate;
        }

        public void RemoveAt(int index)
        {
            if (0 <= index & index < m_list.Count)
            {
                UnlinkParent(m_list[index]);
                m_list.RemoveAt(index);
            }
        }

        public void Remove(VariableDeclaration variableDeclaration)
        {
            // remove the vardecl from the list. If it was there and was
            // successfully remove, Remove will return true. At that point, if the
            // vardecl still thinks we are the parent, reset the parent pointer.
            if (variableDeclaration != null && m_list.Remove(variableDeclaration) && variableDeclaration.Parent == this)
            {
                variableDeclaration.Parent = null;
            }
        }

        public bool Contains(string name)
        {
            if (!name.IsNullOrWhiteSpace())
            {
                // look at each vardecl in our list
                foreach (var varDecl in m_list)
                {
                    foreach (var nameDeclaration in BindingsVisitor.Bindings(varDecl))
                    {
                        // if it matches the target name exactly...
                        if (string.CompareOrdinal(name, nameDeclaration.Name) == 0)
                        {
                            // ...we found a match
                            return true;
                        }
                    }
                }
            }

            // if we get here, we didn't find any matches
            return false;
        }

        /// <summary>
        /// Returns true if any of the variable declarations contain initializers using the in-operator
        /// </summary>
        public override bool ContainsInOperator
        {
            get
            {
                // go through each child var-decl
                foreach (var decl in m_list)
                {
                    // if it has an initializer and it contains an in-operator, then we know that
                    // at least one of our decls contain an in-operator, so WE do.
                    if (decl.Initializer != null && decl.Initializer.ContainsInOperator)
                    {
                        return true;
                    }
                }

                // if we get here, we don't have any in-operators
                return false;
            }
        }

        #region IEnumerable<VariableDeclaration> Members

        public IEnumerator<VariableDeclaration> GetEnumerator()
        {
            return m_list.GetEnumerator();
        }

        #endregion

        #region IEnumerable Members

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return m_list.GetEnumerator();
        }

        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\Declaration.cs(98,43): error CS0165: Use of unassigned local variable 'newDecl'
######################################################################


######################################################################
Nr: 15 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ObjectLiteral.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public sealed class ObjectLiteral : Expression
    {
        private AstNodeList m_properties;

        public AstNodeList Properties
        {
            get { return m_properties; }
            set
            {
                ReplaceNode(ref m_properties, value);
            }
        }

        public override bool IsConstant
        {
            get
            {
                // we are NOT constant if any one property value isn't constant.
                // no properties means an empty object literal, which is constant.
                if (Properties != null)
                {
                    foreach (var property in Properties)
                    {
                        if (!property.IsConstant)
                        {
                            return false;
                        }
                    }
                }

                // if we got here, they're all constant
                return true;
            }
        }

        public ObjectLiteral(SourceContext context)
            : base(context)
        {
        }

        public override void Accept(IVisitor visitor)
        {
            visitor?.Visit(this);
        }

        public override IEnumerable<AstNode> Children
        {
            get
            {
                return EnumerateNonNullNodes(m_properties);
            }
        }

        public override bool ReplaceChild(AstNode oldNode, AstNode newNode)
        {
            if (oldNode == m_properties)
            {
                var properties = newNode as AstNodeList;
                if (newNode == null || properties != null)
                {
                    Properties = properties;
                }
            }
            return false;
        }
    }
}


---- Transformed Tree ----
using System.Collections.Generic;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public sealed class ObjectLiteral : Expression
    {
        private AstNodeList m_properties;

        public AstNodeList Properties
        {
            get { return m_properties; }
            set
            {
                ReplaceNode(ref m_properties, value);
            }
        }

        public override bool IsConstant
        {
            get
            {
                // we are NOT constant if any one property value isn't constant.
                // no properties means an empty object literal, which is constant.
                if (Properties != null)
                {
                    foreach (var property in Properties)
                    {
                        if (!property.IsConstant)
                        {
                            return false;
                        }
                    }
                }

                // if we got here, they're all constant
                return true;
            }
        }

        public ObjectLiteral(SourceContext context)
            : base(context)
        {
        }

        public override void Accept(IVisitor visitor)
        {
            visitor?.Visit(this);
        }

        public override IEnumerable<AstNode> Children
        {
            get
            {
                return EnumerateNonNullNodes(m_properties);
            }
        }

        public override bool ReplaceChild(AstNode oldNode, AstNode newNode)
        {
            if (oldNode == m_properties)
            {
                if (newNode == null || newNode is AstNodeList properties)
                {
                    Properties = properties;
                }
            }
            return false;
        }
    }
}


---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ObjectLiteral.cs(81,34): error CS0165: Use of unassigned local variable 'properties'
######################################################################


######################################################################
Nr: 16 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ObjectLiteralProperty.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using NUglify.Helpers;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public class ObjectLiteralProperty : AstNode
    {
        private ObjectLiteralField m_propertyName;
        private AstNode m_propertyValue;

        public ObjectLiteralField Name
        {
            get { return m_propertyName; }
            set
            {
                ReplaceNode(ref m_propertyName, value);
            }
        }

        public AstNode Value
        {
            get { return m_propertyValue; }
            set
            {
                ReplaceNode(ref m_propertyValue, value);
            }
        }

        public override bool IsConstant
        {
            get
            {
                // we are constant if our value is constant.
                // If we don't have a value, then assume it's constant
                return Value != null ? Value.IsConstant : true;
            }
        }

        public ObjectLiteralProperty(SourceContext context)
            : base(context)
        {
        }

        public override void Accept(IVisitor visitor)
        {
            visitor?.Visit(this);
        }

        public override IEnumerable<AstNode> Children
        {
            get
            {
                return EnumerateNonNullNodes(Name, Value);
            }
        }

        public override bool ReplaceChild(AstNode oldNode, AstNode newNode)
        {
            if (Name == oldNode)
            {
                var objectField = newNode as ObjectLiteralField;
                if (newNode == null || objectField != null)
                {
                    Name = objectField;
                }
                return true;
            }

            if (Value == oldNode)
            {
                Value = newNode;
                return true;
            }

            return false;
        }

        internal override string GetFunctionGuess(AstNode target)
        {
            return Name.IfNotNull(n => n.ToString());
        }
    }
}

---- Transformed Tree ----
using System.Collections.Generic;
using NUglify.Helpers;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public class ObjectLiteralProperty : AstNode
    {
        private ObjectLiteralField m_propertyName;
        private AstNode m_propertyValue;

        public ObjectLiteralField Name
        {
            get { return m_propertyName; }
            set
            {
                ReplaceNode(ref m_propertyName, value);
            }
        }

        public AstNode Value
        {
            get { return m_propertyValue; }
            set
            {
                ReplaceNode(ref m_propertyValue, value);
            }
        }

        public override bool IsConstant
        {
            get
            {
                // we are constant if our value is constant.
                // If we don't have a value, then assume it's constant
                return Value != null ? Value.IsConstant : true;
            }
        }

        public ObjectLiteralProperty(SourceContext context)
            : base(context)
        {
        }

        public override void Accept(IVisitor visitor)
        {
            visitor?.Visit(this);
        }

        public override IEnumerable<AstNode> Children
        {
            get
            {
                return EnumerateNonNullNodes(Name, Value);
            }
        }

        public override bool ReplaceChild(AstNode oldNode, AstNode newNode)
        {
            if (Name == oldNode)
            {
                if (newNode == null || newNode is ObjectLiteralField objectField)
                {
                    Name = objectField;
                }
                return true;
            }

            if (Value == oldNode)
            {
                Value = newNode;
                return true;
            }

            return false;
        }

        internal override string GetFunctionGuess(AstNode target)
        {
            return Name.IfNotNull(n => n.ToString());
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\ObjectLiteralProperty.cs(80,28): error CS0165: Use of unassigned local variable 'objectField'
######################################################################


######################################################################
Nr: 17 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\SwitchCase.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public sealed class SwitchCase : AstNode
    {
        private AstNode m_caseValue;
        private BlockStatement m_statements;

        public AstNode CaseValue
        {
            get { return m_caseValue; }
            set
            {
                ReplaceNode<AstNode>(ref m_caseValue, value);
            }
        }

        public BlockStatement Statements
        {
            get { return m_statements; }
            set
            {
                ReplaceNode<BlockStatement>(ref m_statements, value);
            }
        }

        internal bool IsDefault
        {
            get { return (CaseValue == null); }
        }

        public SourceContext ColonContext { get; set; }

        public SwitchCase(SourceContext context)
            : base(context)
        {
        }

        public override void Accept(IVisitor visitor)
        {
            visitor?.Visit(this);
        }

        public override IEnumerable<AstNode> Children
        {
            get
            {
                return EnumerateNonNullNodes(CaseValue, Statements);
            }
        }

        public override bool ReplaceChild(AstNode oldNode, AstNode newNode)
        {
            if (CaseValue == oldNode)
            {
                CaseValue = newNode;
                return true;
            }
            if (Statements == oldNode)
            {
                var newBlock = newNode as BlockStatement;
                if (newNode == null || newBlock != null)
                {
                    Statements = newBlock;
                    return true;
                }
            }
            return false;
        }
    }
}
---- Transformed Tree ----
using System.Collections.Generic;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public sealed class SwitchCase : AstNode
    {
        private AstNode m_caseValue;
        private BlockStatement m_statements;

        public AstNode CaseValue
        {
            get { return m_caseValue; }
            set
            {
                ReplaceNode<AstNode>(ref m_caseValue, value);
            }
        }

        public BlockStatement Statements
        {
            get { return m_statements; }
            set
            {
                ReplaceNode<BlockStatement>(ref m_statements, value);
            }
        }

        internal bool IsDefault
        {
            get { return (CaseValue == null); }
        }

        public SourceContext ColonContext { get; set; }

        public SwitchCase(SourceContext context)
            : base(context)
        {
        }

        public override void Accept(IVisitor visitor)
        {
            visitor?.Visit(this);
        }

        public override IEnumerable<AstNode> Children
        {
            get
            {
                return EnumerateNonNullNodes(CaseValue, Statements);
            }
        }

        public override bool ReplaceChild(AstNode oldNode, AstNode newNode)
        {
            if (CaseValue == oldNode)
            {
                CaseValue = newNode;
                return true;
            }
            if (Statements == oldNode)
            {
                if (newNode == null || newNode is BlockStatement newBlock)
                {
                    Statements = newBlock;
                    return true;
                }
            }
            return false;
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\SwitchCase.cs(81,34): error CS0165: Use of unassigned local variable 'newBlock'
######################################################################


######################################################################
Nr: 18 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\SwitchStatement.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System.Collections.Generic;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public sealed class SwitchStatement : Statement
    {
        private AstNode m_expression;
        private AstNodeList m_cases;

        public AstNode Expression
        {
            get { return m_expression; }
            set
            {
                ReplaceNode(ref m_expression, value);
            }
        }

        public AstNodeList Cases
        {
            get { return m_cases; }
            set
            {
                ReplaceNode(ref m_cases, value);
            }
        }

        public bool BraceOnNewLine { get; set; }
        public SourceContext BraceContext { get; set; }

        public ActivationObject BlockScope { get; set; }

        public SwitchStatement(SourceContext context)
            : base(context)
        {
        }

        public override void Accept(IVisitor visitor)
        {
            visitor?.Visit(this);
        }

        public override IEnumerable<AstNode> Children
        {
            get
            {
                return EnumerateNonNullNodes(Expression, Cases);
            }
        }

        public override bool ReplaceChild(AstNode oldNode, AstNode newNode)
        {
            if (Expression == oldNode)
            {
                Expression = newNode;
                return true;
            }
            if (Cases == oldNode)
            {
                AstNodeList newList = newNode as AstNodeList;
                if (newNode == null || newList != null)
                {
                    // remove it
                    Cases = newList;
                    return true;
                }
            }

            return false;
        }
    }
}

---- Transformed Tree ----
using System.Collections.Generic;
using NUglify.JavaScript.Visitors;

namespace NUglify.JavaScript.Syntax
{
    public sealed class SwitchStatement : Statement
    {
        private AstNode m_expression;
        private AstNodeList m_cases;

        public AstNode Expression
        {
            get { return m_expression; }
            set
            {
                ReplaceNode(ref m_expression, value);
            }
        }

        public AstNodeList Cases
        {
            get { return m_cases; }
            set
            {
                ReplaceNode(ref m_cases, value);
            }
        }

        public bool BraceOnNewLine { get; set; }
        public SourceContext BraceContext { get; set; }

        public ActivationObject BlockScope { get; set; }

        public SwitchStatement(SourceContext context)
            : base(context)
        {
        }

        public override void Accept(IVisitor visitor)
        {
            visitor?.Visit(this);
        }

        public override IEnumerable<AstNode> Children
        {
            get
            {
                return EnumerateNonNullNodes(Expression, Cases);
            }
        }

        public override bool ReplaceChild(AstNode oldNode, AstNode newNode)
        {
            if (Expression == oldNode)
            {
                Expression = newNode;
                return true;
            }
            if (Cases == oldNode)
            {
                if (newNode == null || newNode is AstNodeList newList)
                {
                    // remove it
                    Cases = newList;
                    return true;
                }
            }

            return false;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Syntax\SwitchStatement.cs(80,29): error CS0165: Use of unassigned local variable 'newList'
######################################################################


######################################################################
Nr: 19 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Text.RegularExpressions;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;
using SwitchStatement = NUglify.JavaScript.Syntax.SwitchStatement;

namespace NUglify.JavaScript.Visitors
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
    internal class AnalyzeNodeVisitor : TreeVisitor
    {
        private JSParser m_parser;
        private bool m_encounteredCCOn;// = false;
        private MatchPropertiesVisitor m_matchVisitor;// == null;
        private Stack<ActivationObject> m_scopeStack;
        private JSError m_strictNameError = JSError.StrictModeVariableName;
        private HashSet<string> m_noRename;
        private bool m_stripDebug;
        private bool m_lookForDebugNamespaces;
        private bool m_possibleDebugNamespace;
        private int m_possibleDebugNamespaceIndex;
        private List<string[]> m_possibleDebugMatches;
        private string[][] m_debugNamespaceParts;

        public AnalyzeNodeVisitor(JSParser parser)
        {
            m_parser = parser;
            m_scopeStack = new Stack<ActivationObject>();
            m_scopeStack.Push(parser.GlobalScope);

            // see if we want to strip debug namespaces, and create the matching list if we do.
            m_stripDebug = m_parser.Settings.StripDebugStatements
                && m_parser.Settings.IsModificationAllowed(TreeModifications.StripDebugStatements);
            m_lookForDebugNamespaces = m_stripDebug && m_parser.DebugLookups.Count > 0;
            if (m_lookForDebugNamespaces)
            {
                m_possibleDebugMatches = new List<string[]>();
                m_debugNamespaceParts = new string[m_parser.DebugLookups.Count][];
                var ndx = 0;
                foreach (var debugNamespace in m_parser.DebugLookups)
                {
                    m_debugNamespaceParts[ndx++] = debugNamespace.Split('.');
                }
            }

            if (m_parser.Settings.LocalRenaming != LocalRenaming.KeepAll)
            {
                m_noRename = new HashSet<string>(m_parser.Settings.NoAutoRenameCollection);
            }
        }

        #region IVisitor

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(BinaryExpression node)
        {
            if (node != null)
            {
                if (node.Operand1 != null)
                {
                    node.Operand1.Accept(this);
                }

                if (node.Operand2 != null)
                {
                    node.Operand2.Accept(this);
                }

                if ((node.Operand1 == null || node.Operand1.IsDebugOnly) 
                    && (node.Operand2 == null || node.Operand2.IsDebugOnly))
                {
                    // if both operands are debug-only, then this whole expression is debug only.
                    // if the right-hand side is debug only and this is an assignment, then this operation is debug-only.
                    node.IsDebugOnly = true;
                }
                else
                {
                    if (node.Operand1 != null && node.Operand1.IsDebugOnly)
                    {
                        node.Operand1 = ClearDebugExpression(node.Operand1);
                    }

                    if (node.Operand2 != null && node.Operand2.IsDebugOnly)
                    {
                        node.Operand2 = ClearDebugExpression(node.Operand2);
                    }

                    // see if this operation is subtracting zero from a lookup -- that is typically done to
                    // coerce a value to numeric. There's a simpler way: unary plus operator.
                    if (node.OperatorToken == JSToken.Minus
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.SimplifyStringToNumericConversion))
                    {
                        LookupExpression lookup = node.Operand1 as LookupExpression;
                        if (lookup != null)
                        {
                            ConstantWrapper right = node.Operand2 as ConstantWrapper;
                            if (right != null && right.IsIntegerLiteral && right.ToNumber() == 0)
                            {
                                // okay, so we have "lookup - 0"
                                // this is done frequently to force a value to be numeric. 
                                // There is an easier way: apply the unary + operator to it. 
                                // transform: lookup - 0   => +lookup
                                var unary = new UnaryExpression(node.Context)
                                    {
                                        Operand = lookup,
                                        OperatorToken = JSToken.Plus
                                    };
                                node.Parent.ReplaceChild(node, unary);

                                // because we recursed at the top of this function, we don't need to Analyze
                                // the new Unary node. This visitor's method for UnaryOperator only does something
                                // if the operand is a constant -- and this one is a Lookup. And we already analyzed
                                // the lookup.
                            }
                        }
                    }
                    else if ((node.OperatorToken == JSToken.StrictEqual || node.OperatorToken == JSToken.StrictNotEqual)
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.ReduceStrictOperatorIfTypesAreSame))
                    {
                        PrimitiveType leftType = node.Operand1.FindPrimitiveType();
                        if (leftType != PrimitiveType.Other)
                        {
                            PrimitiveType rightType = node.Operand2.FindPrimitiveType();
                            if (leftType == rightType)
                            {
                                // the are the same known types. We can reduce the operators
                                node.OperatorToken = node.OperatorToken == JSToken.StrictEqual ? JSToken.Equal : JSToken.NotEqual;
                            }
                            else if (rightType != PrimitiveType.Other)
                            {
                                // they are not the same, but they are both known. We can completely remove the operator
                                // and replace it with true (!==) or false (===).
                                // transform: x !== y   =>   true
                                // transform: x === y   =>   false
                                node.Context.HandleError(JSError.StrictComparisonIsAlwaysTrueOrFalse, false);
                                node.Parent.ReplaceChild(
                                    node,
                                    new ConstantWrapper(node.OperatorToken == JSToken.StrictNotEqual, PrimitiveType.Boolean, node.Context));

                                // because we are essentially removing the node from the AST, be sure to detach any references
                                DetachReferencesVisitor.Apply(node);
                            }
                        }
                    }
                    else if (node.IsAssign)
                    {
                        var lookup = node.Operand1 as LookupExpression;
                        if (lookup != null)
                        {
                            if (lookup.VariableField != null && lookup.VariableField.InitializationOnly)
                            {
                                // the field is an initialization-only field -- we should NOT be assigning to it
                                lookup.Context.HandleError(JSError.AssignmentToConstant, true);
                            }
                            else if (m_scopeStack.Peek().UseStrict)
                            {
                                if (lookup.VariableField == null || lookup.VariableField.FieldType == FieldType.UndefinedGlobal)
                                {
                                    // strict mode cannot assign to undefined fields
                                    node.Operand1.Context.HandleError(JSError.StrictModeUndefinedVariable, true);
                                }
                                else if (lookup.VariableField.FieldType == FieldType.Arguments
                                    || (lookup.VariableField.FieldType == FieldType.Predefined 
                                    && string.CompareOrdinal(lookup.Name, "eval") == 0))
                                {
                                    // strict mode cannot assign to lookup "eval" or "arguments"
                                    node.Operand1.Context.HandleError(JSError.StrictModeInvalidAssign, true);
                                }
                            }
                        }
                    }
                    else if ((node.Parent is BlockStatement || (node.Parent is CommaExpression && node.Parent.Parent is BlockStatement))
                        && (node.OperatorToken == JSToken.LogicalOr || node.OperatorToken == JSToken.LogicalAnd))
                    {
                        // this is an expression statement where the operator is || or && -- basically
                        // it's a shortcut for an if-statement:
                        // expr1&&expr2; ==> if(expr1)expr2;
                        // expr1||expr2; ==> if(!expr1)expr2;
                        // let's check to see if the not of expr1 is smaller. If so, we can not the expression
                        // and change the operator
                        var logicalNot = new LogicalNotVisitor(node.Operand1, m_parser.Settings);
                        if (logicalNot.Measure() < 0)
                        {
                            // it would be smaller! Change it.
                            // transform: expr1&&expr2 => !expr1||expr2
                            // transform: expr1||expr2 => !expr1&&expr2
                            logicalNot.Apply();
                            node.OperatorToken = node.OperatorToken == JSToken.LogicalAnd ? JSToken.LogicalOr : JSToken.LogicalAnd;
                        }
                    }
                }
            }
        }

        public override void Visit(BindingIdentifier node)
        {
            if (node != null)
            {
                ValidateIdentifier(m_scopeStack.Peek().UseStrict, node.Name, node.Context, m_strictNameError);
            }
        }

        private void CombineExpressions(BlockStatement node)
        {
            // walk backwards because we'll be removing items as we go along.
            // and don't bother looking at the first element, because we'll be attempting to combine
            // the current element with the previous element -- and the first element (0) has no
            // previous element.
            // we will check for:
            //      1) expr1;expr2           ==> expr1,expr2
            //      2) expr1;for(;...)       ==> for(expr1;...)
            //      3) expr1;for(expr2;...)  ==> for(expr1,expr2;...)
            //      4) expr1;return expr2    ==> return expr1,expr2
            //      5) expr1;if(cond)...     ==> if(expr1,cond)...
            //      6) expr1;while(cond)...  ==> for(expr;cond;)...
            //      7) lookup=expr1;lookup[OP]=expr2;   ==> lookup=expr1[OP]expr2
            //      8) lookup[OP1]=expr1;lookup[OP2]=expr2  ==> lookup=(lookup[OP1]expr1)[OP2]expr2
            for (var ndx = node.Count - 1; ndx > 0; --ndx)
            {
                // we may have deleted more than 1 statement, in which case we need to loop around
                // again to let ndx catch up to the last item in the block
                if (ndx >= node.Count)
                {
                    continue;
                }

                // see if the previous statement is an expression
                if (node[ndx - 1].IsExpression)
                {
                    CombineWithPreviousExpression(node, ndx);
                }
                else if (node[ndx - 1] is VarDeclaration previousVar)
                {
                    CombineWithPreviousVar(node, ndx, previousVar);
                }
            }
        }

        private void CombineWithPreviousExpression(BlockStatement node, int ndx)
        {
            IfStatement ifNode;
            ForStatement forStatement;
            WhileStatement whileNode;
            ReturnStatement returnNode;
            if (node[ndx].IsExpression)
            {
                CombineTwoExpressions(node, ndx);
            }
            else if ((returnNode = node[ndx] as ReturnStatement) != null)
            {
                CombineReturnWithExpression(node, ndx, returnNode);
            }
            else if ((forStatement = node[ndx] as ForStatement) != null)
            {
                CombineForNodeWithExpression(node, ndx, forStatement);
            }
            else if ((ifNode = node[ndx] as IfStatement) != null)
            {
                // transform: expr;if(cond)... => if(expr,cond)...
                // combine the previous expression with the if-condition via comma, then delete
                // the previous statement.
                ifNode.Condition = CommaExpression.CombineWithComma(node[ndx - 1].Context.FlattenToStart(), node[ndx - 1], ifNode.Condition);
                node.RemoveAt(ndx - 1);
            }
            else if ((whileNode = node[ndx] as WhileStatement) != null
                && m_parser.Settings.IsModificationAllowed(TreeModifications.ChangeWhileToFor))
            {
                // transform: expr;while(cond)... => for(expr;cond;)...
                // zero-sum, and maybe a little worse for performance because of the nop iterator,
                // but combines two statements into one, which may have savings later on.
                var initializer = node[ndx - 1];
                node[ndx] = new ForStatement(initializer.Context.FlattenToStart())
                {
                    Initializer = initializer,
                    Condition = whileNode.Condition,
                    Body = whileNode.Body
                };
                node.RemoveAt(ndx - 1);
            }
        }

        private static void CombineTwoExpressions(BlockStatement node, int ndx)
        {
            var prevBinary = node[ndx - 1] as BinaryExpression;
            var curBinary = node[ndx] as BinaryExpression;
            LookupExpression lookup;
            if (prevBinary != null
                && curBinary != null
                && prevBinary.IsAssign
                && curBinary.IsAssign
                && curBinary.OperatorToken != JSToken.Assign
                && (lookup = curBinary.Operand1 as LookupExpression) != null
                && prevBinary.Operand1.IsEquivalentTo(curBinary.Operand1))
            {
                if (prevBinary.OperatorToken == JSToken.Assign
                    && !ReferencesVisitor.References(curBinary.Operand2, lookup))
                {
                    // transform: lookup=expr1;lookup[OP]=expr2;  ==>  lookup=expr1[OP]expr2
                    // BUT NOT IF expr2 contains a reference to lookup!
                    var binOp = new BinaryExpression(prevBinary.Operand2.Context.CombineWith(curBinary.Operand2.Context))
                    {
                        Operand1 = prevBinary.Operand2,
                        Operand2 = curBinary.Operand2,
                        OperatorToken = JSScanner.StripAssignment(curBinary.OperatorToken),
                        OperatorContext = curBinary.OperatorContext
                    };
                    prevBinary.Operand2 = binOp;

                    // we are removing the second lookup, so clean up the reference on the field
                    if (lookup.VariableField != null)
                    {
                        lookup.VariableField.References.Remove(lookup);
                    }

                    // and remove the current assignment expression (everything was combined into the previous)
                    node[ndx] = null;
                }
                else
                {
                    // there's lots of ins-and-outs in terms of strings versus numerics versus precedence and all 
                    // sorts of stuff. I need to iron this out a little better, but until then, just combine with a comma.
                    // transform: expr1;expr2  ==>  expr1,expr2
                    var binOp = CommaExpression.CombineWithComma(prevBinary.Context.CombineWith(curBinary.Context), prevBinary, curBinary);

                    // replace the previous node and delete the current
                    node[ndx - 1] = binOp;
                    node[ndx] = null;
                }
            }
            else
            {
                // transform: expr1;expr2 to expr1,expr2
                // use the special comma operator object so we can handle it special
                // and don't create stack-breakingly deep trees
                var binOp = CommaExpression.CombineWithComma(node[ndx - 1].Context.CombineWith(node[ndx].Context), node[ndx - 1], node[ndx]);

                // replace the current node and delete the previous
                node[ndx] = binOp;
                node[ndx - 1] = null;
            }
        }

        private static void CombineReturnWithExpression(BlockStatement node, int ndx, ReturnStatement returnNode)
        {
            // see if the return node has an expression operand
            if (returnNode.Operand != null && returnNode.Operand.IsExpression)
            {
                // check for lookup[ASSIGN]expr2;return expr1.
                var beforeExpr = node[ndx - 1] as BinaryExpression;
                LookupExpression lookup;
                if (beforeExpr != null
                    && beforeExpr.IsAssign
                    && (lookup = beforeExpr.Operand1 as LookupExpression) != null)
                {
                    if (returnNode.Operand.IsEquivalentTo(lookup))
                    {
                        // we have lookup[ASSIGN]expr2;return lookup.
                        // if lookup is a local variable in the current scope, we can replace with return expr2;
                        // if lookup is an outer reference, we can replace with return lookup[ASSIGN]expr2
                        if (beforeExpr.OperatorToken == JSToken.Assign)
                        {
                            // check to see if lookup is in the current scope from which we are returning
                            if (lookup.VariableField == null
                                || lookup.VariableField.OuterField != null
                                || lookup.VariableField.IsReferencedInnerScope)
                            {
                                // transform: lookup[ASSIGN]expr2;return lookup => return lookup[ASSIGN]expr2
                                // lookup points to outer field (or we don't know)
                                // replace the operand on the return node with the previous expression and
                                // delete the previous node.
                                // first be sure to remove the lookup in the return operand from the references
                                // to field.
                                DetachReferencesVisitor.Apply(returnNode.Operand);
                                returnNode.Operand = beforeExpr;
                                node[ndx - 1] = null;
                            }
                            else
                            {
                                // transform: lookup[ASSIGN]expr2;return lookup => return expr2
                                // lookup is a variable local to the current scope, so when we return, the
                                // variable won't exists anymore anyway.
                                // replace the operand on the return node oprand with the right-hand operand of the
                                // previous expression and delete the previous node.
                                // we're eliminating the two lookups altogether, so remove them both from the
                                // field's reference table.
                                var varField = lookup.VariableField;
                                DetachReferencesVisitor.Apply(lookup, returnNode.Operand);

                                returnNode.Operand = beforeExpr.Operand2;
                                node[ndx - 1] = null;

                                // now that we've eliminated the two lookups, see if the local variable isn't
                                // referenced anymore. If it isn't, we might be able to remove the variable, too.
                                // (need to pick up those changes to keep track of a field's declarations, though)
                                if (varField.RefCount == 0)
                                {
                                    // it's not. if there's only one declaration and it either has no initializer or
                                    // is initialized to a constant, get rid of it.
                                    var nameDecl = varField.OnlyDeclaration;
                                    if (nameDecl != null)
                                    {
                                        // we only had one declaration.
                                        if (nameDecl.Initializer == null || nameDecl.Initializer.IsConstant)
                                        {
                                            // and it either had no initializer or it was initialized to a constant.
                                            // but it has no references, so let's whack it. Actually, only if it was
                                            // a var-decl (leave parameter and function decls alone).
                                            // TODO: would be nice to properly remove unused declarations from binding parameters
                                            // as well (object literals and array literals)
                                            var varDecl = nameDecl.Parent as VariableDeclaration;
                                            if (varDecl != null)
                                            {
                                                // save the declaration parent (var, const, or let) and remove the
                                                // child vardecl from its list
                                                var declStatement = varDecl.Parent as Declaration;
                                                declStatement.Remove(varDecl);
                                                varField.WasRemoved = true;

                                                // if the parent statement is now empty, remove it, too. this will
                                                // move everything up one index, but that'll just mean an extra loop.
                                                if (declStatement.Count == 0)
                                                {
                                                    declStatement.Parent.ReplaceChild(declStatement, null);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            // it's an assignment, but it's not =. That means it's one of the OP= operators.
                            // we can't remove the field altogether. But we can move the assignment into the 
                            // return statement and get rid of the lone lookup.
                            // transform: lookup OP= expr;return lookup   =>   return lookup OP= expr;
                            if (lookup.VariableField != null)
                            {
                                // we're getting rid of the lookup, so remove it from the field's list of references
                                DetachReferencesVisitor.Apply(returnNode.Operand);
                            }

                            // remove the expression from the block and put it in the operand of
                            // the return statement.
                            node.RemoveAt(ndx - 1);
                            returnNode.Operand = beforeExpr;

                            // is this field scoped only to this function?
                            if (lookup.VariableField != null
                                && lookup.VariableField.OuterField == null
                                && !lookup.VariableField.IsReferencedInnerScope)
                            {
                                // in fact, the lookup is in the current scope, so assigning to it is a waste
                                // because we're going to return (this is a return statement, after all).
                                // we can get rid of the assignment part and just keep the operator:
                                // transform: lookup OP= expr;return lookup   =>   return lookup OP expr;
                                beforeExpr.OperatorToken = JSScanner.StripAssignment(beforeExpr.OperatorToken);
                            }
                        }
                    }
                    else
                    {
                        // transform: expr1;return expr2 to return expr1,expr2
                        var binOp = CommaExpression.CombineWithComma(node[ndx - 1].Context.FlattenToStart(), node[ndx - 1], returnNode.Operand);

                        // replace the operand on the return node with the new expression and
                        // delete the previous node
                        returnNode.Operand = binOp;
                        node[ndx - 1] = null;
                    }
                }
                else
                {
                    // transform: expr1;return expr2 to return expr1,expr2
                    var binOp = CommaExpression.CombineWithComma(node[ndx - 1].Context.FlattenToStart(), node[ndx - 1], returnNode.Operand);

                    // replace the operand on the return node with the new expression and
                    // delete the previous node
                    returnNode.Operand = binOp;
                    node[ndx - 1] = null;
                }
            }
        }

        private void CombineForNodeWithExpression(BlockStatement node, int ndx, ForStatement forStatement)
        {
            // if we aren't allowing in-operators to be moved into for-statements, then
            // first check to see if that previous expression statement is free of in-operators
            // before trying to move it.
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.MoveInExpressionsIntoForStatement)
                || !node[ndx - 1].ContainsInOperator)
            {
                if (forStatement.Initializer == null)
                {
                    // transform: expr1;for(;...) to for(expr1;...)
                    // simply move the previous expression to the for-statement's initializer
                    forStatement.Initializer = node[ndx - 1];
                    node[ndx - 1] = null;
                }
                else if (forStatement.Initializer.IsExpression)
                {
                    // transform: expr1;for(expr2;...) to for(expr1,expr2;...)
                    var binOp = CommaExpression.CombineWithComma(node[ndx-1].Context.FlattenToStart(), node[ndx - 1], forStatement.Initializer);

                    // replace the initializer with the new binary operator and remove the previous node
                    forStatement.Initializer = binOp;
                    node[ndx - 1] = null;
                }
            }
        }

        private static void CombineWithPreviousVar(BlockStatement node, int ndx, VarDeclaration previousVar)
        {
            if (previousVar.Count == 0)
            {
                return;
            }

            var binaryOp = node[ndx] as BinaryExpression;
            var varDecl = previousVar[previousVar.Count - 1];
            LookupExpression lookup;
            BindingIdentifier bindingIdentifier;

            if (binaryOp != null
                && binaryOp.IsAssign
                && (lookup = binaryOp.Operand1 as LookupExpression) != null
                && lookup.VariableField != null
                && !ReferencesVisitor.References(binaryOp.Operand2, lookup)
                && (bindingIdentifier = varDecl.Binding as BindingIdentifier) != null
                && bindingIdentifier.VariableField == lookup.VariableField)
            {
                // the current statement is a binary operator assignment with a lookup on the left-hand side.
                // the previous statement is a var, the last vardecl is a simple binding identifier, and that identifier
                // is the same as the left-hand side of the assignment. 
                if (varDecl.Initializer != null)
                {
                    if (binaryOp.OperatorToken == JSToken.Assign)
                    {
                        // we have var name=expr1;name=expr2. If expr1 is a constant, we will
                        // get rid of it entirely and replace it with expr2. Otherwise we don't
                        // know about any side-effects, so just leave it be.
                        if (varDecl.Initializer.IsConstant)
                        {
                            // transform: var name=const;name=expr  ==> var name=expr
                            varDecl.Initializer = binaryOp.Operand2;

                            // getting rid of the lookup, so clean up its references
                            lookup.VariableField.IfNotNull(v => v.References.Remove(lookup));
                            node[ndx] = null;
                        }
                    }
                    else
                    {
                        // we have var name=expr1;name[OP]=expr2.
                        // transform: var name=expr1;name[OP]=expr2  ==>  var name=expr1[OP]expr2
                        // getting rid of the lookup, so clean up its references
                        lookup.VariableField.IfNotNull(v => v.References.Remove(lookup));

                        // reuse the binary op by stripping the assignment to just the operator,
                        // clobbering the lookup on operand1 with the vardecl assignment,
                        // and expanding the context to include the initializer.
                        binaryOp.OperatorToken = JSScanner.StripAssignment(binaryOp.OperatorToken);
                        binaryOp.Operand1 = varDecl.Initializer;
                        binaryOp.UpdateWith(binaryOp.Operand1.Context);

                        // set the adjusted binary op to the vardecl initializer and remove the
                        // current statement (that points to the binary op)
                        varDecl.Initializer = binaryOp;
                        node[ndx] = null;
                    }
                }
                else if (binaryOp.OperatorToken == JSToken.Assign)
                {
                    // transform: var name;name=expr  ==>  var name=expr
                    lookup.VariableField.IfNotNull(v => v.References.Remove(lookup));
                    varDecl.Initializer = binaryOp.Operand2;
                    node[ndx] = null;
                }
                else
                {
                    // we have var name;name[OP]=expr.
                    // leave it alone???? we could make var name=undefined[OP]expr1, if we have a good undefined value.
                }
            }
        }

        private static AstNode FindLastStatement(BlockStatement node)
        {
            // start with the last statement in the block and back up over any function declarations
            // or important comments until we get the last statement
            var lastStatementIndex = node.Count - 1;
            while (lastStatementIndex >= 0 
                && (node[lastStatementIndex] is FunctionObject || node[lastStatementIndex] is ImportantComment))
            {
                --lastStatementIndex;
            }

            return lastStatementIndex >= 0 ? node[lastStatementIndex] : null;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1809:AvoidExcessiveLocals"),
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling"),
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity"),
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode")]
        public override void Visit(BlockStatement node)
        {
            if (node != null)
            {
                // if this block has a BLOCK scope, then look at the lexically-declared names (if any)
                // and throw an error if any are defined as var's within this scope (ES6 rules).
                // if this is the body of a function object, use the function scope.
                ActivationObject lexicalScope = null;
                if (node.HasOwnScope)
                {
                    lexicalScope = node.EnclosingScope as BlockScope;
                    var functionObject = node.Parent as FunctionObject;
                    if (functionObject != null)
                    {
                        lexicalScope = functionObject.EnclosingScope;
                    }
                }

                if (lexicalScope != null)
                {
                    foreach (var lexDecl in lexicalScope.LexicallyDeclaredNames)
                    {
                        var varDecl = lexicalScope.VarDeclaredName(lexDecl.Name);
                        if (varDecl != null)
                        {
                            // collision.
                            // if the lexical declaration is a let or const declaration (as opposed to a function declaration),
                            // then force the warning to an error. This is so the function declaration will remain a warning if
                            // it collides with a var. 
                            varDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, lexDecl is LexicalDeclaration);

                            // mark them both a no-rename to preserve the collision in the output
                            lexDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                            varDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                        }
                    }
                }

                // we might things differently if these statements are the body collection for a function
                // because we can assume the implicit return statement at the end of it
                bool isFunctionLevel = (node.Parent is FunctionObject);

                // analyze all the statements in our block and recurse them
                if (node.HasOwnScope)
                {
                    m_scopeStack.Push(node.EnclosingScope);
                }

                var oldStrictError = m_strictNameError;
                try
                {
                    m_strictNameError = JSError.StrictModeVariableName;

                    // don't call the base class to recurse -- let's walk the block
                    // backwards in case any of the children opt to delete themselves.
                    for (var ndx = node.Count - 1; ndx >= 0; --ndx)
                    {
                        node[ndx].Accept(this);

                        // we can do this because we are walking backwards, and if the statement had deleted itself
                        // for whatever reason, the next one will slip into its place, and we've already seen it so
                        // it must not be debug only or we would've deleted it.
                        if (m_stripDebug && node.Count > ndx && node[ndx].IsDebugOnly)
                        {
                            node.RemoveAt(ndx);
                        }
                    }
                }
                finally
                {
                    m_strictNameError = oldStrictError;
                    if (node.HasOwnScope)
                    {
                        m_scopeStack.Pop();
                    }
                }

                if (m_parser.Settings.RemoveUnneededCode)
                {
                    // go forward, and check the count each iteration because we might be ADDING statements to the block.
                    // let's look at all our if-statements. If a true-clause ends in a return, then we don't
                    // need the else-clause; we can pull its statements out and stick them after the if-statement.
                    // also, if we encounter a return-, break- or continue-statement, we can axe everything after it
                    for (var ndx = 0; ndx < node.Count; ++ndx)
                    {
                        // see if it's an if-statement with both a true and a false block
                        var ifNode = node[ndx] as IfStatement;
                        if (ifNode?.TrueBlock != null
                            && ifNode.TrueBlock.Count > 0
                            && ifNode.FalseBlock != null)
                        {
                            // now check to see if the true block ends in a return statement
                            if (ifNode.TrueBlock[ifNode.TrueBlock.Count - 1] is ReturnStatement)
                            {
                                // transform: if(cond){statements1;return}else{statements2} to if(cond){statements1;return}statements2
                                // it does. insert all the false-block statements after the if-statement
                                node.InsertRange(ndx + 1, ifNode.FalseBlock.Children);

                                // and then remove the false block altogether
                                ifNode.FalseBlock = null;
                            }
                        }
                        else if (node[ndx] is ReturnStatement
                            || node[ndx] is BreakStatement
                            || node[ndx] is ContinueStatement
                            || node[ndx] is ThrowStatement)
                        {
                            // we have an exit node -- no statments afterwards will be executed, so clear them out.
                            // transform: {...;return;...} to {...;return}
                            // transform: {...;break;...} to {...;break}
                            // transform: {...;continue;...} to {...;continue}
                            // transform: {...;throw;...} to {...;throw}
                            // we've found an exit statement, and it's not the last statement in the function.
                            // walk the rest of the statements and delete anything that isn't a function declaration
                            // or a var- or const-statement.
                            for (var ndxRemove = node.Count - 1; ndxRemove > ndx; --ndxRemove)
                            {
                                if (node[ndxRemove].IsDeclaration)
                                {
                                    // we want to keep this statement because it's a "declaration."
                                    // HOWEVER, if this is a var or a let, let's whack the initializer, since it will 
                                    // never get executed. Leave the initializers for const statements, even though 
                                    // they will never get run, since it would be a syntax error to not have one.
                                    var declaration = node[ndxRemove] as Declaration;
                                    if (declaration != null && declaration.StatementToken != JSToken.Const)
                                    {
                                        for (var ndxDecl = 0; ndxDecl < declaration.Count; ++ndxDecl)
                                        {
                                            if (declaration[ndxDecl].Initializer != null)
                                            {
                                                DetachReferencesVisitor.Apply(declaration[ndxDecl].Initializer);
                                                declaration[ndxDecl].Initializer = null;
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    // not a declaration -- remove it
                                    DetachReferencesVisitor.Apply(node[ndxRemove]);
                                    node.RemoveAt(ndxRemove);
                                }
                            }
                        }
                    }
                }

                // now check the last statement -- if it's an if-statement where the true-block is a single return
                // and there is no false block, convert this one statement to a conditional. We might back it out later
                // if we don't combine the conditional with other stuff.
                // but we can only do this if we're at the functional level because of the implied return at the end
                // of that block.
                if (isFunctionLevel && node.Count > 0
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionReturnToCondition))
                {
                    ReturnStatement returnNode;
                    var ifNode = FindLastStatement(node) as IfStatement;
                    if (ifNode != null && ifNode.FalseBlock == null
                        && ifNode.TrueBlock.Count == 1
                        && (returnNode = ifNode.TrueBlock[0] as ReturnStatement) != null)
                    {
                        // if the return node doesn't have an operand, then we can just replace the if-statement with its conditional
                        if (returnNode.Operand == null)
                        {
                            // if the condition is a constant, then eliminate it altogether
                            if (ifNode.Condition.IsConstant)
                            {
                                // delete the node altogether. Because the condition is a constant,
                                // there is no else-block, and the if-block only contains a return
                                // with no expression, we don't have anything to detach.
                                node.ReplaceChild(ifNode, null);
                            }
                            else
                            {
                                // transform: {...;if(cond)return;} to {...;cond;}
                                node.ReplaceChild(ifNode, ifNode.Condition);
                            }
                        }
                        else if (returnNode.Operand.IsExpression)
                        {
                            // this is a strategic replacement that might pay off later. And if
                            // it doesn't, we'll eventually back it out after all the other stuff
                            // if applied on top of it.
                            // transform: if(cond)return expr;} to return cond?expr:void 0}
                            var conditional = new Conditional(ifNode.Condition.Context.FlattenToStart())
                                {
                                    Condition = ifNode.Condition,
                                    TrueExpression = returnNode.Operand,
                                    FalseExpression = CreateVoidNode(returnNode.Context.FlattenToStart())
                                };

                            // replace the if-statement with the new return node
                            node.ReplaceChild(ifNode, new ReturnStatement(ifNode.Context)
                                {
                                    Operand = conditional
                                });
                            Optimize(conditional);
                        }
                    }
                }

                // now walk through and combine adjacent expression statements, and adjacent var-for statements
                // and adjecent expression-return statements
                if (m_parser.Settings.IsModificationAllowed(TreeModifications.CombineAdjacentExpressionStatements))
                {
                    CombineExpressions(node);
                }

                // check to see if we want to combine a preceding var with a for-statement
                if (m_parser.Settings.IsModificationAllowed(TreeModifications.MoveVarIntoFor))
                {
                    // look at the statements in the block. 
                    // walk BACKWARDS down the list because we'll be removing items when we encounter
                    // var statements that can be moved inside a for statement's initializer
                    // we also don't need to check the first one, since there is nothing before it.
                    for (int ndx = node.Count - 1; ndx > 0; --ndx)
                    {
                        // see if the previous statement is a var statement
                        // (we've already combined adjacent var-statements)
                        ForStatement forStatement;
                        ForInStatement forInNode;
                        WhileStatement whileNode;
                        var previousVar = node[ndx - 1] as VarDeclaration;
                        if (previousVar != null && (forStatement = node[ndx] as ForStatement) != null)
                        {
                            // BUT if the var statement has any initializers containing an in-operator, first check
                            // to see if we haven't killed that move before we try moving it. Opera 11 seems to have
                            // an issue with that syntax, even if properly parenthesized.
                            if (m_parser.Settings.IsModificationAllowed(TreeModifications.MoveInExpressionsIntoForStatement)
                                || !previousVar.ContainsInOperator)
                            {
                                // and see if the ForStatement's initializer is empty
                                if (forStatement.Initializer != null)
                                {
                                    // not empty -- see if it is a Var node
                                    VarDeclaration varInitializer = forStatement.Initializer as VarDeclaration;
                                    if (varInitializer != null)
                                    {
                                        // transform: var decls1;for(var decls2;...) to for(var decls1,decls2;...)
                                        // we want to PREPEND the initializers in the previous var-statement
                                        // to our for-statement's initializer var-statement list
                                        varInitializer.InsertAt(0, previousVar);

                                        // then remove the previous var statement
                                        node.RemoveAt(ndx - 1);
                                        // this will bump the for node up one position in the list, so the next iteration
                                        // will be right back on this node in case there are other var statements we need
                                        // to combine
                                    }
                                    else
                                    {
                                        // we want to see if the initializer expression is a series of one or more
                                        // simple assignments to variables that are in the previous var statement.
                                        // if all the expressions are assignments to variables that are defined in the
                                        // previous var statement, then we can just move the var statement into the 
                                        // for statement.
                                        var binaryOp = forStatement.Initializer as BinaryExpression;
                                        if (binaryOp != null && AreAssignmentsInVar(binaryOp, previousVar))
                                        {
                                            // transform: var decls;for(expr1;...) to for(var decls,expr1;...)
                                            // WHERE expr1 only consists of assignments to variables that are declared
                                            // in that previous var-statement.
                                            // TODO: we *could* also do it is the expr1 assignments are to lookups that are
                                            // defined in THIS scope (not any outer scopes), because it wouldn't hurt to have
                                            // then in a var statement again.
                                            // create a list and fill it with all the var-decls created from the assignment
                                            // operators in the expression
                                            ConvertAssignmentsToVarDecls(binaryOp, previousVar, m_parser);

                                            // move the previous var-statement into our initializer
                                            forStatement.Initializer = previousVar;

                                            // and remove the previous var-statement from the list.
                                            node.RemoveAt(ndx - 1);

                                            // this will bump the for node up one position in the list, so the next iteration
                                            // will be right back on this node, but the initializer will not be null
                                        }
                                    }
                                }
                                else
                                {
                                    // transform: var decls;for(;...) to for(var decls;...)
                                    // if it's empty, then we're free to add the previous var statement
                                    // to this for statement's initializer. remove it from it's current
                                    // position and add it as the initializer
                                    node.RemoveAt(ndx - 1);
                                    forStatement.Initializer = previousVar;
                                    // this will bump the for node up one position in the list, so the next iteration
                                    // will be right back on this node, but the initializer will not be null
                                }
                            }
                        }
                        else if (previousVar != null 
                            && (whileNode = node[ndx] as WhileStatement) != null
                            && m_parser.Settings.IsModificationAllowed(TreeModifications.ChangeWhileToFor))
                        {
                            // transform: var ...;while(cond)... => for(var ...;cond;)...
                            node[ndx] = new ForStatement(whileNode.Context.FlattenToStart())
                                {
                                    Initializer = previousVar,
                                    Condition = whileNode.Condition,
                                    Body = whileNode.Body
                                };
                            node.RemoveAt(ndx - 1);
                        }
                        else if (previousVar != null
                            && (forInNode = node[ndx] as ForInStatement) != null)
                        {
                            // if the for-in's variable field is not a declaration, we should check to see
                            // if there is a single named reference, and whether the previous var's last declaration
                            // is for the same var. If so, we can move that declaration into the for-in.
                            if (!(forInNode.Variable is Declaration))
                            {
                                // now see if the LAST vardecl in the previous var statement is the 
                                // same field(s) as the variable, and there was either no initializer
                                // or the initializer was a constant ('cause we're going to kill it).
                                var lastDecl = previousVar[previousVar.Count - 1];
                                if (lastDecl.IsEquivalentTo(forInNode.Variable)
                                    && (lastDecl.Initializer == null || lastDecl.Initializer.IsConstant))
                                {
                                    // convert the reference inside the for-in to a declaration binding.
                                    // set the previous decl's binding to this new binding, delete any
                                    // initializer, and move the vardecl into the for-in.
                                    // Be sure to clean up the var-statement if it's now empty.
                                    var newBinding = BindingTransform.ToBinding(forInNode.Variable);
                                    if (newBinding != null)
                                    {
                                        var newVarDecl = new VariableDeclaration(forInNode.Variable.Context.Clone())
                                            {
                                                Binding = newBinding,
                                            };
                                        var newVar = new VarDeclaration(forInNode.Variable.Context.Clone());
                                        newVar.Append(newVarDecl);
                                        forInNode.Variable = newVar;

                                        // clean up that last declaration, which might go all the way
                                        // up to the statement if removing it leaves the statement empty.
                                        // but ONLY remove declarations that are in the new for-binding.
                                        var oldBindings = BindingsVisitor.Bindings(lastDecl.Binding);
                                        foreach (var newName in BindingsVisitor.Bindings(newBinding))
                                        {
                                            foreach (var oldName in oldBindings)
                                            {
                                                if (oldName.IsEquivalentTo(newName))
                                                {
                                                    ActivationObject.RemoveBinding(oldName);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // see if the last statement is a return statement
                ReturnStatement lastReturn;
                if ((lastReturn = FindLastStatement(node) as ReturnStatement) != null)
                {
                    // set this flag to true if we end up adding an expression to the block.
                    // before exiting, we'll go through and combine adjacent expressions again if this
                    // flag has been set to true.
                    bool changedStatementToExpression = false;

                    // get the index of the statement before the last return
                    // (skip over function decls and importand comments)
                    var indexPrevious = PreviousStatementIndex(node, lastReturn);

                    // just out of curiosity, let's see if we fit a common pattern:
                    //      var name=expr;return name;
                    // or
                    //      const name=expr;return name;
                    // if so, we can cut out the var and simply return the expression
                    LookupExpression lookup;
                    if ((lookup = lastReturn.Operand as LookupExpression) != null && indexPrevious >= 0)
                    {
                        // use the base class for both the var- and const-statements so we will
                        // pick them both up at the same time
                        var varStatement = node[indexPrevious] as Declaration;
                        if (varStatement != null)
                        {
                            // if the last vardecl in the var statement matches the return lookup, and no
                            // other references exist for this field (refcount == 1)...
                            var varDecl = varStatement[varStatement.Count - 1];
                            if (varDecl.Initializer != null
                                && varDecl.IsEquivalentTo(lookup))
                            {
                                // we only care about simple binding identifiers
                                var bindingIdentifier = varDecl.Binding as BindingIdentifier;
                                if (bindingIdentifier != null
                                    && bindingIdentifier.VariableField.IfNotNull(v => v.RefCount == 1))
                                {
                                    // clean up the field's references because we're removing both the lookup reference
                                    // in the return statement and the vardecl.
                                    bindingIdentifier.VariableField.References.Remove(lookup);
                                    bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);

                                    if (varStatement.Count == 1)
                                    {
                                        // transform: ...;var name=expr;return name} to ...;return expr}
                                        // there's only one vardecl in the var, so get rid of the entire statement
                                        lastReturn.Operand = varDecl.Initializer;
                                        node.RemoveAt(indexPrevious);
                                    }
                                    else
                                    {
                                        // multiple vardecls are in the statement; we only need to get rid of the last one
                                        lastReturn.Operand = varDecl.Initializer;
                                        varStatement[varStatement.Count - 1] = null;
                                    }
                                }
                            }
                        }
                    }

                    // check to see if we can combine the return statement with a previous if-statement
                    // into a simple return-conditional. The true statement needs to have no false block,
                    // and only one statement in the true block.
                    Conditional conditional;
                    IfStatement previousIf;
                    while (indexPrevious >= 0 
                        && lastReturn != null
                        && (previousIf = node[indexPrevious] as IfStatement) != null
                        && previousIf.TrueBlock != null && previousIf.TrueBlock.Count == 1
                        && previousIf.FalseBlock == null)
                    {
                        // assume no change is made for this loop
                        bool somethingChanged = false;

                        // and that one true-block statement needs to be a return statement
                        var previousReturn = previousIf.TrueBlock[0] as ReturnStatement;
                        if (previousReturn != null)
                        {
                            if (lastReturn.Operand == null)
                            {
                                if (previousReturn.Operand == null)
                                {
                                    // IF we are at the function level, then the block ends in an implicit return (undefined)
                                    // and we can change this if to just the condition. If we aren't at the function level,
                                    // then we have to leave the return, but we can replace the if with just the condition.
                                    if (!isFunctionLevel)
                                    {
                                        // not at the function level, so the return must stay.
                                        if (previousIf.Condition.IsConstant)
                                        {
                                            // transform: if(cond)return;return} to return}
                                            node.RemoveAt(indexPrevious);
                                            somethingChanged = true;
                                        }
                                        else
                                        {
                                            // transform: if(cond)return;return} to cond;return}
                                            node[indexPrevious] = previousIf.Condition;
                                        }
                                    }
                                    else if (previousIf.Condition.IsConstant)
                                    {
                                        // transform: remove if(cond)return;return} because cond is a constant
                                        node.ReplaceChild(lastReturn, null);
                                        node.RemoveAt(indexPrevious);
                                        somethingChanged = true;
                                    }
                                    else
                                    {
                                        // transform: if(cond)return;return} to cond}
                                        // replace the final return with just the condition, then remove the previous if
                                        if (node.ReplaceChild(lastReturn, previousIf.Condition))
                                        {
                                            node.RemoveAt(indexPrevious);
                                            somethingChanged = true;
                                        }
                                    }
                                }
                                else
                                {
                                    // transform: if(cond)return expr;return} to return cond?expr:void 0
                                    conditional = new Conditional(previousIf.Condition.Context.FlattenToStart())
                                        {
                                            Condition = previousIf.Condition,
                                            TrueExpression = previousReturn.Operand,
                                            FalseExpression = CreateVoidNode(previousReturn.Context.FlattenToStart())
                                        };

                                    // replace the final return with the new return, then delete the previous if-statement
                                    if (node.ReplaceChild(lastReturn, new ReturnStatement(previousReturn.Context.FlattenToStart())
                                        {
                                            Operand = conditional
                                        }))
                                    {
                                        node.RemoveAt(indexPrevious);
                                        Optimize(conditional);
                                        somethingChanged = true;
                                    }
                                }
                            }
                            else
                            {
                                if (previousReturn.Operand == null)
                                {
                                    // transform: if(cond)return;return expr} to return cond?void 0:expr
                                    conditional = new Conditional(previousIf.Condition.Context.FlattenToStart())
                                        {
                                            Condition = previousIf.Condition,
                                            TrueExpression = CreateVoidNode(lastReturn.Context.FlattenToStart()),
                                            FalseExpression = lastReturn.Operand
                                        };

                                    // replace the final return with the new return, then delete the previous if-statement
                                    if (node.ReplaceChild(lastReturn, new ReturnStatement(lastReturn.Context.FlattenToStart())
                                        {
                                            Operand = conditional
                                        }))
                                    {
                                        node.RemoveAt(indexPrevious);
                                        Optimize(conditional);
                                        somethingChanged = true;
                                    }
                                }
                                else if (previousReturn.Operand.IsEquivalentTo(lastReturn.Operand))
                                {
                                    if (previousIf.Condition.IsConstant)
                                    {
                                        // the condition is constant, and the returns return the same thing.
                                        // get rid of the if statement altogether.
                                        // transform: if(cond)return expr;return expr} to return expr}
                                        DetachReferencesVisitor.Apply(previousReturn.Operand);
                                        node.RemoveAt(indexPrevious);
                                        somethingChanged = true;
                                    }
                                    else
                                    {
                                        // transform: if(cond)return expr;return expr} to return cond,expr}
                                        // create a new binary op with the condition and the final-return operand,
                                        // replace the operand on the final-return with the new binary operator,
                                        // and then delete the previous if-statement
                                        DetachReferencesVisitor.Apply(previousReturn.Operand);
                                        lastReturn.Operand = CommaExpression.CombineWithComma(previousIf.Condition.Context.FlattenToStart(), previousIf.Condition, lastReturn.Operand);
                                        node.RemoveAt(indexPrevious);
                                        somethingChanged = true;
                                    }
                                }
                                else
                                {
                                    // transform: if(cond)return expr1;return expr2} to return cond?expr1:expr2}
                                    // create a new conditional with the condition and the return operands,
                                    // replace the operand on the final-return with the new conditional operator,
                                    // and then delete the previous if-statement
                                    // transform: if(cond)return expr1;return expr2} to return cond?expr1:expr2}
                                    conditional = new Conditional(previousIf.Condition.Context.FlattenToStart())
                                        {
                                            Condition = previousIf.Condition,
                                            TrueExpression = previousReturn.Operand,
                                            FalseExpression = lastReturn.Operand
                                        };

                                    // replace the operand on the final-return with the new conditional operator,
                                    // and then delete the previous if-statement
                                    lastReturn.Operand = conditional;
                                    node.RemoveAt(indexPrevious);
                                    Optimize(conditional);
                                    somethingChanged = true;
                                }
                            }
                        }

                        if (!somethingChanged)
                        {
                            // nothing changed -- break out of the loop
                            break;
                        }
                        else
                        {
                            // set the flag that indicates something changed in at least one of these loops
                            changedStatementToExpression = true;
                            
                            // and since we changed something, we need to bump the index down one
                            // AFTER we grab the last return node (which has slipped into the same position
                            // as the previous node)
                            lastReturn = node[indexPrevious--] as ReturnStatement;
                        }
                    }

                    // if we added any more expressions since we ran our expression-combination logic, 
                    // run it again.
                    if (changedStatementToExpression
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.CombineAdjacentExpressionStatements))
                    {
                        CombineExpressions(node);
                    }

                    // and FINALLY, we want to see if what we did previously didn't pan out and we end
                    // in something like return cond?expr:void 0, in which case we want to change it
                    // back to a simple if(condition)return expr; (saves four bytes).
                    // see if the last statement is a return statement that returns a conditional
                    if (lastReturn != null
                        && (conditional = lastReturn.Operand as Conditional) != null)
                    {
                        var unaryOperator = conditional.FalseExpression as UnaryExpression;
                        if (unaryOperator != null 
                            && unaryOperator.OperatorToken == JSToken.Void
                            && unaryOperator.Operand is ConstantWrapper)
                        {
                            unaryOperator = conditional.TrueExpression as UnaryExpression;
                            if (unaryOperator != null && unaryOperator.OperatorToken == JSToken.Void)
                            {
                                if (isFunctionLevel)
                                {
                                    // transform: ...;return cond?void 0:void 0} to ...;cond}
                                    // function level ends in an implicit "return void 0"
                                    node.ReplaceChild(lastReturn, conditional.Condition);
                                }
                                else
                                {
                                    // transform: ...;return cond?void 0:void 0} to ...;cond;return}
                                    // non-function level doesn't end in an implicit return,
                                    // so we need to break them out into two statements
                                    node.ReplaceChild(lastReturn, conditional.Condition);
                                    node.Append(new ReturnStatement(lastReturn.Context.Clone()));
                                }
                            }
                            else if (isFunctionLevel)
                            {
                                // transform: ...;return cond?expr:void 0} to ...;if(cond)return expr}
                                // (only works at the function-level because of the implicit return statement)
                                var ifNode = new IfStatement(lastReturn.Context)
                                    {
                                        Condition = conditional.Condition,
                                        TrueBlock = AstNode.ForceToBlock(new ReturnStatement(lastReturn.Context.Clone())
                                            {
                                                Operand = conditional.TrueExpression
                                            })
                                    };
                                node.ReplaceChild(lastReturn, ifNode);
                            }
                        }
                        else if (isFunctionLevel)
                        {
                            unaryOperator = conditional.TrueExpression as UnaryExpression;
                            if (unaryOperator != null 
                                && unaryOperator.OperatorToken == JSToken.Void
                                && unaryOperator.Operand is ConstantWrapper)
                            {
                                // transform: ...;return cond?void 0;expr} to ...;if(!cond)return expr}
                                // (only works at the function level because of the implicit return)
                                // get the logical-not of the conditional
                                var logicalNot = new LogicalNotVisitor(conditional.Condition, m_parser.Settings);
                                logicalNot.Apply();

                                // create a new if-node based on the condition, with the branches swapped 
                                // (true-expression goes to false-branch, false-expression goes to true-branch
                                var ifNode = new IfStatement(lastReturn.Context)
                                    {
                                        Condition = conditional.Condition,
                                        TrueBlock = AstNode.ForceToBlock(new ReturnStatement(lastReturn.Context.Clone())
                                            {
                                                Operand = conditional.FalseExpression
                                            })
                                    };
                                node.ReplaceChild(lastReturn, ifNode);
                            }
                        }
                    }
                }

                if (m_parser.Settings.IsModificationAllowed(TreeModifications.CombineEquivalentIfReturns))
                {
                    // walk backwards looking for if(cond1)return expr1;if(cond2)return expr2;
                    // (backwards, because we'll be combining those into one statement, reducing the number of statements.
                    // don't go all the way to zero, because each loop will compare the statement to the PREVIOUS
                    // statement, and the first statement (index==0) has no previous statement.
                    for (var ndx = node.Count - 1; ndx > 0; --ndx)
                    {
                        // see if the current statement is an if-statement with no else block, and a true
                        // block that contains a single return-statement WITH an expression.
                        AstNode currentExpr = null;
                        AstNode condition2;
                        if (IsIfReturnExpr(node[ndx], out condition2, ref currentExpr) != null)
                        {
                            // see if the previous statement is also the same pattern, but with
                            // the equivalent expression as its return operand
                            AstNode condition1;
                            var matchedExpression = currentExpr;
                            var ifNode = IsIfReturnExpr(node[ndx - 1], out condition1, ref matchedExpression);
                            if (ifNode != null)
                            {
                                // it is a match!
                                // let's combine them -- we'll add the current condition to the
                                // previous condition with a logical-or and delete the current statement.
                                // transform: if(cond1)return expr;if(cond2)return expr; to if(cond1||cond2)return expr;
                                ifNode.Condition = new BinaryExpression(condition1.Context.FlattenToStart())
                                    {
                                        Operand1 = condition1,
                                        Operand2 = condition2,
                                        OperatorToken = JSToken.LogicalOr,
                                        TerminatingContext = ifNode.TerminatingContext ?? node.TerminatingContext
                                    };
                                DetachReferencesVisitor.Apply(currentExpr);
                                node.RemoveAt(ndx);
                            }
                        }
                    }
                }

                if (isFunctionLevel
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.InvertIfReturn))
                {
                    // walk backwards looking for if (cond) return; whenever we encounter that statement,
                    // we can change it to if (!cond) and put all subsequent statements in the block inside the
                    // if's true-block.
                    for (var ndx = node.Count - 1; ndx >= 0; --ndx)
                    {
                        var ifNode = node[ndx] as IfStatement;
                        if (ifNode != null
                            && ifNode.FalseBlock == null
                            && ifNode.TrueBlock != null
                            && ifNode.TrueBlock.Count == 1)
                        {
                            var returnNode = ifNode.TrueBlock[0] as ReturnStatement;
                            if (returnNode != null && returnNode.Operand == null)
                            {
                                // we have if(cond)return;
                                // logical-not the condition, remove the return statement,
                                // and move all subsequent sibling statements inside the if-statement.
                                LogicalNotVisitor.Apply(ifNode.Condition, m_parser.Settings);
                                ifNode.TrueBlock.Clear();

                                var ndxMove = ndx + 1;
                                if (node.Count == ndxMove + 1)
                                {
                                    // there's only one statement after our if-node.
                                    // see if it's ALSO an if-node with no else block.
                                    var secondIfNode = node[ndxMove] as IfStatement;
                                    if (secondIfNode != null && (secondIfNode.FalseBlock == null || secondIfNode.FalseBlock.Count == 0))
                                    {
                                        // it is!
                                        // transform: if(cond1)return;if(cond2){...} => if(!cond1&&cond2){...}
                                        // (the cond1 is already inverted at this point)
                                        // combine cond2 with cond1 via a logical-and,
                                        // move all secondIf statements inside the if-node,
                                        // remove the secondIf node.
                                        node.RemoveAt(ndxMove);
                                        ifNode.Condition = new BinaryExpression(ifNode.Condition.Context.FlattenToStart())
                                            {
                                                Operand1 = ifNode.Condition,
                                                Operand2 = secondIfNode.Condition,
                                                OperatorToken = JSToken.LogicalAnd
                                            };

                                        ifNode.TrueBlock = secondIfNode.TrueBlock;
                                    }
                                    else if (node[ndxMove].IsExpression
                                        && m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionCallToConditionAndCall))
                                    {
                                        // now we have if(cond)expr; optimize that!
                                        var expression = node[ndxMove];
                                        node.RemoveAt(ndxMove);
                                        IfConditionExpressionToExpression(ifNode, expression);
                                    }
                                }

                                // just move all the following statements inside the if-statement
                                while (node.Count > ndxMove)
                                {
                                    var movedNode = node[ndxMove];
                                    node.RemoveAt(ndxMove);
                                    ifNode.TrueBlock.Append(movedNode);
                                }
                            }
                        }
                    }
                }
                else
                {
                    var isIteratorBlock = node.Parent is ForStatement
                        || node.Parent is ForInStatement
                        || node.Parent is WhileStatement
                        || node.Parent is DoWhileStatement;

                    if (isIteratorBlock
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.InvertIfContinue))
                    {
                        // walk backwards looking for if (cond) continue; whenever we encounter that statement,
                        // we can change it to if (!cond) and put all subsequent statements in the block inside the
                        // if's true-block.
                        for (var ndx = node.Count - 1; ndx >= 0; --ndx)
                        {
                            var ifNode = node[ndx] as IfStatement;
                            if (ifNode != null
                                && ifNode.FalseBlock == null
                                && ifNode.TrueBlock != null
                                && ifNode.TrueBlock.Count == 1)
                            {
                                var continueNode = ifNode.TrueBlock[0] as ContinueStatement;

                                // if there's no label, then we're good. Otherwise we can only make this optimization
                                // if the label refers to the parent iterator node.
                                if (continueNode != null 
                                    && (string.IsNullOrEmpty(continueNode.Label) || (LabelMatchesParent(continueNode.Label, node.Parent))))
                                {
                                    // if this is the last statement, then we don't really need the if at all
                                    // and can just replace it with its condition
                                    if (ndx < node.Count - 1)
                                    {
                                        // we have if(cond)continue;st1;...stn;
                                        // logical-not the condition, remove the continue statement,
                                        // and move all subsequent sibling statements inside the if-statement.
                                        LogicalNotVisitor.Apply(ifNode.Condition, m_parser.Settings);
                                        ifNode.TrueBlock.Clear();

                                        // TODO: if we removed a labeled continue, do we need to fix up some label references?

                                        var ndxMove = ndx + 1;
                                        if (node.Count == ndxMove + 1)
                                        {
                                            // there's only one statement after our if-node.
                                            // see if it's ALSO an if-node with no else block.
                                            var secondIfNode = node[ndxMove] as IfStatement;
                                            if (secondIfNode != null && (secondIfNode.FalseBlock == null || secondIfNode.FalseBlock.Count == 0))
                                            {
                                                // it is!
                                                // transform: if(cond1)continue;if(cond2){...} => if(!cond1&&cond2){...}
                                                // (the cond1 is already inverted at this point)
                                                // combine cond2 with cond1 via a logical-and,
                                                // move all secondIf statements inside the if-node,
                                                // remove the secondIf node.
                                                ifNode.Condition = new BinaryExpression(ifNode.Condition.Context.FlattenToStart())
                                                    {
                                                        Operand1 = ifNode.Condition,
                                                        Operand2 = secondIfNode.Condition,
                                                        OperatorToken = JSToken.LogicalAnd
                                                    };

                                                ifNode.TrueBlock = secondIfNode.TrueBlock;
                                                node.RemoveAt(ndxMove);
                                            }
                                            else if (node[ndxMove].IsExpression
                                                && m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionCallToConditionAndCall))
                                            {
                                                // now we have if(cond)expr; optimize that!
                                                var expression = node[ndxMove];
                                                node.RemoveAt(ndxMove);
                                                IfConditionExpressionToExpression(ifNode, expression);
                                            }
                                        }

                                        // just move all the following statements inside the if-statement
                                        while (node.Count > ndxMove)
                                        {
                                            var movedNode = node[ndxMove];
                                            node.RemoveAt(ndxMove);
                                            ifNode.TrueBlock.Append(movedNode);
                                        }
                                    }
                                    else
                                    {
                                        // we have if(cond)continue} -- nothing after the if.
                                        // the loop is going to continue anyway, so replace the if-statement
                                        // with the condition and be done
                                        if (ifNode.Condition.IsConstant)
                                        {
                                            // consition is constant -- get rid of the if-statement altogether
                                            node.RemoveAt(ndx);
                                        }
                                        else
                                        {
                                            // condition isn't constant
                                            node[ndx] = ifNode.Condition;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        private static bool LabelMatchesParent(string label, AstNode parentNode)
        {
            var isMatch = false;

            // see if the parent's parent is a labeled statement
            LabeledStatement labeledStatement;
            while ((labeledStatement = parentNode.Parent as LabeledStatement) != null)
            {
                // see if the label we are looking for matches the labeled statement
                if (string.CompareOrdinal(label, labeledStatement.Label) == 0)
                {
                    // it's a match -- we're done
                    isMatch = true;
                    break;
                }

                // try the next node up (a labeled statement can itself be labeled)
                parentNode = labeledStatement;
            }
            return isMatch;
        }

        private static IfStatement IsIfReturnExpr(AstNode node, out AstNode condition, ref AstNode matchExpression)
        {
            // set the condition to null initially
            condition = null;

            // must be an if-node with no false block, and a true block with one statement
            var ifNode = node as IfStatement;
            if (ifNode != null
                && ifNode.FalseBlock == null
                && ifNode.TrueBlock != null
                && ifNode.TrueBlock.Count == 1)
            {
                // and that one statement needs to be a return statement
                var returnNode = ifNode.TrueBlock[0] as ReturnStatement;
                if (returnNode != null)
                {
                    if (matchExpression == null
                        || matchExpression.IsEquivalentTo(returnNode.Operand))
                    {
                        // either we don't care what the return expression is,
                        // or we do care and it's a match.
                        matchExpression = returnNode.Operand;
                        condition = ifNode.Condition;
                    }
                }
            }

            // but we will only return the if-node IF the matchedExpression and the
            // condition are both non-null (our TRUE state)
            return condition != null && matchExpression != null ? ifNode : null;
        }

        private static int PreviousStatementIndex(BlockStatement node, AstNode child)
        {
            // get the index of the statement before the last return
            // (skip over function decls and importand comments)
            var indexPrevious = node.IndexOf(child) - 1;
            while (indexPrevious >= 0 && (node[indexPrevious] is FunctionObject || node[indexPrevious] is ImportantComment))
            {
                --indexPrevious;
            }

            return indexPrevious;
        }

        public override void Visit(BreakStatement node)
        {
            if (node != null)
            {
                // if the label isn't valid an we can remove them, remove it now
                if (!node.Label.IsNullOrWhiteSpace()
                    && node.LabelInfo == null
                    && m_parser.Settings.RemoveUnneededCode
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryLabels))
                {
                    node.Label = null;
                }

                // check the break is inside a loop or in a label block
                if (!IsInsideLoop(node, true) && (node.Label == null || !IsInsideLabel(node, node.Label)))
                {
                    node.Context.HandleError(JSError.BadBreak, true);
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(CallExpression node)
        {
            if (node != null)
            {
                // see if this is a member (we'll need it for a couple checks)
                MemberExpression member = node.Function as MemberExpression;
                LookupExpression lookup;

                // if this is a constructor and we want to collapse
                // some of them to literals...
                if (node.IsConstructor)
                {
                    // array function as new operands will probably be wrapped in parens
                    var funcObject = node.Function as FunctionObject;
                    if (funcObject != null || (funcObject = (node.Function as GroupingOperator).IfNotNull(g => g.Operand as FunctionObject)) != null)
                    {
                        if (funcObject.FunctionType == FunctionType.ArrowFunction)
                        {
                            // arrow functions can't be constructors, and we explicitly have one here.
                            // throw an error
                            node.Function.Context.HandleError(JSError.ArrowCannotBeConstructor, true);
                        }
                    }
                    else if (m_parser.Settings.CollapseToLiteral)
                    {
                        // see if this is a lookup, and if so, if it's pointing to one
                        // of the two constructors we want to collapse
                        lookup = node.Function as LookupExpression;
                        if (lookup != null)
                        {
                            if (lookup.Name == "Object"
                                && m_parser.Settings.IsModificationAllowed(TreeModifications.NewObjectToObjectLiteral))
                            {
                                // no arguments -- the Object constructor with no arguments is the exact same as an empty
                                // object literal
                                if (node.Arguments == null || node.Arguments.Count == 0)
                                {
                                    // replace our node with an object literal
                                    var objLiteral = new ObjectLiteral(node.Context);
                                    if (node.Parent.ReplaceChild(node, objLiteral))
                                    {
                                        // and bail now. No need to recurse -- it's an empty literal
                                        return;
                                    }
                                }
                                else if (node.Arguments.Count == 1)
                                {
                                    // one argument
                                    // check to see if it's an object literal.
                                    var objectLiteral = node.Arguments[0] as ObjectLiteral;
                                    if (objectLiteral != null)
                                    {
                                        // the Object constructor with an argument that is a JavaScript object merely returns the
                                        // argument. Since the argument is an object literal, it is by definition a JavaScript object
                                        // and therefore we can replace the constructor call with the object literal
                                        node.Parent.ReplaceChild(node, objectLiteral);

                                        // don't forget to recurse the object now
                                        objectLiteral.Accept(this);

                                        // and then bail -- we don't want to process this call
                                        // operation any more; we've gotten rid of it
                                        return;
                                    }
                                }
                            }
                            else if (lookup.Name == "Array"
                                && m_parser.Settings.IsModificationAllowed(TreeModifications.NewArrayToArrayLiteral))
                            {
                                // Array is trickier. 
                                // If there are no arguments, then just use [].
                                // if there are multiple arguments, then use [arg0,arg1...argN].
                                // but if there is one argument and it's numeric, we can't crunch it.
                                // also can't crunch if it's a function call or a member or something, since we won't
                                // KNOW whether or not it's numeric.
                                //
                                // so first see if it even is a single-argument constant wrapper. 
                                ConstantWrapper constWrapper = (node.Arguments != null && node.Arguments.Count == 1
                                    ? node.Arguments[0] as ConstantWrapper
                                    : null);

                                // if the argument count is not one, then we crunch.
                                // if the argument count IS one, we only crunch if we have a constant wrapper, 
                                // AND it's not numeric.
                                if (node.Arguments == null
                                  || node.Arguments.Count != 1
                                  || (constWrapper != null && !constWrapper.IsNumericLiteral))
                                {
                                    // create the new array literal object
                                    var arrayLiteral = new ArrayLiteral(node.Context)
                                        {
                                            Elements = node.Arguments
                                        };

                                    // replace ourself within our parent
                                    if (node.Parent.ReplaceChild(node, arrayLiteral))
                                    {
                                        // recurse
                                        arrayLiteral.Accept(this);
                                        // and bail -- we don't want to recurse this node any more
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }

                // if we are replacing resource references with strings generated from resource files
                // and this is a brackets call: lookup[args]
                var resourceList = m_parser.Settings.ResourceStrings;
                if (node.InBrackets && resourceList.Count > 0)
                {
                    // if we don't have a match visitor, create it now
                    if (m_matchVisitor == null)
                    {
                        m_matchVisitor = new MatchPropertiesVisitor();
                    }

                    // check each resource strings object to see if we have a match.
                    // Walk the list BACKWARDS so that later resource string definitions supercede previous ones.
                    for (var ndx = resourceList.Count - 1; ndx >= 0; --ndx)
                    {
                        var resourceStrings = resourceList[ndx];

                        // check to see if the resource strings name matches the function
                        if (resourceStrings != null && m_matchVisitor.Match(node.Function, resourceStrings.Name))
                        {
                            // we're going to replace this node with a string constant wrapper
                            // but first we need to make sure that this is a valid lookup.
                            // if the parameter contains anything that would vary at run-time, 
                            // then we need to throw an error.
                            // the parser will always have either one or zero nodes in the arguments
                            // arg list. We're not interested in zero args, so just make sure there is one
                            if (node.Arguments.Count == 1)
                            {
                                // must be a constant wrapper
                                ConstantWrapper argConstant = node.Arguments[0] as ConstantWrapper;
                                if (argConstant != null)
                                {
                                    string resourceName = argConstant.Value.ToString();

                                    // get the localized string from the resources object
                                    ConstantWrapper resourceLiteral = new ConstantWrapper(
                                        resourceStrings[resourceName],
                                        PrimitiveType.String,
                                        node.Context);

                                    // replace this node with localized string, analyze it, and bail
                                    // so we don't anaylze the tree we just replaced
                                    node.Parent.ReplaceChild(node, resourceLiteral);
                                    resourceLiteral.Accept(this);
                                    return;
                                }
                                else
                                {
                                    // error! must be a constant
                                    node.Context.HandleError(
                                        JSError.ResourceReferenceMustBeConstant,
                                        true);
                                }
                            }
                            else
                            {
                                // error! can only be a single constant argument to the string resource object.
                                // the parser will only have zero or one arguments, so this must be zero
                                // (since the parser won't pass multiple args to a [] operator)
                                node.Context.HandleError(
                                    JSError.ResourceReferenceMustBeConstant,
                                    true);
                            }
                        }
                    }
                }

                // and finally, if this is a backets call and the argument is a constantwrapper that can
                // be an identifier, just change us to a member node:  obj["prop"] to obj.prop.
                // but ONLY if the string value is "safe" to be an identifier. Even though the ECMA-262
                // spec says certain Unicode categories are okay, in practice the various major browsers
                // all seem to have problems with certain characters in identifiers. Rather than risking
                // some browsers breaking when we change this syntax, don't do it for those "danger" categories.
                if (node.InBrackets && node.Arguments != null)
                {
                    // see if there is a single, constant argument
                    string argText = node.Arguments.SingleConstantArgument;
                    if (argText != null)
                    {
                        // see if we want to replace the name
                        string newName;
                        if (m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties
                            && m_parser.Settings.IsModificationAllowed(TreeModifications.PropertyRenaming)
                            && !string.IsNullOrEmpty(newName = m_parser.Settings.GetNewName(argText)))
                        {
                            // yes -- we are going to replace the name, either as a string literal, or by converting
                            // to a member-dot operation.
                            // See if we can't turn it into a dot-operator. If we can't, then we just want to replace the operator with
                            // a new constant wrapper. Otherwise we'll just replace the operator with a new constant wrapper.
                            if (m_parser.Settings.IsModificationAllowed(TreeModifications.BracketMemberToDotMember)
                                && JSScanner.IsSafeIdentifier(newName)
                                && !JSScanner.IsKeyword(newName, (node.EnclosingScope ?? m_parser.GlobalScope).UseStrict))
                            {
                                // the new name is safe to convert to a member-dot operator.
                                // but we don't want to convert the node to the NEW name, because we still need to Analyze the
                                // new member node -- and it might convert the new name to something else. So instead we're
                                // just going to convert this existing string to a member node WITH THE OLD STRING, 
                                // and THEN analyze it (which will convert the old string to newName)
                                MemberExpression replacementMember = new MemberExpression(node.Context)
                                    {
                                        Root = node.Function,
                                        Name = argText,
                                        NameContext = node.Arguments[0].Context
                                    };
                                node.Parent.ReplaceChild(node, replacementMember);

                                // this analyze call will convert the old-name member to the newName value
                                replacementMember.Accept(this);
                                return;
                            }
                            else
                            {
                                // nope; can't convert to a dot-operator. 
                                // we're just going to replace the first argument with a new string literal
                                // and continue along our merry way.
                                node.Arguments[0] = new ConstantWrapper(newName, PrimitiveType.String, node.Arguments[0].Context);
                            }
                        }
                        else if (m_parser.Settings.IsModificationAllowed(TreeModifications.BracketMemberToDotMember)
                            && JSScanner.IsSafeIdentifier(argText)
                            && !JSScanner.IsKeyword(argText, (node.EnclosingScope ?? m_parser.GlobalScope).UseStrict))
                        {
                            // not a replacement, but the string literal is a safe identifier. So we will
                            // replace this call node with a Member-dot operation
                            MemberExpression replacementMember = new MemberExpression(node.Context)
                                {
                                    Root = node.Function,
                                    Name = argText,
                                    NameContext = node.Arguments[0].Context
                                };
                            node.Parent.ReplaceChild(node, replacementMember);
                            replacementMember.Accept(this);
                            return;
                        }
                    }
                }

                // call the base class to recurse
                base.Visit(node);

                if (node.Function != null && node.Function.IsDebugOnly)
                {
                    // if the funtion is debug-only, then we are too!
                    node.IsDebugOnly = true;

                    // if if this node is a constructor call....
                    if (node.IsConstructor)
                    {
                        // we have "new root.func(...)", root.func is a debug namespace, and we
                        // are stripping debug namespaces. Replace the new-operator with an 
                        // empty object literal.
                        node.Parent.ReplaceChild(node, new ObjectLiteral(node.Context)
                            {
                                IsDebugOnly = true
                            });
                    }
                }
                else
                {
                    // might have changed
                    member = node.Function as MemberExpression;
                    lookup = node.Function as LookupExpression;

                    var isEval = false;
                    if (lookup != null
                        && string.CompareOrdinal(lookup.Name, "eval") == 0
                        && lookup.VariableField.FieldType == FieldType.Predefined)
                    {
                        // call to predefined eval function
                        isEval = true;
                    }
                    else if (member != null && string.CompareOrdinal(member.Name, "eval") == 0)
                    {
                        // if this is a window.eval call, then we need to mark this scope as unknown just as
                        // we would if this was a regular eval call.
                        // (unless, of course, the parser settings say evals are safe)
                        // call AFTER recursing so we know the left-hand side properties have had a chance to
                        // lookup their fields to see if they are local or global
                        if (member.Root.IsWindowLookup)
                        {
                            // this is a call to window.eval()
                            isEval = true;
                        }
                    }
                    else
                    {
                        CallExpression callNode = node.Function as CallExpression;
                        if (callNode != null
                            && callNode.InBrackets
                            && callNode.Function.IsWindowLookup
                            && callNode.Arguments.IsSingleConstantArgument("eval"))
                        {
                            // this is a call to window["eval"]
                            isEval = true;
                        }
                    }

                    if (isEval)
                    {
                        if (m_parser.Settings.EvalTreatment != EvalTreatment.Ignore)
                        {
                            // mark this scope as unknown so we don't crunch out locals 
                            // we might reference in the eval at runtime
                            m_scopeStack.Peek().IsKnownAtCompileTime = false;
                        }
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(ClassNode node)
        {
            if (node != null)
            {
                base.Visit(node);

                // if this is a named class expression
                if (node.ClassType == ClassType.Expression && node.Binding != null)
                {
                    // it SHOULD be a simple identifier; if it's not, then leave it alone.
                    // but if it is, check to see if it's actually referenced, and if not, get rid of it
                    // because we don't need it.
                    var bindingIdentifier = node.Binding as BindingIdentifier;
                    if (bindingIdentifier?.VariableField != null
                        && bindingIdentifier.VariableField.RefCount == 0
                        && m_parser.Settings.RemoveFunctionExpressionNames
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveFunctionExpressionNames))
                    {
                        // if the class is a named expression and the name isn't
                        // referenced anywhere, delete it.
                        node.Binding = null;
                    }
                }

                if (node.Elements != null)
                {
                    // it is an error for a class to contain multiple methods with the same name
                    // (other than get/set pairs)
                    var nameHash = new HashSet<string>();
                    foreach (var element in node.Elements)
                    {
                        string functionName;
                        var functionObject = element as FunctionObject;
                        if (functionObject?.Binding != null 
                            && !(functionName = functionObject.Binding.Name).IsNullOrWhiteSpace())
                        {
                            var errorContext = functionObject.Binding.Context ?? functionObject.Context;

                            // the keyed name is the function type (get/set/other) plus the name
                            // make sure there's no duplicate with this name
                            if (!nameHash.Add(ClassElementKeyName(functionObject.FunctionType, functionName)))
                            {
                                // couldn't add because there's a duplicate, which is not allowed
                                errorContext.HandleError(JSError.DuplicateClassElementName, true);
                            }

                            if (functionObject.FunctionType == FunctionType.Getter || functionObject.FunctionType == FunctionType.Setter)
                            {
                                // make sure there's no method with this name
                                if (nameHash.Contains(ClassElementKeyName(FunctionType.Method, functionName)))
                                {
                                    // couldn't add because there's a duplicate, which is not allowed
                                    errorContext.HandleError(JSError.DuplicateClassElementName, true);
                                }
                            }
                            else
                            {
                                // make sure there's no getter or setter with this name
                                if (nameHash.Contains(ClassElementKeyName(FunctionType.Getter, functionName))
                                    || nameHash.Contains(ClassElementKeyName(FunctionType.Setter, functionName)))
                                {
                                    // couldn't add because there's a duplicate, which is not allowed
                                    errorContext.HandleError(JSError.DuplicateClassElementName, true);
                                }
                            }

                            if ((functionObject.FunctionType != FunctionType.Method || functionObject.IsGenerator)
                                && string.CompareOrdinal(functionName, "constructor") == 0)
                            {
                                errorContext.HandleError(JSError.SpecialConstructor, true);
                            }
                            else if (functionObject.IsStatic && string.CompareOrdinal(functionName, "prototype") == 0)
                            {
                                errorContext.HandleError(JSError.StaticPrototype, true);
                            }
                        }
                    }
                }
            }
        }

        private static string ClassElementKeyName(FunctionType funcType, string name)
        {
            switch (funcType)
            {
                case FunctionType.Getter:
                    return "get_" + name;

                case FunctionType.Setter:
                    return "set_" + name;

                default:
                    return "method_" + name;
            }
        }

        public override void Visit(ComprehensionNode node)
        {
            if (node != null)
            {
                // we need to push the scope onto the stack before we recurse
                node.BlockScope.IfNotNull(s => m_scopeStack.Push(s));
                try
                {
                    if (node.Clauses != null)
                    {
                        node.Clauses.Accept(this);
                    }

                    if (node.Expression != null)
                    {
                        node.Expression.Accept(this);
                    }
                }
                finally
                {
                    node.BlockScope.IfNotNull(s => m_scopeStack.Pop());
                }

                // TODO: verify that there are no naming collisions in the scope
            }
        }

        private void Optimize(Conditional node)
        {
            // if the condition is debug-only, then replace the condition with the false branch
            if (node.Condition != null && node.Condition.IsDebugOnly)
            {
                // if the false branch is debug-only, then replace the entire expression with a null
                if (node.FalseExpression == null || node.FalseExpression.IsDebugOnly)
                {
                    node.Parent.ReplaceChild(node, new ConstantWrapper(null, PrimitiveType.Null, node.Context)
                        {
                            IsDebugOnly = true
                        });
                }
                else
                {
                    node.Parent.ReplaceChild(node, node.FalseExpression);
                }
            }
            else
            {
                // now check to see if the condition starts with a not-operator. If so, we can get rid of it
                // and swap the true/false children
                var unary = node.Condition as UnaryExpression;
                if (unary != null && unary.OperatorToken == JSToken.LogicalNot
                    && !unary.OperatorInConditionalCompilationComment
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.IfNotTrueFalseToIfFalseTrue))
                {
                    // get rid of the not by replacing it with its operand
                    // and swap the branches
                    node.Condition = unary.Operand;
                    node.SwapBranches();
                }

                // see if the two branches are both assignment operations to the same variable.
                // if so, we can pull the assignment outside the conditional and have the conditional
                // be the assignment
                var trueAssign = node.TrueExpression as BinaryExpression;
                if (trueAssign != null && trueAssign.IsAssign)
                {
                    var falseAssign = node.FalseExpression as BinaryExpression;
                    if (falseAssign != null && falseAssign.OperatorToken == trueAssign.OperatorToken)
                    {
                        // see if the left-hand-side is equivalent
                        if (trueAssign.Operand1.IsEquivalentTo(falseAssign.Operand1))
                        {
                            // we're going to be getting rid of the left-hand side in the false-block, 
                            // so we need to remove any references it may represent
                            DetachReferencesVisitor.Apply(falseAssign.Operand1);

                            // transform: cond?lhs=expr1:lhs=expr2 to lhs=cond?expr1:expr2s
                            var binaryOp = new BinaryExpression(node.Context)
                                {
                                    Operand1 = trueAssign.Operand1,
                                    Operand2 = new Conditional(node.Context)
                                    {
                                        Condition = node.Condition,
                                        QuestionContext = node.QuestionContext,
                                        TrueExpression = trueAssign.Operand2,
                                        ColonContext = node.ColonContext,
                                        FalseExpression = falseAssign.Operand2
                                    },
                                    OperatorContext = trueAssign.OperatorContext,
                                    OperatorToken = trueAssign.OperatorToken,
                                    TerminatingContext = node.TerminatingContext
                                };

                            node.Parent.ReplaceChild(node, binaryOp);
                        }
                    }
                }
            }
        }

        public override void Visit(Conditional node)
        {
            if (node != null)
            {
                // analye all the children
                base.Visit(node);

                // and then optimize our node
                Optimize(node);
            }
        }

        public override void Visit(ConditionalCompilationOn node)
        {
            // well, we've encountered a cc_on statement now
            m_encounteredCCOn = true;
        }

        private static bool StringSourceIsNotInlineSafe(string source)
        {
            var isNotSafe = false;
            if (!string.IsNullOrEmpty(source))
            {
                // most browsers won't close the <script> tag unless they see </script, but the
                // user has explicitly set the flag to throw an error if the string isn't safe, so
                // let's err on the side of caution. Also check for the closing of a CDATA element.
                isNotSafe = source.IndexOf("</", StringComparison.Ordinal) >= 0
                    || source.IndexOf("]]>", StringComparison.Ordinal) >= 0;
            }

            return isNotSafe;
        }

        public override void Visit(ConstantWrapper node)
        {
            if (node != null)
            {
                if ((node.PrimitiveType == PrimitiveType.Other || node.PrimitiveType == PrimitiveType.String)
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.CultureInfoTokenReplacement)
                    && JSScanner.IsReplacementToken(node.Value.ToString()))
                {
                    // either this is a regular replacement token, or it's a string that contains
                    // only a replacement token. See if we want to potentially replace it with the
                    // actual cultureinfo value.
                    var newNode = ReplaceCultureValue(node);

                    // cast the new node back to a constant wrapper. If it is, keep on processing
                    // as if nothing changed.
                    node = newNode as ConstantWrapper;
                    if (node == null)
                    {
                        // otherwise we're going to want to recurse this new node and exit this one.
                        newNode.Accept(this);
                        return;
                    }
                }

                // if we want to throw an error when the string's source isn't inline safe...
                if (node.PrimitiveType == PrimitiveType.String
                    && m_parser.Settings.ErrorIfNotInlineSafe
                    && node.Context != null
                    && StringSourceIsNotInlineSafe(node.Context.Code))
                {
                    // ...throw an error
                    node.Context.HandleError(JSError.StringNotInlineSafe, true);
                }

                // check to see if this node is an argument to a RegExp constructor.
                // if it is, we'll want to not use certain string escapes
                AstNode previousNode = null;
                AstNode parentNode = node.Parent;
                while (parentNode != null)
                {
                    // is this a call node and the previous node was one of the parameters?
                    CallExpression callNode = parentNode as CallExpression;
                    if (callNode != null && previousNode == callNode.Arguments)
                    {
                        // are we calling a simple lookup for "RegExp"?
                        LookupExpression lookup = callNode.Function as LookupExpression;
                        if (lookup != null && lookup.Name == "RegExp")
                        {
                            // we are -- so all string literals passed within this constructor should not use
                            // standard string escape sequences
                            node.IsParameterToRegExp = true;
                            // we can stop looking
                            break;
                        }
                    }

                    // next up the chain, keeping track of this current node as next iteration's "previous" node
                    previousNode = parentNode;
                    parentNode = parentNode.Parent;
                }
            }
        }

        public override void Visit(ConstStatement node)
        {
            if (node != null)
            {
                // we shouldn't have any duplicate constants
                // const a=1, a=2 is not okay!
                // but don't automatically remove them -- we don't know whether browsers implement first-wins
                // or last-wins.
                var uniqueNames = new HashSet<string>(StringComparer.Ordinal);
                foreach (var bindingIdentifier in BindingsVisitor.Bindings(node))
                {
                    // will return false if the name is already in the collection
                    if (!uniqueNames.Add(bindingIdentifier.Name))
                    {
                        bindingIdentifier.Context.HandleError(JSError.DuplicateConstantDeclaration, true);
                    }
                }

                // recurse the analyze
                base.Visit(node);
            }
        }

        public override void Visit(ContinueStatement node)
        {
            if (node != null)
            {
                // if the label isn't valid an we can remove them, remove it now
                if (!node.Label.IsNullOrWhiteSpace()
                    && node.LabelInfo == null
                    && m_parser.Settings.RemoveUnneededCode
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryLabels))
                {
                    node.Label = null;
                }

                if (!IsInsideLoop(node, false))
                {
                    node.Context.HandleError(JSError.BadContinue, true);
                }
            }
        }

        public override void Visit(DebuggerNode node)
        {
            if (node != null)
            {
                // we ARE a debug statement!
                node.IsDebugOnly = true;
            }
        }

        public override void Visit(DoWhileStatement node)
        {
            if (node != null)
            {
                // recurse
                base.Visit(node);

                // if the body is now empty, make it null
                if (node.Body != null && node.Body.Count == 0)
                {
                    node.Body = null;
                }

                if (node.Condition != null && node.Condition.IsDebugOnly)
                {
                    if (node.Body == null)
                    {
                        node.Parent.ReplaceChild(node, null);
                    }
                    else
                    {
                        node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                    }
                }
            }
        }

        public override void Visit(ExportStatement node)
        {
            if (node != null)
            {
                // export default is an assignment expression, so any function expression or
                // other expression it exports can be renamed. But straight exports of var/const/let,
                // function, and class cannot be renamed.
                if (!node.IsDefault)
                {
                    if (!node.ModuleName.IsNullOrWhiteSpace())
                    {
                        // re-export from external module, so the local value(s) cannot be redefined either, since it
                        // is coming from the external modules as well
                        foreach (var bindingIdentifier in BindingsVisitor.Bindings(node))
                        {
                            if (bindingIdentifier.VariableField != null)
                            {
                                bindingIdentifier.VariableField.CanCrunch = false;
                            }
                        }
                    }
                    else if (node.Count == 1 && (node[0] is Declaration || node[0] is FunctionObject || node[0] is ClassNode))
                    {
                        // we are explicitly exporting function or class names or declarations (var/let/const)
                        // make sure we don't rename them
                        foreach (var bindingIdentifier in BindingsVisitor.Bindings(node[0]))
                        {
                            if (bindingIdentifier.VariableField != null)
                            {
                                bindingIdentifier.VariableField.CanCrunch = false;
                            }
                        }
                    }
                }

                base.Visit(node);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(ForStatement node)
        {
            if (node != null)
            {
                // if this for-statement has it's own lexical scope, then it's an error
                // if the any of the field names declared in this scope is also defined inside the body.
                if (node.BlockScope != null)
                {
                    foreach (var field in node.BlockScope.LexicallyDeclaredNames)
                    {
                        // if the block has a lexical scope, check it for conflicts
                        if (node.Body != null && node.Body.HasOwnScope)
                        {
                            var lexDecl = node.Body.EnclosingScope.LexicallyDeclaredName(field.Name);
                            if (lexDecl != null)
                            {
                                // report the error (lex/const/funcdecl collision)
                                lexDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, true);

                                // link the inner one to the outer one so any renaming stays in sync.
                                if (lexDecl.VariableField != null)
                                {
                                    lexDecl.VariableField.OuterField = field.VariableField;
                                    if (field.VariableField != null && !lexDecl.VariableField.CanCrunch)
                                    {
                                        field.VariableField.CanCrunch = false;
                                    }
                                }
                            }
                        }

                        // check to make sure there are no var-decl'd names with the same name. Those will
                        // get carried up to this scope so we don't need to check the block scope (if any)
                        var varDecl = node.BlockScope.VarDeclaredName(field.Name);
                        if (varDecl != null)
                        {
                            // report the error (lex/const collides with var) or warning (funcdecl collides with var)
                            varDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, field is LexicalDeclaration);

                            // and mark them both as no-rename
                            varDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                            field.VariableField.IfNotNull(v => v.CanCrunch = false);
                        }
                    }
                }

                // recurse
                base.Visit(node);

                // if the body is now empty (and doesn't have its own lexical scope), make it null
                if (node.Body != null && node.Body.Count == 0 && !node.Body.HasOwnScope)
                {
                    node.Body = null;
                }

                if (node.Initializer != null && node.Initializer.IsDebugOnly)
                {
                    node.Initializer = null;
                }

                if (node.Incrementer != null && node.Incrementer.IsDebugOnly)
                {
                    node.Incrementer = null;
                }

                if (node.Condition != null && node.Condition.IsDebugOnly)
                {
                    if (node.Initializer == null && node.Incrementer == null && node.Body == null)
                    {
                        node.IsDebugOnly = true;
                    }
                    else
                    {
                        node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                    }
                }
            }
        }

        public override void Visit(ForInStatement node)
        {
            if (node != null)
            {
                // if this forIn-statement has it's own lexical scope, then it's an error
                // if the any of the field names declared in this scope is also defined inside the body.
                if (node.BlockScope != null)
                {
                    foreach (var field in node.BlockScope.LexicallyDeclaredNames)
                    {
                        // if the block has a lexical scope, check it for conflicts
                        if (node.Body != null && node.Body.HasOwnScope)
                        {
                            var lexDecl = node.Body.EnclosingScope.LexicallyDeclaredName(field.Name);
                            if (lexDecl != null)
                            {
                                // report the error (lex/const/funcdecl collision)
                                lexDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, true);

                                // link the inner one to the outer one so any renaming stays in sync.
                                if (lexDecl.VariableField != null)
                                {
                                    lexDecl.VariableField.OuterField = field.VariableField;
                                    if (field.VariableField != null && !lexDecl.VariableField.CanCrunch)
                                    {
                                        field.VariableField.CanCrunch = false;
                                    }
                                }
                            }
                        }

                        // check to make sure there are no var-decl'd names with the same name. Those will
                        // get carried up to this scope so we don't need to check the block scope (if any)
                        var varDecl = node.BlockScope.VarDeclaredName(field.Name);
                        if (varDecl != null)
                        {
                            // report the error (lex/const collides with var) or warning (funcdecl collides with var)
                            varDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, field is LexicalDeclaration);

                            // and mark them both as no-rename
                            varDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                            field.VariableField.IfNotNull(v => v.CanCrunch = false);
                        }
                    }
                }

                // recurse
                base.Visit(node);

                // if the body is now empty (and doesn't have its own lexical scope), make it null
                if (node.Body != null && node.Body.Count == 0 && !node.Body.HasOwnScope)
                {
                    node.Body = null;
                }

                if (node.Collection != null && node.Collection.IsDebugOnly)
                {
                    if (node.Body == null)
                    {
                        node.IsDebugOnly = true;
                    }
                    else
                    {
                        node.Collection = new ObjectLiteral(node.Collection.Context)
                            {
                                IsDebugOnly = true
                            };
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(FunctionObject node)
        {
            if (node != null)
            {
                // get the name of this function, calculate something if it's anonymous or if
                // the name isn't actually referenced
                if (node.Binding == null
                    || node.Binding.Name.IsNullOrWhiteSpace()
                    || (node.IsExpression
                        && node.Binding.VariableField.IfNotNull(v => v.RefCount == 0)
                        && m_parser.Settings.RemoveFunctionExpressionNames
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveFunctionExpressionNames)))
                {
                    node.NameGuess = GuessAtName(node);
                }

                // don't analyze the identifier or we'll add an extra reference to it.
                var isStrict = m_scopeStack.Peek().UseStrict;
                if (isStrict && node.Binding != null)
                {
                    // we need to make sure the function isn't named "eval" or "arguments"
                    if (string.CompareOrdinal(node.Binding.Name, "eval") == 0
                        || string.CompareOrdinal(node.Binding.Name, "arguments") == 0)
                    {
                        if (node.Binding.Context != null)
                        {
                            node.Binding.Context.HandleError(JSError.StrictModeFunctionName, true);
                        }
                        else if (node.Context != null)
                        {
                            node.Context.HandleError(JSError.StrictModeFunctionName, true);
                        }
                    }
                }

                if (node.FunctionType == FunctionType.Setter
                    && (node.ParameterDeclarations == null || node.ParameterDeclarations.Count != 1))
                {
                    (node.ParameterDeclarations.IfNotNull(p => p.Context) ?? node.Context).HandleError(JSError.SetterMustHaveOneParameter, true);
                }
                else if (node.ParameterDeclarations.IfNotNull(p => p.Count > 1))
                {
                    // more than one parameter. Make sure there are no rest parameters BEFORE the last parameter
                    var lastParameterIndex = node.ParameterDeclarations.Count - 1;
                    node.ParameterDeclarations.ForEach<ParameterDeclaration>(paramDecl =>
                        {
                            if (paramDecl.Position != lastParameterIndex && paramDecl.HasRest)
                            {
                                paramDecl.Context.HandleError(JSError.RestParameterNotLast, true);
                            }
                        });
                }

                if (node.ParameterDeclarations != null && node.ParameterDeclarations.Count > 0)
                {
                    // recurse the parameters to catch any keywords or strict naming issues
                    var oldError = m_strictNameError;
                    m_strictNameError = JSError.StrictModeArgumentName;
                    node.ParameterDeclarations.Accept(this);
                    m_strictNameError = oldError;

                    // we need to make sure there are no duplicate argument names, so
                    // create map that we'll use to determine if there are any dups
                    var parameterMap = new HashSet<string>();
                    foreach (var bindingIdentifier in BindingsVisitor.Bindings(node.ParameterDeclarations))
                    {
                        // if it already exists in the map, then it's a dup
                        if (!parameterMap.Add(bindingIdentifier.Name))
                        {
                            // already exists -- throw an error
                            if (isStrict)
                            {
                                bindingIdentifier.Context.HandleError(JSError.StrictModeDuplicateArgument, true);
                            }
                            else
                            {
                                bindingIdentifier.Context.HandleError(JSError.DuplicateName, false);
                            }
                        }
                    }
                }

                if (node.Body != null)
                {
                    // push the stack and analyze the body
                    m_scopeStack.Push(node.EnclosingScope);
                    try
                    {
                        // recurse the body
                        node.Body.Accept(this);
                    }
                    finally
                    {
                        m_scopeStack.Pop();
                    }
                }

                if (node.ParameterDeclarations != null && node.ParameterDeclarations.Count > 0)
                {
                    // everything's been resolved and things may have been taken away away now that we've
                    // recursed, so walk backwards from the end of the parameters list
                    // and flag/remove any parameters that are not referenced until we hit the first one that is.
                    var removeIfUnreferenced = m_parser.Settings.RemoveUnneededCode
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnusedParameters);
                    var foundLastReference = false;
                    for (var ndx = node.ParameterDeclarations.Count - 1; ndx >= 0; --ndx)
                    {
                        var paramDecl = node.ParameterDeclarations[ndx] as ParameterDeclaration;
                        if (paramDecl != null)
                        {
                            if (CheckParametersAreReferenced(paramDecl.Binding, removeIfUnreferenced, foundLastReference))
                            {
                                // if we've already hit a referenced parameter, then we couldn't delete this
                                // one if we wanted, so don't bother even reporting it.
                                if (!foundLastReference)
                                {
                                    // the entire parameter is unreferenced and we haven't found a referenced
                                    // parameter yet, so report the issue
                                    paramDecl.Context.HandleError(JSError.ArgumentNotReferenced);

                                    if (removeIfUnreferenced)
                                    {
                                        node.ParameterDeclarations.RemoveAt(ndx);
                                    }
                                }
                            }
                            else
                            {
                                // *something* is referenced in this parameter. But keep going so we can
                                // find unreferenced binding pattern identifiers in other parameters
                                foundLastReference = true;
                            }
                        }
                    }
                }

                // if this is an arrow function with a single statement in the body that's
                // a return statement, we can get rid of the return and just return keep the
                // operand by itself.
                ReturnStatement returnNode;
                if (node.FunctionType == FunctionType.ArrowFunction
                    && node.Body.IfNotNull(b => b.Count == 1)
                    && (returnNode = node.Body[0] as ReturnStatement) != null)
                {
                    node.Body.ReplaceChild(returnNode, returnNode.Operand);
                    node.Body.IsConcise = true;
                }
            }
        }

        private static bool CheckParametersAreReferenced(AstNode binding, bool removeIfUnreferenced, bool foundLastReference)
        {
            var isUnreferenced = false;

            // if it's either a simple binding identifier or a unary rest that's a binding operator...
            var bindingIdentifier = binding as BindingIdentifier;
            if (bindingIdentifier != null)
            {
                // simple binding identifier
                isUnreferenced = false;
                if (bindingIdentifier.VariableField != null)
                {
                    isUnreferenced = !bindingIdentifier.VariableField.IsReferenced;
                    if (isUnreferenced && removeIfUnreferenced && !foundLastReference)
                    {
                        // clean up the field - the parameter itself will be deleted when we return
                        bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);
                        bindingIdentifier.VariableField.WasRemoved = true;
                    }
                }
            }
            else
            {
                // binding pattern
                // assume the whole thing UNreferenced unless we find something that IS referenced
                isUnreferenced = true;
                foreach (var nameDecl in BindingsVisitor.Bindings(binding))
                {
                    if (nameDecl.VariableField.IfNotNull(v => !v.IsReferenced))
                    {
                        // this declaration is unreferenced, and it's in a binding pattern.
                        // report it as unreferenced
                        nameDecl.Context.HandleError(JSError.ArgumentNotReferenced);

                        // and delete it now if we are deleting unreferenced parameters
                        if (removeIfUnreferenced)
                        {
                            // delete it, but don't clean up the containing binding because
                            // we will need to do special processing for argument binding patterns.
                            ActivationObject.DeleteFromBindingPattern(nameDecl, false);
                        }
                    }
                    else
                    {
                        // referenced (or no field). This entire binding is considered referenced
                        isUnreferenced = false;
                    }
                }

                // we should always trim the trailing elisions from array bindings
                TrimTrailingElisionsFromArrayBindings(binding);
            }

            return isUnreferenced;
        }

        private static void TrimTrailingElisionsFromArrayBindings(AstNode binding)
        {
            ObjectLiteral objectLiteral;
            var arrayBinding = binding as ArrayLiteral;
            if (arrayBinding != null)
            {
                // trim all trailing elisions
                var trailing = true;
                for (var ndx = arrayBinding.Elements.Count - 1; ndx >= 0; --ndx)
                {
                    // since this is a binding, the only constant allowed would be the missing
                    // value, so don't bother checking. If it's a constant, whack it.
                    var constantWrapper = arrayBinding.Elements[ndx] as ConstantWrapper;
                    if (constantWrapper != null)
                    {
                        // if it's no longer trailing, then just ignore it
                        if (trailing)
                        {
                            arrayBinding.Elements.RemoveAt(ndx);
                        }
                    }
                    else
                    {
                        // no longer elision, but recurse
                        trailing = false;
                        TrimTrailingElisionsFromArrayBindings(arrayBinding.Elements[ndx]);
                    }
                }
            }
            else if ((objectLiteral = binding as ObjectLiteral) != null)
            {
                objectLiteral.Properties.ForEach<ObjectLiteralProperty>(property => TrimTrailingElisionsFromArrayBindings(property.Value));
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(IfStatement node)
        {
            if (node != null)
            {
                // recurse....
                base.Visit(node);

                // now check to see if the two branches are now empty.
                // if they are, null them out.
                if (node.TrueBlock != null && node.TrueBlock.Count == 0)
                {
                    node.TrueBlock = null;
                }
                if (node.FalseBlock != null && node.FalseBlock.Count == 0)
                {
                    node.FalseBlock = null;
                }

                if (node.Condition != null && node.Condition.IsDebugOnly)
                {
                    node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                    node.TrueBlock = null;
                }

                if (node.TrueBlock != null && node.FalseBlock != null)
                {
                    // neither true block nor false block is null.
                    // if they're both expressions, convert them to a condition operator
                    if (node.TrueBlock.IsExpression && node.FalseBlock.IsExpression
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.IfExpressionsToExpression))
                    {
                        // if this statement has both true and false blocks, and they are both expressions,
                        // then we can simplify this to a conditional expression.
                        // because the blocks are expressions, we know they only have ONE statement in them,
                        // so we can just dereference them directly.
                        Conditional conditional;
                        var logicalNot = new LogicalNotVisitor(node.Condition, m_parser.Settings);
                        if (logicalNot.Measure() < 0)
                        {
                            // applying a logical-not makes the condition smaller -- reverse the branches
                            logicalNot.Apply();
                            conditional = new Conditional(node.Context)
                                {
                                    Condition = node.Condition,
                                    TrueExpression = node.FalseBlock[0],
                                    FalseExpression = node.TrueBlock[0]
                                };
                        }
                        else
                        {
                            // regular order
                            conditional = new Conditional(node.Context)
                                {
                                    Condition = node.Condition,
                                    TrueExpression = node.TrueBlock[0],
                                    FalseExpression = node.FalseBlock[0]
                                };
                        }

                        node.Parent.ReplaceChild(
                            node,
                            conditional);

                        Optimize(conditional);
                    }
                    else
                    {
                        // see if logical-notting the condition produces something smaller
                        var logicalNot = new LogicalNotVisitor(node.Condition, m_parser.Settings);
                        if (logicalNot.Measure() < 0)
                        {
                            // it does -- not the condition and swap the branches
                            logicalNot.Apply();
                            node.SwapBranches();
                        }

                        // see if the true- and false-branches each contain only a single statement
                        if (node.TrueBlock.Count == 1 && node.FalseBlock.Count == 1)
                        {
                            // they do -- see if the true-branch's statement is a return-statement
                            var trueReturn = node.TrueBlock[0] as ReturnStatement;
                            if (trueReturn?.Operand != null)
                            {
                                // it is -- see if the false-branch is also a return statement
                                var falseReturn = node.FalseBlock[0] as ReturnStatement;
                                if (falseReturn?.Operand != null)
                                {
                                    // transform: if(cond)return expr1;else return expr2 to return cond?expr1:expr2
                                    var conditional = new Conditional(node.Condition.Context.FlattenToStart())
                                        {
                                            Condition = node.Condition,
                                            TrueExpression = trueReturn.Operand,
                                            FalseExpression = falseReturn.Operand
                                        };

                                    // create a new return node from the conditional and replace
                                    // our if-node with it
                                    var returnNode = new ReturnStatement(node.Context)
                                        {
                                            Operand = conditional
                                        };

                                    node.Parent.ReplaceChild(
                                        node,
                                        returnNode);

                                    Optimize(conditional);
                                }
                            }
                        }
                    }
                }
                else if (node.FalseBlock != null)
                {
                    // true block must be null.
                    // if there is no true branch but a false branch, then
                    // put a not on the condition and move the false branch to the true branch.
                    if (node.FalseBlock.IsExpression
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionCallToConditionAndCall))
                    {
                        // if (cond); else expr ==> cond || expr
                        // but first -- which operator to use? if(a);else b --> a||b, and if(!a);else b --> a&&b
                        // so determine which one is smaller: a or !a
                        // assume we'll use the logical-or, since that doesn't require changing the condition
                        var newOperator = JSToken.LogicalOr;
                        var logicalNot = new LogicalNotVisitor(node.Condition, m_parser.Settings);
                        if (logicalNot.Measure() < 0)
                        {
                            // !a is smaller, so apply it and use the logical-or operator
                            logicalNot.Apply();
                            newOperator = JSToken.LogicalAnd;
                        }

                        var binaryOp = new BinaryExpression(node.Context)
                            {
                                Operand1 = node.Condition,
                                Operand2 = node.FalseBlock[0],
                                OperatorToken = newOperator,
                            };

                        // we don't need to analyse this new node because we've already analyzed
                        // the pieces parts as part of the if. And this visitor's method for the BinaryExpression
                        // doesn't really do anything else. Just replace our current node with this
                        // new node
                        node.Parent.ReplaceChild(node, binaryOp);
                    }
                    else if (m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionFalseToIfNotConditionTrue))
                    {
                        // logical-not the condition
                        // if(cond);else stmt ==> if(!cond)stmt
                        var logicalNot = new LogicalNotVisitor(node.Condition, m_parser.Settings);
                        logicalNot.Apply();

                        // and swap the branches
                        node.SwapBranches();
                    }
                }
                else if (node.TrueBlock != null)
                {
                    // false block must be null
                    if (node.TrueBlock.IsExpression
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionCallToConditionAndCall))
                    {
                        // convert the if-node to an expression
                        IfConditionExpressionToExpression(node, node.TrueBlock[0]);
                    }
                }
                else if (m_parser.Settings.IsModificationAllowed(TreeModifications.IfEmptyToExpression))
                {
                    // NEITHER branches have anything now!

                    // as long as the condition doesn't
                    // contain calls or assignments, we should be able to completely delete
                    // the statement altogether rather than changing it to an expression
                    // statement on the condition.
                    // but how do we KNOW there are no side-effects?
                    // if the condition is a constant or operations on constants, delete it.
                    // or if the condition itself is a debugger statement -- a call, lookup, or member.
                    var remove = node.Condition == null || node.Condition.IsConstant || node.Condition.IsDebugOnly;
                    if (remove)
                    {
                        // we're pretty sure there are no side-effects; remove it altogether
                        node.Parent.ReplaceChild(node, null);
                    }
                    else
                    {
                        // We don't know what it is and what the side-effects may be, so
                        // just change this statement into an expression statement by replacing us with 
                        // the expression
                        // no need to analyze -- we already recursed
                        node.Parent.ReplaceChild(node, node.Condition);
                    }
                }

                if (node.FalseBlock == null
                    && node.TrueBlock != null
                    && node.TrueBlock.Count == 1
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.CombineNestedIfs))
                {
                    var nestedIf = node.TrueBlock[0] as IfStatement;
                    if (nestedIf != null && nestedIf.FalseBlock == null)
                    {
                        // we have nested if-blocks.
                        // transform if(cond1)if(cond2){...} to if(cond1&&cond2){...}
                        // change the first if-statement's condition to be cond1&&cond2
                        // move the nested if-statement's true block to the outer if-statement
                        node.Condition = new BinaryExpression(node.Condition.Context.FlattenToStart())
                            {
                                Operand1 = node.Condition,
                                Operand2 = nestedIf.Condition,
                                OperatorToken = JSToken.LogicalAnd
                            };
                        node.TrueBlock = nestedIf.TrueBlock;
                    }
                }
            }
        }

        private void IfConditionExpressionToExpression(IfStatement ifNode, AstNode expression)
        {
            // but first -- which operator to use? if(a)b --> a&&b, and if(!a)b --> a||b
            // so determine which one is smaller: a or !a
            // assume we'll use the logical-and, since that doesn't require changing the condition
            var newOperator = JSToken.LogicalAnd;
            var logicalNot = new LogicalNotVisitor(ifNode.Condition, m_parser.Settings);
            if (logicalNot.Measure() < 0)
            {
                // !a is smaller, so apply it and use the logical-or operator
                logicalNot.Apply();
                newOperator = JSToken.LogicalOr;
            }

            // because the true block is an expression, we know it must only have
            // ONE statement in it, so we can just dereference it directly.
            var binaryOp = new BinaryExpression(ifNode.Context)
                {
                    Operand1 = ifNode.Condition,
                    Operand2 = expression,
                    OperatorToken = newOperator,
                };

            // we don't need to analyse this new node because we've already analyzed
            // the pieces parts as part of the if. And this visitor's method for the BinaryExpression
            // doesn't really do anything else. Just replace our current node with this
            // new node
            ifNode.Parent.ReplaceChild(ifNode, binaryOp);
        }

        public override void Visit(ImportStatement node)
        {
            if (node != null)
            {
                base.Visit(node);

                // if there is only one binding and it's not a specifier, then we want to
                // make sure we do NOT rename them, because they are dependent on an external module.
                // but we CAN rename any of the other specifiers we may have. 
                if (node.Count == 1 && !(node[0] is ImportExportSpecifier))
                {
                    foreach (var bindingIdentifier in BindingsVisitor.Bindings(node[0]))
                    {
                        if (bindingIdentifier.VariableField != null)
                        {
                            bindingIdentifier.VariableField.CanCrunch = false;
                        }
                    }
                }
            }
        }

        public override void Visit(LabeledStatement node)
        {
            if (node != null)
            {
                // if we set the nest count to something greater than 0, then the label will
                // get renamed when we output it.

                // then recurse the statement
                if (node.Statement != null)
                {
                    node.Statement.Accept(this);
                }

                if (node.LabelInfo != null && !node.LabelInfo.HasIssues)
                {
                    if (node.LabelInfo.RefCount == 0)
                    {
                        // low-sev warning
                        node.LabelContext.HandleError(JSError.UnusedLabel);
                    }

                    if (node.LabelInfo.RefCount == 0
                        && m_parser.Settings.RemoveUnneededCode
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryLabels))
                    {
                        // just get rid of the label altogether
                        if (node.Statement == null)
                        {
                            // no statement; just delete this node from its parent
                            node.Parent.ReplaceChild(node, null);
                        }
                        else
                        {
                            // take the statement from this node and replace the node with
                            // this statement
                            node.Parent.ReplaceChild(node, node.Statement);
                        }
                    }
                    else if (m_parser.Settings.LocalRenaming != LocalRenaming.KeepAll
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.LocalRenaming))
                    {
                        // it was either referenced or we don't want to get rid of unused labels,
                        // but we DO want to minify them. set the minified value.
                        node.LabelInfo.MinLabel = CrunchEnumerator.CrunchedLabel(node.LabelInfo.NestLevel);
                    }
                }
            }
        }

        public override void Visit(LookupExpression node)
        {
            // lookup is the start of a possible debug namespace, so assume we are NOT a match
            m_possibleDebugNamespace = false;
            if (node != null)
            {
                // figure out if our reference type is a function or a constructor
                if (node.Parent is CallExpression)
                {
                    node.RefType = (
                      ((CallExpression)(node.Parent)).IsConstructor
                      ? ReferenceType.Constructor
                      : ReferenceType.Function
                      );
                }

                // check the name of the variable for reserved words that aren't allowed
                ActivationObject scope = m_scopeStack.Peek();
                if (JSScanner.IsKeyword(node.Name, scope.UseStrict)
                    && node.VariableField.IfNotNull(v => v.FieldType != FieldType.Super))
                {
                    node.Context.HandleError(JSError.KeywordUsedAsIdentifier, true);
                }

                // no variable field means ignore it
                var parentIsMember = node.Parent is MemberExpression;
                if (node.VariableField != null && node.VariableField.FieldType == FieldType.Predefined)
                {
                    // this is a predefined field. If it's Nan or Infinity, we should
                    // replace it with the numeric value in case we need to later combine
                    // some literal expressions.
                    if (string.CompareOrdinal(node.Name, "NaN") == 0)
                    {
                        // don't analyze the new ConstantWrapper -- we don't want it to take part in the
                        // duplicate constant combination logic should it be turned on.
                        node.Parent.ReplaceChild(node, new ConstantWrapper(double.NaN, PrimitiveType.Number, node.Context));
                    }
                    else if (string.CompareOrdinal(node.Name, "Infinity") == 0)
                    {
                        // don't analyze the new ConstantWrapper -- we don't want it to take part in the
                        // duplicate constant combination logic should it be turned on.
                        node.Parent.ReplaceChild(node, new ConstantWrapper(double.PositiveInfinity, PrimitiveType.Number, node.Context));
                    }
                    else if (m_lookForDebugNamespaces 
                        && parentIsMember 
                        && string.CompareOrdinal(node.Name, "window") == 0)
                    {
                        // this is a lookup for the global window object. Might be the start of a debug namespace.
                        // leave the index at zero, because we haven't matched anything yet.
                        m_possibleDebugNamespace = true;
                        m_possibleDebugNamespaceIndex = 0;
                        m_possibleDebugMatches.Clear();
                    }
                }

                if (m_lookForDebugNamespaces && !m_possibleDebugNamespace)
                {
                    if (InitialDebugNameSpaceMatches(node.Name, parentIsMember))
                    {
                        // the initial search found a match! No need to keep looking; just replace
                        // the lookup with an empty object literal marked as debug-only.
                        node.IsDebugOnly = true;
                        node.Parent.ReplaceChild(node, new ObjectLiteral(node.Context)
                        {
                            IsDebugOnly = true
                        });
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(MemberExpression node)
        {
            if (node != null)
            {
                // if we don't even have any resource strings, then there's nothing
                // we need to do and we can just perform the base operation
                var resourceList = m_parser.Settings.ResourceStrings;
                if (resourceList.Count > 0)
                {
                    // if we haven't created the match visitor yet, do so now
                    if (m_matchVisitor == null)
                    {
                        m_matchVisitor = new MatchPropertiesVisitor();
                    }

                    // walk the list BACKWARDS so that later resource strings supercede previous ones
                    for (var ndx = resourceList.Count - 1; ndx >= 0; --ndx)
                    {
                        var resourceStrings = resourceList[ndx];

                        // see if the resource string name matches the root
                        if (m_matchVisitor.Match(node.Root, resourceStrings.Name))
                        {
                            // it is -- we're going to replace this with a string value.
                            // if this member name is a string on the object, we'll replacve it with
                            // the literal. Otherwise we'll replace it with an empty string.
                            // see if the string resource contains this value
                            ConstantWrapper stringLiteral = new ConstantWrapper(
                                resourceStrings[node.Name] ?? string.Empty,
                                PrimitiveType.String,
                                node.Context);

                            node.Parent.ReplaceChild(node, stringLiteral);

                            // analyze the literal
                            stringLiteral.Accept(this);
                            return;
                        }
                    }
                }

                // if we are replacing property names and we have something to replace
                if (m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.PropertyRenaming))
                {
                    // see if this name is a target for replacement
                    string newName = m_parser.Settings.GetNewName(node.Name);
                    if (!string.IsNullOrEmpty(newName))
                    {
                        // it is -- set the name to the new name
                        node.Name = newName;
                    }
                }

                // check the name of the member for reserved words that aren't allowed
                if (JSScanner.IsKeyword(node.Name, m_scopeStack.Peek().UseStrict))
                {
                    node.NameContext.HandleError(JSError.KeywordUsedAsIdentifier);
                }

                // recurse
                if (node.Root != null)
                {
                    node.Root.Accept(this);
                }

                if (m_stripDebug)
                {
                    var parentIsMember = node.Parent is MemberExpression;
                    if (node.Root.IfNotNull(r => r.IsDebugOnly))
                    {
                        // if the root is debug-only, WE are debug-only
                        node.IsDebugOnly = true;
                    }
                    else if (m_possibleDebugNamespace)
                    {
                        // if the matches are empty, then we need to populate the list to begin with
                        if (m_possibleDebugMatches.Count == 0)
                        {
                            if (InitialDebugNameSpaceMatches(node.Name, parentIsMember))
                            {
                                node.IsDebugOnly = true;
                            }
                        }
                        else
                        {
                            // if we are still a possible debug namespace, check the remaining patterns
                            for (var ndx = m_possibleDebugMatches.Count - 1; ndx >= 0; --ndx)
                            {
                                var debugParts = m_possibleDebugMatches[ndx];
                                if (string.CompareOrdinal(node.Name, debugParts[m_possibleDebugNamespaceIndex]) == 0)
                                {
                                    // another match. If that means we've matched a complete part list!
                                    // if not, if there are more parts available to check, then keep going.
                                    if (debugParts.Length == m_possibleDebugNamespaceIndex + 1)
                                    {
                                        node.IsDebugOnly = true;
                                        m_possibleDebugMatches.Clear();
                                        break;
                                    }
                                }
                                else
                                {
                                    // not a match; remove this possibility
                                    m_possibleDebugMatches.RemoveAt(ndx);
                                }
                            }

                            // if there are still patterns that we're matching, keep going with the next item if
                            // our parent is another member
                            if (m_possibleDebugMatches.Count > 0 && parentIsMember)
                            {
                                ++m_possibleDebugNamespaceIndex;
                            }
                            else
                            {
                                // otherwise we're done; make sure the list is cleared out.
                                m_possibleDebugMatches.Clear();
                                m_possibleDebugNamespace = false;
                            }
                        }

                        // if we found a match, replace ourselves with an object literal
                        if (node.IsDebugOnly)
                        {
                            node.Parent.ReplaceChild(node, new ObjectLiteral(node.Context)
                            {
                                IsDebugOnly = true
                            });
                        }
                    }
                }
            }
        }

        private bool InitialDebugNameSpaceMatches(string name, bool parentIsMember)
        {
            foreach (var parts in m_debugNamespaceParts)
            {
                if (string.CompareOrdinal(name, parts[0]) == 0)
                {
                    // we have a match. If there is only one part, we're done because we totally matched.
                    if (parts.Length == 1)
                    {
                        // clear out the list so we stop looking and return true
                        // as an indicator that we found a complete match
                        m_possibleDebugMatches.Clear();
                        m_possibleDebugNamespace = false;
                        return true;
                    }
                    else if (parentIsMember)
                    {
                        // otherwise add it to the list so we will keep looking when we go up a
                        // level to the next member operator
                        m_possibleDebugMatches.Add(parts);
                    }
                }
            }

            if (m_possibleDebugMatches.Count > 0)
            {
                // we found possible matches, so set the state so we keep looking
                m_possibleDebugNamespace = true;
                m_possibleDebugNamespaceIndex = 1;
            }

            // if we got here, we didn't find a complete match
            return false;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(ObjectLiteral node)
        {
            if (node != null)
            {
                // recurse
                base.Visit(node);

                // if we are going to be renaming things...
                if (m_parser.Settings.LocalRenaming != LocalRenaming.KeepAll)
                {
                    node.Properties.ForEach<ObjectLiteralProperty>(property =>
                        {
                            if (property.Name == null)
                            {
                                // implicit object property name! if we change the variable name,
                                // we will pick up the WRONG property name!
                                // the value should be a binding identifier or a lookup, should be a valid identifier,
                                // and not be in the "norename" list
                                var propertyName = property.Value.ToString();
                                if (JSScanner.IsValidIdentifier(propertyName) && !m_noRename.Contains(propertyName))
                                {
                                    if (FieldCanBeRenamed(property.Value))
                                    {
                                        // it can be renamed. Let's add a property name now to lock the name down
                                        property.Name = new ObjectLiteralField(propertyName, PrimitiveType.String, property.Value.Context)
                                        {
                                            IsIdentifier = true
                                        };
                                    }
                                }
                            }
                        });
                }

                if (m_scopeStack.Peek().UseStrict)
                {
                    // now strict-mode checks
                    // go through all property names and make sure there are no duplicates.
                    // use a map to remember which ones we already have and of what type.
                    var nameMap = new Dictionary<string, string>();
                    node.Properties.ForEach<ObjectLiteralProperty>(property =>
                        {
                            var propertyType = GetPropertyType(property.Value as FunctionObject);

                            // key name is the name plus the type. Can't just use the name because 
                            // get and set will both have the same name (but different types)
                            var keyName = (property.Name ?? property.Value) + propertyType;

                            string mappedType;
                            if (propertyType == "data")
                            {
                                // can't have another data, get, or set
                                if (nameMap.TryGetValue(keyName, out mappedType)
                                    || nameMap.TryGetValue((property.Name ?? property.Value) + "get", out mappedType)
                                    || nameMap.TryGetValue((property.Name ?? property.Value) + "set", out mappedType))
                                {
                                    // throw the error
                                    (property.Name ?? property.Value).Context.HandleError(JSError.StrictModeDuplicateProperty, true);

                                    // if the mapped type isn't data, then we can add this data name/type to the map
                                    // because that means the first tryget failed and we don't have a data already
                                    if (mappedType != propertyType)
                                    {
                                        nameMap.Add(keyName, propertyType);
                                    }
                                }
                                else
                                {
                                    // not in the map at all. Add it now.
                                    nameMap.Add(keyName, propertyType);
                                }
                            }
                            else
                            {
                                // get can have a set, but can't have a data or another get
                                // set can have a get, but can't have a data or another set
                                if (nameMap.TryGetValue(keyName, out mappedType)
                                    || nameMap.TryGetValue((property.Name ?? property.Value) + "data", out mappedType))
                                {
                                    // throw the error
                                    (property.Name ?? property.Value).Context.HandleError(JSError.StrictModeDuplicateProperty, true);

                                    // if the mapped type isn't data, then we can add this data name/type to the map
                                    if (mappedType != propertyType)
                                    {
                                        nameMap.Add(keyName, propertyType);
                                    }
                                }
                                else
                                {
                                    // not in the map at all - add it now
                                    nameMap.Add(keyName, propertyType);
                                }
                            }
                        });
                }
            }
        }

        private static bool FieldCanBeRenamed(AstNode node)
        {
            var canBeRenamed = false;
            if (node != null)
            {
                canBeRenamed = (node as INameDeclaration).IfNotNull(n => !n.RenameNotAllowed && n.VariableField.IfNotNull(v => v.CanCrunch));
                if (!canBeRenamed)
                {
                    canBeRenamed = (node as INameReference).IfNotNull(n => n.VariableField.IfNotNull(v => v.CanCrunch));
                }
            }

            return canBeRenamed;
        }

        public override void Visit(ObjectLiteralField node)
        {
            if (node != null)
            {
                if (node.PrimitiveType == PrimitiveType.String
                    && m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.PropertyRenaming))
                {
                    string newName = m_parser.Settings.GetNewName(node.Value.ToString());
                    if (!string.IsNullOrEmpty(newName))
                    {
                        node.Value = newName;
                    }
                }

                // don't call the base -- we don't want to add the literal to
                // the combination logic, which is what the ConstantWrapper (base class) does
                //base.Visit(node);
            }
        }

        public override void Visit(ObjectLiteralProperty node)
        {
            if (node != null)
            {
                base.Visit(node);
                if (node.Value != null && node.Value.IsDebugOnly)
                {
                    node.Value = new ConstantWrapper(null, PrimitiveType.Null, node.Value.Context);
                }
            }
        }

        private static string GetPropertyType(FunctionObject funcObj)
        {
            // should never be a function declaration....
            switch(funcObj.IfNotNull(f => f.FunctionType))
            {
                case FunctionType.Getter:
                    return "get";

                case FunctionType.Setter:
                    return "set";

                case FunctionType.Method:
                    return "method";

                default:
                    return "data";
            }
        }

        public override void Visit(RegExpLiteral node)
        {
            if (node != null)
            {
                // verify the syntax
                try
                {
                    // just try instantiating a Regex object with this string.
                    // if it's invalid, it will throw an exception.
                    // we don't need to pass the flags -- we're just interested in the pattern
                    Regex re = new Regex(node.Pattern, RegexOptions.ECMAScript);

                    // basically we have this test here so the re variable is referenced
                    // and FxCop won't throw an error. There really aren't any cases where
                    // the constructor will return null (other than out-of-memory)
                    if (re == null)
                    {
                        node.Context.HandleError(JSError.RegExpSyntax, true);
                    }
                }
                catch (System.ArgumentException e)
                {
                    Debug.WriteLine(e.ToString());
                    node.Context.HandleError(JSError.RegExpSyntax, true);
                }
                // don't bother calling the base -- there are no children
            }
        }

        public override void Visit(ReturnStatement node)
        {
            if (node != null)
            {
                // first we want to make sure that we are indeed within a function scope.
                // it makes no sense to have a return outside of a function
                ActivationObject scope = m_scopeStack.Peek();
                while (scope != null && !(scope is FunctionScope))
                {
                    scope = scope.Parent;
                }

                if (scope == null)
                {
                    node.Context.HandleError(JSError.BadReturn);
                }

                // recurse the operand if we have one
                if (node.Operand != null)
                {
                    node.Operand.Accept(this);

                    if (node.Operand == null || node.Operand.IsDebugOnly)
                    {
                        node.Operand = null;
                    }
                    else
                    {
                        // now see if it's a binary op assignment to a variable local to this scope.
                        // if it is, we can get rid of the assignment because we're leaving the scope.
                        var lookup = node.Operand.LeftHandSide as LookupExpression;
                        BinaryExpression binaryOp;
                        if (lookup?.VariableField != null
                            && lookup.VariableField.OuterField == null
                            && (binaryOp = lookup.Parent as BinaryExpression) != null
                            && binaryOp.IsAssign
                            && !lookup.VariableField.IsReferencedInnerScope)
                        {
                            if (binaryOp.OperatorToken != JSToken.Assign)
                            {
                                // it's an OP= assignment, so keep the lookup, but convert the operator to a non-assignment
                                binaryOp.OperatorToken = JSScanner.StripAssignment(binaryOp.OperatorToken);
                            }
                            else if (binaryOp.Parent == node)
                            {
                                // straight assignment. But we can only get rid of the assignment if
                                // it's the root operation of the return. If it's buried down in a complex
                                // assignment, then leave it be.
                                lookup.VariableField.References.Remove(lookup);
                                node.Operand = binaryOp.Operand2;
                            }
                        }
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(SwitchStatement node)
        {
            if (node != null)
            {
                base.Visit(node);

                if (node.Expression != null && node.Expression.IsDebugOnly)
                {
                    node.Expression = new ConstantWrapper(null, PrimitiveType.Null, node.Expression.Context);
                }

                // if the switch case has a lexical scope, we need to check to make sure anything declared lexically
                // doesn't collide with anything declared as a var underneath (which bubbles up to the variable scope).
                if (node.BlockScope != null)
                {
                    foreach (var lexDecl in node.BlockScope.LexicallyDeclaredNames)
                    {
                        var varDecl = node.BlockScope.VarDeclaredName(lexDecl.Name);
                        if (varDecl != null)
                        {
                            // report the error (lex/const collides with var) or warning (funcdecl collides with var)
                            varDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, lexDecl is LexicalDeclaration);

                            // mark them both a no-rename to preserve the collision
                            varDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                            lexDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                        }
                    }
                }

                // we only want to remove stuff if we are hypercrunching
                if (m_parser.Settings.RemoveUnneededCode)
                {
                    // because we are looking at breaks, we need to know if this
                    // switch statement is labeled
                    string thisLabel = string.Empty;
                    LabeledStatement label = node.Parent as LabeledStatement;
                    if (label != null)
                    {
                        thisLabel = label.Label;
                    }

                    // loop through all the cases, looking for the default.
                    // then, if it's empty (or just doesn't do anything), we can
                    // get rid of it altogether
                    int defaultCase = -1;
                    bool eliminateDefault = false;
                    for (int ndx = 0; ndx < node.Cases.Count; ++ndx)
                    {
                        // it should always be a switch case, but just in case...
                        SwitchCase switchCase = node.Cases[ndx] as SwitchCase;
                        if (switchCase != null)
                        {
                            if (switchCase.IsDefault)
                            {
                                // save the index for later
                                defaultCase = ndx;

                                // set the flag to true unless we can prove that we need it.
                                // we'll prove we need it by finding the statement block executed by
                                // this case and showing that it's neither empty nor containing
                                // just a single break statement.
                                eliminateDefault = true;
                            }

                            // if the default case is empty, then we need to keep going
                            // until we find the very next non-empty case
                            if (eliminateDefault && switchCase.Statements.Count > 0)
                            {
                                // this is the set of statements executed during default processing.
                                // if it does nothing -- one break statement -- then we can get rid
                                // of the default case. Otherwise we need to leave it in.
                                if (switchCase.Statements.Count == 1)
                                {
                                    // see if it's a break
                                    BreakStatement lastBreak = switchCase.Statements[0] as BreakStatement;

                                    // if the last statement is not a break,
                                    // OR it has a label and it's not this switch statement...
                                    if (lastBreak == null
                                      || (lastBreak.Label != null && lastBreak.Label != thisLabel))
                                    {
                                        // set the flag back to false to indicate that we need to keep it.
                                        eliminateDefault = false;
                                    }
                                }
                                else
                                {
                                    // set the flag back to false to indicate that we need to keep it.
                                    eliminateDefault = false;
                                }

                                // break out of the loop
                                break;
                            }
                        }
                    }

                    // if we get here and the flag is still true, then either the default case is
                    // empty, or it contains only a single break statement. Either way, we can get 
                    // rid of it.
                    if (eliminateDefault && defaultCase >= 0
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveEmptyDefaultCase))
                    {
                        // remove it and reset the position index
                        node.Cases.RemoveAt(defaultCase);
                        defaultCase = -1;
                    }

                    // if we have no default handling, then we know we can get rid
                    // of any cases that don't do anything either.
                    if (defaultCase == -1
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveEmptyCaseWhenNoDefault))
                    {
                        // when we delete a case statement, we set this flag to true.
                        // when we hit a non-empty case statement, we set the flag to false.
                        // if we hit an empty case statement when this flag is true, we can delete this case, too.
                        bool emptyStatements = true;
                        BreakStatement deletedBreak = null;

                        // walk the tree backwards because we don't know how many we will
                        // be deleting, and if we go backwards, we won't have to adjust the 
                        // index as we go.
                        for (int ndx = node.Cases.Count - 1; ndx >= 0; --ndx)
                        {
                            // should always be a switch case
                            SwitchCase switchCase = node.Cases[ndx] as SwitchCase;
                            if (switchCase != null)
                            {
                                // if the block is empty and the last block was empty, we can delete this case.
                                // OR if there is only one statement and it's a break, we can delete it, too.
                                if (switchCase.Statements.Count == 0 && emptyStatements)
                                {
                                    // remove this case statement because it falls through to a deleted case
                                    DetachReferencesVisitor.Apply(switchCase.CaseValue);
                                    node.Cases.RemoveAt(ndx);
                                }
                                else
                                {
                                    // onlyBreak will be set to null if this block is not a single-statement break block
                                    BreakStatement onlyBreak = (switchCase.Statements.Count == 1 ? switchCase.Statements[0] as BreakStatement : null);
                                    if (onlyBreak != null)
                                    {
                                        // we'll only delete this case if the break either doesn't have a label
                                        // OR the label matches the switch statement
                                        if (onlyBreak.Label == null || onlyBreak.Label == thisLabel)
                                        {
                                            // if this is a block with only a break, then we need to keep a hold of the break
                                            // statement in case we need it later
                                            deletedBreak = onlyBreak;

                                            // remove this case statement
                                            DetachReferencesVisitor.Apply(switchCase.CaseValue);
                                            node.Cases.RemoveAt(ndx);
                                            // make sure the flag is set so we delete any other empty
                                            // cases that fell through to this empty case block
                                            emptyStatements = true;
                                        }
                                        else
                                        {
                                            // the break statement has a label and it's not the switch statement.
                                            // we're going to keep this block
                                            emptyStatements = false;
                                            deletedBreak = null;
                                        }
                                    }
                                    else
                                    {
                                        // either this is a non-empty block, or it's an empty case that falls through
                                        // to a non-empty block. if we have been deleting case statements and this
                                        // is not an empty block....
                                        if (emptyStatements && switchCase.Statements.Count > 0 && deletedBreak != null)
                                        {
                                            // we'll need to append the deleted break statement if it doesn't already have
                                            // a flow-changing statement: break, continue, return, or throw
                                            AstNode lastStatement = switchCase.Statements[switchCase.Statements.Count - 1];
                                            if (!(lastStatement is BreakStatement) && !(lastStatement is ContinueStatement)
                                              && !(lastStatement is ReturnStatement) && !(lastStatement is ThrowStatement))
                                            {
                                                switchCase.Statements.Append(deletedBreak);
                                            }
                                        }

                                        // make sure the deletedBreak flag is reset
                                        deletedBreak = null;

                                        // reset the flag
                                        emptyStatements = false;
                                    }
                                }
                            }
                        }
                    }

                    // if the last case's statement list ends in a break, 
                    // we can get rid of the break statement
                    if (node.Cases.Count > 0
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveBreakFromLastCaseBlock))
                    {
                        SwitchCase lastCase = node.Cases[node.Cases.Count - 1] as SwitchCase;
                        if (lastCase != null)
                        {
                            // get the block of statements making up the last case block
                            BlockStatement lastBlock = lastCase.Statements;
                            // if the last statement is not a break, then lastBreak will be null
                            BreakStatement lastBreak = (lastBlock.Count > 0 ? lastBlock[lastBlock.Count - 1] as BreakStatement : null);
                            // if lastBreak is not null and it either has no label, or the label matches this switch statement...
                            if (lastBreak != null
                              && (lastBreak.Label == null || lastBreak.Label == thisLabel))
                            {
                                // remove the break statement
                                lastBlock.RemoveLast();
                            }
                        }
                    }
                }
            }
        }

        public override void Visit(TryStatement node)
        {
            if (node != null)
            {
                // anaylze the blocks
                node.TryBlock.IfNotNull(b => b.Accept(this));
                // if the try block is empty, then set it to null
                if (node.TryBlock != null && node.TryBlock.Count == 0)
                {
                    node.TryBlock = null;
                }

                DoCatchBlock(node);

                node.FinallyBlock.IfNotNull(b => b.Accept(this));
                // eliminate an empty finally block UNLESS there is no catch block.
                if (node.FinallyBlock != null && node.FinallyBlock.Count == 0 && node.CatchBlock != null
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveEmptyFinally))
                {
                    node.FinallyBlock = null;
                }
            }
        }

        private void DoCatchBlock(TryStatement node)
        {
            node.CatchBlock.IfNotNull(b => b.Accept(this));
            if (node.CatchParameter != null)
            {
                // check for binding errors (strict names, etc)
                m_strictNameError = JSError.StrictModeCatchName;
                node.CatchParameter.Accept(this);
                m_strictNameError = JSError.StrictModeVariableName;

                // if the block has a lexical scope, check it for conflicts
                var catchBindings = BindingsVisitor.Bindings(node.CatchParameter);
                foreach (var lexDecl in node.CatchBlock.EnclosingScope.LexicallyDeclaredNames)
                {
                    foreach (var catchDecl in catchBindings)
                    {
                        if (lexDecl != catchDecl
                            && string.CompareOrdinal(lexDecl.Name, catchDecl.Name) == 0)
                        {
                            // report the error (catchvar collides with lex/const) or warning (catchvar collides with funcdecl)
                            lexDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, lexDecl is LexicalDeclaration);

                            // link the inner one to the outer one so any renaming stays in sync.
                            if (lexDecl.VariableField != null)
                            {
                                lexDecl.VariableField.OuterField = catchDecl.VariableField;
                                if (catchDecl.VariableField != null && !lexDecl.VariableField.CanCrunch)
                                {
                                    catchDecl.VariableField.CanCrunch = false;
                                }
                            }
                        }
                    }
                }

                // check to make sure there are no var-decl'd names with the same name. 
                foreach (var varDecl in node.CatchBlock.EnclosingScope.VarDeclaredNames)
                {
                    foreach (var catchDecl in catchBindings)
                    {
                        if (string.CompareOrdinal(varDecl.Name, catchDecl.Name) == 0)
                        {
                            // report the warning (catchvar collides with var)
                            // we shouldn't have to link them; the catchvar should already ghosted.
                            varDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, false);
                        }
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(UnaryExpression node)
        {
            if (node != null)
            {
                base.Visit(node);

                if (node.Operand != null && node.Operand.IsDebugOnly)
                {
                    node.IsDebugOnly = true;
                    switch (node.OperatorToken)
                    {
                        case JSToken.Void:
                            // void *anything* is the same as void 0
                            node.Operand = new ConstantWrapper(0, PrimitiveType.Number, node.Operand.Context);
                            break;

                        case JSToken.TypeOf:
                            // typeof null is "object"
                            node.Parent.ReplaceChild(node, new ConstantWrapper("object", PrimitiveType.String, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        case JSToken.Delete:
                            // delete null is true
                            node.Operand = new ConstantWrapper(true, PrimitiveType.Boolean, node.Context);
                            break;

                        case JSToken.Increment:
                        case JSToken.Decrement:
                            // ++ and -- result in a number, so just replace with 0
                            node.Parent.ReplaceChild(node, new ConstantWrapper(0, PrimitiveType.Number, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        case JSToken.LogicalNot:
                            // !null is true
                            node.Parent.ReplaceChild(node, new ConstantWrapper(true, PrimitiveType.Boolean, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        case JSToken.BitwiseNot:
                            // ~null is -1
                            node.Parent.ReplaceChild(node, new ConstantWrapper(-1, PrimitiveType.Number, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        case JSToken.Plus:
                            // +null is zero
                            node.Parent.ReplaceChild(node, new ConstantWrapper(0, PrimitiveType.Number, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        case JSToken.Minus:
                            // -null is negative zero
                            node.Parent.ReplaceChild(node, new ConstantWrapper(-0, PrimitiveType.Number, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        default:
                            node.Operand = ClearDebugExpression(node.Operand);
                            break;
                    }
                }
                else
                {
                    // strict mode has some restrictions
                    if (node.OperatorToken == JSToken.Delete)
                    {
                        if (m_scopeStack.Peek().UseStrict)
                        {
                            // operand of a delete operator cannot be a variable name, argument name, or function name
                            // which means it can't be a lookup
                            if (node.Operand is LookupExpression)
                            {
                                node.Context.HandleError(JSError.StrictModeInvalidDelete, true);
                            }
                        }
                    }
                    else if (node.OperatorToken == JSToken.Increment || node.OperatorToken == JSToken.Decrement)
                    {
                        var lookup = node.Operand as LookupExpression;
                        if (lookup != null)
                        {
                            if (lookup.VariableField != null && lookup.VariableField.InitializationOnly)
                            {
                                // can't increment or decrement a constant!
                                lookup.Context.HandleError(JSError.AssignmentToConstant, true);
                            }

                            // and strict mode has some restrictions we want to check now
                            if (m_scopeStack.Peek().UseStrict)
                            {
                                // the operator cannot be the eval function or arguments object.
                                // that means the operator is a lookup, and the field for that lookup
                                // is the arguments object or the predefined "eval" object.
                                if (lookup.VariableField == null
                                    || lookup.VariableField.FieldType == FieldType.UndefinedGlobal
                                    || lookup.VariableField.FieldType == FieldType.Arguments
                                    || (lookup.VariableField.FieldType == FieldType.Predefined 
                                    && string.CompareOrdinal(lookup.Name, "eval") == 0))
                                {
                                    node.Operand.Context.HandleError(JSError.StrictModeInvalidPreOrPost, true);
                                }
                            }
                        }
                    }
                    else if (node.OperatorToken == JSToken.TypeOf)
                    {
                        if (m_parser.Settings.RemoveUnneededCode
                            && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveWindowDotFromTypeOf))
                        {
                            // we want to see if the typeof operand is window.name -- which is getting the type string of 
                            // a potential global variable. If "name" would otherwise resolve to the global namespace (either
                            // defined or undefined), then we can really get rid of the "window." part because the typeof
                            // operator will work just fine if the operand is undefined (it won't throw a reference error).
                            var member = node.Operand as MemberExpression;
                            if (member != null)
                            {
                                var lookup = member.Root as LookupExpression;
                                if (lookup?.VariableField != null
                                    && lookup.VariableField.FieldType == FieldType.Predefined
                                    && lookup.Name == "window")
                                {
                                    // we have window.name
                                    // now check to see if the name part of our member would resolve to something in
                                    // the global namespace.
                                    var name = member.Name;
                                    var enclosingScope = member.EnclosingScope;
                                    var existingField = enclosingScope.CanReference(name);
                                    if (existingField == null
                                        || existingField.FieldType == FieldType.Predefined
                                        || existingField.FieldType == FieldType.Global
                                        || existingField.FieldType == FieldType.UndefinedGlobal)
                                    {
                                        // replace the member with a lookup on the name.
                                        // first, detach the reference to window
                                        DetachReferencesVisitor.Apply(lookup);

                                        // (just reuse the lookup for "window" by changing the name and doing
                                        // a formal reference lookup on it (which will generate fields if needed)
                                        lookup.Name = name;
                                        lookup.VariableField = enclosingScope.FindReference(name);
                                        node.Operand = lookup;

                                        // and make sure we increment the new reference
                                        lookup.VariableField.AddReference(lookup);
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // if the operand is a numeric literal
                        ConstantWrapper constantWrapper = node.Operand as ConstantWrapper;
                        if (constantWrapper != null && constantWrapper.IsNumericLiteral)
                        {
                            // get the value of the constant. We've already screened it for numeric, so
                            // we don't have to worry about catching any errors
                            double doubleValue = constantWrapper.ToNumber();

                            // if this is a unary minus...
                            if (node.OperatorToken == JSToken.Minus
                                && m_parser.Settings.IsModificationAllowed(TreeModifications.ApplyUnaryMinusToNumericLiteral))
                            {
                                // negate the value
                                constantWrapper.Value = -doubleValue;

                                // replace us with the negated constant
                                if (node.Parent.ReplaceChild(node, constantWrapper))
                                {
                                    // the context for the minus will include the number (its operand),
                                    // but the constant will just be the number. Update the context on
                                    // the constant to be a copy of the context on the operator
                                    constantWrapper.Context = node.Context.Clone();
                                }
                            }
                            else if (node.OperatorToken == JSToken.Plus
                                && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnaryPlusOnNumericLiteral))
                            {
                                // +NEG is still negative, +POS is still positive, and +0 is still 0.
                                // so just get rid of the unary operator altogether
                                if (node.Parent.ReplaceChild(node, constantWrapper))
                                {
                                    // the context for the unary will include the number (its operand),
                                    // but the constant will just be the number. Update the context on
                                    // the constant to be a copy of the context on the operator
                                    constantWrapper.Context = node.Context.Clone();
                                }
                            }
                        }
                    }
                }
            }
        }

        public override void Visit(VarDeclaration node)
        {
            if (node != null)
            {
                // first we want to weed out duplicates that don't have initializers
                // var a=1, a=2 is okay, but var a, a=2 and var a=2, a should both be just var a=2, 
                // and var a, a should just be var a
                if (m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveDuplicateVar))
                {
                    // first we want to weed out duplicates that don't have initializers
                    // var a=1, a=2 is okay, but var a, a=2 and var a=2, a should both be just var a=2, 
                    // and var a, a should just be var a
                    // only do this for simple binding identifier; leave binding patterns alone
                    int ndx = 0;
                    while (ndx < node.Count)
                    {
                        var bindingIdentifier = node[ndx].Binding as BindingIdentifier;
                        if (bindingIdentifier != null)
                        {
                            var thisName = bindingIdentifier.Name;

                            // handle differently if we have an initializer or not
                            if (node[ndx].Initializer != null)
                            {
                                // the current vardecl has an initializer, so we want to delete any other
                                // simple binding identifier vardecls of the same name in the rest of the 
                                // list with no initializer and move on to the next item afterwards
                                DeleteNoInits(node, ++ndx, thisName);
                            }
                            else
                            {
                                // this vardecl has no initializer, so we can delete it if there is ANY
                                // other vardecl with the same name (whether or not it has an initializer)
                                if (VarDeclExists(node, ndx + 1, thisName))
                                {
                                    // don't increment the index; we just deleted the current item,
                                    // so the next item just slid into this position
                                    bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);
                                    node.RemoveAt(ndx);
                                }
                                else
                                {
                                    // nope -- it's the only one. Move on to the next
                                    ++ndx;
                                }
                            }
                        }
                        else
                        {
                            ++ndx;
                        }
                    }
                }

                // recurse the analyze
                base.Visit(node);
            }
        }

        public override void Visit(VariableDeclaration node)
        {
            if (node != null)
            {
                base.Visit(node);

                if (node.Initializer != null && node.Initializer.IsDebugOnly)
                {
                    node.Initializer = ClearDebugExpression(node.Initializer);
                }

                // if this is a binding pattern and the parent is NOT a for-in loop,
                // then we MUST have an initializer as per the language syntax!
                if (node.Initializer == null 
                    && !(node.Binding is BindingIdentifier)
                    && node.Parent.IfNotNull(p => !(p.Parent is ForInStatement)))
                {
                    // binding patterns in declarations (var/const/let) must always be followed by an assignment
                    node.Binding.Context.HandleError(JSError.BindingPatternRequiresInitializer, true);
                }

                // if this is a special-case vardecl (var foo/*@cc_on=EXPR@*/), set the flag indicating
                // we encountered a @cc_on statement if we found one
                if (node.IsCCSpecialCase && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryCCOnStatements))
                {
                    node.UseCCOn = !m_encounteredCCOn;
                    m_encounteredCCOn = true;
                }
            }
        }

        public override void Visit(WhileStatement node)
        {
            if (node != null)
            {
                // recurse
                base.Visit(node);

                // if the body is now empty, make it null
                if (node.Body != null && node.Body.Count == 0)
                {
                    node.Body = null;
                }

                if (node.Condition != null && node.Condition.IsDebugOnly)
                {
                    if (node.Body == null)
                    {
                        node.IsDebugOnly = true;
                    }
                    else
                    {
                        node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                    }
                }
            }
        }

        public override void Visit(WithStatement node)
        {
            if (node != null)
            {
                // throw a warning discouraging the use of this statement
                if (m_scopeStack.Peek().UseStrict)
                {
                    // with-statements not allowed in strict code at all
                    node.Context.HandleError(JSError.StrictModeNoWith, true);
                }
                else
                {
                    // not strict, but still not recommended
                    node.Context.HandleError(JSError.WithNotRecommended, false);
                }

                // hold onto the with-scope in case we need to do something with it
                var withScope = node.Body.IfNotNull(b => b.EnclosingScope);

                // recurse
                base.Visit(node);

                // we'd have to know what the object (obj) evaluates to before we
                // can figure out what to add to the scope -- not possible without actually
                // running the code. This could throw a whole bunch of 'undefined' errors.
                if (node.Body != null && node.Body.Count == 0)
                {
                    node.Body = null;
                }

                // we got rid of the block -- tidy up the no-longer-needed scope
                if (node.Body == null && withScope != null)
                {
                    // because the scope is empty, we now know it (it does nothing)
                    withScope.IsKnownAtCompileTime = true;
                }

                if (node.WithObject != null && node.WithObject.IsDebugOnly)
                {
                    if (node.Body == null)
                    {
                        node.IsDebugOnly = true;
                    }
                    else
                    {
                        node.WithObject = new ObjectLiteral(node.WithObject.Context)
                            {
                                IsDebugOnly = true
                            };
                    }
                }
            }
        }

        #endregion

        private static AstNode ClearDebugExpression(AstNode node)
        {
            if (node == null || node is ObjectLiteral || node is ConstantWrapper)
            {
                return node;
            }

            return new ObjectLiteral(node.Context)
                {
                    IsDebugOnly = true
                };
        }

        private static string GuessAtName(AstNode node)
        {
            string guess = string.Empty;
            var parent = node.Parent;

            if (parent != null)
            {
                if (parent is AstNodeList)
                {
                    // if the parent is an ASTList, then we're really interested
                    // in our parent's parent (probably a call)
                    parent = parent.Parent;
                }

                CallExpression call = parent as CallExpression;
                if (call != null && call.IsConstructor)
                {
                    // if this function expression is the object of a new, then we want the parent
                    parent = parent.Parent;
                }

                guess = parent.GetFunctionGuess(node);
            }

            return guess;
        }

        private static bool AreAssignmentsInVar(BinaryExpression binaryOp, VarDeclaration varStatement)
        {
            bool areAssignmentsInVar = false;

            if (binaryOp != null)
            {
                // we only want to pop positive for the simple assign (=). If it's any of the 
                // complex assigns (+=, -=, etc) then we don't want to combine them.
                if (binaryOp.OperatorToken == JSToken.Assign)
                {
                    // see if the left-hand side is a simple lookup
                    LookupExpression lookup = binaryOp.Operand1 as LookupExpression;
                    if (lookup != null)
                    {
                        // it is. see if that variable is in the previous var statement
                        areAssignmentsInVar = varStatement.Contains(lookup.Name);
                    }
                }
                else if (binaryOp.OperatorToken == JSToken.Comma)
                {
                    // this is a comma operator, so we will return true only if both
                    // left and right operators are assignments to vars defined in the 
                    // var statement
                    areAssignmentsInVar = AreAssignmentsInVar(binaryOp.Operand1 as BinaryExpression, varStatement)
                        && AreAssignmentsInVar(binaryOp.Operand2 as BinaryExpression, varStatement);
                }
            }

            return areAssignmentsInVar;
        }

        private static void ConvertAssignmentsToVarDecls(BinaryExpression binaryOp, Declaration declaration, JSParser parser)
        {
            // we've already checked that the tree only contains simple assignments separate by commas,
            // but just in case we'll check for null anyway
            if (binaryOp != null)
            {
                if (binaryOp.OperatorToken == JSToken.Assign)
                {
                    // we've already cleared this as a simple lookup, but run the check just to be sure
                    LookupExpression lookup = binaryOp.Operand1 as LookupExpression;
                    if (lookup != null)
                    {
                        var bindingIdentifier = new BindingIdentifier(lookup.Context)
                                {
                                    Name = lookup.Name,
                                    TerminatingContext = lookup.TerminatingContext,
                                    VariableField = lookup.VariableField
                                };
                        var varDecl = new VariableDeclaration(binaryOp.Context.Clone())
                            {
                                Binding = bindingIdentifier,
                                AssignContext = binaryOp.OperatorContext,
                                Initializer = binaryOp.Operand2,
                            };
                        lookup.VariableField.Declarations.Add(bindingIdentifier);
                        declaration.Append(varDecl);
                    }
                }
                else if (binaryOp.OperatorToken == JSToken.Comma)
                {
                    // recurse both operands
                    ConvertAssignmentsToVarDecls(binaryOp.Operand1 as BinaryExpression, declaration, parser);
                    ConvertAssignmentsToVarDecls(binaryOp.Operand2 as BinaryExpression, declaration, parser);
                }
                // shouldn't ever be anything but these two operators
            }
        }

        private static bool VarDeclExists(VarDeclaration node, int ndx, string name)
        {
            // only need to look forward from the index passed
            for (; ndx < node.Count; ++ndx)
            {
                var varDecl = node[ndx];
                foreach (var bindingIdentifier in BindingsVisitor.Bindings(varDecl))
                {
                    // string must be exact match
                    if (string.CompareOrdinal(name, bindingIdentifier.Name) == 0)
                    {
                        // there is at least one -- we can bail
                        return true;
                    }
                }
            }
            // if we got here, we didn't find any matches
            return false;
        }

        private static void DeleteNoInits(VarDeclaration node, int min, string name)
        {
            // walk backwards from the end of the list down to (and including) the minimum index
            for (int ndx = node.Count - 1; ndx >= min; --ndx)
            {
                var varDecl = node[ndx];
                var bindingIdentifier = varDecl.Binding as BindingIdentifier;

                // if it's a simple binding identifier, the name matches and there is no initializer...
                if (bindingIdentifier != null
                    && string.CompareOrdinal(name, bindingIdentifier.Name) == 0
                    && varDecl.Initializer == null)
                {
                    // ...remove it from the list and from the field's declarations
                    node.RemoveAt(ndx);
                    bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);
                }
            }
        }

        private static UnaryExpression CreateVoidNode(SourceContext context)
        {
            return new UnaryExpression(context.FlattenToStart())
                {
                    Operand = new ConstantWrapper(0.0, PrimitiveType.Number, context),
                    OperatorToken = JSToken.Void
                };
        }

        private static void ValidateIdentifier(bool isStrict, string identifier, SourceContext context, JSError error)
        {
            // check the name of the variable for reserved words that aren't allowed
            if (JSScanner.IsKeyword(identifier, isStrict))
            {
                context.HandleError(JSError.KeywordUsedAsIdentifier, true);
            }
            else if (isStrict
                && (string.CompareOrdinal(identifier, "eval") == 0
                || string.CompareOrdinal(identifier, "arguments") == 0))
            {
                // strict mode cannot declare variables named "eval" or "arguments"
                context.HandleError(error, true);
            }
        }

        private static bool IsInsideLoop(AstNode node, bool orSwitch)
        {
            // assume we are not
            var insideLoop = false;

            // loop until we get to the top or we get to a function object,
            // which is an entirely different scope.
            while (node != null && !(node is FunctionObject))
            {
                // while, do-while, and for/for-in are loops.
                // break can also appear in switch-statements, so check that too if the appropriate flag is passed.
                if (node is WhileStatement
                    || node is DoWhileStatement
                    || node is ForInStatement
                    || node is ForStatement
                    || (orSwitch && node is SwitchCase))
                {
                    // we are in a loop (or maybe a switch)
                    return true;
                }

                // go up the tree
                node = node.Parent;
            }

            // if we get here, we're not in a loop
            return insideLoop;
        }

        private static bool IsInsideLabel(AstNode node, string label)
        {
            // assume we are not
            var insideLabel = false;

            // go up until we get to the top or we get to a function object
            while (node != null && !(node is FunctionObject))
            {
                if (node is LabeledStatement && string.Compare(((LabeledStatement)node).Label, label) == 0)
                {
                    // we have a matching label
                    return true;
                }

                // go up the tree
                node = node.Parent;
            }

            // if we get here, we're not in a nested label
            return insideLabel;
        }

        private static AstNode ReplaceCultureValue(ConstantWrapper node)
        {
            // get the name of the token.
            var tokenName = node.Value.ToString().Trim('%');
            var path = tokenName.Split('.');
            if (path.Length > 0 && path[0].Equals("CurrentCulture", StringComparison.Ordinal))
            {
                object currentObject = CultureInfo.CurrentCulture;
                for(var ndx = 1; ndx < path.Length; ++ndx)
                {
                    var objectType = currentObject.GetType();
                    int index;
                    if (objectType.IsArray && int.TryParse(path[ndx], out index))
                    {
                        // integer index into an array
                        try
                        {
                            var getMethod = objectType.GetMethod("Get", new[] { typeof(int) });
                            if (getMethod != null)
                            {
                                currentObject = getMethod.Invoke(currentObject, new object[] { index });
                                continue;
                            }
                        }
                        catch(AmbiguousMatchException)
                        {
                            // eat this exception
                        }
                    }
                    else
                    {
                        // not an integer array index
                        try
                        {
                            var propertyInfo = objectType.GetProperty(path[ndx]);
                            if (propertyInfo != null)
                            {
                                currentObject = propertyInfo.GetValue(currentObject, null);
                                continue;
                            }
                        }
                        catch (AmbiguousMatchException)
                        {
                            // eat this exception
                        }
                    }

                    // if we get here, never mind
                    currentObject = null;
                    break;
                }

                if (currentObject != null)
                {
                    if (node.PrimitiveType == PrimitiveType.String)
                    {
                        // just make the value of the string be the string representation
                        // of the current object
                        node.Value = currentObject.ToString();
                    }
                    else 
                    {
                        // create an appropriate node and replace the token node with it
                        var newNode = CreateNodeFromObject(node.Context, currentObject);
                        node.Parent.ReplaceChild(node, newNode);
                        return newNode;
                    }
                }
            }

            return node;
        }

        private static AstNode CreateNodeFromObject(SourceContext context, object item)
        {
            if (item == null)
            {
                return new ConstantWrapper(null, PrimitiveType.Null, context);
            }
            
            if (item is String)
            {
                // create a string literal
                return  new ConstantWrapper(item, PrimitiveType.String, context);
            }
            
            if (item is Boolean)
            {
                // create a boolean literal
                return new ConstantWrapper(item, PrimitiveType.Boolean, context);
            }
            
            if (item is Int16
                || item is UInt16
                || item is Int32
                || item is UInt32
                || item is Int64
                || item is UInt64
                || item is Single
                || item is Double)
            {
                // create a numeric literal, forcing the number to double
                return new ConstantWrapper(Convert.ToDouble(item, CultureInfo.InvariantCulture), PrimitiveType.Number, context);
            }

            if (item is DateTime dateTime)
            {
                return new ConstantWrapper(dateTime.ToString("s", CultureInfo.InvariantCulture), PrimitiveType.String, context);
            }

            if (item.GetType().GetTypeInfo().IsValueType)
            {
                return new ConstantWrapper(item.ToString(), PrimitiveType.String, context);
            }

            var arrayObject = item as Array;
            if (arrayObject != null)
            {
                // create an array literal from the array
                var arrayLiteral = new ArrayLiteral(context)
                    {
                        Elements = new AstNodeList(context)
                    };
                foreach (var element in arrayObject)
                {
                    arrayLiteral.Elements.Append(CreateNodeFromObject(context, element));
                }

                return arrayLiteral;
            }

            // create an object literal from all the public unambiguous properties on the item object
            var objectLiteral = new ObjectLiteral(context)
                {
                    Properties = new AstNodeList(context)
                };
            var properties = item.GetType().GetTypeInfo().GetDeclaredProperties();
            foreach(var property in properties)
            {
                try
                {
                    var propertyValue = property.GetValue(item, null);
                    if (propertyValue != item)
                    {
                        var valueNode = CreateNodeFromObject(context, propertyValue);
                        objectLiteral.Properties.Append(new ObjectLiteralProperty(context)
                        {
                            Name = new ObjectLiteralField(property.Name, PrimitiveType.String, context),
                            Value = valueNode,
                        });
                    }
                }
                catch(AmbiguousMatchException)
                {
                    // ignore this property
                }
            }

            return objectLiteral;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Text.RegularExpressions;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;
using SwitchStatement = NUglify.JavaScript.Syntax.SwitchStatement;

namespace NUglify.JavaScript.Visitors
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
    internal class AnalyzeNodeVisitor : TreeVisitor
    {
        private JSParser m_parser;
        private bool m_encounteredCCOn;// = false;
        private MatchPropertiesVisitor m_matchVisitor;// == null;
        private Stack<ActivationObject> m_scopeStack;
        private JSError m_strictNameError = JSError.StrictModeVariableName;
        private HashSet<string> m_noRename;
        private bool m_stripDebug;
        private bool m_lookForDebugNamespaces;
        private bool m_possibleDebugNamespace;
        private int m_possibleDebugNamespaceIndex;
        private List<string[]> m_possibleDebugMatches;
        private string[][] m_debugNamespaceParts;

        public AnalyzeNodeVisitor(JSParser parser)
        {
            m_parser = parser;
            m_scopeStack = new Stack<ActivationObject>();
            m_scopeStack.Push(parser.GlobalScope);

            // see if we want to strip debug namespaces, and create the matching list if we do.
            m_stripDebug = m_parser.Settings.StripDebugStatements
                && m_parser.Settings.IsModificationAllowed(TreeModifications.StripDebugStatements);
            m_lookForDebugNamespaces = m_stripDebug && m_parser.DebugLookups.Count > 0;
            if (m_lookForDebugNamespaces)
            {
                m_possibleDebugMatches = new List<string[]>();
                m_debugNamespaceParts = new string[m_parser.DebugLookups.Count][];
                var ndx = 0;
                foreach (var debugNamespace in m_parser.DebugLookups)
                {
                    m_debugNamespaceParts[ndx++] = debugNamespace.Split('.');
                }
            }

            if (m_parser.Settings.LocalRenaming != LocalRenaming.KeepAll)
            {
                m_noRename = new HashSet<string>(m_parser.Settings.NoAutoRenameCollection);
            }
        }

        #region IVisitor

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(BinaryExpression node)
        {
            if (node != null)
            {
                if (node.Operand1 != null)
                {
                    node.Operand1.Accept(this);
                }

                if (node.Operand2 != null)
                {
                    node.Operand2.Accept(this);
                }

                if ((node.Operand1 == null || node.Operand1.IsDebugOnly) 
                    && (node.Operand2 == null || node.Operand2.IsDebugOnly))
                {
                    // if both operands are debug-only, then this whole expression is debug only.
                    // if the right-hand side is debug only and this is an assignment, then this operation is debug-only.
                    node.IsDebugOnly = true;
                }
                else
                {
                    if (node.Operand1 != null && node.Operand1.IsDebugOnly)
                    {
                        node.Operand1 = ClearDebugExpression(node.Operand1);
                    }

                    if (node.Operand2 != null && node.Operand2.IsDebugOnly)
                    {
                        node.Operand2 = ClearDebugExpression(node.Operand2);
                    }

                    // see if this operation is subtracting zero from a lookup -- that is typically done to
                    // coerce a value to numeric. There's a simpler way: unary plus operator.
                    if (node.OperatorToken == JSToken.Minus
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.SimplifyStringToNumericConversion))
                    {
                        if (node.Operand1 is LookupExpression lookup)
                        {
                            if (node.Operand2 is ConstantWrapper right && right.IsIntegerLiteral && right.ToNumber() == 0)
                            {
                                // okay, so we have "lookup - 0"
                                // this is done frequently to force a value to be numeric. 
                                // There is an easier way: apply the unary + operator to it. 
                                // transform: lookup - 0   => +lookup
                                var unary = new UnaryExpression(node.Context)
                                    {
                                        Operand = lookup,
                                        OperatorToken = JSToken.Plus
                                    };
                                node.Parent.ReplaceChild(node, unary);

                                // because we recursed at the top of this function, we don't need to Analyze
                                // the new Unary node. This visitor's method for UnaryOperator only does something
                                // if the operand is a constant -- and this one is a Lookup. And we already analyzed
                                // the lookup.
                            }
                        }
                    }
                    else if ((node.OperatorToken == JSToken.StrictEqual || node.OperatorToken == JSToken.StrictNotEqual)
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.ReduceStrictOperatorIfTypesAreSame))
                    {
                        PrimitiveType leftType = node.Operand1.FindPrimitiveType();
                        if (leftType != PrimitiveType.Other)
                        {
                            PrimitiveType rightType = node.Operand2.FindPrimitiveType();
                            if (leftType == rightType)
                            {
                                // the are the same known types. We can reduce the operators
                                node.OperatorToken = node.OperatorToken == JSToken.StrictEqual ? JSToken.Equal : JSToken.NotEqual;
                            }
                            else if (rightType != PrimitiveType.Other)
                            {
                                // they are not the same, but they are both known. We can completely remove the operator
                                // and replace it with true (!==) or false (===).
                                // transform: x !== y   =>   true
                                // transform: x === y   =>   false
                                node.Context.HandleError(JSError.StrictComparisonIsAlwaysTrueOrFalse, false);
                                node.Parent.ReplaceChild(
                                    node,
                                    new ConstantWrapper(node.OperatorToken == JSToken.StrictNotEqual, PrimitiveType.Boolean, node.Context));

                                // because we are essentially removing the node from the AST, be sure to detach any references
                                DetachReferencesVisitor.Apply(node);
                            }
                        }
                    }
                    else if (node.IsAssign)
                    {
                        if (node.Operand1 is LookupExpression lookup)
                        {
                            if (lookup.VariableField != null && lookup.VariableField.InitializationOnly)
                            {
                                // the field is an initialization-only field -- we should NOT be assigning to it
                                lookup.Context.HandleError(JSError.AssignmentToConstant, true);
                            }
                            else if (m_scopeStack.Peek().UseStrict)
                            {
                                if (lookup.VariableField == null || lookup.VariableField.FieldType == FieldType.UndefinedGlobal)
                                {
                                    // strict mode cannot assign to undefined fields
                                    node.Operand1.Context.HandleError(JSError.StrictModeUndefinedVariable, true);
                                }
                                else if (lookup.VariableField.FieldType == FieldType.Arguments
                                    || (lookup.VariableField.FieldType == FieldType.Predefined 
                                    && string.CompareOrdinal(lookup.Name, "eval") == 0))
                                {
                                    // strict mode cannot assign to lookup "eval" or "arguments"
                                    node.Operand1.Context.HandleError(JSError.StrictModeInvalidAssign, true);
                                }
                            }
                        }
                    }
                    else if ((node.Parent is BlockStatement || (node.Parent is CommaExpression && node.Parent.Parent is BlockStatement))
                        && (node.OperatorToken == JSToken.LogicalOr || node.OperatorToken == JSToken.LogicalAnd))
                    {
                        // this is an expression statement where the operator is || or && -- basically
                        // it's a shortcut for an if-statement:
                        // expr1&&expr2; ==> if(expr1)expr2;
                        // expr1||expr2; ==> if(!expr1)expr2;
                        // let's check to see if the not of expr1 is smaller. If so, we can not the expression
                        // and change the operator
                        var logicalNot = new LogicalNotVisitor(node.Operand1, m_parser.Settings);
                        if (logicalNot.Measure() < 0)
                        {
                            // it would be smaller! Change it.
                            // transform: expr1&&expr2 => !expr1||expr2
                            // transform: expr1||expr2 => !expr1&&expr2
                            logicalNot.Apply();
                            node.OperatorToken = node.OperatorToken == JSToken.LogicalAnd ? JSToken.LogicalOr : JSToken.LogicalAnd;
                        }
                    }
                }
            }
        }

        public override void Visit(BindingIdentifier node)
        {
            if (node != null)
            {
                ValidateIdentifier(m_scopeStack.Peek().UseStrict, node.Name, node.Context, m_strictNameError);
            }
        }

        private void CombineExpressions(BlockStatement node)
        {
            // walk backwards because we'll be removing items as we go along.
            // and don't bother looking at the first element, because we'll be attempting to combine
            // the current element with the previous element -- and the first element (0) has no
            // previous element.
            // we will check for:
            //      1) expr1;expr2           ==> expr1,expr2
            //      2) expr1;for(;...)       ==> for(expr1;...)
            //      3) expr1;for(expr2;...)  ==> for(expr1,expr2;...)
            //      4) expr1;return expr2    ==> return expr1,expr2
            //      5) expr1;if(cond)...     ==> if(expr1,cond)...
            //      6) expr1;while(cond)...  ==> for(expr;cond;)...
            //      7) lookup=expr1;lookup[OP]=expr2;   ==> lookup=expr1[OP]expr2
            //      8) lookup[OP1]=expr1;lookup[OP2]=expr2  ==> lookup=(lookup[OP1]expr1)[OP2]expr2
            for (var ndx = node.Count - 1; ndx > 0; --ndx)
            {
                // we may have deleted more than 1 statement, in which case we need to loop around
                // again to let ndx catch up to the last item in the block
                if (ndx >= node.Count)
                {
                    continue;
                }

                // see if the previous statement is an expression
                if (node[ndx - 1].IsExpression)
                {
                    CombineWithPreviousExpression(node, ndx);
                }
                else if (node[ndx - 1] is VarDeclaration previousVar)
                {
                    CombineWithPreviousVar(node, ndx, previousVar);
                }
            }
        }

        private void CombineWithPreviousExpression(BlockStatement node, int ndx)
        {
            IfStatement ifNode;
            ForStatement forStatement;
            WhileStatement whileNode;
            ReturnStatement returnNode;
            if (node[ndx].IsExpression)
            {
                CombineTwoExpressions(node, ndx);
            }
            else if ((returnNode = node[ndx] as ReturnStatement) != null)
            {
                CombineReturnWithExpression(node, ndx, returnNode);
            }
            else if ((forStatement = node[ndx] as ForStatement) != null)
            {
                CombineForNodeWithExpression(node, ndx, forStatement);
            }
            else if ((ifNode = node[ndx] as IfStatement) != null)
            {
                // transform: expr;if(cond)... => if(expr,cond)...
                // combine the previous expression with the if-condition via comma, then delete
                // the previous statement.
                ifNode.Condition = CommaExpression.CombineWithComma(node[ndx - 1].Context.FlattenToStart(), node[ndx - 1], ifNode.Condition);
                node.RemoveAt(ndx - 1);
            }
            else if ((whileNode = node[ndx] as WhileStatement) != null
                && m_parser.Settings.IsModificationAllowed(TreeModifications.ChangeWhileToFor))
            {
                // transform: expr;while(cond)... => for(expr;cond;)...
                // zero-sum, and maybe a little worse for performance because of the nop iterator,
                // but combines two statements into one, which may have savings later on.
                var initializer = node[ndx - 1];
                node[ndx] = new ForStatement(initializer.Context.FlattenToStart())
                {
                    Initializer = initializer,
                    Condition = whileNode.Condition,
                    Body = whileNode.Body
                };
                node.RemoveAt(ndx - 1);
            }
        }

        private static void CombineTwoExpressions(BlockStatement node, int ndx)
        {
            LookupExpression lookup;
            if (node[ndx - 1] is BinaryExpression prevBinary
                && node[ndx] is BinaryExpression curBinary
                && prevBinary.IsAssign
                && curBinary.IsAssign
                && curBinary.OperatorToken != JSToken.Assign
                && (lookup = curBinary.Operand1 as LookupExpression) != null
                && prevBinary.Operand1.IsEquivalentTo(curBinary.Operand1))
            {
                if (prevBinary.OperatorToken == JSToken.Assign
                    && !ReferencesVisitor.References(curBinary.Operand2, lookup))
                {
                    // transform: lookup=expr1;lookup[OP]=expr2;  ==>  lookup=expr1[OP]expr2
                    // BUT NOT IF expr2 contains a reference to lookup!
                    var binOp = new BinaryExpression(prevBinary.Operand2.Context.CombineWith(curBinary.Operand2.Context))
                    {
                        Operand1 = prevBinary.Operand2,
                        Operand2 = curBinary.Operand2,
                        OperatorToken = JSScanner.StripAssignment(curBinary.OperatorToken),
                        OperatorContext = curBinary.OperatorContext
                    };
                    prevBinary.Operand2 = binOp;

                    // we are removing the second lookup, so clean up the reference on the field
                    if (lookup.VariableField != null)
                    {
                        lookup.VariableField.References.Remove(lookup);
                    }

                    // and remove the current assignment expression (everything was combined into the previous)
                    node[ndx] = null;
                }
                else
                {
                    // there's lots of ins-and-outs in terms of strings versus numerics versus precedence and all 
                    // sorts of stuff. I need to iron this out a little better, but until then, just combine with a comma.
                    // transform: expr1;expr2  ==>  expr1,expr2
                    var binOp = CommaExpression.CombineWithComma(prevBinary.Context.CombineWith(curBinary.Context), prevBinary, curBinary);

                    // replace the previous node and delete the current
                    node[ndx - 1] = binOp;
                    node[ndx] = null;
                }
            }
            else
            {
                // transform: expr1;expr2 to expr1,expr2
                // use the special comma operator object so we can handle it special
                // and don't create stack-breakingly deep trees
                var binOp = CommaExpression.CombineWithComma(node[ndx - 1].Context.CombineWith(node[ndx].Context), node[ndx - 1], node[ndx]);

                // replace the current node and delete the previous
                node[ndx] = binOp;
                node[ndx - 1] = null;
            }
        }

        private static void CombineReturnWithExpression(BlockStatement node, int ndx, ReturnStatement returnNode)
        {
            // see if the return node has an expression operand
            if (returnNode.Operand != null && returnNode.Operand.IsExpression)
            {
                // check for lookup[ASSIGN]expr2;return expr1.
                LookupExpression lookup;
                if (node[ndx - 1] is BinaryExpression beforeExpr
                    && beforeExpr.IsAssign
                    && (lookup = beforeExpr.Operand1 as LookupExpression) != null)
                {
                    if (returnNode.Operand.IsEquivalentTo(lookup))
                    {
                        // we have lookup[ASSIGN]expr2;return lookup.
                        // if lookup is a local variable in the current scope, we can replace with return expr2;
                        // if lookup is an outer reference, we can replace with return lookup[ASSIGN]expr2
                        if (beforeExpr.OperatorToken == JSToken.Assign)
                        {
                            // check to see if lookup is in the current scope from which we are returning
                            if (lookup.VariableField == null
                                || lookup.VariableField.OuterField != null
                                || lookup.VariableField.IsReferencedInnerScope)
                            {
                                // transform: lookup[ASSIGN]expr2;return lookup => return lookup[ASSIGN]expr2
                                // lookup points to outer field (or we don't know)
                                // replace the operand on the return node with the previous expression and
                                // delete the previous node.
                                // first be sure to remove the lookup in the return operand from the references
                                // to field.
                                DetachReferencesVisitor.Apply(returnNode.Operand);
                                returnNode.Operand = beforeExpr;
                                node[ndx - 1] = null;
                            }
                            else
                            {
                                // transform: lookup[ASSIGN]expr2;return lookup => return expr2
                                // lookup is a variable local to the current scope, so when we return, the
                                // variable won't exists anymore anyway.
                                // replace the operand on the return node oprand with the right-hand operand of the
                                // previous expression and delete the previous node.
                                // we're eliminating the two lookups altogether, so remove them both from the
                                // field's reference table.
                                var varField = lookup.VariableField;
                                DetachReferencesVisitor.Apply(lookup, returnNode.Operand);

                                returnNode.Operand = beforeExpr.Operand2;
                                node[ndx - 1] = null;

                                // now that we've eliminated the two lookups, see if the local variable isn't
                                // referenced anymore. If it isn't, we might be able to remove the variable, too.
                                // (need to pick up those changes to keep track of a field's declarations, though)
                                if (varField.RefCount == 0)
                                {
                                    // it's not. if there's only one declaration and it either has no initializer or
                                    // is initialized to a constant, get rid of it.
                                    var nameDecl = varField.OnlyDeclaration;
                                    if (nameDecl != null)
                                    {
                                        // we only had one declaration.
                                        if (nameDecl.Initializer == null || nameDecl.Initializer.IsConstant)
                                        {
                                            // and it either had no initializer or it was initialized to a constant.                                            // but it has no references, so let's whack it. Actually, only if it was                                            // a var-decl (leave parameter and function decls alone).                                            // TODO: would be nice to properly remove unused declarations from binding parameters                                            // as well (object literals and array literals)
                                            if (nameDecl.Parent is VariableDeclaration varDecl)
                                            {
                                                // save the declaration parent (var, const, or let) and remove the
                                                // child vardecl from its list
                                                var declStatement = varDecl.Parent as Declaration;
                                                declStatement.Remove(varDecl);
                                                varField.WasRemoved = true;

                                                // if the parent statement is now empty, remove it, too. this will
                                                // move everything up one index, but that'll just mean an extra loop.
                                                if (declStatement.Count == 0)
                                                {
                                                    declStatement.Parent.ReplaceChild(declStatement, null);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            // it's an assignment, but it's not =. That means it's one of the OP= operators.
                            // we can't remove the field altogether. But we can move the assignment into the 
                            // return statement and get rid of the lone lookup.
                            // transform: lookup OP= expr;return lookup   =>   return lookup OP= expr;
                            if (lookup.VariableField != null)
                            {
                                // we're getting rid of the lookup, so remove it from the field's list of references
                                DetachReferencesVisitor.Apply(returnNode.Operand);
                            }

                            // remove the expression from the block and put it in the operand of
                            // the return statement.
                            node.RemoveAt(ndx - 1);
                            returnNode.Operand = beforeExpr;

                            // is this field scoped only to this function?
                            if (lookup.VariableField != null
                                && lookup.VariableField.OuterField == null
                                && !lookup.VariableField.IsReferencedInnerScope)
                            {
                                // in fact, the lookup is in the current scope, so assigning to it is a waste
                                // because we're going to return (this is a return statement, after all).
                                // we can get rid of the assignment part and just keep the operator:
                                // transform: lookup OP= expr;return lookup   =>   return lookup OP expr;
                                beforeExpr.OperatorToken = JSScanner.StripAssignment(beforeExpr.OperatorToken);
                            }
                        }
                    }
                    else
                    {
                        // transform: expr1;return expr2 to return expr1,expr2
                        var binOp = CommaExpression.CombineWithComma(node[ndx - 1].Context.FlattenToStart(), node[ndx - 1], returnNode.Operand);

                        // replace the operand on the return node with the new expression and
                        // delete the previous node
                        returnNode.Operand = binOp;
                        node[ndx - 1] = null;
                    }
                }
                else
                {
                    // transform: expr1;return expr2 to return expr1,expr2
                    var binOp = CommaExpression.CombineWithComma(node[ndx - 1].Context.FlattenToStart(), node[ndx - 1], returnNode.Operand);

                    // replace the operand on the return node with the new expression and
                    // delete the previous node
                    returnNode.Operand = binOp;
                    node[ndx - 1] = null;
                }
            }
        }

        private void CombineForNodeWithExpression(BlockStatement node, int ndx, ForStatement forStatement)
        {
            // if we aren't allowing in-operators to be moved into for-statements, then
            // first check to see if that previous expression statement is free of in-operators
            // before trying to move it.
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.MoveInExpressionsIntoForStatement)
                || !node[ndx - 1].ContainsInOperator)
            {
                if (forStatement.Initializer == null)
                {
                    // transform: expr1;for(;...) to for(expr1;...)
                    // simply move the previous expression to the for-statement's initializer
                    forStatement.Initializer = node[ndx - 1];
                    node[ndx - 1] = null;
                }
                else if (forStatement.Initializer.IsExpression)
                {
                    // transform: expr1;for(expr2;...) to for(expr1,expr2;...)
                    var binOp = CommaExpression.CombineWithComma(node[ndx-1].Context.FlattenToStart(), node[ndx - 1], forStatement.Initializer);

                    // replace the initializer with the new binary operator and remove the previous node
                    forStatement.Initializer = binOp;
                    node[ndx - 1] = null;
                }
            }
        }

        private static void CombineWithPreviousVar(BlockStatement node, int ndx, VarDeclaration previousVar)
        {
            if (previousVar.Count == 0)
            {
                return;
            }
            var varDecl = previousVar[previousVar.Count - 1];
            LookupExpression lookup;
            BindingIdentifier bindingIdentifier;

            if (node[ndx] is BinaryExpression binaryOp
                && binaryOp.IsAssign
                && (lookup = binaryOp.Operand1 as LookupExpression) != null
                && lookup.VariableField != null
                && !ReferencesVisitor.References(binaryOp.Operand2, lookup)
                && (bindingIdentifier = varDecl.Binding as BindingIdentifier) != null
                && bindingIdentifier.VariableField == lookup.VariableField)
            {
                // the current statement is a binary operator assignment with a lookup on the left-hand side.
                // the previous statement is a var, the last vardecl is a simple binding identifier, and that identifier
                // is the same as the left-hand side of the assignment. 
                if (varDecl.Initializer != null)
                {
                    if (binaryOp.OperatorToken == JSToken.Assign)
                    {
                        // we have var name=expr1;name=expr2. If expr1 is a constant, we will
                        // get rid of it entirely and replace it with expr2. Otherwise we don't
                        // know about any side-effects, so just leave it be.
                        if (varDecl.Initializer.IsConstant)
                        {
                            // transform: var name=const;name=expr  ==> var name=expr
                            varDecl.Initializer = binaryOp.Operand2;

                            // getting rid of the lookup, so clean up its references
                            lookup.VariableField.IfNotNull(v => v.References.Remove(lookup));
                            node[ndx] = null;
                        }
                    }
                    else
                    {
                        // we have var name=expr1;name[OP]=expr2.
                        // transform: var name=expr1;name[OP]=expr2  ==>  var name=expr1[OP]expr2
                        // getting rid of the lookup, so clean up its references
                        lookup.VariableField.IfNotNull(v => v.References.Remove(lookup));

                        // reuse the binary op by stripping the assignment to just the operator,
                        // clobbering the lookup on operand1 with the vardecl assignment,
                        // and expanding the context to include the initializer.
                        binaryOp.OperatorToken = JSScanner.StripAssignment(binaryOp.OperatorToken);
                        binaryOp.Operand1 = varDecl.Initializer;
                        binaryOp.UpdateWith(binaryOp.Operand1.Context);

                        // set the adjusted binary op to the vardecl initializer and remove the
                        // current statement (that points to the binary op)
                        varDecl.Initializer = binaryOp;
                        node[ndx] = null;
                    }
                }
                else if (binaryOp.OperatorToken == JSToken.Assign)
                {
                    // transform: var name;name=expr  ==>  var name=expr
                    lookup.VariableField.IfNotNull(v => v.References.Remove(lookup));
                    varDecl.Initializer = binaryOp.Operand2;
                    node[ndx] = null;
                }
                else
                {
                    // we have var name;name[OP]=expr.
                    // leave it alone???? we could make var name=undefined[OP]expr1, if we have a good undefined value.
                }
            }
        }

        private static AstNode FindLastStatement(BlockStatement node)
        {
            // start with the last statement in the block and back up over any function declarations
            // or important comments until we get the last statement
            var lastStatementIndex = node.Count - 1;
            while (lastStatementIndex >= 0 
                && (node[lastStatementIndex] is FunctionObject || node[lastStatementIndex] is ImportantComment))
            {
                --lastStatementIndex;
            }

            return lastStatementIndex >= 0 ? node[lastStatementIndex] : null;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1809:AvoidExcessiveLocals"),
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling"),
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity"),
         System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode")]
        public override void Visit(BlockStatement node)
        {
            if (node != null)
            {
                // if this block has a BLOCK scope, then look at the lexically-declared names (if any)
                // and throw an error if any are defined as var's within this scope (ES6 rules).
                // if this is the body of a function object, use the function scope.
                ActivationObject lexicalScope = null;
                if (node.HasOwnScope)
                {
                    lexicalScope = node.EnclosingScope as BlockScope;

                    if (node.Parent is FunctionObject functionObject)
                    {
                        lexicalScope = functionObject.EnclosingScope;
                    }
                }

                if (lexicalScope != null)
                {
                    foreach (var lexDecl in lexicalScope.LexicallyDeclaredNames)
                    {
                        var varDecl = lexicalScope.VarDeclaredName(lexDecl.Name);
                        if (varDecl != null)
                        {
                            // collision.
                            // if the lexical declaration is a let or const declaration (as opposed to a function declaration),
                            // then force the warning to an error. This is so the function declaration will remain a warning if
                            // it collides with a var. 
                            varDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, lexDecl is LexicalDeclaration);

                            // mark them both a no-rename to preserve the collision in the output
                            lexDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                            varDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                        }
                    }
                }

                // we might things differently if these statements are the body collection for a function
                // because we can assume the implicit return statement at the end of it
                bool isFunctionLevel = (node.Parent is FunctionObject);

                // analyze all the statements in our block and recurse them
                if (node.HasOwnScope)
                {
                    m_scopeStack.Push(node.EnclosingScope);
                }

                var oldStrictError = m_strictNameError;
                try
                {
                    m_strictNameError = JSError.StrictModeVariableName;

                    // don't call the base class to recurse -- let's walk the block
                    // backwards in case any of the children opt to delete themselves.
                    for (var ndx = node.Count - 1; ndx >= 0; --ndx)
                    {
                        node[ndx].Accept(this);

                        // we can do this because we are walking backwards, and if the statement had deleted itself
                        // for whatever reason, the next one will slip into its place, and we've already seen it so
                        // it must not be debug only or we would've deleted it.
                        if (m_stripDebug && node.Count > ndx && node[ndx].IsDebugOnly)
                        {
                            node.RemoveAt(ndx);
                        }
                    }
                }
                finally
                {
                    m_strictNameError = oldStrictError;
                    if (node.HasOwnScope)
                    {
                        m_scopeStack.Pop();
                    }
                }

                if (m_parser.Settings.RemoveUnneededCode)
                {
                    // go forward, and check the count each iteration because we might be ADDING statements to the block.
                    // let's look at all our if-statements. If a true-clause ends in a return, then we don't
                    // need the else-clause; we can pull its statements out and stick them after the if-statement.
                    // also, if we encounter a return-, break- or continue-statement, we can axe everything after it
                    for (var ndx = 0; ndx < node.Count; ++ndx)
                    {
                        // see if it's an if-statement with both a true and a false block
                        if (ifNode?.TrueBlock != null
                            && ifNode.TrueBlock.Count > 0
                            && ifNode.FalseBlock != null)
                        {
                            // now check to see if the true block ends in a return statement
                            if (ifNode.TrueBlock[ifNode.TrueBlock.Count - 1] is ReturnStatement)
                            {
                                // transform: if(cond){statements1;return}else{statements2} to if(cond){statements1;return}statements2
                                // it does. insert all the false-block statements after the if-statement
                                node.InsertRange(ndx + 1, ifNode.FalseBlock.Children);

                                // and then remove the false block altogether
                                ifNode.FalseBlock = null;
                            }
                        }
                        else if (node[ndx] is ReturnStatement
                            || node[ndx] is BreakStatement
                            || node[ndx] is ContinueStatement
                            || node[ndx] is ThrowStatement)
                        {
                            // we have an exit node -- no statments afterwards will be executed, so clear them out.
                            // transform: {...;return;...} to {...;return}
                            // transform: {...;break;...} to {...;break}
                            // transform: {...;continue;...} to {...;continue}
                            // transform: {...;throw;...} to {...;throw}
                            // we've found an exit statement, and it's not the last statement in the function.
                            // walk the rest of the statements and delete anything that isn't a function declaration
                            // or a var- or const-statement.
                            for (var ndxRemove = node.Count - 1; ndxRemove > ndx; --ndxRemove)
                            {
                                if (node[ndxRemove].IsDeclaration)
                                {
                                    // we want to keep this statement because it's a "declaration."                                    // HOWEVER, if this is a var or a let, let's whack the initializer, since it will                                     // never get executed. Leave the initializers for const statements, even though                                     // they will never get run, since it would be a syntax error to not have one.
                                    if (node[ndxRemove] is Declaration declaration && declaration.StatementToken != JSToken.Const)
                                    {
                                        for (var ndxDecl = 0; ndxDecl < declaration.Count; ++ndxDecl)
                                        {
                                            if (declaration[ndxDecl].Initializer != null)
                                            {
                                                DetachReferencesVisitor.Apply(declaration[ndxDecl].Initializer);
                                                declaration[ndxDecl].Initializer = null;
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    // not a declaration -- remove it
                                    DetachReferencesVisitor.Apply(node[ndxRemove]);
                                    node.RemoveAt(ndxRemove);
                                }
                            }
                        }
                    }
                }

                // now check the last statement -- if it's an if-statement where the true-block is a single return
                // and there is no false block, convert this one statement to a conditional. We might back it out later
                // if we don't combine the conditional with other stuff.
                // but we can only do this if we're at the functional level because of the implied return at the end
                // of that block.
                if (isFunctionLevel && node.Count > 0
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionReturnToCondition))
                {
                    ReturnStatement returnNode;
                    if (node[ndx] is IfStatement ifNode && ifNode.FalseBlock == null
                        && ifNode.TrueBlock.Count == 1
                        && (returnNode = ifNode.TrueBlock[0] as ReturnStatement) != null)
                    {
                        // if the return node doesn't have an operand, then we can just replace the if-statement with its conditional
                        if (returnNode.Operand == null)
                        {
                            // if the condition is a constant, then eliminate it altogether
                            if (ifNode.Condition.IsConstant)
                            {
                                // delete the node altogether. Because the condition is a constant,
                                // there is no else-block, and the if-block only contains a return
                                // with no expression, we don't have anything to detach.
                                node.ReplaceChild(ifNode, null);
                            }
                            else
                            {
                                // transform: {...;if(cond)return;} to {...;cond;}
                                node.ReplaceChild(ifNode, ifNode.Condition);
                            }
                        }
                        else if (returnNode.Operand.IsExpression)
                        {
                            // this is a strategic replacement that might pay off later. And if
                            // it doesn't, we'll eventually back it out after all the other stuff
                            // if applied on top of it.
                            // transform: if(cond)return expr;} to return cond?expr:void 0}
                            var conditional = new Conditional(ifNode.Condition.Context.FlattenToStart())
                                {
                                    Condition = ifNode.Condition,
                                    TrueExpression = returnNode.Operand,
                                    FalseExpression = CreateVoidNode(returnNode.Context.FlattenToStart())
                                };

                            // replace the if-statement with the new return node
                            node.ReplaceChild(ifNode, new ReturnStatement(ifNode.Context)
                                {
                                    Operand = conditional
                                });
                            Optimize(conditional);
                        }
                    }
                }

                // now walk through and combine adjacent expression statements, and adjacent var-for statements
                // and adjecent expression-return statements
                if (m_parser.Settings.IsModificationAllowed(TreeModifications.CombineAdjacentExpressionStatements))
                {
                    CombineExpressions(node);
                }

                // check to see if we want to combine a preceding var with a for-statement
                if (m_parser.Settings.IsModificationAllowed(TreeModifications.MoveVarIntoFor))
                {
                    // look at the statements in the block. 
                    // walk BACKWARDS down the list because we'll be removing items when we encounter
                    // var statements that can be moved inside a for statement's initializer
                    // we also don't need to check the first one, since there is nothing before it.
                    for (int ndx = node.Count - 1; ndx > 0; --ndx)
                    {
                        // see if the previous statement is a var statement
                        // (we've already combined adjacent var-statements)
                        ForStatement forStatement;
                        ForInStatement forInNode;
                        WhileStatement whileNode;

                        if (node[ndx - 1] is VarDeclaration previousVar && (forStatement = node[ndx] as ForStatement) != null)
                        {
                            // BUT if the var statement has any initializers containing an in-operator, first check
                            // to see if we haven't killed that move before we try moving it. Opera 11 seems to have
                            // an issue with that syntax, even if properly parenthesized.
                            if (m_parser.Settings.IsModificationAllowed(TreeModifications.MoveInExpressionsIntoForStatement)
                                || !previousVar.ContainsInOperator)
                            {
                                // and see if the ForStatement's initializer is empty
                                if (forStatement.Initializer != null)
                                {
                                    // not empty -- see if it is a Var node
                                    if (forStatement.Initializer is VarDeclaration varInitializer)
                                    {
                                        // transform: var decls1;for(var decls2;...) to for(var decls1,decls2;...)
                                        // we want to PREPEND the initializers in the previous var-statement
                                        // to our for-statement's initializer var-statement list
                                        varInitializer.InsertAt(0, previousVar);

                                        // then remove the previous var statement
                                        node.RemoveAt(ndx - 1);
                                        // this will bump the for node up one position in the list, so the next iteration
                                        // will be right back on this node in case there are other var statements we need
                                        // to combine
                                    }
                                    else
                                    {
                                        // we want to see if the initializer expression is a series of one or more                                        // simple assignments to variables that are in the previous var statement.                                        // if all the expressions are assignments to variables that are defined in the                                        // previous var statement, then we can just move the var statement into the                                         // for statement.
                                        if (forStatement.Initializer is BinaryExpression binaryOp && AreAssignmentsInVar(binaryOp, previousVar))
                                        {
                                            // transform: var decls;for(expr1;...) to for(var decls,expr1;...)
                                            // WHERE expr1 only consists of assignments to variables that are declared
                                            // in that previous var-statement.
                                            // TODO: we *could* also do it is the expr1 assignments are to lookups that are
                                            // defined in THIS scope (not any outer scopes), because it wouldn't hurt to have
                                            // then in a var statement again.
                                            // create a list and fill it with all the var-decls created from the assignment
                                            // operators in the expression
                                            ConvertAssignmentsToVarDecls(binaryOp, previousVar, m_parser);

                                            // move the previous var-statement into our initializer
                                            forStatement.Initializer = previousVar;

                                            // and remove the previous var-statement from the list.
                                            node.RemoveAt(ndx - 1);

                                            // this will bump the for node up one position in the list, so the next iteration
                                            // will be right back on this node, but the initializer will not be null
                                        }
                                    }
                                }
                                else
                                {
                                    // transform: var decls;for(;...) to for(var decls;...)
                                    // if it's empty, then we're free to add the previous var statement
                                    // to this for statement's initializer. remove it from it's current
                                    // position and add it as the initializer
                                    node.RemoveAt(ndx - 1);
                                    forStatement.Initializer = previousVar;
                                    // this will bump the for node up one position in the list, so the next iteration
                                    // will be right back on this node, but the initializer will not be null
                                }
                            }
                        }
                        else if (node[ndx - 1] is VarDeclaration previousVar 
                            && (whileNode = node[ndx] as WhileStatement) != null
                            && m_parser.Settings.IsModificationAllowed(TreeModifications.ChangeWhileToFor))
                        {
                            // transform: var ...;while(cond)... => for(var ...;cond;)...
                            node[ndx] = new ForStatement(whileNode.Context.FlattenToStart())
                                {
                                    Initializer = previousVar,
                                    Condition = whileNode.Condition,
                                    Body = whileNode.Body
                                };
                            node.RemoveAt(ndx - 1);
                        }
                        else if (node[ndx - 1] is VarDeclaration previousVar
                            && (forInNode = node[ndx] as ForInStatement) != null)
                        {
                            // if the for-in's variable field is not a declaration, we should check to see
                            // if there is a single named reference, and whether the previous var's last declaration
                            // is for the same var. If so, we can move that declaration into the for-in.
                            if (!(forInNode.Variable is Declaration))
                            {
                                // now see if the LAST vardecl in the previous var statement is the 
                                // same field(s) as the variable, and there was either no initializer
                                // or the initializer was a constant ('cause we're going to kill it).
                                var lastDecl = previousVar[previousVar.Count - 1];
                                if (lastDecl.IsEquivalentTo(forInNode.Variable)
                                    && (lastDecl.Initializer == null || lastDecl.Initializer.IsConstant))
                                {
                                    // convert the reference inside the for-in to a declaration binding.
                                    // set the previous decl's binding to this new binding, delete any
                                    // initializer, and move the vardecl into the for-in.
                                    // Be sure to clean up the var-statement if it's now empty.
                                    var newBinding = BindingTransform.ToBinding(forInNode.Variable);
                                    if (newBinding != null)
                                    {
                                        var newVarDecl = new VariableDeclaration(forInNode.Variable.Context.Clone())
                                            {
                                                Binding = newBinding,
                                            };
                                        var newVar = new VarDeclaration(forInNode.Variable.Context.Clone());
                                        newVar.Append(newVarDecl);
                                        forInNode.Variable = newVar;

                                        // clean up that last declaration, which might go all the way
                                        // up to the statement if removing it leaves the statement empty.
                                        // but ONLY remove declarations that are in the new for-binding.
                                        var oldBindings = BindingsVisitor.Bindings(lastDecl.Binding);
                                        foreach (var newName in BindingsVisitor.Bindings(newBinding))
                                        {
                                            foreach (var oldName in oldBindings)
                                            {
                                                if (oldName.IsEquivalentTo(newName))
                                                {
                                                    ActivationObject.RemoveBinding(oldName);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // see if the last statement is a return statement
                ReturnStatement lastReturn;
                if ((lastReturn = FindLastStatement(node) as ReturnStatement) != null)
                {
                    // set this flag to true if we end up adding an expression to the block.
                    // before exiting, we'll go through and combine adjacent expressions again if this
                    // flag has been set to true.
                    bool changedStatementToExpression = false;

                    // get the index of the statement before the last return
                    // (skip over function decls and importand comments)
                    var indexPrevious = PreviousStatementIndex(node, lastReturn);

                    // just out of curiosity, let's see if we fit a common pattern:
                    //      var name=expr;return name;
                    // or
                    //      const name=expr;return name;
                    // if so, we can cut out the var and simply return the expression
                    LookupExpression lookup;
                    if ((lookup = lastReturn.Operand as LookupExpression) != null && indexPrevious >= 0)
                    {
                        // use the base class for both the var- and const-statements so we will                        // pick them both up at the same time
                        if (node[indexPrevious] is Declaration varStatement)
                        {
                            // if the last vardecl in the var statement matches the return lookup, and no
                            // other references exist for this field (refcount == 1)...
                            var varDecl = varStatement[varStatement.Count - 1];
                            if (varDecl.Initializer != null
                                && varDecl.IsEquivalentTo(lookup))
                            {
                                // we only care about simple binding identifiers
                                if (varDecl.Binding is BindingIdentifier bindingIdentifier
                                    && bindingIdentifier.VariableField.IfNotNull(v => v.RefCount == 1))
                                {
                                    // clean up the field's references because we're removing both the lookup reference
                                    // in the return statement and the vardecl.
                                    bindingIdentifier.VariableField.References.Remove(lookup);
                                    bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);

                                    if (varStatement.Count == 1)
                                    {
                                        // transform: ...;var name=expr;return name} to ...;return expr}
                                        // there's only one vardecl in the var, so get rid of the entire statement
                                        lastReturn.Operand = varDecl.Initializer;
                                        node.RemoveAt(indexPrevious);
                                    }
                                    else
                                    {
                                        // multiple vardecls are in the statement; we only need to get rid of the last one
                                        lastReturn.Operand = varDecl.Initializer;
                                        varStatement[varStatement.Count - 1] = null;
                                    }
                                }
                            }
                        }
                    }

                    // check to see if we can combine the return statement with a previous if-statement
                    // into a simple return-conditional. The true statement needs to have no false block,
                    // and only one statement in the true block.
                    Conditional conditional;
                    IfStatement previousIf;
                    while (indexPrevious >= 0 
                        && lastReturn != null
                        && (previousIf = node[indexPrevious] as IfStatement) != null
                        && previousIf.TrueBlock != null && previousIf.TrueBlock.Count == 1
                        && previousIf.FalseBlock == null)
                    {
                        // assume no change is made for this loop
                        bool somethingChanged = false;

                        // and that one true-block statement needs to be a return statement
                        if (previousIf.TrueBlock[0] is ReturnStatement previousReturn)
                        {
                            if (lastReturn.Operand == null)
                            {
                                if (previousReturn.Operand == null)
                                {
                                    // IF we are at the function level, then the block ends in an implicit return (undefined)
                                    // and we can change this if to just the condition. If we aren't at the function level,
                                    // then we have to leave the return, but we can replace the if with just the condition.
                                    if (!isFunctionLevel)
                                    {
                                        // not at the function level, so the return must stay.
                                        if (previousIf.Condition.IsConstant)
                                        {
                                            // transform: if(cond)return;return} to return}
                                            node.RemoveAt(indexPrevious);
                                            somethingChanged = true;
                                        }
                                        else
                                        {
                                            // transform: if(cond)return;return} to cond;return}
                                            node[indexPrevious] = previousIf.Condition;
                                        }
                                    }
                                    else if (previousIf.Condition.IsConstant)
                                    {
                                        // transform: remove if(cond)return;return} because cond is a constant
                                        node.ReplaceChild(lastReturn, null);
                                        node.RemoveAt(indexPrevious);
                                        somethingChanged = true;
                                    }
                                    else
                                    {
                                        // transform: if(cond)return;return} to cond}
                                        // replace the final return with just the condition, then remove the previous if
                                        if (node.ReplaceChild(lastReturn, previousIf.Condition))
                                        {
                                            node.RemoveAt(indexPrevious);
                                            somethingChanged = true;
                                        }
                                    }
                                }
                                else
                                {
                                    // transform: if(cond)return expr;return} to return cond?expr:void 0
                                    conditional = new Conditional(previousIf.Condition.Context.FlattenToStart())
                                        {
                                            Condition = previousIf.Condition,
                                            TrueExpression = previousReturn.Operand,
                                            FalseExpression = CreateVoidNode(previousReturn.Context.FlattenToStart())
                                        };

                                    // replace the final return with the new return, then delete the previous if-statement
                                    if (node.ReplaceChild(lastReturn, new ReturnStatement(previousReturn.Context.FlattenToStart())
                                        {
                                            Operand = conditional
                                        }))
                                    {
                                        node.RemoveAt(indexPrevious);
                                        Optimize(conditional);
                                        somethingChanged = true;
                                    }
                                }
                            }
                            else
                            {
                                if (previousReturn.Operand == null)
                                {
                                    // transform: if(cond)return;return expr} to return cond?void 0:expr
                                    conditional = new Conditional(previousIf.Condition.Context.FlattenToStart())
                                        {
                                            Condition = previousIf.Condition,
                                            TrueExpression = CreateVoidNode(lastReturn.Context.FlattenToStart()),
                                            FalseExpression = lastReturn.Operand
                                        };

                                    // replace the final return with the new return, then delete the previous if-statement
                                    if (node.ReplaceChild(lastReturn, new ReturnStatement(lastReturn.Context.FlattenToStart())
                                        {
                                            Operand = conditional
                                        }))
                                    {
                                        node.RemoveAt(indexPrevious);
                                        Optimize(conditional);
                                        somethingChanged = true;
                                    }
                                }
                                else if (previousReturn.Operand.IsEquivalentTo(lastReturn.Operand))
                                {
                                    if (previousIf.Condition.IsConstant)
                                    {
                                        // the condition is constant, and the returns return the same thing.
                                        // get rid of the if statement altogether.
                                        // transform: if(cond)return expr;return expr} to return expr}
                                        DetachReferencesVisitor.Apply(previousReturn.Operand);
                                        node.RemoveAt(indexPrevious);
                                        somethingChanged = true;
                                    }
                                    else
                                    {
                                        // transform: if(cond)return expr;return expr} to return cond,expr}
                                        // create a new binary op with the condition and the final-return operand,
                                        // replace the operand on the final-return with the new binary operator,
                                        // and then delete the previous if-statement
                                        DetachReferencesVisitor.Apply(previousReturn.Operand);
                                        lastReturn.Operand = CommaExpression.CombineWithComma(previousIf.Condition.Context.FlattenToStart(), previousIf.Condition, lastReturn.Operand);
                                        node.RemoveAt(indexPrevious);
                                        somethingChanged = true;
                                    }
                                }
                                else
                                {
                                    // transform: if(cond)return expr1;return expr2} to return cond?expr1:expr2}
                                    // create a new conditional with the condition and the return operands,
                                    // replace the operand on the final-return with the new conditional operator,
                                    // and then delete the previous if-statement
                                    // transform: if(cond)return expr1;return expr2} to return cond?expr1:expr2}
                                    conditional = new Conditional(previousIf.Condition.Context.FlattenToStart())
                                        {
                                            Condition = previousIf.Condition,
                                            TrueExpression = previousReturn.Operand,
                                            FalseExpression = lastReturn.Operand
                                        };

                                    // replace the operand on the final-return with the new conditional operator,
                                    // and then delete the previous if-statement
                                    lastReturn.Operand = conditional;
                                    node.RemoveAt(indexPrevious);
                                    Optimize(conditional);
                                    somethingChanged = true;
                                }
                            }
                        }

                        if (!somethingChanged)
                        {
                            // nothing changed -- break out of the loop
                            break;
                        }
                        else
                        {
                            // set the flag that indicates something changed in at least one of these loops
                            changedStatementToExpression = true;
                            
                            // and since we changed something, we need to bump the index down one
                            // AFTER we grab the last return node (which has slipped into the same position
                            // as the previous node)
                            lastReturn = node[indexPrevious--] as ReturnStatement;
                        }
                    }

                    // if we added any more expressions since we ran our expression-combination logic, 
                    // run it again.
                    if (changedStatementToExpression
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.CombineAdjacentExpressionStatements))
                    {
                        CombineExpressions(node);
                    }

                    // and FINALLY, we want to see if what we did previously didn't pan out and we end
                    // in something like return cond?expr:void 0, in which case we want to change it
                    // back to a simple if(condition)return expr; (saves four bytes).
                    // see if the last statement is a return statement that returns a conditional
                    if (lastReturn != null
                        && (conditional = lastReturn.Operand as Conditional) != null)
                    {
                        if (conditional.FalseExpression is UnaryExpression unaryOperator 
                            && unaryOperator.OperatorToken == JSToken.Void
                            && unaryOperator.Operand is ConstantWrapper)
                        {
                            unaryOperator = conditional.TrueExpression as UnaryExpression;

                            if (conditional.FalseExpression is UnaryExpression unaryOperator && unaryOperator.OperatorToken == JSToken.Void)
                            {
                                if (isFunctionLevel)
                                {
                                    // transform: ...;return cond?void 0:void 0} to ...;cond}
                                    // function level ends in an implicit "return void 0"
                                    node.ReplaceChild(lastReturn, conditional.Condition);
                                }
                                else
                                {
                                    // transform: ...;return cond?void 0:void 0} to ...;cond;return}
                                    // non-function level doesn't end in an implicit return,
                                    // so we need to break them out into two statements
                                    node.ReplaceChild(lastReturn, conditional.Condition);
                                    node.Append(new ReturnStatement(lastReturn.Context.Clone()));
                                }
                            }
                            else if (isFunctionLevel)
                            {
                                // transform: ...;return cond?expr:void 0} to ...;if(cond)return expr}
                                // (only works at the function-level because of the implicit return statement)
                                var ifNode = new IfStatement(lastReturn.Context)
                                    {
                                        Condition = conditional.Condition,
                                        TrueBlock = AstNode.ForceToBlock(new ReturnStatement(lastReturn.Context.Clone())
                                            {
                                                Operand = conditional.TrueExpression
                                            })
                                    };
                                node.ReplaceChild(lastReturn, ifNode);
                            }
                        }
                        else if (isFunctionLevel)
                        {
                            unaryOperator = conditional.TrueExpression as UnaryExpression;
                            if (conditional.FalseExpression is UnaryExpression unaryOperator 
                                && unaryOperator.OperatorToken == JSToken.Void
                                && unaryOperator.Operand is ConstantWrapper)
                            {
                                // transform: ...;return cond?void 0;expr} to ...;if(!cond)return expr}
                                // (only works at the function level because of the implicit return)
                                // get the logical-not of the conditional
                                var logicalNot = new LogicalNotVisitor(conditional.Condition, m_parser.Settings);
                                logicalNot.Apply();

                                // create a new if-node based on the condition, with the branches swapped 
                                // (true-expression goes to false-branch, false-expression goes to true-branch
                                var ifNode = new IfStatement(lastReturn.Context)
                                    {
                                        Condition = conditional.Condition,
                                        TrueBlock = AstNode.ForceToBlock(new ReturnStatement(lastReturn.Context.Clone())
                                            {
                                                Operand = conditional.FalseExpression
                                            })
                                    };
                                node.ReplaceChild(lastReturn, ifNode);
                            }
                        }
                    }
                }

                if (m_parser.Settings.IsModificationAllowed(TreeModifications.CombineEquivalentIfReturns))
                {
                    // walk backwards looking for if(cond1)return expr1;if(cond2)return expr2;
                    // (backwards, because we'll be combining those into one statement, reducing the number of statements.
                    // don't go all the way to zero, because each loop will compare the statement to the PREVIOUS
                    // statement, and the first statement (index==0) has no previous statement.
                    for (var ndx = node.Count - 1; ndx > 0; --ndx)
                    {
                        // see if the current statement is an if-statement with no else block, and a true
                        // block that contains a single return-statement WITH an expression.
                        AstNode currentExpr = null;
                        AstNode condition2;
                        if (IsIfReturnExpr(node[ndx], out condition2, ref currentExpr) != null)
                        {
                            // see if the previous statement is also the same pattern, but with
                            // the equivalent expression as its return operand
                            AstNode condition1;
                            var matchedExpression = currentExpr;
                            var ifNode = IsIfReturnExpr(node[ndx - 1], out condition1, ref matchedExpression);

                            if (node[ndx] is IfStatement ifNode)
                            {
                                // it is a match!
                                // let's combine them -- we'll add the current condition to the
                                // previous condition with a logical-or and delete the current statement.
                                // transform: if(cond1)return expr;if(cond2)return expr; to if(cond1||cond2)return expr;
                                ifNode.Condition = new BinaryExpression(condition1.Context.FlattenToStart())
                                    {
                                        Operand1 = condition1,
                                        Operand2 = condition2,
                                        OperatorToken = JSToken.LogicalOr,
                                        TerminatingContext = ifNode.TerminatingContext ?? node.TerminatingContext
                                    };
                                DetachReferencesVisitor.Apply(currentExpr);
                                node.RemoveAt(ndx);
                            }
                        }
                    }
                }

                if (isFunctionLevel
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.InvertIfReturn))
                {
                    // walk backwards looking for if (cond) return; whenever we encounter that statement,
                    // we can change it to if (!cond) and put all subsequent statements in the block inside the
                    // if's true-block.
                    for (var ndx = node.Count - 1; ndx >= 0; --ndx)
                    {
                        if (node[ndx] is IfStatement ifNode
                            && ifNode.FalseBlock == null
                            && ifNode.TrueBlock != null
                            && ifNode.TrueBlock.Count == 1)
                        {
                            if (ifNode.TrueBlock[0] is ReturnStatement returnNode && returnNode.Operand == null)
                            {
                                // we have if(cond)return;
                                // logical-not the condition, remove the return statement,
                                // and move all subsequent sibling statements inside the if-statement.
                                LogicalNotVisitor.Apply(ifNode.Condition, m_parser.Settings);
                                ifNode.TrueBlock.Clear();

                                var ndxMove = ndx + 1;
                                if (node.Count == ndxMove + 1)
                                {
                                    // there's only one statement after our if-node.                                    // see if it's ALSO an if-node with no else block.
                                    if (node[ndxMove] is IfStatement secondIfNode && (secondIfNode.FalseBlock == null || secondIfNode.FalseBlock.Count == 0))
                                    {
                                        // it is!
                                        // transform: if(cond1)return;if(cond2){...} => if(!cond1&&cond2){...}
                                        // (the cond1 is already inverted at this point)
                                        // combine cond2 with cond1 via a logical-and,
                                        // move all secondIf statements inside the if-node,
                                        // remove the secondIf node.
                                        node.RemoveAt(ndxMove);
                                        ifNode.Condition = new BinaryExpression(ifNode.Condition.Context.FlattenToStart())
                                            {
                                                Operand1 = ifNode.Condition,
                                                Operand2 = secondIfNode.Condition,
                                                OperatorToken = JSToken.LogicalAnd
                                            };

                                        ifNode.TrueBlock = secondIfNode.TrueBlock;
                                    }
                                    else if (node[ndxMove].IsExpression
                                        && m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionCallToConditionAndCall))
                                    {
                                        // now we have if(cond)expr; optimize that!
                                        var expression = node[ndxMove];
                                        node.RemoveAt(ndxMove);
                                        IfConditionExpressionToExpression(ifNode, expression);
                                    }
                                }

                                // just move all the following statements inside the if-statement
                                while (node.Count > ndxMove)
                                {
                                    var movedNode = node[ndxMove];
                                    node.RemoveAt(ndxMove);
                                    ifNode.TrueBlock.Append(movedNode);
                                }
                            }
                        }
                    }
                }
                else
                {
                    var isIteratorBlock = node.Parent is ForStatement
                        || node.Parent is ForInStatement
                        || node.Parent is WhileStatement
                        || node.Parent is DoWhileStatement;

                    if (isIteratorBlock
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.InvertIfContinue))
                    {
                        // walk backwards looking for if (cond) continue; whenever we encounter that statement,
                        // we can change it to if (!cond) and put all subsequent statements in the block inside the
                        // if's true-block.
                        for (var ndx = node.Count - 1; ndx >= 0; --ndx)
                        {
                            if (node[ndx] is IfStatement ifNode
                                && ifNode.FalseBlock == null
                                && ifNode.TrueBlock != null
                                && ifNode.TrueBlock.Count == 1)
                            {
                                // if there's no label, then we're good. Otherwise we can only make this optimization
                                // if the label refers to the parent iterator node.
                                if (ifNode.TrueBlock[0] is ContinueStatement continueNode 
                                    && (string.IsNullOrEmpty(continueNode.Label) || (LabelMatchesParent(continueNode.Label, node.Parent))))
                                {
                                    // if this is the last statement, then we don't really need the if at all
                                    // and can just replace it with its condition
                                    if (ndx < node.Count - 1)
                                    {
                                        // we have if(cond)continue;st1;...stn;
                                        // logical-not the condition, remove the continue statement,
                                        // and move all subsequent sibling statements inside the if-statement.
                                        LogicalNotVisitor.Apply(ifNode.Condition, m_parser.Settings);
                                        ifNode.TrueBlock.Clear();

                                        // TODO: if we removed a labeled continue, do we need to fix up some label references?

                                        var ndxMove = ndx + 1;
                                        if (node.Count == ndxMove + 1)
                                        {
                                            // there's only one statement after our if-node.                                            // see if it's ALSO an if-node with no else block.
                                            if (node[ndxMove] is IfStatement secondIfNode && (secondIfNode.FalseBlock == null || secondIfNode.FalseBlock.Count == 0))
                                            {
                                                // it is!
                                                // transform: if(cond1)continue;if(cond2){...} => if(!cond1&&cond2){...}
                                                // (the cond1 is already inverted at this point)
                                                // combine cond2 with cond1 via a logical-and,
                                                // move all secondIf statements inside the if-node,
                                                // remove the secondIf node.
                                                ifNode.Condition = new BinaryExpression(ifNode.Condition.Context.FlattenToStart())
                                                    {
                                                        Operand1 = ifNode.Condition,
                                                        Operand2 = secondIfNode.Condition,
                                                        OperatorToken = JSToken.LogicalAnd
                                                    };

                                                ifNode.TrueBlock = secondIfNode.TrueBlock;
                                                node.RemoveAt(ndxMove);
                                            }
                                            else if (node[ndxMove].IsExpression
                                                && m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionCallToConditionAndCall))
                                            {
                                                // now we have if(cond)expr; optimize that!
                                                var expression = node[ndxMove];
                                                node.RemoveAt(ndxMove);
                                                IfConditionExpressionToExpression(ifNode, expression);
                                            }
                                        }

                                        // just move all the following statements inside the if-statement
                                        while (node.Count > ndxMove)
                                        {
                                            var movedNode = node[ndxMove];
                                            node.RemoveAt(ndxMove);
                                            ifNode.TrueBlock.Append(movedNode);
                                        }
                                    }
                                    else
                                    {
                                        // we have if(cond)continue} -- nothing after the if.
                                        // the loop is going to continue anyway, so replace the if-statement
                                        // with the condition and be done
                                        if (ifNode.Condition.IsConstant)
                                        {
                                            // consition is constant -- get rid of the if-statement altogether
                                            node.RemoveAt(ndx);
                                        }
                                        else
                                        {
                                            // condition isn't constant
                                            node[ndx] = ifNode.Condition;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        private static bool LabelMatchesParent(string label, AstNode parentNode)
        {
            var isMatch = false;

            // see if the parent's parent is a labeled statement
            LabeledStatement labeledStatement;
            while ((labeledStatement = parentNode.Parent as LabeledStatement) != null)
            {
                // see if the label we are looking for matches the labeled statement
                if (string.CompareOrdinal(label, labeledStatement.Label) == 0)
                {
                    // it's a match -- we're done
                    isMatch = true;
                    break;
                }

                // try the next node up (a labeled statement can itself be labeled)
                parentNode = labeledStatement;
            }
            return isMatch;
        }

        private static IfStatement IsIfReturnExpr(AstNode node, out AstNode condition, ref AstNode matchExpression)
        {
            // set the condition to null initially
            condition = null;
            // must be an if-node with no false block, and a true block with one statement
            if (node is IfStatement ifNode
                && ifNode.FalseBlock == null
                && ifNode.TrueBlock != null
                && ifNode.TrueBlock.Count == 1)
            {
                // and that one statement needs to be a return statement
                if (ifNode.TrueBlock[0] is ReturnStatement returnNode)
                {
                    if (matchExpression == null
                        || matchExpression.IsEquivalentTo(returnNode.Operand))
                    {
                        // either we don't care what the return expression is,
                        // or we do care and it's a match.
                        matchExpression = returnNode.Operand;
                        condition = ifNode.Condition;
                    }
                }
            }

            // but we will only return the if-node IF the matchedExpression and the
            // condition are both non-null (our TRUE state)
            return condition != null && matchExpression != null ? ifNode : null;
        }

        private static int PreviousStatementIndex(BlockStatement node, AstNode child)
        {
            // get the index of the statement before the last return
            // (skip over function decls and importand comments)
            var indexPrevious = node.IndexOf(child) - 1;
            while (indexPrevious >= 0 && (node[indexPrevious] is FunctionObject || node[indexPrevious] is ImportantComment))
            {
                --indexPrevious;
            }

            return indexPrevious;
        }

        public override void Visit(BreakStatement node)
        {
            if (node != null)
            {
                // if the label isn't valid an we can remove them, remove it now
                if (!node.Label.IsNullOrWhiteSpace()
                    && node.LabelInfo == null
                    && m_parser.Settings.RemoveUnneededCode
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryLabels))
                {
                    node.Label = null;
                }

                // check the break is inside a loop or in a label block
                if (!IsInsideLoop(node, true) && (node.Label == null || !IsInsideLabel(node, node.Label)))
                {
                    node.Context.HandleError(JSError.BadBreak, true);
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(CallExpression node)
        {
            if (node != null)
            {
                // see if this is a member (we'll need it for a couple checks)
                LookupExpression lookup;

                // if this is a constructor and we want to collapse
                // some of them to literals...
                if (node.IsConstructor)
                {
                    // array function as new operands will probably be wrapped in parens
                    if (node.Function is FunctionObject funcObject || (funcObject = (node.Function as GroupingOperator).IfNotNull(g => g.Operand as FunctionObject)) != null)
                    {
                        if (funcObject.FunctionType == FunctionType.ArrowFunction)
                        {
                            // arrow functions can't be constructors, and we explicitly have one here.
                            // throw an error
                            node.Function.Context.HandleError(JSError.ArrowCannotBeConstructor, true);
                        }
                    }
                    else if (m_parser.Settings.CollapseToLiteral)
                    {
                        // see if this is a lookup, and if so, if it's pointing to one
                        // of the two constructors we want to collapse
                        lookup = node.Function as LookupExpression;
                        if (lookup != null)
                        {
                            if (lookup.Name == "Object"
                                && m_parser.Settings.IsModificationAllowed(TreeModifications.NewObjectToObjectLiteral))
                            {
                                // no arguments -- the Object constructor with no arguments is the exact same as an empty
                                // object literal
                                if (node.Arguments == null || node.Arguments.Count == 0)
                                {
                                    // replace our node with an object literal
                                    var objLiteral = new ObjectLiteral(node.Context);
                                    if (node.Parent.ReplaceChild(node, objLiteral))
                                    {
                                        // and bail now. No need to recurse -- it's an empty literal
                                        return;
                                    }
                                }
                                else if (node.Arguments.Count == 1)
                                {
                                    // one argument                                    // check to see if it's an object literal.
                                    if (node.Arguments[0] is ObjectLiteral objectLiteral)
                                    {
                                        // the Object constructor with an argument that is a JavaScript object merely returns the
                                        // argument. Since the argument is an object literal, it is by definition a JavaScript object
                                        // and therefore we can replace the constructor call with the object literal
                                        node.Parent.ReplaceChild(node, objectLiteral);

                                        // don't forget to recurse the object now
                                        objectLiteral.Accept(this);

                                        // and then bail -- we don't want to process this call
                                        // operation any more; we've gotten rid of it
                                        return;
                                    }
                                }
                            }
                            else if (lookup.Name == "Array"
                                && m_parser.Settings.IsModificationAllowed(TreeModifications.NewArrayToArrayLiteral))
                            {
                                // Array is trickier. 
                                // If there are no arguments, then just use [].
                                // if there are multiple arguments, then use [arg0,arg1...argN].
                                // but if there is one argument and it's numeric, we can't crunch it.
                                // also can't crunch if it's a function call or a member or something, since we won't
                                // KNOW whether or not it's numeric.
                                //
                                // so first see if it even is a single-argument constant wrapper. 
                                ConstantWrapper constWrapper = (node.Arguments != null && node.Arguments.Count == 1
                                    ? node.Arguments[0] as ConstantWrapper
                                    : null);

                                // if the argument count is not one, then we crunch.
                                // if the argument count IS one, we only crunch if we have a constant wrapper, 
                                // AND it's not numeric.
                                if (node.Arguments == null
                                  || node.Arguments.Count != 1
                                  || (constWrapper != null && !constWrapper.IsNumericLiteral))
                                {
                                    // create the new array literal object
                                    var arrayLiteral = new ArrayLiteral(node.Context)
                                        {
                                            Elements = node.Arguments
                                        };

                                    // replace ourself within our parent
                                    if (node.Parent.ReplaceChild(node, arrayLiteral))
                                    {
                                        // recurse
                                        arrayLiteral.Accept(this);
                                        // and bail -- we don't want to recurse this node any more
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }

                // if we are replacing resource references with strings generated from resource files
                // and this is a brackets call: lookup[args]
                var resourceList = m_parser.Settings.ResourceStrings;
                if (node.InBrackets && resourceList.Count > 0)
                {
                    // if we don't have a match visitor, create it now
                    if (m_matchVisitor == null)
                    {
                        m_matchVisitor = new MatchPropertiesVisitor();
                    }

                    // check each resource strings object to see if we have a match.
                    // Walk the list BACKWARDS so that later resource string definitions supercede previous ones.
                    for (var ndx = resourceList.Count - 1; ndx >= 0; --ndx)
                    {
                        var resourceStrings = resourceList[ndx];

                        // check to see if the resource strings name matches the function
                        if (resourceStrings != null && m_matchVisitor.Match(node.Function, resourceStrings.Name))
                        {
                            // we're going to replace this node with a string constant wrapper
                            // but first we need to make sure that this is a valid lookup.
                            // if the parameter contains anything that would vary at run-time, 
                            // then we need to throw an error.
                            // the parser will always have either one or zero nodes in the arguments
                            // arg list. We're not interested in zero args, so just make sure there is one
                            if (node.Arguments.Count == 1)
                            {
                                // must be a constant wrapper
                                if (node.Arguments[0] is ConstantWrapper argConstant)
                                {
                                    string resourceName = argConstant.Value.ToString();

                                    // get the localized string from the resources object
                                    ConstantWrapper resourceLiteral = new ConstantWrapper(
                                        resourceStrings[resourceName],
                                        PrimitiveType.String,
                                        node.Context);

                                    // replace this node with localized string, analyze it, and bail
                                    // so we don't anaylze the tree we just replaced
                                    node.Parent.ReplaceChild(node, resourceLiteral);
                                    resourceLiteral.Accept(this);
                                    return;
                                }
                                else
                                {
                                    // error! must be a constant
                                    node.Context.HandleError(
                                        JSError.ResourceReferenceMustBeConstant,
                                        true);
                                }
                            }
                            else
                            {
                                // error! can only be a single constant argument to the string resource object.
                                // the parser will only have zero or one arguments, so this must be zero
                                // (since the parser won't pass multiple args to a [] operator)
                                node.Context.HandleError(
                                    JSError.ResourceReferenceMustBeConstant,
                                    true);
                            }
                        }
                    }
                }

                // and finally, if this is a backets call and the argument is a constantwrapper that can
                // be an identifier, just change us to a member node:  obj["prop"] to obj.prop.
                // but ONLY if the string value is "safe" to be an identifier. Even though the ECMA-262
                // spec says certain Unicode categories are okay, in practice the various major browsers
                // all seem to have problems with certain characters in identifiers. Rather than risking
                // some browsers breaking when we change this syntax, don't do it for those "danger" categories.
                if (node.InBrackets && node.Arguments != null)
                {
                    // see if there is a single, constant argument
                    string argText = node.Arguments.SingleConstantArgument;
                    if (argText != null)
                    {
                        // see if we want to replace the name
                        string newName;
                        if (m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties
                            && m_parser.Settings.IsModificationAllowed(TreeModifications.PropertyRenaming)
                            && !string.IsNullOrEmpty(newName = m_parser.Settings.GetNewName(argText)))
                        {
                            // yes -- we are going to replace the name, either as a string literal, or by converting
                            // to a member-dot operation.
                            // See if we can't turn it into a dot-operator. If we can't, then we just want to replace the operator with
                            // a new constant wrapper. Otherwise we'll just replace the operator with a new constant wrapper.
                            if (m_parser.Settings.IsModificationAllowed(TreeModifications.BracketMemberToDotMember)
                                && JSScanner.IsSafeIdentifier(newName)
                                && !JSScanner.IsKeyword(newName, (node.EnclosingScope ?? m_parser.GlobalScope).UseStrict))
                            {
                                // the new name is safe to convert to a member-dot operator.
                                // but we don't want to convert the node to the NEW name, because we still need to Analyze the
                                // new member node -- and it might convert the new name to something else. So instead we're
                                // just going to convert this existing string to a member node WITH THE OLD STRING, 
                                // and THEN analyze it (which will convert the old string to newName)
                                MemberExpression replacementMember = new MemberExpression(node.Context)
                                    {
                                        Root = node.Function,
                                        Name = argText,
                                        NameContext = node.Arguments[0].Context
                                    };
                                node.Parent.ReplaceChild(node, replacementMember);

                                // this analyze call will convert the old-name member to the newName value
                                replacementMember.Accept(this);
                                return;
                            }
                            else
                            {
                                // nope; can't convert to a dot-operator. 
                                // we're just going to replace the first argument with a new string literal
                                // and continue along our merry way.
                                node.Arguments[0] = new ConstantWrapper(newName, PrimitiveType.String, node.Arguments[0].Context);
                            }
                        }
                        else if (m_parser.Settings.IsModificationAllowed(TreeModifications.BracketMemberToDotMember)
                            && JSScanner.IsSafeIdentifier(argText)
                            && !JSScanner.IsKeyword(argText, (node.EnclosingScope ?? m_parser.GlobalScope).UseStrict))
                        {
                            // not a replacement, but the string literal is a safe identifier. So we will
                            // replace this call node with a Member-dot operation
                            MemberExpression replacementMember = new MemberExpression(node.Context)
                                {
                                    Root = node.Function,
                                    Name = argText,
                                    NameContext = node.Arguments[0].Context
                                };
                            node.Parent.ReplaceChild(node, replacementMember);
                            replacementMember.Accept(this);
                            return;
                        }
                    }
                }

                // call the base class to recurse
                base.Visit(node);

                if (node.Function != null && node.Function.IsDebugOnly)
                {
                    // if the funtion is debug-only, then we are too!
                    node.IsDebugOnly = true;

                    // if if this node is a constructor call....
                    if (node.IsConstructor)
                    {
                        // we have "new root.func(...)", root.func is a debug namespace, and we
                        // are stripping debug namespaces. Replace the new-operator with an 
                        // empty object literal.
                        node.Parent.ReplaceChild(node, new ObjectLiteral(node.Context)
                            {
                                IsDebugOnly = true
                            });
                    }
                }
                else
                {
                    // might have changed
                    member = node.Function as MemberExpression;
                    lookup = node.Function as LookupExpression;

                    var isEval = false;
                    if (lookup != null
                        && string.CompareOrdinal(lookup.Name, "eval") == 0
                        && lookup.VariableField.FieldType == FieldType.Predefined)
                    {
                        // call to predefined eval function
                        isEval = true;
                    }
                    else if (node.Function is MemberExpression member && string.CompareOrdinal(member.Name, "eval") == 0)
                    {
                        // if this is a window.eval call, then we need to mark this scope as unknown just as
                        // we would if this was a regular eval call.
                        // (unless, of course, the parser settings say evals are safe)
                        // call AFTER recursing so we know the left-hand side properties have had a chance to
                        // lookup their fields to see if they are local or global
                        if (member.Root.IsWindowLookup)
                        {
                            // this is a call to window.eval()
                            isEval = true;
                        }
                    }
                    else
                    {
                        if (node.Function is CallExpression callNode
                            && callNode.InBrackets
                            && callNode.Function.IsWindowLookup
                            && callNode.Arguments.IsSingleConstantArgument("eval"))
                        {
                            // this is a call to window["eval"]
                            isEval = true;
                        }
                    }

                    if (isEval)
                    {
                        if (m_parser.Settings.EvalTreatment != EvalTreatment.Ignore)
                        {
                            // mark this scope as unknown so we don't crunch out locals 
                            // we might reference in the eval at runtime
                            m_scopeStack.Peek().IsKnownAtCompileTime = false;
                        }
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(ClassNode node)
        {
            if (node != null)
            {
                base.Visit(node);

                // if this is a named class expression
                if (node.ClassType == ClassType.Expression && node.Binding != null)
                {
                    // it SHOULD be a simple identifier; if it's not, then leave it alone.
                    // but if it is, check to see if it's actually referenced, and if not, get rid of it
                    // because we don't need it.
                    var bindingIdentifier = node.Binding as BindingIdentifier;
                    if (bindingIdentifier?.VariableField != null
                        && bindingIdentifier.VariableField.RefCount == 0
                        && m_parser.Settings.RemoveFunctionExpressionNames
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveFunctionExpressionNames))
                    {
                        // if the class is a named expression and the name isn't
                        // referenced anywhere, delete it.
                        node.Binding = null;
                    }
                }

                if (node.Elements != null)
                {
                    // it is an error for a class to contain multiple methods with the same name
                    // (other than get/set pairs)
                    var nameHash = new HashSet<string>();
                    foreach (var element in node.Elements)
                    {
                        string functionName;
                        var functionObject = element as FunctionObject;
                        if (functionObject?.Binding != null 
                            && !(functionName = functionObject.Binding.Name).IsNullOrWhiteSpace())
                        {
                            var errorContext = functionObject.Binding.Context ?? functionObject.Context;

                            // the keyed name is the function type (get/set/other) plus the name
                            // make sure there's no duplicate with this name
                            if (!nameHash.Add(ClassElementKeyName(functionObject.FunctionType, functionName)))
                            {
                                // couldn't add because there's a duplicate, which is not allowed
                                errorContext.HandleError(JSError.DuplicateClassElementName, true);
                            }

                            if (functionObject.FunctionType == FunctionType.Getter || functionObject.FunctionType == FunctionType.Setter)
                            {
                                // make sure there's no method with this name
                                if (nameHash.Contains(ClassElementKeyName(FunctionType.Method, functionName)))
                                {
                                    // couldn't add because there's a duplicate, which is not allowed
                                    errorContext.HandleError(JSError.DuplicateClassElementName, true);
                                }
                            }
                            else
                            {
                                // make sure there's no getter or setter with this name
                                if (nameHash.Contains(ClassElementKeyName(FunctionType.Getter, functionName))
                                    || nameHash.Contains(ClassElementKeyName(FunctionType.Setter, functionName)))
                                {
                                    // couldn't add because there's a duplicate, which is not allowed
                                    errorContext.HandleError(JSError.DuplicateClassElementName, true);
                                }
                            }

                            if ((functionObject.FunctionType != FunctionType.Method || functionObject.IsGenerator)
                                && string.CompareOrdinal(functionName, "constructor") == 0)
                            {
                                errorContext.HandleError(JSError.SpecialConstructor, true);
                            }
                            else if (functionObject.IsStatic && string.CompareOrdinal(functionName, "prototype") == 0)
                            {
                                errorContext.HandleError(JSError.StaticPrototype, true);
                            }
                        }
                    }
                }
            }
        }

        private static string ClassElementKeyName(FunctionType funcType, string name)
        {
            switch (funcType)
            {
                case FunctionType.Getter:
                    return "get_" + name;

                case FunctionType.Setter:
                    return "set_" + name;

                default:
                    return "method_" + name;
            }
        }

        public override void Visit(ComprehensionNode node)
        {
            if (node != null)
            {
                // we need to push the scope onto the stack before we recurse
                node.BlockScope.IfNotNull(s => m_scopeStack.Push(s));
                try
                {
                    if (node.Clauses != null)
                    {
                        node.Clauses.Accept(this);
                    }

                    if (node.Expression != null)
                    {
                        node.Expression.Accept(this);
                    }
                }
                finally
                {
                    node.BlockScope.IfNotNull(s => m_scopeStack.Pop());
                }

                // TODO: verify that there are no naming collisions in the scope
            }
        }

        private void Optimize(Conditional node)
        {
            // if the condition is debug-only, then replace the condition with the false branch
            if (node.Condition != null && node.Condition.IsDebugOnly)
            {
                // if the false branch is debug-only, then replace the entire expression with a null
                if (node.FalseExpression == null || node.FalseExpression.IsDebugOnly)
                {
                    node.Parent.ReplaceChild(node, new ConstantWrapper(null, PrimitiveType.Null, node.Context)
                        {
                            IsDebugOnly = true
                        });
                }
                else
                {
                    node.Parent.ReplaceChild(node, node.FalseExpression);
                }
            }
            else
            {
                // now check to see if the condition starts with a not-operator. If so, we can get rid of it                // and swap the true/false children
                if (node.Condition is UnaryExpression unary && unary.OperatorToken == JSToken.LogicalNot
                    && !unary.OperatorInConditionalCompilationComment
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.IfNotTrueFalseToIfFalseTrue))
                {
                    // get rid of the not by replacing it with its operand
                    // and swap the branches
                    node.Condition = unary.Operand;
                    node.SwapBranches();
                }

                // see if the two branches are both assignment operations to the same variable.                // if so, we can pull the assignment outside the conditional and have the conditional                // be the assignment
                if (node.TrueExpression is BinaryExpression trueAssign && trueAssign.IsAssign)
                {
                    if (node.FalseExpression is BinaryExpression falseAssign && falseAssign.OperatorToken == trueAssign.OperatorToken)
                    {
                        // see if the left-hand-side is equivalent
                        if (trueAssign.Operand1.IsEquivalentTo(falseAssign.Operand1))
                        {
                            // we're going to be getting rid of the left-hand side in the false-block, 
                            // so we need to remove any references it may represent
                            DetachReferencesVisitor.Apply(falseAssign.Operand1);

                            // transform: cond?lhs=expr1:lhs=expr2 to lhs=cond?expr1:expr2s
                            var binaryOp = new BinaryExpression(node.Context)
                                {
                                    Operand1 = trueAssign.Operand1,
                                    Operand2 = new Conditional(node.Context)
                                    {
                                        Condition = node.Condition,
                                        QuestionContext = node.QuestionContext,
                                        TrueExpression = trueAssign.Operand2,
                                        ColonContext = node.ColonContext,
                                        FalseExpression = falseAssign.Operand2
                                    },
                                    OperatorContext = trueAssign.OperatorContext,
                                    OperatorToken = trueAssign.OperatorToken,
                                    TerminatingContext = node.TerminatingContext
                                };

                            node.Parent.ReplaceChild(node, binaryOp);
                        }
                    }
                }
            }
        }

        public override void Visit(Conditional node)
        {
            if (node != null)
            {
                // analye all the children
                base.Visit(node);

                // and then optimize our node
                Optimize(node);
            }
        }

        public override void Visit(ConditionalCompilationOn node)
        {
            // well, we've encountered a cc_on statement now
            m_encounteredCCOn = true;
        }

        private static bool StringSourceIsNotInlineSafe(string source)
        {
            var isNotSafe = false;
            if (!string.IsNullOrEmpty(source))
            {
                // most browsers won't close the <script> tag unless they see </script, but the
                // user has explicitly set the flag to throw an error if the string isn't safe, so
                // let's err on the side of caution. Also check for the closing of a CDATA element.
                isNotSafe = source.IndexOf("</", StringComparison.Ordinal) >= 0
                    || source.IndexOf("]]>", StringComparison.Ordinal) >= 0;
            }

            return isNotSafe;
        }

        public override void Visit(ConstantWrapper node)
        {
            if (node != null)
            {
                if ((node.PrimitiveType == PrimitiveType.Other || node.PrimitiveType == PrimitiveType.String)
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.CultureInfoTokenReplacement)
                    && JSScanner.IsReplacementToken(node.Value.ToString()))
                {
                    // either this is a regular replacement token, or it's a string that contains
                    // only a replacement token. See if we want to potentially replace it with the
                    // actual cultureinfo value.
                    var newNode = ReplaceCultureValue(node);

                    // cast the new node back to a constant wrapper. If it is, keep on processing
                    // as if nothing changed.
                    node = newNode as ConstantWrapper;
                    if (node == null)
                    {
                        // otherwise we're going to want to recurse this new node and exit this one.
                        newNode.Accept(this);
                        return;
                    }
                }

                // if we want to throw an error when the string's source isn't inline safe...
                if (node.PrimitiveType == PrimitiveType.String
                    && m_parser.Settings.ErrorIfNotInlineSafe
                    && node.Context != null
                    && StringSourceIsNotInlineSafe(node.Context.Code))
                {
                    // ...throw an error
                    node.Context.HandleError(JSError.StringNotInlineSafe, true);
                }

                // check to see if this node is an argument to a RegExp constructor.
                // if it is, we'll want to not use certain string escapes
                AstNode previousNode = null;
                AstNode parentNode = node.Parent;
                while (parentNode != null)
                {
                    // is this a call node and the previous node was one of the parameters?
                    if (parentNode is CallExpression callNode && previousNode == callNode.Arguments)
                    {
                        // are we calling a simple lookup for "RegExp"?
                        if (callNode.Function is LookupExpression lookup && lookup.Name == "RegExp")
                        {
                            // we are -- so all string literals passed within this constructor should not use
                            // standard string escape sequences
                            node.IsParameterToRegExp = true;
                            // we can stop looking
                            break;
                        }
                    }

                    // next up the chain, keeping track of this current node as next iteration's "previous" node
                    previousNode = parentNode;
                    parentNode = parentNode.Parent;
                }
            }
        }

        public override void Visit(ConstStatement node)
        {
            if (node != null)
            {
                // we shouldn't have any duplicate constants
                // const a=1, a=2 is not okay!
                // but don't automatically remove them -- we don't know whether browsers implement first-wins
                // or last-wins.
                var uniqueNames = new HashSet<string>(StringComparer.Ordinal);
                foreach (var bindingIdentifier in BindingsVisitor.Bindings(node))
                {
                    // will return false if the name is already in the collection
                    if (!uniqueNames.Add(bindingIdentifier.Name))
                    {
                        bindingIdentifier.Context.HandleError(JSError.DuplicateConstantDeclaration, true);
                    }
                }

                // recurse the analyze
                base.Visit(node);
            }
        }

        public override void Visit(ContinueStatement node)
        {
            if (node != null)
            {
                // if the label isn't valid an we can remove them, remove it now
                if (!node.Label.IsNullOrWhiteSpace()
                    && node.LabelInfo == null
                    && m_parser.Settings.RemoveUnneededCode
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryLabels))
                {
                    node.Label = null;
                }

                if (!IsInsideLoop(node, false))
                {
                    node.Context.HandleError(JSError.BadContinue, true);
                }
            }
        }

        public override void Visit(DebuggerNode node)
        {
            if (node != null)
            {
                // we ARE a debug statement!
                node.IsDebugOnly = true;
            }
        }

        public override void Visit(DoWhileStatement node)
        {
            if (node != null)
            {
                // recurse
                base.Visit(node);

                // if the body is now empty, make it null
                if (node.Body != null && node.Body.Count == 0)
                {
                    node.Body = null;
                }

                if (node.Condition != null && node.Condition.IsDebugOnly)
                {
                    if (node.Body == null)
                    {
                        node.Parent.ReplaceChild(node, null);
                    }
                    else
                    {
                        node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                    }
                }
            }
        }

        public override void Visit(ExportStatement node)
        {
            if (node != null)
            {
                // export default is an assignment expression, so any function expression or
                // other expression it exports can be renamed. But straight exports of var/const/let,
                // function, and class cannot be renamed.
                if (!node.IsDefault)
                {
                    if (!node.ModuleName.IsNullOrWhiteSpace())
                    {
                        // re-export from external module, so the local value(s) cannot be redefined either, since it
                        // is coming from the external modules as well
                        foreach (var bindingIdentifier in BindingsVisitor.Bindings(node))
                        {
                            if (bindingIdentifier.VariableField != null)
                            {
                                bindingIdentifier.VariableField.CanCrunch = false;
                            }
                        }
                    }
                    else if (node.Count == 1 && (node[0] is Declaration || node[0] is FunctionObject || node[0] is ClassNode))
                    {
                        // we are explicitly exporting function or class names or declarations (var/let/const)
                        // make sure we don't rename them
                        foreach (var bindingIdentifier in BindingsVisitor.Bindings(node[0]))
                        {
                            if (bindingIdentifier.VariableField != null)
                            {
                                bindingIdentifier.VariableField.CanCrunch = false;
                            }
                        }
                    }
                }

                base.Visit(node);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(ForStatement node)
        {
            if (node != null)
            {
                // if this for-statement has it's own lexical scope, then it's an error
                // if the any of the field names declared in this scope is also defined inside the body.
                if (node.BlockScope != null)
                {
                    foreach (var field in node.BlockScope.LexicallyDeclaredNames)
                    {
                        // if the block has a lexical scope, check it for conflicts
                        if (node.Body != null && node.Body.HasOwnScope)
                        {
                            var lexDecl = node.Body.EnclosingScope.LexicallyDeclaredName(field.Name);
                            if (lexDecl != null)
                            {
                                // report the error (lex/const/funcdecl collision)
                                lexDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, true);

                                // link the inner one to the outer one so any renaming stays in sync.
                                if (lexDecl.VariableField != null)
                                {
                                    lexDecl.VariableField.OuterField = field.VariableField;
                                    if (field.VariableField != null && !lexDecl.VariableField.CanCrunch)
                                    {
                                        field.VariableField.CanCrunch = false;
                                    }
                                }
                            }
                        }

                        // check to make sure there are no var-decl'd names with the same name. Those will
                        // get carried up to this scope so we don't need to check the block scope (if any)
                        var varDecl = node.BlockScope.VarDeclaredName(field.Name);
                        if (varDecl != null)
                        {
                            // report the error (lex/const collides with var) or warning (funcdecl collides with var)
                            varDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, field is LexicalDeclaration);

                            // and mark them both as no-rename
                            varDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                            field.VariableField.IfNotNull(v => v.CanCrunch = false);
                        }
                    }
                }

                // recurse
                base.Visit(node);

                // if the body is now empty (and doesn't have its own lexical scope), make it null
                if (node.Body != null && node.Body.Count == 0 && !node.Body.HasOwnScope)
                {
                    node.Body = null;
                }

                if (node.Initializer != null && node.Initializer.IsDebugOnly)
                {
                    node.Initializer = null;
                }

                if (node.Incrementer != null && node.Incrementer.IsDebugOnly)
                {
                    node.Incrementer = null;
                }

                if (node.Condition != null && node.Condition.IsDebugOnly)
                {
                    if (node.Initializer == null && node.Incrementer == null && node.Body == null)
                    {
                        node.IsDebugOnly = true;
                    }
                    else
                    {
                        node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                    }
                }
            }
        }

        public override void Visit(ForInStatement node)
        {
            if (node != null)
            {
                // if this forIn-statement has it's own lexical scope, then it's an error
                // if the any of the field names declared in this scope is also defined inside the body.
                if (node.BlockScope != null)
                {
                    foreach (var field in node.BlockScope.LexicallyDeclaredNames)
                    {
                        // if the block has a lexical scope, check it for conflicts
                        if (node.Body != null && node.Body.HasOwnScope)
                        {
                            var lexDecl = node.Body.EnclosingScope.LexicallyDeclaredName(field.Name);
                            if (lexDecl != null)
                            {
                                // report the error (lex/const/funcdecl collision)
                                lexDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, true);

                                // link the inner one to the outer one so any renaming stays in sync.
                                if (lexDecl.VariableField != null)
                                {
                                    lexDecl.VariableField.OuterField = field.VariableField;
                                    if (field.VariableField != null && !lexDecl.VariableField.CanCrunch)
                                    {
                                        field.VariableField.CanCrunch = false;
                                    }
                                }
                            }
                        }

                        // check to make sure there are no var-decl'd names with the same name. Those will
                        // get carried up to this scope so we don't need to check the block scope (if any)
                        var varDecl = node.BlockScope.VarDeclaredName(field.Name);
                        if (varDecl != null)
                        {
                            // report the error (lex/const collides with var) or warning (funcdecl collides with var)
                            varDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, field is LexicalDeclaration);

                            // and mark them both as no-rename
                            varDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                            field.VariableField.IfNotNull(v => v.CanCrunch = false);
                        }
                    }
                }

                // recurse
                base.Visit(node);

                // if the body is now empty (and doesn't have its own lexical scope), make it null
                if (node.Body != null && node.Body.Count == 0 && !node.Body.HasOwnScope)
                {
                    node.Body = null;
                }

                if (node.Collection != null && node.Collection.IsDebugOnly)
                {
                    if (node.Body == null)
                    {
                        node.IsDebugOnly = true;
                    }
                    else
                    {
                        node.Collection = new ObjectLiteral(node.Collection.Context)
                            {
                                IsDebugOnly = true
                            };
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(FunctionObject node)
        {
            if (node != null)
            {
                // get the name of this function, calculate something if it's anonymous or if
                // the name isn't actually referenced
                if (node.Binding == null
                    || node.Binding.Name.IsNullOrWhiteSpace()
                    || (node.IsExpression
                        && node.Binding.VariableField.IfNotNull(v => v.RefCount == 0)
                        && m_parser.Settings.RemoveFunctionExpressionNames
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveFunctionExpressionNames)))
                {
                    node.NameGuess = GuessAtName(node);
                }

                // don't analyze the identifier or we'll add an extra reference to it.
                var isStrict = m_scopeStack.Peek().UseStrict;
                if (isStrict && node.Binding != null)
                {
                    // we need to make sure the function isn't named "eval" or "arguments"
                    if (string.CompareOrdinal(node.Binding.Name, "eval") == 0
                        || string.CompareOrdinal(node.Binding.Name, "arguments") == 0)
                    {
                        if (node.Binding.Context != null)
                        {
                            node.Binding.Context.HandleError(JSError.StrictModeFunctionName, true);
                        }
                        else if (node.Context != null)
                        {
                            node.Context.HandleError(JSError.StrictModeFunctionName, true);
                        }
                    }
                }

                if (node.FunctionType == FunctionType.Setter
                    && (node.ParameterDeclarations == null || node.ParameterDeclarations.Count != 1))
                {
                    (node.ParameterDeclarations.IfNotNull(p => p.Context) ?? node.Context).HandleError(JSError.SetterMustHaveOneParameter, true);
                }
                else if (node.ParameterDeclarations.IfNotNull(p => p.Count > 1))
                {
                    // more than one parameter. Make sure there are no rest parameters BEFORE the last parameter
                    var lastParameterIndex = node.ParameterDeclarations.Count - 1;
                    node.ParameterDeclarations.ForEach<ParameterDeclaration>(paramDecl =>
                        {
                            if (paramDecl.Position != lastParameterIndex && paramDecl.HasRest)
                            {
                                paramDecl.Context.HandleError(JSError.RestParameterNotLast, true);
                            }
                        });
                }

                if (node.ParameterDeclarations != null && node.ParameterDeclarations.Count > 0)
                {
                    // recurse the parameters to catch any keywords or strict naming issues
                    var oldError = m_strictNameError;
                    m_strictNameError = JSError.StrictModeArgumentName;
                    node.ParameterDeclarations.Accept(this);
                    m_strictNameError = oldError;

                    // we need to make sure there are no duplicate argument names, so
                    // create map that we'll use to determine if there are any dups
                    var parameterMap = new HashSet<string>();
                    foreach (var bindingIdentifier in BindingsVisitor.Bindings(node.ParameterDeclarations))
                    {
                        // if it already exists in the map, then it's a dup
                        if (!parameterMap.Add(bindingIdentifier.Name))
                        {
                            // already exists -- throw an error
                            if (isStrict)
                            {
                                bindingIdentifier.Context.HandleError(JSError.StrictModeDuplicateArgument, true);
                            }
                            else
                            {
                                bindingIdentifier.Context.HandleError(JSError.DuplicateName, false);
                            }
                        }
                    }
                }

                if (node.Body != null)
                {
                    // push the stack and analyze the body
                    m_scopeStack.Push(node.EnclosingScope);
                    try
                    {
                        // recurse the body
                        node.Body.Accept(this);
                    }
                    finally
                    {
                        m_scopeStack.Pop();
                    }
                }

                if (node.ParameterDeclarations != null && node.ParameterDeclarations.Count > 0)
                {
                    // everything's been resolved and things may have been taken away away now that we've
                    // recursed, so walk backwards from the end of the parameters list
                    // and flag/remove any parameters that are not referenced until we hit the first one that is.
                    var removeIfUnreferenced = m_parser.Settings.RemoveUnneededCode
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnusedParameters);
                    var foundLastReference = false;
                    for (var ndx = node.ParameterDeclarations.Count - 1; ndx >= 0; --ndx)
                    {
                        if (node.ParameterDeclarations[ndx] is ParameterDeclaration paramDecl)
                        {
                            if (CheckParametersAreReferenced(paramDecl.Binding, removeIfUnreferenced, foundLastReference))
                            {
                                // if we've already hit a referenced parameter, then we couldn't delete this
                                // one if we wanted, so don't bother even reporting it.
                                if (!foundLastReference)
                                {
                                    // the entire parameter is unreferenced and we haven't found a referenced
                                    // parameter yet, so report the issue
                                    paramDecl.Context.HandleError(JSError.ArgumentNotReferenced);

                                    if (removeIfUnreferenced)
                                    {
                                        node.ParameterDeclarations.RemoveAt(ndx);
                                    }
                                }
                            }
                            else
                            {
                                // *something* is referenced in this parameter. But keep going so we can
                                // find unreferenced binding pattern identifiers in other parameters
                                foundLastReference = true;
                            }
                        }
                    }
                }

                // if this is an arrow function with a single statement in the body that's
                // a return statement, we can get rid of the return and just return keep the
                // operand by itself.
                ReturnStatement returnNode;
                if (node.FunctionType == FunctionType.ArrowFunction
                    && node.Body.IfNotNull(b => b.Count == 1)
                    && (returnNode = node.Body[0] as ReturnStatement) != null)
                {
                    node.Body.ReplaceChild(returnNode, returnNode.Operand);
                    node.Body.IsConcise = true;
                }
            }
        }

        private static bool CheckParametersAreReferenced(AstNode binding, bool removeIfUnreferenced, bool foundLastReference)
        {
            var isUnreferenced = false;

            // if it's either a simple binding identifier or a unary rest that's a binding operator...
            if (binding is BindingIdentifier bindingIdentifier)
            {
                // simple binding identifier
                isUnreferenced = false;
                if (bindingIdentifier.VariableField != null)
                {
                    isUnreferenced = !bindingIdentifier.VariableField.IsReferenced;
                    if (isUnreferenced && removeIfUnreferenced && !foundLastReference)
                    {
                        // clean up the field - the parameter itself will be deleted when we return
                        bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);
                        bindingIdentifier.VariableField.WasRemoved = true;
                    }
                }
            }
            else
            {
                // binding pattern
                // assume the whole thing UNreferenced unless we find something that IS referenced
                isUnreferenced = true;
                foreach (var nameDecl in BindingsVisitor.Bindings(binding))
                {
                    if (nameDecl.VariableField.IfNotNull(v => !v.IsReferenced))
                    {
                        // this declaration is unreferenced, and it's in a binding pattern.
                        // report it as unreferenced
                        nameDecl.Context.HandleError(JSError.ArgumentNotReferenced);

                        // and delete it now if we are deleting unreferenced parameters
                        if (removeIfUnreferenced)
                        {
                            // delete it, but don't clean up the containing binding because
                            // we will need to do special processing for argument binding patterns.
                            ActivationObject.DeleteFromBindingPattern(nameDecl, false);
                        }
                    }
                    else
                    {
                        // referenced (or no field). This entire binding is considered referenced
                        isUnreferenced = false;
                    }
                }

                // we should always trim the trailing elisions from array bindings
                TrimTrailingElisionsFromArrayBindings(binding);
            }

            return isUnreferenced;
        }

        private static void TrimTrailingElisionsFromArrayBindings(AstNode binding)
        {
            ObjectLiteral objectLiteral;

            if (binding is ArrayLiteral arrayBinding)
            {
                // trim all trailing elisions
                var trailing = true;
                for (var ndx = arrayBinding.Elements.Count - 1; ndx >= 0; --ndx)
                {
                    // since this is a binding, the only constant allowed would be the missing                    // value, so don't bother checking. If it's a constant, whack it.
                    if (arrayBinding.Elements[ndx] is ConstantWrapper constantWrapper)
                    {
                        // if it's no longer trailing, then just ignore it
                        if (trailing)
                        {
                            arrayBinding.Elements.RemoveAt(ndx);
                        }
                    }
                    else
                    {
                        // no longer elision, but recurse
                        trailing = false;
                        TrimTrailingElisionsFromArrayBindings(arrayBinding.Elements[ndx]);
                    }
                }
            }
            else if ((objectLiteral = binding as ObjectLiteral) != null)
            {
                objectLiteral.Properties.ForEach<ObjectLiteralProperty>(property => TrimTrailingElisionsFromArrayBindings(property.Value));
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(IfStatement node)
        {
            if (node != null)
            {
                // recurse....
                base.Visit(node);

                // now check to see if the two branches are now empty.
                // if they are, null them out.
                if (node.TrueBlock != null && node.TrueBlock.Count == 0)
                {
                    node.TrueBlock = null;
                }
                if (node.FalseBlock != null && node.FalseBlock.Count == 0)
                {
                    node.FalseBlock = null;
                }

                if (node.Condition != null && node.Condition.IsDebugOnly)
                {
                    node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                    node.TrueBlock = null;
                }

                if (node.TrueBlock != null && node.FalseBlock != null)
                {
                    // neither true block nor false block is null.
                    // if they're both expressions, convert them to a condition operator
                    if (node.TrueBlock.IsExpression && node.FalseBlock.IsExpression
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.IfExpressionsToExpression))
                    {
                        // if this statement has both true and false blocks, and they are both expressions,
                        // then we can simplify this to a conditional expression.
                        // because the blocks are expressions, we know they only have ONE statement in them,
                        // so we can just dereference them directly.
                        Conditional conditional;
                        var logicalNot = new LogicalNotVisitor(node.Condition, m_parser.Settings);
                        if (logicalNot.Measure() < 0)
                        {
                            // applying a logical-not makes the condition smaller -- reverse the branches
                            logicalNot.Apply();
                            conditional = new Conditional(node.Context)
                                {
                                    Condition = node.Condition,
                                    TrueExpression = node.FalseBlock[0],
                                    FalseExpression = node.TrueBlock[0]
                                };
                        }
                        else
                        {
                            // regular order
                            conditional = new Conditional(node.Context)
                                {
                                    Condition = node.Condition,
                                    TrueExpression = node.TrueBlock[0],
                                    FalseExpression = node.FalseBlock[0]
                                };
                        }

                        node.Parent.ReplaceChild(
                            node,
                            conditional);

                        Optimize(conditional);
                    }
                    else
                    {
                        // see if logical-notting the condition produces something smaller
                        var logicalNot = new LogicalNotVisitor(node.Condition, m_parser.Settings);
                        if (logicalNot.Measure() < 0)
                        {
                            // it does -- not the condition and swap the branches
                            logicalNot.Apply();
                            node.SwapBranches();
                        }

                        // see if the true- and false-branches each contain only a single statement
                        if (node.TrueBlock.Count == 1 && node.FalseBlock.Count == 1)
                        {
                            // they do -- see if the true-branch's statement is a return-statement
                            var trueReturn = node.TrueBlock[0] as ReturnStatement;
                            if (trueReturn?.Operand != null)
                            {
                                // it is -- see if the false-branch is also a return statement
                                var falseReturn = node.FalseBlock[0] as ReturnStatement;
                                if (falseReturn?.Operand != null)
                                {
                                    // transform: if(cond)return expr1;else return expr2 to return cond?expr1:expr2
                                    var conditional = new Conditional(node.Condition.Context.FlattenToStart())
                                        {
                                            Condition = node.Condition,
                                            TrueExpression = trueReturn.Operand,
                                            FalseExpression = falseReturn.Operand
                                        };

                                    // create a new return node from the conditional and replace
                                    // our if-node with it
                                    var returnNode = new ReturnStatement(node.Context)
                                        {
                                            Operand = conditional
                                        };

                                    node.Parent.ReplaceChild(
                                        node,
                                        returnNode);

                                    Optimize(conditional);
                                }
                            }
                        }
                    }
                }
                else if (node.FalseBlock != null)
                {
                    // true block must be null.
                    // if there is no true branch but a false branch, then
                    // put a not on the condition and move the false branch to the true branch.
                    if (node.FalseBlock.IsExpression
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionCallToConditionAndCall))
                    {
                        // if (cond); else expr ==> cond || expr
                        // but first -- which operator to use? if(a);else b --> a||b, and if(!a);else b --> a&&b
                        // so determine which one is smaller: a or !a
                        // assume we'll use the logical-or, since that doesn't require changing the condition
                        var newOperator = JSToken.LogicalOr;
                        var logicalNot = new LogicalNotVisitor(node.Condition, m_parser.Settings);
                        if (logicalNot.Measure() < 0)
                        {
                            // !a is smaller, so apply it and use the logical-or operator
                            logicalNot.Apply();
                            newOperator = JSToken.LogicalAnd;
                        }

                        var binaryOp = new BinaryExpression(node.Context)
                            {
                                Operand1 = node.Condition,
                                Operand2 = node.FalseBlock[0],
                                OperatorToken = newOperator,
                            };

                        // we don't need to analyse this new node because we've already analyzed
                        // the pieces parts as part of the if. And this visitor's method for the BinaryExpression
                        // doesn't really do anything else. Just replace our current node with this
                        // new node
                        node.Parent.ReplaceChild(node, binaryOp);
                    }
                    else if (m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionFalseToIfNotConditionTrue))
                    {
                        // logical-not the condition
                        // if(cond);else stmt ==> if(!cond)stmt
                        var logicalNot = new LogicalNotVisitor(node.Condition, m_parser.Settings);
                        logicalNot.Apply();

                        // and swap the branches
                        node.SwapBranches();
                    }
                }
                else if (node.TrueBlock != null)
                {
                    // false block must be null
                    if (node.TrueBlock.IsExpression
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.IfConditionCallToConditionAndCall))
                    {
                        // convert the if-node to an expression
                        IfConditionExpressionToExpression(node, node.TrueBlock[0]);
                    }
                }
                else if (m_parser.Settings.IsModificationAllowed(TreeModifications.IfEmptyToExpression))
                {
                    // NEITHER branches have anything now!

                    // as long as the condition doesn't
                    // contain calls or assignments, we should be able to completely delete
                    // the statement altogether rather than changing it to an expression
                    // statement on the condition.
                    // but how do we KNOW there are no side-effects?
                    // if the condition is a constant or operations on constants, delete it.
                    // or if the condition itself is a debugger statement -- a call, lookup, or member.
                    var remove = node.Condition == null || node.Condition.IsConstant || node.Condition.IsDebugOnly;
                    if (remove)
                    {
                        // we're pretty sure there are no side-effects; remove it altogether
                        node.Parent.ReplaceChild(node, null);
                    }
                    else
                    {
                        // We don't know what it is and what the side-effects may be, so
                        // just change this statement into an expression statement by replacing us with 
                        // the expression
                        // no need to analyze -- we already recursed
                        node.Parent.ReplaceChild(node, node.Condition);
                    }
                }

                if (node.FalseBlock == null
                    && node.TrueBlock != null
                    && node.TrueBlock.Count == 1
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.CombineNestedIfs))
                {
                    if (node.TrueBlock[0] is IfStatement nestedIf && nestedIf.FalseBlock == null)
                    {
                        // we have nested if-blocks.
                        // transform if(cond1)if(cond2){...} to if(cond1&&cond2){...}
                        // change the first if-statement's condition to be cond1&&cond2
                        // move the nested if-statement's true block to the outer if-statement
                        node.Condition = new BinaryExpression(node.Condition.Context.FlattenToStart())
                            {
                                Operand1 = node.Condition,
                                Operand2 = nestedIf.Condition,
                                OperatorToken = JSToken.LogicalAnd
                            };
                        node.TrueBlock = nestedIf.TrueBlock;
                    }
                }
            }
        }

        private void IfConditionExpressionToExpression(IfStatement ifNode, AstNode expression)
        {
            // but first -- which operator to use? if(a)b --> a&&b, and if(!a)b --> a||b
            // so determine which one is smaller: a or !a
            // assume we'll use the logical-and, since that doesn't require changing the condition
            var newOperator = JSToken.LogicalAnd;
            var logicalNot = new LogicalNotVisitor(ifNode.Condition, m_parser.Settings);
            if (logicalNot.Measure() < 0)
            {
                // !a is smaller, so apply it and use the logical-or operator
                logicalNot.Apply();
                newOperator = JSToken.LogicalOr;
            }

            // because the true block is an expression, we know it must only have
            // ONE statement in it, so we can just dereference it directly.
            var binaryOp = new BinaryExpression(ifNode.Context)
                {
                    Operand1 = ifNode.Condition,
                    Operand2 = expression,
                    OperatorToken = newOperator,
                };

            // we don't need to analyse this new node because we've already analyzed
            // the pieces parts as part of the if. And this visitor's method for the BinaryExpression
            // doesn't really do anything else. Just replace our current node with this
            // new node
            ifNode.Parent.ReplaceChild(ifNode, binaryOp);
        }

        public override void Visit(ImportStatement node)
        {
            if (node != null)
            {
                base.Visit(node);

                // if there is only one binding and it's not a specifier, then we want to
                // make sure we do NOT rename them, because they are dependent on an external module.
                // but we CAN rename any of the other specifiers we may have. 
                if (node.Count == 1 && !(node[0] is ImportExportSpecifier))
                {
                    foreach (var bindingIdentifier in BindingsVisitor.Bindings(node[0]))
                    {
                        if (bindingIdentifier.VariableField != null)
                        {
                            bindingIdentifier.VariableField.CanCrunch = false;
                        }
                    }
                }
            }
        }

        public override void Visit(LabeledStatement node)
        {
            if (node != null)
            {
                // if we set the nest count to something greater than 0, then the label will
                // get renamed when we output it.

                // then recurse the statement
                if (node.Statement != null)
                {
                    node.Statement.Accept(this);
                }

                if (node.LabelInfo != null && !node.LabelInfo.HasIssues)
                {
                    if (node.LabelInfo.RefCount == 0)
                    {
                        // low-sev warning
                        node.LabelContext.HandleError(JSError.UnusedLabel);
                    }

                    if (node.LabelInfo.RefCount == 0
                        && m_parser.Settings.RemoveUnneededCode
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryLabels))
                    {
                        // just get rid of the label altogether
                        if (node.Statement == null)
                        {
                            // no statement; just delete this node from its parent
                            node.Parent.ReplaceChild(node, null);
                        }
                        else
                        {
                            // take the statement from this node and replace the node with
                            // this statement
                            node.Parent.ReplaceChild(node, node.Statement);
                        }
                    }
                    else if (m_parser.Settings.LocalRenaming != LocalRenaming.KeepAll
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.LocalRenaming))
                    {
                        // it was either referenced or we don't want to get rid of unused labels,
                        // but we DO want to minify them. set the minified value.
                        node.LabelInfo.MinLabel = CrunchEnumerator.CrunchedLabel(node.LabelInfo.NestLevel);
                    }
                }
            }
        }

        public override void Visit(LookupExpression node)
        {
            // lookup is the start of a possible debug namespace, so assume we are NOT a match
            m_possibleDebugNamespace = false;
            if (node != null)
            {
                // figure out if our reference type is a function or a constructor
                if (node.Parent is CallExpression)
                {
                    node.RefType = (
                      ((CallExpression)(node.Parent)).IsConstructor
                      ? ReferenceType.Constructor
                      : ReferenceType.Function
                      );
                }

                // check the name of the variable for reserved words that aren't allowed
                ActivationObject scope = m_scopeStack.Peek();
                if (JSScanner.IsKeyword(node.Name, scope.UseStrict)
                    && node.VariableField.IfNotNull(v => v.FieldType != FieldType.Super))
                {
                    node.Context.HandleError(JSError.KeywordUsedAsIdentifier, true);
                }

                // no variable field means ignore it
                var parentIsMember = node.Parent is MemberExpression;
                if (node.VariableField != null && node.VariableField.FieldType == FieldType.Predefined)
                {
                    // this is a predefined field. If it's Nan or Infinity, we should
                    // replace it with the numeric value in case we need to later combine
                    // some literal expressions.
                    if (string.CompareOrdinal(node.Name, "NaN") == 0)
                    {
                        // don't analyze the new ConstantWrapper -- we don't want it to take part in the
                        // duplicate constant combination logic should it be turned on.
                        node.Parent.ReplaceChild(node, new ConstantWrapper(double.NaN, PrimitiveType.Number, node.Context));
                    }
                    else if (string.CompareOrdinal(node.Name, "Infinity") == 0)
                    {
                        // don't analyze the new ConstantWrapper -- we don't want it to take part in the
                        // duplicate constant combination logic should it be turned on.
                        node.Parent.ReplaceChild(node, new ConstantWrapper(double.PositiveInfinity, PrimitiveType.Number, node.Context));
                    }
                    else if (m_lookForDebugNamespaces 
                        && parentIsMember 
                        && string.CompareOrdinal(node.Name, "window") == 0)
                    {
                        // this is a lookup for the global window object. Might be the start of a debug namespace.
                        // leave the index at zero, because we haven't matched anything yet.
                        m_possibleDebugNamespace = true;
                        m_possibleDebugNamespaceIndex = 0;
                        m_possibleDebugMatches.Clear();
                    }
                }

                if (m_lookForDebugNamespaces && !m_possibleDebugNamespace)
                {
                    if (InitialDebugNameSpaceMatches(node.Name, parentIsMember))
                    {
                        // the initial search found a match! No need to keep looking; just replace
                        // the lookup with an empty object literal marked as debug-only.
                        node.IsDebugOnly = true;
                        node.Parent.ReplaceChild(node, new ObjectLiteral(node.Context)
                        {
                            IsDebugOnly = true
                        });
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(MemberExpression node)
        {
            if (node != null)
            {
                // if we don't even have any resource strings, then there's nothing
                // we need to do and we can just perform the base operation
                var resourceList = m_parser.Settings.ResourceStrings;
                if (resourceList.Count > 0)
                {
                    // if we haven't created the match visitor yet, do so now
                    if (m_matchVisitor == null)
                    {
                        m_matchVisitor = new MatchPropertiesVisitor();
                    }

                    // walk the list BACKWARDS so that later resource strings supercede previous ones
                    for (var ndx = resourceList.Count - 1; ndx >= 0; --ndx)
                    {
                        var resourceStrings = resourceList[ndx];

                        // see if the resource string name matches the root
                        if (m_matchVisitor.Match(node.Root, resourceStrings.Name))
                        {
                            // it is -- we're going to replace this with a string value.
                            // if this member name is a string on the object, we'll replacve it with
                            // the literal. Otherwise we'll replace it with an empty string.
                            // see if the string resource contains this value
                            ConstantWrapper stringLiteral = new ConstantWrapper(
                                resourceStrings[node.Name] ?? string.Empty,
                                PrimitiveType.String,
                                node.Context);

                            node.Parent.ReplaceChild(node, stringLiteral);

                            // analyze the literal
                            stringLiteral.Accept(this);
                            return;
                        }
                    }
                }

                // if we are replacing property names and we have something to replace
                if (m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.PropertyRenaming))
                {
                    // see if this name is a target for replacement
                    string newName = m_parser.Settings.GetNewName(node.Name);
                    if (!string.IsNullOrEmpty(newName))
                    {
                        // it is -- set the name to the new name
                        node.Name = newName;
                    }
                }

                // check the name of the member for reserved words that aren't allowed
                if (JSScanner.IsKeyword(node.Name, m_scopeStack.Peek().UseStrict))
                {
                    node.NameContext.HandleError(JSError.KeywordUsedAsIdentifier);
                }

                // recurse
                if (node.Root != null)
                {
                    node.Root.Accept(this);
                }

                if (m_stripDebug)
                {
                    var parentIsMember = node.Parent is MemberExpression;
                    if (node.Root.IfNotNull(r => r.IsDebugOnly))
                    {
                        // if the root is debug-only, WE are debug-only
                        node.IsDebugOnly = true;
                    }
                    else if (m_possibleDebugNamespace)
                    {
                        // if the matches are empty, then we need to populate the list to begin with
                        if (m_possibleDebugMatches.Count == 0)
                        {
                            if (InitialDebugNameSpaceMatches(node.Name, parentIsMember))
                            {
                                node.IsDebugOnly = true;
                            }
                        }
                        else
                        {
                            // if we are still a possible debug namespace, check the remaining patterns
                            for (var ndx = m_possibleDebugMatches.Count - 1; ndx >= 0; --ndx)
                            {
                                var debugParts = m_possibleDebugMatches[ndx];
                                if (string.CompareOrdinal(node.Name, debugParts[m_possibleDebugNamespaceIndex]) == 0)
                                {
                                    // another match. If that means we've matched a complete part list!
                                    // if not, if there are more parts available to check, then keep going.
                                    if (debugParts.Length == m_possibleDebugNamespaceIndex + 1)
                                    {
                                        node.IsDebugOnly = true;
                                        m_possibleDebugMatches.Clear();
                                        break;
                                    }
                                }
                                else
                                {
                                    // not a match; remove this possibility
                                    m_possibleDebugMatches.RemoveAt(ndx);
                                }
                            }

                            // if there are still patterns that we're matching, keep going with the next item if
                            // our parent is another member
                            if (m_possibleDebugMatches.Count > 0 && parentIsMember)
                            {
                                ++m_possibleDebugNamespaceIndex;
                            }
                            else
                            {
                                // otherwise we're done; make sure the list is cleared out.
                                m_possibleDebugMatches.Clear();
                                m_possibleDebugNamespace = false;
                            }
                        }

                        // if we found a match, replace ourselves with an object literal
                        if (node.IsDebugOnly)
                        {
                            node.Parent.ReplaceChild(node, new ObjectLiteral(node.Context)
                            {
                                IsDebugOnly = true
                            });
                        }
                    }
                }
            }
        }

        private bool InitialDebugNameSpaceMatches(string name, bool parentIsMember)
        {
            foreach (var parts in m_debugNamespaceParts)
            {
                if (string.CompareOrdinal(name, parts[0]) == 0)
                {
                    // we have a match. If there is only one part, we're done because we totally matched.
                    if (parts.Length == 1)
                    {
                        // clear out the list so we stop looking and return true
                        // as an indicator that we found a complete match
                        m_possibleDebugMatches.Clear();
                        m_possibleDebugNamespace = false;
                        return true;
                    }
                    else if (parentIsMember)
                    {
                        // otherwise add it to the list so we will keep looking when we go up a
                        // level to the next member operator
                        m_possibleDebugMatches.Add(parts);
                    }
                }
            }

            if (m_possibleDebugMatches.Count > 0)
            {
                // we found possible matches, so set the state so we keep looking
                m_possibleDebugNamespace = true;
                m_possibleDebugNamespaceIndex = 1;
            }

            // if we got here, we didn't find a complete match
            return false;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(ObjectLiteral node)
        {
            if (node != null)
            {
                // recurse
                base.Visit(node);

                // if we are going to be renaming things...
                if (m_parser.Settings.LocalRenaming != LocalRenaming.KeepAll)
                {
                    node.Properties.ForEach<ObjectLiteralProperty>(property =>
                        {
                            if (property.Name == null)
                            {
                                // implicit object property name! if we change the variable name,
                                // we will pick up the WRONG property name!
                                // the value should be a binding identifier or a lookup, should be a valid identifier,
                                // and not be in the "norename" list
                                var propertyName = property.Value.ToString();
                                if (JSScanner.IsValidIdentifier(propertyName) && !m_noRename.Contains(propertyName))
                                {
                                    if (FieldCanBeRenamed(property.Value))
                                    {
                                        // it can be renamed. Let's add a property name now to lock the name down
                                        property.Name = new ObjectLiteralField(propertyName, PrimitiveType.String, property.Value.Context)
                                        {
                                            IsIdentifier = true
                                        };
                                    }
                                }
                            }
                        });
                }

                if (m_scopeStack.Peek().UseStrict)
                {
                    // now strict-mode checks
                    // go through all property names and make sure there are no duplicates.
                    // use a map to remember which ones we already have and of what type.
                    var nameMap = new Dictionary<string, string>();
                    node.Properties.ForEach<ObjectLiteralProperty>(property =>
                        {
                            var propertyType = GetPropertyType(property.Value as FunctionObject);

                            // key name is the name plus the type. Can't just use the name because 
                            // get and set will both have the same name (but different types)
                            var keyName = (property.Name ?? property.Value) + propertyType;

                            string mappedType;
                            if (propertyType == "data")
                            {
                                // can't have another data, get, or set
                                if (nameMap.TryGetValue(keyName, out mappedType)
                                    || nameMap.TryGetValue((property.Name ?? property.Value) + "get", out mappedType)
                                    || nameMap.TryGetValue((property.Name ?? property.Value) + "set", out mappedType))
                                {
                                    // throw the error
                                    (property.Name ?? property.Value).Context.HandleError(JSError.StrictModeDuplicateProperty, true);

                                    // if the mapped type isn't data, then we can add this data name/type to the map
                                    // because that means the first tryget failed and we don't have a data already
                                    if (mappedType != propertyType)
                                    {
                                        nameMap.Add(keyName, propertyType);
                                    }
                                }
                                else
                                {
                                    // not in the map at all. Add it now.
                                    nameMap.Add(keyName, propertyType);
                                }
                            }
                            else
                            {
                                // get can have a set, but can't have a data or another get
                                // set can have a get, but can't have a data or another set
                                if (nameMap.TryGetValue(keyName, out mappedType)
                                    || nameMap.TryGetValue((property.Name ?? property.Value) + "data", out mappedType))
                                {
                                    // throw the error
                                    (property.Name ?? property.Value).Context.HandleError(JSError.StrictModeDuplicateProperty, true);

                                    // if the mapped type isn't data, then we can add this data name/type to the map
                                    if (mappedType != propertyType)
                                    {
                                        nameMap.Add(keyName, propertyType);
                                    }
                                }
                                else
                                {
                                    // not in the map at all - add it now
                                    nameMap.Add(keyName, propertyType);
                                }
                            }
                        });
                }
            }
        }

        private static bool FieldCanBeRenamed(AstNode node)
        {
            var canBeRenamed = false;
            if (node != null)
            {
                canBeRenamed = (node as INameDeclaration).IfNotNull(n => !n.RenameNotAllowed && n.VariableField.IfNotNull(v => v.CanCrunch));
                if (!canBeRenamed)
                {
                    canBeRenamed = (node as INameReference).IfNotNull(n => n.VariableField.IfNotNull(v => v.CanCrunch));
                }
            }

            return canBeRenamed;
        }

        public override void Visit(ObjectLiteralField node)
        {
            if (node != null)
            {
                if (node.PrimitiveType == PrimitiveType.String
                    && m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.PropertyRenaming))
                {
                    string newName = m_parser.Settings.GetNewName(node.Value.ToString());
                    if (!string.IsNullOrEmpty(newName))
                    {
                        node.Value = newName;
                    }
                }

                // don't call the base -- we don't want to add the literal to
                // the combination logic, which is what the ConstantWrapper (base class) does
                //base.Visit(node);
            }
        }

        public override void Visit(ObjectLiteralProperty node)
        {
            if (node != null)
            {
                base.Visit(node);
                if (node.Value != null && node.Value.IsDebugOnly)
                {
                    node.Value = new ConstantWrapper(null, PrimitiveType.Null, node.Value.Context);
                }
            }
        }

        private static string GetPropertyType(FunctionObject funcObj)
        {
            // should never be a function declaration....
            switch(funcObj.IfNotNull(f => f.FunctionType))
            {
                case FunctionType.Getter:
                    return "get";

                case FunctionType.Setter:
                    return "set";

                case FunctionType.Method:
                    return "method";

                default:
                    return "data";
            }
        }

        public override void Visit(RegExpLiteral node)
        {
            if (node != null)
            {
                // verify the syntax
                try
                {
                    // just try instantiating a Regex object with this string.
                    // if it's invalid, it will throw an exception.
                    // we don't need to pass the flags -- we're just interested in the pattern
                    Regex re = new Regex(node.Pattern, RegexOptions.ECMAScript);

                    // basically we have this test here so the re variable is referenced
                    // and FxCop won't throw an error. There really aren't any cases where
                    // the constructor will return null (other than out-of-memory)
                    if (re == null)
                    {
                        node.Context.HandleError(JSError.RegExpSyntax, true);
                    }
                }
                catch (System.ArgumentException e)
                {
                    Debug.WriteLine(e.ToString());
                    node.Context.HandleError(JSError.RegExpSyntax, true);
                }
                // don't bother calling the base -- there are no children
            }
        }

        public override void Visit(ReturnStatement node)
        {
            if (node != null)
            {
                // first we want to make sure that we are indeed within a function scope.
                // it makes no sense to have a return outside of a function
                ActivationObject scope = m_scopeStack.Peek();
                while (scope != null && !(scope is FunctionScope))
                {
                    scope = scope.Parent;
                }

                if (scope == null)
                {
                    node.Context.HandleError(JSError.BadReturn);
                }

                // recurse the operand if we have one
                if (node.Operand != null)
                {
                    node.Operand.Accept(this);

                    if (node.Operand == null || node.Operand.IsDebugOnly)
                    {
                        node.Operand = null;
                    }
                    else
                    {
                        // now see if it's a binary op assignment to a variable local to this scope.
                        // if it is, we can get rid of the assignment because we're leaving the scope.
                        var lookup = node.Operand.LeftHandSide as LookupExpression;
                        BinaryExpression binaryOp;
                        if (lookup?.VariableField != null
                            && lookup.VariableField.OuterField == null
                            && (binaryOp = lookup.Parent as BinaryExpression) != null
                            && binaryOp.IsAssign
                            && !lookup.VariableField.IsReferencedInnerScope)
                        {
                            if (binaryOp.OperatorToken != JSToken.Assign)
                            {
                                // it's an OP= assignment, so keep the lookup, but convert the operator to a non-assignment
                                binaryOp.OperatorToken = JSScanner.StripAssignment(binaryOp.OperatorToken);
                            }
                            else if (binaryOp.Parent == node)
                            {
                                // straight assignment. But we can only get rid of the assignment if
                                // it's the root operation of the return. If it's buried down in a complex
                                // assignment, then leave it be.
                                lookup.VariableField.References.Remove(lookup);
                                node.Operand = binaryOp.Operand2;
                            }
                        }
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(SwitchStatement node)
        {
            if (node != null)
            {
                base.Visit(node);

                if (node.Expression != null && node.Expression.IsDebugOnly)
                {
                    node.Expression = new ConstantWrapper(null, PrimitiveType.Null, node.Expression.Context);
                }

                // if the switch case has a lexical scope, we need to check to make sure anything declared lexically
                // doesn't collide with anything declared as a var underneath (which bubbles up to the variable scope).
                if (node.BlockScope != null)
                {
                    foreach (var lexDecl in node.BlockScope.LexicallyDeclaredNames)
                    {
                        var varDecl = node.BlockScope.VarDeclaredName(lexDecl.Name);
                        if (varDecl != null)
                        {
                            // report the error (lex/const collides with var) or warning (funcdecl collides with var)
                            varDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, lexDecl is LexicalDeclaration);

                            // mark them both a no-rename to preserve the collision
                            varDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                            lexDecl.VariableField.IfNotNull(v => v.CanCrunch = false);
                        }
                    }
                }

                // we only want to remove stuff if we are hypercrunching
                if (m_parser.Settings.RemoveUnneededCode)
                {
                    // because we are looking at breaks, we need to know if this
                    // switch statement is labeled
                    string thisLabel = string.Empty;

                    if (node.Parent is LabeledStatement label)
                    {
                        thisLabel = label.Label;
                    }

                    // loop through all the cases, looking for the default.
                    // then, if it's empty (or just doesn't do anything), we can
                    // get rid of it altogether
                    int defaultCase = -1;
                    bool eliminateDefault = false;
                    for (int ndx = 0; ndx < node.Cases.Count; ++ndx)
                    {
                        // it should always be a switch case, but just in case...
                        if (node.Cases[ndx] is SwitchCase switchCase)
                        {
                            if (switchCase.IsDefault)
                            {
                                // save the index for later
                                defaultCase = ndx;

                                // set the flag to true unless we can prove that we need it.
                                // we'll prove we need it by finding the statement block executed by
                                // this case and showing that it's neither empty nor containing
                                // just a single break statement.
                                eliminateDefault = true;
                            }

                            // if the default case is empty, then we need to keep going
                            // until we find the very next non-empty case
                            if (eliminateDefault && switchCase.Statements.Count > 0)
                            {
                                // this is the set of statements executed during default processing.
                                // if it does nothing -- one break statement -- then we can get rid
                                // of the default case. Otherwise we need to leave it in.
                                if (switchCase.Statements.Count == 1)
                                {
                                    // see if it's a break

                                    // if the last statement is not a break,
                                    // OR it has a label and it's not this switch statement...
                                    if (lastBreak == null
                                      || (lastBreak.Label != null && lastBreak.Label != thisLabel))
                                    {
                                        // set the flag back to false to indicate that we need to keep it.
                                        eliminateDefault = false;
                                    }
                                }
                                else
                                {
                                    // set the flag back to false to indicate that we need to keep it.
                                    eliminateDefault = false;
                                }

                                // break out of the loop
                                break;
                            }
                        }
                    }

                    // if we get here and the flag is still true, then either the default case is
                    // empty, or it contains only a single break statement. Either way, we can get 
                    // rid of it.
                    if (eliminateDefault && defaultCase >= 0
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveEmptyDefaultCase))
                    {
                        // remove it and reset the position index
                        node.Cases.RemoveAt(defaultCase);
                        defaultCase = -1;
                    }

                    // if we have no default handling, then we know we can get rid
                    // of any cases that don't do anything either.
                    if (defaultCase == -1
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveEmptyCaseWhenNoDefault))
                    {
                        // when we delete a case statement, we set this flag to true.
                        // when we hit a non-empty case statement, we set the flag to false.
                        // if we hit an empty case statement when this flag is true, we can delete this case, too.
                        bool emptyStatements = true;
                        BreakStatement deletedBreak = null;

                        // walk the tree backwards because we don't know how many we will
                        // be deleting, and if we go backwards, we won't have to adjust the 
                        // index as we go.
                        for (int ndx = node.Cases.Count - 1; ndx >= 0; --ndx)
                        {
                            // should always be a switch case
                            if (node.Cases[ndx] is SwitchCase switchCase)
                            {
                                // if the block is empty and the last block was empty, we can delete this case.
                                // OR if there is only one statement and it's a break, we can delete it, too.
                                if (switchCase.Statements.Count == 0 && emptyStatements)
                                {
                                    // remove this case statement because it falls through to a deleted case
                                    DetachReferencesVisitor.Apply(switchCase.CaseValue);
                                    node.Cases.RemoveAt(ndx);
                                }
                                else
                                {
                                    // onlyBreak will be set to null if this block is not a single-statement break block
                                    BreakStatement onlyBreak = (switchCase.Statements.Count == 1 ? switchCase.Statements[0] as BreakStatement : null);
                                    if (onlyBreak != null)
                                    {
                                        // we'll only delete this case if the break either doesn't have a label
                                        // OR the label matches the switch statement
                                        if (onlyBreak.Label == null || onlyBreak.Label == thisLabel)
                                        {
                                            // if this is a block with only a break, then we need to keep a hold of the break
                                            // statement in case we need it later
                                            deletedBreak = onlyBreak;

                                            // remove this case statement
                                            DetachReferencesVisitor.Apply(switchCase.CaseValue);
                                            node.Cases.RemoveAt(ndx);
                                            // make sure the flag is set so we delete any other empty
                                            // cases that fell through to this empty case block
                                            emptyStatements = true;
                                        }
                                        else
                                        {
                                            // the break statement has a label and it's not the switch statement.
                                            // we're going to keep this block
                                            emptyStatements = false;
                                            deletedBreak = null;
                                        }
                                    }
                                    else
                                    {
                                        // either this is a non-empty block, or it's an empty case that falls through
                                        // to a non-empty block. if we have been deleting case statements and this
                                        // is not an empty block....
                                        if (emptyStatements && switchCase.Statements.Count > 0 && deletedBreak != null)
                                        {
                                            // we'll need to append the deleted break statement if it doesn't already have
                                            // a flow-changing statement: break, continue, return, or throw
                                            AstNode lastStatement = switchCase.Statements[switchCase.Statements.Count - 1];
                                            if (!(lastStatement is BreakStatement) && !(lastStatement is ContinueStatement)
                                              && !(lastStatement is ReturnStatement) && !(lastStatement is ThrowStatement))
                                            {
                                                switchCase.Statements.Append(deletedBreak);
                                            }
                                        }

                                        // make sure the deletedBreak flag is reset
                                        deletedBreak = null;

                                        // reset the flag
                                        emptyStatements = false;
                                    }
                                }
                            }
                        }
                    }

                    // if the last case's statement list ends in a break, 
                    // we can get rid of the break statement
                    if (node.Cases.Count > 0
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveBreakFromLastCaseBlock))
                    {
                        if (node.Cases[node.Cases.Count - 1] is SwitchCase lastCase)
                        {
                            // get the block of statements making up the last case block
                            BlockStatement lastBlock = lastCase.Statements;
                            // if the last statement is not a break, then lastBreak will be null
                            BreakStatement lastBreak = (lastBlock.Count > 0 ? lastBlock[lastBlock.Count - 1] as BreakStatement : null);

                            // if lastBreak is not null and it either has no label, or the label matches this switch statement...
                            if (switchCase.Statements[0] is BreakStatement lastBreak
                              && (lastBreak.Label == null || lastBreak.Label == thisLabel))
                            {
                                // remove the break statement
                                lastBlock.RemoveLast();
                            }
                        }
                    }
                }
            }
        }

        public override void Visit(TryStatement node)
        {
            if (node != null)
            {
                // anaylze the blocks
                node.TryBlock.IfNotNull(b => b.Accept(this));
                // if the try block is empty, then set it to null
                if (node.TryBlock != null && node.TryBlock.Count == 0)
                {
                    node.TryBlock = null;
                }

                DoCatchBlock(node);

                node.FinallyBlock.IfNotNull(b => b.Accept(this));
                // eliminate an empty finally block UNLESS there is no catch block.
                if (node.FinallyBlock != null && node.FinallyBlock.Count == 0 && node.CatchBlock != null
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveEmptyFinally))
                {
                    node.FinallyBlock = null;
                }
            }
        }

        private void DoCatchBlock(TryStatement node)
        {
            node.CatchBlock.IfNotNull(b => b.Accept(this));
            if (node.CatchParameter != null)
            {
                // check for binding errors (strict names, etc)
                m_strictNameError = JSError.StrictModeCatchName;
                node.CatchParameter.Accept(this);
                m_strictNameError = JSError.StrictModeVariableName;

                // if the block has a lexical scope, check it for conflicts
                var catchBindings = BindingsVisitor.Bindings(node.CatchParameter);
                foreach (var lexDecl in node.CatchBlock.EnclosingScope.LexicallyDeclaredNames)
                {
                    foreach (var catchDecl in catchBindings)
                    {
                        if (lexDecl != catchDecl
                            && string.CompareOrdinal(lexDecl.Name, catchDecl.Name) == 0)
                        {
                            // report the error (catchvar collides with lex/const) or warning (catchvar collides with funcdecl)
                            lexDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, lexDecl is LexicalDeclaration);

                            // link the inner one to the outer one so any renaming stays in sync.
                            if (lexDecl.VariableField != null)
                            {
                                lexDecl.VariableField.OuterField = catchDecl.VariableField;
                                if (catchDecl.VariableField != null && !lexDecl.VariableField.CanCrunch)
                                {
                                    catchDecl.VariableField.CanCrunch = false;
                                }
                            }
                        }
                    }
                }

                // check to make sure there are no var-decl'd names with the same name. 
                foreach (var varDecl in node.CatchBlock.EnclosingScope.VarDeclaredNames)
                {
                    foreach (var catchDecl in catchBindings)
                    {
                        if (string.CompareOrdinal(varDecl.Name, catchDecl.Name) == 0)
                        {
                            // report the warning (catchvar collides with var)
                            // we shouldn't have to link them; the catchvar should already ghosted.
                            varDecl.Context.HandleError(JSError.DuplicateLexicalDeclaration, false);
                        }
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(UnaryExpression node)
        {
            if (node != null)
            {
                base.Visit(node);

                if (node.Operand != null && node.Operand.IsDebugOnly)
                {
                    node.IsDebugOnly = true;
                    switch (node.OperatorToken)
                    {
                        case JSToken.Void:
                            // void *anything* is the same as void 0
                            node.Operand = new ConstantWrapper(0, PrimitiveType.Number, node.Operand.Context);
                            break;

                        case JSToken.TypeOf:
                            // typeof null is "object"
                            node.Parent.ReplaceChild(node, new ConstantWrapper("object", PrimitiveType.String, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        case JSToken.Delete:
                            // delete null is true
                            node.Operand = new ConstantWrapper(true, PrimitiveType.Boolean, node.Context);
                            break;

                        case JSToken.Increment:
                        case JSToken.Decrement:
                            // ++ and -- result in a number, so just replace with 0
                            node.Parent.ReplaceChild(node, new ConstantWrapper(0, PrimitiveType.Number, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        case JSToken.LogicalNot:
                            // !null is true
                            node.Parent.ReplaceChild(node, new ConstantWrapper(true, PrimitiveType.Boolean, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        case JSToken.BitwiseNot:
                            // ~null is -1
                            node.Parent.ReplaceChild(node, new ConstantWrapper(-1, PrimitiveType.Number, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        case JSToken.Plus:
                            // +null is zero
                            node.Parent.ReplaceChild(node, new ConstantWrapper(0, PrimitiveType.Number, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        case JSToken.Minus:
                            // -null is negative zero
                            node.Parent.ReplaceChild(node, new ConstantWrapper(-0, PrimitiveType.Number, node.Context)
                                {
                                    IsDebugOnly = true
                                });
                            break;

                        default:
                            node.Operand = ClearDebugExpression(node.Operand);
                            break;
                    }
                }
                else
                {
                    // strict mode has some restrictions
                    if (node.OperatorToken == JSToken.Delete)
                    {
                        if (m_scopeStack.Peek().UseStrict)
                        {
                            // operand of a delete operator cannot be a variable name, argument name, or function name
                            // which means it can't be a lookup
                            if (node.Operand is LookupExpression)
                            {
                                node.Context.HandleError(JSError.StrictModeInvalidDelete, true);
                            }
                        }
                    }
                    else if (node.OperatorToken == JSToken.Increment || node.OperatorToken == JSToken.Decrement)
                    {
                        if (node.Operand is LookupExpression lookup)
                        {
                            if (lookup.VariableField != null && lookup.VariableField.InitializationOnly)
                            {
                                // can't increment or decrement a constant!
                                lookup.Context.HandleError(JSError.AssignmentToConstant, true);
                            }

                            // and strict mode has some restrictions we want to check now
                            if (m_scopeStack.Peek().UseStrict)
                            {
                                // the operator cannot be the eval function or arguments object.
                                // that means the operator is a lookup, and the field for that lookup
                                // is the arguments object or the predefined "eval" object.
                                if (lookup.VariableField == null
                                    || lookup.VariableField.FieldType == FieldType.UndefinedGlobal
                                    || lookup.VariableField.FieldType == FieldType.Arguments
                                    || (lookup.VariableField.FieldType == FieldType.Predefined 
                                    && string.CompareOrdinal(lookup.Name, "eval") == 0))
                                {
                                    node.Operand.Context.HandleError(JSError.StrictModeInvalidPreOrPost, true);
                                }
                            }
                        }
                    }
                    else if (node.OperatorToken == JSToken.TypeOf)
                    {
                        if (m_parser.Settings.RemoveUnneededCode
                            && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveWindowDotFromTypeOf))
                        {
                            // we want to see if the typeof operand is window.name -- which is getting the type string of                             // a potential global variable. If "name" would otherwise resolve to the global namespace (either                            // defined or undefined), then we can really get rid of the "window." part because the typeof                            // operator will work just fine if the operand is undefined (it won't throw a reference error).
                            if (node.Operand is MemberExpression member)
                            {
                                if (lookup?.VariableField != null
                                    && lookup.VariableField.FieldType == FieldType.Predefined
                                    && lookup.Name == "window")
                                {
                                    // we have window.name
                                    // now check to see if the name part of our member would resolve to something in
                                    // the global namespace.
                                    var name = member.Name;
                                    var enclosingScope = member.EnclosingScope;
                                    var existingField = enclosingScope.CanReference(name);
                                    if (existingField == null
                                        || existingField.FieldType == FieldType.Predefined
                                        || existingField.FieldType == FieldType.Global
                                        || existingField.FieldType == FieldType.UndefinedGlobal)
                                    {
                                        // replace the member with a lookup on the name.
                                        // first, detach the reference to window
                                        DetachReferencesVisitor.Apply(lookup);

                                        // (just reuse the lookup for "window" by changing the name and doing
                                        // a formal reference lookup on it (which will generate fields if needed)
                                        lookup.Name = name;
                                        lookup.VariableField = enclosingScope.FindReference(name);
                                        node.Operand = lookup;

                                        // and make sure we increment the new reference
                                        lookup.VariableField.AddReference(lookup);
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // if the operand is a numeric literal
                        if (node.Operand is ConstantWrapper constantWrapper && constantWrapper.IsNumericLiteral)
                        {
                            // get the value of the constant. We've already screened it for numeric, so
                            // we don't have to worry about catching any errors
                            double doubleValue = constantWrapper.ToNumber();

                            // if this is a unary minus...
                            if (node.OperatorToken == JSToken.Minus
                                && m_parser.Settings.IsModificationAllowed(TreeModifications.ApplyUnaryMinusToNumericLiteral))
                            {
                                // negate the value
                                constantWrapper.Value = -doubleValue;

                                // replace us with the negated constant
                                if (node.Parent.ReplaceChild(node, constantWrapper))
                                {
                                    // the context for the minus will include the number (its operand),
                                    // but the constant will just be the number. Update the context on
                                    // the constant to be a copy of the context on the operator
                                    constantWrapper.Context = node.Context.Clone();
                                }
                            }
                            else if (node.OperatorToken == JSToken.Plus
                                && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnaryPlusOnNumericLiteral))
                            {
                                // +NEG is still negative, +POS is still positive, and +0 is still 0.
                                // so just get rid of the unary operator altogether
                                if (node.Parent.ReplaceChild(node, constantWrapper))
                                {
                                    // the context for the unary will include the number (its operand),
                                    // but the constant will just be the number. Update the context on
                                    // the constant to be a copy of the context on the operator
                                    constantWrapper.Context = node.Context.Clone();
                                }
                            }
                        }
                    }
                }
            }
        }

        public override void Visit(VarDeclaration node)
        {
            if (node != null)
            {
                // first we want to weed out duplicates that don't have initializers
                // var a=1, a=2 is okay, but var a, a=2 and var a=2, a should both be just var a=2, 
                // and var a, a should just be var a
                if (m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveDuplicateVar))
                {
                    // first we want to weed out duplicates that don't have initializers
                    // var a=1, a=2 is okay, but var a, a=2 and var a=2, a should both be just var a=2, 
                    // and var a, a should just be var a
                    // only do this for simple binding identifier; leave binding patterns alone
                    int ndx = 0;
                    while (ndx < node.Count)
                    {
                        if (node[ndx].Binding is BindingIdentifier bindingIdentifier)
                        {
                            var thisName = bindingIdentifier.Name;

                            // handle differently if we have an initializer or not
                            if (node[ndx].Initializer != null)
                            {
                                // the current vardecl has an initializer, so we want to delete any other
                                // simple binding identifier vardecls of the same name in the rest of the 
                                // list with no initializer and move on to the next item afterwards
                                DeleteNoInits(node, ++ndx, thisName);
                            }
                            else
                            {
                                // this vardecl has no initializer, so we can delete it if there is ANY
                                // other vardecl with the same name (whether or not it has an initializer)
                                if (VarDeclExists(node, ndx + 1, thisName))
                                {
                                    // don't increment the index; we just deleted the current item,
                                    // so the next item just slid into this position
                                    bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);
                                    node.RemoveAt(ndx);
                                }
                                else
                                {
                                    // nope -- it's the only one. Move on to the next
                                    ++ndx;
                                }
                            }
                        }
                        else
                        {
                            ++ndx;
                        }
                    }
                }

                // recurse the analyze
                base.Visit(node);
            }
        }

        public override void Visit(VariableDeclaration node)
        {
            if (node != null)
            {
                base.Visit(node);

                if (node.Initializer != null && node.Initializer.IsDebugOnly)
                {
                    node.Initializer = ClearDebugExpression(node.Initializer);
                }

                // if this is a binding pattern and the parent is NOT a for-in loop,
                // then we MUST have an initializer as per the language syntax!
                if (node.Initializer == null 
                    && !(node.Binding is BindingIdentifier)
                    && node.Parent.IfNotNull(p => !(p.Parent is ForInStatement)))
                {
                    // binding patterns in declarations (var/const/let) must always be followed by an assignment
                    node.Binding.Context.HandleError(JSError.BindingPatternRequiresInitializer, true);
                }

                // if this is a special-case vardecl (var foo/*@cc_on=EXPR@*/), set the flag indicating
                // we encountered a @cc_on statement if we found one
                if (node.IsCCSpecialCase && m_parser.Settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryCCOnStatements))
                {
                    node.UseCCOn = !m_encounteredCCOn;
                    m_encounteredCCOn = true;
                }
            }
        }

        public override void Visit(WhileStatement node)
        {
            if (node != null)
            {
                // recurse
                base.Visit(node);

                // if the body is now empty, make it null
                if (node.Body != null && node.Body.Count == 0)
                {
                    node.Body = null;
                }

                if (node.Condition != null && node.Condition.IsDebugOnly)
                {
                    if (node.Body == null)
                    {
                        node.IsDebugOnly = true;
                    }
                    else
                    {
                        node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                    }
                }
            }
        }

        public override void Visit(WithStatement node)
        {
            if (node != null)
            {
                // throw a warning discouraging the use of this statement
                if (m_scopeStack.Peek().UseStrict)
                {
                    // with-statements not allowed in strict code at all
                    node.Context.HandleError(JSError.StrictModeNoWith, true);
                }
                else
                {
                    // not strict, but still not recommended
                    node.Context.HandleError(JSError.WithNotRecommended, false);
                }

                // hold onto the with-scope in case we need to do something with it
                var withScope = node.Body.IfNotNull(b => b.EnclosingScope);

                // recurse
                base.Visit(node);

                // we'd have to know what the object (obj) evaluates to before we
                // can figure out what to add to the scope -- not possible without actually
                // running the code. This could throw a whole bunch of 'undefined' errors.
                if (node.Body != null && node.Body.Count == 0)
                {
                    node.Body = null;
                }

                // we got rid of the block -- tidy up the no-longer-needed scope
                if (node.Body == null && withScope != null)
                {
                    // because the scope is empty, we now know it (it does nothing)
                    withScope.IsKnownAtCompileTime = true;
                }

                if (node.WithObject != null && node.WithObject.IsDebugOnly)
                {
                    if (node.Body == null)
                    {
                        node.IsDebugOnly = true;
                    }
                    else
                    {
                        node.WithObject = new ObjectLiteral(node.WithObject.Context)
                            {
                                IsDebugOnly = true
                            };
                    }
                }
            }
        }

        #endregion

        private static AstNode ClearDebugExpression(AstNode node)
        {
            if (node == null || node is ObjectLiteral || node is ConstantWrapper)
            {
                return node;
            }

            return new ObjectLiteral(node.Context)
                {
                    IsDebugOnly = true
                };
        }

        private static string GuessAtName(AstNode node)
        {
            string guess = string.Empty;
            var parent = node.Parent;

            if (parent != null)
            {
                if (parent is AstNodeList)
                {
                    // if the parent is an ASTList, then we're really interested
                    // in our parent's parent (probably a call)
                    parent = parent.Parent;
                }

                if (parent is CallExpression call && call.IsConstructor)
                {
                    // if this function expression is the object of a new, then we want the parent
                    parent = parent.Parent;
                }

                guess = parent.GetFunctionGuess(node);
            }

            return guess;
        }

        private static bool AreAssignmentsInVar(BinaryExpression binaryOp, VarDeclaration varStatement)
        {
            bool areAssignmentsInVar = false;

            if (binaryOp != null)
            {
                // we only want to pop positive for the simple assign (=). If it's any of the 
                // complex assigns (+=, -=, etc) then we don't want to combine them.
                if (binaryOp.OperatorToken == JSToken.Assign)
                {
                    // see if the left-hand side is a simple lookup
                    if (binaryOp.Operand1 is LookupExpression lookup)
                    {
                        // it is. see if that variable is in the previous var statement
                        areAssignmentsInVar = varStatement.Contains(lookup.Name);
                    }
                }
                else if (binaryOp.OperatorToken == JSToken.Comma)
                {
                    // this is a comma operator, so we will return true only if both
                    // left and right operators are assignments to vars defined in the 
                    // var statement
                    areAssignmentsInVar = AreAssignmentsInVar(binaryOp.Operand1 as BinaryExpression, varStatement)
                        && AreAssignmentsInVar(binaryOp.Operand2 as BinaryExpression, varStatement);
                }
            }

            return areAssignmentsInVar;
        }

        private static void ConvertAssignmentsToVarDecls(BinaryExpression binaryOp, Declaration declaration, JSParser parser)
        {
            // we've already checked that the tree only contains simple assignments separate by commas,
            // but just in case we'll check for null anyway
            if (binaryOp != null)
            {
                if (binaryOp.OperatorToken == JSToken.Assign)
                {
                    // we've already cleared this as a simple lookup, but run the check just to be sure
                    if (binaryOp.Operand1 is LookupExpression lookup)
                    {
                        var bindingIdentifier = new BindingIdentifier(lookup.Context)
                                {
                                    Name = lookup.Name,
                                    TerminatingContext = lookup.TerminatingContext,
                                    VariableField = lookup.VariableField
                                };
                        var varDecl = new VariableDeclaration(binaryOp.Context.Clone())
                            {
                                Binding = bindingIdentifier,
                                AssignContext = binaryOp.OperatorContext,
                                Initializer = binaryOp.Operand2,
                            };
                        lookup.VariableField.Declarations.Add(bindingIdentifier);
                        declaration.Append(varDecl);
                    }
                }
                else if (binaryOp.OperatorToken == JSToken.Comma)
                {
                    // recurse both operands
                    ConvertAssignmentsToVarDecls(binaryOp.Operand1 as BinaryExpression, declaration, parser);
                    ConvertAssignmentsToVarDecls(binaryOp.Operand2 as BinaryExpression, declaration, parser);
                }
                // shouldn't ever be anything but these two operators
            }
        }

        private static bool VarDeclExists(VarDeclaration node, int ndx, string name)
        {
            // only need to look forward from the index passed
            for (; ndx < node.Count; ++ndx)
            {
                var varDecl = node[ndx];
                foreach (var bindingIdentifier in BindingsVisitor.Bindings(varDecl))
                {
                    // string must be exact match
                    if (string.CompareOrdinal(name, bindingIdentifier.Name) == 0)
                    {
                        // there is at least one -- we can bail
                        return true;
                    }
                }
            }
            // if we got here, we didn't find any matches
            return false;
        }

        private static void DeleteNoInits(VarDeclaration node, int min, string name)
        {
            // walk backwards from the end of the list down to (and including) the minimum index
            for (int ndx = node.Count - 1; ndx >= min; --ndx)
            {
                var varDecl = node[ndx];

                // if it's a simple binding identifier, the name matches and there is no initializer...
                if (varDecl.Binding is BindingIdentifier bindingIdentifier
                    && string.CompareOrdinal(name, bindingIdentifier.Name) == 0
                    && varDecl.Initializer == null)
                {
                    // ...remove it from the list and from the field's declarations
                    node.RemoveAt(ndx);
                    bindingIdentifier.VariableField.Declarations.Remove(bindingIdentifier);
                }
            }
        }

        private static UnaryExpression CreateVoidNode(SourceContext context)
        {
            return new UnaryExpression(context.FlattenToStart())
                {
                    Operand = new ConstantWrapper(0.0, PrimitiveType.Number, context),
                    OperatorToken = JSToken.Void
                };
        }

        private static void ValidateIdentifier(bool isStrict, string identifier, SourceContext context, JSError error)
        {
            // check the name of the variable for reserved words that aren't allowed
            if (JSScanner.IsKeyword(identifier, isStrict))
            {
                context.HandleError(JSError.KeywordUsedAsIdentifier, true);
            }
            else if (isStrict
                && (string.CompareOrdinal(identifier, "eval") == 0
                || string.CompareOrdinal(identifier, "arguments") == 0))
            {
                // strict mode cannot declare variables named "eval" or "arguments"
                context.HandleError(error, true);
            }
        }

        private static bool IsInsideLoop(AstNode node, bool orSwitch)
        {
            // assume we are not
            var insideLoop = false;

            // loop until we get to the top or we get to a function object,
            // which is an entirely different scope.
            while (node != null && !(node is FunctionObject))
            {
                // while, do-while, and for/for-in are loops.
                // break can also appear in switch-statements, so check that too if the appropriate flag is passed.
                if (node is WhileStatement
                    || node is DoWhileStatement
                    || node is ForInStatement
                    || node is ForStatement
                    || (orSwitch && node is SwitchCase))
                {
                    // we are in a loop (or maybe a switch)
                    return true;
                }

                // go up the tree
                node = node.Parent;
            }

            // if we get here, we're not in a loop
            return insideLoop;
        }

        private static bool IsInsideLabel(AstNode node, string label)
        {
            // assume we are not
            var insideLabel = false;

            // go up until we get to the top or we get to a function object
            while (node != null && !(node is FunctionObject))
            {
                if (node is LabeledStatement && string.Compare(((LabeledStatement)node).Label, label) == 0)
                {
                    // we have a matching label
                    return true;
                }

                // go up the tree
                node = node.Parent;
            }

            // if we get here, we're not in a nested label
            return insideLabel;
        }

        private static AstNode ReplaceCultureValue(ConstantWrapper node)
        {
            // get the name of the token.
            var tokenName = node.Value.ToString().Trim('%');
            var path = tokenName.Split('.');
            if (path.Length > 0 && path[0].Equals("CurrentCulture", StringComparison.Ordinal))
            {
                object currentObject = CultureInfo.CurrentCulture;
                for(var ndx = 1; ndx < path.Length; ++ndx)
                {
                    var objectType = currentObject.GetType();
                    int index;
                    if (objectType.IsArray && int.TryParse(path[ndx], out index))
                    {
                        // integer index into an array
                        try
                        {
                            var getMethod = objectType.GetMethod("Get", new[] { typeof(int) });
                            if (getMethod != null)
                            {
                                currentObject = getMethod.Invoke(currentObject, new object[] { index });
                                continue;
                            }
                        }
                        catch(AmbiguousMatchException)
                        {
                            // eat this exception
                        }
                    }
                    else
                    {
                        // not an integer array index
                        try
                        {
                            var propertyInfo = objectType.GetProperty(path[ndx]);
                            if (propertyInfo != null)
                            {
                                currentObject = propertyInfo.GetValue(currentObject, null);
                                continue;
                            }
                        }
                        catch (AmbiguousMatchException)
                        {
                            // eat this exception
                        }
                    }

                    // if we get here, never mind
                    currentObject = null;
                    break;
                }

                if (currentObject != null)
                {
                    if (node.PrimitiveType == PrimitiveType.String)
                    {
                        // just make the value of the string be the string representation
                        // of the current object
                        node.Value = currentObject.ToString();
                    }
                    else 
                    {
                        // create an appropriate node and replace the token node with it
                        var newNode = CreateNodeFromObject(node.Context, currentObject);
                        node.Parent.ReplaceChild(node, newNode);
                        return newNode;
                    }
                }
            }

            return node;
        }

        private static AstNode CreateNodeFromObject(SourceContext context, object item)
        {
            if (item == null)
            {
                return new ConstantWrapper(null, PrimitiveType.Null, context);
            }
            
            if (item is String)
            {
                // create a string literal
                return  new ConstantWrapper(item, PrimitiveType.String, context);
            }
            
            if (item is Boolean)
            {
                // create a boolean literal
                return new ConstantWrapper(item, PrimitiveType.Boolean, context);
            }
            
            if (item is Int16
                || item is UInt16
                || item is Int32
                || item is UInt32
                || item is Int64
                || item is UInt64
                || item is Single
                || item is Double)
            {
                // create a numeric literal, forcing the number to double
                return new ConstantWrapper(Convert.ToDouble(item, CultureInfo.InvariantCulture), PrimitiveType.Number, context);
            }

            if (item is DateTime dateTime)
            {
                return new ConstantWrapper(dateTime.ToString("s", CultureInfo.InvariantCulture), PrimitiveType.String, context);
            }

            if (item.GetType().GetTypeInfo().IsValueType)
            {
                return new ConstantWrapper(item.ToString(), PrimitiveType.String, context);
            }

            if (item is Array arrayObject)
            {
                // create an array literal from the array
                var arrayLiteral = new ArrayLiteral(context)
                    {
                        Elements = new AstNodeList(context)
                    };
                foreach (var element in arrayObject)
                {
                    arrayLiteral.Elements.Append(CreateNodeFromObject(context, element));
                }

                return arrayLiteral;
            }

            // create an object literal from all the public unambiguous properties on the item object
            var objectLiteral = new ObjectLiteral(context)
                {
                    Properties = new AstNodeList(context)
                };
            var properties = item.GetType().GetTypeInfo().GetDeclaredProperties();
            foreach(var property in properties)
            {
                try
                {
                    var propertyValue = property.GetValue(item, null);
                    if (propertyValue != item)
                    {
                        var valueNode = CreateNodeFromObject(context, propertyValue);
                        objectLiteral.Properties.Append(new ObjectLiteralProperty(context)
                        {
                            Name = new ObjectLiteralField(property.Name, PrimitiveType.String, context),
                            Value = valueNode,
                        });
                    }
                }
                catch(AmbiguousMatchException)
                {
                    // ignore this property
                }
            }

            return objectLiteral;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(698,29): error CS0103: The name 'ifNode' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(699,32): error CS0103: The name 'ifNode' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(700,32): error CS0103: The name 'ifNode' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(703,33): error CS0103: The name 'ifNode' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(703,50): error CS0103: The name 'ifNode' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(707,59): error CS0103: The name 'ifNode' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(710,33): error CS0103: The name 'ifNode' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(763,30): error CS0103: The name 'ndx' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(893,66): error CS0136: A local or parameter named 'previousVar' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(906,66): error CS0136: A local or parameter named 'previousVar' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(1200,29): error CS0841: Cannot use local variable 'unaryOperator' before it is declared,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(1202,80): error CS0136: A local or parameter named 'unaryOperator' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(1236,29): error CS0841: Cannot use local variable 'unaryOperator' before it is declared,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(1237,80): error CS0136: A local or parameter named 'unaryOperator' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(1283,58): error CS0128: A local variable or function named 'ifNode' is already defined in this scope,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(1516,67): error CS0165: Use of unassigned local variable 'ifNode',D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(1817,21): error CS0103: The name 'member' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3551,41): error CS0103: The name 'lastBreak' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3552,43): error CS0103: The name 'lastBreak' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3552,70): error CS0103: The name 'lastBreak' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3678,33): error CS0103: The name 'switchCase' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3678,76): error CS0128: A local variable or function named 'lastBreak' is already defined in this scope,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3891,37): error CS0103: The name 'lookup' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3892,40): error CS0103: The name 'lookup' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3893,40): error CS0103: The name 'lookup' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3908,71): error CS0103: The name 'lookup' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3912,41): error CS0103: The name 'lookup' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3913,41): error CS0103: The name 'lookup' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3914,56): error CS0103: The name 'lookup' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3917,41): error CS0103: The name 'lookup' does not exist in the current context,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\AnalyzeNodeVisitor.cs(3917,75): error CS0103: The name 'lookup' does not exist in the current context
######################################################################


######################################################################
Nr: 20 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\EvaluateLiteralVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;

namespace NUglify.JavaScript.Visitors
{
    internal class EvaluateLiteralVisitor : TreeVisitor
    {
        private JSParser m_parser;

        public EvaluateLiteralVisitor(JSParser parser) 
        {
            m_parser = parser;
        }

        #region BinaryExpression helper methods

        /// <summary>
        /// If the new literal is a string literal, then we need to check to see if our
        /// parent is a CallNode. If it is, and if the string literal can be an identifier,
        /// we'll replace it with a Member-Dot operation.
        /// </summary>
        /// <param name="newLiteral">newLiteral we intend to replace this binaryop node with</param>
        /// <returns>true if we replaced the parent callnode with a member-dot operation</returns>
        private bool ReplaceMemberBracketWithDot(BinaryExpression node, ConstantWrapper newLiteral)
        {
            if (newLiteral.IsStringLiteral)
            {
                // see if this newly-combined string is the sole argument to a 
                // call-brackets node. If it is and the combined string is a valid
                // identifier (and not a keyword), then we can replace the call
                // with a member operator.
                // remember that the parent of the argument won't be the call node -- it
                // will be the ast node list representing the arguments, whose parent will
                // be the node list. 
                CallExpression parentCall = (node.Parent is AstNodeList ? node.Parent.Parent as CallExpression : null);
                if (parentCall != null && parentCall.InBrackets)
                {
                    // get the newly-combined string
                    string combinedString = newLiteral.ToString();

                    // see if this new string is the target of a replacement operation
                    string newName;
                    if (m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.PropertyRenaming)
                        && !string.IsNullOrEmpty(newName = m_parser.Settings.GetNewName(combinedString)))
                    {
                        // yes, it is. Now see if the new name is safe to be converted to a dot-operation.
                        if (m_parser.Settings.IsModificationAllowed(TreeModifications.BracketMemberToDotMember)
                            && JSScanner.IsSafeIdentifier(newName)
                            && !JSScanner.IsKeyword(newName, (parentCall.EnclosingScope ?? m_parser.GlobalScope).UseStrict))
                        {
                            // we want to replace the call with operator with a new member dot operation, and
                            // since we won't be analyzing it (we're past the analyze phase, we're going to need
                            // to use the new string value
                            MemberExpression replacementMember = new MemberExpression(parentCall.Context)
                                {
                                    Root = parentCall.Function,
                                    Name = newName,
                                    NameContext = parentCall.Arguments[0].Context
                                };
                            parentCall.Parent.ReplaceChild(parentCall, replacementMember);
                            return true;
                        }
                        else
                        {
                            // nope, can't be changed to a dot-operator for whatever reason.
                            // just replace the value on this new literal. The old operation will
                            // get replaced with this new literal
                            newLiteral.Value = newName;

                            // and make sure it's type is string
                            newLiteral.PrimitiveType = PrimitiveType.String;
                        }
                    }
                    else if (m_parser.Settings.IsModificationAllowed(TreeModifications.BracketMemberToDotMember))
                    {
                        // our parent is a call-bracket -- now we just need to see if the newly-combined
                        // string can be an identifier
                        if (JSScanner.IsSafeIdentifier(combinedString) 
                            && !JSScanner.IsKeyword(combinedString, (parentCall.EnclosingScope ?? m_parser.GlobalScope).UseStrict))
                        {
                            // yes -- replace the parent call with a new member node using the newly-combined string
                            MemberExpression replacementMember = new MemberExpression(parentCall.Context)
                                {
                                    Root = parentCall.Function,
                                    Name = combinedString,
                                    NameContext = parentCall.Arguments[0].Context
                                };
                            parentCall.Parent.ReplaceChild(parentCall, replacementMember);
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// replace the node with a literal. If the node was wrapped in a grouping operator
        /// before (parentheses around it), then we can get rid of the parentheses too, since
        /// we are replacing the node with a single literal entity.
        /// </summary>
        /// <param name="node">node to replace</param>
        /// <param name="newLiteral">literal to replace the node with</param>
        private static void ReplaceNodeWithLiteral(AstNode node, ConstantWrapper newLiteral)
        {
            var grouping = node.Parent as GroupingOperator;
            if (grouping != null)
            {
                // because we are replacing the operator with a literal, the parentheses
                // the grouped this operator are now superfluous. Replace them, too
                grouping.Parent.ReplaceChild(grouping, newLiteral);
            }
            else
            {
                // just replace the node with the literal
                node.Parent.ReplaceChild(node, newLiteral);
            }
        }

        private static void ReplaceNodeCheckParens(AstNode oldNode, AstNode newNode)
        {
            var grouping = oldNode.Parent as GroupingOperator;
            if (grouping != null)
            {
                if (newNode != null)
                {
                    var targetPrecedence = grouping.Parent.Precedence;
                    var conditional = grouping.Parent as Conditional;
                    if (conditional != null)
                    {
                        // the conditional is weird in that the different parts need to be
                        // compared against different precedences, not the precedence of the
                        // conditional itself. The condition should be compared to logical-or,
                        // and the true/false expressions against assignment.
                        targetPrecedence = conditional.Condition == grouping
                            ? OperatorPrecedence.LogicalOr
                            : OperatorPrecedence.Assignment;
                    }

                    if (newNode.Precedence >= targetPrecedence)
                    {
                        // don't need the parens anymore, so replace the grouping operator
                        // with the new node, thereby eliminating the parens
                        grouping.Parent.ReplaceChild(grouping, newNode);
                    }
                    else
                    {
                        // still need the parens; just replace the node with the literal
                        oldNode.Parent.ReplaceChild(oldNode, newNode);
                    }
                }
                else
                {
                    // eliminate the parens
                    grouping.Parent.ReplaceChild(grouping, null);
                }
            }
            else
            {
                // just replace the node with the literal
                oldNode.Parent.ReplaceChild(oldNode, newNode);
            }
        }

        /// <summary>
        /// Both the operands of this operator are constants. See if we can evaluate them
        /// </summary>
        /// <param name="left">left-side operand</param>
        /// <param name="right">right-side operand</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void EvalThisOperator(BinaryExpression node, ConstantWrapper left, ConstantWrapper right)
        {
            // we can evaluate these operators if we know both operands are literal
            // number, boolean, string or null
            ConstantWrapper newLiteral = null;
            switch (node.OperatorToken)
            {
                case JSToken.Multiply:
                    newLiteral = Multiply(left, right);
                    break;

                case JSToken.Divide:
                    newLiteral = Divide(left, right);
                    if (newLiteral != null && NodeLength(newLiteral) > NodeLength(node))
                    {
                        // the result is bigger than the expression.
                        // eg: 1/3 is smaller than .333333333333333
                        // never mind.
                        newLiteral = null;
                    }
                    break;

                case JSToken.Modulo:
                    newLiteral = Modulo(left, right);
                    if (newLiteral != null && NodeLength(newLiteral) > NodeLength(node))
                    {
                        // the result is bigger than the expression.
                        // eg: 46.5%6.3 is smaller than 2.4000000000000012
                        // never mind.
                        newLiteral = null;
                    }
                    break;

                case JSToken.Plus:
                    newLiteral = Plus(left, right);
                    break;

                case JSToken.Minus:
                    newLiteral = Minus(left, right);
                    break;

                case JSToken.LeftShift:
                    newLiteral = LeftShift(left, right);
                    break;

                case JSToken.RightShift:
                    newLiteral = RightShift(left, right);
                    break;

                case JSToken.UnsignedRightShift:
                    newLiteral = UnsignedRightShift(left, right);
                    break;

                case JSToken.LessThan:
                    newLiteral = LessThan(left, right);
                    break;

                case JSToken.LessThanEqual:
                    newLiteral = LessThanOrEqual(left, right);
                    break;

                case JSToken.GreaterThan:
                    newLiteral = GreaterThan(left, right);
                    break;

                case JSToken.GreaterThanEqual:
                    newLiteral = GreaterThanOrEqual(left, right);
                    break;

                case JSToken.Equal:
                    newLiteral = Equal(left, right);
                    break;

                case JSToken.NotEqual:
                    newLiteral = NotEqual(left, right);
                    break;

                case JSToken.StrictEqual:
                    newLiteral = StrictEqual(left, right);
                    break;

                case JSToken.StrictNotEqual:
                    newLiteral = StrictNotEqual(left, right);
                    break;

                case JSToken.BitwiseAnd:
                    newLiteral = BitwiseAnd(left, right);
                    break;

                case JSToken.BitwiseOr:
                    newLiteral = BitwiseOr(left, right);
                    break;

                case JSToken.BitwiseXor:
                    newLiteral = BitwiseXor(left, right);
                    break;

                case JSToken.LogicalAnd:
                    newLiteral = LogicalAnd(left, right);
                    break;

                case JSToken.LogicalOr:
                    newLiteral = LogicalOr(left, right);
                    break;

                default:
                    // an operator we don't want to evaluate
                    break;
            }

            // if we can combine them...
            if (newLiteral != null)
            {
                // first we want to check if the new combination is a string literal, and if so, whether 
                // it's now the sole parameter of a member-bracket call operator. If so, instead of replacing our
                // binary operation with the new constant, we'll replace the entire call with a member-dot
                // expression
                if (!ReplaceMemberBracketWithDot(node, newLiteral))
                {
                    ReplaceNodeWithLiteral(node, newLiteral);
                }
            }
        }

        /// <summary>
        /// We have determined that our left-hand operand is another binary operator, and its
        /// right-hand operand is a constant that can be combined with our right-hand operand.
        /// Now we want to set the right-hand operand of that other operator to the newly-
        /// combined constant value, and then rotate it up -- replace our binary operator
        /// with this newly-modified binary operator, and then attempt to re-evaluate it.
        /// </summary>
        /// <param name="binaryOp">the binary operator that is our left-hand operand</param>
        /// <param name="newLiteral">the newly-combined literal</param>
        private void RotateFromLeft(BinaryExpression node, BinaryExpression binaryOp, ConstantWrapper newLiteral)
        {
            // replace our node with the binary operator
            binaryOp.Operand2 = newLiteral;
            node.Parent.ReplaceChild(node, binaryOp);

            // and just for good measure.. revisit the node that's taking our place, since
            // we just changed a constant value. Assuming the other operand is a constant, too.
            ConstantWrapper otherConstant = binaryOp.Operand1 as ConstantWrapper;
            if (otherConstant != null)
            {
                EvalThisOperator(binaryOp, otherConstant, newLiteral);
            }
        }

        /// <summary>
        /// We have determined that our right-hand operand is another binary operator, and its
        /// left-hand operand is a constant that can be combined with our left-hand operand.
        /// Now we want to set the left-hand operand of that other operator to the newly-
        /// combined constant value, and then rotate it up -- replace our binary operator
        /// with this newly-modified binary operator, and then attempt to re-evaluate it.
        /// </summary>
        /// <param name="binaryOp">the binary operator that is our right-hand operand</param>
        /// <param name="newLiteral">the newly-combined literal</param>
        private void RotateFromRight(BinaryExpression node, BinaryExpression binaryOp, ConstantWrapper newLiteral)
        {
            // replace our node with the binary operator
            binaryOp.Operand1 = newLiteral;
            node.Parent.ReplaceChild(node, binaryOp);

            // and just for good measure.. revisit the node that's taking our place, since
            // we just changed a constant value. Assuming the other operand is a constant, too.
            ConstantWrapper otherConstant = binaryOp.Operand2 as ConstantWrapper;
            if (otherConstant != null)
            {
                EvalThisOperator(binaryOp, newLiteral, otherConstant);
            }
        }

        /// <summary>
        /// Return true is not an overflow or underflow, for multiplication operations
        /// </summary>
        /// <param name="left">left operand</param>
        /// <param name="right">right operand</param>
        /// <param name="result">result</param>
        /// <returns>true if result not overflow or underflow; false if it is</returns>
        private static bool NoMultiplicativeOverOrUnderFlow(ConstantWrapper left, ConstantWrapper right, ConstantWrapper result)
        {
            // check for overflow
            bool okayToProceed = !result.IsInfinity;

            // if we still might be good, check for possible underflow
            if (okayToProceed)
            {
                // if the result is zero, we might have an underflow. But if one of the operands
                // was zero, then it's okay.
                // Inverse: if neither operand is zero, then a zero result is not okay
                okayToProceed = !result.IsZero || (left.IsZero || right.IsZero);
            }
            return okayToProceed;
        }

        /// <summary>
        /// Return true if the result isn't an overflow condition
        /// </summary>
        /// <param name="result">result constant</param>
        /// <returns>true is not an overflow; false if it is</returns>
        private static bool NoOverflow(ConstantWrapper result)
        {
            return !result.IsInfinity;
        }

        /// <summary>
        /// Evaluate: (OTHER [op] CONST) [op] CONST
        /// </summary>
        /// <param name="thisConstant">second constant</param>
        /// <param name="otherConstant">first constant</param>
        /// <param name="leftExpression">first operator</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void EvalToTheLeft(BinaryExpression node, ConstantWrapper thisConstant, ConstantWrapper otherConstant, BinaryExpression leftExpression)
        {
            if (leftExpression.OperatorToken == JSToken.Plus && node.OperatorToken == JSToken.Plus)
            {
                // plus-plus
                // the other operation goes first, so if the other constant is a string, then we know that
                // operation will do a string concatenation, which will force our operation to be a string
                // concatenation. If the other constant is not a string, then we won't know until runtime and
                // we can't combine them.
                if (otherConstant.IsStringLiteral)
                {
                    // the other constant is a string -- so we can do the string concat and combine them
                    ConstantWrapper newLiteral = StringConcat(otherConstant, thisConstant);
                    if (newLiteral != null)
                    {
                        RotateFromLeft(node, leftExpression, newLiteral);
                    }
                }
            }
            else if (leftExpression.OperatorToken == JSToken.Minus)
            {
                if (node.OperatorToken == JSToken.Plus)
                {
                    // minus-plus
                    // the minus operator goes first and will always convert to number.
                    // if our constant is not a string, then it will be a numeric addition and we can combine them.
                    // if our constant is a string, then we'll end up doing a string concat, so we can't combine
                    if (!thisConstant.IsStringLiteral)
                    {
                        // two numeric operators. a-n1+n2 is the same as a-(n1-n2)
                        ConstantWrapper newLiteral = Minus(otherConstant, thisConstant);
                        if (newLiteral != null && NoOverflow(newLiteral))
                        {
                            // a-(-n) is numerically equivalent as a+n -- and takes fewer characters to represent.
                            // BUT we can't do that because that might change a numeric operation (the original minus)
                            // to a string concatenation if the unknown operand turns out to be a string!

                            RotateFromLeft(node, leftExpression, newLiteral);
                        }
                        else
                        {
                            // if the left-left is a constant, then we can try combining with it
                            ConstantWrapper leftLeft = leftExpression.Operand1 as ConstantWrapper;
                            if (leftLeft != null)
                            {
                                EvalFarToTheLeft(node, thisConstant, leftLeft, leftExpression);
                            }
                        }
                    }
                }
                else if (node.OperatorToken == JSToken.Minus)
                {
                    // minus-minus. Both operations are numeric.
                    // (a-n1)-n2 => a-(n1+n2), so we can add the two constants and subtract from 
                    // the left-hand non-constant. 
                    ConstantWrapper newLiteral = NumericAddition(otherConstant, thisConstant);
                    if (newLiteral != null && NoOverflow(newLiteral))
                    {
                        // make it the new right-hand literal for the left-hand operator
                        // and make the left-hand operator replace our operator
                        RotateFromLeft(node, leftExpression, newLiteral);
                    }
                    else
                    {
                        // if the left-left is a constant, then we can try combining with it
                        ConstantWrapper leftLeft = leftExpression.Operand1 as ConstantWrapper;
                        if (leftLeft != null)
                        {
                            EvalFarToTheLeft(node, thisConstant, leftLeft, leftExpression);
                        }
                    }
                }
            }
            else if (leftExpression.OperatorToken == node.OperatorToken
                && (node.OperatorToken == JSToken.Multiply || node.OperatorToken == JSToken.Divide))
            {
                // either multiply-multiply or divide-divide
                // either way, we use the other operand and the product of the two constants.
                // if the product blows up to an infinte value, then don't combine them because that
                // could change the way the program goes at runtime, depending on the unknown value.
                ConstantWrapper newLiteral = Multiply(otherConstant, thisConstant);
                if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, newLiteral))
                {
                    RotateFromLeft(node, leftExpression, newLiteral);
                }
            }
            else if ((leftExpression.OperatorToken == JSToken.Multiply && node.OperatorToken == JSToken.Divide)
                || (leftExpression.OperatorToken == JSToken.Divide && node.OperatorToken == JSToken.Multiply))
            {
                if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
                {
                    // get the two division operators
                    ConstantWrapper otherOverThis = Divide(otherConstant, thisConstant);
                    ConstantWrapper thisOverOther = Divide(thisConstant, otherConstant);

                    // get the lengths
                    int otherOverThisLength = otherOverThis != null ? NodeLength(otherOverThis) : int.MaxValue;
                    int thisOverOtherLength = thisOverOther != null ? NodeLength(thisOverOther) : int.MaxValue;

                    // we'll want to use whichever one is shorter, and whichever one does NOT involve an overflow 
                    // or possible underflow
                    if (otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, otherOverThis)
                        && (thisOverOther == null || otherOverThisLength < thisOverOtherLength))
                    {
                        // but only if it's smaller than the original expression
                        if (otherOverThisLength <= NodeLength(otherConstant) + NodeLength(thisConstant) + 1)
                        {
                            // same operator
                            RotateFromLeft(node, leftExpression, otherOverThis);
                        }
                    }
                    else if (thisOverOther != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, thisOverOther))
                    {
                        // but only if it's smaller than the original expression
                        if (thisOverOtherLength <= NodeLength(otherConstant) + NodeLength(thisConstant) + 1)
                        {
                            // opposite operator
                            leftExpression.OperatorToken = leftExpression.OperatorToken == JSToken.Multiply ? JSToken.Divide : JSToken.Multiply;
                            RotateFromLeft(node, leftExpression, thisOverOther);
                        }
                    }
                }
            }
            else if (node.OperatorToken == leftExpression.OperatorToken
                && (node.OperatorToken == JSToken.BitwiseAnd || node.OperatorToken == JSToken.BitwiseOr || node.OperatorToken == JSToken.BitwiseXor))
            {
                // identical bitwise operators can be combined
                ConstantWrapper newLiteral = null;
                switch (node.OperatorToken)
                {
                    case JSToken.BitwiseAnd:
                        newLiteral = BitwiseAnd(otherConstant, thisConstant);
                        break;

                    case JSToken.BitwiseOr:
                        newLiteral = BitwiseOr(otherConstant, thisConstant);
                        break;

                    case JSToken.BitwiseXor:
                        newLiteral = BitwiseXor(otherConstant, thisConstant);
                        break;
                }
                if (newLiteral != null)
                {
                    RotateFromLeft(node, leftExpression, newLiteral);
                }
            }
        }

        /// <summary>
        /// Evaluate: (CONST [op] OTHER) [op] CONST
        /// </summary>
        /// <param name="thisConstant">second constant</param>
        /// <param name="otherConstant">first constant</param>
        /// <param name="leftExpression">first operator</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void EvalFarToTheLeft(BinaryExpression node, ConstantWrapper thisConstant, ConstantWrapper otherConstant, BinaryExpression leftExpression)
        {
            if (leftExpression.OperatorToken == JSToken.Minus)
            {
                if (node.OperatorToken == JSToken.Plus)
                {
                    // minus-plus
                    // the minus will be a numeric operator, but if this constant is a string, it will be a
                    // string concatenation and we can't combine it.
                    if (thisConstant.PrimitiveType != PrimitiveType.String && thisConstant.PrimitiveType != PrimitiveType.Other)
                    {
                        ConstantWrapper newLiteral = NumericAddition(otherConstant, thisConstant);
                        if (newLiteral != null && NoOverflow(newLiteral))
                        {
                            RotateFromRight(node, leftExpression, newLiteral);
                        }
                    }
                }
                else if (node.OperatorToken == JSToken.Minus)
                {
                    // minus-minus
                    ConstantWrapper newLiteral = Minus(otherConstant, thisConstant);
                    if (newLiteral != null && NoOverflow(newLiteral))
                    {
                        RotateFromRight(node, leftExpression, newLiteral);
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Multiply)
            {
                if (leftExpression.OperatorToken == JSToken.Multiply || leftExpression.OperatorToken == JSToken.Divide)
                {
                    ConstantWrapper newLiteral = Multiply(otherConstant, thisConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, newLiteral))
                    {
                        RotateFromRight(node, leftExpression, newLiteral);
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Divide)
            {
                if (leftExpression.OperatorToken == JSToken.Divide)
                {
                    // divide-divide
                    ConstantWrapper newLiteral = Divide(otherConstant, thisConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, newLiteral)
                        && NodeLength(newLiteral) <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                    {
                        RotateFromRight(node, leftExpression, newLiteral);
                    }
                }
                else if (leftExpression.OperatorToken == JSToken.Multiply)
                {
                    // mult-divide
                    ConstantWrapper otherOverThis = Divide(otherConstant, thisConstant);
                    ConstantWrapper thisOverOther = Divide(thisConstant, otherConstant);

                    int otherOverThisLength = otherOverThis != null ? NodeLength(otherOverThis) : int.MaxValue;
                    int thisOverOtherLength = thisOverOther != null ? NodeLength(thisOverOther) : int.MaxValue;

                    if (otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, otherOverThis)
                        && (thisOverOther == null || otherOverThisLength < thisOverOtherLength))
                    {
                        if (otherOverThisLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            RotateFromRight(node, leftExpression, otherOverThis);
                        }
                    }
                    else if (thisOverOther != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, thisOverOther))
                    {
                        if (thisOverOtherLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            // swap the operands
                            leftExpression.SwapOperands();

                            // operator is the opposite
                            leftExpression.OperatorToken = JSToken.Divide;
                            RotateFromLeft(node, leftExpression, thisOverOther);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Evaluate: CONST [op] (CONST [op] OTHER)
        /// </summary>
        /// <param name="thisConstant">first constant</param>
        /// <param name="otherConstant">second constant</param>
        /// <param name="leftOperator">second operator</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void EvalToTheRight(BinaryExpression node, ConstantWrapper thisConstant, ConstantWrapper otherConstant, BinaryExpression rightExpression)
        {
            if (node.OperatorToken == JSToken.Plus)
            {
                if (rightExpression.OperatorToken == JSToken.Plus && otherConstant.IsStringLiteral)
                {
                    // plus-plus, and the other constant is a string. So the right operator will be a string-concat
                    // that generates a string. And since this is a plus-operator, then this operator will be a string-
                    // concat as well. So we can just combine the strings now and replace our node with the right-hand 
                    // operation
                    ConstantWrapper newLiteral = StringConcat(thisConstant, otherConstant);
                    if (newLiteral != null)
                    {
                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                }
                else if (rightExpression.OperatorToken == JSToken.Minus && !thisConstant.IsStringLiteral)
                {
                    // plus-minus. Now, the minus operation happens first, and it will perform a numeric
                    // operation. The plus is NOT string, so that means it will also be a numeric operation
                    // and we can combine the operators numericly. 
                    ConstantWrapper newLiteral = NumericAddition(thisConstant, otherConstant);
                    if (newLiteral != null && NoOverflow(newLiteral))
                    {
                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                    else
                    {
                        ConstantWrapper rightRight = rightExpression.Operand2 as ConstantWrapper;
                        if (rightRight != null)
                        {
                            EvalFarToTheRight(node, thisConstant, rightRight, rightExpression);
                        }
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Minus && rightExpression.OperatorToken == JSToken.Minus)
            {
                // minus-minus
                // both operations are numeric, so we can combine the constant operands. However, we 
                // can't combine them into a plus, so make sure we do the minus in the opposite direction
                ConstantWrapper newLiteral = Minus(otherConstant, thisConstant);
                if (newLiteral != null && NoOverflow(newLiteral))
                {
                    rightExpression.SwapOperands();
                    RotateFromLeft(node, rightExpression, newLiteral);
                }
                else
                {
                    ConstantWrapper rightRight = rightExpression.Operand2 as ConstantWrapper;
                    if (rightRight != null)
                    {
                        EvalFarToTheRight(node, thisConstant, rightRight, rightExpression);
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Multiply
                && (rightExpression.OperatorToken == JSToken.Multiply || rightExpression.OperatorToken == JSToken.Divide))
            {
                // multiply-divide or multiply-multiply
                // multiply the operands and use the right-hand operator
                ConstantWrapper newLiteral = Multiply(thisConstant, otherConstant);
                if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, newLiteral))
                {
                    RotateFromRight(node, rightExpression, newLiteral);
                }
            }
            else if (node.OperatorToken == JSToken.Divide)
            {
                if (rightExpression.OperatorToken == JSToken.Multiply)
                {
                    // divide-multiply
                    ConstantWrapper newLiteral = Divide(thisConstant, otherConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, newLiteral)
                        && NodeLength(newLiteral) < NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                    {
                        // flip the operator: multiply becomes divide; devide becomes multiply
                        rightExpression.OperatorToken = JSToken.Divide;

                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                }
                else if (rightExpression.OperatorToken == JSToken.Divide)
                {
                    // divide-divide
                    // get constants for left/right and for right/left
                    ConstantWrapper leftOverRight = Divide(thisConstant, otherConstant);
                    ConstantWrapper rightOverLeft = Divide(otherConstant, thisConstant);

                    // get the lengths of the resulting code
                    int leftOverRightLength = leftOverRight != null ? NodeLength(leftOverRight) : int.MaxValue;
                    int rightOverLeftLength = rightOverLeft != null ? NodeLength(rightOverLeft) : int.MaxValue;

                    // try whichever is smaller
                    if (leftOverRight != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, leftOverRight)
                        && (rightOverLeft == null || leftOverRightLength < rightOverLeftLength))
                    {
                        // use left-over-right. 
                        // but only if the resulting value is smaller than the original expression
                        if (leftOverRightLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            // We don't need to swap the operands, but we do need to switch the operator
                            rightExpression.OperatorToken = JSToken.Multiply;
                            RotateFromRight(node, rightExpression, leftOverRight);
                        }
                    }
                    else if (rightOverLeft != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, rightOverLeft))
                    {
                        // but only if the resulting value is smaller than the original expression
                        if (rightOverLeftLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            // use right-over-left. Keep the operator, but swap the operands
                            rightExpression.SwapOperands();
                            RotateFromLeft(node, rightExpression, rightOverLeft);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Eval the two constants: CONST [op] (OTHER [op] CONST)
        /// </summary>
        /// <param name="thisConstant">first constant</param>
        /// <param name="otherConstant">second constant</param>
        /// <param name="rightExpression">second operator</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void EvalFarToTheRight(BinaryExpression node, ConstantWrapper thisConstant, ConstantWrapper otherConstant, BinaryExpression rightExpression)
        {
            if (rightExpression.OperatorToken == JSToken.Minus)
            {
                if (node.OperatorToken == JSToken.Plus)
                {
                    // plus-minus
                    // our constant cannot be a string, though
                    if (!thisConstant.IsStringLiteral)
                    {
                        ConstantWrapper newLiteral = Minus(otherConstant, thisConstant);
                        if (newLiteral != null && NoOverflow(newLiteral))
                        {
                            RotateFromLeft(node, rightExpression, newLiteral);
                        }
                    }
                }
                else if (node.OperatorToken == JSToken.Minus)
                {
                    // minus-minus
                    ConstantWrapper newLiteral = NumericAddition(thisConstant, otherConstant);
                    if (newLiteral != null && NoOverflow(newLiteral))
                    {
                        // but we need to swap the left and right operands first
                        rightExpression.SwapOperands();

                        // then rotate the node up after replacing old with new
                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Multiply)
            {
                if (rightExpression.OperatorToken == JSToken.Multiply)
                {
                    // mult-mult
                    ConstantWrapper newLiteral = Multiply(thisConstant, otherConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, newLiteral))
                    {
                        RotateFromLeft(node, rightExpression, newLiteral);
                    }
                }
                else if (rightExpression.OperatorToken == JSToken.Divide)
                {
                    // mult-divide
                    ConstantWrapper otherOverThis = Divide(otherConstant, thisConstant);
                    ConstantWrapper thisOverOther = Divide(thisConstant, otherConstant);

                    int otherOverThisLength = otherOverThis != null ? NodeLength(otherOverThis) : int.MaxValue;
                    int thisOverOtherLength = thisOverOther != null ? NodeLength(thisOverOther) : int.MaxValue;

                    if (otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, otherOverThis)
                        && (thisOverOther == null || otherOverThisLength < thisOverOtherLength))
                    {
                        if (otherOverThisLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            // swap the operands, but keep the operator
                            RotateFromLeft(node, rightExpression, otherOverThis);
                        }
                    }
                    else if (thisOverOther != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, thisOverOther))
                    {
                        if (thisOverOtherLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            // swap the operands and opposite operator
                            rightExpression.SwapOperands();
                            rightExpression.OperatorToken = JSToken.Multiply;
                            RotateFromRight(node, rightExpression, thisOverOther);
                        }
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Divide)
            {
                if (rightExpression.OperatorToken == JSToken.Multiply)
                {
                    // divide-mult
                    ConstantWrapper newLiteral = Divide(thisConstant, otherConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, newLiteral)
                        && NodeLength(newLiteral) <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                    {
                        // swap the operands
                        rightExpression.SwapOperands();

                        // change the operator
                        rightExpression.OperatorToken = JSToken.Divide;
                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                }
                else if (rightExpression.OperatorToken == JSToken.Divide)
                {
                    // divide-divide
                    ConstantWrapper newLiteral = Multiply(thisConstant, otherConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, newLiteral))
                    {
                        // but we need to swap the left and right operands first
                        rightExpression.SwapOperands();

                        // then rotate the node up after replacing old with new
                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                }
            }
        }

        #endregion

        #region Constant operation methods

        private ConstantWrapper Multiply(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsOkayToCombine && right.IsOkayToCombine
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    double leftValue = left.ToNumber();
                    double rightValue = right.ToNumber();
                    double result = leftValue * rightValue;

                    if (ConstantWrapper.NumberIsOkayToCombine(result))
                    {
                        newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                    }
                    else
                    {
                        if (!left.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(leftValue))
                        {
                            left.Parent.ReplaceChild(left, new ConstantWrapper(leftValue, PrimitiveType.Number, left.Context));
                        }
                        if (!right.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(rightValue))
                        {
                            right.Parent.ReplaceChild(right, new ConstantWrapper(rightValue, PrimitiveType.Number, right.Context));
                        }
                    }
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper Divide(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsOkayToCombine && right.IsOkayToCombine
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    double leftValue = left.ToNumber();
                    double rightValue = right.ToNumber();
                    double result = leftValue / rightValue;

                    if (ConstantWrapper.NumberIsOkayToCombine(result))
                    {
                        newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                    }
                    else
                    {
                        if (!left.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(leftValue))
                        {
                            left.Parent.ReplaceChild(left, new ConstantWrapper(leftValue, PrimitiveType.Number, left.Context));
                        }
                        if (!right.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(rightValue))
                        {
                            right.Parent.ReplaceChild(right, new ConstantWrapper(rightValue, PrimitiveType.Number, right.Context));
                        }
                    }
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper Modulo(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsOkayToCombine && right.IsOkayToCombine
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    double leftValue = left.ToNumber();
                    double rightValue = right.ToNumber();
                    double result = leftValue % rightValue;

                    if (ConstantWrapper.NumberIsOkayToCombine(result))
                    {
                        newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                    }
                    else
                    {
                        if (!left.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(leftValue))
                        {
                            left.Parent.ReplaceChild(left, new ConstantWrapper(leftValue, PrimitiveType.Number, left.Context));
                        }
                        if (!right.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(rightValue))
                        {
                            right.Parent.ReplaceChild(right, new ConstantWrapper(rightValue, PrimitiveType.Number, right.Context));
                        }
                    }
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper Plus(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsStringLiteral || right.IsStringLiteral)
            {
                // one or both are strings -- this is a strng concat operation
                newLiteral = StringConcat(left, right);
            }
            else
            {
                // neither are strings -- this is a numeric addition operation
                newLiteral = NumericAddition(left, right);
            }
            return newLiteral;
        }

        private ConstantWrapper NumericAddition(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsOkayToCombine && right.IsOkayToCombine
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    double leftValue = left.ToNumber();
                    double rightValue = right.ToNumber();
                    double result = leftValue + rightValue;

                    if (ConstantWrapper.NumberIsOkayToCombine(result))
                    {
                        newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                    }
                    else
                    {
                        if (!left.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(leftValue))
                        {
                            left.Parent.ReplaceChild(left, new ConstantWrapper(leftValue, PrimitiveType.Number, left.Context));
                        }
                        if (!right.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(rightValue))
                        {
                            right.Parent.ReplaceChild(right, new ConstantWrapper(rightValue, PrimitiveType.Number, right.Context));
                        }
                    }
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper StringConcat(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            // if we don't want to combine adjacent string literals, then we know we don't want to do
            // anything here.
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.CombineAdjacentStringLiterals))
            {
                // if either one of the operands is not a string literal, then check to see if we allow
                // evaluation of numeric expression; if not, then no-go. IF they are both string literals,
                // then it doesn't matter what the numeric flag says.
                if ((left.IsStringLiteral && right.IsStringLiteral)
                    || m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
                {
                    // if either value is a floating-point number (a number, not NaN, not Infinite, not an Integer),
                    // then we won't do the string concatenation because different browsers may have subtle differences
                    // in their double-to-string conversion algorithms.
                    // so if neither is a numeric literal, or if one or both are, if they are both integer literals
                    // in the range that we can EXACTLY represent them in a double, then we can proceed.
                    // NaN, +Infinity and -Infinity are also acceptable
                    if (left.IsOkayToCombine && right.IsOkayToCombine)
                    {
                        newLiteral = new ConstantWrapper(left.Concat(right), PrimitiveType.String, left.Context.FlattenToStart());
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper Minus(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsOkayToCombine && right.IsOkayToCombine
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    double leftValue = left.ToNumber();
                    double rightValue = right.ToNumber();
                    double result = leftValue - rightValue;

                    if (ConstantWrapper.NumberIsOkayToCombine(result))
                    {
                        newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                    }
                    else
                    {
                        if (!left.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(leftValue))
                        {
                            left.Parent.ReplaceChild(left, new ConstantWrapper(leftValue, PrimitiveType.Number, left.Context));
                        }
                        if (!right.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(rightValue))
                        {
                            right.Parent.ReplaceChild(right, new ConstantWrapper(rightValue, PrimitiveType.Number, right.Context));
                        }
                    }
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper LeftShift(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    // left-hand value is a 32-bit signed integer
                    Int32 lvalue = left.ToInt32();

                    // mask only the bottom 5 bits of the right-hand value
                    int rvalue = (int)(right.ToUInt32() & 0x1F);

                    // convert the result to a double
                    double result = Convert.ToDouble(lvalue << rvalue);
                    newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }
            return newLiteral;
        }

        private ConstantWrapper RightShift(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    // left-hand value is a 32-bit signed integer
                    Int32 lvalue = left.ToInt32();

                    // mask only the bottom 5 bits of the right-hand value
                    int rvalue = (int)(right.ToUInt32() & 0x1F);

                    // convert the result to a double
                    double result = Convert.ToDouble(lvalue >> rvalue);
                    newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper UnsignedRightShift(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    // left-hand value is a 32-bit signed integer
                    UInt32 lvalue = left.ToUInt32();

                    // mask only the bottom 5 bits of the right-hand value
                    int rvalue = (int)(right.ToUInt32() & 0x1F);

                    // convert the result to a double
                    double result = Convert.ToDouble(lvalue >> rvalue);
                    newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper LessThan(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                if (left.IsStringLiteral && right.IsStringLiteral)
                {
                    if (left.IsOkayToCombine && right.IsOkayToCombine)
                    {
                        // do a straight ordinal comparison of the strings
                        newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) < 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                }
                else
                {
                    try
                    {
                        // either one or both are NOT a string -- numeric comparison
                        if (left.IsOkayToCombine && right.IsOkayToCombine)
                        {
                            newLiteral = new ConstantWrapper(left.ToNumber() < right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }
            return newLiteral;
        }

        private ConstantWrapper LessThanOrEqual(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                if (left.IsStringLiteral && right.IsStringLiteral)
                {
                    if (left.IsOkayToCombine && right.IsOkayToCombine)
                    {
                        // do a straight ordinal comparison of the strings
                        newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) <= 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                }
                else
                {
                    try
                    {
                        // either one or both are NOT a string -- numeric comparison
                        if (left.IsOkayToCombine && right.IsOkayToCombine)
                        {
                            newLiteral = new ConstantWrapper(left.ToNumber() <= right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper GreaterThan(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                if (left.IsStringLiteral && right.IsStringLiteral)
                {
                    if (left.IsOkayToCombine && right.IsOkayToCombine)
                    {
                        // do a straight ordinal comparison of the strings
                        newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) > 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                }
                else
                {
                    try
                    {
                        // either one or both are NOT a string -- numeric comparison
                        if (left.IsOkayToCombine && right.IsOkayToCombine)
                        {
                            newLiteral = new ConstantWrapper(left.ToNumber() > right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper GreaterThanOrEqual(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                if (left.IsStringLiteral && right.IsStringLiteral)
                {
                    if (left.IsOkayToCombine && right.IsOkayToCombine)
                    {
                        // do a straight ordinal comparison of the strings
                        newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) >= 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                }
                else
                {
                    try
                    {
                        // either one or both are NOT a string -- numeric comparison
                        if (left.IsOkayToCombine && right.IsOkayToCombine)
                        {
                            newLiteral = new ConstantWrapper(left.ToNumber() >= right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper Equal(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                PrimitiveType leftType = left.PrimitiveType;
                if (leftType == right.PrimitiveType)
                {
                    // the values are the same type
                    switch (leftType)
                    {
                        case PrimitiveType.Null:
                            // null == null is true
                            newLiteral = new ConstantWrapper(true, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.Boolean:
                            // compare boolean values
                            newLiteral = new ConstantWrapper(left.ToBoolean() == right.ToBoolean(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.String:
                            // compare string ordinally
                            if (left.IsOkayToCombine && right.IsOkayToCombine)
                            {
                                newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) == 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            }
                            break;

                        case PrimitiveType.Number:
                            try
                            {
                                // compare the values
                                // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                                // and NaN is always unequal to everything else, including itself.
                                if (left.IsOkayToCombine && right.IsOkayToCombine)
                                {
                                    newLiteral = new ConstantWrapper(left.ToNumber() == right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                                }
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                            break;
                    }
                }
                else if (left.IsOkayToCombine && right.IsOkayToCombine)
                {
                    try
                    {
                        // numeric comparison
                        // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                        // and NaN is always unequal to everything else, including itself.
                        newLiteral = new ConstantWrapper(left.ToNumber() == right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper NotEqual(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                PrimitiveType leftType = left.PrimitiveType;
                if (leftType == right.PrimitiveType)
                {
                    // the values are the same type
                    switch (leftType)
                    {
                        case PrimitiveType.Null:
                            // null != null is false
                            newLiteral = new ConstantWrapper(false, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.Boolean:
                            // compare boolean values
                            newLiteral = new ConstantWrapper(left.ToBoolean() != right.ToBoolean(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.String:
                            // compare string ordinally
                            if (left.IsOkayToCombine && right.IsOkayToCombine)
                            {
                                newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) != 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            }
                            break;

                        case PrimitiveType.Number:
                            try
                            {
                                // compare the values
                                // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                                // and NaN is always unequal to everything else, including itself.
                                if (left.IsOkayToCombine && right.IsOkayToCombine)
                                {
                                    newLiteral = new ConstantWrapper(left.ToNumber() != right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                                }
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                            break;
                    }
                }
                else if (left.IsOkayToCombine && right.IsOkayToCombine)
                {
                    try
                    {
                        // numeric comparison
                        // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                        // and NaN is always unequal to everything else, including itself.
                        newLiteral = new ConstantWrapper(left.ToNumber() != right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper StrictEqual(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                PrimitiveType leftType = left.PrimitiveType;
                if (leftType == right.PrimitiveType)
                {
                    // the values are the same type
                    switch (leftType)
                    {
                        case PrimitiveType.Null:
                            // null === null is true
                            newLiteral = new ConstantWrapper(true, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.Boolean:
                            // compare boolean values
                            newLiteral = new ConstantWrapper(left.ToBoolean() == right.ToBoolean(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.String:
                            // compare string ordinally
                            if (left.IsOkayToCombine && right.IsOkayToCombine)
                            {
                                newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) == 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            }
                            break;

                        case PrimitiveType.Number:
                            try
                            {
                                // compare the values
                                // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                                // and NaN is always unequal to everything else, including itself.
                                if (left.IsOkayToCombine && right.IsOkayToCombine)
                                {
                                    newLiteral = new ConstantWrapper(left.ToNumber() == right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                                }
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                            break;
                    }
                }
                else
                {
                    // if they aren't the same type, they ain't equal
                    newLiteral = new ConstantWrapper(false, PrimitiveType.Boolean, left.Context.FlattenToStart());
                }
            }

            return newLiteral;
        }

        private ConstantWrapper StrictNotEqual(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                PrimitiveType leftType = left.PrimitiveType;
                if (leftType == right.PrimitiveType)
                {
                    // the values are the same type
                    switch (leftType)
                    {
                        case PrimitiveType.Null:
                            // null !== null is false
                            newLiteral = new ConstantWrapper(false, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.Boolean:
                            // compare boolean values
                            newLiteral = new ConstantWrapper(left.ToBoolean() != right.ToBoolean(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.String:
                            // compare string ordinally
                            if (left.IsOkayToCombine && right.IsOkayToCombine)
                            {
                                newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) != 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            }
                            break;

                        case PrimitiveType.Number:
                            try
                            {
                                // compare the values
                                // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                                // and NaN is always unequal to everything else, including itself.
                                if (left.IsOkayToCombine && right.IsOkayToCombine)
                                {
                                    newLiteral = new ConstantWrapper(left.ToNumber() != right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                                }
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                            break;
                    }
                }
                else
                {
                    // if they aren't the same type, they are not equal
                    newLiteral = new ConstantWrapper(true, PrimitiveType.Boolean, left.Context.FlattenToStart());
                }
            }

            return newLiteral;
        }

        private ConstantWrapper BitwiseAnd(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    Int32 lValue = left.ToInt32();
                    Int32 rValue = right.ToInt32();
                    newLiteral = new ConstantWrapper(Convert.ToDouble(lValue & rValue), PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper BitwiseOr(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    Int32 lValue = left.ToInt32();
                    Int32 rValue = right.ToInt32();
                    newLiteral = new ConstantWrapper(Convert.ToDouble(lValue | rValue), PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper BitwiseXor(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    Int32 lValue = left.ToInt32();
                    Int32 rValue = right.ToInt32();
                    newLiteral = new ConstantWrapper(Convert.ToDouble(lValue ^ rValue), PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper LogicalAnd(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    // if the left-hand side evaluates to true, return the right-hand side.
                    // if the left-hand side is false, return it.
                    newLiteral = left.ToBoolean() ? right : left;
                }
                catch (InvalidCastException)
                {
                    // if we couldn't cast to bool, ignore
                }
            }

            return newLiteral;
        }

        private ConstantWrapper LogicalOr(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    // if the left-hand side evaluates to true, return the left-hand side.
                    // if the left-hand side is false, return the right-hand side.
                    newLiteral = left.ToBoolean() ? left : right;
                }
                catch (InvalidCastException)
                {
                    // if we couldn't cast to bool, ignore
                }
            }

            return newLiteral;
        }

        private static bool OnlyHasConstantItems(ArrayLiteral arrayLiteral)
        {
            var elementCount = arrayLiteral.Elements.Count;
            for (var ndx = 0; ndx < elementCount; ++ndx)
            {
                // if any one element isn't a constant or isn't safe for combination, then bail with false
                var constantWrapper = arrayLiteral.Elements[ndx] as ConstantWrapper;
                if (constantWrapper == null || !constantWrapper.IsOkayToCombine)
                {
                    return false;
                }
            }

            // if we get here, they were all constant
            return true;
        }

        private static string ComputeJoin(ArrayLiteral arrayLiteral, ConstantWrapper separatorNode)
        {
            // if the separator node is null, then the separator is a single comma character.
            // otherwise it's just the string value of the separator.
            var separator = separatorNode == null ? "," : separatorNode.ToString();

            var sb = StringBuilderPool.Acquire();
            try
            {
                for (var ndx = 0; ndx < arrayLiteral.Elements.Count; ++ndx)
                {
                    // add the separator between items (if we have one)
                    if (ndx > 0 && !string.IsNullOrEmpty(separator))
                    {
                        sb.Append(separator);
                    }

                    // the element is a constant wrapper (we wouldn't get this far if it wasn't),
                    // but we've overloaded the virtual ToString method on ConstantWrappers to convert the
                    // constant value to a string value.
                    sb.Append(arrayLiteral.Elements[ndx].ToString());
                }

                return sb.ToString();
            }
            finally
            {
                sb.Release();
            }
        }

        #endregion

        private int NodeLength(AstNode node)
        {
            var code = OutputVisitor.Apply(node, m_parser.Settings);
            return code.IfNotNull(c => c.Length);
        }

        //
        // IVisitor implementations
        //

        public override void Visit(AstNodeList node)
        {
            if (node != null)
            {
                var commaOperator = node.Parent as CommaExpression;
                AstNodeList list;
                if (commaOperator != null
                    && (list = commaOperator.Operand2 as AstNodeList) != null)
                {
                    // this list is part of a comma-operator, which is a collection of contiguous
                    // expression statements that we combined together. What we want to do is
                    // delete all constant elements from the list.
                    // if the parent is a block, then this was just a collection of statements and
                    // we can delete ALL constant expressions. But if the parent is not a block, then
                    // we will want to keep the last one as-is because it is the return value of the
                    // overall expression.
                    for (var ndx = list.Count - (node.Parent is BlockStatement ? 1 : 2); ndx >= 0; --ndx)
                    {
                        if (list[ndx] is ConstantWrapper)
                        {
                            list.RemoveAt(ndx);
                        }
                    }

                }

                // then normally recurse whatever is left over
                base.Visit(node);
            }
        }

        public override void Visit(BinaryExpression node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                // then evaluate.
                // do it in a separate method than this one because if this method
                // allocates a lot of bytes on the stack, we'll overflow our stack for
                // code that has lots of expression statements that get converted into one
                // BIG, uber-nested set of comma operators.
                DoBinaryOperator(node);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void DoBinaryOperator(BinaryExpression node)
        {
            if (m_parser.Settings.EvalLiteralExpressions)
            {
                // if this is an assign operator, an in, or an instanceof, then we won't
                // try to evaluate it
                if (!node.IsAssign && node.OperatorToken != JSToken.In && node.OperatorToken != JSToken.InstanceOf)
                {
                    if (node.OperatorToken == JSToken.StrictEqual || node.OperatorToken == JSToken.StrictNotEqual)
                    {
                        // the operator is a strict equality (or not-equal).
                        // check the primitive types of the two operands -- if they are known but not the same, we can
                        // shortcut the whole process by just replacing this node with a boolean literal.
                        var leftType = node.Operand1.FindPrimitiveType();
                        if (leftType != PrimitiveType.Other)
                        {
                            var rightType = node.Operand2.FindPrimitiveType();
                            if (rightType != PrimitiveType.Other)
                            {
                                // both sides are known
                                if (leftType != rightType)
                                {
                                    // they are not the same type -- replace with a boolean and bail
                                    ReplaceNodeWithLiteral(
                                        node, 
                                        new ConstantWrapper(node.OperatorToken == JSToken.StrictEqual ? false : true, PrimitiveType.Boolean, node.Context));
                                    return;
                                }

                                // they are the same type -- we can change the operator to simple equality/not equality
                                node.OperatorToken = node.OperatorToken == JSToken.StrictEqual ? JSToken.Equal : JSToken.NotEqual;
                            }
                        }
                    }

                    // see if the left operand is a literal number, boolean, string, or null
                    ConstantWrapper left = node.Operand1 as ConstantWrapper;
                    if (left != null)
                    {
                        if (node.OperatorToken == JSToken.Comma)
                        {
                            // the comma operator evaluates the left, then evaluates the right and returns it.
                            // but if the left is a literal, evaluating it doesn't DO anything, so we can replace the
                            // entire operation with the right-hand operand
                            ConstantWrapper rightConstant = node.Operand2 as ConstantWrapper;
                            if (rightConstant != null)
                            {
                                // we'll replace the operator with the right-hand operand, BUT it's a constant, too.
                                // first check to see if replacing this node with a constant will result in creating
                                // a member-bracket operator that can be turned into a member-dot. If it is, then that
                                // method will handle the replacement. But if it doesn't, then we should just replace
                                // the comma with the right-hand operand.
                                if (!ReplaceMemberBracketWithDot(node, rightConstant))
                                {
                                    ReplaceNodeWithLiteral(node, rightConstant);
                                }
                            }
                            else if (node is CommaExpression)
                            {
                                // this is a collection of expression statements that we've joined together as
                                // an extended comma operator. 
                                var list = node.Operand2 as AstNodeList;
                                if (list == null)
                                {
                                    // Check that the right operand is not an eval lookup as in (0, eval)('this');
                                    // In this case, we cannot simplify the expression and we have to let the eval
                                    // inside the CommaExpression.
                                    if (!IsEvalLookup(node.Operand2))
                                    {
                                        // not a list, just a single item, so we can just
                                        // replace this entire node with the one element
                                        ReplaceNodeCheckParens(node, node.Operand2);
                                    }
                                }
                                else if (list.Count == 1)
                                {
                                    // If the list has a single element, then we can just
                                    // replace this entire node with the one element
                                    if (!IsEvalLookup(list[0]))
                                    {
                                        ReplaceNodeCheckParens(node, list[0]);
                                    }
                                }
                                else if (list.Count == 0)
                                {
                                    // the recursion ended up emptying the list, so we can just delete
                                    // this node altogether
                                    ReplaceNodeCheckParens(node, null);
                                }
                                else
                                {
                                    // more than one item in the list
                                    // move the first item from the list to the left-hand side
                                    var firstItem = list[0];
                                    list.RemoveAt(0);
                                    node.Operand1 = firstItem;

                                    // if there's only one item left in the list, we can get rid of the
                                    // extra list node and make it just the remaining node
                                    if (list.Count == 1)
                                    {
                                        firstItem = list[0];
                                        list.RemoveAt(0);
                                        node.Operand2 = firstItem;
                                    }
                                }
                            }
                            else
                            {
                                // replace the comma operator with the right-hand operand
                                ReplaceNodeCheckParens(node, node.Operand2);
                            }
                        }
                        else
                        {
                            // see if the right operand is a literal number, boolean, string, or null
                            ConstantWrapper right = node.Operand2 as ConstantWrapper;
                            if (right != null)
                            {
                                // then they are both constants and we can evaluate the operation
                                EvalThisOperator(node, left, right);
                            }
                            else
                            {
                                // see if the right is a binary operator that can be combined with ours
                                BinaryExpression rightBinary = node.Operand2 as BinaryExpression;
                                if (rightBinary != null)
                                {
                                    ConstantWrapper rightLeft = rightBinary.Operand1 as ConstantWrapper;
                                    if (rightLeft != null)
                                    {
                                        // eval our left and the right-hand binary's left and put the combined operation as
                                        // the child of the right-hand binary
                                        EvalToTheRight(node, left, rightLeft, rightBinary);
                                    }
                                    else
                                    {
                                        ConstantWrapper rightRight = rightBinary.Operand2 as ConstantWrapper;
                                        if (rightRight != null)
                                        {
                                            EvalFarToTheRight(node, left, rightRight, rightBinary);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // left is not a constantwrapper. See if the right is
                        ConstantWrapper right = node.Operand2 as ConstantWrapper;
                        if (right != null)
                        {
                            // the right is a constant. See if the the left is a binary operator...
                            BinaryExpression leftBinary = node.Operand1 as BinaryExpression;
                            if (leftBinary != null)
                            {
                                // ...with a constant on the right, and the operators can be combined
                                ConstantWrapper leftRight = leftBinary.Operand2 as ConstantWrapper;
                                if (leftRight != null)
                                {
                                    EvalToTheLeft(node, right, leftRight, leftBinary);
                                }
                                else
                                {
                                    ConstantWrapper leftLeft = leftBinary.Operand1 as ConstantWrapper;
                                    if (leftLeft != null)
                                    {
                                        EvalFarToTheLeft(node, right, leftLeft, leftBinary);
                                    }
                                }
                            }
                            else if (m_parser.Settings.IsModificationAllowed(TreeModifications.SimplifyStringToNumericConversion))
                            {
                                // see if it's a lookup and this is a minus operation and the constant is a zero
                                LookupExpression lookup = node.Operand1 as LookupExpression;
                                if (lookup != null && node.OperatorToken == JSToken.Minus && right.IsIntegerLiteral && right.ToNumber() == 0)
                                {
                                    // okay, so we have "lookup - 0"
                                    // this is done frequently to force a value to be numeric. 
                                    // There is an easier way: apply the unary + operator to it. 
                                    var unary = new UnaryExpression(node.Context)
                                        {
                                            Operand = lookup,
                                            OperatorToken = JSToken.Plus
                                        };
                                    ReplaceNodeCheckParens(node, unary);
                                }
                            }
                        }
                        // TODO: shouldn't we check if they BOTH are binary operators? (a*6)*(5*b) ==> a*30*b (for instance)
                    }
                }
            }
        }

        private bool IsEvalLookup(AstNode node)
        {
            var lookupExpression = node as LookupExpression;
            return lookupExpression != null && lookupExpression.Name == "eval";
        }

        public override void Visit(CallExpression node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                // if this isn't a constructor and it isn't a member-brackets operator
                if (!node.IsConstructor && !node.InBrackets)
                {
                    // check to see if this is a call of certain member functions
                    var member = node.Function as MemberExpression;
                    if (member != null)
                    {
                        if (string.CompareOrdinal(member.Name, "join") == 0 && node.Arguments.Count <= 1
                            && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateLiteralJoins))
                        {
                            // this is a call to join with zero or one argument (no more)
                            // see if the root is an array literal that has no issues
                            var arrayLiteral = member.Root as ArrayLiteral;
                            if (arrayLiteral != null && !arrayLiteral.MayHaveIssues)
                            {
                                // it is -- make sure the separator is either not specified or is a constant
                                ConstantWrapper separator = null;
                                if (node.Arguments.Count == 0 || (separator = node.Arguments[0] as ConstantWrapper) != null)
                                {
                                    // and the array literal must contain only constant items
                                    if (OnlyHasConstantItems(arrayLiteral))
                                    {
                                        // last test: compute the combined string and only use it if it's actually
                                        // shorter than the original code
                                        var combinedJoin = ComputeJoin(arrayLiteral, separator);
                                        if (combinedJoin.Length + 2 < NodeLength(node))
                                        {
                                            // transform: [c,c,c].join(s) => "cscsc"
                                            ReplaceNodeWithLiteral(node, 
                                                new ConstantWrapper(combinedJoin, PrimitiveType.String, node.Context));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        public override void Visit(Conditional node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoConditional(node);
            }
        }

        private void DoConditional(Conditional node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                // if the condition is a literal, evaluating the condition doesn't do anything, AND
                // we know now whether it's true or not.
                ConstantWrapper literalCondition = node.Condition as ConstantWrapper;
                if (literalCondition != null)
                {
                    try
                    {
                        // if the boolean represenation of the literal is true, we can replace the condition operator
                        // with the true expression; otherwise we can replace it with the false expression
                        ReplaceNodeCheckParens(node, literalCondition.ToBoolean() ? node.TrueExpression : node.FalseExpression);
                    }
                    catch (InvalidCastException)
                    {
                        // ignore any invalid cast errors
                    }
                }
            }
        }

        public override void Visit(ConditionalCompilationElseIf node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoConditionalCompilationElseIf(node);
            }
        }

        private void DoConditionalCompilationElseIf(ConditionalCompilationElseIf node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                // if the if-condition is a constant, we can eliminate one of the two branches
                ConstantWrapper constantCondition = node.Condition as ConstantWrapper;
                if (constantCondition != null)
                {
                    // instead, replace the condition with a 1 if it's always true or a 0 if it's always false
                    if (constantCondition.IsNotOneOrPositiveZero)
                    {
                        try
                        {
                            node.Condition =
                                new ConstantWrapper(constantCondition.ToBoolean() ? 1 : 0, PrimitiveType.Number, node.Condition.Context);
                        }
                        catch (InvalidCastException)
                        {
                            // ignore any invalid cast exceptions
                        }
                    }
                }
            }
        }

        public override void Visit(ConditionalCompilationIf node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoConditionalCompilationIf(node);
            }
        }

        private void DoConditionalCompilationIf(ConditionalCompilationIf node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                // if the if-condition is a constant, we can eliminate one of the two branches
                ConstantWrapper constantCondition = node.Condition as ConstantWrapper;
                if (constantCondition != null)
                {
                    // instead, replace the condition with a 1 if it's always true or a 0 if it's always false
                    if (constantCondition.IsNotOneOrPositiveZero)
                    {
                        try
                        {
                            node.Condition =
                                new ConstantWrapper(constantCondition.ToBoolean() ? 1 : 0, PrimitiveType.Number, node.Condition.Context);
                        }
                        catch (InvalidCastException)
                        {
                            // ignore any invalid cast exceptions
                        }
                    }
                }
            }
        }

        public override void Visit(DoWhileStatement node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoDoWhile(node);
            }
        }

        private void DoDoWhile(DoWhileStatement node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                // if the condition is a constant, we can simplify things
                ConstantWrapper constantCondition = node.Condition as ConstantWrapper;
                if (constantCondition != null && constantCondition.IsNotOneOrPositiveZero)
                {
                    try
                    {
                        // the condition is a constant, so it is always either true or false
                        // we can replace the condition with a one or a zero -- only one byte
                        node.Condition =
                            new ConstantWrapper(constantCondition.ToBoolean() ? 1 : 0, PrimitiveType.Number, node.Condition.Context);
                    }
                    catch (InvalidCastException)
                    {
                        // ignore any invalid cast errors
                    }
                }
            }
        }

        public override void Visit(ForStatement node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoForNode(node);
            }
        }

        private void DoForNode(ForStatement node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                ConstantWrapper constantCondition = node.Condition as ConstantWrapper;
                if (constantCondition != null)
                {
                    try
                    {
                        // if condition is always false, change it to a zero (only one byte)
                        // and if it is always true, remove it (default behavior)
                        if (constantCondition.ToBoolean())
                        {
                            // always true -- don't need a condition at all
                            node.Condition = null;
                        }
                        else if (constantCondition.IsNotOneOrPositiveZero)
                        {
                            // always false and it's not already a zero. Make it so (only one byte)
                            node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // ignore any invalid cast exceptions
                    }
                }
            }
        }

        public override void Visit(IfStatement node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoIfNode(node);
            }
        }

        private void DoIfNode(IfStatement node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                // if the if-condition is a constant, we can eliminate one of the two branches
                ConstantWrapper constantCondition = node.Condition as ConstantWrapper;
                if (constantCondition != null)
                {
                    // instead, replace the condition with a 1 if it's always true or a 0 if it's always false
                    if (constantCondition.IsNotOneOrPositiveZero)
                    {
                        try
                        {
                            node.Condition =
                                new ConstantWrapper(constantCondition.ToBoolean() ? 1 : 0, PrimitiveType.Number, node.Condition.Context);
                        }
                        catch (InvalidCastException)
                        {
                            // ignore any invalid cast exceptions
                        }
                    }
                }
            }
        }

        public override void Visit(MemberExpression node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                if (string.CompareOrdinal(node.Name, "length") == 0
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateLiteralLengths))
                {
                    // if we create a constant, we'll replace the current node with it
                    ConstantWrapper length = null;

                    ArrayLiteral arrayLiteral;
                    var constantWrapper = node.Root as ConstantWrapper;
                    if (constantWrapper != null)
                    {
                        if (constantWrapper.PrimitiveType == PrimitiveType.String && !constantWrapper.MayHaveIssues)
                        {
                            length = new ConstantWrapper(constantWrapper.ToString().Length, PrimitiveType.Number, node.Context);
                        }
                    }
                    else if ((arrayLiteral = node.Root as ArrayLiteral) != null && !arrayLiteral.MayHaveIssues)
                    {
                        var lengthValue = arrayLiteral.Length;
                        if (lengthValue >= 0)
                        {
                            // get the count of items in the array literal, create a constant wrapper from it, and
                            // replace this node with it
                            length = new ConstantWrapper(lengthValue, PrimitiveType.Number, node.Context);
                        }
                    }

                    if (length != null)
                    {
                        node.Parent.ReplaceChild(node, length);
                    }
                }
            }
        }

        public override void Visit(UnaryExpression node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoUnaryNode(node);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void DoUnaryNode(UnaryExpression node)
        {
            if (!node.OperatorInConditionalCompilationComment
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                var literalOperand = node.Operand as ConstantWrapper;
                switch(node.OperatorToken)
                {
                    case JSToken.Void:
                        // see if our operand is a ConstantWrapper
                        if (literalOperand != null)
                        {
                            // either number, string, boolean, or null.
                            // the void operator evaluates its operand and returns undefined. Since evaluating a literal
                            // does nothing, then it doesn't matter what the heck it is. Replace it with a zero -- a one-
                            // character literal.
                            node.Operand = new ConstantWrapper(0, PrimitiveType.Number, node.Context);
                        }
                        break;

                    case JSToken.TypeOf:
                        if (literalOperand != null)
                        {
                            // either number, string, boolean, or null.
                            // the operand is a literal. Therefore we already know what the typeof
                            // operator will return. Just short-circuit that behavior now and replace the operator
                            // with a string literal of the proper value
                            string typeName = null;
                            if (literalOperand.IsStringLiteral)
                            {
                                // "string"
                                typeName = "string";
                            }
                            else if (literalOperand.IsNumericLiteral)
                            {
                                // "number"
                                typeName = "number";
                            }
                            else if (literalOperand.IsBooleanLiteral)
                            {
                                // "boolean"
                                typeName = "boolean";
                            }
                            else if (literalOperand.Value == null)
                            {
                                // "object"
                                typeName = "object";
                            }

                            if (!string.IsNullOrEmpty(typeName))
                            {
                                ReplaceNodeWithLiteral(node, new ConstantWrapper(typeName, PrimitiveType.String, node.Context));
                            }
                        }
                        else if (node.Operand is ObjectLiteral)
                        {
                            ReplaceNodeWithLiteral(node, new ConstantWrapper("object", PrimitiveType.String, node.Context));
                        }
                        break;

                    case JSToken.Plus:
                        if (literalOperand != null)
                        {
                            try
                            {
                                // replace with a constant representing operand.ToNumber,
                                ReplaceNodeWithLiteral(node, new ConstantWrapper(literalOperand.ToNumber(), PrimitiveType.Number, node.Context));
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                        }
                        break;

                    case JSToken.Minus:
                        if (literalOperand != null)
                        {
                            try
                            {
                                // replace with a constant representing the negative of operand.ToNumber
                                ReplaceNodeWithLiteral(node, new ConstantWrapper(-literalOperand.ToNumber(), PrimitiveType.Number, node.Context));
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                        }
                        break;

                    case JSToken.BitwiseNot:
                        if (literalOperand != null)
                        {
                            try
                            {
                                // replace with a constant representing the bitwise-not of operant.ToInt32
                                ReplaceNodeWithLiteral(node, new ConstantWrapper(Convert.ToDouble(~literalOperand.ToInt32()), PrimitiveType.Number, node.Context));
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                        }
                        break;

                    case JSToken.LogicalNot:
                        if (literalOperand != null)
                        {
                            // replace with a constant representing the opposite of operand.ToBoolean
                            try
                            {
                                ReplaceNodeWithLiteral(node, new ConstantWrapper(!literalOperand.ToBoolean(), PrimitiveType.Boolean, node.Context));
                            }
                            catch (InvalidCastException)
                            {
                                // ignore any invalid cast exceptions
                            }
                        }
                        break;
                }
            }
        }

        public override void Visit(WhileStatement node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoWhileNode(node);
            }
        }

        private void DoWhileNode(WhileStatement node)
        {
            // see if the condition is a constant
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                var constantCondition = node.Condition as ConstantWrapper;
                if (constantCondition != null)
                {
                    // TODO: (someday) we'd RATHER eliminate the statement altogether if the condition is always false,
                    // but we'd need to make sure var'd variables and declared functions are properly handled.
                    try
                    {
                        bool isTrue = constantCondition.ToBoolean();
                        if (isTrue)
                        {
                            // the condition is always true, so we should change it to 1
                            if (m_parser.Settings.IsModificationAllowed(TreeModifications.ChangeWhileToFor))
                            {
                                // the condition is always true; we should change it to a for(;;) statement.
                                // less bytes than while(1)

                                // check to see if we want to combine a preceding var with a for-statement
                                AstNode initializer = null;
                                if (m_parser.Settings.IsModificationAllowed(TreeModifications.MoveVarIntoFor))
                                {
                                    // if the previous statement is a var, we can move it to the initializer
                                    // and save even more bytes. The parent should always be a block. If not, 
                                    // then assume there is no previous.
                                    var parentBlock = node.Parent as BlockStatement;
                                    if (parentBlock != null)
                                    {
                                        int whileIndex = parentBlock.IndexOf(node);
                                        if (whileIndex > 0)
                                        {
                                            var previousVar = parentBlock[whileIndex - 1] as VarDeclaration;
                                            if (previousVar != null)
                                            {
                                                initializer = previousVar;
                                                parentBlock.RemoveAt(whileIndex - 1);
                                            }
                                        }
                                    }
                                }

                                // create the for using our body and replace ourselves with it
                                var forNode = new ForStatement(node.Context)
                                    {
                                        Initializer = initializer,
                                        Body = node.Body
                                    };
                                node.Parent.ReplaceChild(node, forNode);
                            }
                            else
                            {
                                // the condition is always true, so we can replace the condition
                                // with a 1 -- only one byte
                                node.Condition = new ConstantWrapper(1, PrimitiveType.Number, node.Condition.Context);
                            }
                        }
                        else if (constantCondition.IsNotOneOrPositiveZero)
                        {
                            // the condition is always false, so we can replace the condition
                            // with a zero -- only one byte
                            node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // ignore any invalid cast exceptions
                    }
                }
            }
        }
    }
}

---- Transformed Tree ----
using System;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;

namespace NUglify.JavaScript.Visitors
{
    internal class EvaluateLiteralVisitor : TreeVisitor
    {
        private JSParser m_parser;

        public EvaluateLiteralVisitor(JSParser parser) 
        {
            m_parser = parser;
        }

        #region BinaryExpression helper methods

        /// <summary>
        /// If the new literal is a string literal, then we need to check to see if our
        /// parent is a CallNode. If it is, and if the string literal can be an identifier,
        /// we'll replace it with a Member-Dot operation.
        /// </summary>
        /// <param name="newLiteral">newLiteral we intend to replace this binaryop node with</param>
        /// <returns>true if we replaced the parent callnode with a member-dot operation</returns>
        private bool ReplaceMemberBracketWithDot(BinaryExpression node, ConstantWrapper newLiteral)
        {
            if (newLiteral.IsStringLiteral)
            {
                // see if this newly-combined string is the sole argument to a 
                // call-brackets node. If it is and the combined string is a valid
                // identifier (and not a keyword), then we can replace the call
                // with a member operator.
                // remember that the parent of the argument won't be the call node -- it
                // will be the ast node list representing the arguments, whose parent will
                // be the node list. 
                CallExpression parentCall = (node.Parent is AstNodeList ? node.Parent.Parent as CallExpression : null);
                if (parentCall != null && parentCall.InBrackets)
                {
                    // get the newly-combined string
                    string combinedString = newLiteral.ToString();

                    // see if this new string is the target of a replacement operation
                    string newName;
                    if (m_parser.Settings.HasRenamePairs && m_parser.Settings.ManualRenamesProperties
                        && m_parser.Settings.IsModificationAllowed(TreeModifications.PropertyRenaming)
                        && !string.IsNullOrEmpty(newName = m_parser.Settings.GetNewName(combinedString)))
                    {
                        // yes, it is. Now see if the new name is safe to be converted to a dot-operation.
                        if (m_parser.Settings.IsModificationAllowed(TreeModifications.BracketMemberToDotMember)
                            && JSScanner.IsSafeIdentifier(newName)
                            && !JSScanner.IsKeyword(newName, (parentCall.EnclosingScope ?? m_parser.GlobalScope).UseStrict))
                        {
                            // we want to replace the call with operator with a new member dot operation, and
                            // since we won't be analyzing it (we're past the analyze phase, we're going to need
                            // to use the new string value
                            MemberExpression replacementMember = new MemberExpression(parentCall.Context)
                                {
                                    Root = parentCall.Function,
                                    Name = newName,
                                    NameContext = parentCall.Arguments[0].Context
                                };
                            parentCall.Parent.ReplaceChild(parentCall, replacementMember);
                            return true;
                        }
                        else
                        {
                            // nope, can't be changed to a dot-operator for whatever reason.
                            // just replace the value on this new literal. The old operation will
                            // get replaced with this new literal
                            newLiteral.Value = newName;

                            // and make sure it's type is string
                            newLiteral.PrimitiveType = PrimitiveType.String;
                        }
                    }
                    else if (m_parser.Settings.IsModificationAllowed(TreeModifications.BracketMemberToDotMember))
                    {
                        // our parent is a call-bracket -- now we just need to see if the newly-combined
                        // string can be an identifier
                        if (JSScanner.IsSafeIdentifier(combinedString) 
                            && !JSScanner.IsKeyword(combinedString, (parentCall.EnclosingScope ?? m_parser.GlobalScope).UseStrict))
                        {
                            // yes -- replace the parent call with a new member node using the newly-combined string
                            MemberExpression replacementMember = new MemberExpression(parentCall.Context)
                                {
                                    Root = parentCall.Function,
                                    Name = combinedString,
                                    NameContext = parentCall.Arguments[0].Context
                                };
                            parentCall.Parent.ReplaceChild(parentCall, replacementMember);
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// replace the node with a literal. If the node was wrapped in a grouping operator
        /// before (parentheses around it), then we can get rid of the parentheses too, since
        /// we are replacing the node with a single literal entity.
        /// </summary>
        /// <param name="node">node to replace</param>
        /// <param name="newLiteral">literal to replace the node with</param>
        private static void ReplaceNodeWithLiteral(AstNode node, ConstantWrapper newLiteral)
        {
            if (node.Parent is GroupingOperator grouping)
            {
                // because we are replacing the operator with a literal, the parentheses
                // the grouped this operator are now superfluous. Replace them, too
                grouping.Parent.ReplaceChild(grouping, newLiteral);
            }
            else
            {
                // just replace the node with the literal
                node.Parent.ReplaceChild(node, newLiteral);
            }
        }

        private static void ReplaceNodeCheckParens(AstNode oldNode, AstNode newNode)
        {
            if (oldNode.Parent is GroupingOperator grouping)
            {
                if (newNode != null)
                {
                    var targetPrecedence = grouping.Parent.Precedence;

                    if (grouping.Parent is Conditional conditional)
                    {
                        // the conditional is weird in that the different parts need to be
                        // compared against different precedences, not the precedence of the
                        // conditional itself. The condition should be compared to logical-or,
                        // and the true/false expressions against assignment.
                        targetPrecedence = conditional.Condition == grouping
                            ? OperatorPrecedence.LogicalOr
                            : OperatorPrecedence.Assignment;
                    }

                    if (newNode.Precedence >= targetPrecedence)
                    {
                        // don't need the parens anymore, so replace the grouping operator
                        // with the new node, thereby eliminating the parens
                        grouping.Parent.ReplaceChild(grouping, newNode);
                    }
                    else
                    {
                        // still need the parens; just replace the node with the literal
                        oldNode.Parent.ReplaceChild(oldNode, newNode);
                    }
                }
                else
                {
                    // eliminate the parens
                    grouping.Parent.ReplaceChild(grouping, null);
                }
            }
            else
            {
                // just replace the node with the literal
                oldNode.Parent.ReplaceChild(oldNode, newNode);
            }
        }

        /// <summary>
        /// Both the operands of this operator are constants. See if we can evaluate them
        /// </summary>
        /// <param name="left">left-side operand</param>
        /// <param name="right">right-side operand</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void EvalThisOperator(BinaryExpression node, ConstantWrapper left, ConstantWrapper right)
        {
            // we can evaluate these operators if we know both operands are literal
            // number, boolean, string or null
            ConstantWrapper newLiteral = null;
            switch (node.OperatorToken)
            {
                case JSToken.Multiply:
                    newLiteral = Multiply(left, right);
                    break;

                case JSToken.Divide:
                    newLiteral = Divide(left, right);
                    if (newLiteral != null && NodeLength(newLiteral) > NodeLength(node))
                    {
                        // the result is bigger than the expression.
                        // eg: 1/3 is smaller than .333333333333333
                        // never mind.
                        newLiteral = null;
                    }
                    break;

                case JSToken.Modulo:
                    newLiteral = Modulo(left, right);
                    if (newLiteral != null && NodeLength(newLiteral) > NodeLength(node))
                    {
                        // the result is bigger than the expression.
                        // eg: 46.5%6.3 is smaller than 2.4000000000000012
                        // never mind.
                        newLiteral = null;
                    }
                    break;

                case JSToken.Plus:
                    newLiteral = Plus(left, right);
                    break;

                case JSToken.Minus:
                    newLiteral = Minus(left, right);
                    break;

                case JSToken.LeftShift:
                    newLiteral = LeftShift(left, right);
                    break;

                case JSToken.RightShift:
                    newLiteral = RightShift(left, right);
                    break;

                case JSToken.UnsignedRightShift:
                    newLiteral = UnsignedRightShift(left, right);
                    break;

                case JSToken.LessThan:
                    newLiteral = LessThan(left, right);
                    break;

                case JSToken.LessThanEqual:
                    newLiteral = LessThanOrEqual(left, right);
                    break;

                case JSToken.GreaterThan:
                    newLiteral = GreaterThan(left, right);
                    break;

                case JSToken.GreaterThanEqual:
                    newLiteral = GreaterThanOrEqual(left, right);
                    break;

                case JSToken.Equal:
                    newLiteral = Equal(left, right);
                    break;

                case JSToken.NotEqual:
                    newLiteral = NotEqual(left, right);
                    break;

                case JSToken.StrictEqual:
                    newLiteral = StrictEqual(left, right);
                    break;

                case JSToken.StrictNotEqual:
                    newLiteral = StrictNotEqual(left, right);
                    break;

                case JSToken.BitwiseAnd:
                    newLiteral = BitwiseAnd(left, right);
                    break;

                case JSToken.BitwiseOr:
                    newLiteral = BitwiseOr(left, right);
                    break;

                case JSToken.BitwiseXor:
                    newLiteral = BitwiseXor(left, right);
                    break;

                case JSToken.LogicalAnd:
                    newLiteral = LogicalAnd(left, right);
                    break;

                case JSToken.LogicalOr:
                    newLiteral = LogicalOr(left, right);
                    break;

                default:
                    // an operator we don't want to evaluate
                    break;
            }

            // if we can combine them...
            if (newLiteral != null)
            {
                // first we want to check if the new combination is a string literal, and if so, whether 
                // it's now the sole parameter of a member-bracket call operator. If so, instead of replacing our
                // binary operation with the new constant, we'll replace the entire call with a member-dot
                // expression
                if (!ReplaceMemberBracketWithDot(node, newLiteral))
                {
                    ReplaceNodeWithLiteral(node, newLiteral);
                }
            }
        }

        /// <summary>
        /// We have determined that our left-hand operand is another binary operator, and its
        /// right-hand operand is a constant that can be combined with our right-hand operand.
        /// Now we want to set the right-hand operand of that other operator to the newly-
        /// combined constant value, and then rotate it up -- replace our binary operator
        /// with this newly-modified binary operator, and then attempt to re-evaluate it.
        /// </summary>
        /// <param name="binaryOp">the binary operator that is our left-hand operand</param>
        /// <param name="newLiteral">the newly-combined literal</param>
        private void RotateFromLeft(BinaryExpression node, BinaryExpression binaryOp, ConstantWrapper newLiteral)
        {
            // replace our node with the binary operator
            binaryOp.Operand2 = newLiteral;
            node.Parent.ReplaceChild(node, binaryOp);

            // and just for good measure.. revisit the node that's taking our place, since            // we just changed a constant value. Assuming the other operand is a constant, too.
            if (binaryOp.Operand1 is ConstantWrapper otherConstant)
            {
                EvalThisOperator(binaryOp, otherConstant, newLiteral);
            }
        }

        /// <summary>
        /// We have determined that our right-hand operand is another binary operator, and its
        /// left-hand operand is a constant that can be combined with our left-hand operand.
        /// Now we want to set the left-hand operand of that other operator to the newly-
        /// combined constant value, and then rotate it up -- replace our binary operator
        /// with this newly-modified binary operator, and then attempt to re-evaluate it.
        /// </summary>
        /// <param name="binaryOp">the binary operator that is our right-hand operand</param>
        /// <param name="newLiteral">the newly-combined literal</param>
        private void RotateFromRight(BinaryExpression node, BinaryExpression binaryOp, ConstantWrapper newLiteral)
        {
            // replace our node with the binary operator
            binaryOp.Operand1 = newLiteral;
            node.Parent.ReplaceChild(node, binaryOp);

            // and just for good measure.. revisit the node that's taking our place, since            // we just changed a constant value. Assuming the other operand is a constant, too.
            if (binaryOp.Operand2 is ConstantWrapper otherConstant)
            {
                EvalThisOperator(binaryOp, newLiteral, otherConstant);
            }
        }

        /// <summary>
        /// Return true is not an overflow or underflow, for multiplication operations
        /// </summary>
        /// <param name="left">left operand</param>
        /// <param name="right">right operand</param>
        /// <param name="result">result</param>
        /// <returns>true if result not overflow or underflow; false if it is</returns>
        private static bool NoMultiplicativeOverOrUnderFlow(ConstantWrapper left, ConstantWrapper right, ConstantWrapper result)
        {
            // check for overflow
            bool okayToProceed = !result.IsInfinity;

            // if we still might be good, check for possible underflow
            if (okayToProceed)
            {
                // if the result is zero, we might have an underflow. But if one of the operands
                // was zero, then it's okay.
                // Inverse: if neither operand is zero, then a zero result is not okay
                okayToProceed = !result.IsZero || (left.IsZero || right.IsZero);
            }
            return okayToProceed;
        }

        /// <summary>
        /// Return true if the result isn't an overflow condition
        /// </summary>
        /// <param name="result">result constant</param>
        /// <returns>true is not an overflow; false if it is</returns>
        private static bool NoOverflow(ConstantWrapper result)
        {
            return !result.IsInfinity;
        }

        /// <summary>
        /// Evaluate: (OTHER [op] CONST) [op] CONST
        /// </summary>
        /// <param name="thisConstant">second constant</param>
        /// <param name="otherConstant">first constant</param>
        /// <param name="leftExpression">first operator</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void EvalToTheLeft(BinaryExpression node, ConstantWrapper thisConstant, ConstantWrapper otherConstant, BinaryExpression leftExpression)
        {
            if (leftExpression.OperatorToken == JSToken.Plus && node.OperatorToken == JSToken.Plus)
            {
                // plus-plus
                // the other operation goes first, so if the other constant is a string, then we know that
                // operation will do a string concatenation, which will force our operation to be a string
                // concatenation. If the other constant is not a string, then we won't know until runtime and
                // we can't combine them.
                if (otherConstant.IsStringLiteral)
                {
                    // the other constant is a string -- so we can do the string concat and combine them
                    ConstantWrapper newLiteral = StringConcat(otherConstant, thisConstant);
                    if (newLiteral != null)
                    {
                        RotateFromLeft(node, leftExpression, newLiteral);
                    }
                }
            }
            else if (leftExpression.OperatorToken == JSToken.Minus)
            {
                if (node.OperatorToken == JSToken.Plus)
                {
                    // minus-plus
                    // the minus operator goes first and will always convert to number.
                    // if our constant is not a string, then it will be a numeric addition and we can combine them.
                    // if our constant is a string, then we'll end up doing a string concat, so we can't combine
                    if (!thisConstant.IsStringLiteral)
                    {
                        // two numeric operators. a-n1+n2 is the same as a-(n1-n2)
                        ConstantWrapper newLiteral = Minus(otherConstant, thisConstant);
                        if (newLiteral != null && NoOverflow(newLiteral))
                        {
                            // a-(-n) is numerically equivalent as a+n -- and takes fewer characters to represent.
                            // BUT we can't do that because that might change a numeric operation (the original minus)
                            // to a string concatenation if the unknown operand turns out to be a string!

                            RotateFromLeft(node, leftExpression, newLiteral);
                        }
                        else
                        {
                            // if the left-left is a constant, then we can try combining with it
                            if (leftExpression.Operand1 is ConstantWrapper leftLeft)
                            {
                                EvalFarToTheLeft(node, thisConstant, leftLeft, leftExpression);
                            }
                        }
                    }
                }
                else if (node.OperatorToken == JSToken.Minus)
                {
                    // minus-minus. Both operations are numeric.
                    // (a-n1)-n2 => a-(n1+n2), so we can add the two constants and subtract from 
                    // the left-hand non-constant. 
                    ConstantWrapper newLiteral = NumericAddition(otherConstant, thisConstant);
                    if (newLiteral != null && NoOverflow(newLiteral))
                    {
                        // make it the new right-hand literal for the left-hand operator
                        // and make the left-hand operator replace our operator
                        RotateFromLeft(node, leftExpression, newLiteral);
                    }
                    else
                    {
                        // if the left-left is a constant, then we can try combining with it
                        if (leftExpression.Operand1 is ConstantWrapper leftLeft)
                        {
                            EvalFarToTheLeft(node, thisConstant, leftLeft, leftExpression);
                        }
                    }
                }
            }
            else if (leftExpression.OperatorToken == node.OperatorToken
                && (node.OperatorToken == JSToken.Multiply || node.OperatorToken == JSToken.Divide))
            {
                // either multiply-multiply or divide-divide
                // either way, we use the other operand and the product of the two constants.
                // if the product blows up to an infinte value, then don't combine them because that
                // could change the way the program goes at runtime, depending on the unknown value.
                ConstantWrapper newLiteral = Multiply(otherConstant, thisConstant);
                if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, newLiteral))
                {
                    RotateFromLeft(node, leftExpression, newLiteral);
                }
            }
            else if ((leftExpression.OperatorToken == JSToken.Multiply && node.OperatorToken == JSToken.Divide)
                || (leftExpression.OperatorToken == JSToken.Divide && node.OperatorToken == JSToken.Multiply))
            {
                if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
                {
                    // get the two division operators
                    ConstantWrapper otherOverThis = Divide(otherConstant, thisConstant);
                    ConstantWrapper thisOverOther = Divide(thisConstant, otherConstant);

                    // get the lengths
                    int otherOverThisLength = otherOverThis != null ? NodeLength(otherOverThis) : int.MaxValue;
                    int thisOverOtherLength = thisOverOther != null ? NodeLength(thisOverOther) : int.MaxValue;

                    // we'll want to use whichever one is shorter, and whichever one does NOT involve an overflow 
                    // or possible underflow
                    if (otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, otherOverThis)
                        && (thisOverOther == null || otherOverThisLength < thisOverOtherLength))
                    {
                        // but only if it's smaller than the original expression
                        if (otherOverThisLength <= NodeLength(otherConstant) + NodeLength(thisConstant) + 1)
                        {
                            // same operator
                            RotateFromLeft(node, leftExpression, otherOverThis);
                        }
                    }
                    else if (thisOverOther != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, thisOverOther))
                    {
                        // but only if it's smaller than the original expression
                        if (thisOverOtherLength <= NodeLength(otherConstant) + NodeLength(thisConstant) + 1)
                        {
                            // opposite operator
                            leftExpression.OperatorToken = leftExpression.OperatorToken == JSToken.Multiply ? JSToken.Divide : JSToken.Multiply;
                            RotateFromLeft(node, leftExpression, thisOverOther);
                        }
                    }
                }
            }
            else if (node.OperatorToken == leftExpression.OperatorToken
                && (node.OperatorToken == JSToken.BitwiseAnd || node.OperatorToken == JSToken.BitwiseOr || node.OperatorToken == JSToken.BitwiseXor))
            {
                // identical bitwise operators can be combined
                ConstantWrapper newLiteral = null;
                switch (node.OperatorToken)
                {
                    case JSToken.BitwiseAnd:
                        newLiteral = BitwiseAnd(otherConstant, thisConstant);
                        break;

                    case JSToken.BitwiseOr:
                        newLiteral = BitwiseOr(otherConstant, thisConstant);
                        break;

                    case JSToken.BitwiseXor:
                        newLiteral = BitwiseXor(otherConstant, thisConstant);
                        break;
                }
                if (newLiteral != null)
                {
                    RotateFromLeft(node, leftExpression, newLiteral);
                }
            }
        }

        /// <summary>
        /// Evaluate: (CONST [op] OTHER) [op] CONST
        /// </summary>
        /// <param name="thisConstant">second constant</param>
        /// <param name="otherConstant">first constant</param>
        /// <param name="leftExpression">first operator</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void EvalFarToTheLeft(BinaryExpression node, ConstantWrapper thisConstant, ConstantWrapper otherConstant, BinaryExpression leftExpression)
        {
            if (leftExpression.OperatorToken == JSToken.Minus)
            {
                if (node.OperatorToken == JSToken.Plus)
                {
                    // minus-plus
                    // the minus will be a numeric operator, but if this constant is a string, it will be a
                    // string concatenation and we can't combine it.
                    if (thisConstant.PrimitiveType != PrimitiveType.String && thisConstant.PrimitiveType != PrimitiveType.Other)
                    {
                        ConstantWrapper newLiteral = NumericAddition(otherConstant, thisConstant);
                        if (newLiteral != null && NoOverflow(newLiteral))
                        {
                            RotateFromRight(node, leftExpression, newLiteral);
                        }
                    }
                }
                else if (node.OperatorToken == JSToken.Minus)
                {
                    // minus-minus
                    ConstantWrapper newLiteral = Minus(otherConstant, thisConstant);
                    if (newLiteral != null && NoOverflow(newLiteral))
                    {
                        RotateFromRight(node, leftExpression, newLiteral);
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Multiply)
            {
                if (leftExpression.OperatorToken == JSToken.Multiply || leftExpression.OperatorToken == JSToken.Divide)
                {
                    ConstantWrapper newLiteral = Multiply(otherConstant, thisConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, newLiteral))
                    {
                        RotateFromRight(node, leftExpression, newLiteral);
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Divide)
            {
                if (leftExpression.OperatorToken == JSToken.Divide)
                {
                    // divide-divide
                    ConstantWrapper newLiteral = Divide(otherConstant, thisConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, newLiteral)
                        && NodeLength(newLiteral) <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                    {
                        RotateFromRight(node, leftExpression, newLiteral);
                    }
                }
                else if (leftExpression.OperatorToken == JSToken.Multiply)
                {
                    // mult-divide
                    ConstantWrapper otherOverThis = Divide(otherConstant, thisConstant);
                    ConstantWrapper thisOverOther = Divide(thisConstant, otherConstant);

                    int otherOverThisLength = otherOverThis != null ? NodeLength(otherOverThis) : int.MaxValue;
                    int thisOverOtherLength = thisOverOther != null ? NodeLength(thisOverOther) : int.MaxValue;

                    if (otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, otherOverThis)
                        && (thisOverOther == null || otherOverThisLength < thisOverOtherLength))
                    {
                        if (otherOverThisLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            RotateFromRight(node, leftExpression, otherOverThis);
                        }
                    }
                    else if (thisOverOther != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, thisOverOther))
                    {
                        if (thisOverOtherLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            // swap the operands
                            leftExpression.SwapOperands();

                            // operator is the opposite
                            leftExpression.OperatorToken = JSToken.Divide;
                            RotateFromLeft(node, leftExpression, thisOverOther);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Evaluate: CONST [op] (CONST [op] OTHER)
        /// </summary>
        /// <param name="thisConstant">first constant</param>
        /// <param name="otherConstant">second constant</param>
        /// <param name="leftOperator">second operator</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void EvalToTheRight(BinaryExpression node, ConstantWrapper thisConstant, ConstantWrapper otherConstant, BinaryExpression rightExpression)
        {
            if (node.OperatorToken == JSToken.Plus)
            {
                if (rightExpression.OperatorToken == JSToken.Plus && otherConstant.IsStringLiteral)
                {
                    // plus-plus, and the other constant is a string. So the right operator will be a string-concat
                    // that generates a string. And since this is a plus-operator, then this operator will be a string-
                    // concat as well. So we can just combine the strings now and replace our node with the right-hand 
                    // operation
                    ConstantWrapper newLiteral = StringConcat(thisConstant, otherConstant);
                    if (newLiteral != null)
                    {
                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                }
                else if (rightExpression.OperatorToken == JSToken.Minus && !thisConstant.IsStringLiteral)
                {
                    // plus-minus. Now, the minus operation happens first, and it will perform a numeric
                    // operation. The plus is NOT string, so that means it will also be a numeric operation
                    // and we can combine the operators numericly. 
                    ConstantWrapper newLiteral = NumericAddition(thisConstant, otherConstant);
                    if (newLiteral != null && NoOverflow(newLiteral))
                    {
                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                    else
                    {
                        if (rightExpression.Operand2 is ConstantWrapper rightRight)
                        {
                            EvalFarToTheRight(node, thisConstant, rightRight, rightExpression);
                        }
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Minus && rightExpression.OperatorToken == JSToken.Minus)
            {
                // minus-minus
                // both operations are numeric, so we can combine the constant operands. However, we 
                // can't combine them into a plus, so make sure we do the minus in the opposite direction
                ConstantWrapper newLiteral = Minus(otherConstant, thisConstant);
                if (newLiteral != null && NoOverflow(newLiteral))
                {
                    rightExpression.SwapOperands();
                    RotateFromLeft(node, rightExpression, newLiteral);
                }
                else
                {
                    if (rightExpression.Operand2 is ConstantWrapper rightRight)
                    {
                        EvalFarToTheRight(node, thisConstant, rightRight, rightExpression);
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Multiply
                && (rightExpression.OperatorToken == JSToken.Multiply || rightExpression.OperatorToken == JSToken.Divide))
            {
                // multiply-divide or multiply-multiply
                // multiply the operands and use the right-hand operator
                ConstantWrapper newLiteral = Multiply(thisConstant, otherConstant);
                if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, newLiteral))
                {
                    RotateFromRight(node, rightExpression, newLiteral);
                }
            }
            else if (node.OperatorToken == JSToken.Divide)
            {
                if (rightExpression.OperatorToken == JSToken.Multiply)
                {
                    // divide-multiply
                    ConstantWrapper newLiteral = Divide(thisConstant, otherConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, newLiteral)
                        && NodeLength(newLiteral) < NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                    {
                        // flip the operator: multiply becomes divide; devide becomes multiply
                        rightExpression.OperatorToken = JSToken.Divide;

                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                }
                else if (rightExpression.OperatorToken == JSToken.Divide)
                {
                    // divide-divide
                    // get constants for left/right and for right/left
                    ConstantWrapper leftOverRight = Divide(thisConstant, otherConstant);
                    ConstantWrapper rightOverLeft = Divide(otherConstant, thisConstant);

                    // get the lengths of the resulting code
                    int leftOverRightLength = leftOverRight != null ? NodeLength(leftOverRight) : int.MaxValue;
                    int rightOverLeftLength = rightOverLeft != null ? NodeLength(rightOverLeft) : int.MaxValue;

                    // try whichever is smaller
                    if (leftOverRight != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, leftOverRight)
                        && (rightOverLeft == null || leftOverRightLength < rightOverLeftLength))
                    {
                        // use left-over-right. 
                        // but only if the resulting value is smaller than the original expression
                        if (leftOverRightLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            // We don't need to swap the operands, but we do need to switch the operator
                            rightExpression.OperatorToken = JSToken.Multiply;
                            RotateFromRight(node, rightExpression, leftOverRight);
                        }
                    }
                    else if (rightOverLeft != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, rightOverLeft))
                    {
                        // but only if the resulting value is smaller than the original expression
                        if (rightOverLeftLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            // use right-over-left. Keep the operator, but swap the operands
                            rightExpression.SwapOperands();
                            RotateFromLeft(node, rightExpression, rightOverLeft);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Eval the two constants: CONST [op] (OTHER [op] CONST)
        /// </summary>
        /// <param name="thisConstant">first constant</param>
        /// <param name="otherConstant">second constant</param>
        /// <param name="rightExpression">second operator</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void EvalFarToTheRight(BinaryExpression node, ConstantWrapper thisConstant, ConstantWrapper otherConstant, BinaryExpression rightExpression)
        {
            if (rightExpression.OperatorToken == JSToken.Minus)
            {
                if (node.OperatorToken == JSToken.Plus)
                {
                    // plus-minus
                    // our constant cannot be a string, though
                    if (!thisConstant.IsStringLiteral)
                    {
                        ConstantWrapper newLiteral = Minus(otherConstant, thisConstant);
                        if (newLiteral != null && NoOverflow(newLiteral))
                        {
                            RotateFromLeft(node, rightExpression, newLiteral);
                        }
                    }
                }
                else if (node.OperatorToken == JSToken.Minus)
                {
                    // minus-minus
                    ConstantWrapper newLiteral = NumericAddition(thisConstant, otherConstant);
                    if (newLiteral != null && NoOverflow(newLiteral))
                    {
                        // but we need to swap the left and right operands first
                        rightExpression.SwapOperands();

                        // then rotate the node up after replacing old with new
                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Multiply)
            {
                if (rightExpression.OperatorToken == JSToken.Multiply)
                {
                    // mult-mult
                    ConstantWrapper newLiteral = Multiply(thisConstant, otherConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, newLiteral))
                    {
                        RotateFromLeft(node, rightExpression, newLiteral);
                    }
                }
                else if (rightExpression.OperatorToken == JSToken.Divide)
                {
                    // mult-divide
                    ConstantWrapper otherOverThis = Divide(otherConstant, thisConstant);
                    ConstantWrapper thisOverOther = Divide(thisConstant, otherConstant);

                    int otherOverThisLength = otherOverThis != null ? NodeLength(otherOverThis) : int.MaxValue;
                    int thisOverOtherLength = thisOverOther != null ? NodeLength(thisOverOther) : int.MaxValue;

                    if (otherOverThis != null && NoMultiplicativeOverOrUnderFlow(otherConstant, thisConstant, otherOverThis)
                        && (thisOverOther == null || otherOverThisLength < thisOverOtherLength))
                    {
                        if (otherOverThisLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            // swap the operands, but keep the operator
                            RotateFromLeft(node, rightExpression, otherOverThis);
                        }
                    }
                    else if (thisOverOther != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, thisOverOther))
                    {
                        if (thisOverOtherLength <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                        {
                            // swap the operands and opposite operator
                            rightExpression.SwapOperands();
                            rightExpression.OperatorToken = JSToken.Multiply;
                            RotateFromRight(node, rightExpression, thisOverOther);
                        }
                    }
                }
            }
            else if (node.OperatorToken == JSToken.Divide)
            {
                if (rightExpression.OperatorToken == JSToken.Multiply)
                {
                    // divide-mult
                    ConstantWrapper newLiteral = Divide(thisConstant, otherConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, newLiteral)
                        && NodeLength(newLiteral) <= NodeLength(thisConstant) + NodeLength(otherConstant) + 1)
                    {
                        // swap the operands
                        rightExpression.SwapOperands();

                        // change the operator
                        rightExpression.OperatorToken = JSToken.Divide;
                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                }
                else if (rightExpression.OperatorToken == JSToken.Divide)
                {
                    // divide-divide
                    ConstantWrapper newLiteral = Multiply(thisConstant, otherConstant);
                    if (newLiteral != null && NoMultiplicativeOverOrUnderFlow(thisConstant, otherConstant, newLiteral))
                    {
                        // but we need to swap the left and right operands first
                        rightExpression.SwapOperands();

                        // then rotate the node up after replacing old with new
                        RotateFromRight(node, rightExpression, newLiteral);
                    }
                }
            }
        }

        #endregion

        #region Constant operation methods

        private ConstantWrapper Multiply(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsOkayToCombine && right.IsOkayToCombine
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    double leftValue = left.ToNumber();
                    double rightValue = right.ToNumber();
                    double result = leftValue * rightValue;

                    if (ConstantWrapper.NumberIsOkayToCombine(result))
                    {
                        newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                    }
                    else
                    {
                        if (!left.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(leftValue))
                        {
                            left.Parent.ReplaceChild(left, new ConstantWrapper(leftValue, PrimitiveType.Number, left.Context));
                        }
                        if (!right.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(rightValue))
                        {
                            right.Parent.ReplaceChild(right, new ConstantWrapper(rightValue, PrimitiveType.Number, right.Context));
                        }
                    }
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper Divide(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsOkayToCombine && right.IsOkayToCombine
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    double leftValue = left.ToNumber();
                    double rightValue = right.ToNumber();
                    double result = leftValue / rightValue;

                    if (ConstantWrapper.NumberIsOkayToCombine(result))
                    {
                        newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                    }
                    else
                    {
                        if (!left.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(leftValue))
                        {
                            left.Parent.ReplaceChild(left, new ConstantWrapper(leftValue, PrimitiveType.Number, left.Context));
                        }
                        if (!right.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(rightValue))
                        {
                            right.Parent.ReplaceChild(right, new ConstantWrapper(rightValue, PrimitiveType.Number, right.Context));
                        }
                    }
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper Modulo(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsOkayToCombine && right.IsOkayToCombine
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    double leftValue = left.ToNumber();
                    double rightValue = right.ToNumber();
                    double result = leftValue % rightValue;

                    if (ConstantWrapper.NumberIsOkayToCombine(result))
                    {
                        newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                    }
                    else
                    {
                        if (!left.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(leftValue))
                        {
                            left.Parent.ReplaceChild(left, new ConstantWrapper(leftValue, PrimitiveType.Number, left.Context));
                        }
                        if (!right.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(rightValue))
                        {
                            right.Parent.ReplaceChild(right, new ConstantWrapper(rightValue, PrimitiveType.Number, right.Context));
                        }
                    }
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper Plus(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsStringLiteral || right.IsStringLiteral)
            {
                // one or both are strings -- this is a strng concat operation
                newLiteral = StringConcat(left, right);
            }
            else
            {
                // neither are strings -- this is a numeric addition operation
                newLiteral = NumericAddition(left, right);
            }
            return newLiteral;
        }

        private ConstantWrapper NumericAddition(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsOkayToCombine && right.IsOkayToCombine
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    double leftValue = left.ToNumber();
                    double rightValue = right.ToNumber();
                    double result = leftValue + rightValue;

                    if (ConstantWrapper.NumberIsOkayToCombine(result))
                    {
                        newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                    }
                    else
                    {
                        if (!left.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(leftValue))
                        {
                            left.Parent.ReplaceChild(left, new ConstantWrapper(leftValue, PrimitiveType.Number, left.Context));
                        }
                        if (!right.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(rightValue))
                        {
                            right.Parent.ReplaceChild(right, new ConstantWrapper(rightValue, PrimitiveType.Number, right.Context));
                        }
                    }
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper StringConcat(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            // if we don't want to combine adjacent string literals, then we know we don't want to do
            // anything here.
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.CombineAdjacentStringLiterals))
            {
                // if either one of the operands is not a string literal, then check to see if we allow
                // evaluation of numeric expression; if not, then no-go. IF they are both string literals,
                // then it doesn't matter what the numeric flag says.
                if ((left.IsStringLiteral && right.IsStringLiteral)
                    || m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
                {
                    // if either value is a floating-point number (a number, not NaN, not Infinite, not an Integer),
                    // then we won't do the string concatenation because different browsers may have subtle differences
                    // in their double-to-string conversion algorithms.
                    // so if neither is a numeric literal, or if one or both are, if they are both integer literals
                    // in the range that we can EXACTLY represent them in a double, then we can proceed.
                    // NaN, +Infinity and -Infinity are also acceptable
                    if (left.IsOkayToCombine && right.IsOkayToCombine)
                    {
                        newLiteral = new ConstantWrapper(left.Concat(right), PrimitiveType.String, left.Context.FlattenToStart());
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper Minus(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (left.IsOkayToCombine && right.IsOkayToCombine
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    double leftValue = left.ToNumber();
                    double rightValue = right.ToNumber();
                    double result = leftValue - rightValue;

                    if (ConstantWrapper.NumberIsOkayToCombine(result))
                    {
                        newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                    }
                    else
                    {
                        if (!left.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(leftValue))
                        {
                            left.Parent.ReplaceChild(left, new ConstantWrapper(leftValue, PrimitiveType.Number, left.Context));
                        }
                        if (!right.IsNumericLiteral && ConstantWrapper.NumberIsOkayToCombine(rightValue))
                        {
                            right.Parent.ReplaceChild(right, new ConstantWrapper(rightValue, PrimitiveType.Number, right.Context));
                        }
                    }
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper LeftShift(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    // left-hand value is a 32-bit signed integer
                    Int32 lvalue = left.ToInt32();

                    // mask only the bottom 5 bits of the right-hand value
                    int rvalue = (int)(right.ToUInt32() & 0x1F);

                    // convert the result to a double
                    double result = Convert.ToDouble(lvalue << rvalue);
                    newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }
            return newLiteral;
        }

        private ConstantWrapper RightShift(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    // left-hand value is a 32-bit signed integer
                    Int32 lvalue = left.ToInt32();

                    // mask only the bottom 5 bits of the right-hand value
                    int rvalue = (int)(right.ToUInt32() & 0x1F);

                    // convert the result to a double
                    double result = Convert.ToDouble(lvalue >> rvalue);
                    newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper UnsignedRightShift(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    // left-hand value is a 32-bit signed integer
                    UInt32 lvalue = left.ToUInt32();

                    // mask only the bottom 5 bits of the right-hand value
                    int rvalue = (int)(right.ToUInt32() & 0x1F);

                    // convert the result to a double
                    double result = Convert.ToDouble(lvalue >> rvalue);
                    newLiteral = new ConstantWrapper(result, PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper LessThan(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                if (left.IsStringLiteral && right.IsStringLiteral)
                {
                    if (left.IsOkayToCombine && right.IsOkayToCombine)
                    {
                        // do a straight ordinal comparison of the strings
                        newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) < 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                }
                else
                {
                    try
                    {
                        // either one or both are NOT a string -- numeric comparison
                        if (left.IsOkayToCombine && right.IsOkayToCombine)
                        {
                            newLiteral = new ConstantWrapper(left.ToNumber() < right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }
            return newLiteral;
        }

        private ConstantWrapper LessThanOrEqual(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                if (left.IsStringLiteral && right.IsStringLiteral)
                {
                    if (left.IsOkayToCombine && right.IsOkayToCombine)
                    {
                        // do a straight ordinal comparison of the strings
                        newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) <= 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                }
                else
                {
                    try
                    {
                        // either one or both are NOT a string -- numeric comparison
                        if (left.IsOkayToCombine && right.IsOkayToCombine)
                        {
                            newLiteral = new ConstantWrapper(left.ToNumber() <= right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper GreaterThan(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                if (left.IsStringLiteral && right.IsStringLiteral)
                {
                    if (left.IsOkayToCombine && right.IsOkayToCombine)
                    {
                        // do a straight ordinal comparison of the strings
                        newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) > 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                }
                else
                {
                    try
                    {
                        // either one or both are NOT a string -- numeric comparison
                        if (left.IsOkayToCombine && right.IsOkayToCombine)
                        {
                            newLiteral = new ConstantWrapper(left.ToNumber() > right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper GreaterThanOrEqual(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                if (left.IsStringLiteral && right.IsStringLiteral)
                {
                    if (left.IsOkayToCombine && right.IsOkayToCombine)
                    {
                        // do a straight ordinal comparison of the strings
                        newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) >= 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                }
                else
                {
                    try
                    {
                        // either one or both are NOT a string -- numeric comparison
                        if (left.IsOkayToCombine && right.IsOkayToCombine)
                        {
                            newLiteral = new ConstantWrapper(left.ToNumber() >= right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper Equal(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                PrimitiveType leftType = left.PrimitiveType;
                if (leftType == right.PrimitiveType)
                {
                    // the values are the same type
                    switch (leftType)
                    {
                        case PrimitiveType.Null:
                            // null == null is true
                            newLiteral = new ConstantWrapper(true, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.Boolean:
                            // compare boolean values
                            newLiteral = new ConstantWrapper(left.ToBoolean() == right.ToBoolean(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.String:
                            // compare string ordinally
                            if (left.IsOkayToCombine && right.IsOkayToCombine)
                            {
                                newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) == 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            }
                            break;

                        case PrimitiveType.Number:
                            try
                            {
                                // compare the values
                                // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                                // and NaN is always unequal to everything else, including itself.
                                if (left.IsOkayToCombine && right.IsOkayToCombine)
                                {
                                    newLiteral = new ConstantWrapper(left.ToNumber() == right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                                }
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                            break;
                    }
                }
                else if (left.IsOkayToCombine && right.IsOkayToCombine)
                {
                    try
                    {
                        // numeric comparison
                        // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                        // and NaN is always unequal to everything else, including itself.
                        newLiteral = new ConstantWrapper(left.ToNumber() == right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper NotEqual(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                PrimitiveType leftType = left.PrimitiveType;
                if (leftType == right.PrimitiveType)
                {
                    // the values are the same type
                    switch (leftType)
                    {
                        case PrimitiveType.Null:
                            // null != null is false
                            newLiteral = new ConstantWrapper(false, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.Boolean:
                            // compare boolean values
                            newLiteral = new ConstantWrapper(left.ToBoolean() != right.ToBoolean(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.String:
                            // compare string ordinally
                            if (left.IsOkayToCombine && right.IsOkayToCombine)
                            {
                                newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) != 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            }
                            break;

                        case PrimitiveType.Number:
                            try
                            {
                                // compare the values
                                // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                                // and NaN is always unequal to everything else, including itself.
                                if (left.IsOkayToCombine && right.IsOkayToCombine)
                                {
                                    newLiteral = new ConstantWrapper(left.ToNumber() != right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                                }
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                            break;
                    }
                }
                else if (left.IsOkayToCombine && right.IsOkayToCombine)
                {
                    try
                    {
                        // numeric comparison
                        // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                        // and NaN is always unequal to everything else, including itself.
                        newLiteral = new ConstantWrapper(left.ToNumber() != right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                    }
                    catch (InvalidCastException)
                    {
                        // some kind of casting in ToNumber caused a situation where we don't want
                        // to perform the combination on these operands
                    }
                }
            }

            return newLiteral;
        }

        private ConstantWrapper StrictEqual(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                PrimitiveType leftType = left.PrimitiveType;
                if (leftType == right.PrimitiveType)
                {
                    // the values are the same type
                    switch (leftType)
                    {
                        case PrimitiveType.Null:
                            // null === null is true
                            newLiteral = new ConstantWrapper(true, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.Boolean:
                            // compare boolean values
                            newLiteral = new ConstantWrapper(left.ToBoolean() == right.ToBoolean(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.String:
                            // compare string ordinally
                            if (left.IsOkayToCombine && right.IsOkayToCombine)
                            {
                                newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) == 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            }
                            break;

                        case PrimitiveType.Number:
                            try
                            {
                                // compare the values
                                // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                                // and NaN is always unequal to everything else, including itself.
                                if (left.IsOkayToCombine && right.IsOkayToCombine)
                                {
                                    newLiteral = new ConstantWrapper(left.ToNumber() == right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                                }
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                            break;
                    }
                }
                else
                {
                    // if they aren't the same type, they ain't equal
                    newLiteral = new ConstantWrapper(false, PrimitiveType.Boolean, left.Context.FlattenToStart());
                }
            }

            return newLiteral;
        }

        private ConstantWrapper StrictNotEqual(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                PrimitiveType leftType = left.PrimitiveType;
                if (leftType == right.PrimitiveType)
                {
                    // the values are the same type
                    switch (leftType)
                    {
                        case PrimitiveType.Null:
                            // null !== null is false
                            newLiteral = new ConstantWrapper(false, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.Boolean:
                            // compare boolean values
                            newLiteral = new ConstantWrapper(left.ToBoolean() != right.ToBoolean(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                            break;

                        case PrimitiveType.String:
                            // compare string ordinally
                            if (left.IsOkayToCombine && right.IsOkayToCombine)
                            {
                                newLiteral = new ConstantWrapper(string.CompareOrdinal(left.ToString(), right.ToString()) != 0, PrimitiveType.Boolean, left.Context.FlattenToStart());
                            }
                            break;

                        case PrimitiveType.Number:
                            try
                            {
                                // compare the values
                                // +0 and -0 are treated as "equal" in C#, so we don't need to test them separately.
                                // and NaN is always unequal to everything else, including itself.
                                if (left.IsOkayToCombine && right.IsOkayToCombine)
                                {
                                    newLiteral = new ConstantWrapper(left.ToNumber() != right.ToNumber(), PrimitiveType.Boolean, left.Context.FlattenToStart());
                                }
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                            break;
                    }
                }
                else
                {
                    // if they aren't the same type, they are not equal
                    newLiteral = new ConstantWrapper(true, PrimitiveType.Boolean, left.Context.FlattenToStart());
                }
            }

            return newLiteral;
        }

        private ConstantWrapper BitwiseAnd(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    Int32 lValue = left.ToInt32();
                    Int32 rValue = right.ToInt32();
                    newLiteral = new ConstantWrapper(Convert.ToDouble(lValue & rValue), PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper BitwiseOr(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    Int32 lValue = left.ToInt32();
                    Int32 rValue = right.ToInt32();
                    newLiteral = new ConstantWrapper(Convert.ToDouble(lValue | rValue), PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper BitwiseXor(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;

            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    Int32 lValue = left.ToInt32();
                    Int32 rValue = right.ToInt32();
                    newLiteral = new ConstantWrapper(Convert.ToDouble(lValue ^ rValue), PrimitiveType.Number, left.Context.FlattenToStart());
                }
                catch (InvalidCastException)
                {
                    // some kind of casting in ToNumber caused a situation where we don't want
                    // to perform the combination on these operands
                }
            }

            return newLiteral;
        }

        private ConstantWrapper LogicalAnd(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    // if the left-hand side evaluates to true, return the right-hand side.
                    // if the left-hand side is false, return it.
                    newLiteral = left.ToBoolean() ? right : left;
                }
                catch (InvalidCastException)
                {
                    // if we couldn't cast to bool, ignore
                }
            }

            return newLiteral;
        }

        private ConstantWrapper LogicalOr(ConstantWrapper left, ConstantWrapper right)
        {
            ConstantWrapper newLiteral = null;
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                try
                {
                    // if the left-hand side evaluates to true, return the left-hand side.
                    // if the left-hand side is false, return the right-hand side.
                    newLiteral = left.ToBoolean() ? left : right;
                }
                catch (InvalidCastException)
                {
                    // if we couldn't cast to bool, ignore
                }
            }

            return newLiteral;
        }

        private static bool OnlyHasConstantItems(ArrayLiteral arrayLiteral)
        {
            var elementCount = arrayLiteral.Elements.Count;
            for (var ndx = 0; ndx < elementCount; ++ndx)
            {
                // if any one element isn't a constant or isn't safe for combination, then bail with false
                var constantWrapper = arrayLiteral.Elements[ndx] as ConstantWrapper;
                if (constantWrapper == null || !constantWrapper.IsOkayToCombine)
                {
                    return false;
                }
            }

            // if we get here, they were all constant
            return true;
        }

        private static string ComputeJoin(ArrayLiteral arrayLiteral, ConstantWrapper separatorNode)
        {
            // if the separator node is null, then the separator is a single comma character.
            // otherwise it's just the string value of the separator.
            var separator = separatorNode == null ? "," : separatorNode.ToString();

            var sb = StringBuilderPool.Acquire();
            try
            {
                for (var ndx = 0; ndx < arrayLiteral.Elements.Count; ++ndx)
                {
                    // add the separator between items (if we have one)
                    if (ndx > 0 && !string.IsNullOrEmpty(separator))
                    {
                        sb.Append(separator);
                    }

                    // the element is a constant wrapper (we wouldn't get this far if it wasn't),
                    // but we've overloaded the virtual ToString method on ConstantWrappers to convert the
                    // constant value to a string value.
                    sb.Append(arrayLiteral.Elements[ndx].ToString());
                }

                return sb.ToString();
            }
            finally
            {
                sb.Release();
            }
        }

        #endregion

        private int NodeLength(AstNode node)
        {
            var code = OutputVisitor.Apply(node, m_parser.Settings);
            return code.IfNotNull(c => c.Length);
        }

        //
        // IVisitor implementations
        //

        public override void Visit(AstNodeList node)
        {
            if (node != null)
            {
                AstNodeList list;

                if (node.Parent is CommaExpression commaOperator
                    && (list = commaOperator.Operand2 as AstNodeList) != null)
                {
                    // this list is part of a comma-operator, which is a collection of contiguous
                    // expression statements that we combined together. What we want to do is
                    // delete all constant elements from the list.
                    // if the parent is a block, then this was just a collection of statements and
                    // we can delete ALL constant expressions. But if the parent is not a block, then
                    // we will want to keep the last one as-is because it is the return value of the
                    // overall expression.
                    for (var ndx = list.Count - (node.Parent is BlockStatement ? 1 : 2); ndx >= 0; --ndx)
                    {
                        if (list[ndx] is ConstantWrapper)
                        {
                            list.RemoveAt(ndx);
                        }
                    }

                }

                // then normally recurse whatever is left over
                base.Visit(node);
            }
        }

        public override void Visit(BinaryExpression node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                // then evaluate.
                // do it in a separate method than this one because if this method
                // allocates a lot of bytes on the stack, we'll overflow our stack for
                // code that has lots of expression statements that get converted into one
                // BIG, uber-nested set of comma operators.
                DoBinaryOperator(node);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void DoBinaryOperator(BinaryExpression node)
        {
            if (m_parser.Settings.EvalLiteralExpressions)
            {
                // if this is an assign operator, an in, or an instanceof, then we won't
                // try to evaluate it
                if (!node.IsAssign && node.OperatorToken != JSToken.In && node.OperatorToken != JSToken.InstanceOf)
                {
                    if (node.OperatorToken == JSToken.StrictEqual || node.OperatorToken == JSToken.StrictNotEqual)
                    {
                        // the operator is a strict equality (or not-equal).
                        // check the primitive types of the two operands -- if they are known but not the same, we can
                        // shortcut the whole process by just replacing this node with a boolean literal.
                        var leftType = node.Operand1.FindPrimitiveType();
                        if (leftType != PrimitiveType.Other)
                        {
                            var rightType = node.Operand2.FindPrimitiveType();
                            if (rightType != PrimitiveType.Other)
                            {
                                // both sides are known
                                if (leftType != rightType)
                                {
                                    // they are not the same type -- replace with a boolean and bail
                                    ReplaceNodeWithLiteral(
                                        node, 
                                        new ConstantWrapper(node.OperatorToken == JSToken.StrictEqual ? false : true, PrimitiveType.Boolean, node.Context));
                                    return;
                                }

                                // they are the same type -- we can change the operator to simple equality/not equality
                                node.OperatorToken = node.OperatorToken == JSToken.StrictEqual ? JSToken.Equal : JSToken.NotEqual;
                            }
                        }
                    }

                    // see if the left operand is a literal number, boolean, string, or null
                    if (node.Operand1 is ConstantWrapper left)
                    {
                        if (node.OperatorToken == JSToken.Comma)
                        {
                            // the comma operator evaluates the left, then evaluates the right and returns it.                            // but if the left is a literal, evaluating it doesn't DO anything, so we can replace the                            // entire operation with the right-hand operand
                            if (node.Operand2 is ConstantWrapper rightConstant)
                            {
                                // we'll replace the operator with the right-hand operand, BUT it's a constant, too.
                                // first check to see if replacing this node with a constant will result in creating
                                // a member-bracket operator that can be turned into a member-dot. If it is, then that
                                // method will handle the replacement. But if it doesn't, then we should just replace
                                // the comma with the right-hand operand.
                                if (!ReplaceMemberBracketWithDot(node, rightConstant))
                                {
                                    ReplaceNodeWithLiteral(node, rightConstant);
                                }
                            }
                            else if (node is CommaExpression)
                            {
                                // this is a collection of expression statements that we've joined together as
                                // an extended comma operator. 
                                var list = node.Operand2 as AstNodeList;
                                if (list == null)
                                {
                                    // Check that the right operand is not an eval lookup as in (0, eval)('this');
                                    // In this case, we cannot simplify the expression and we have to let the eval
                                    // inside the CommaExpression.
                                    if (!IsEvalLookup(node.Operand2))
                                    {
                                        // not a list, just a single item, so we can just
                                        // replace this entire node with the one element
                                        ReplaceNodeCheckParens(node, node.Operand2);
                                    }
                                }
                                else if (list.Count == 1)
                                {
                                    // If the list has a single element, then we can just
                                    // replace this entire node with the one element
                                    if (!IsEvalLookup(list[0]))
                                    {
                                        ReplaceNodeCheckParens(node, list[0]);
                                    }
                                }
                                else if (list.Count == 0)
                                {
                                    // the recursion ended up emptying the list, so we can just delete
                                    // this node altogether
                                    ReplaceNodeCheckParens(node, null);
                                }
                                else
                                {
                                    // more than one item in the list
                                    // move the first item from the list to the left-hand side
                                    var firstItem = list[0];
                                    list.RemoveAt(0);
                                    node.Operand1 = firstItem;

                                    // if there's only one item left in the list, we can get rid of the
                                    // extra list node and make it just the remaining node
                                    if (list.Count == 1)
                                    {
                                        firstItem = list[0];
                                        list.RemoveAt(0);
                                        node.Operand2 = firstItem;
                                    }
                                }
                            }
                            else
                            {
                                // replace the comma operator with the right-hand operand
                                ReplaceNodeCheckParens(node, node.Operand2);
                            }
                        }
                        else
                        {
                            // see if the right operand is a literal number, boolean, string, or null
                            if (node.Operand2 is ConstantWrapper right)
                            {
                                // then they are both constants and we can evaluate the operation
                                EvalThisOperator(node, left, right);
                            }
                            else
                            {
                                // see if the right is a binary operator that can be combined with ours
                                if (node.Operand2 is BinaryExpression rightBinary)
                                {
                                    if (rightBinary.Operand1 is ConstantWrapper rightLeft)
                                    {
                                        // eval our left and the right-hand binary's left and put the combined operation as
                                        // the child of the right-hand binary
                                        EvalToTheRight(node, left, rightLeft, rightBinary);
                                    }
                                    else
                                    {
                                        if (rightBinary.Operand2 is ConstantWrapper rightRight)
                                        {
                                            EvalFarToTheRight(node, left, rightRight, rightBinary);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        // left is not a constantwrapper. See if the right is
                        if (node.Operand2 is ConstantWrapper right)
                        {
                            // the right is a constant. See if the the left is a binary operator...
                            if (node.Operand1 is BinaryExpression leftBinary)
                            {
                                // ...with a constant on the right, and the operators can be combined
                                if (leftBinary.Operand2 is ConstantWrapper leftRight)
                                {
                                    EvalToTheLeft(node, right, leftRight, leftBinary);
                                }
                                else
                                {
                                    if (leftBinary.Operand1 is ConstantWrapper leftLeft)
                                    {
                                        EvalFarToTheLeft(node, right, leftLeft, leftBinary);
                                    }
                                }
                            }
                            else if (m_parser.Settings.IsModificationAllowed(TreeModifications.SimplifyStringToNumericConversion))
                            {
                                // see if it's a lookup and this is a minus operation and the constant is a zero
                                if (node.Operand1 is LookupExpression lookup && node.OperatorToken == JSToken.Minus && right.IsIntegerLiteral && right.ToNumber() == 0)
                                {
                                    // okay, so we have "lookup - 0"
                                    // this is done frequently to force a value to be numeric. 
                                    // There is an easier way: apply the unary + operator to it. 
                                    var unary = new UnaryExpression(node.Context)
                                        {
                                            Operand = lookup,
                                            OperatorToken = JSToken.Plus
                                        };
                                    ReplaceNodeCheckParens(node, unary);
                                }
                            }
                        }
                        // TODO: shouldn't we check if they BOTH are binary operators? (a*6)*(5*b) ==> a*30*b (for instance)
                    }
                }
            }
        }

        private bool IsEvalLookup(AstNode node)
        {
            return node is LookupExpression lookupExpression && lookupExpression.Name == "eval";
        }

        public override void Visit(CallExpression node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                // if this isn't a constructor and it isn't a member-brackets operator
                if (!node.IsConstructor && !node.InBrackets)
                {
                    // check to see if this is a call of certain member functions
                    if (node.Function is MemberExpression member)
                    {
                        if (string.CompareOrdinal(member.Name, "join") == 0 && node.Arguments.Count <= 1
                            && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateLiteralJoins))
                        {
                            // this is a call to join with zero or one argument (no more)                            // see if the root is an array literal that has no issues
                            if (member.Root is ArrayLiteral arrayLiteral && !arrayLiteral.MayHaveIssues)
                            {
                                // it is -- make sure the separator is either not specified or is a constant
                                ConstantWrapper separator = null;
                                if (node.Arguments.Count == 0 || (separator = node.Arguments[0] as ConstantWrapper) != null)
                                {
                                    // and the array literal must contain only constant items
                                    if (OnlyHasConstantItems(arrayLiteral))
                                    {
                                        // last test: compute the combined string and only use it if it's actually
                                        // shorter than the original code
                                        var combinedJoin = ComputeJoin(arrayLiteral, separator);
                                        if (combinedJoin.Length + 2 < NodeLength(node))
                                        {
                                            // transform: [c,c,c].join(s) => "cscsc"
                                            ReplaceNodeWithLiteral(node, 
                                                new ConstantWrapper(combinedJoin, PrimitiveType.String, node.Context));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        public override void Visit(Conditional node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoConditional(node);
            }
        }

        private void DoConditional(Conditional node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                // if the condition is a literal, evaluating the condition doesn't do anything, AND                // we know now whether it's true or not.
                if (node.Condition is ConstantWrapper literalCondition)
                {
                    try
                    {
                        // if the boolean represenation of the literal is true, we can replace the condition operator
                        // with the true expression; otherwise we can replace it with the false expression
                        ReplaceNodeCheckParens(node, literalCondition.ToBoolean() ? node.TrueExpression : node.FalseExpression);
                    }
                    catch (InvalidCastException)
                    {
                        // ignore any invalid cast errors
                    }
                }
            }
        }

        public override void Visit(ConditionalCompilationElseIf node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoConditionalCompilationElseIf(node);
            }
        }

        private void DoConditionalCompilationElseIf(ConditionalCompilationElseIf node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                // if the if-condition is a constant, we can eliminate one of the two branches
                if (node.Condition is ConstantWrapper constantCondition)
                {
                    // instead, replace the condition with a 1 if it's always true or a 0 if it's always false
                    if (constantCondition.IsNotOneOrPositiveZero)
                    {
                        try
                        {
                            node.Condition =
                                new ConstantWrapper(constantCondition.ToBoolean() ? 1 : 0, PrimitiveType.Number, node.Condition.Context);
                        }
                        catch (InvalidCastException)
                        {
                            // ignore any invalid cast exceptions
                        }
                    }
                }
            }
        }

        public override void Visit(ConditionalCompilationIf node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoConditionalCompilationIf(node);
            }
        }

        private void DoConditionalCompilationIf(ConditionalCompilationIf node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                // if the if-condition is a constant, we can eliminate one of the two branches
                if (node.Condition is ConstantWrapper constantCondition)
                {
                    // instead, replace the condition with a 1 if it's always true or a 0 if it's always false
                    if (constantCondition.IsNotOneOrPositiveZero)
                    {
                        try
                        {
                            node.Condition =
                                new ConstantWrapper(constantCondition.ToBoolean() ? 1 : 0, PrimitiveType.Number, node.Condition.Context);
                        }
                        catch (InvalidCastException)
                        {
                            // ignore any invalid cast exceptions
                        }
                    }
                }
            }
        }

        public override void Visit(DoWhileStatement node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoDoWhile(node);
            }
        }

        private void DoDoWhile(DoWhileStatement node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                // if the condition is a constant, we can simplify things
                if (node.Condition is ConstantWrapper constantCondition && constantCondition.IsNotOneOrPositiveZero)
                {
                    try
                    {
                        // the condition is a constant, so it is always either true or false
                        // we can replace the condition with a one or a zero -- only one byte
                        node.Condition =
                            new ConstantWrapper(constantCondition.ToBoolean() ? 1 : 0, PrimitiveType.Number, node.Condition.Context);
                    }
                    catch (InvalidCastException)
                    {
                        // ignore any invalid cast errors
                    }
                }
            }
        }

        public override void Visit(ForStatement node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoForNode(node);
            }
        }

        private void DoForNode(ForStatement node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                if (node.Condition is ConstantWrapper constantCondition)
                {
                    try
                    {
                        // if condition is always false, change it to a zero (only one byte)
                        // and if it is always true, remove it (default behavior)
                        if (constantCondition.ToBoolean())
                        {
                            // always true -- don't need a condition at all
                            node.Condition = null;
                        }
                        else if (constantCondition.IsNotOneOrPositiveZero)
                        {
                            // always false and it's not already a zero. Make it so (only one byte)
                            node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // ignore any invalid cast exceptions
                    }
                }
            }
        }

        public override void Visit(IfStatement node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoIfNode(node);
            }
        }

        private void DoIfNode(IfStatement node)
        {
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                // if the if-condition is a constant, we can eliminate one of the two branches
                if (node.Condition is ConstantWrapper constantCondition)
                {
                    // instead, replace the condition with a 1 if it's always true or a 0 if it's always false
                    if (constantCondition.IsNotOneOrPositiveZero)
                    {
                        try
                        {
                            node.Condition =
                                new ConstantWrapper(constantCondition.ToBoolean() ? 1 : 0, PrimitiveType.Number, node.Condition.Context);
                        }
                        catch (InvalidCastException)
                        {
                            // ignore any invalid cast exceptions
                        }
                    }
                }
            }
        }

        public override void Visit(MemberExpression node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                if (string.CompareOrdinal(node.Name, "length") == 0
                    && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateLiteralLengths))
                {
                    // if we create a constant, we'll replace the current node with it
                    ConstantWrapper length = null;

                    ArrayLiteral arrayLiteral;

                    if (node.Root is ConstantWrapper constantWrapper)
                    {
                        if (constantWrapper.PrimitiveType == PrimitiveType.String && !constantWrapper.MayHaveIssues)
                        {
                            length = new ConstantWrapper(constantWrapper.ToString().Length, PrimitiveType.Number, node.Context);
                        }
                    }
                    else if ((arrayLiteral = node.Root as ArrayLiteral) != null && !arrayLiteral.MayHaveIssues)
                    {
                        var lengthValue = arrayLiteral.Length;
                        if (lengthValue >= 0)
                        {
                            // get the count of items in the array literal, create a constant wrapper from it, and
                            // replace this node with it
                            length = new ConstantWrapper(lengthValue, PrimitiveType.Number, node.Context);
                        }
                    }

                    if (length != null)
                    {
                        node.Parent.ReplaceChild(node, length);
                    }
                }
            }
        }

        public override void Visit(UnaryExpression node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoUnaryNode(node);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void DoUnaryNode(UnaryExpression node)
        {
            if (!node.OperatorInConditionalCompilationComment
                && m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                switch(node.OperatorToken)
                {
                    case JSToken.Void:

                        // see if our operand is a ConstantWrapper
                        if (node.Operand is ConstantWrapper literalOperand)
                        {
                            // either number, string, boolean, or null.
                            // the void operator evaluates its operand and returns undefined. Since evaluating a literal
                            // does nothing, then it doesn't matter what the heck it is. Replace it with a zero -- a one-
                            // character literal.
                            node.Operand = new ConstantWrapper(0, PrimitiveType.Number, node.Context);
                        }
                        break;

                    case JSToken.TypeOf:

                        if (node.Operand is ConstantWrapper literalOperand)
                        {
                            // either number, string, boolean, or null.
                            // the operand is a literal. Therefore we already know what the typeof
                            // operator will return. Just short-circuit that behavior now and replace the operator
                            // with a string literal of the proper value
                            string typeName = null;
                            if (literalOperand.IsStringLiteral)
                            {
                                // "string"
                                typeName = "string";
                            }
                            else if (literalOperand.IsNumericLiteral)
                            {
                                // "number"
                                typeName = "number";
                            }
                            else if (literalOperand.IsBooleanLiteral)
                            {
                                // "boolean"
                                typeName = "boolean";
                            }
                            else if (literalOperand.Value == null)
                            {
                                // "object"
                                typeName = "object";
                            }

                            if (!string.IsNullOrEmpty(typeName))
                            {
                                ReplaceNodeWithLiteral(node, new ConstantWrapper(typeName, PrimitiveType.String, node.Context));
                            }
                        }
                        else if (node.Operand is ObjectLiteral)
                        {
                            ReplaceNodeWithLiteral(node, new ConstantWrapper("object", PrimitiveType.String, node.Context));
                        }
                        break;

                    case JSToken.Plus:

                        if (node.Operand is ConstantWrapper literalOperand)
                        {
                            try
                            {
                                // replace with a constant representing operand.ToNumber,
                                ReplaceNodeWithLiteral(node, new ConstantWrapper(literalOperand.ToNumber(), PrimitiveType.Number, node.Context));
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                        }
                        break;

                    case JSToken.Minus:

                        if (node.Operand is ConstantWrapper literalOperand)
                        {
                            try
                            {
                                // replace with a constant representing the negative of operand.ToNumber
                                ReplaceNodeWithLiteral(node, new ConstantWrapper(-literalOperand.ToNumber(), PrimitiveType.Number, node.Context));
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                        }
                        break;

                    case JSToken.BitwiseNot:

                        if (node.Operand is ConstantWrapper literalOperand)
                        {
                            try
                            {
                                // replace with a constant representing the bitwise-not of operant.ToInt32
                                ReplaceNodeWithLiteral(node, new ConstantWrapper(Convert.ToDouble(~literalOperand.ToInt32()), PrimitiveType.Number, node.Context));
                            }
                            catch (InvalidCastException)
                            {
                                // some kind of casting in ToNumber caused a situation where we don't want
                                // to perform the combination on these operands
                            }
                        }
                        break;

                    case JSToken.LogicalNot:

                        if (node.Operand is ConstantWrapper literalOperand)
                        {
                            // replace with a constant representing the opposite of operand.ToBoolean
                            try
                            {
                                ReplaceNodeWithLiteral(node, new ConstantWrapper(!literalOperand.ToBoolean(), PrimitiveType.Boolean, node.Context));
                            }
                            catch (InvalidCastException)
                            {
                                // ignore any invalid cast exceptions
                            }
                        }
                        break;
                }
            }
        }

        public override void Visit(WhileStatement node)
        {
            if (node != null)
            {
                // depth-first
                base.Visit(node);

                DoWhileNode(node);
            }
        }

        private void DoWhileNode(WhileStatement node)
        {
            // see if the condition is a constant
            if (m_parser.Settings.IsModificationAllowed(TreeModifications.EvaluateNumericExpressions))
            {
                if (node.Condition is ConstantWrapper constantCondition)
                {
                    // TODO: (someday) we'd RATHER eliminate the statement altogether if the condition is always false,
                    // but we'd need to make sure var'd variables and declared functions are properly handled.
                    try
                    {
                        bool isTrue = constantCondition.ToBoolean();
                        if (isTrue)
                        {
                            // the condition is always true, so we should change it to 1
                            if (m_parser.Settings.IsModificationAllowed(TreeModifications.ChangeWhileToFor))
                            {
                                // the condition is always true; we should change it to a for(;;) statement.
                                // less bytes than while(1)

                                // check to see if we want to combine a preceding var with a for-statement
                                AstNode initializer = null;
                                if (m_parser.Settings.IsModificationAllowed(TreeModifications.MoveVarIntoFor))
                                {
                                    // if the previous statement is a var, we can move it to the initializer                                    // and save even more bytes. The parent should always be a block. If not,                                     // then assume there is no previous.
                                    if (node.Parent is BlockStatement parentBlock)
                                    {
                                        int whileIndex = parentBlock.IndexOf(node);
                                        if (whileIndex > 0)
                                        {
                                            if (parentBlock[whileIndex - 1] is VarDeclaration previousVar)
                                            {
                                                initializer = previousVar;
                                                parentBlock.RemoveAt(whileIndex - 1);
                                            }
                                        }
                                    }
                                }

                                // create the for using our body and replace ourselves with it
                                var forNode = new ForStatement(node.Context)
                                    {
                                        Initializer = initializer,
                                        Body = node.Body
                                    };
                                node.Parent.ReplaceChild(node, forNode);
                            }
                            else
                            {
                                // the condition is always true, so we can replace the condition
                                // with a 1 -- only one byte
                                node.Condition = new ConstantWrapper(1, PrimitiveType.Number, node.Condition.Context);
                            }
                        }
                        else if (constantCondition.IsNotOneOrPositiveZero)
                        {
                            // the condition is always false, so we can replace the condition
                            // with a zero -- only one byte
                            node.Condition = new ConstantWrapper(0, PrimitiveType.Number, node.Condition.Context);
                        }
                    }
                    catch (InvalidCastException)
                    {
                        // ignore any invalid cast exceptions
                    }
                }
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\EvaluateLiteralVisitor.cs(2325,61): error CS0128: A local variable or function named 'literalOperand' is already defined in this scope,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\EvaluateLiteralVisitor.cs(2366,61): error CS0128: A local variable or function named 'literalOperand' is already defined in this scope,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\EvaluateLiteralVisitor.cs(2383,61): error CS0128: A local variable or function named 'literalOperand' is already defined in this scope,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\EvaluateLiteralVisitor.cs(2400,61): error CS0128: A local variable or function named 'literalOperand' is already defined in this scope,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\EvaluateLiteralVisitor.cs(2417,61): error CS0128: A local variable or function named 'literalOperand' is already defined in this scope,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\EvaluateLiteralVisitor.cs(2332,33): error CS0165: Use of unassigned local variable 'literalOperand'
######################################################################


######################################################################
Nr: 21 - MergeSequentialChecksRewriterR2
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\OutputVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;

namespace NUglify.JavaScript.Visitors
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
    public class OutputVisitor : IVisitor
    {
        private TextWriter m_outputStream;

        private char m_lastCharacter;
        private bool m_lastCountOdd;
        private bool m_onNewLine;
        private bool m_startOfStatement;
        private bool m_outputCCOn;
        private bool m_doneWithGlobalDirectives;
        private bool m_needsStrictDirective;
        private bool m_noLineBreaks;

        private int m_indentLevel;
        private int m_lineLength;
        private int m_lineCount;

        // needed when generating map files
        private Stack<string> m_functionStack = new Stack<string>();
        private int m_segmentStartLine;
        private int m_segmentStartColumn;

        // if this function is set, before outputting a character will pass it to this
        // function and insert a space if it returns true. Then we reset the function.
        private Func<char, bool> m_addSpaceIfTrue;

        // normally false; gets set to true if we are in a no-in scenario
        // (in-operator not directly allowed)
        private bool m_noIn;

        // shortcut so we don't have to keep checking the count
        private bool m_hasReplacementTokens;

        private CodeSettings m_settings;

        private RequiresSeparatorVisitor m_requiresSeparator;

        private static string[] s_exponents = { 
            null, 
            null, 
            null, 
            "e3", 
            "e4",
            "e5",
            "e6",
            "e7",
            "e8",
            "e9",

            "e10", 
            "e11", 
            "e12", 
            "e13", 
            "e14",
            "e15",
            "e16",
            "e17",
            "e18",
            "e19",

            "e20", 
            "e21", 
            "e22", 
            "e23", 
            "e24",
            "e25",
            "e26",
            "e27",
            "e28",
            "e29"
        };

        private static char[] DecimalOrExponentChars = { '.', 'e', 'E' };
        private static char[] LineFeedCharacters = { '\n', '\r', '\u2028', '\u2029' };

        private OutputVisitor(TextWriter writer, CodeSettings settings)
        {
            m_outputStream = writer;
            m_settings = settings ?? new CodeSettings();
            m_onNewLine = true;
            m_requiresSeparator = new RequiresSeparatorVisitor(m_settings);
            m_hasReplacementTokens = settings.ReplacementTokens.Count > 0;
            writer.NewLine = settings.LineTerminator;
        }

        /// <summary>
        /// Render a node tree to a text writer
        /// </summary>
        /// <param name="writer">writer to which to send output</param>
        /// <param name="node">node to render</param>
        /// <param name="settings">settings to use for output</param>
        public static void Apply(TextWriter writer, AstNode node, CodeSettings settings)
        {
            if (node != null)
            {
                var outputVisitor = new OutputVisitor(writer, settings);
                node.Accept(outputVisitor);

                // if there is a symbol map that we are tracking, tell it that we have ended an output run
                // and pass it offsets to the last line and column positions.
                settings.IfNotNull(s => s.SymbolsMap.IfNotNull(m => m.EndOutputRun(outputVisitor.m_lineCount, outputVisitor.m_lineLength)));
            }
        }

        /// <summary>
        /// Render a node tree as a string
        /// </summary>
        /// <param name="node">node to render</param>
        /// <param name="settings">settings to use for output</param>
        /// <returns>string representation of the node</returns>
        public static string Apply(AstNode node, CodeSettings settings)
        {
            if (node != null)
            {
                using (var writer = new StringWriter(CultureInfo.InvariantCulture))
                {
                    OutputVisitor.Apply(writer, node, settings);
                    return writer.ToString();
                }
            }

            return string.Empty;
        }

        #region IVisitor Members

        public void Visit(ArrayLiteral node)
        {
            var isNoIn = m_noIn;
            m_noIn = false;

            if (node != null)
            {
                var symbol = StartSymbol(node);

                OutputPossibleLineBreak('[');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;

                if (node.Elements.Count > 0)
                {
                    Indent();

                    AstNode element = null;
                    for (var ndx = 0; ndx < node.Elements.Count; ++ndx)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            MarkSegment(node, null, element.IfNotNull(e => e.TerminatingContext));

                            if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        element = node.Elements[ndx];
                        if (element != null)
                        {
                            AcceptNodeWithParens(element, element.Precedence == OperatorPrecedence.Comma);
                        }
                    }

                    Unindent();
                }

                Output(']');
                MarkSegment(node, null, node.Context);

                EndSymbol(symbol);
            }

            m_noIn = isNoIn;
        }

        public void Visit(ComputedPropertyField node)
        {
            var isNoIn = m_noIn;
            m_noIn = false;

            var arrayNode = node.ArrayNode;

            if (node != null)
            {
                var symbol = StartSymbol(node);

                OutputPossibleLineBreak('[');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;

                if (arrayNode.Elements.Count > 0)
                {
                    Indent();

                    AstNode element = null;
                    for (var ndx = 0; ndx < arrayNode.Elements.Count; ++ndx)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            MarkSegment(node, null, element.IfNotNull(e => e.TerminatingContext));

                            if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        element = arrayNode.Elements[ndx];
                        if (element != null)
                        {
                            AcceptNodeWithParens(element, element.Precedence == OperatorPrecedence.Comma);
                        }
                    }

                    Unindent();
                }

                Output(']');
                OutputPossibleLineBreak(':');

                MarkSegment(node, null, node.Context);

                EndSymbol(symbol);
            }

            m_noIn = isNoIn;
        }

        public void Visit(AspNetBlockNode node)
        {
            if (node != null)
            {
                Output(node.AspNetBlockText);
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
            }
        }

        public void Visit(AstNodeList node)
        {
            if (node != null && node.Count > 0)
            {
                var symbol = StartSymbol(node);

                // see if this parent is a comma operator whose parent in turn is a block.
                // if so, then these expressions were expression statements that we've combined.
                // if that's the case, we're going to put newlines in so it's a little easier
                // to read in multi-line mode
                var addNewLines = node.Parent is CommaExpression
                    && node.Parent.Parent is BlockStatement
                    && m_settings.OutputMode == OutputMode.MultipleLines;

                // output as comma-separated expressions starting with the first one
                node[0].Accept(this);
                SetContextOutputPosition(node.Context, node[0].Context);

                // this should never be the first element of the line, but
                // just in case, reset the flag after the first expression.
                m_startOfStatement = false;

                // if we aren't breaking them up by newlines, indent now in case
                // one of the items causes a newline to be inserted.
                if (!addNewLines)
                {
                    Indent();
                }

                for (var ndx = 1; ndx < node.Count; ++ndx)
                {
                    // output a comma
                    OutputPossibleLineBreak(',');
                    MarkSegment(node, null, node[ndx-1].IfNotNull(n => n.TerminatingContext));

                    if (addNewLines)
                    {
                        NewLine();
                    }
                    else if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }

                    // output the next node
                    node[ndx].Accept(this);
                }

                // if we aren't breaking by newlines, unindent our previous indent
                if (!addNewLines)
                {
                    Unindent();
                }

                EndSymbol(symbol);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public void Visit(BinaryExpression node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                if (node.OperatorToken == JSToken.Comma)
                {
                    // output the left-hand operand, if we have one
                    if (node.Operand1 != null)
                    {
                        node.Operand1.Accept(this);
                        SetContextOutputPosition(node.Context, node.Operand1.Context);

                        // if we don't have a right-hand operator, don't bother with the comma
                        if (node.Operand2 != null)
                        {
                            OutputPossibleLineBreak(',');
                            MarkSegment(node, null, node.Operand1.TerminatingContext);
                            m_startOfStatement = false;

                            // if the parent is a block, then the comma operator is separating
                            // expression statements -- so break it on the line
                            if (node.Parent is BlockStatement)
                            {
                                NewLine();
                            }
                            else if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }
                    }

                    // output the right-hand operator, if we have one
                    if (node.Operand2 != null)
                    {
                        node.Operand2.Accept(this);
                        m_startOfStatement = false;
                    }
                }
                else
                {
                    var ourPrecedence = node.Precedence;
                    var isNoIn = m_noIn;
                    if (isNoIn)
                    {
                        if (node.OperatorToken == JSToken.In)
                        {
                            // we're in a no-in situation, but our operator is an in-operator.
                            // so we need to wrap this operator in parens
                            OutputPossibleLineBreak('(');
                            m_noIn = false;
                        }
                        else
                        {
                            m_noIn = ourPrecedence <= OperatorPrecedence.Relational;
                        }
                    }

                    if (node.Operand1 != null)
                    {
                        AcceptNodeWithParens(node.Operand1, node.Operand1.Precedence < ourPrecedence);
                        SetContextOutputPosition(node.Context, node.Operand1.Context);
                    }

                    m_startOfStatement = false;

                    if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        // treat the comma-operator special, since we combine expression statements
                        // with it very often
                        if (node.OperatorToken != JSToken.Comma)
                        {
                            // anything other than a comma operator has a space before it, too
                            OutputPossibleLineBreak(' ');
                        }

                        Output(OperatorString(node.OperatorToken));
                        MarkSegment(node, null, node.OperatorContext);

                        BreakLine(false);
                        if (!m_onNewLine)
                        {
                            OutputPossibleLineBreak(' ');
                        }
                    }
                    else
                    {
                        Output(OperatorString(node.OperatorToken));
                        MarkSegment(node, null, node.OperatorContext);
                        BreakLine(false);
                    }

                    if (node.OperatorToken == JSToken.Divide)
                    {
                        // add a function that will check if the next character is also
                        // a forward slash. If it is, the output methods will separate them
                        // with a space so they don't get interpreted as the start of a
                        // single-line comment.
                        m_addSpaceIfTrue = c => c == '/';
                    }

                    if (node.Operand2 != null)
                    {
                        var rightPrecedence = node.Operand2.Precedence;
                        var rightNeedsParens = rightPrecedence < ourPrecedence;

                        var rightHandBinary = node.Operand2 as BinaryExpression;
                        if (rightHandBinary != null)
                        {
                            // they are BOTH binary expressions. This is where it gets complicated.
                            // because most binary tokens (except assignment) are evaluated from left to right,
                            // if we have a binary expression with the same precedence on the RIGHT, then that means the
                            // developer must've put parentheses around it. For some operators, those parentheses 
                            // may not be needed (associative operators like multiply and logical AND or logical OR).
                            // Non-associative operators (divide) will need those parens, so we will want to say they
                            // are a higher relative precedence because of those parentheses.
                            // The plus operator is a special case. It is the same physical token, but it can be two
                            // operations depending on the runtime data: numeric addition or string concatenation.
                            // Because of that ambiguity, let's also calculate the precedence for it as if it were
                            // non-associate as well.
                            // commas never need the parens -- they always evaluate left to right and always return the
                            // right value, so any parens will always be unneccessary.
                            if (ourPrecedence == rightPrecedence
                                && ourPrecedence != OperatorPrecedence.Assignment
                                && ourPrecedence != OperatorPrecedence.Comma)
                            {
                                if (node.OperatorToken == rightHandBinary.OperatorToken)
                                {
                                    // the tokens are the same and we're not assignment or comma operators.
                                    // so for a few associative operators, we're going to say the relative precedence
                                    // is the same so unneeded parens are removed. But for all others, we'll say the
                                    // right-hand side is a higher precedence so we maintain the sematic structure
                                    // of the expression
                                    switch (node.OperatorToken)
                                    {
                                        case JSToken.Multiply:
                                        case JSToken.BitwiseAnd:
                                        case JSToken.BitwiseXor:
                                        case JSToken.BitwiseOr:
                                        case JSToken.LogicalAnd:
                                        case JSToken.LogicalOr:
                                            // these are the same regardless
                                            rightNeedsParens = false;
                                            break;

                                        // TODO: the plus operator: if we can prove that it is a numeric operator
                                        // or a string operator on BOTH sides, then it can be associative, too. But
                                        // if one side is a string and the other numeric, or if we can't tell at 
                                        // compile-time, then we need to preserve the structural precedence.
                                        default:
                                            // all other operators are structurally a lower precedence when they
                                            // are on the right, so they need to be evaluated first
                                            rightNeedsParens = true;
                                            break;
                                    }
                                }
                                else
                                {
                                    // they have the same precedence, but the tokens are different.
                                    // and the developer had purposely put parens around the right-hand side
                                    // to get them on the right (otherwise with the same precedence they
                                    // would've ended up on the left. Keep the parens; must've been done for
                                    // a purpose.
                                    rightNeedsParens = true;
                                }
                            }
                            else
                            {
                                // different precedence -- just base the decision on the relative precedence values
                                rightNeedsParens = rightPrecedence < ourPrecedence;
                            }
                        }

                        m_noIn = isNoIn && ourPrecedence <= OperatorPrecedence.Relational;
                        AcceptNodeWithParens(node.Operand2, rightNeedsParens);
                    }

                    if (isNoIn && node.OperatorToken == JSToken.In)
                    {
                        // we're in a no-in situation, but our operator is an in-operator.
                        // so we need to wrap this entire operator in parens
                        OutputPossibleLineBreak(')');
                    }
                    m_noIn = isNoIn;

                    EndSymbol(symbol);
                }
            }
        }

        public void Visit(BindingIdentifier node)
        {
            if (node != null)
            {
                // output the name (use the field is possible)
                Output(node.VariableField != null ? node.VariableField.ToString() : node.Name);
                MarkSegment(node, node.Name, node.Context);
                SetContextOutputPosition(node.Context);
                node.VariableField.IfNotNull(f => SetContextOutputPosition(f.OriginalContext));
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public void Visit(BlockStatement node)
        {
            if (node != null)
            {
                // don't create a symbol for the root node -- it can encompass any of the input files
                var symbol = node.Parent != null ? StartSymbol(node) : null;

                var outputBraces = true;
                if (node.Parent != null)
                {
                    // not the root block.
                    // if the parent is a function node, we will need a "use strict" directive
                    // if the function's scope is strict but the parent scope is not
                    ModuleDeclaration moduleDecl;
                    var parentNode = node.Parent;
                    if (parentNode is FunctionObject
                        && parentNode.EnclosingScope.UseStrict
                        && !parentNode.EnclosingScope.Parent.UseStrict)
                    {
                        m_needsStrictDirective = true;
                    }
                    else if ((moduleDecl = node.Parent as ModuleDeclaration) != null && moduleDecl.IsImplicit)
                    {
                        // this is an implicit module block. Don't output the strict directive
                        // because all modules are implicitly strict anyway.
                        m_needsStrictDirective = false;
                        outputBraces = false;
                    }

                    if (outputBraces)
                    {
                        // always enclose in curly-braces
                        OutputPossibleLineBreak('{');
                        SetContextOutputPosition(node.Context);
                        MarkSegment(node, null, node.Context);
                        Indent();
                    }
                }
                else
                {
                    // root block.
                    // we will need a "use strict" directive IF this scope is strict and we
                    // haven't already gone past where we can insert global directive prologues
                    m_needsStrictDirective = node.EnclosingScope.IfNotNull(s => s.UseStrict) && !m_doneWithGlobalDirectives;
                    outputBraces = false;
                }

                AstNode prevStatement = null;
                for (var ndx = 0; ndx < node.Count; ++ndx)
                {
                    var statement = node[ndx];
                    if (statement != null)
                    {
                        if (prevStatement != null && m_requiresSeparator.Query(prevStatement))
                        {
                            OutputPossibleLineBreak(';');
                            MarkSegment(prevStatement, null, prevStatement.TerminatingContext);
                        }

                        if (!(statement is DirectivePrologue))
                        {
                            if (m_needsStrictDirective)
                            {
                                // we need a strict directive, but we didn't have one.
                                // add it now
                                Output("\"use strict\";");
                                m_needsStrictDirective = false;
                            }

                            m_doneWithGlobalDirectives = true;
                        }

                        NewLine();
                        m_startOfStatement = true;
                        statement.Accept(this);
                        prevStatement = statement;
                    }
                }

                if (outputBraces)
                {
                    Unindent();

                    // if there weren't any statements, the curly-braces will be on the same line.
                    // otherwise we want them on a new line
                    if (node.Count > 0)
                    {
                        NewLine();
                    }

                    OutputPossibleLineBreak('}');
                    MarkSegment(node, null, node.Context);
                }
                else if (prevStatement != null && m_requiresSeparator.Query(prevStatement) && m_settings.TermSemicolons)
                {
                    // this is the root block (parent is null) and we want to make sure we end
                    // with a terminating semicolon, so don't replace it
                    OutputPossibleLineBreak(';');
                    MarkSegment(prevStatement, null, prevStatement.TerminatingContext);
                }

                if (symbol != null)
                {
                    EndSymbol(symbol);
                }
            }
        }

        public void Visit(BreakStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("break");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                if (!node.Label.IsNullOrWhiteSpace())
                {
                    // NO PAGE BREAKS ALLOWED HERE
                    m_noLineBreaks = true;
                    if (node.LabelInfo.IfNotNull(li => !li.MinLabel.IsNullOrWhiteSpace()))
                    {
                        // output minified label
                        Output(node.LabelInfo.MinLabel);
                    }
                    else
                    {
                        // not minified -- just output original label
                        Output(node.Label);
                    }

                    MarkSegment(node, null, node.LabelContext);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(CallExpression node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;
                m_noIn = false;

                if (node.IsConstructor)
                {
                    Output("new");
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);

                    m_startOfStatement = false;
                }

                if (node.Function != null)
                {
                    var needsParens = node.Function.Precedence < node.Precedence;

                    // if we think we don't need parens, we need to make one more check:
                    // if the function is a new operator with no argument list, then we 
                    // need to wrap it so our argument list doesn't get mistaken for the new-operator's
                    // argument list
                    if (!needsParens)
                    {
                        // because if the new-operator associates to the right and the ()-operator associates
                        // to the left, we need to be careful that we don't change the precedence order when the 
                        // function of a new operator is itself a call or contains a call. In that case, the call will have it's own
                        // parameters (and therefore parentheses) that will need to be associated with the call
                        // and NOT the new -- the call will need to be surrounded with parens to keep that association.
                        // (if we are already going to wrap it in parens, no need to check further)
                        if (node.IsConstructor)
                        {
                            // check the constructor function of our new operator to see if 
                            // it requires parens so we don't get the precedence all screwed up.
                            // pass in whether or not WE have any arguments -- will make a difference when we have embedded
                            // constructors that don't have arguments
                            needsParens = NewParensVisitor.NeedsParens(node.Function, node.Arguments == null || node.Arguments.Count == 0);
                        }
                        else
                        {
                            var newExpression = node.Function as CallExpression;
                            if (newExpression != null && newExpression.IsConstructor
                                && (newExpression.Arguments == null || newExpression.Arguments.Count == 0))
                            {
                                needsParens = true;
                            }
                        }
                    }

                    AcceptNodeWithParens(node.Function, needsParens);
                    if (!node.IsConstructor)
                    {
                        SetContextOutputPosition(node.Context);
                    }
                }

                if (!node.IsConstructor || node.Arguments.Count > 0)
                {
                    OutputPossibleLineBreak(node.InBrackets ? '[' : '(');
                    MarkSegment(node, null, node.Arguments.Context);

                    AstNode argument = null;
                    for (var ndx = 0; ndx < node.Arguments.Count; ++ndx)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            MarkSegment(node.Arguments, null, argument.IfNotNull(a => a.TerminatingContext) ?? node.Arguments.Context);

                            if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        argument = node.Arguments[ndx];
                        if (argument != null)
                        {
                            AcceptNodeWithParens(argument, argument.Precedence <= OperatorPrecedence.Comma);
                        }
                    }

                    Output(node.InBrackets ? ']' : ')');
                    MarkSegment(node, null, node.Arguments.Context);
                }

                m_noIn = isNoIn;

                EndSymbol(symbol);
            }
        }

        public void Visit(ClassNode node)
        {
            if (node != null)
            {
                var wrapInParens = m_startOfStatement && node.ClassType != ClassType.Declaration;
                if (wrapInParens)
                {
                    OutputPossibleLineBreak('(');
                    m_startOfStatement = false;
                }

                Output("class");
                MarkSegment(node, null, node.ClassContext);
                SetContextOutputPosition(node.ClassContext);
                m_startOfStatement = false;

                // name if optional if this is an expression, and it should
                // be a simple binding identifier if it's present
                if (node.Binding != null)
                {
                    var bindingIdentifier = node.Binding as BindingIdentifier;
                    if (bindingIdentifier != null)
                    {
                        // if this isn't an expression, or if the class name is actually referenced,
                        // or if we don't want to remove expression names, output the name. Otherwise
                        // hide it.
                        if (node.ClassType != ClassType.Expression
                            || bindingIdentifier.VariableField.IsReferenced
                            || !m_settings.RemoveFunctionExpressionNames)
                        {
                            node.Binding.Accept(this);
                        }
                    }
                    else
                    {
                        // not a simple identifier -- output anyway to maintain the code as-is
                        node.Binding.Accept(this);
                    }
                }

                // heritage is optional
                if (node.Heritage != null)
                {
                    Output("extends");
                    MarkSegment(node, null, node.ExtendsContext);
                    SetContextOutputPosition(node.ExtendsContext);

                    node.Heritage.Accept(this);
                }

                // if there are any elements, put the braces on new lines and indent
                node.Elements.IfNotNull(e => { if (e.Count > 0) { NewLine(); Indent();  } });
                OutputPossibleLineBreak('{');
                MarkSegment(node, null, node.OpenBrace);
                SetContextOutputPosition(node.OpenBrace);

                // output each element in turn
                if (node.Elements != null && node.Elements.Count > 0)
                {
                    foreach (var element in node.Elements)
                    {
                        NewLine();
                        element.Accept(this);
                    }
                }

                // if there are any elements, unindent and put the closing braces on a new line
                node.Elements.IfNotNull(e => { if (e.Count > 0) { Unindent();  NewLine(); } });
                OutputPossibleLineBreak('}');
                MarkSegment(node, null, node.CloseBrace);
                SetContextOutputPosition(node.CloseBrace);

                if (wrapInParens)
                {
                    OutputPossibleLineBreak(')');
                }
            }
        }

        public void Visit(ComprehensionNode node)
        {
            if (node != null)
            {
                // array is the default (0) so check for generator
                OutputPossibleLineBreak(node.ComprehensionType == ComprehensionType.Generator ? '(' : '[');
                MarkSegment(node, null, node.OpenDelimiter);

                if (node.MozillaOrdering)
                {
                    // Mozilla order implemented by Firefox - they want the expression first,
                    // then the for-clause(s) followed by an optional single if-clause
                    if (node.Expression != null)
                    {
                        node.Expression.Accept(this);
                    }

                    // skip the AstNodeList part and just output the clauses
                    // because the list will add commas
                    foreach (var clause in node.Clauses)
                    {
                        clause.Accept(this);
                    }
                }
                else
                {
                    // spec'd ES6 format
                    // a for-clause followed by any number of for- or if-clauses, followed by the expression
                    // skip the AstNodeList part and just output the clauses
                    // because the list will add commas
                    foreach (var clause in node.Clauses)
                    {
                        clause.Accept(this);
                    }

                    if (node.Expression != null)
                    {
                        node.Expression.Accept(this);
                    }
                }

                OutputPossibleLineBreak(node.ComprehensionType == ComprehensionType.Generator ? ')' : ']');
                MarkSegment(node, null, node.CloseDelimiter);
            }
        }

        public void Visit(ComprehensionForClause node)
        {
            if (node != null)
            {
                Output("for");
                MarkSegment(node, null, node.OperatorContext);
                OutputPossibleLineBreak('(');
                MarkSegment(node, null, node.OpenContext);

                if (node.Binding != null)
                {
                    node.Binding.Accept(this);
                }

                Output(node.IsInOperation ? "in" : "of");
                MarkSegment(node, null, node.OfContext);

                if (node.Expression != null)
                {
                    node.Expression.Accept(this);
                }

                OutputPossibleLineBreak(')');
                MarkSegment(node, null, node.CloseContext);
            }
        }

        public void Visit(ComprehensionIfClause node)
        {
            if (node != null)
            {
                Output("if");
                MarkSegment(node, null, node.OperatorContext);
                OutputPossibleLineBreak('(');
                MarkSegment(node, null, node.OpenContext);

                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                OutputPossibleLineBreak(')');
                MarkSegment(node, null, node.CloseContext);
            }
        }

        public void Visit(ConditionalCompilationComment node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                // if we have already output a cc_on and we don't want to keep any dupes, let's
                // skip over any @cc_on statements at the beginning now
                var ndx = 0;
                if (m_outputCCOn && m_settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryCCOnStatements))
                {
                    while (ndx < node.Statements.Count
                        && node.Statements[ndx] is ConditionalCompilationOn)
                    {
                        ++ndx;
                    }
                }

                // if there's anything left....
                if (ndx < node.Statements.Count)
                {
                    // start of comment
                    Output("/*");
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);

                    // get the next statement, which will be the first one we output
                    var statement = node.Statements[ndx];
                    if (statement is ConditionalCompilationStatement
                        || statement is ConstantWrapperPP)
                    {
                        // the next statement STARTS with an @-sign, so just output it. It will add the @ sign to begin
                        // the conditional-compilation comment
                        statement.Accept(this);
                    }
                    else
                    {
                        // next statement does NOT start with an @-sign, so add one now.
                        // outputting an @-sign as the last character will ensure that a
                        // space is inserted before any identifier character coming after.
                        OutputPossibleLineBreak('@');

                        // and then output the first statement
                        statement.Accept(this);
                    }

                    // go through the rest of the statements (if any)
                    AstNode prevStatement = statement;
                    while (++ndx < node.Statements.Count)
                    {
                        statement = node.Statements[ndx];
                        if (statement != null)
                        {
                            if (prevStatement != null && m_requiresSeparator.Query(prevStatement))
                            {
                                OutputPossibleLineBreak(';');
                                MarkSegment(prevStatement, null, prevStatement.TerminatingContext);
                            }

                            NewLine();
                            m_startOfStatement = true;
                            statement.Accept(this);
                            prevStatement = statement;
                        }
                    }

                    // output the closing comment
                    Output("@*/");
                    MarkSegment(node, null, node.Context);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationElse node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                
                Output("@else");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationElseIf node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("@elif(");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                OutputPossibleLineBreak(')');
                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationEnd node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("@end");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationIf node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("@if(");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                OutputPossibleLineBreak(')');
                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationOn node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                if (!m_outputCCOn
                    || !m_settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryCCOnStatements))
                {
                    m_outputCCOn = true;
                    Output("@cc_on");
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationSet node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("@set");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                Output(node.VariableName);
                Output('=');

                // if the value is an operator of any kind, we need to wrap it in parentheses
                // so it gets properly parsed
                if (node.Value is BinaryExpression || node.Value is UnaryExpression)
                {
                    Output('(');
                    node.Value.Accept(this);
                    OutputPossibleLineBreak(')');
                }
                else if (node.Value != null)
                {
                    node.Value.Accept(this);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(Conditional node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;

                if (node.Condition != null)
                {
                    AcceptNodeWithParens(node.Condition, node.Condition.Precedence < OperatorPrecedence.LogicalOr);
                    SetContextOutputPosition(node.Context);
                }

                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                    OutputPossibleLineBreak('?');
                    MarkSegment(node, null, node.QuestionContext ?? node.Context);
                    BreakLine(false);
                    if (!m_onNewLine)
                    {
                        OutputPossibleLineBreak(' ');
                    }
                }
                else
                {
                    OutputPossibleLineBreak('?');
                    MarkSegment(node, null, node.QuestionContext ?? node.Context);
                }

                m_startOfStatement = false;
                if (node.TrueExpression != null)
                {
                    m_noIn = isNoIn;
                    AcceptNodeWithParens(node.TrueExpression, node.TrueExpression.Precedence < OperatorPrecedence.Assignment);
                }

                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                    OutputPossibleLineBreak(':');
                    MarkSegment(node, null, node.ColonContext ?? node.Context);
                    BreakLine(false);
                    if (!m_onNewLine)
                    {
                        OutputPossibleLineBreak(' ');
                    }
                }
                else
                {
                    OutputPossibleLineBreak(':');
                    MarkSegment(node, null, node.ColonContext ?? node.Context);
                }

                if (node.FalseExpression != null)
                {
                    m_noIn = isNoIn;
                    AcceptNodeWithParens(node.FalseExpression, node.FalseExpression.Precedence < OperatorPrecedence.Assignment);
                }

                m_noIn = isNoIn;

                EndSymbol(symbol);
            }
        }

        public void Visit(ConstantWrapper node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;
                m_noIn = false;

                switch (node.PrimitiveType)
                {
                    case PrimitiveType.Boolean:
                        Output(node.ToBoolean() ? "true" : "false");
                        break;

                    case PrimitiveType.Null:
                        Output("null");
                        break;

                    case PrimitiveType.Number:
                        if (node.Context == null || !node.Context.HasCode
                            || (!node.MayHaveIssues && m_settings.IsModificationAllowed(TreeModifications.MinifyNumericLiterals)))
                        {
                            // apply minification to the literal to get it as small as possible
                            Output(NormalizeNumber(node.ToNumber(), node.Context));
                        }
                        else
                        {
                            // context is not null but we don't want to minify numeric literals.
                            // just use the original literal from the context.
                            Output(node.Context.Code);
                        }
                        break;

                    case PrimitiveType.Other:
                        // see if the value of this other "constant" is actually a replacement token.
                        // the regex doesn't have ^ or $ so that it can be used to match tokens within a
                        // string, so if there's a match, make sure the match is the whole string.
                        Match match;
                        if (m_hasReplacementTokens
                            && (match = CommonData.ReplacementToken.Match(node.Value.ToString())).Success
                            && match.Value.Equals(node.Value))
                        {
                            // this is a token value, and we are replacing tokens.
                            Output(GetSyntacticReplacementToken(match));
                        }
                        else
                        {
                            // not replacing tokens; just output the value as-is
                            Output(node.Value.ToString());
                        }
                        break;

                    case PrimitiveType.String:
                        if (node.Context == null || !node.Context.HasCode)
                        {
                            // escape the string value because we don't have a raw context value
                            // to show anyways
                            Output(InlineSafeString(EscapeString(ReplaceTokens(node.Value.ToString()))));
                        }
                        else if (!m_settings.IsModificationAllowed(TreeModifications.MinifyStringLiterals))
                        {
                            // we don't want to modify the strings at all!
                            Output(ReplaceTokens(node.Context.Code));
                        }
                        else if (node.MayHaveIssues
                            || (m_settings.AllowEmbeddedAspNetBlocks && node.StringContainsAspNetReplacement))
                        {
                            // we'd rather show the raw string, but make sure it's safe for inlining
                            Output(InlineSafeString(ReplaceTokens(node.Context.Code)));
                        }
                        else
                        {
                            // under normal circumstances we would show a properly escaped and delimited
                            // string that is safe for inlining.
                            Output(InlineSafeString(EscapeString(ReplaceTokens(node.Value.ToString()))));
                        }

                        break;
                }

                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                m_noIn = isNoIn;

                EndSymbol(symbol);
            }
        }

        private string ReplaceTokens(string text)
        {
            // if we have any replacement tokens that we are looking for,
            // then do the replace operation on the string with the function that
            // will look up the token and replace it with the appropriate string.
            if (m_hasReplacementTokens)
            {
                text = CommonData.ReplacementToken.Replace(text, GetReplacementToken);
            }

            // no replacement; output as-is
            return text;
        }

        private string GetReplacementToken(Match match)
        {
            // see if there's a match for the token
            string replacement;
            if (!m_settings.ReplacementTokens.TryGetValue(match.Result("${token}"), out replacement))
            {
                // no match. Check the fallback, if any.
                var fallbackClass = match.Result("${fallback}");
                if (!fallbackClass.IsNullOrWhiteSpace())
                {
                    m_settings.ReplacementFallbacks.TryGetValue(fallbackClass, out replacement);
                }
            }

            return replacement ?? string.Empty;
        }

        private string GetSyntacticReplacementToken(Match match)
        {
            // see if there's a match for the token
            string replacement;
            if (m_settings.ReplacementTokens.TryGetValue(match.Result("${token}"), out replacement))
            {
                // we have a match.
                // if the string is valid JSON, the just output it as-is (well, with a little minification)
                var json = JsonParser.Validate(replacement);
                if (!json.IsNullOrWhiteSpace())
                {
                    // use the minified JSON object
                    replacement = json;
                }
                else
                {
                    // not JSON, so we need to treat the value as a string: wrap in quotes.
                    replacement = InlineSafeString(EscapeString(replacement));
                }
            }
            else
            {
                // no match. Check the fallback, if any. We're not going to do ANY processing
                // on a fallback value, so it BETTER generate proper JS syntax!
                var fallbackClass = match.Result("${fallback}");
                if (!fallbackClass.IsNullOrWhiteSpace())
                {
                    m_settings.ReplacementFallbacks.TryGetValue(fallbackClass, out replacement);
                }
            }

            return replacement ?? string.Empty;
        }

        public void Visit(ConstantWrapperPP node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                if (node.ForceComments)
                {
                    Output("/*");
                }

                // varname must include the @ sign
                Output(node.VarName);
                m_startOfStatement = false;
                SetContextOutputPosition(node.Context);

                if (node.ForceComments)
                {
                    Output("@*/");
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ConstStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("const");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                Indent();

                for (var ndx = 0; ndx < node.Count; ++ndx)
                {
                    var decl = node[ndx];
                    if (decl != null)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            NewLine();
                        }

                        decl.Accept(this);
                    }
                }
                Unindent();
                EndSymbol(symbol);
            }
        }

        public void Visit(ContinueStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("continue");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                if (!node.Label.IsNullOrWhiteSpace())
                {
                    // NO PAGE BREAKS ALLOWED HERE
                    m_noLineBreaks = true;
                    if (node.LabelInfo.IfNotNull(li => !li.MinLabel.IsNullOrWhiteSpace()))
                    {
                        // output minified label
                        Output(node.LabelInfo.MinLabel);
                    }
                    else
                    {
                        // not minified -- just output original label
                        Output(node.Label);
                    }

                    MarkSegment(node, null, node.LabelContext);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(CustomNode node)
        {
            if (node != null)
            {
                // custom nodes override the ToCode method to return a blank string.
                // nodes DERIVED from CustomNode should override ToCode is they want
                // to introduce anything into the output stream.
                var code = node.ToCode();
                if (!code.IsNullOrWhiteSpace())
                {
                    var symbol = StartSymbol(node);
                    Output(code);
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);
                    EndSymbol(symbol);
                }
            }
        }

        public void Visit(DebuggerNode node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("debugger");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                EndSymbol(symbol);
            }
        }

        public void Visit(DirectivePrologue node)
        {
            if (node != null)
            {
                // always output directive prologues that aren't strict; only output
                // the use-strict directive if we need one
                node.IsRedundant = node.UseStrict && !m_needsStrictDirective;
                if (!node.IsRedundant)
                {
                    Visit((ConstantWrapper)node);
                    if (node.UseStrict)
                    {
                        // just output a strict directive -- don't need one anymore
                        m_needsStrictDirective = false;
                    }
                }
            }
        }

        public void Visit(DoWhileStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("do");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                if (node.Body == null || node.Body.Count == 0)
                {
                    // semicolon-replacement cannot create an empty statement
                    OutputPossibleLineBreak(';');
                }
                else if (node.Body.Count == 1 && !node.Body.EncloseBlock(EncloseBlockType.SingleDoWhile))
                {
                    // there's only one statement, which means we don't need curley braces.
                    // HOWEVER, if the one statement ends in a do-while statement, then we DO need curley-braces
                    // because of an IE bug. IE parses the semi-colon that terminates the do-while as an empty
                    // statement FOLLOWING the do-while, which means the while-clause of the do-while is in the 
                    // wrong spot. We *could* leave the semi-colon out and all browsers will parse it properly, but
                    // that isn't strictly correct JS. So just wrap it in curly-braces to remain proper AND work in 
                    // all browsers.
                    Indent();
                    NewLine();
                    m_startOfStatement = true;
                    node.Body[0].Accept(this);

                    if (m_requiresSeparator.Query(node.Body[0]))
                    {
                        // because the next thing we are going to output is a while keyword, if the
                        // semicolon would be at the end of a line, we can skip it and just let the
                        // end of line trigger the semicolon-insertion rules.
                        if (ReplaceableSemicolon())
                        {
                            MarkSegment(node.Body[0], null, node.Body[0].TerminatingContext);
                        }
                    }

                    Unindent();
                    NewLine();
                }
                else
                {
                    if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                        || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.Body.BraceOnNewLine))
                    {
                        NewLine();
                    }
                    else if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }
                    
                    node.Body.Accept(this);

                    if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }
                }

                Output("while");
                MarkSegment(node, null, node.WhileContext);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                Output(')');

                EndSymbol(symbol);
            }
        }

        public void Visit(EmptyStatement node)
        {
            if (node != null)
            {
                // empty statement is just a semicolon
                OutputPossibleLineBreak(';');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
            }
        }

        public void Visit(ExportStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("export");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                SetContextOutputPosition(node.KeywordContext);
                m_startOfStatement = false;

                if (node.IsDefault)
                {
                    Output("default");

                    // there should only be a single element in the list, and it should be
                    // and assignment expression.
                    if (node.Count > 0)
                    {
                        node[0].Accept(this);
                    }
                }
                else
                {
                    if (node.Count == 1
                        && (node[0] is Declaration || node[0] is FunctionObject || node[0] is ClassNode))
                    {
                        // exporting a declaration (var/const/let), a function declaration, or a class node
                        node[0].Accept(this);
                    }
                    else
                    {
                        // the array should be an export specifier set. If there's nothing there, it's a star
                        if (node.Count == 0)
                        {
                            OutputPossibleLineBreak('*');
                            SetContextOutputPosition(node.OpenContext);
                        }
                        else
                        {
                            OutputPossibleLineBreak('{');
                            SetContextOutputPosition(node.OpenContext);

                            var first = true;
                            foreach (var specifier in node.Children)
                            {
                                if (first)
                                {
                                    first = false;
                                }
                                else
                                {
                                    OutputPossibleLineBreak(',');
                                }

                                specifier.Accept(this);
                            }

                            OutputPossibleLineBreak('}');
                            SetContextOutputPosition(node.CloseContext);
                        }

                        if (node.ModuleName != null)
                        {
                            Output("from");
                            SetContextOutputPosition(node.FromContext);

                            Output(EscapeString(node.ModuleName));
                            SetContextOutputPosition(node.ModuleContext);
                        }
                    }
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ForInStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("for");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Variable != null)
                {
                    // we have a no-in scenario for the variable
                    m_noIn = true;
                    node.Variable.Accept(this);
                    m_noIn = false;
                }

                if (node.OperatorContext != null
                    && !node.OperatorContext.Code.IsNullOrWhiteSpace())
                {
                    Output(node.OperatorContext.Code);
                }
                else
                {
                    // assume this is a for-in operator
                    Output("in");
                }

                MarkSegment(node, null, node.OperatorContext);

                if (node.Collection != null)
                {
                    node.Collection.Accept(this);
                }

                OutputPossibleLineBreak(')');
                MarkSegment(node, null, node.Context);
                OutputBlock(node.Body);

                EndSymbol(symbol);
            }
        }

        public void Visit(ForStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("for");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Initializer != null)
                {
                    // we have a no-in scenario for the initializer
                    m_noIn = true;
                    node.Initializer.Accept(this);
                    m_noIn = false;
                }

                // NEVER do without these semicolons
                OutputPossibleLineBreak(';');
                MarkSegment(node, null, node.Separator1Context ?? node.Context); 
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                OutputPossibleLineBreak(';');
                MarkSegment(node, null, node.Separator2Context ?? node.Context);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                if (node.Incrementer != null)
                {
                    node.Incrementer.Accept(this);
                }

                OutputPossibleLineBreak(')');
                MarkSegment(node, null, node.Context);

                OutputBlock(node.Body);
                EndSymbol(symbol);
            }
        }

        private void OutputFunctionPrefix(FunctionObject node, string functionName)
        {
            if (node.FunctionType == FunctionType.Method)
            {
                if (node.IsAsync)
                {
                    Output("async");
                }

                if (node.IsGenerator)
                {
                    Output('*');
                    MarkSegment(node, functionName, node.Context);
                    SetContextOutputPosition(node.Context);
                }
            }
            else if (node.FunctionType == FunctionType.Getter)
            {
                Output("get");
                MarkSegment(node, functionName, node.Context);
                SetContextOutputPosition(node.Context);
            }
            else if (node.FunctionType == FunctionType.Setter)
            {
                Output("set");
                MarkSegment(node, functionName, node.Context);
                SetContextOutputPosition(node.Context);
            }
            else
            {
                if (node.IsAsync)
                {
                    Output("async");
                }

                Output("function");
                MarkSegment(node, functionName, node.Context);
                SetContextOutputPosition(node.Context);

                if (node.IsGenerator)
                {
                    Output('*');
                }
            }
        }

        public void Visit(FunctionObject node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;
                m_noIn = false;

                if (node.FunctionType == FunctionType.ArrowFunction)
                {
                    if (node.IsAsync)
                    {
                        Output("async");
                    }

                    // arrow functions are simple...
                    OutputFunctionArgsAndBody(node);
                }
                else
                {
                    var encloseInParens = node.IsExpression && m_startOfStatement;
                    if (encloseInParens)
                    {
                        OutputPossibleLineBreak('(');
                    }

                    // get the function name we will use for symbol references.
                    // use the function's real name if:
                    //    1. there is one AND
                    //      2a. the function is not an expression (declaration, method, getter/setter) OR
                    //      2b. the refcount is greater than zero OR
                    //      2c. we aren't going to remove function expression names
                    // otherwise use the name guess.
                    var hasName = (node.Binding != null && !node.Binding.Name.IsNullOrWhiteSpace())
                            && (node.FunctionType != FunctionType.Expression
                                || node.Binding.VariableField.RefCount > 0
                                || !m_settings.RemoveFunctionExpressionNames
                                || !m_settings.IsModificationAllowed(TreeModifications.RemoveFunctionExpressionNames));
                    var fullFunctionName = hasName
                            ? node.Binding.Name
                            : node.NameGuess;

                    if (node.IsStatic)
                    {
                        Output("static");
                    }

                    OutputFunctionPrefix(node, fullFunctionName);
                    m_startOfStatement = false;
                    bool isAnonymous = true;
                    if (node.Binding != null && !node.Binding.Name.IsNullOrWhiteSpace())
                    {
                        isAnonymous = false;
                        var minFunctionName = node.Binding.VariableField != null
                            ? node.Binding.VariableField.ToString()
                            : node.Binding.Name;
                        if (m_settings.SymbolsMap != null)
                        {
                            m_functionStack.Push(minFunctionName);
                        }

                        if (hasName)
                        {
                            // all identifier should be treated as if they start with a valid
                            // identifier character. That might not always be the case, like when
                            // we consider an ASP.NET block to output the start of an identifier.
                            // so let's FORCE the insert-space logic here.
                            if (JSScanner.IsValidIdentifierPart(m_lastCharacter))
                            {
                                Output(' ');
                            }

                            Output(minFunctionName);
                            MarkSegment(node, node.Binding.Name, node.Binding.Context);
                            SetContextOutputPosition(node.Context);
                        }
                    }

                    if (m_settings.SymbolsMap != null && isAnonymous)
                    {
                        BinaryExpression binaryExpression = node.Parent as BinaryExpression;
                        if (binaryExpression != null && binaryExpression.Operand1 is LookupExpression)
                        {
                            m_functionStack.Push("(anonymous) [{0}]".FormatInvariant(binaryExpression.Operand1));
                        }
                        else
                        {
                            m_functionStack.Push("(anonymous)");
                        }
                    }

                    OutputFunctionArgsAndBody(node);

                    if (encloseInParens)
                    {
                        OutputPossibleLineBreak(')');
                    }
                }

                m_noIn = isNoIn;
                EndSymbol(symbol);
                if (m_settings.SymbolsMap != null)
                {
                    m_functionStack.Pop();
                }
           }
        }

        public void Visit(GetterSetter node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output(node.IsGetter ? "get" : "set");
                MarkSegment(node, node.Value.ToString(), node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                Output(node.Value.ToString());

                EndSymbol(symbol);
            }
        }

        public virtual void Visit(GroupingOperator node)
        {
            if (node != null)
            {
                // don't output a possible line-break here.
                Output('(');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;

                if (node.Operand != null)
                {
                    node.Operand.Accept(this);
                }

                OutputPossibleLineBreak(')');
                MarkSegment(node, null, node.Context);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public void Visit(IfStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("if");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                OutputPossibleLineBreak(')');

                if (node.TrueBlock != null && node.TrueBlock.ForceBraces)
                {
                    OutputBlockWithBraces(node.TrueBlock);
                }
                else if (node.TrueBlock == null || node.TrueBlock.Count == 0)
                {
                    // no true-block; just output an empty statement
                    OutputPossibleLineBreak(';');
                }
                else if (node.TrueBlock.Count == 1
                    && (node.FalseBlock == null || (!node.TrueBlock.EncloseBlock(EncloseBlockType.IfWithoutElse) && !node.TrueBlock.EncloseBlock(EncloseBlockType.SingleDoWhile)))
                    && (!m_settings.MacSafariQuirks || !(node.TrueBlock[0] is FunctionObject)))
                {
                    // we only have a single statement in the true-branch; normally
                    // we wouldn't wrap that statement in braces. However, if there 
                    // is an else-branch, we need to make sure that single statement 
                    // doesn't end with an if-statement that doesn't have an else-branch
                    // because otherwise OUR else-branch will get associated with that
                    // other if-statement. AND it can't end in a do-while statement because then
                    // we run into IE issues with the strict terminating semi-colon.
                    // AND if we are being safari-strict, we want to wrap a single function declaration in
                    // curly-braces, too.
                    Indent();
                    NewLine();

                    m_startOfStatement = true;
                    node.TrueBlock[0].Accept(this);
                    if (node.TrueBlock[0] is ImportantComment)
                    {
                        // the true-block only contained a single important comment.
                        // that's not a true statement, so terminate it with an empty-statement
                        // semicolon
                        OutputPossibleLineBreak(';');
                    }

                    if (node.FalseBlock != null && node.FalseBlock.Count > 0
                        && m_requiresSeparator.Query(node.TrueBlock[0]))
                    {
                        // we have only one statement, we did not wrap it in braces,
                        // and we have an else-block, and the one true-statement needs
                        // a semicolon; add it now. But because we're going to be outputting
                        // and ELSE keyword next, if we are at the end of a line, we can omit the
                        // semicolon and just output the line-break, because semicolon-insertion
                        // rules will kick in here.
                        if (ReplaceableSemicolon())
                        {
                            MarkSegment(node.TrueBlock[0], null, node.TrueBlock[0].TerminatingContext);
                        }
                    }

                    Unindent();
                }
                else
                {
                    OutputBlockWithBraces(node.TrueBlock);
                }

                if (node.FalseBlock != null && (node.FalseBlock.Count > 0 || node.FalseBlock.ForceBraces))
                {
                    NewLine();
                    Output("else");
                    MarkSegment(node, null, node.ElseContext);
                    if (node.FalseBlock.Count == 1 && !node.FalseBlock.ForceBraces)
                    {
                        var statement = node.FalseBlock[0];
                        if (statement is IfStatement)
                        {
                            // this is an else-if construct. Don't newline or indent, just
                            // handle the if-statement directly. 
                            statement.Accept(this);
                        }
                        else
                        {
                            Indent();
                            NewLine();
                            m_startOfStatement = true;
                            statement.Accept(this);
                            Unindent();
                        }
                    }
                    else
                    {
                        OutputBlockWithBraces(node.FalseBlock);
                    }
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ImportantComment node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                // make sure we force the important comments to start on a new line, regardless
                // of whether or not we are in multi- or single-line mode, and the statement after
                // should also be on a new line.
                BreakLine(true);

                node.Context.OutputLine = m_lineCount;

                // the output method assumes any text we send it's way doesn't contain any line feed
                // characters. The important comment, however, may contain some. We don't want to count
                // the entire comment as a single line, AND we want to normalize the line-feed characters,
                // so lets process the comment line-by-line
                var startIndex = 0;
                var firstLF = node.Comment.IndexOfAny(LineFeedCharacters, startIndex);
                if (firstLF < 0)
                {
                    // no line-breaks at all!
                    Output(node.Comment);
                }
                else
                {
                    // output the first segment -- from start to first line break
                    Output(node.Comment.Substring(0, firstLF));
                    while (true)
                    {
                        // advance the next segment pointer
                        if (node.Comment[firstLF] == '\r'
                            && firstLF < node.Comment.Length - 1
                            && node.Comment[firstLF + 1] == '\n')
                        {
                            startIndex = firstLF + 2;
                        }
                        else
                        {
                            startIndex = firstLF + 1;
                        }

                        // force the line-break in the output
                        BreakLine(true);

                        // look for the next line break
                        firstLF = node.Comment.IndexOfAny(LineFeedCharacters, startIndex);

                        if (firstLF > startIndex)
                        {
                            // only output something if there was something before the next line break
                            Output(node.Comment.Substring(startIndex, firstLF - startIndex));
                        }
                        else if (firstLF < 0)
                        {
                            // no more line-breaks -- output the last segment and break out of the loop
                            Output(node.Comment.Substring(startIndex));
                            break;
                        }
                    }
                }

                // force a line-break AFTER teh important comment as well
                BreakLine(true);
                EndSymbol(symbol);
            }
        }

        public void Visit(ImportExportSpecifier node)
        {
            if (node != null)
            {
                if (node.Parent is ImportStatement)
                {
                    // import specifier: external (as local)
                    if (!node.ExternalName.IsNullOrWhiteSpace())
                    {
                        Output(node.ExternalName);
                        SetContextOutputPosition(node.Context);
                        SetContextOutputPosition(node.NameContext);

                        Output("as");
                        SetContextOutputPosition(node.AsContext);
                    }

                    // the local identiier should ALWAYS be present, but just in case...
                    if (node.LocalIdentifier != null)
                    {
                        node.LocalIdentifier.Accept(this);
                        if (node.ExternalName.IsNullOrWhiteSpace())
                        {
                            // if there was no external name, then this is the first (and only)
                            // part of the node output, so set the node's context position from it.
                            SetContextOutputPosition(node.Context);
                        }
                    }
                }
                else
                {
                    // export specifier: local (as external)
                    // local identifier should always be present...
                    if (node.LocalIdentifier != null)
                    {
                        node.LocalIdentifier.Accept(this);
                        SetContextOutputPosition(node.Context);
                    }

                    if (!node.ExternalName.IsNullOrWhiteSpace())
                    {
                        Output("as");
                        SetContextOutputPosition(node.AsContext);

                        Output(node.ExternalName);
                        SetContextOutputPosition(node.NameContext);
                    }
                }
            }
        }

        public void Visit(ImportStatement node)
        {
            if (node != null)
            {
                Output("import");
                SetContextOutputPosition(node.Context);
                SetContextOutputPosition(node.KeywordContext);
                m_startOfStatement = false;

                // ANY specifier or identifier is optional
                if (node.Count > 0)
                {
                    if (node.Count == 1 && node[0] is BindingIdentifier)
                    {
                        // identifier without braces
                        node[0].Accept(this);
                    }
                    else
                    {
                        // specifier list enclosed in braces
                        OutputPossibleLineBreak('{');
                        SetContextOutputPosition(node.OpenContext);

                        var first = true;
                        foreach (var specifier in node.Children)
                        {
                            if (first)
                            {
                                first = false;
                            }
                            else
                            {
                                OutputPossibleLineBreak(',');
                            }

                            specifier.Accept(this);
                        }

                        OutputPossibleLineBreak('}');
                        SetContextOutputPosition(node.CloseContext);
                    }

                    Output("from");
                    SetContextOutputPosition(node.FromContext);
                }

                // module is mandatory, but if it's null we didn't have one.
                if (node.ModuleName != null)
                {
                    Output(EscapeString(node.ModuleName));
                    SetContextOutputPosition(node.ModuleContext);
                }
            }
        }

        public void Visit(InitializerNode node)
        {
            if (node != null)
            {
                if (node.Binding != null)
                {
                    node.Binding.Accept(this);
                }

                OutputPossibleLineBreak('=');
                MarkSegment(node, null, node.AssignContext);

                if (node.Initializer != null)
                {
                    node.Initializer.Accept(this);
                }
            }
        }

        public void Visit(LabeledStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                if (!node.Label.IsNullOrWhiteSpace())
                {
                    if (node.LabelInfo.IfNotNull(li => !li.MinLabel.IsNullOrWhiteSpace()))
                    {
                        // output minified label
                        Output(node.LabelInfo.MinLabel);
                    }
                    else
                    {
                        // not minified -- just output original label
                        Output(node.Label);
                    }

                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);
                    OutputPossibleLineBreak(':');
                    MarkSegment(node, null, node.ColonContext);
                }

                if (node.Statement != null)
                {
                    m_startOfStatement = true;
                    node.Statement.Accept(this);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(LexicalDeclaration node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                // save the no-in state -- we'll reset before processing each initializer
                var isNoIn = m_noIn;

                Output(OperatorString(node.StatementToken));
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                Indent();
                var useNewLines = !(node.Parent is ForStatement);

                for (var ndx = 0; ndx < node.Count; ++ndx)
                {
                    var decl = node[ndx];
                    if (decl != null)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            if (useNewLines)
                            {
                                NewLine();
                            }
                            else if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        // be sure to set the no-in state to whatever it was when we entered
                        // this node, because each declaration might reset it as it's outputting
                        // its child nodes
                        m_noIn = isNoIn;
                        decl.Accept(this);
                    }
                }

                Unindent();
                EndSymbol(symbol);
            }
        }

        public void Visit(LookupExpression node)
        {
            if (node != null)
            {
                // all identifier should be treated as if they start with a valid
                // identifier character. That might not always be the case, like when
                // we consider an ASP.NET block to output the start of an identifier.
                // so let's FORCE the insert-space logic here.
                if (JSScanner.IsValidIdentifierPart(m_lastCharacter))
                {
                    OutputSpaceOrLineBreak();
                }

                var symbol = StartSymbol(node);

                Output(node.VariableField != null
                    ? node.VariableField.ToString()
                    : node.Name);
                MarkSegment(node, node.Name, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;

                EndSymbol(symbol);
            }
        }

        public void Visit(MemberExpression node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;
                m_noIn = false;

                if (node.Root != null)
                {
                    var constantWrapper = node.Root as ConstantWrapper;
                    if (constantWrapper != null 
                        && (constantWrapper.IsFiniteNumericLiteral || constantWrapper.IsOtherDecimal))
                    {
                        // numeric constant wrapper that isn't NaN or Infinity - get the formatted text version.
                        // if the number has issues, then don't format it and just use the source.
                        string numericText;
                        if (constantWrapper.Context == null
                            || !constantWrapper.Context.HasCode
                            || (m_settings.IsModificationAllowed(TreeModifications.MinifyNumericLiterals) && !constantWrapper.MayHaveIssues))
                        {
                            // apply minification to the literal to get it as small as possible
                            numericText = NormalizeNumber(constantWrapper.ToNumber(), constantWrapper.Context);
                        }
                        else
                        {
                            // context is not null but we don't want to minify numeric literals.
                            // just use the original literal from the context.
                            numericText = constantWrapper.Context.Code;
                        }

                        // if the value is negative, we're going to need to wrap it in parens
                        if (numericText.StartsWith("-", StringComparison.Ordinal))
                        {
                            Output('(');
                            Output(numericText);
                            Output(')');
                        }
                        else
                        {
                            // if there is no decimal point in the number and no exponent, then we may need to add 
                            // a decimal point to the end of the number so the member-dot operator doesn't get mistaken 
                            // for the decimal point and generate a syntax error.
                            Output(numericText);
                            if (numericText.IndexOf('.') < 0
                                && numericText.IndexOf("e", StringComparison.OrdinalIgnoreCase) < 0)
                            {
                                // HOWEVER... octal literals don't need the dot. So if this number starts with zero and
                                // has more than one digit, we need to check for octal literals and 0xd+ 0bd+ and 0od+ literals,
                                // because THOSE don't need the extra dot, either. 
                                bool addDecimalPoint = !numericText.StartsWith("0", StringComparison.Ordinal) || numericText.Length == 1;
                                if (!addDecimalPoint)
                                {
                                    // But we might also have a number that just starts with zero and is a regular decimal (like 0009).
                                    // if the second "digit" isn't a number, then we have 0x or 0b or 0o, so we don't have to do
                                    // any further tests -- we know we don't need the extra decimal point. Otherwise we need to
                                    // make sure this
                                    if (JSScanner.IsDigit(numericText[1]))
                                    {
                                        // the second character is a digit, so we know we aren't 0x, 0b, or 0o. But we start with
                                        // a zero -- so we need to test to see if this is an octal literal, because they do NOT need
                                        // the extra decimal point. But if it isn't an octal literal, we DO need it after all.
                                        for (var ndx = 1; ndx < numericText.Length; ++ndx)
                                        {
                                            if ('7' < numericText[ndx])
                                            {
                                                // NOT octal; we need the extra dot
                                                addDecimalPoint = true;
                                                break;
                                            }
                                        }
                                    }
                                }

                                if (addDecimalPoint)
                                {
                                    Output('.');
                                }
                            }
                        }
                    }
                    else
                    {
                        // not a numeric constant wrapper
                        var needsParens = node.Root.Precedence < node.Precedence;
                        if (!needsParens)
                        {
                            // if the root is a new operator with no arguments, then we need to wrap
                            var callNode = node.Root as CallExpression;
                            if (callNode != null
                                && callNode.IsConstructor
                                && (callNode.Arguments == null || callNode.Arguments.Count == 0))
                            {
                                needsParens = true;
                            }
                        }

                        AcceptNodeWithParens(node.Root, needsParens);
                    }

                    SetContextOutputPosition(node.Context);
                }

                OutputPossibleLineBreak('.');
                MarkSegment(node, node.Name, node.NameContext);
                Output(node.Name);
                m_startOfStatement = false;
                m_noIn = isNoIn;

                EndSymbol(symbol);
            }
        }

        public void Visit(ModuleDeclaration node)
        {
            if (node != null)
            {
                if (node.IsImplicit)
                {
                    // implicit module declarations just skip the module part and output only the body.
                    if (node.Body != null)
                    {
                        node.Body.Accept(this);
                    }
                }
                else
                {
                    // explicit module statement
                    Output("module");
                    SetContextOutputPosition(node.Context);
                    SetContextOutputPosition(node.ModuleContext);

                    if (node.Binding != null)
                    {
                        // bind entire external module to an identifier
                        node.Binding.Accept(this);
                        Output("from");
                        SetContextOutputPosition(node.FromContext);

                        if (node.ModuleName != null)
                        {
                            Output(EscapeString(node.ModuleName));
                            SetContextOutputPosition(node.ModuleContext);
                        }
                    }
                    else
                    {
                        // inline module declaration
                        m_noLineBreaks = true;
                        if (node.ModuleName != null)
                        {
                            Output(EscapeString(node.ModuleName));
                            SetContextOutputPosition(node.ModuleContext);
                        }

                        if (node.Body != null)
                        {
                            node.Body.Accept(this);
                        }
                        else
                        {
                            // no body; add an empty one.
                            Output("{}");
                        }
                    }
                }
            }
        }

        public void Visit(ObjectLiteral node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;
                m_noIn = false;

                // if start of statement, need to enclose in parens
                var encloseInParens = m_startOfStatement;
                if (encloseInParens)
                {
                    OutputPossibleLineBreak('(');
                }

                OutputPossibleLineBreak('{');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                Indent();

                var count = node.Properties.IfNotNull(p => p.Count);
                if (count > 1)
                {
                    NewLine();
                }

                // output each key/value pair
                if (node.Properties != null)
                {
                    node.Properties.Accept(this);
                }

                Unindent();
                if (count > 1)
                {
                    NewLine();
                }

                Output('}');
                MarkSegment(node, null, node.Context);
                if (encloseInParens)
                {
                    Output(')');
                }

                m_noIn = isNoIn;

                EndSymbol(symbol);
            }
        }

        public void Visit(ObjectLiteralField node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                if (m_settings.QuoteObjectLiteralProperties)
                {
                    // we always want to quote object literal property names, no matter whether
                    // they are valid JS identifiers, numbers, or whatever. Typically this is done
                    // because we're generating JSON output, which requires quotes.
                    if (node.PrimitiveType == PrimitiveType.String)
                    {
                        // strings are always quoted anyway
                        Visit(node as ConstantWrapper);
                    }
                    else
                    {
                        // output quotes around it
                        Output('"');
                        Visit(node as ConstantWrapper);
                        Output('"');
                    }
                }
                else if (node.PrimitiveType == PrimitiveType.String)
                {
                    // call the base to format the value
                    // determine whether we need quotes or not
                    var propertyName = node.ToString();
                    if (!string.IsNullOrEmpty(propertyName)
                        && JSScanner.IsSafeIdentifier(propertyName)
                        && !JSScanner.IsKeyword(propertyName, node.EnclosingScope.IfNotNull(s => s.UseStrict)))
                    {
                        Output(propertyName);
                        MarkSegment(node, null, node.Context);
                    }
                    else
                    {
                        // base implementation adds quotes
                        Visit(node as ConstantWrapper);
                    }
                }
                else
                {
                    // not a string -- just output it
                    Visit(node as ConstantWrapper);
                }

                OutputPossibleLineBreak(':');
                MarkSegment(node, null, node.ColonContext);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ObjectLiteralProperty node)
        {
            if (node != null)
            {
                // getter/setter will be handled by the value, which is the function object
                if (node.Name != null && !(node.Name is GetterSetter))
                {
                    node.Name.Accept(this);
                    SetContextOutputPosition(node.Context);
                }

                if (node.Value != null)
                {
                    AcceptNodeWithParens(node.Value, node.Value.Precedence == OperatorPrecedence.Comma);
                }
            }
        }

        public void Visit(ParameterDeclaration node)
        {
            if (node != null)
            {
                if (node.HasRest)
                {
                    Output(OperatorString(JSToken.RestSpread));
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);
                }

                // output the binding
                if (node.Binding != null)
                {
                    node.Binding.Accept(this);
                }

                // optional initializer
                if (node.Initializer != null)
                {
                    if (m_settings.OutputMode == OutputMode.MultipleLines && m_settings.IndentSize > 0)
                    {
                        OutputPossibleLineBreak(' ');
                        OutputPossibleLineBreak('=');
                        BreakLine(false);
                        if (!m_onNewLine)
                        {
                            OutputPossibleLineBreak(' ');
                        }
                    }
                    else
                    {
                        OutputPossibleLineBreak('=');
                    }

                    AcceptNodeWithParens(node.Initializer, node.Initializer.Precedence == OperatorPrecedence.Comma);
                }
            }
        }

        public void Visit(RegExpLiteral node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                m_startOfStatement = false;

                // cannot have a line break anywhere in this node
                Output('/');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                Output(node.Pattern);
                Output('/');
                if (!string.IsNullOrEmpty(node.PatternSwitches))
                {
                    Output(node.PatternSwitches);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ReturnStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("return");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                if (node.Operand != null)
                {
                    if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Output(' ');
                    }

                    // no page breaks allowed here
                    m_noLineBreaks = true;
                    Indent();
                    node.Operand.Accept(this);
                    Unindent();
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(SwitchStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("switch");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Expression != null)
                {
                    node.Expression.Accept(this);
                }
                OutputPossibleLineBreak(')');
                if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                    || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.BraceOnNewLine))
                {
                    NewLine();
                }
                else if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('{');
                MarkSegment(node, null, node.BraceContext); 
                Indent();

                AstNode prevSwitchCase = null;
                for (var ndx = 0; ndx < node.Cases.Count; ++ndx)
                {
                    var switchCase = node.Cases[ndx];
                    if (switchCase != null)
                    {
                        if (prevSwitchCase != null && m_requiresSeparator.Query(prevSwitchCase))
                        {
                            // because the next switch-case will always start with either the case or default
                            // keyword, if the semicolon we are about the output would be at the end of a newline,
                            // we can omit the semicolon altogether and just let the semicolon-insertion rules
                            // kick in.
                            if (ReplaceableSemicolon())
                            {
                                MarkSegment(prevSwitchCase, null, prevSwitchCase.TerminatingContext);
                            }
                        }

                        NewLine();
                        switchCase.Accept(this);
                        prevSwitchCase = switchCase;
                    }
                }

                Unindent();
                NewLine();
                OutputPossibleLineBreak('}');
                MarkSegment(node, null, node.BraceContext);

                EndSymbol(symbol);
            }
        }

        public void Visit(SwitchCase node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                if (node.CaseValue != null)
                {
                    Output("case");
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);

                    m_startOfStatement = false;
                    node.CaseValue.Accept(this);
                }
                else
                {
                    Output("default");
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);
                }

                OutputPossibleLineBreak(':');
                MarkSegment(node, null, node.ColonContext);
                if (node.Statements != null && node.Statements.Count > 0)
                {
                    Indent();
                    AstNode prevStatement = null;
                    for (var ndx = 0; ndx < node.Statements.Count; ++ndx)
                    {
                        var statement = node.Statements[ndx];
                        if (statement != null)
                        {
                            if (prevStatement != null && m_requiresSeparator.Query(prevStatement))
                            {
                                OutputPossibleLineBreak(';');
                                MarkSegment(prevStatement, null, prevStatement.TerminatingContext);
                            }

                            NewLine();
                            m_startOfStatement = true;
                            statement.Accept(this);
                            prevStatement = statement;
                        }
                    }

                    Unindent();
                }

                EndSymbol(symbol);
            }
        }

        public virtual void Visit(TemplateLiteral node)
        {
            if (node != null)
            {
                if (node.Function != null)
                {
                    node.Function.Accept(this);
                    m_startOfStatement = false;
                }

                // get the text string to output. If we don't want to minify string literals,
                // then we should also not minify template literals (since they're just special strings)
                var text = node.Text;
                if (node.TextContext != null && !m_settings.IsModificationAllowed(TreeModifications.MinifyStringLiterals))
                {
                    // use the raw version of the text source
                    text = node.TextContext.Code;
                }

                if (!text.IsNullOrWhiteSpace())
                {
                    Output(text);
                    MarkSegment(node, null, node.TextContext ?? node.Context);
                    SetContextOutputPosition(node.TextContext);
                    m_startOfStatement = false;
                }

                if (node.Expressions != null && node.Expressions.Count > 0)
                {
                    node.Expressions.ForEach<TemplateLiteralExpression>(expr =>
                        {
                            expr.Accept(this);
                        });
                }
            }
        }

        public virtual void Visit(TemplateLiteralExpression node)
        {
            if (node != null)
            {
                if (node.Expression != null)
                {
                    node.Expression.Accept(this);
                }

                if (!node.Text.IsNullOrWhiteSpace())
                {
                    Output(node.Text);
                    MarkSegment(node, null, node.TextContext);
                    SetContextOutputPosition(node.TextContext);
                    m_startOfStatement = false;
                }
            }
        }

        public void Visit(ThisLiteral node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("this");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                EndSymbol(symbol);
            }
        }

        public void Visit(ThrowStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("throw");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                if (node.Operand != null)
                {
                    m_noLineBreaks = true;
                    node.Operand.Accept(this);
                }

                if (m_settings.MacSafariQuirks)
                {
                    // force the statement ending with a semicolon
                    OutputPossibleLineBreak(';');
                    MarkSegment(node, null, node.TerminatingContext);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(TryStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                OutputTryBranch(node);

                var hasCatchBlock = false;
                if (node.CatchParameter != null)
                {
                    hasCatchBlock = true;
                    OutputCatchBranch(node);
                }

                if (!hasCatchBlock || (node.FinallyBlock != null && node.FinallyBlock.Count > 0))
                {
                    OutputFinallyBranch(node);
                }

                EndSymbol(symbol);
            }
        }

        private void OutputTryBranch(TryStatement node)
        {
            Output("try");
            MarkSegment(node, null, node.Context);
            SetContextOutputPosition(node.Context);
            if (node.TryBlock == null || node.TryBlock.Count == 0)
            {
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                Output("{}");
                BreakLine(false);
            }
            else
            {
                if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                    || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.TryBlock.BraceOnNewLine))
                {
                    NewLine();
                }
                else if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                node.TryBlock.Accept(this);
            }
        }

        private void OutputCatchBranch(TryStatement node)
        {
            NewLine();
            Output("catch(");
            node.CatchParameter.IfNotNull(p => p.Accept(this));
            OutputPossibleLineBreak(')');

            if (node.CatchBlock == null || node.CatchBlock.Count == 0)
            {
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                Output("{}");
                BreakLine(false);
            }
            else
            {
                if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                    || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.CatchBlock.BraceOnNewLine))
                {
                    NewLine();
                }
                else if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                node.CatchBlock.Accept(this);
            }
        }

        private void OutputFinallyBranch(TryStatement node)
        {
            NewLine();
            Output("finally");
            MarkSegment(node, null, node.FinallyContext);
            if (node.FinallyBlock == null || node.FinallyBlock.Count == 0)
            {
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                Output("{}");
                BreakLine(false);
            }
            else
            {
                if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                    || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.FinallyBlock.BraceOnNewLine))
                {
                    NewLine();
                }
                else if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                node.FinallyBlock.Accept(this);
            }
        }

        public void Visit(VarDeclaration node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                // save the no-in state -- we'll reset before processing each initializer
                var isNoIn = m_noIn;

                Output("var");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                Indent();
                var useNewLines = !(node.Parent is ForStatement);

                for (var ndx = 0; ndx < node.Count; ++ndx)
                {
                    var decl = node[ndx];
                    if (decl != null)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            if (useNewLines)
                            {
                                NewLine();
                            }
                            else if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        // be sure to set the no-in state to whatever it was when we entered
                        // this node, because each declaration might reset it as it's outputting
                        // its child nodes
                        m_noIn = isNoIn;
                        decl.Accept(this);
                    }
                }
                Unindent();

                EndSymbol(symbol);
            }
        }

        public void Visit(VariableDeclaration node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                // output the binding
                if (node.Binding != null)
                {
                    node.Binding.Accept(this);
                }

                m_startOfStatement = false;
                if (node.Initializer != null)
                {
                    if (node.IsCCSpecialCase)
                    {
                        // we haven't output a cc_on yet -- output it now.
                        // if we have, we really only need to output one if we had one to begin with AND
                        // we are NOT removing unnecessary ones
                        if (!m_outputCCOn
                            || (node.UseCCOn && !m_settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryCCOnStatements)))
                        {
                            Output("/*@cc_on=");
                            m_outputCCOn = true;
                        }
                        else
                        {
                            Output("/*@=");
                        }
                    }
                    else
                    {
                        if (m_settings.OutputMode == OutputMode.MultipleLines && m_settings.IndentSize > 0)
                        {
                            OutputPossibleLineBreak(' ');
                            OutputPossibleLineBreak('=');
                            BreakLine(false);
                            if (!m_onNewLine)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }
                        else
                        {
                            OutputPossibleLineBreak('=');
                        }
                    }

                    AcceptNodeWithParens(node.Initializer, node.Initializer.Precedence == OperatorPrecedence.Comma);

                    if (node.IsCCSpecialCase)
                    {
                        Output("@*/");
                    }
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(UnaryExpression node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                var isNoIn = m_noIn;
                m_noIn = false;

                if (node.IsPostfix)
                {
                    if (node.Operand != null)
                    {
                        AcceptNodeWithParens(node.Operand, node.Operand.Precedence < node.Precedence);
                        SetContextOutputPosition(node.Context, node.Operand.Context);
                    }

                    // the only postfix unary operators are ++ and --, and when in the postfix position,
                    // line breaks are NOT allowed between the operand and the operator.
                    // doesn't seem to need this flag set here, but set it anyways just in case.
                    m_noLineBreaks = true;
                    Output(OperatorString(node.OperatorToken));
                    MarkSegment(node, null, node.OperatorContext);
                    m_startOfStatement = false;
                }
                else if (node.OperatorToken == JSToken.RestSpread)
                {
                    // spread operator. Output the spread token followed by the
                    // operand. I don't think we need parentheses or anything.
                    Output(OperatorString(JSToken.RestSpread));
                    MarkSegment(node, null, node.OperatorContext ?? node.Context);
                    node.Operand.IfNotNull(o => o.Accept(this));
                }
                else
                {
                    if (node.OperatorInConditionalCompilationComment)
                    {
                        // if we haven't output a cc_on yet, we ALWAYS want to do it now, whether or not the 
                        // sources had one. Otherwise, we only only want to output one if we had one and we aren't
                        // removing unneccesary ones.
                        if (!m_outputCCOn
                            || (node.ConditionalCommentContainsOn && !m_settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryCCOnStatements)))
                        {
                            // output it now and set the flag that we have output them
                            Output("/*@cc_on");
                            m_outputCCOn = true;
                        }
                        else
                        {
                            Output("/*@");
                        }

                        Output(OperatorString(node.OperatorToken));
                        MarkSegment(node, null, node.OperatorContext);
                        SetContextOutputPosition(node.Context);
                        Output("@*/");
                    }
                    else
                    {
                        Output(OperatorString(node.OperatorToken));
                        MarkSegment(node, null, node.OperatorContext ?? node.Context);
                        SetContextOutputPosition(node.Context);
                        
                        // if this is a yield delegator, output the asterisk
                        if (node.OperatorToken == JSToken.Yield && node.IsDelegator)
                        {
                            Output('*');
                        }
                    }

                    m_startOfStatement = false;
                    if (node.Operand != null)
                    {
                        AcceptNodeWithParens(node.Operand, node.Operand.Precedence < node.Precedence);
                    }
                }

                m_noIn = isNoIn;
                EndSymbol(symbol);
            }
        }

        public void Visit(WhileStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("while");
                SetContextOutputPosition(node.Context);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }
                OutputPossibleLineBreak(')');

                OutputBlock(node.Body);

                EndSymbol(symbol);
            }
        }

        public void Visit(WithStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("with");
                SetContextOutputPosition(node.Context);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.WithObject != null)
                {
                    node.WithObject.Accept(this);
                }
                OutputPossibleLineBreak(')');

                OutputBlock(node.Body);
                EndSymbol(symbol);
            }
        }

        #endregion

        #region output methods

        private void Output(string text)
        {
            if (!string.IsNullOrEmpty(text))
            {
                // insert a space if needed, then the character
                InsertSpaceIfNeeded(text);

                // save the start of this segment
                m_segmentStartLine = m_lineCount;
                m_segmentStartColumn = m_lineLength;

                m_lineLength += WriteToStream(text);
                m_noLineBreaks = false;

                // if it ends in a newline, we're still on a newline
                var lastChar = text[text.Length - 1];

                m_onNewLine = (lastChar == '\n' || lastChar == '\r'); ;

                // now set the "last character" state
                SetLastCharState(lastChar, text);
            }
        }

        private void Output(char ch)
        {
            // insert a space if needed, then the character
            InsertSpaceIfNeeded(ch);

            // save the start of this segment
            m_segmentStartLine = m_lineCount;
            m_segmentStartColumn = m_lineLength;

            m_lineLength += WriteToStream(ch);
            m_noLineBreaks = false;

            // determine if this was a newline character
            m_onNewLine = (ch == '\n' || ch == '\r');

            // now set the "last character" state
            SetLastCharState(ch);
        }

        private void OutputSpaceOrLineBreak()
        {
            if (m_noLineBreaks)
            {
                // don't bother going through the WriteToStream method, since
                // we KNOW a space won't be expanded to \u0020.
                m_outputStream.Write(' ');
                ++m_lineLength;
                m_lastCharacter = ' ';
            }
            else
            {
                OutputPossibleLineBreak(' ');
            }
        }

        private void InsertSpaceIfNeeded(char ch)
        {
            // shortcut a space character -- we never need a space before a space!
            if (ch != ' ')
            {
                if (m_addSpaceIfTrue != null)
                {
                    if (m_addSpaceIfTrue(ch))
                    {
                        OutputSpaceOrLineBreak();
                    }

                    // reset the function
                    m_addSpaceIfTrue = null;
                }
                else if ((ch == '+' || ch == '-') && m_lastCharacter == ch)
                {
                    // if the current character is a + or - and the last character was the same.
                    // if the previous character was an ODD number of the same character, 
                    // then we need to add a space so it doesn't get read as ++ (or --)
                    if (m_lastCountOdd)
                    {
                        OutputSpaceOrLineBreak();
                    }
                }
                else if ((m_lastCharacter == '@' || JSScanner.IsValidIdentifierPart(m_lastCharacter)) && JSScanner.IsValidIdentifierPart(ch))
                {
                    // either the last character is a valid part of an identifier and the current character is, too;
                    // OR the last part was numeric and the current character is a .
                    // we need to separate those with spaces as well
                    OutputSpaceOrLineBreak();
                }
            }
        }

        private void InsertSpaceIfNeeded(string text)
        {
            // if the current character is a + or - and the last character was the same....
            var ch = text[0];
            if (m_addSpaceIfTrue != null)
            {
                if (m_addSpaceIfTrue(ch))
                {
                    OutputSpaceOrLineBreak();
                }

                // reset the function
                m_addSpaceIfTrue = null;
            }
            else if ((ch == '+' || ch == '-') && m_lastCharacter == ch)
            {
                // if we want to put a + or a - in the stream, and the previous character was
                // an odd number of the same, then we need to add a space so it doesn't
                // get read as ++ (or --)
                if (m_lastCountOdd)
                {
                    OutputSpaceOrLineBreak();
                }
            }
            else if ((m_lastCharacter == '@' || JSScanner.IsValidIdentifierPart(m_lastCharacter)) 
                && (text[0] == '\\' || JSScanner.StartsWithValidIdentifierPart(text)))
            {
                // either the last character is a valid part of an identifier and the current character is, too;
                // OR the last part was numeric and the current character is a .
                // we need to separate those with spaces as well
                OutputSpaceOrLineBreak();
            }
        }

        private void SetLastCharState(char ch)
        {
            // if it's a + or a -, we need to adjust the odd state
            if (ch == '+' || ch == '-')
            {
                if (ch == m_lastCharacter)
                {
                    // same as the last string -- so we're adding one to it.
                    // if it was odd before, it's now even; if it was even before,
                    // it's now odd
                    m_lastCountOdd = !m_lastCountOdd;
                }
                else
                {
                    // not the same as last time, so this is a string of 1
                    // characters, which is odd
                    m_lastCountOdd = true;
                }
            }
            else
            {
                // neither + nor -; reset the odd state
                m_lastCountOdd = false;
            }

            m_lastCharacter = ch;
        }

        private void SetLastCharState(char lastChar, string text)
        {
            if (lastChar == '+' || lastChar == '-')
            {
                // see HOW MANY of those characters were at the end of the string
                var ndxDifferent = text.Length - 1;
                while (--ndxDifferent >= 0)
                {
                    if (text[ndxDifferent] != lastChar)
                    {
                        break;
                    }
                }

                // if the first diff index is less than zero, then the whole string is one of
                // these two special characters
                if (ndxDifferent < 0 && m_lastCharacter == lastChar)
                {
                    // the whole string is the same character, AND it's the same character 
                    // at the end of the last time we output stuff. We need to take into 
                    // account the previous state when we set the current state.
                    // it's a logical XOR -- if the two values are the same, m_lastCountOdd is false;
                    // it they are different, m_lastCountOdd is true.
                    m_lastCountOdd = (text.Length % 2 == 1) ^ m_lastCountOdd;
                }
                else
                {
                    // either the whole string wasn't the same character, OR the previous ending
                    // wasn't the same character. Either way, the current state is determined 
                    // exclusively by the number of characters we found at the end of this string
                    // get the number of same characters ending this string, mod by 2, and if the
                    // result is 1, it's an odd number of characters.
                    m_lastCountOdd = (text.Length - 1 - ndxDifferent) % 2 == 1;
                }
            }
            else
            {
                // say we weren't odd
                m_lastCountOdd = false;
            }

            // save the last character for next time
            m_lastCharacter = lastChar;
        }

        private void Indent()
        {
            ++m_indentLevel;
        }

        private void Unindent()
        {
            --m_indentLevel;
        }

        private void OutputPossibleLineBreak(char ch)
        {
            if (ch == ' ')
            {
                // break the line if it's already too long, but don't force it
                BreakLine(false);

                // if we aren't on a new line, then output our space character
                if (!m_onNewLine)
                {
                    m_lineLength += WriteToStream(ch);
                    m_lastCharacter = ch;
                }
            }
            else
            {
                // always output the character, although we can line-break
                // after it if needed
                InsertSpaceIfNeeded(ch);

                // save the start of this segment
                m_segmentStartLine = m_lineCount;
                m_segmentStartColumn = m_lineLength;
                
                m_lineLength += WriteToStream(ch);
                m_onNewLine = false;
                m_lastCharacter = ch;

                // break the line if it's too long, but don't force it
                BreakLine(false);
            }
        }

        private bool ReplaceableSemicolon()
        {
            var outputSemicolon = false;

            // this is a terminating semicolon that might be replaced with a line-break
            // if needed. Semicolon-insertion would suffice to reconstitute it.
            if (m_lineLength < m_settings.LineBreakThreshold)
            {
                // save the start of this segment
                m_segmentStartLine = m_lineCount;
                m_segmentStartColumn = m_lineLength;

                // output the semicolon
                // don't bother going through the WriteToStream method, since we
                // KNOW a semicolon won't be expanded to \u003b
                m_outputStream.Write(';');
                ++m_lineLength;
                m_onNewLine = false;
                m_lastCharacter = ';';
                outputSemicolon = true;
            }

            // break the line if it's too long, but don't force it
            BreakLine(false);
            return outputSemicolon;
        }

        private void BreakLine(bool forceBreak)
        {
            if (!m_onNewLine && (forceBreak || m_lineLength >= m_settings.LineBreakThreshold))
            {
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    NewLine();
                }
                else
                {
                    // terminate the line and start a new one
                    // don't bother going through the WriteToStream method, since we
                    // KNOW a \n character won't be expanded to \u000a
                    m_outputStream.Write('\n');
                    m_lineCount++;

                    // set the appropriate newline state
                    m_lineLength = 0;
                    m_onNewLine = true;
                    m_lastCharacter = ' ';
                }
            }
        }

        private void NewLine()
        {
            if (m_settings.OutputMode == OutputMode.MultipleLines && !m_onNewLine)
            {
                // output the newline character -- don't go through WriteToStream
                // since we KNOW it won't get expanded to \uXXXX formats.
                m_outputStream.WriteLine();
                m_lineCount++;

                // if the indent level is greater than zero, output the indent spaces
                if (m_indentLevel > 0)
                {
                    // the spaces won't get expanded to \u0020, so don't bother going
                    // through the WriteToStream method.
                    var numSpaces = m_indentLevel * m_settings.IndentSize;
                    m_lineLength = numSpaces;
                    while (numSpaces-- > 0)
                    {
                        m_outputStream.Write(' ');
                    }
                }
                else
                {
                    m_lineLength = 0;
                }

                // say our last character was a space
                m_lastCharacter = ' ';

                // we just output a newline
                m_onNewLine = true;
            }
        }

        // write a text string to the output stream, optionally expanding any single characters
        // to \uXXXX format if outside the ASCII range. Return the actual number of characters written
        // after any expansion.
        private int WriteToStream(string text)
        {
            // if we always want to encode non-ascii characters, then we need
            // to look at each one and see if we need to encode anything!
            if (m_settings.AlwaysEscapeNonAscii)
            {
                StringBuilder sb = null;
                try
                {
                    var runStart = 0;
                    for (var ndx = 0; ndx < text.Length; ++ndx)
                    {
                        // if the character is over the ASCII range, we'll need to escape it
                        if (text[ndx] > '\u007f')
                        {
                            // if we haven't yet created the builder, create it now
                            if (sb == null)
                            {
                                sb = StringBuilderPool.Acquire();
                            }

                            // if there's a run of unescaped characters waiting to be
                            // output, output it now
                            if (ndx > runStart)
                            {
                                sb.Append(text, runStart, ndx - runStart);
                            }

                            // format the current character in \uXXXX, and start the next
                            // run at the NEXT character.
                            sb.AppendFormat(CultureInfo.InvariantCulture, "\\u{0:x4}".FormatInvariant((int)text[ndx]));
                            runStart = ndx + 1;
                        }
                    }

                    // if nothing needed escaping, the builder will still be null and we
                    // have nothing else to do (just use the string as-is)
                    if (sb != null)
                    {
                        // if there is an unescaped run at the end still left, add it now
                        if (runStart < text.Length)
                        {
                            sb.Append(text, runStart, text.Length - runStart);
                        }

                        // and use the fully-escaped string going forward.
                        text = sb.ToString();
                    }
                }
                finally
                {
                    sb.Release();
                }
            }

            m_outputStream.Write(text);
            return text.Length;
        }

        // write a single character to the stream, optionally expanding it to a \uXXXX sequence
        // if needed. Return the number of characters sent to the stream (1 or 6)
        private int WriteToStream(char ch)
        {
            if (m_settings.AlwaysEscapeNonAscii && ch > '\u007f')
            {
                // expand it to the \uXXXX format, which is six characters
                m_outputStream.Write("\\u{0:x4}", (int)ch);
                return 6;
            }
            else
            {
                m_outputStream.Write(ch);
                return 1;
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification="Big but simple case statement")]
        public static string OperatorString(JSToken token)
        {
            switch (token)
            {
                case JSToken.Decrement: return "--";
                case JSToken.Delete: return "delete";
                case JSToken.Increment: return "++";
                case JSToken.TypeOf: return "typeof";
                case JSToken.Void: return "void";
                case JSToken.LogicalNot: return "!";
                case JSToken.BitwiseNot: return "~";
                case JSToken.Minus: return "-";
                case JSToken.Plus: return "+";
                case JSToken.Multiply: return "*";
                case JSToken.BitwiseAnd: return "&";
                case JSToken.BitwiseOr: return "|";
                case JSToken.BitwiseXor: return "^";
                case JSToken.LogicalAnd: return "&&";
                case JSToken.LogicalOr: return "||";
                case JSToken.Assign: return "=";
                case JSToken.BitwiseAndAssign: return "&=";
                case JSToken.BitwiseOrAssign: return "|=";
                case JSToken.BitwiseXorAssign: return "^=";
                case JSToken.Comma: return ",";
                case JSToken.Equal: return "==";
                case JSToken.GreaterThan: return ">";
                case JSToken.GreaterThanEqual: return ">=";
                case JSToken.In: return "in";
                case JSToken.InstanceOf: return "instanceof";
                case JSToken.LeftShift: return "<<";
                case JSToken.LeftShiftAssign: return "<<=";
                case JSToken.LessThan: return "<";
                case JSToken.LessThanEqual: return "<=";
                case JSToken.MinusAssign: return "-=";
                case JSToken.Modulo: return "%";
                case JSToken.ModuloAssign: return "%=";
                case JSToken.MultiplyAssign: return "*=";
                case JSToken.NotEqual: return "!=";
                case JSToken.PlusAssign: return "+=";
                case JSToken.RightShift: return ">>";
                case JSToken.RightShiftAssign: return ">>=";
                case JSToken.StrictEqual: return "===";
                case JSToken.StrictNotEqual: return "!==";
                case JSToken.UnsignedRightShift: return ">>>";
                case JSToken.UnsignedRightShiftAssign: return ">>>=";
                case JSToken.Divide: return "/";
                case JSToken.DivideAssign: return "/=";
                case JSToken.Let: return "let";
                case JSToken.Const: return "const";
                case JSToken.ArrowFunction: return "=>";
                case JSToken.RestSpread: return "...";
                case JSToken.Yield: return "yield";
                case JSToken.Await: return "await";
                case JSToken.Get: return "get";
                case JSToken.Set: return "set";

                default: return string.Empty;
            }
        }

        #endregion

        #region Helper methods

        private void AcceptNodeWithParens(AstNode node, bool needsParens)
        {
            // if we need parentheses, add the opening
            if (needsParens)
            {
                OutputPossibleLineBreak('(');

                // because we output an open paren, reset the start flag
                m_startOfStatement = false;

                // and because we are outputting a paren, we are no longer in a no-in scenario
                m_noIn = false;
            }

            // now output the node
            node.Accept(this);

            // if we need parentheses, add the closing and restore whatever noin state we had
            if (needsParens)
            {
                Output(')');
            }

            // make SURE the start flag is reset
            m_startOfStatement = false;
        }

        private static bool shouldWrapArgumentListInParens(FunctionObject node)
        {
            // we need to wrap the parens for all function object other than arrow functions,
            // and for arrow functions where there are zero or more than one parameter.
            // if it IS an arrow function with a single parameter, we still want to wrap the
            // parameter in parens if it's a rest argument or a destructuring array.
            if (node.FunctionType != FunctionType.ArrowFunction
                || node.ParameterDeclarations.Count != 1)
            {
                return true;
            }

            var declaration = node.ParameterDeclarations[0] as ParameterDeclaration;
            return declaration == null
                || declaration.HasRest
                || declaration.Binding is ArrayLiteral;
        }

        /// <summary>
        /// Output everything for a function except the initial keyword
        /// </summary>
        /// <param name="node"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void OutputFunctionArgsAndBody(FunctionObject node)
        {
            if (node != null)
            {
                if (node.ParameterDeclarations != null)
                {
                    Indent();

                    bool wrapInParens = shouldWrapArgumentListInParens(node);

                    if (wrapInParens)
                    {
                        m_startOfStatement = false;
                        OutputPossibleLineBreak('(');
                        MarkSegment(node, null, node.ParameterDeclarations.Context);
                    }

                    AstNode paramDecl = null;
                    for (var ndx = 0; ndx < node.ParameterDeclarations.Count; ++ndx)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            MarkSegment(node, null, paramDecl.IfNotNull(p => p.TerminatingContext) ?? node.ParameterDeclarations.Context);

                            if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        paramDecl = node.ParameterDeclarations[ndx];
                        if (paramDecl != null)
                        {
                            paramDecl.Accept(this);
                        }
                    }

                    Unindent();
                    if (wrapInParens)
                    {
                        OutputPossibleLineBreak(')');
                        MarkSegment(node, null, node.ParameterDeclarations.Context);
                    }
                }
                else if (node.FunctionType == FunctionType.ArrowFunction)
                {
                    // empty arrow function parameters need the empty parentheses
                    OutputPossibleLineBreak('(');
                    OutputPossibleLineBreak(')');
                    m_startOfStatement = false;
                }

                if (node.FunctionType == FunctionType.ArrowFunction)
                {
                    if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }

                    Output(OperatorString(JSToken.ArrowFunction));
                    if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }
                }

                if (node.Body == null || node.Body.Count == 0)
                {
                    Output("{}");
                    MarkSegment(node, null, node.Body.IfNotNull(b => b.Context));
                    BreakLine(false);
                }
                else if (node.FunctionType == FunctionType.ArrowFunction
                    && node.Body.Count == 1
                    && node.Body.IsConcise)
                {
                    // the arrow function body has only one "statement" and it's not a return.
                    // assume it's a concise expression body and just output it
                    var body = node.Body[0];
                    var requiresExplicitReturn = body is ObjectLiteral || body is CommaExpression;

                    if (requiresExplicitReturn)
                    {
                        Output("(");
                    }
                    node.Body[0].Accept(this);
                    if (requiresExplicitReturn)
                    {
                        Output(")");
                    }
                }
                else
                {
                    if (node.FunctionType == FunctionType.ArrowFunction)
                    {
                        Indent();
                    }

                    if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                        || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.Body.BraceOnNewLine))
                    {
                        NewLine();
                    }
                    else if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }

                    node.Body.Accept(this);

                    if (node.FunctionType == FunctionType.ArrowFunction)
                    {
                        Unindent();
                    }
                }
            }
        }

        /// <summary>
        /// outputs a semicolon for an empty block, just the statement for a single-statement block,
        /// and recurses to the Block visitor for mutiple-statement blocks
        /// </summary>
        /// <param name="block">block to output</param>
        private void OutputBlock(BlockStatement block)
        {
            if (block != null && block.ForceBraces)
            {
                // always output the braces
                OutputBlockWithBraces(block);
            }
            else if (block == null || block.Count == 0)
            {
                // semicolon-replacement cannot generate an empty statement
                OutputPossibleLineBreak(';');
                MarkSegment(block, null, block.IfNotNull(b => b.Context));
            }
            else if (block.Count == 1)
            {
                Indent();
                NewLine();
                if (block[0] is ImportantComment)
                {
                    // not a REAL statement, so follow the comment with a semicolon to
                    // be the actual statement for this block.
                    block[0].Accept(this);
                    OutputPossibleLineBreak(';');
                    MarkSegment(block, null, block.Context);
                }
                else
                {
                    m_startOfStatement = true;
                    block[0].Accept(this);
                }
                Unindent();
            }
            else
            {
                // always output the braces
                OutputBlockWithBraces(block);
            }
        }

        private void OutputBlockWithBraces(BlockStatement block)
        {
            if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && block.BraceOnNewLine))
            {
                NewLine();
            }
            else if (m_settings.OutputMode == OutputMode.MultipleLines)
            {
                OutputPossibleLineBreak(' ');
            }

            block.Accept(this);
        }

        private string InlineSafeString(string text)
        {
            if (m_settings.InlineSafeStrings)
            {
                var limit = text.Length - 1;

                var xmlOpen  = false;
                var datClose = false;

                for (var i = 0; i < limit; i++)
                {
                    var ch = text[i];

                    if ((ch == '<') && (text[i + 1] == '/'))
                    {
                        xmlOpen = true;
                    }

                    if ((ch == ']') && (text[i + 1] == ']'))
                    {
                        datClose = true;
                    }
                }

                // if there are ANY potential XML closing tags, which might confuse the browser
                // as to where the end of the inline script really is. Go conservative; the specs
                // say </ should be escaped, even though most browsers are smart enough to look for
                // </script. Also escape any XML CDATA closing tags.
                if (xmlOpen)
                {
                    // replace all of them with an escaped version so a text-compare won't match
                    text = text.Replace("</", @"<\/");
                }

                // if there are ANY closing CDATA strings...
                if (datClose)
                {
                    // replace all of them with an escaped version so a text-compare won't match
                    text = text.Replace("]]>", @"]\]>");
                }
            }

            return text;
        }

        #endregion

        #region numeric formatting methods

        public static string NormalizeNumber(double numericValue, SourceContext originalContext)
        {
            // numerics are doubles in JavaScript, so force it now as a shortcut
            if (double.IsNaN(numericValue) || double.IsInfinity(numericValue))
            {
                // weird number -- just return the original source code as-is. 
                if (originalContext != null && !string.IsNullOrEmpty(originalContext.Code)
                    && !originalContext.Document.IsGenerated)
                {
                    return originalContext.Code;
                }

                // Hmmm... don't have an original source. 
                // Must be generated. Just generate the proper JS literal.
                //
                // DANGER! If we just output NaN and Infinity and -Infinity blindly, that assumes
                // that there aren't any local variables in this scope chain with that
                // name, and we're pulling the GLOBAL properties. Might want to use properties
                // on the Number object -- which, of course, assumes that Number doesn't
                // resolve to a local variable...
                string objectName = double.IsNaN(numericValue) ? "NaN" : "Infinity";

                // get the enclosing lexical environment
                /*var enclosingScope = constant.EnclosingLexicalEnvironment;
                if (enclosingScope != null)
                {
                    var reference = enclosingScope.GetIdentifierReference(objectName, null);
                    if (reference.Category != BindingCategory.Predefined)
                    {
                        // NaN/Infinity didn't resolve to the global predefined values!
                        // see if Number does
                        reference = enclosingScope.GetIdentifierReference("Number", null);
                        if (reference.Category == BindingCategory.Predefined)
                        {
                            // use the properties off this object. Not very compact, but accurate.
                            // I don't think there will be any precedence problems with these constructs --
                            // the member-dot operator is pretty high on the precedence scale.
                            if (double.IsPositiveInfinity(doubleValue))
                            {
                                return "Number.POSITIVE_INFINITY";
                            }
                            if (double.IsNegativeInfinity(doubleValue))
                            {
                                return "Number.NEGATIVE_INFINITY";
                            }
                            return "Number.NaN";
                        }
                        else
                        {
                            // that doesn't resolve to the global Number object, either!
                            // well, extreme circumstances. Let's use literals to generate those values.
                            if (double.IsPositiveInfinity(doubleValue))
                            {
                                // 1 divided by zero is +Infinity
                                return "(1/0)";
                            }
                            if (double.IsNegativeInfinity(doubleValue))
                            {
                                // 1 divided by negative zero is -Infinity
                                return "(1/-0)";
                            }
                            // the unary plus converts to a number, and "x" will generate NaN
                            return "(+'x')";
                        }
                    }
                }*/

                // we're good to go -- just return the name because it will resolve to the
                // global properties (make a special case for negative infinity)
                return double.IsNegativeInfinity(numericValue) ? "-Infinity" : objectName;
            }
            else if (numericValue == 0)
            {
                // special case zero because we don't need to go through all those
                // gyrations to get a "0" -- and because negative zero is different
                // than a positive zero
                return 1 / numericValue < 0 ? "-0" : "0";
            }
            else
            {
                // normal string representations
                string normal = GetSmallestRep(numericValue.ToStringInvariant("R"));

                // if this is an integer (no decimal portion)....
                if (Math.Floor(numericValue) == numericValue)
                {
                    // then convert to hex and see if it's smaller.
                    // only really big numbers might be smaller in hex.
                    string hex = NormalOrHexIfSmaller(numericValue, normal);
                    if (hex.Length < normal.Length)
                    {
                        normal = hex;
                    }
                }
                return normal;
            }
        }

        private static string GetSmallestRep(string number)
        {
            var len = number.Length;

            // Quick check avoid using regular expression
            if (len <= 2)
            {
                return number;
            }

            if (number.IndexOfAny(DecimalOrExponentChars) < 0)
            {
                // integer
                var zeros = 0;
                while ((zeros < len) && (number[len - zeros - 1] == '0'))
                {
                    zeros++;
                }

                if (zeros >= 3)
                {
                    return number.Substring(0, len - zeros) + s_exponents[zeros];
                }
                else
                {
                    return number;
                }
            }

            return GetSmallestRepReg(number);
        }

        private static string GetSmallestRepReg(string number)
        {
            var match = CommonData.DecimalFormat.Match(number);
            if (match.Success)
            {
                string mantissa = match.Result("${man}");
                if (string.IsNullOrEmpty(match.Result("${exp}")))
                {
                    if (string.IsNullOrEmpty(mantissa))
                    {
                        // no decimal portion
                        if (string.IsNullOrEmpty(match.Result("${sig}")))
                        {
                            // no non-zero digits in the magnitude either -- must be a zero
                            number = match.Result("${neg}") + "0";
                        }
                        else
                        {
                            // see if there are trailing zeros
                            // that we can use e-notation to make smaller
                            int numZeros = match.Result("${zer}").Length;
                            if (numZeros > 2)
                            {
                                number = match.Result("${neg}") + match.Result("${sig}")
                                    + 'e' + numZeros.ToStringInvariant();
                            }
                        }
                    }
                    else
                    {
                        // there is a decimal portion. Put it back together
                        // with the bare-minimum stuff -- no plus-sign, no leading magnitude zeros,
                        // no trailing mantissa zeros. A zero magnitude won't show up, either.
                        number = match.Result("${neg}") + match.Result("${mag}") + '.' + mantissa;
                    }
                }
                else if (string.IsNullOrEmpty(mantissa))
                {
                    // there is an exponent, but no significant mantissa
                    number = match.Result("${neg}") + match.Result("${mag}")
                        + "e" + match.Result("${eng}") + match.Result("${pow}");
                }
                else
                {
                    // there is an exponent and a significant mantissa
                    // we want to see if we can eliminate it and save some bytes

                    // get the integer value of the exponent
                    int exponent;
                    if ((match.Result("${eng}") + match.Result("${pow}")).TryParseIntInvariant(NumberStyles.Integer, out exponent))
                    {
                        // slap the mantissa directly to the magnitude without a decimal point.
                        // we'll subtract the number of characters we just added to the magnitude from
                        // the exponent
                        number = match.Result("${neg}") + match.Result("${mag}") + mantissa
                            + 'e' + (exponent - mantissa.Length).ToStringInvariant();
                    }
                    else
                    {
                        // should n't get here, but it we do, go with what we have
                        number = match.Result("${neg}") + match.Result("${mag}") + '.' + mantissa
                            + 'e' + match.Result("${eng}") + match.Result("${pow}");
                    }
                }
            }
            return number;
        }

        private static string NormalOrHexIfSmaller(double doubleValue, string normal)
        {
            // keep track of the maximum number of characters we can have in our
            // hexadecimal number before it'd be longer than the normal version.
            // subtract two characters for the 0x
            int maxValue = normal.Length - 2;

            int sign = Math.Sign(doubleValue);
            if (sign < 0)
            {
                // negate the value so it's positive
                doubleValue = -doubleValue;
                // subtract another character for the minus sign
                --maxValue;
            }

            // we don't want to get larger -- or even the same size, so we know
            // the maximum length is the length of the normal string less one
            char[] charArray = new char[normal.Length - 1];
            // point PAST the last character in the array because we will decrement
            // the position before we add a character. that way position will always
            // point to the first valid character in the array.
            int position = charArray.Length;

            while (maxValue > 0 && doubleValue > 0)
            {
                // get the right-most hex character
                int digit = (int)(doubleValue % 16);

                // if the digit is less than ten, then we want to add it to '0' to get the decimal character.
                // otherwise we want to add (digit - 10) to 'a' to get the alphabetic hex digit
                charArray[--position] = (char)((digit < 10 ? '0' : 'a' - 10) + digit);

                // next character
                doubleValue = Math.Floor(doubleValue / 16);
                --maxValue;
            }

            // if the max value is still greater than zero, then the hex value
            // will be shorter than the normal value and we want to go with it
            if (maxValue > 0)
            {
                // add the 0x prefix
                charArray[--position] = 'x';
                charArray[--position] = '0';

                // add the sign if negative
                if (sign < 0)
                {
                    charArray[--position] = '-';
                }

                // create a new string starting at the current position
                normal = new string(charArray, position, charArray.Length - position);
            }
            return normal;
        }

        #endregion

        #region string formatting methods

        public static string EscapeString(string text)
        {
            // the quote factor is a calculation based on the relative number of
            // double-quotes in the string in relation to single-quotes. If the factor is
            // less than zero, then there are more double-quotes than single-quotes and
            // we can save bytes by using single-quotes as the delimiter. If it's greater
            // than zero, then there are more single quotes than double-quotes and we should
            // use double-quotes for the delimiter. If it's exactly zero, then 
            // there are exactly the same number, so it doesn't matter which delimiter
            // we use. In that case, use double-quotes because I think it's easier to read.
            // More like other languages (C/C++, C#, Java) that way.
            var delimiter = QuoteFactor(text) < 0 ? "\'" : "\"";

            // we also don't want to build a new string builder object if we don't have to.
            // and we only need to if we end up escaping characters. 
            var rawStart = 0;
            string escapedText = string.Empty;
            StringBuilder sb = null;
            try
            {
                if (!string.IsNullOrEmpty(text))
                {
                    // check each character of the string
                    for (var index = 0; index < text.Length; ++index)
                    {
                        var ch = text[index];
                        switch (ch)
                        {
                            case '\'':
                            case '"':
                                // we only need to escape whichever one we chose as our delimiter
                                if (ch == delimiter[0])
                                {
                                    // need to escape instances of the delimiter character
                                    goto case '\\';
                                }

                                break;

                            case '\b':
                                // output "\b"
                                ch = 'b';
                                goto case '\\';

                            case '\t':
                                // output "\t"
                                ch = 't';
                                goto case '\\';

                            case '\n':
                                // output "\n"
                                ch = 'n';
                                goto case '\\';

                            case '\v':
                                // w3c-strict can encode this character as a \v escape. 
                                // BUT... IE<9 doesn't recognize that escape sequence,
                                // so encode is as hex for maximum compatibility.
                                // if the source actually had "\v" in it, it wouldn't been
                                // marked as having issues and not get encoded anyway.
                                goto default;

                            case '\f':
                                // output "\f"
                                ch = 'f';
                                goto case '\\';

                            case '\r':
                                // output "\r"
                                ch = 'r';
                                goto case '\\';

                            case '\\':
                                // we need to output an escape, so create the string builder
                                // if we haven't already
                                if (sb == null)
                                {
                                    sb = StringBuilderPool.Acquire();
                                }

                                // output the block of raw characters we have since the last time
                                if (rawStart < index)
                                {
                                    sb.Append(text, rawStart, index - rawStart);
                                }

                                // set raw start to the next character
                                rawStart = index + 1;

                                // output the escape character, then the escaped character
                                sb.Append('\\');
                                sb.Append(ch);
                                break;

                            case '\x2028':
                            case '\x2029':
                                // issue #14398 - unescaped, these characters (Unicode LineSeparator and ParagraphSeparator)
                                // would introduce a line-break in the string.  they ALWAYS need to be escaped, 
                                // no matter what output encoding we may use.
                                if (sb == null)
                                {
                                    sb = StringBuilderPool.Acquire();
                                }

                                // output the block of raw characters we have since the last time
                                if (rawStart < index)
                                {
                                    sb.Append(text.Substring(rawStart, index - rawStart));
                                }

                                // set raw start to the next character
                                rawStart = index + 1;

                                // output the escape character, a "u", then the four-digit escaped character
                                sb.Append(@"\u");
                                sb.Append(((int)ch).ToStringInvariant("x4"));
                                break;

                            default:
                                if (ch < ' ')
                                {
                                    // need to escape control codes that aren't handled
                                    // by the single-letter escape codes
                                    // create the string builder if we haven't already
                                    if (sb == null)
                                    {
                                        sb = StringBuilderPool.Acquire();
                                    }

                                    // output the block of raw characters we have since the last time
                                    if (rawStart < index)
                                    {
                                        sb.Append(text, rawStart, index - rawStart);
                                    }

                                    // set raw start to the next character
                                    rawStart = index + 1;

                                    // strict ECMA-262 does not support octal escapes, but octal will
                                    // crunch down a full character more here than hexadecimal. Plus, if we do
                                    // octal, we'll still need to escape these characters to hex for RexExp
                                    // constructor strings so they don't get confused with back references.
                                    // minifies smaller, but octal is too much trouble.
                                    int intValue = ch;
                                    //if (noOctalEscapes)
                                    {
                                        // output the hex escape sequence
                                        sb.Append(@"\x");
                                        sb.Append(intValue.ToStringInvariant("x2"));
                                    }
                                    //else
                                    //{
                                    //    // octal representation of 0 through 31 are \0 through \37
                                    //    sb.Append('\\');
                                    //    if (intValue < 8)
                                    //    {
                                    //        // single octal digit
                                    //        sb.Append(intValue.ToStringInvariant());
                                    //    }
                                    //    else
                                    //    {
                                    //        // two octal digits
                                    //        sb.Append((intValue / 8).ToStringInvariant());
                                    //        sb.Append((intValue % 8).ToStringInvariant());
                                    //    }
                                    //}
                                }

                                break;
                        }
                    }

                    if (sb != null)
                    {
                        // we had escapes; use the string builder
                        // but first make sure the last batch of raw text is output
                        if (rawStart < text.Length)
                        {
                            sb.Append(text.Substring(rawStart));
                        }

                        escapedText = sb.ToString();
                    }
                    else
                    {
                        // no escaped needed; just use the text as-is
                        escapedText = text;
                    }
                }
            }
            finally
            {
                sb.Release();
            }

            return delimiter + escapedText + delimiter;
        }

        /// <summary>
        /// Counts the number of double-quotes and single-quotes in a string
        /// and returns a numeric indicator for which one should be used as
        /// the string delimiter.
        /// </summary>
        /// <param name="text">string to test</param>
        /// <returns>less than zero use single-quotes, zero or more, use double-quotes</returns>
        private static int QuoteFactor(string text)
        {
            // determine the delimiter to use based on the quote factor.
            // a value less than zero means there are more double-quotes than single-quotes,
            // therefore we should use single-quotes for the delimiter.
            // otherwise there are more single-quotes than double-quotes (or equal values)
            // and it's okay to use double-quotes
            int quoteFactor = 0;
            if (!text.IsNullOrWhiteSpace())
            {
                for (int index = 0; index < text.Length; ++index)
                {
                    if (text[index] == '\'')
                    {
                        ++quoteFactor;
                    }
                    else if (text[index] == '"')
                    {
                        --quoteFactor;
                    }
                }
            }

            return quoteFactor;
        }

        #endregion

        #region Map file methods

        private object StartSymbol(AstNode node)
        {
            if (m_settings.SymbolsMap != null)
            {
                return m_settings.SymbolsMap.StartSymbol(node, m_lineCount, m_lineLength);
            }

            return null;
        }

        private void MarkSegment(AstNode node, string name, SourceContext context)
        {
            if (m_settings.SymbolsMap != null && node != null)
            {
                m_settings.SymbolsMap.MarkSegment(node, m_segmentStartLine, m_segmentStartColumn, name, context);
            }
        }

        private void EndSymbol(object symbol)
        {
            if (m_settings.SymbolsMap != null && symbol != null)
            {
                string parentFunction = null;
                if (m_functionStack.Count > 0)
                {
                    parentFunction = m_functionStack.Peek();
                }

                m_settings.SymbolsMap.EndSymbol(symbol, m_lineCount, m_lineLength, parentFunction);
            }
        }

        #endregion Map file methods

        #region context output position methods

        private void SetContextOutputPosition(SourceContext context)
        {
            if (context != null)
            {
                // segment start line will be zero-based, but we want to have a 1-based line number
                context.OutputLine = m_segmentStartLine + 1;
                context.OutputColumn = m_segmentStartColumn;
            }
        }

        private static void SetContextOutputPosition(SourceContext context, SourceContext fromContext)
        {
            if (context != null && fromContext != null)
            {
                context.OutputLine = fromContext.OutputLine;
                context.OutputColumn = fromContext.OutputColumn;
            }
        }

        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;

namespace NUglify.JavaScript.Visitors
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
    public class OutputVisitor : IVisitor
    {
        private TextWriter m_outputStream;

        private char m_lastCharacter;
        private bool m_lastCountOdd;
        private bool m_onNewLine;
        private bool m_startOfStatement;
        private bool m_outputCCOn;
        private bool m_doneWithGlobalDirectives;
        private bool m_needsStrictDirective;
        private bool m_noLineBreaks;

        private int m_indentLevel;
        private int m_lineLength;
        private int m_lineCount;

        // needed when generating map files
        private Stack<string> m_functionStack = new Stack<string>();
        private int m_segmentStartLine;
        private int m_segmentStartColumn;

        // if this function is set, before outputting a character will pass it to this
        // function and insert a space if it returns true. Then we reset the function.
        private Func<char, bool> m_addSpaceIfTrue;

        // normally false; gets set to true if we are in a no-in scenario
        // (in-operator not directly allowed)
        private bool m_noIn;

        // shortcut so we don't have to keep checking the count
        private bool m_hasReplacementTokens;

        private CodeSettings m_settings;

        private RequiresSeparatorVisitor m_requiresSeparator;

        private static string[] s_exponents = { 
            null, 
            null, 
            null, 
            "e3", 
            "e4",
            "e5",
            "e6",
            "e7",
            "e8",
            "e9",

            "e10", 
            "e11", 
            "e12", 
            "e13", 
            "e14",
            "e15",
            "e16",
            "e17",
            "e18",
            "e19",

            "e20", 
            "e21", 
            "e22", 
            "e23", 
            "e24",
            "e25",
            "e26",
            "e27",
            "e28",
            "e29"
        };

        private static char[] DecimalOrExponentChars = { '.', 'e', 'E' };
        private static char[] LineFeedCharacters = { '\n', '\r', '\u2028', '\u2029' };

        private OutputVisitor(TextWriter writer, CodeSettings settings)
        {
            m_outputStream = writer;
            m_settings = settings ?? new CodeSettings();
            m_onNewLine = true;
            m_requiresSeparator = new RequiresSeparatorVisitor(m_settings);
            m_hasReplacementTokens = settings.ReplacementTokens.Count > 0;
            writer.NewLine = settings.LineTerminator;
        }

        /// <summary>
        /// Render a node tree to a text writer
        /// </summary>
        /// <param name="writer">writer to which to send output</param>
        /// <param name="node">node to render</param>
        /// <param name="settings">settings to use for output</param>
        public static void Apply(TextWriter writer, AstNode node, CodeSettings settings)
        {
            if (node != null)
            {
                var outputVisitor = new OutputVisitor(writer, settings);
                node.Accept(outputVisitor);

                // if there is a symbol map that we are tracking, tell it that we have ended an output run
                // and pass it offsets to the last line and column positions.
                settings.IfNotNull(s => s.SymbolsMap.IfNotNull(m => m.EndOutputRun(outputVisitor.m_lineCount, outputVisitor.m_lineLength)));
            }
        }

        /// <summary>
        /// Render a node tree as a string
        /// </summary>
        /// <param name="node">node to render</param>
        /// <param name="settings">settings to use for output</param>
        /// <returns>string representation of the node</returns>
        public static string Apply(AstNode node, CodeSettings settings)
        {
            if (node != null)
            {
                using (var writer = new StringWriter(CultureInfo.InvariantCulture))
                {
                    OutputVisitor.Apply(writer, node, settings);
                    return writer.ToString();
                }
            }

            return string.Empty;
        }

        #region IVisitor Members

        public void Visit(ArrayLiteral node)
        {
            var isNoIn = m_noIn;
            m_noIn = false;

            if (node != null)
            {
                var symbol = StartSymbol(node);

                OutputPossibleLineBreak('[');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;

                if (node.Elements.Count > 0)
                {
                    Indent();

                    AstNode element = null;
                    for (var ndx = 0; ndx < node.Elements.Count; ++ndx)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            MarkSegment(node, null, element.IfNotNull(e => e.TerminatingContext));

                            if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        element = node.Elements[ndx];
                        if (element != null)
                        {
                            AcceptNodeWithParens(element, element.Precedence == OperatorPrecedence.Comma);
                        }
                    }

                    Unindent();
                }

                Output(']');
                MarkSegment(node, null, node.Context);

                EndSymbol(symbol);
            }

            m_noIn = isNoIn;
        }

        public void Visit(ComputedPropertyField node)
        {
            var isNoIn = m_noIn;
            m_noIn = false;

            var arrayNode = node.ArrayNode;

            if (node != null)
            {
                var symbol = StartSymbol(node);

                OutputPossibleLineBreak('[');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;

                if (arrayNode.Elements.Count > 0)
                {
                    Indent();

                    AstNode element = null;
                    for (var ndx = 0; ndx < arrayNode.Elements.Count; ++ndx)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            MarkSegment(node, null, element.IfNotNull(e => e.TerminatingContext));

                            if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        element = arrayNode.Elements[ndx];
                        if (element != null)
                        {
                            AcceptNodeWithParens(element, element.Precedence == OperatorPrecedence.Comma);
                        }
                    }

                    Unindent();
                }

                Output(']');
                OutputPossibleLineBreak(':');

                MarkSegment(node, null, node.Context);

                EndSymbol(symbol);
            }

            m_noIn = isNoIn;
        }

        public void Visit(AspNetBlockNode node)
        {
            if (node != null)
            {
                Output(node.AspNetBlockText);
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
            }
        }

        public void Visit(AstNodeList node)
        {
            if (node != null && node.Count > 0)
            {
                var symbol = StartSymbol(node);

                // see if this parent is a comma operator whose parent in turn is a block.
                // if so, then these expressions were expression statements that we've combined.
                // if that's the case, we're going to put newlines in so it's a little easier
                // to read in multi-line mode
                var addNewLines = node.Parent is CommaExpression
                    && node.Parent.Parent is BlockStatement
                    && m_settings.OutputMode == OutputMode.MultipleLines;

                // output as comma-separated expressions starting with the first one
                node[0].Accept(this);
                SetContextOutputPosition(node.Context, node[0].Context);

                // this should never be the first element of the line, but
                // just in case, reset the flag after the first expression.
                m_startOfStatement = false;

                // if we aren't breaking them up by newlines, indent now in case
                // one of the items causes a newline to be inserted.
                if (!addNewLines)
                {
                    Indent();
                }

                for (var ndx = 1; ndx < node.Count; ++ndx)
                {
                    // output a comma
                    OutputPossibleLineBreak(',');
                    MarkSegment(node, null, node[ndx-1].IfNotNull(n => n.TerminatingContext));

                    if (addNewLines)
                    {
                        NewLine();
                    }
                    else if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }

                    // output the next node
                    node[ndx].Accept(this);
                }

                // if we aren't breaking by newlines, unindent our previous indent
                if (!addNewLines)
                {
                    Unindent();
                }

                EndSymbol(symbol);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public void Visit(BinaryExpression node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                if (node.OperatorToken == JSToken.Comma)
                {
                    // output the left-hand operand, if we have one
                    if (node.Operand1 != null)
                    {
                        node.Operand1.Accept(this);
                        SetContextOutputPosition(node.Context, node.Operand1.Context);

                        // if we don't have a right-hand operator, don't bother with the comma
                        if (node.Operand2 != null)
                        {
                            OutputPossibleLineBreak(',');
                            MarkSegment(node, null, node.Operand1.TerminatingContext);
                            m_startOfStatement = false;

                            // if the parent is a block, then the comma operator is separating
                            // expression statements -- so break it on the line
                            if (node.Parent is BlockStatement)
                            {
                                NewLine();
                            }
                            else if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }
                    }

                    // output the right-hand operator, if we have one
                    if (node.Operand2 != null)
                    {
                        node.Operand2.Accept(this);
                        m_startOfStatement = false;
                    }
                }
                else
                {
                    var ourPrecedence = node.Precedence;
                    var isNoIn = m_noIn;
                    if (isNoIn)
                    {
                        if (node.OperatorToken == JSToken.In)
                        {
                            // we're in a no-in situation, but our operator is an in-operator.
                            // so we need to wrap this operator in parens
                            OutputPossibleLineBreak('(');
                            m_noIn = false;
                        }
                        else
                        {
                            m_noIn = ourPrecedence <= OperatorPrecedence.Relational;
                        }
                    }

                    if (node.Operand1 != null)
                    {
                        AcceptNodeWithParens(node.Operand1, node.Operand1.Precedence < ourPrecedence);
                        SetContextOutputPosition(node.Context, node.Operand1.Context);
                    }

                    m_startOfStatement = false;

                    if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        // treat the comma-operator special, since we combine expression statements
                        // with it very often
                        if (node.OperatorToken != JSToken.Comma)
                        {
                            // anything other than a comma operator has a space before it, too
                            OutputPossibleLineBreak(' ');
                        }

                        Output(OperatorString(node.OperatorToken));
                        MarkSegment(node, null, node.OperatorContext);

                        BreakLine(false);
                        if (!m_onNewLine)
                        {
                            OutputPossibleLineBreak(' ');
                        }
                    }
                    else
                    {
                        Output(OperatorString(node.OperatorToken));
                        MarkSegment(node, null, node.OperatorContext);
                        BreakLine(false);
                    }

                    if (node.OperatorToken == JSToken.Divide)
                    {
                        // add a function that will check if the next character is also
                        // a forward slash. If it is, the output methods will separate them
                        // with a space so they don't get interpreted as the start of a
                        // single-line comment.
                        m_addSpaceIfTrue = c => c == '/';
                    }

                    if (node.Operand2 != null)
                    {
                        var rightPrecedence = node.Operand2.Precedence;
                        var rightNeedsParens = rightPrecedence < ourPrecedence;

                        var rightHandBinary = node.Operand2 as BinaryExpression;
                        if (rightHandBinary != null)
                        {
                            // they are BOTH binary expressions. This is where it gets complicated.
                            // because most binary tokens (except assignment) are evaluated from left to right,
                            // if we have a binary expression with the same precedence on the RIGHT, then that means the
                            // developer must've put parentheses around it. For some operators, those parentheses 
                            // may not be needed (associative operators like multiply and logical AND or logical OR).
                            // Non-associative operators (divide) will need those parens, so we will want to say they
                            // are a higher relative precedence because of those parentheses.
                            // The plus operator is a special case. It is the same physical token, but it can be two
                            // operations depending on the runtime data: numeric addition or string concatenation.
                            // Because of that ambiguity, let's also calculate the precedence for it as if it were
                            // non-associate as well.
                            // commas never need the parens -- they always evaluate left to right and always return the
                            // right value, so any parens will always be unneccessary.
                            if (ourPrecedence == rightPrecedence
                                && ourPrecedence != OperatorPrecedence.Assignment
                                && ourPrecedence != OperatorPrecedence.Comma)
                            {
                                if (node.OperatorToken == rightHandBinary.OperatorToken)
                                {
                                    // the tokens are the same and we're not assignment or comma operators.
                                    // so for a few associative operators, we're going to say the relative precedence
                                    // is the same so unneeded parens are removed. But for all others, we'll say the
                                    // right-hand side is a higher precedence so we maintain the sematic structure
                                    // of the expression
                                    switch (node.OperatorToken)
                                    {
                                        case JSToken.Multiply:
                                        case JSToken.BitwiseAnd:
                                        case JSToken.BitwiseXor:
                                        case JSToken.BitwiseOr:
                                        case JSToken.LogicalAnd:
                                        case JSToken.LogicalOr:
                                            // these are the same regardless
                                            rightNeedsParens = false;
                                            break;

                                        // TODO: the plus operator: if we can prove that it is a numeric operator
                                        // or a string operator on BOTH sides, then it can be associative, too. But
                                        // if one side is a string and the other numeric, or if we can't tell at 
                                        // compile-time, then we need to preserve the structural precedence.
                                        default:
                                            // all other operators are structurally a lower precedence when they
                                            // are on the right, so they need to be evaluated first
                                            rightNeedsParens = true;
                                            break;
                                    }
                                }
                                else
                                {
                                    // they have the same precedence, but the tokens are different.
                                    // and the developer had purposely put parens around the right-hand side
                                    // to get them on the right (otherwise with the same precedence they
                                    // would've ended up on the left. Keep the parens; must've been done for
                                    // a purpose.
                                    rightNeedsParens = true;
                                }
                            }
                            else
                            {
                                // different precedence -- just base the decision on the relative precedence values
                                rightNeedsParens = rightPrecedence < ourPrecedence;
                            }
                        }

                        m_noIn = isNoIn && ourPrecedence <= OperatorPrecedence.Relational;
                        AcceptNodeWithParens(node.Operand2, rightNeedsParens);
                    }

                    if (isNoIn && node.OperatorToken == JSToken.In)
                    {
                        // we're in a no-in situation, but our operator is an in-operator.
                        // so we need to wrap this entire operator in parens
                        OutputPossibleLineBreak(')');
                    }
                    m_noIn = isNoIn;

                    EndSymbol(symbol);
                }
            }
        }

        public void Visit(BindingIdentifier node)
        {
            if (node != null)
            {
                // output the name (use the field is possible)
                Output(node.VariableField != null ? node.VariableField.ToString() : node.Name);
                MarkSegment(node, node.Name, node.Context);
                SetContextOutputPosition(node.Context);
                node.VariableField.IfNotNull(f => SetContextOutputPosition(f.OriginalContext));
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public void Visit(BlockStatement node)
        {
            if (node != null)
            {
                // don't create a symbol for the root node -- it can encompass any of the input files
                var symbol = node.Parent != null ? StartSymbol(node) : null;

                var outputBraces = true;
                if (node.Parent != null)
                {
                    // not the root block.
                    // if the parent is a function node, we will need a "use strict" directive
                    // if the function's scope is strict but the parent scope is not
                    ModuleDeclaration moduleDecl;
                    var parentNode = node.Parent;
                    if (parentNode is FunctionObject
                        && parentNode.EnclosingScope.UseStrict
                        && !parentNode.EnclosingScope.Parent.UseStrict)
                    {
                        m_needsStrictDirective = true;
                    }
                    else if ((moduleDecl = node.Parent as ModuleDeclaration) != null && moduleDecl.IsImplicit)
                    {
                        // this is an implicit module block. Don't output the strict directive
                        // because all modules are implicitly strict anyway.
                        m_needsStrictDirective = false;
                        outputBraces = false;
                    }

                    if (outputBraces)
                    {
                        // always enclose in curly-braces
                        OutputPossibleLineBreak('{');
                        SetContextOutputPosition(node.Context);
                        MarkSegment(node, null, node.Context);
                        Indent();
                    }
                }
                else
                {
                    // root block.
                    // we will need a "use strict" directive IF this scope is strict and we
                    // haven't already gone past where we can insert global directive prologues
                    m_needsStrictDirective = node.EnclosingScope.IfNotNull(s => s.UseStrict) && !m_doneWithGlobalDirectives;
                    outputBraces = false;
                }

                AstNode prevStatement = null;
                for (var ndx = 0; ndx < node.Count; ++ndx)
                {
                    var statement = node[ndx];
                    if (statement != null)
                    {
                        if (prevStatement != null && m_requiresSeparator.Query(prevStatement))
                        {
                            OutputPossibleLineBreak(';');
                            MarkSegment(prevStatement, null, prevStatement.TerminatingContext);
                        }

                        if (!(statement is DirectivePrologue))
                        {
                            if (m_needsStrictDirective)
                            {
                                // we need a strict directive, but we didn't have one.
                                // add it now
                                Output("\"use strict\";");
                                m_needsStrictDirective = false;
                            }

                            m_doneWithGlobalDirectives = true;
                        }

                        NewLine();
                        m_startOfStatement = true;
                        statement.Accept(this);
                        prevStatement = statement;
                    }
                }

                if (outputBraces)
                {
                    Unindent();

                    // if there weren't any statements, the curly-braces will be on the same line.
                    // otherwise we want them on a new line
                    if (node.Count > 0)
                    {
                        NewLine();
                    }

                    OutputPossibleLineBreak('}');
                    MarkSegment(node, null, node.Context);
                }
                else if (prevStatement != null && m_requiresSeparator.Query(prevStatement) && m_settings.TermSemicolons)
                {
                    // this is the root block (parent is null) and we want to make sure we end
                    // with a terminating semicolon, so don't replace it
                    OutputPossibleLineBreak(';');
                    MarkSegment(prevStatement, null, prevStatement.TerminatingContext);
                }

                if (symbol != null)
                {
                    EndSymbol(symbol);
                }
            }
        }

        public void Visit(BreakStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("break");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                if (!node.Label.IsNullOrWhiteSpace())
                {
                    // NO PAGE BREAKS ALLOWED HERE
                    m_noLineBreaks = true;
                    if (node.LabelInfo.IfNotNull(li => !li.MinLabel.IsNullOrWhiteSpace()))
                    {
                        // output minified label
                        Output(node.LabelInfo.MinLabel);
                    }
                    else
                    {
                        // not minified -- just output original label
                        Output(node.Label);
                    }

                    MarkSegment(node, null, node.LabelContext);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(CallExpression node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;
                m_noIn = false;

                if (node.IsConstructor)
                {
                    Output("new");
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);

                    m_startOfStatement = false;
                }

                if (node.Function != null)
                {
                    var needsParens = node.Function.Precedence < node.Precedence;

                    // if we think we don't need parens, we need to make one more check:
                    // if the function is a new operator with no argument list, then we 
                    // need to wrap it so our argument list doesn't get mistaken for the new-operator's
                    // argument list
                    if (!needsParens)
                    {
                        // because if the new-operator associates to the right and the ()-operator associates
                        // to the left, we need to be careful that we don't change the precedence order when the 
                        // function of a new operator is itself a call or contains a call. In that case, the call will have it's own
                        // parameters (and therefore parentheses) that will need to be associated with the call
                        // and NOT the new -- the call will need to be surrounded with parens to keep that association.
                        // (if we are already going to wrap it in parens, no need to check further)
                        if (node.IsConstructor)
                        {
                            // check the constructor function of our new operator to see if 
                            // it requires parens so we don't get the precedence all screwed up.
                            // pass in whether or not WE have any arguments -- will make a difference when we have embedded
                            // constructors that don't have arguments
                            needsParens = NewParensVisitor.NeedsParens(node.Function, node.Arguments == null || node.Arguments.Count == 0);
                        }
                        else
                        {
                            var newExpression = node.Function as CallExpression;
                            if (newExpression != null && newExpression.IsConstructor
                                && (newExpression.Arguments == null || newExpression.Arguments.Count == 0))
                            {
                                needsParens = true;
                            }
                        }
                    }

                    AcceptNodeWithParens(node.Function, needsParens);
                    if (!node.IsConstructor)
                    {
                        SetContextOutputPosition(node.Context);
                    }
                }

                if (!node.IsConstructor || node.Arguments.Count > 0)
                {
                    OutputPossibleLineBreak(node.InBrackets ? '[' : '(');
                    MarkSegment(node, null, node.Arguments.Context);

                    AstNode argument = null;
                    for (var ndx = 0; ndx < node.Arguments.Count; ++ndx)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            MarkSegment(node.Arguments, null, argument.IfNotNull(a => a.TerminatingContext) ?? node.Arguments.Context);

                            if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        argument = node.Arguments[ndx];
                        if (argument != null)
                        {
                            AcceptNodeWithParens(argument, argument.Precedence <= OperatorPrecedence.Comma);
                        }
                    }

                    Output(node.InBrackets ? ']' : ')');
                    MarkSegment(node, null, node.Arguments.Context);
                }

                m_noIn = isNoIn;

                EndSymbol(symbol);
            }
        }

        public void Visit(ClassNode node)
        {
            if (node != null)
            {
                var wrapInParens = m_startOfStatement && node.ClassType != ClassType.Declaration;
                if (wrapInParens)
                {
                    OutputPossibleLineBreak('(');
                    m_startOfStatement = false;
                }

                Output("class");
                MarkSegment(node, null, node.ClassContext);
                SetContextOutputPosition(node.ClassContext);
                m_startOfStatement = false;

                // name if optional if this is an expression, and it should
                // be a simple binding identifier if it's present
                if (node.Binding != null)
                {
                    var bindingIdentifier = node.Binding as BindingIdentifier;
                    if (bindingIdentifier != null)
                    {
                        // if this isn't an expression, or if the class name is actually referenced,
                        // or if we don't want to remove expression names, output the name. Otherwise
                        // hide it.
                        if (node.ClassType != ClassType.Expression
                            || bindingIdentifier.VariableField.IsReferenced
                            || !m_settings.RemoveFunctionExpressionNames)
                        {
                            node.Binding.Accept(this);
                        }
                    }
                    else
                    {
                        // not a simple identifier -- output anyway to maintain the code as-is
                        node.Binding.Accept(this);
                    }
                }

                // heritage is optional
                if (node.Heritage != null)
                {
                    Output("extends");
                    MarkSegment(node, null, node.ExtendsContext);
                    SetContextOutputPosition(node.ExtendsContext);

                    node.Heritage.Accept(this);
                }

                // if there are any elements, put the braces on new lines and indent
                node.Elements.IfNotNull(e => { if (e.Count > 0) { NewLine(); Indent();  } });
                OutputPossibleLineBreak('{');
                MarkSegment(node, null, node.OpenBrace);
                SetContextOutputPosition(node.OpenBrace);

                // output each element in turn
                if (node.Elements != null && node.Elements.Count > 0)
                {
                    foreach (var element in node.Elements)
                    {
                        NewLine();
                        element.Accept(this);
                    }
                }

                // if there are any elements, unindent and put the closing braces on a new line
                node.Elements.IfNotNull(e => { if (e.Count > 0) { Unindent();  NewLine(); } });
                OutputPossibleLineBreak('}');
                MarkSegment(node, null, node.CloseBrace);
                SetContextOutputPosition(node.CloseBrace);

                if (wrapInParens)
                {
                    OutputPossibleLineBreak(')');
                }
            }
        }

        public void Visit(ComprehensionNode node)
        {
            if (node != null)
            {
                // array is the default (0) so check for generator
                OutputPossibleLineBreak(node.ComprehensionType == ComprehensionType.Generator ? '(' : '[');
                MarkSegment(node, null, node.OpenDelimiter);

                if (node.MozillaOrdering)
                {
                    // Mozilla order implemented by Firefox - they want the expression first,
                    // then the for-clause(s) followed by an optional single if-clause
                    if (node.Expression != null)
                    {
                        node.Expression.Accept(this);
                    }

                    // skip the AstNodeList part and just output the clauses
                    // because the list will add commas
                    foreach (var clause in node.Clauses)
                    {
                        clause.Accept(this);
                    }
                }
                else
                {
                    // spec'd ES6 format
                    // a for-clause followed by any number of for- or if-clauses, followed by the expression
                    // skip the AstNodeList part and just output the clauses
                    // because the list will add commas
                    foreach (var clause in node.Clauses)
                    {
                        clause.Accept(this);
                    }

                    if (node.Expression != null)
                    {
                        node.Expression.Accept(this);
                    }
                }

                OutputPossibleLineBreak(node.ComprehensionType == ComprehensionType.Generator ? ')' : ']');
                MarkSegment(node, null, node.CloseDelimiter);
            }
        }

        public void Visit(ComprehensionForClause node)
        {
            if (node != null)
            {
                Output("for");
                MarkSegment(node, null, node.OperatorContext);
                OutputPossibleLineBreak('(');
                MarkSegment(node, null, node.OpenContext);

                if (node.Binding != null)
                {
                    node.Binding.Accept(this);
                }

                Output(node.IsInOperation ? "in" : "of");
                MarkSegment(node, null, node.OfContext);

                if (node.Expression != null)
                {
                    node.Expression.Accept(this);
                }

                OutputPossibleLineBreak(')');
                MarkSegment(node, null, node.CloseContext);
            }
        }

        public void Visit(ComprehensionIfClause node)
        {
            if (node != null)
            {
                Output("if");
                MarkSegment(node, null, node.OperatorContext);
                OutputPossibleLineBreak('(');
                MarkSegment(node, null, node.OpenContext);

                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                OutputPossibleLineBreak(')');
                MarkSegment(node, null, node.CloseContext);
            }
        }

        public void Visit(ConditionalCompilationComment node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                // if we have already output a cc_on and we don't want to keep any dupes, let's
                // skip over any @cc_on statements at the beginning now
                var ndx = 0;
                if (m_outputCCOn && m_settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryCCOnStatements))
                {
                    while (ndx < node.Statements.Count
                        && node.Statements[ndx] is ConditionalCompilationOn)
                    {
                        ++ndx;
                    }
                }

                // if there's anything left....
                if (ndx < node.Statements.Count)
                {
                    // start of comment
                    Output("/*");
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);

                    // get the next statement, which will be the first one we output
                    var statement = node.Statements[ndx];
                    if (statement is ConditionalCompilationStatement
                        || statement is ConstantWrapperPP)
                    {
                        // the next statement STARTS with an @-sign, so just output it. It will add the @ sign to begin
                        // the conditional-compilation comment
                        statement.Accept(this);
                    }
                    else
                    {
                        // next statement does NOT start with an @-sign, so add one now.
                        // outputting an @-sign as the last character will ensure that a
                        // space is inserted before any identifier character coming after.
                        OutputPossibleLineBreak('@');

                        // and then output the first statement
                        statement.Accept(this);
                    }

                    // go through the rest of the statements (if any)
                    AstNode prevStatement = statement;
                    while (++ndx < node.Statements.Count)
                    {
                        statement = node.Statements[ndx];
                        if (statement != null)
                        {
                            if (prevStatement != null && m_requiresSeparator.Query(prevStatement))
                            {
                                OutputPossibleLineBreak(';');
                                MarkSegment(prevStatement, null, prevStatement.TerminatingContext);
                            }

                            NewLine();
                            m_startOfStatement = true;
                            statement.Accept(this);
                            prevStatement = statement;
                        }
                    }

                    // output the closing comment
                    Output("@*/");
                    MarkSegment(node, null, node.Context);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationElse node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                
                Output("@else");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationElseIf node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("@elif(");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                OutputPossibleLineBreak(')');
                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationEnd node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("@end");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationIf node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("@if(");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                OutputPossibleLineBreak(')');
                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationOn node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                if (!m_outputCCOn
                    || !m_settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryCCOnStatements))
                {
                    m_outputCCOn = true;
                    Output("@cc_on");
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ConditionalCompilationSet node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("@set");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                Output(node.VariableName);
                Output('=');

                // if the value is an operator of any kind, we need to wrap it in parentheses
                // so it gets properly parsed
                if (node.Value is BinaryExpression || node.Value is UnaryExpression)
                {
                    Output('(');
                    node.Value.Accept(this);
                    OutputPossibleLineBreak(')');
                }
                else if (node.Value != null)
                {
                    node.Value.Accept(this);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(Conditional node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;

                if (node.Condition != null)
                {
                    AcceptNodeWithParens(node.Condition, node.Condition.Precedence < OperatorPrecedence.LogicalOr);
                    SetContextOutputPosition(node.Context);
                }

                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                    OutputPossibleLineBreak('?');
                    MarkSegment(node, null, node.QuestionContext ?? node.Context);
                    BreakLine(false);
                    if (!m_onNewLine)
                    {
                        OutputPossibleLineBreak(' ');
                    }
                }
                else
                {
                    OutputPossibleLineBreak('?');
                    MarkSegment(node, null, node.QuestionContext ?? node.Context);
                }

                m_startOfStatement = false;
                if (node.TrueExpression != null)
                {
                    m_noIn = isNoIn;
                    AcceptNodeWithParens(node.TrueExpression, node.TrueExpression.Precedence < OperatorPrecedence.Assignment);
                }

                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                    OutputPossibleLineBreak(':');
                    MarkSegment(node, null, node.ColonContext ?? node.Context);
                    BreakLine(false);
                    if (!m_onNewLine)
                    {
                        OutputPossibleLineBreak(' ');
                    }
                }
                else
                {
                    OutputPossibleLineBreak(':');
                    MarkSegment(node, null, node.ColonContext ?? node.Context);
                }

                if (node.FalseExpression != null)
                {
                    m_noIn = isNoIn;
                    AcceptNodeWithParens(node.FalseExpression, node.FalseExpression.Precedence < OperatorPrecedence.Assignment);
                }

                m_noIn = isNoIn;

                EndSymbol(symbol);
            }
        }

        public void Visit(ConstantWrapper node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;
                m_noIn = false;

                switch (node.PrimitiveType)
                {
                    case PrimitiveType.Boolean:
                        Output(node.ToBoolean() ? "true" : "false");
                        break;

                    case PrimitiveType.Null:
                        Output("null");
                        break;

                    case PrimitiveType.Number:
                        if (node.Context == null || !node.Context.HasCode
                            || (!node.MayHaveIssues && m_settings.IsModificationAllowed(TreeModifications.MinifyNumericLiterals)))
                        {
                            // apply minification to the literal to get it as small as possible
                            Output(NormalizeNumber(node.ToNumber(), node.Context));
                        }
                        else
                        {
                            // context is not null but we don't want to minify numeric literals.
                            // just use the original literal from the context.
                            Output(node.Context.Code);
                        }
                        break;

                    case PrimitiveType.Other:
                        // see if the value of this other "constant" is actually a replacement token.
                        // the regex doesn't have ^ or $ so that it can be used to match tokens within a
                        // string, so if there's a match, make sure the match is the whole string.
                        Match match;
                        if (m_hasReplacementTokens
                            && (match = CommonData.ReplacementToken.Match(node.Value.ToString())).Success
                            && match.Value.Equals(node.Value))
                        {
                            // this is a token value, and we are replacing tokens.
                            Output(GetSyntacticReplacementToken(match));
                        }
                        else
                        {
                            // not replacing tokens; just output the value as-is
                            Output(node.Value.ToString());
                        }
                        break;

                    case PrimitiveType.String:
                        if (node.Context == null || !node.Context.HasCode)
                        {
                            // escape the string value because we don't have a raw context value
                            // to show anyways
                            Output(InlineSafeString(EscapeString(ReplaceTokens(node.Value.ToString()))));
                        }
                        else if (!m_settings.IsModificationAllowed(TreeModifications.MinifyStringLiterals))
                        {
                            // we don't want to modify the strings at all!
                            Output(ReplaceTokens(node.Context.Code));
                        }
                        else if (node.MayHaveIssues
                            || (m_settings.AllowEmbeddedAspNetBlocks && node.StringContainsAspNetReplacement))
                        {
                            // we'd rather show the raw string, but make sure it's safe for inlining
                            Output(InlineSafeString(ReplaceTokens(node.Context.Code)));
                        }
                        else
                        {
                            // under normal circumstances we would show a properly escaped and delimited
                            // string that is safe for inlining.
                            Output(InlineSafeString(EscapeString(ReplaceTokens(node.Value.ToString()))));
                        }

                        break;
                }

                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                m_noIn = isNoIn;

                EndSymbol(symbol);
            }
        }

        private string ReplaceTokens(string text)
        {
            // if we have any replacement tokens that we are looking for,
            // then do the replace operation on the string with the function that
            // will look up the token and replace it with the appropriate string.
            if (m_hasReplacementTokens)
            {
                text = CommonData.ReplacementToken.Replace(text, GetReplacementToken);
            }

            // no replacement; output as-is
            return text;
        }

        private string GetReplacementToken(Match match)
        {
            // see if there's a match for the token
            string replacement;
            if (!m_settings.ReplacementTokens.TryGetValue(match.Result("${token}"), out replacement))
            {
                // no match. Check the fallback, if any.
                var fallbackClass = match.Result("${fallback}");
                if (!fallbackClass.IsNullOrWhiteSpace())
                {
                    m_settings.ReplacementFallbacks.TryGetValue(fallbackClass, out replacement);
                }
            }

            return replacement ?? string.Empty;
        }

        private string GetSyntacticReplacementToken(Match match)
        {
            // see if there's a match for the token
            string replacement;
            if (m_settings.ReplacementTokens.TryGetValue(match.Result("${token}"), out replacement))
            {
                // we have a match.
                // if the string is valid JSON, the just output it as-is (well, with a little minification)
                var json = JsonParser.Validate(replacement);
                if (!json.IsNullOrWhiteSpace())
                {
                    // use the minified JSON object
                    replacement = json;
                }
                else
                {
                    // not JSON, so we need to treat the value as a string: wrap in quotes.
                    replacement = InlineSafeString(EscapeString(replacement));
                }
            }
            else
            {
                // no match. Check the fallback, if any. We're not going to do ANY processing
                // on a fallback value, so it BETTER generate proper JS syntax!
                var fallbackClass = match.Result("${fallback}");
                if (!fallbackClass.IsNullOrWhiteSpace())
                {
                    m_settings.ReplacementFallbacks.TryGetValue(fallbackClass, out replacement);
                }
            }

            return replacement ?? string.Empty;
        }

        public void Visit(ConstantWrapperPP node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                if (node.ForceComments)
                {
                    Output("/*");
                }

                // varname must include the @ sign
                Output(node.VarName);
                m_startOfStatement = false;
                SetContextOutputPosition(node.Context);

                if (node.ForceComments)
                {
                    Output("@*/");
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ConstStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("const");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                Indent();

                for (var ndx = 0; ndx < node.Count; ++ndx)
                {
                    var decl = node[ndx];
                    if (decl != null)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            NewLine();
                        }

                        decl.Accept(this);
                    }
                }
                Unindent();
                EndSymbol(symbol);
            }
        }

        public void Visit(ContinueStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("continue");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                if (!node.Label.IsNullOrWhiteSpace())
                {
                    // NO PAGE BREAKS ALLOWED HERE
                    m_noLineBreaks = true;
                    if (node.LabelInfo.IfNotNull(li => !li.MinLabel.IsNullOrWhiteSpace()))
                    {
                        // output minified label
                        Output(node.LabelInfo.MinLabel);
                    }
                    else
                    {
                        // not minified -- just output original label
                        Output(node.Label);
                    }

                    MarkSegment(node, null, node.LabelContext);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(CustomNode node)
        {
            if (node != null)
            {
                // custom nodes override the ToCode method to return a blank string.
                // nodes DERIVED from CustomNode should override ToCode is they want
                // to introduce anything into the output stream.
                var code = node.ToCode();
                if (!code.IsNullOrWhiteSpace())
                {
                    var symbol = StartSymbol(node);
                    Output(code);
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);
                    EndSymbol(symbol);
                }
            }
        }

        public void Visit(DebuggerNode node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("debugger");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                EndSymbol(symbol);
            }
        }

        public void Visit(DirectivePrologue node)
        {
            if (node != null)
            {
                // always output directive prologues that aren't strict; only output
                // the use-strict directive if we need one
                node.IsRedundant = node.UseStrict && !m_needsStrictDirective;
                if (!node.IsRedundant)
                {
                    Visit((ConstantWrapper)node);
                    if (node.UseStrict)
                    {
                        // just output a strict directive -- don't need one anymore
                        m_needsStrictDirective = false;
                    }
                }
            }
        }

        public void Visit(DoWhileStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("do");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                if (node.Body == null || node.Body.Count == 0)
                {
                    // semicolon-replacement cannot create an empty statement
                    OutputPossibleLineBreak(';');
                }
                else if (node.Body.Count == 1 && !node.Body.EncloseBlock(EncloseBlockType.SingleDoWhile))
                {
                    // there's only one statement, which means we don't need curley braces.
                    // HOWEVER, if the one statement ends in a do-while statement, then we DO need curley-braces
                    // because of an IE bug. IE parses the semi-colon that terminates the do-while as an empty
                    // statement FOLLOWING the do-while, which means the while-clause of the do-while is in the 
                    // wrong spot. We *could* leave the semi-colon out and all browsers will parse it properly, but
                    // that isn't strictly correct JS. So just wrap it in curly-braces to remain proper AND work in 
                    // all browsers.
                    Indent();
                    NewLine();
                    m_startOfStatement = true;
                    node.Body[0].Accept(this);

                    if (m_requiresSeparator.Query(node.Body[0]))
                    {
                        // because the next thing we are going to output is a while keyword, if the
                        // semicolon would be at the end of a line, we can skip it and just let the
                        // end of line trigger the semicolon-insertion rules.
                        if (ReplaceableSemicolon())
                        {
                            MarkSegment(node.Body[0], null, node.Body[0].TerminatingContext);
                        }
                    }

                    Unindent();
                    NewLine();
                }
                else
                {
                    if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                        || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.Body.BraceOnNewLine))
                    {
                        NewLine();
                    }
                    else if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }
                    
                    node.Body.Accept(this);

                    if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }
                }

                Output("while");
                MarkSegment(node, null, node.WhileContext);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                Output(')');

                EndSymbol(symbol);
            }
        }

        public void Visit(EmptyStatement node)
        {
            if (node != null)
            {
                // empty statement is just a semicolon
                OutputPossibleLineBreak(';');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
            }
        }

        public void Visit(ExportStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("export");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                SetContextOutputPosition(node.KeywordContext);
                m_startOfStatement = false;

                if (node.IsDefault)
                {
                    Output("default");

                    // there should only be a single element in the list, and it should be
                    // and assignment expression.
                    if (node.Count > 0)
                    {
                        node[0].Accept(this);
                    }
                }
                else
                {
                    if (node.Count == 1
                        && (node[0] is Declaration || node[0] is FunctionObject || node[0] is ClassNode))
                    {
                        // exporting a declaration (var/const/let), a function declaration, or a class node
                        node[0].Accept(this);
                    }
                    else
                    {
                        // the array should be an export specifier set. If there's nothing there, it's a star
                        if (node.Count == 0)
                        {
                            OutputPossibleLineBreak('*');
                            SetContextOutputPosition(node.OpenContext);
                        }
                        else
                        {
                            OutputPossibleLineBreak('{');
                            SetContextOutputPosition(node.OpenContext);

                            var first = true;
                            foreach (var specifier in node.Children)
                            {
                                if (first)
                                {
                                    first = false;
                                }
                                else
                                {
                                    OutputPossibleLineBreak(',');
                                }

                                specifier.Accept(this);
                            }

                            OutputPossibleLineBreak('}');
                            SetContextOutputPosition(node.CloseContext);
                        }

                        if (node.ModuleName != null)
                        {
                            Output("from");
                            SetContextOutputPosition(node.FromContext);

                            Output(EscapeString(node.ModuleName));
                            SetContextOutputPosition(node.ModuleContext);
                        }
                    }
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ForInStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("for");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Variable != null)
                {
                    // we have a no-in scenario for the variable
                    m_noIn = true;
                    node.Variable.Accept(this);
                    m_noIn = false;
                }

                if (node.OperatorContext != null
                    && !node.OperatorContext.Code.IsNullOrWhiteSpace())
                {
                    Output(node.OperatorContext.Code);
                }
                else
                {
                    // assume this is a for-in operator
                    Output("in");
                }

                MarkSegment(node, null, node.OperatorContext);

                if (node.Collection != null)
                {
                    node.Collection.Accept(this);
                }

                OutputPossibleLineBreak(')');
                MarkSegment(node, null, node.Context);
                OutputBlock(node.Body);

                EndSymbol(symbol);
            }
        }

        public void Visit(ForStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("for");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Initializer != null)
                {
                    // we have a no-in scenario for the initializer
                    m_noIn = true;
                    node.Initializer.Accept(this);
                    m_noIn = false;
                }

                // NEVER do without these semicolons
                OutputPossibleLineBreak(';');
                MarkSegment(node, null, node.Separator1Context ?? node.Context); 
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                OutputPossibleLineBreak(';');
                MarkSegment(node, null, node.Separator2Context ?? node.Context);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                if (node.Incrementer != null)
                {
                    node.Incrementer.Accept(this);
                }

                OutputPossibleLineBreak(')');
                MarkSegment(node, null, node.Context);

                OutputBlock(node.Body);
                EndSymbol(symbol);
            }
        }

        private void OutputFunctionPrefix(FunctionObject node, string functionName)
        {
            if (node.FunctionType == FunctionType.Method)
            {
                if (node.IsAsync)
                {
                    Output("async");
                }

                if (node.IsGenerator)
                {
                    Output('*');
                    MarkSegment(node, functionName, node.Context);
                    SetContextOutputPosition(node.Context);
                }
            }
            else if (node.FunctionType == FunctionType.Getter)
            {
                Output("get");
                MarkSegment(node, functionName, node.Context);
                SetContextOutputPosition(node.Context);
            }
            else if (node.FunctionType == FunctionType.Setter)
            {
                Output("set");
                MarkSegment(node, functionName, node.Context);
                SetContextOutputPosition(node.Context);
            }
            else
            {
                if (node.IsAsync)
                {
                    Output("async");
                }

                Output("function");
                MarkSegment(node, functionName, node.Context);
                SetContextOutputPosition(node.Context);

                if (node.IsGenerator)
                {
                    Output('*');
                }
            }
        }

        public void Visit(FunctionObject node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;
                m_noIn = false;

                if (node.FunctionType == FunctionType.ArrowFunction)
                {
                    if (node.IsAsync)
                    {
                        Output("async");
                    }

                    // arrow functions are simple...
                    OutputFunctionArgsAndBody(node);
                }
                else
                {
                    var encloseInParens = node.IsExpression && m_startOfStatement;
                    if (encloseInParens)
                    {
                        OutputPossibleLineBreak('(');
                    }

                    // get the function name we will use for symbol references.
                    // use the function's real name if:
                    //    1. there is one AND
                    //      2a. the function is not an expression (declaration, method, getter/setter) OR
                    //      2b. the refcount is greater than zero OR
                    //      2c. we aren't going to remove function expression names
                    // otherwise use the name guess.
                    var hasName = (node.Binding != null && !node.Binding.Name.IsNullOrWhiteSpace())
                            && (node.FunctionType != FunctionType.Expression
                                || node.Binding.VariableField.RefCount > 0
                                || !m_settings.RemoveFunctionExpressionNames
                                || !m_settings.IsModificationAllowed(TreeModifications.RemoveFunctionExpressionNames));
                    var fullFunctionName = hasName
                            ? node.Binding.Name
                            : node.NameGuess;

                    if (node.IsStatic)
                    {
                        Output("static");
                    }

                    OutputFunctionPrefix(node, fullFunctionName);
                    m_startOfStatement = false;
                    bool isAnonymous = true;
                    if (node.Binding != null && !node.Binding.Name.IsNullOrWhiteSpace())
                    {
                        isAnonymous = false;
                        var minFunctionName = node.Binding.VariableField != null
                            ? node.Binding.VariableField.ToString()
                            : node.Binding.Name;
                        if (m_settings.SymbolsMap != null)
                        {
                            m_functionStack.Push(minFunctionName);
                        }

                        if (hasName)
                        {
                            // all identifier should be treated as if they start with a valid
                            // identifier character. That might not always be the case, like when
                            // we consider an ASP.NET block to output the start of an identifier.
                            // so let's FORCE the insert-space logic here.
                            if (JSScanner.IsValidIdentifierPart(m_lastCharacter))
                            {
                                Output(' ');
                            }

                            Output(minFunctionName);
                            MarkSegment(node, node.Binding.Name, node.Binding.Context);
                            SetContextOutputPosition(node.Context);
                        }
                    }

                    if (m_settings.SymbolsMap != null && isAnonymous)
                    {
                        BinaryExpression binaryExpression = node.Parent as BinaryExpression;
                        if (binaryExpression?.Operand1 is LookupExpression)
                        {
                            m_functionStack.Push("(anonymous) [{0}]".FormatInvariant(binaryExpression.Operand1));
                        }
                        else
                        {
                            m_functionStack.Push("(anonymous)");
                        }
                    }

                    OutputFunctionArgsAndBody(node);

                    if (encloseInParens)
                    {
                        OutputPossibleLineBreak(')');
                    }
                }

                m_noIn = isNoIn;
                EndSymbol(symbol);
                if (m_settings.SymbolsMap != null)
                {
                    m_functionStack.Pop();
                }
           }
        }

        public void Visit(GetterSetter node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output(node.IsGetter ? "get" : "set");
                MarkSegment(node, node.Value.ToString(), node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                Output(node.Value.ToString());

                EndSymbol(symbol);
            }
        }

        public virtual void Visit(GroupingOperator node)
        {
            if (node != null)
            {
                // don't output a possible line-break here.
                Output('(');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;

                if (node.Operand != null)
                {
                    node.Operand.Accept(this);
                }

                OutputPossibleLineBreak(')');
                MarkSegment(node, null, node.Context);
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public void Visit(IfStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("if");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }

                OutputPossibleLineBreak(')');

                if (node.TrueBlock != null && node.TrueBlock.ForceBraces)
                {
                    OutputBlockWithBraces(node.TrueBlock);
                }
                else if (node.TrueBlock == null || node.TrueBlock.Count == 0)
                {
                    // no true-block; just output an empty statement
                    OutputPossibleLineBreak(';');
                }
                else if (node.TrueBlock.Count == 1
                    && (node.FalseBlock == null || (!node.TrueBlock.EncloseBlock(EncloseBlockType.IfWithoutElse) && !node.TrueBlock.EncloseBlock(EncloseBlockType.SingleDoWhile)))
                    && (!m_settings.MacSafariQuirks || !(node.TrueBlock[0] is FunctionObject)))
                {
                    // we only have a single statement in the true-branch; normally
                    // we wouldn't wrap that statement in braces. However, if there 
                    // is an else-branch, we need to make sure that single statement 
                    // doesn't end with an if-statement that doesn't have an else-branch
                    // because otherwise OUR else-branch will get associated with that
                    // other if-statement. AND it can't end in a do-while statement because then
                    // we run into IE issues with the strict terminating semi-colon.
                    // AND if we are being safari-strict, we want to wrap a single function declaration in
                    // curly-braces, too.
                    Indent();
                    NewLine();

                    m_startOfStatement = true;
                    node.TrueBlock[0].Accept(this);
                    if (node.TrueBlock[0] is ImportantComment)
                    {
                        // the true-block only contained a single important comment.
                        // that's not a true statement, so terminate it with an empty-statement
                        // semicolon
                        OutputPossibleLineBreak(';');
                    }

                    if (node.FalseBlock != null && node.FalseBlock.Count > 0
                        && m_requiresSeparator.Query(node.TrueBlock[0]))
                    {
                        // we have only one statement, we did not wrap it in braces,
                        // and we have an else-block, and the one true-statement needs
                        // a semicolon; add it now. But because we're going to be outputting
                        // and ELSE keyword next, if we are at the end of a line, we can omit the
                        // semicolon and just output the line-break, because semicolon-insertion
                        // rules will kick in here.
                        if (ReplaceableSemicolon())
                        {
                            MarkSegment(node.TrueBlock[0], null, node.TrueBlock[0].TerminatingContext);
                        }
                    }

                    Unindent();
                }
                else
                {
                    OutputBlockWithBraces(node.TrueBlock);
                }

                if (node.FalseBlock != null && (node.FalseBlock.Count > 0 || node.FalseBlock.ForceBraces))
                {
                    NewLine();
                    Output("else");
                    MarkSegment(node, null, node.ElseContext);
                    if (node.FalseBlock.Count == 1 && !node.FalseBlock.ForceBraces)
                    {
                        var statement = node.FalseBlock[0];
                        if (statement is IfStatement)
                        {
                            // this is an else-if construct. Don't newline or indent, just
                            // handle the if-statement directly. 
                            statement.Accept(this);
                        }
                        else
                        {
                            Indent();
                            NewLine();
                            m_startOfStatement = true;
                            statement.Accept(this);
                            Unindent();
                        }
                    }
                    else
                    {
                        OutputBlockWithBraces(node.FalseBlock);
                    }
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ImportantComment node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                // make sure we force the important comments to start on a new line, regardless
                // of whether or not we are in multi- or single-line mode, and the statement after
                // should also be on a new line.
                BreakLine(true);

                node.Context.OutputLine = m_lineCount;

                // the output method assumes any text we send it's way doesn't contain any line feed
                // characters. The important comment, however, may contain some. We don't want to count
                // the entire comment as a single line, AND we want to normalize the line-feed characters,
                // so lets process the comment line-by-line
                var startIndex = 0;
                var firstLF = node.Comment.IndexOfAny(LineFeedCharacters, startIndex);
                if (firstLF < 0)
                {
                    // no line-breaks at all!
                    Output(node.Comment);
                }
                else
                {
                    // output the first segment -- from start to first line break
                    Output(node.Comment.Substring(0, firstLF));
                    while (true)
                    {
                        // advance the next segment pointer
                        if (node.Comment[firstLF] == '\r'
                            && firstLF < node.Comment.Length - 1
                            && node.Comment[firstLF + 1] == '\n')
                        {
                            startIndex = firstLF + 2;
                        }
                        else
                        {
                            startIndex = firstLF + 1;
                        }

                        // force the line-break in the output
                        BreakLine(true);

                        // look for the next line break
                        firstLF = node.Comment.IndexOfAny(LineFeedCharacters, startIndex);

                        if (firstLF > startIndex)
                        {
                            // only output something if there was something before the next line break
                            Output(node.Comment.Substring(startIndex, firstLF - startIndex));
                        }
                        else if (firstLF < 0)
                        {
                            // no more line-breaks -- output the last segment and break out of the loop
                            Output(node.Comment.Substring(startIndex));
                            break;
                        }
                    }
                }

                // force a line-break AFTER teh important comment as well
                BreakLine(true);
                EndSymbol(symbol);
            }
        }

        public void Visit(ImportExportSpecifier node)
        {
            if (node != null)
            {
                if (node.Parent is ImportStatement)
                {
                    // import specifier: external (as local)
                    if (!node.ExternalName.IsNullOrWhiteSpace())
                    {
                        Output(node.ExternalName);
                        SetContextOutputPosition(node.Context);
                        SetContextOutputPosition(node.NameContext);

                        Output("as");
                        SetContextOutputPosition(node.AsContext);
                    }

                    // the local identiier should ALWAYS be present, but just in case...
                    if (node.LocalIdentifier != null)
                    {
                        node.LocalIdentifier.Accept(this);
                        if (node.ExternalName.IsNullOrWhiteSpace())
                        {
                            // if there was no external name, then this is the first (and only)
                            // part of the node output, so set the node's context position from it.
                            SetContextOutputPosition(node.Context);
                        }
                    }
                }
                else
                {
                    // export specifier: local (as external)
                    // local identifier should always be present...
                    if (node.LocalIdentifier != null)
                    {
                        node.LocalIdentifier.Accept(this);
                        SetContextOutputPosition(node.Context);
                    }

                    if (!node.ExternalName.IsNullOrWhiteSpace())
                    {
                        Output("as");
                        SetContextOutputPosition(node.AsContext);

                        Output(node.ExternalName);
                        SetContextOutputPosition(node.NameContext);
                    }
                }
            }
        }

        public void Visit(ImportStatement node)
        {
            if (node != null)
            {
                Output("import");
                SetContextOutputPosition(node.Context);
                SetContextOutputPosition(node.KeywordContext);
                m_startOfStatement = false;

                // ANY specifier or identifier is optional
                if (node.Count > 0)
                {
                    if (node.Count == 1 && node[0] is BindingIdentifier)
                    {
                        // identifier without braces
                        node[0].Accept(this);
                    }
                    else
                    {
                        // specifier list enclosed in braces
                        OutputPossibleLineBreak('{');
                        SetContextOutputPosition(node.OpenContext);

                        var first = true;
                        foreach (var specifier in node.Children)
                        {
                            if (first)
                            {
                                first = false;
                            }
                            else
                            {
                                OutputPossibleLineBreak(',');
                            }

                            specifier.Accept(this);
                        }

                        OutputPossibleLineBreak('}');
                        SetContextOutputPosition(node.CloseContext);
                    }

                    Output("from");
                    SetContextOutputPosition(node.FromContext);
                }

                // module is mandatory, but if it's null we didn't have one.
                if (node.ModuleName != null)
                {
                    Output(EscapeString(node.ModuleName));
                    SetContextOutputPosition(node.ModuleContext);
                }
            }
        }

        public void Visit(InitializerNode node)
        {
            if (node != null)
            {
                if (node.Binding != null)
                {
                    node.Binding.Accept(this);
                }

                OutputPossibleLineBreak('=');
                MarkSegment(node, null, node.AssignContext);

                if (node.Initializer != null)
                {
                    node.Initializer.Accept(this);
                }
            }
        }

        public void Visit(LabeledStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                if (!node.Label.IsNullOrWhiteSpace())
                {
                    if (node.LabelInfo.IfNotNull(li => !li.MinLabel.IsNullOrWhiteSpace()))
                    {
                        // output minified label
                        Output(node.LabelInfo.MinLabel);
                    }
                    else
                    {
                        // not minified -- just output original label
                        Output(node.Label);
                    }

                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);
                    OutputPossibleLineBreak(':');
                    MarkSegment(node, null, node.ColonContext);
                }

                if (node.Statement != null)
                {
                    m_startOfStatement = true;
                    node.Statement.Accept(this);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(LexicalDeclaration node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                // save the no-in state -- we'll reset before processing each initializer
                var isNoIn = m_noIn;

                Output(OperatorString(node.StatementToken));
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                Indent();
                var useNewLines = !(node.Parent is ForStatement);

                for (var ndx = 0; ndx < node.Count; ++ndx)
                {
                    var decl = node[ndx];
                    if (decl != null)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            if (useNewLines)
                            {
                                NewLine();
                            }
                            else if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        // be sure to set the no-in state to whatever it was when we entered
                        // this node, because each declaration might reset it as it's outputting
                        // its child nodes
                        m_noIn = isNoIn;
                        decl.Accept(this);
                    }
                }

                Unindent();
                EndSymbol(symbol);
            }
        }

        public void Visit(LookupExpression node)
        {
            if (node != null)
            {
                // all identifier should be treated as if they start with a valid
                // identifier character. That might not always be the case, like when
                // we consider an ASP.NET block to output the start of an identifier.
                // so let's FORCE the insert-space logic here.
                if (JSScanner.IsValidIdentifierPart(m_lastCharacter))
                {
                    OutputSpaceOrLineBreak();
                }

                var symbol = StartSymbol(node);

                Output(node.VariableField != null
                    ? node.VariableField.ToString()
                    : node.Name);
                MarkSegment(node, node.Name, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;

                EndSymbol(symbol);
            }
        }

        public void Visit(MemberExpression node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;
                m_noIn = false;

                if (node.Root != null)
                {
                    var constantWrapper = node.Root as ConstantWrapper;
                    if (constantWrapper != null 
                        && (constantWrapper.IsFiniteNumericLiteral || constantWrapper.IsOtherDecimal))
                    {
                        // numeric constant wrapper that isn't NaN or Infinity - get the formatted text version.
                        // if the number has issues, then don't format it and just use the source.
                        string numericText;
                        if (constantWrapper.Context == null
                            || !constantWrapper.Context.HasCode
                            || (m_settings.IsModificationAllowed(TreeModifications.MinifyNumericLiterals) && !constantWrapper.MayHaveIssues))
                        {
                            // apply minification to the literal to get it as small as possible
                            numericText = NormalizeNumber(constantWrapper.ToNumber(), constantWrapper.Context);
                        }
                        else
                        {
                            // context is not null but we don't want to minify numeric literals.
                            // just use the original literal from the context.
                            numericText = constantWrapper.Context.Code;
                        }

                        // if the value is negative, we're going to need to wrap it in parens
                        if (numericText.StartsWith("-", StringComparison.Ordinal))
                        {
                            Output('(');
                            Output(numericText);
                            Output(')');
                        }
                        else
                        {
                            // if there is no decimal point in the number and no exponent, then we may need to add 
                            // a decimal point to the end of the number so the member-dot operator doesn't get mistaken 
                            // for the decimal point and generate a syntax error.
                            Output(numericText);
                            if (numericText.IndexOf('.') < 0
                                && numericText.IndexOf("e", StringComparison.OrdinalIgnoreCase) < 0)
                            {
                                // HOWEVER... octal literals don't need the dot. So if this number starts with zero and
                                // has more than one digit, we need to check for octal literals and 0xd+ 0bd+ and 0od+ literals,
                                // because THOSE don't need the extra dot, either. 
                                bool addDecimalPoint = !numericText.StartsWith("0", StringComparison.Ordinal) || numericText.Length == 1;
                                if (!addDecimalPoint)
                                {
                                    // But we might also have a number that just starts with zero and is a regular decimal (like 0009).
                                    // if the second "digit" isn't a number, then we have 0x or 0b or 0o, so we don't have to do
                                    // any further tests -- we know we don't need the extra decimal point. Otherwise we need to
                                    // make sure this
                                    if (JSScanner.IsDigit(numericText[1]))
                                    {
                                        // the second character is a digit, so we know we aren't 0x, 0b, or 0o. But we start with
                                        // a zero -- so we need to test to see if this is an octal literal, because they do NOT need
                                        // the extra decimal point. But if it isn't an octal literal, we DO need it after all.
                                        for (var ndx = 1; ndx < numericText.Length; ++ndx)
                                        {
                                            if ('7' < numericText[ndx])
                                            {
                                                // NOT octal; we need the extra dot
                                                addDecimalPoint = true;
                                                break;
                                            }
                                        }
                                    }
                                }

                                if (addDecimalPoint)
                                {
                                    Output('.');
                                }
                            }
                        }
                    }
                    else
                    {
                        // not a numeric constant wrapper
                        var needsParens = node.Root.Precedence < node.Precedence;
                        if (!needsParens)
                        {
                            // if the root is a new operator with no arguments, then we need to wrap
                            var callNode = node.Root as CallExpression;
                            if (callNode != null
                                && callNode.IsConstructor
                                && (callNode.Arguments == null || callNode.Arguments.Count == 0))
                            {
                                needsParens = true;
                            }
                        }

                        AcceptNodeWithParens(node.Root, needsParens);
                    }

                    SetContextOutputPosition(node.Context);
                }

                OutputPossibleLineBreak('.');
                MarkSegment(node, node.Name, node.NameContext);
                Output(node.Name);
                m_startOfStatement = false;
                m_noIn = isNoIn;

                EndSymbol(symbol);
            }
        }

        public void Visit(ModuleDeclaration node)
        {
            if (node != null)
            {
                if (node.IsImplicit)
                {
                    // implicit module declarations just skip the module part and output only the body.
                    if (node.Body != null)
                    {
                        node.Body.Accept(this);
                    }
                }
                else
                {
                    // explicit module statement
                    Output("module");
                    SetContextOutputPosition(node.Context);
                    SetContextOutputPosition(node.ModuleContext);

                    if (node.Binding != null)
                    {
                        // bind entire external module to an identifier
                        node.Binding.Accept(this);
                        Output("from");
                        SetContextOutputPosition(node.FromContext);

                        if (node.ModuleName != null)
                        {
                            Output(EscapeString(node.ModuleName));
                            SetContextOutputPosition(node.ModuleContext);
                        }
                    }
                    else
                    {
                        // inline module declaration
                        m_noLineBreaks = true;
                        if (node.ModuleName != null)
                        {
                            Output(EscapeString(node.ModuleName));
                            SetContextOutputPosition(node.ModuleContext);
                        }

                        if (node.Body != null)
                        {
                            node.Body.Accept(this);
                        }
                        else
                        {
                            // no body; add an empty one.
                            Output("{}");
                        }
                    }
                }
            }
        }

        public void Visit(ObjectLiteral node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                var isNoIn = m_noIn;
                m_noIn = false;

                // if start of statement, need to enclose in parens
                var encloseInParens = m_startOfStatement;
                if (encloseInParens)
                {
                    OutputPossibleLineBreak('(');
                }

                OutputPossibleLineBreak('{');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                m_startOfStatement = false;
                Indent();

                var count = node.Properties.IfNotNull(p => p.Count);
                if (count > 1)
                {
                    NewLine();
                }

                // output each key/value pair
                if (node.Properties != null)
                {
                    node.Properties.Accept(this);
                }

                Unindent();
                if (count > 1)
                {
                    NewLine();
                }

                Output('}');
                MarkSegment(node, null, node.Context);
                if (encloseInParens)
                {
                    Output(')');
                }

                m_noIn = isNoIn;

                EndSymbol(symbol);
            }
        }

        public void Visit(ObjectLiteralField node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                if (m_settings.QuoteObjectLiteralProperties)
                {
                    // we always want to quote object literal property names, no matter whether
                    // they are valid JS identifiers, numbers, or whatever. Typically this is done
                    // because we're generating JSON output, which requires quotes.
                    if (node.PrimitiveType == PrimitiveType.String)
                    {
                        // strings are always quoted anyway
                        Visit(node as ConstantWrapper);
                    }
                    else
                    {
                        // output quotes around it
                        Output('"');
                        Visit(node as ConstantWrapper);
                        Output('"');
                    }
                }
                else if (node.PrimitiveType == PrimitiveType.String)
                {
                    // call the base to format the value
                    // determine whether we need quotes or not
                    var propertyName = node.ToString();
                    if (!string.IsNullOrEmpty(propertyName)
                        && JSScanner.IsSafeIdentifier(propertyName)
                        && !JSScanner.IsKeyword(propertyName, node.EnclosingScope.IfNotNull(s => s.UseStrict)))
                    {
                        Output(propertyName);
                        MarkSegment(node, null, node.Context);
                    }
                    else
                    {
                        // base implementation adds quotes
                        Visit(node as ConstantWrapper);
                    }
                }
                else
                {
                    // not a string -- just output it
                    Visit(node as ConstantWrapper);
                }

                OutputPossibleLineBreak(':');
                MarkSegment(node, null, node.ColonContext);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ObjectLiteralProperty node)
        {
            if (node != null)
            {
                // getter/setter will be handled by the value, which is the function object
                if (node.Name != null && !(node.Name is GetterSetter))
                {
                    node.Name.Accept(this);
                    SetContextOutputPosition(node.Context);
                }

                if (node.Value != null)
                {
                    AcceptNodeWithParens(node.Value, node.Value.Precedence == OperatorPrecedence.Comma);
                }
            }
        }

        public void Visit(ParameterDeclaration node)
        {
            if (node != null)
            {
                if (node.HasRest)
                {
                    Output(OperatorString(JSToken.RestSpread));
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);
                }

                // output the binding
                if (node.Binding != null)
                {
                    node.Binding.Accept(this);
                }

                // optional initializer
                if (node.Initializer != null)
                {
                    if (m_settings.OutputMode == OutputMode.MultipleLines && m_settings.IndentSize > 0)
                    {
                        OutputPossibleLineBreak(' ');
                        OutputPossibleLineBreak('=');
                        BreakLine(false);
                        if (!m_onNewLine)
                        {
                            OutputPossibleLineBreak(' ');
                        }
                    }
                    else
                    {
                        OutputPossibleLineBreak('=');
                    }

                    AcceptNodeWithParens(node.Initializer, node.Initializer.Precedence == OperatorPrecedence.Comma);
                }
            }
        }

        public void Visit(RegExpLiteral node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                m_startOfStatement = false;

                // cannot have a line break anywhere in this node
                Output('/');
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);

                Output(node.Pattern);
                Output('/');
                if (!string.IsNullOrEmpty(node.PatternSwitches))
                {
                    Output(node.PatternSwitches);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(ReturnStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("return");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                if (node.Operand != null)
                {
                    if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        Output(' ');
                    }

                    // no page breaks allowed here
                    m_noLineBreaks = true;
                    Indent();
                    node.Operand.Accept(this);
                    Unindent();
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(SwitchStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("switch");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Expression != null)
                {
                    node.Expression.Accept(this);
                }
                OutputPossibleLineBreak(')');
                if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                    || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.BraceOnNewLine))
                {
                    NewLine();
                }
                else if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('{');
                MarkSegment(node, null, node.BraceContext); 
                Indent();

                AstNode prevSwitchCase = null;
                for (var ndx = 0; ndx < node.Cases.Count; ++ndx)
                {
                    var switchCase = node.Cases[ndx];
                    if (switchCase != null)
                    {
                        if (prevSwitchCase != null && m_requiresSeparator.Query(prevSwitchCase))
                        {
                            // because the next switch-case will always start with either the case or default
                            // keyword, if the semicolon we are about the output would be at the end of a newline,
                            // we can omit the semicolon altogether and just let the semicolon-insertion rules
                            // kick in.
                            if (ReplaceableSemicolon())
                            {
                                MarkSegment(prevSwitchCase, null, prevSwitchCase.TerminatingContext);
                            }
                        }

                        NewLine();
                        switchCase.Accept(this);
                        prevSwitchCase = switchCase;
                    }
                }

                Unindent();
                NewLine();
                OutputPossibleLineBreak('}');
                MarkSegment(node, null, node.BraceContext);

                EndSymbol(symbol);
            }
        }

        public void Visit(SwitchCase node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                if (node.CaseValue != null)
                {
                    Output("case");
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);

                    m_startOfStatement = false;
                    node.CaseValue.Accept(this);
                }
                else
                {
                    Output("default");
                    MarkSegment(node, null, node.Context);
                    SetContextOutputPosition(node.Context);
                }

                OutputPossibleLineBreak(':');
                MarkSegment(node, null, node.ColonContext);
                if (node.Statements != null && node.Statements.Count > 0)
                {
                    Indent();
                    AstNode prevStatement = null;
                    for (var ndx = 0; ndx < node.Statements.Count; ++ndx)
                    {
                        var statement = node.Statements[ndx];
                        if (statement != null)
                        {
                            if (prevStatement != null && m_requiresSeparator.Query(prevStatement))
                            {
                                OutputPossibleLineBreak(';');
                                MarkSegment(prevStatement, null, prevStatement.TerminatingContext);
                            }

                            NewLine();
                            m_startOfStatement = true;
                            statement.Accept(this);
                            prevStatement = statement;
                        }
                    }

                    Unindent();
                }

                EndSymbol(symbol);
            }
        }

        public virtual void Visit(TemplateLiteral node)
        {
            if (node != null)
            {
                if (node.Function != null)
                {
                    node.Function.Accept(this);
                    m_startOfStatement = false;
                }

                // get the text string to output. If we don't want to minify string literals,
                // then we should also not minify template literals (since they're just special strings)
                var text = node.Text;
                if (node.TextContext != null && !m_settings.IsModificationAllowed(TreeModifications.MinifyStringLiterals))
                {
                    // use the raw version of the text source
                    text = node.TextContext.Code;
                }

                if (!text.IsNullOrWhiteSpace())
                {
                    Output(text);
                    MarkSegment(node, null, node.TextContext ?? node.Context);
                    SetContextOutputPosition(node.TextContext);
                    m_startOfStatement = false;
                }

                if (node.Expressions != null && node.Expressions.Count > 0)
                {
                    node.Expressions.ForEach<TemplateLiteralExpression>(expr =>
                        {
                            expr.Accept(this);
                        });
                }
            }
        }

        public virtual void Visit(TemplateLiteralExpression node)
        {
            if (node != null)
            {
                if (node.Expression != null)
                {
                    node.Expression.Accept(this);
                }

                if (!node.Text.IsNullOrWhiteSpace())
                {
                    Output(node.Text);
                    MarkSegment(node, null, node.TextContext);
                    SetContextOutputPosition(node.TextContext);
                    m_startOfStatement = false;
                }
            }
        }

        public void Visit(ThisLiteral node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("this");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                EndSymbol(symbol);
            }
        }

        public void Visit(ThrowStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("throw");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                if (node.Operand != null)
                {
                    m_noLineBreaks = true;
                    node.Operand.Accept(this);
                }

                if (m_settings.MacSafariQuirks)
                {
                    // force the statement ending with a semicolon
                    OutputPossibleLineBreak(';');
                    MarkSegment(node, null, node.TerminatingContext);
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(TryStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                OutputTryBranch(node);

                var hasCatchBlock = false;
                if (node.CatchParameter != null)
                {
                    hasCatchBlock = true;
                    OutputCatchBranch(node);
                }

                if (!hasCatchBlock || (node.FinallyBlock != null && node.FinallyBlock.Count > 0))
                {
                    OutputFinallyBranch(node);
                }

                EndSymbol(symbol);
            }
        }

        private void OutputTryBranch(TryStatement node)
        {
            Output("try");
            MarkSegment(node, null, node.Context);
            SetContextOutputPosition(node.Context);
            if (node.TryBlock == null || node.TryBlock.Count == 0)
            {
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                Output("{}");
                BreakLine(false);
            }
            else
            {
                if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                    || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.TryBlock.BraceOnNewLine))
                {
                    NewLine();
                }
                else if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                node.TryBlock.Accept(this);
            }
        }

        private void OutputCatchBranch(TryStatement node)
        {
            NewLine();
            Output("catch(");
            node.CatchParameter.IfNotNull(p => p.Accept(this));
            OutputPossibleLineBreak(')');

            if (node.CatchBlock == null || node.CatchBlock.Count == 0)
            {
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                Output("{}");
                BreakLine(false);
            }
            else
            {
                if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                    || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.CatchBlock.BraceOnNewLine))
                {
                    NewLine();
                }
                else if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                node.CatchBlock.Accept(this);
            }
        }

        private void OutputFinallyBranch(TryStatement node)
        {
            NewLine();
            Output("finally");
            MarkSegment(node, null, node.FinallyContext);
            if (node.FinallyBlock == null || node.FinallyBlock.Count == 0)
            {
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                Output("{}");
                BreakLine(false);
            }
            else
            {
                if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                    || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.FinallyBlock.BraceOnNewLine))
                {
                    NewLine();
                }
                else if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                node.FinallyBlock.Accept(this);
            }
        }

        public void Visit(VarDeclaration node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                // save the no-in state -- we'll reset before processing each initializer
                var isNoIn = m_noIn;

                Output("var");
                MarkSegment(node, null, node.Context);
                SetContextOutputPosition(node.Context);
                m_startOfStatement = false;
                Indent();
                var useNewLines = !(node.Parent is ForStatement);

                for (var ndx = 0; ndx < node.Count; ++ndx)
                {
                    var decl = node[ndx];
                    if (decl != null)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            if (useNewLines)
                            {
                                NewLine();
                            }
                            else if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        // be sure to set the no-in state to whatever it was when we entered
                        // this node, because each declaration might reset it as it's outputting
                        // its child nodes
                        m_noIn = isNoIn;
                        decl.Accept(this);
                    }
                }
                Unindent();

                EndSymbol(symbol);
            }
        }

        public void Visit(VariableDeclaration node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                // output the binding
                if (node.Binding != null)
                {
                    node.Binding.Accept(this);
                }

                m_startOfStatement = false;
                if (node.Initializer != null)
                {
                    if (node.IsCCSpecialCase)
                    {
                        // we haven't output a cc_on yet -- output it now.
                        // if we have, we really only need to output one if we had one to begin with AND
                        // we are NOT removing unnecessary ones
                        if (!m_outputCCOn
                            || (node.UseCCOn && !m_settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryCCOnStatements)))
                        {
                            Output("/*@cc_on=");
                            m_outputCCOn = true;
                        }
                        else
                        {
                            Output("/*@=");
                        }
                    }
                    else
                    {
                        if (m_settings.OutputMode == OutputMode.MultipleLines && m_settings.IndentSize > 0)
                        {
                            OutputPossibleLineBreak(' ');
                            OutputPossibleLineBreak('=');
                            BreakLine(false);
                            if (!m_onNewLine)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }
                        else
                        {
                            OutputPossibleLineBreak('=');
                        }
                    }

                    AcceptNodeWithParens(node.Initializer, node.Initializer.Precedence == OperatorPrecedence.Comma);

                    if (node.IsCCSpecialCase)
                    {
                        Output("@*/");
                    }
                }

                EndSymbol(symbol);
            }
        }

        public void Visit(UnaryExpression node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                var isNoIn = m_noIn;
                m_noIn = false;

                if (node.IsPostfix)
                {
                    if (node.Operand != null)
                    {
                        AcceptNodeWithParens(node.Operand, node.Operand.Precedence < node.Precedence);
                        SetContextOutputPosition(node.Context, node.Operand.Context);
                    }

                    // the only postfix unary operators are ++ and --, and when in the postfix position,
                    // line breaks are NOT allowed between the operand and the operator.
                    // doesn't seem to need this flag set here, but set it anyways just in case.
                    m_noLineBreaks = true;
                    Output(OperatorString(node.OperatorToken));
                    MarkSegment(node, null, node.OperatorContext);
                    m_startOfStatement = false;
                }
                else if (node.OperatorToken == JSToken.RestSpread)
                {
                    // spread operator. Output the spread token followed by the
                    // operand. I don't think we need parentheses or anything.
                    Output(OperatorString(JSToken.RestSpread));
                    MarkSegment(node, null, node.OperatorContext ?? node.Context);
                    node.Operand.IfNotNull(o => o.Accept(this));
                }
                else
                {
                    if (node.OperatorInConditionalCompilationComment)
                    {
                        // if we haven't output a cc_on yet, we ALWAYS want to do it now, whether or not the 
                        // sources had one. Otherwise, we only only want to output one if we had one and we aren't
                        // removing unneccesary ones.
                        if (!m_outputCCOn
                            || (node.ConditionalCommentContainsOn && !m_settings.IsModificationAllowed(TreeModifications.RemoveUnnecessaryCCOnStatements)))
                        {
                            // output it now and set the flag that we have output them
                            Output("/*@cc_on");
                            m_outputCCOn = true;
                        }
                        else
                        {
                            Output("/*@");
                        }

                        Output(OperatorString(node.OperatorToken));
                        MarkSegment(node, null, node.OperatorContext);
                        SetContextOutputPosition(node.Context);
                        Output("@*/");
                    }
                    else
                    {
                        Output(OperatorString(node.OperatorToken));
                        MarkSegment(node, null, node.OperatorContext ?? node.Context);
                        SetContextOutputPosition(node.Context);
                        
                        // if this is a yield delegator, output the asterisk
                        if (node.OperatorToken == JSToken.Yield && node.IsDelegator)
                        {
                            Output('*');
                        }
                    }

                    m_startOfStatement = false;
                    if (node.Operand != null)
                    {
                        AcceptNodeWithParens(node.Operand, node.Operand.Precedence < node.Precedence);
                    }
                }

                m_noIn = isNoIn;
                EndSymbol(symbol);
            }
        }

        public void Visit(WhileStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);

                Output("while");
                SetContextOutputPosition(node.Context);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.Condition != null)
                {
                    node.Condition.Accept(this);
                }
                OutputPossibleLineBreak(')');

                OutputBlock(node.Body);

                EndSymbol(symbol);
            }
        }

        public void Visit(WithStatement node)
        {
            if (node != null)
            {
                var symbol = StartSymbol(node);
                Output("with");
                SetContextOutputPosition(node.Context);
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    OutputPossibleLineBreak(' ');
                }

                OutputPossibleLineBreak('(');
                m_startOfStatement = false;
                if (node.WithObject != null)
                {
                    node.WithObject.Accept(this);
                }
                OutputPossibleLineBreak(')');

                OutputBlock(node.Body);
                EndSymbol(symbol);
            }
        }

        #endregion

        #region output methods

        private void Output(string text)
        {
            if (!string.IsNullOrEmpty(text))
            {
                // insert a space if needed, then the character
                InsertSpaceIfNeeded(text);

                // save the start of this segment
                m_segmentStartLine = m_lineCount;
                m_segmentStartColumn = m_lineLength;

                m_lineLength += WriteToStream(text);
                m_noLineBreaks = false;

                // if it ends in a newline, we're still on a newline
                var lastChar = text[text.Length - 1];

                m_onNewLine = (lastChar == '\n' || lastChar == '\r'); ;

                // now set the "last character" state
                SetLastCharState(lastChar, text);
            }
        }

        private void Output(char ch)
        {
            // insert a space if needed, then the character
            InsertSpaceIfNeeded(ch);

            // save the start of this segment
            m_segmentStartLine = m_lineCount;
            m_segmentStartColumn = m_lineLength;

            m_lineLength += WriteToStream(ch);
            m_noLineBreaks = false;

            // determine if this was a newline character
            m_onNewLine = (ch == '\n' || ch == '\r');

            // now set the "last character" state
            SetLastCharState(ch);
        }

        private void OutputSpaceOrLineBreak()
        {
            if (m_noLineBreaks)
            {
                // don't bother going through the WriteToStream method, since
                // we KNOW a space won't be expanded to \u0020.
                m_outputStream.Write(' ');
                ++m_lineLength;
                m_lastCharacter = ' ';
            }
            else
            {
                OutputPossibleLineBreak(' ');
            }
        }

        private void InsertSpaceIfNeeded(char ch)
        {
            // shortcut a space character -- we never need a space before a space!
            if (ch != ' ')
            {
                if (m_addSpaceIfTrue != null)
                {
                    if (m_addSpaceIfTrue(ch))
                    {
                        OutputSpaceOrLineBreak();
                    }

                    // reset the function
                    m_addSpaceIfTrue = null;
                }
                else if ((ch == '+' || ch == '-') && m_lastCharacter == ch)
                {
                    // if the current character is a + or - and the last character was the same.
                    // if the previous character was an ODD number of the same character, 
                    // then we need to add a space so it doesn't get read as ++ (or --)
                    if (m_lastCountOdd)
                    {
                        OutputSpaceOrLineBreak();
                    }
                }
                else if ((m_lastCharacter == '@' || JSScanner.IsValidIdentifierPart(m_lastCharacter)) && JSScanner.IsValidIdentifierPart(ch))
                {
                    // either the last character is a valid part of an identifier and the current character is, too;
                    // OR the last part was numeric and the current character is a .
                    // we need to separate those with spaces as well
                    OutputSpaceOrLineBreak();
                }
            }
        }

        private void InsertSpaceIfNeeded(string text)
        {
            // if the current character is a + or - and the last character was the same....
            var ch = text[0];
            if (m_addSpaceIfTrue != null)
            {
                if (m_addSpaceIfTrue(ch))
                {
                    OutputSpaceOrLineBreak();
                }

                // reset the function
                m_addSpaceIfTrue = null;
            }
            else if ((ch == '+' || ch == '-') && m_lastCharacter == ch)
            {
                // if we want to put a + or a - in the stream, and the previous character was
                // an odd number of the same, then we need to add a space so it doesn't
                // get read as ++ (or --)
                if (m_lastCountOdd)
                {
                    OutputSpaceOrLineBreak();
                }
            }
            else if ((m_lastCharacter == '@' || JSScanner.IsValidIdentifierPart(m_lastCharacter)) 
                && (text[0] == '\\' || JSScanner.StartsWithValidIdentifierPart(text)))
            {
                // either the last character is a valid part of an identifier and the current character is, too;
                // OR the last part was numeric and the current character is a .
                // we need to separate those with spaces as well
                OutputSpaceOrLineBreak();
            }
        }

        private void SetLastCharState(char ch)
        {
            // if it's a + or a -, we need to adjust the odd state
            if (ch == '+' || ch == '-')
            {
                if (ch == m_lastCharacter)
                {
                    // same as the last string -- so we're adding one to it.
                    // if it was odd before, it's now even; if it was even before,
                    // it's now odd
                    m_lastCountOdd = !m_lastCountOdd;
                }
                else
                {
                    // not the same as last time, so this is a string of 1
                    // characters, which is odd
                    m_lastCountOdd = true;
                }
            }
            else
            {
                // neither + nor -; reset the odd state
                m_lastCountOdd = false;
            }

            m_lastCharacter = ch;
        }

        private void SetLastCharState(char lastChar, string text)
        {
            if (lastChar == '+' || lastChar == '-')
            {
                // see HOW MANY of those characters were at the end of the string
                var ndxDifferent = text.Length - 1;
                while (--ndxDifferent >= 0)
                {
                    if (text[ndxDifferent] != lastChar)
                    {
                        break;
                    }
                }

                // if the first diff index is less than zero, then the whole string is one of
                // these two special characters
                if (ndxDifferent < 0 && m_lastCharacter == lastChar)
                {
                    // the whole string is the same character, AND it's the same character 
                    // at the end of the last time we output stuff. We need to take into 
                    // account the previous state when we set the current state.
                    // it's a logical XOR -- if the two values are the same, m_lastCountOdd is false;
                    // it they are different, m_lastCountOdd is true.
                    m_lastCountOdd = (text.Length % 2 == 1) ^ m_lastCountOdd;
                }
                else
                {
                    // either the whole string wasn't the same character, OR the previous ending
                    // wasn't the same character. Either way, the current state is determined 
                    // exclusively by the number of characters we found at the end of this string
                    // get the number of same characters ending this string, mod by 2, and if the
                    // result is 1, it's an odd number of characters.
                    m_lastCountOdd = (text.Length - 1 - ndxDifferent) % 2 == 1;
                }
            }
            else
            {
                // say we weren't odd
                m_lastCountOdd = false;
            }

            // save the last character for next time
            m_lastCharacter = lastChar;
        }

        private void Indent()
        {
            ++m_indentLevel;
        }

        private void Unindent()
        {
            --m_indentLevel;
        }

        private void OutputPossibleLineBreak(char ch)
        {
            if (ch == ' ')
            {
                // break the line if it's already too long, but don't force it
                BreakLine(false);

                // if we aren't on a new line, then output our space character
                if (!m_onNewLine)
                {
                    m_lineLength += WriteToStream(ch);
                    m_lastCharacter = ch;
                }
            }
            else
            {
                // always output the character, although we can line-break
                // after it if needed
                InsertSpaceIfNeeded(ch);

                // save the start of this segment
                m_segmentStartLine = m_lineCount;
                m_segmentStartColumn = m_lineLength;
                
                m_lineLength += WriteToStream(ch);
                m_onNewLine = false;
                m_lastCharacter = ch;

                // break the line if it's too long, but don't force it
                BreakLine(false);
            }
        }

        private bool ReplaceableSemicolon()
        {
            var outputSemicolon = false;

            // this is a terminating semicolon that might be replaced with a line-break
            // if needed. Semicolon-insertion would suffice to reconstitute it.
            if (m_lineLength < m_settings.LineBreakThreshold)
            {
                // save the start of this segment
                m_segmentStartLine = m_lineCount;
                m_segmentStartColumn = m_lineLength;

                // output the semicolon
                // don't bother going through the WriteToStream method, since we
                // KNOW a semicolon won't be expanded to \u003b
                m_outputStream.Write(';');
                ++m_lineLength;
                m_onNewLine = false;
                m_lastCharacter = ';';
                outputSemicolon = true;
            }

            // break the line if it's too long, but don't force it
            BreakLine(false);
            return outputSemicolon;
        }

        private void BreakLine(bool forceBreak)
        {
            if (!m_onNewLine && (forceBreak || m_lineLength >= m_settings.LineBreakThreshold))
            {
                if (m_settings.OutputMode == OutputMode.MultipleLines)
                {
                    NewLine();
                }
                else
                {
                    // terminate the line and start a new one
                    // don't bother going through the WriteToStream method, since we
                    // KNOW a \n character won't be expanded to \u000a
                    m_outputStream.Write('\n');
                    m_lineCount++;

                    // set the appropriate newline state
                    m_lineLength = 0;
                    m_onNewLine = true;
                    m_lastCharacter = ' ';
                }
            }
        }

        private void NewLine()
        {
            if (m_settings.OutputMode == OutputMode.MultipleLines && !m_onNewLine)
            {
                // output the newline character -- don't go through WriteToStream
                // since we KNOW it won't get expanded to \uXXXX formats.
                m_outputStream.WriteLine();
                m_lineCount++;

                // if the indent level is greater than zero, output the indent spaces
                if (m_indentLevel > 0)
                {
                    // the spaces won't get expanded to \u0020, so don't bother going
                    // through the WriteToStream method.
                    var numSpaces = m_indentLevel * m_settings.IndentSize;
                    m_lineLength = numSpaces;
                    while (numSpaces-- > 0)
                    {
                        m_outputStream.Write(' ');
                    }
                }
                else
                {
                    m_lineLength = 0;
                }

                // say our last character was a space
                m_lastCharacter = ' ';

                // we just output a newline
                m_onNewLine = true;
            }
        }

        // write a text string to the output stream, optionally expanding any single characters
        // to \uXXXX format if outside the ASCII range. Return the actual number of characters written
        // after any expansion.
        private int WriteToStream(string text)
        {
            // if we always want to encode non-ascii characters, then we need
            // to look at each one and see if we need to encode anything!
            if (m_settings.AlwaysEscapeNonAscii)
            {
                StringBuilder sb = null;
                try
                {
                    var runStart = 0;
                    for (var ndx = 0; ndx < text.Length; ++ndx)
                    {
                        // if the character is over the ASCII range, we'll need to escape it
                        if (text[ndx] > '\u007f')
                        {
                            // if we haven't yet created the builder, create it now
                            if (sb == null)
                            {
                                sb = StringBuilderPool.Acquire();
                            }

                            // if there's a run of unescaped characters waiting to be
                            // output, output it now
                            if (ndx > runStart)
                            {
                                sb.Append(text, runStart, ndx - runStart);
                            }

                            // format the current character in \uXXXX, and start the next
                            // run at the NEXT character.
                            sb.AppendFormat(CultureInfo.InvariantCulture, "\\u{0:x4}".FormatInvariant((int)text[ndx]));
                            runStart = ndx + 1;
                        }
                    }

                    // if nothing needed escaping, the builder will still be null and we
                    // have nothing else to do (just use the string as-is)
                    if (sb != null)
                    {
                        // if there is an unescaped run at the end still left, add it now
                        if (runStart < text.Length)
                        {
                            sb.Append(text, runStart, text.Length - runStart);
                        }

                        // and use the fully-escaped string going forward.
                        text = sb.ToString();
                    }
                }
                finally
                {
                    sb.Release();
                }
            }

            m_outputStream.Write(text);
            return text.Length;
        }

        // write a single character to the stream, optionally expanding it to a \uXXXX sequence
        // if needed. Return the number of characters sent to the stream (1 or 6)
        private int WriteToStream(char ch)
        {
            if (m_settings.AlwaysEscapeNonAscii && ch > '\u007f')
            {
                // expand it to the \uXXXX format, which is six characters
                m_outputStream.Write("\\u{0:x4}", (int)ch);
                return 6;
            }
            else
            {
                m_outputStream.Write(ch);
                return 1;
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity", Justification="Big but simple case statement")]
        public static string OperatorString(JSToken token)
        {
            switch (token)
            {
                case JSToken.Decrement: return "--";
                case JSToken.Delete: return "delete";
                case JSToken.Increment: return "++";
                case JSToken.TypeOf: return "typeof";
                case JSToken.Void: return "void";
                case JSToken.LogicalNot: return "!";
                case JSToken.BitwiseNot: return "~";
                case JSToken.Minus: return "-";
                case JSToken.Plus: return "+";
                case JSToken.Multiply: return "*";
                case JSToken.BitwiseAnd: return "&";
                case JSToken.BitwiseOr: return "|";
                case JSToken.BitwiseXor: return "^";
                case JSToken.LogicalAnd: return "&&";
                case JSToken.LogicalOr: return "||";
                case JSToken.Assign: return "=";
                case JSToken.BitwiseAndAssign: return "&=";
                case JSToken.BitwiseOrAssign: return "|=";
                case JSToken.BitwiseXorAssign: return "^=";
                case JSToken.Comma: return ",";
                case JSToken.Equal: return "==";
                case JSToken.GreaterThan: return ">";
                case JSToken.GreaterThanEqual: return ">=";
                case JSToken.In: return "in";
                case JSToken.InstanceOf: return "instanceof";
                case JSToken.LeftShift: return "<<";
                case JSToken.LeftShiftAssign: return "<<=";
                case JSToken.LessThan: return "<";
                case JSToken.LessThanEqual: return "<=";
                case JSToken.MinusAssign: return "-=";
                case JSToken.Modulo: return "%";
                case JSToken.ModuloAssign: return "%=";
                case JSToken.MultiplyAssign: return "*=";
                case JSToken.NotEqual: return "!=";
                case JSToken.PlusAssign: return "+=";
                case JSToken.RightShift: return ">>";
                case JSToken.RightShiftAssign: return ">>=";
                case JSToken.StrictEqual: return "===";
                case JSToken.StrictNotEqual: return "!==";
                case JSToken.UnsignedRightShift: return ">>>";
                case JSToken.UnsignedRightShiftAssign: return ">>>=";
                case JSToken.Divide: return "/";
                case JSToken.DivideAssign: return "/=";
                case JSToken.Let: return "let";
                case JSToken.Const: return "const";
                case JSToken.ArrowFunction: return "=>";
                case JSToken.RestSpread: return "...";
                case JSToken.Yield: return "yield";
                case JSToken.Await: return "await";
                case JSToken.Get: return "get";
                case JSToken.Set: return "set";

                default: return string.Empty;
            }
        }

        #endregion

        #region Helper methods

        private void AcceptNodeWithParens(AstNode node, bool needsParens)
        {
            // if we need parentheses, add the opening
            if (needsParens)
            {
                OutputPossibleLineBreak('(');

                // because we output an open paren, reset the start flag
                m_startOfStatement = false;

                // and because we are outputting a paren, we are no longer in a no-in scenario
                m_noIn = false;
            }

            // now output the node
            node.Accept(this);

            // if we need parentheses, add the closing and restore whatever noin state we had
            if (needsParens)
            {
                Output(')');
            }

            // make SURE the start flag is reset
            m_startOfStatement = false;
        }

        private static bool shouldWrapArgumentListInParens(FunctionObject node)
        {
            // we need to wrap the parens for all function object other than arrow functions,
            // and for arrow functions where there are zero or more than one parameter.
            // if it IS an arrow function with a single parameter, we still want to wrap the
            // parameter in parens if it's a rest argument or a destructuring array.
            if (node.FunctionType != FunctionType.ArrowFunction
                || node.ParameterDeclarations.Count != 1)
            {
                return true;
            }

            var declaration = node.ParameterDeclarations[0] as ParameterDeclaration;
            return declaration == null
                || declaration.HasRest
                || declaration.Binding is ArrayLiteral;
        }

        /// <summary>
        /// Output everything for a function except the initial keyword
        /// </summary>
        /// <param name="node"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void OutputFunctionArgsAndBody(FunctionObject node)
        {
            if (node != null)
            {
                if (node.ParameterDeclarations != null)
                {
                    Indent();

                    bool wrapInParens = shouldWrapArgumentListInParens(node);

                    if (wrapInParens)
                    {
                        m_startOfStatement = false;
                        OutputPossibleLineBreak('(');
                        MarkSegment(node, null, node.ParameterDeclarations.Context);
                    }

                    AstNode paramDecl = null;
                    for (var ndx = 0; ndx < node.ParameterDeclarations.Count; ++ndx)
                    {
                        if (ndx > 0)
                        {
                            OutputPossibleLineBreak(',');
                            MarkSegment(node, null, paramDecl.IfNotNull(p => p.TerminatingContext) ?? node.ParameterDeclarations.Context);

                            if (m_settings.OutputMode == OutputMode.MultipleLines)
                            {
                                OutputPossibleLineBreak(' ');
                            }
                        }

                        paramDecl = node.ParameterDeclarations[ndx];
                        if (paramDecl != null)
                        {
                            paramDecl.Accept(this);
                        }
                    }

                    Unindent();
                    if (wrapInParens)
                    {
                        OutputPossibleLineBreak(')');
                        MarkSegment(node, null, node.ParameterDeclarations.Context);
                    }
                }
                else if (node.FunctionType == FunctionType.ArrowFunction)
                {
                    // empty arrow function parameters need the empty parentheses
                    OutputPossibleLineBreak('(');
                    OutputPossibleLineBreak(')');
                    m_startOfStatement = false;
                }

                if (node.FunctionType == FunctionType.ArrowFunction)
                {
                    if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }

                    Output(OperatorString(JSToken.ArrowFunction));
                    if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }
                }

                if (node.Body == null || node.Body.Count == 0)
                {
                    Output("{}");
                    MarkSegment(node, null, node.Body.IfNotNull(b => b.Context));
                    BreakLine(false);
                }
                else if (node.FunctionType == FunctionType.ArrowFunction
                    && node.Body.Count == 1
                    && node.Body.IsConcise)
                {
                    // the arrow function body has only one "statement" and it's not a return.
                    // assume it's a concise expression body and just output it
                    var body = node.Body[0];
                    var requiresExplicitReturn = body is ObjectLiteral || body is CommaExpression;

                    if (requiresExplicitReturn)
                    {
                        Output("(");
                    }
                    node.Body[0].Accept(this);
                    if (requiresExplicitReturn)
                    {
                        Output(")");
                    }
                }
                else
                {
                    if (node.FunctionType == FunctionType.ArrowFunction)
                    {
                        Indent();
                    }

                    if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                        || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && node.Body.BraceOnNewLine))
                    {
                        NewLine();
                    }
                    else if (m_settings.OutputMode == OutputMode.MultipleLines)
                    {
                        OutputPossibleLineBreak(' ');
                    }

                    node.Body.Accept(this);

                    if (node.FunctionType == FunctionType.ArrowFunction)
                    {
                        Unindent();
                    }
                }
            }
        }

        /// <summary>
        /// outputs a semicolon for an empty block, just the statement for a single-statement block,
        /// and recurses to the Block visitor for mutiple-statement blocks
        /// </summary>
        /// <param name="block">block to output</param>
        private void OutputBlock(BlockStatement block)
        {
            if (block != null && block.ForceBraces)
            {
                // always output the braces
                OutputBlockWithBraces(block);
            }
            else if (block == null || block.Count == 0)
            {
                // semicolon-replacement cannot generate an empty statement
                OutputPossibleLineBreak(';');
                MarkSegment(block, null, block.IfNotNull(b => b.Context));
            }
            else if (block.Count == 1)
            {
                Indent();
                NewLine();
                if (block[0] is ImportantComment)
                {
                    // not a REAL statement, so follow the comment with a semicolon to
                    // be the actual statement for this block.
                    block[0].Accept(this);
                    OutputPossibleLineBreak(';');
                    MarkSegment(block, null, block.Context);
                }
                else
                {
                    m_startOfStatement = true;
                    block[0].Accept(this);
                }
                Unindent();
            }
            else
            {
                // always output the braces
                OutputBlockWithBraces(block);
            }
        }

        private void OutputBlockWithBraces(BlockStatement block)
        {
            if (m_settings.BlocksStartOnSameLine == BlockStart.NewLine
                || (m_settings.BlocksStartOnSameLine == BlockStart.UseSource && block.BraceOnNewLine))
            {
                NewLine();
            }
            else if (m_settings.OutputMode == OutputMode.MultipleLines)
            {
                OutputPossibleLineBreak(' ');
            }

            block.Accept(this);
        }

        private string InlineSafeString(string text)
        {
            if (m_settings.InlineSafeStrings)
            {
                var limit = text.Length - 1;

                var xmlOpen  = false;
                var datClose = false;

                for (var i = 0; i < limit; i++)
                {
                    var ch = text[i];

                    if ((ch == '<') && (text[i + 1] == '/'))
                    {
                        xmlOpen = true;
                    }

                    if ((ch == ']') && (text[i + 1] == ']'))
                    {
                        datClose = true;
                    }
                }

                // if there are ANY potential XML closing tags, which might confuse the browser
                // as to where the end of the inline script really is. Go conservative; the specs
                // say </ should be escaped, even though most browsers are smart enough to look for
                // </script. Also escape any XML CDATA closing tags.
                if (xmlOpen)
                {
                    // replace all of them with an escaped version so a text-compare won't match
                    text = text.Replace("</", @"<\/");
                }

                // if there are ANY closing CDATA strings...
                if (datClose)
                {
                    // replace all of them with an escaped version so a text-compare won't match
                    text = text.Replace("]]>", @"]\]>");
                }
            }

            return text;
        }

        #endregion

        #region numeric formatting methods

        public static string NormalizeNumber(double numericValue, SourceContext originalContext)
        {
            // numerics are doubles in JavaScript, so force it now as a shortcut
            if (double.IsNaN(numericValue) || double.IsInfinity(numericValue))
            {
                // weird number -- just return the original source code as-is. 
                if (originalContext != null && !string.IsNullOrEmpty(originalContext.Code)
                    && !originalContext.Document.IsGenerated)
                {
                    return originalContext.Code;
                }

                // Hmmm... don't have an original source. 
                // Must be generated. Just generate the proper JS literal.
                //
                // DANGER! If we just output NaN and Infinity and -Infinity blindly, that assumes
                // that there aren't any local variables in this scope chain with that
                // name, and we're pulling the GLOBAL properties. Might want to use properties
                // on the Number object -- which, of course, assumes that Number doesn't
                // resolve to a local variable...
                string objectName = double.IsNaN(numericValue) ? "NaN" : "Infinity";

                // get the enclosing lexical environment
                /*var enclosingScope = constant.EnclosingLexicalEnvironment;
                if (enclosingScope != null)
                {
                    var reference = enclosingScope.GetIdentifierReference(objectName, null);
                    if (reference.Category != BindingCategory.Predefined)
                    {
                        // NaN/Infinity didn't resolve to the global predefined values!
                        // see if Number does
                        reference = enclosingScope.GetIdentifierReference("Number", null);
                        if (reference.Category == BindingCategory.Predefined)
                        {
                            // use the properties off this object. Not very compact, but accurate.
                            // I don't think there will be any precedence problems with these constructs --
                            // the member-dot operator is pretty high on the precedence scale.
                            if (double.IsPositiveInfinity(doubleValue))
                            {
                                return "Number.POSITIVE_INFINITY";
                            }
                            if (double.IsNegativeInfinity(doubleValue))
                            {
                                return "Number.NEGATIVE_INFINITY";
                            }
                            return "Number.NaN";
                        }
                        else
                        {
                            // that doesn't resolve to the global Number object, either!
                            // well, extreme circumstances. Let's use literals to generate those values.
                            if (double.IsPositiveInfinity(doubleValue))
                            {
                                // 1 divided by zero is +Infinity
                                return "(1/0)";
                            }
                            if (double.IsNegativeInfinity(doubleValue))
                            {
                                // 1 divided by negative zero is -Infinity
                                return "(1/-0)";
                            }
                            // the unary plus converts to a number, and "x" will generate NaN
                            return "(+'x')";
                        }
                    }
                }*/

                // we're good to go -- just return the name because it will resolve to the
                // global properties (make a special case for negative infinity)
                return double.IsNegativeInfinity(numericValue) ? "-Infinity" : objectName;
            }
            else if (numericValue == 0)
            {
                // special case zero because we don't need to go through all those
                // gyrations to get a "0" -- and because negative zero is different
                // than a positive zero
                return 1 / numericValue < 0 ? "-0" : "0";
            }
            else
            {
                // normal string representations
                string normal = GetSmallestRep(numericValue.ToStringInvariant("R"));

                // if this is an integer (no decimal portion)....
                if (Math.Floor(numericValue) == numericValue)
                {
                    // then convert to hex and see if it's smaller.
                    // only really big numbers might be smaller in hex.
                    string hex = NormalOrHexIfSmaller(numericValue, normal);
                    if (hex.Length < normal.Length)
                    {
                        normal = hex;
                    }
                }
                return normal;
            }
        }

        private static string GetSmallestRep(string number)
        {
            var len = number.Length;

            // Quick check avoid using regular expression
            if (len <= 2)
            {
                return number;
            }

            if (number.IndexOfAny(DecimalOrExponentChars) < 0)
            {
                // integer
                var zeros = 0;
                while ((zeros < len) && (number[len - zeros - 1] == '0'))
                {
                    zeros++;
                }

                if (zeros >= 3)
                {
                    return number.Substring(0, len - zeros) + s_exponents[zeros];
                }
                else
                {
                    return number;
                }
            }

            return GetSmallestRepReg(number);
        }

        private static string GetSmallestRepReg(string number)
        {
            var match = CommonData.DecimalFormat.Match(number);
            if (match.Success)
            {
                string mantissa = match.Result("${man}");
                if (string.IsNullOrEmpty(match.Result("${exp}")))
                {
                    if (string.IsNullOrEmpty(mantissa))
                    {
                        // no decimal portion
                        if (string.IsNullOrEmpty(match.Result("${sig}")))
                        {
                            // no non-zero digits in the magnitude either -- must be a zero
                            number = match.Result("${neg}") + "0";
                        }
                        else
                        {
                            // see if there are trailing zeros
                            // that we can use e-notation to make smaller
                            int numZeros = match.Result("${zer}").Length;
                            if (numZeros > 2)
                            {
                                number = match.Result("${neg}") + match.Result("${sig}")
                                    + 'e' + numZeros.ToStringInvariant();
                            }
                        }
                    }
                    else
                    {
                        // there is a decimal portion. Put it back together
                        // with the bare-minimum stuff -- no plus-sign, no leading magnitude zeros,
                        // no trailing mantissa zeros. A zero magnitude won't show up, either.
                        number = match.Result("${neg}") + match.Result("${mag}") + '.' + mantissa;
                    }
                }
                else if (string.IsNullOrEmpty(mantissa))
                {
                    // there is an exponent, but no significant mantissa
                    number = match.Result("${neg}") + match.Result("${mag}")
                        + "e" + match.Result("${eng}") + match.Result("${pow}");
                }
                else
                {
                    // there is an exponent and a significant mantissa
                    // we want to see if we can eliminate it and save some bytes

                    // get the integer value of the exponent
                    int exponent;
                    if ((match.Result("${eng}") + match.Result("${pow}")).TryParseIntInvariant(NumberStyles.Integer, out exponent))
                    {
                        // slap the mantissa directly to the magnitude without a decimal point.
                        // we'll subtract the number of characters we just added to the magnitude from
                        // the exponent
                        number = match.Result("${neg}") + match.Result("${mag}") + mantissa
                            + 'e' + (exponent - mantissa.Length).ToStringInvariant();
                    }
                    else
                    {
                        // should n't get here, but it we do, go with what we have
                        number = match.Result("${neg}") + match.Result("${mag}") + '.' + mantissa
                            + 'e' + match.Result("${eng}") + match.Result("${pow}");
                    }
                }
            }
            return number;
        }

        private static string NormalOrHexIfSmaller(double doubleValue, string normal)
        {
            // keep track of the maximum number of characters we can have in our
            // hexadecimal number before it'd be longer than the normal version.
            // subtract two characters for the 0x
            int maxValue = normal.Length - 2;

            int sign = Math.Sign(doubleValue);
            if (sign < 0)
            {
                // negate the value so it's positive
                doubleValue = -doubleValue;
                // subtract another character for the minus sign
                --maxValue;
            }

            // we don't want to get larger -- or even the same size, so we know
            // the maximum length is the length of the normal string less one
            char[] charArray = new char[normal.Length - 1];
            // point PAST the last character in the array because we will decrement
            // the position before we add a character. that way position will always
            // point to the first valid character in the array.
            int position = charArray.Length;

            while (maxValue > 0 && doubleValue > 0)
            {
                // get the right-most hex character
                int digit = (int)(doubleValue % 16);

                // if the digit is less than ten, then we want to add it to '0' to get the decimal character.
                // otherwise we want to add (digit - 10) to 'a' to get the alphabetic hex digit
                charArray[--position] = (char)((digit < 10 ? '0' : 'a' - 10) + digit);

                // next character
                doubleValue = Math.Floor(doubleValue / 16);
                --maxValue;
            }

            // if the max value is still greater than zero, then the hex value
            // will be shorter than the normal value and we want to go with it
            if (maxValue > 0)
            {
                // add the 0x prefix
                charArray[--position] = 'x';
                charArray[--position] = '0';

                // add the sign if negative
                if (sign < 0)
                {
                    charArray[--position] = '-';
                }

                // create a new string starting at the current position
                normal = new string(charArray, position, charArray.Length - position);
            }
            return normal;
        }

        #endregion

        #region string formatting methods

        public static string EscapeString(string text)
        {
            // the quote factor is a calculation based on the relative number of
            // double-quotes in the string in relation to single-quotes. If the factor is
            // less than zero, then there are more double-quotes than single-quotes and
            // we can save bytes by using single-quotes as the delimiter. If it's greater
            // than zero, then there are more single quotes than double-quotes and we should
            // use double-quotes for the delimiter. If it's exactly zero, then 
            // there are exactly the same number, so it doesn't matter which delimiter
            // we use. In that case, use double-quotes because I think it's easier to read.
            // More like other languages (C/C++, C#, Java) that way.
            var delimiter = QuoteFactor(text) < 0 ? "\'" : "\"";

            // we also don't want to build a new string builder object if we don't have to.
            // and we only need to if we end up escaping characters. 
            var rawStart = 0;
            string escapedText = string.Empty;
            StringBuilder sb = null;
            try
            {
                if (!string.IsNullOrEmpty(text))
                {
                    // check each character of the string
                    for (var index = 0; index < text.Length; ++index)
                    {
                        var ch = text[index];
                        switch (ch)
                        {
                            case '\'':
                            case '"':
                                // we only need to escape whichever one we chose as our delimiter
                                if (ch == delimiter[0])
                                {
                                    // need to escape instances of the delimiter character
                                    goto case '\\';
                                }

                                break;

                            case '\b':
                                // output "\b"
                                ch = 'b';
                                goto case '\\';

                            case '\t':
                                // output "\t"
                                ch = 't';
                                goto case '\\';

                            case '\n':
                                // output "\n"
                                ch = 'n';
                                goto case '\\';

                            case '\v':
                                // w3c-strict can encode this character as a \v escape. 
                                // BUT... IE<9 doesn't recognize that escape sequence,
                                // so encode is as hex for maximum compatibility.
                                // if the source actually had "\v" in it, it wouldn't been
                                // marked as having issues and not get encoded anyway.
                                goto default;

                            case '\f':
                                // output "\f"
                                ch = 'f';
                                goto case '\\';

                            case '\r':
                                // output "\r"
                                ch = 'r';
                                goto case '\\';

                            case '\\':
                                // we need to output an escape, so create the string builder
                                // if we haven't already
                                if (sb == null)
                                {
                                    sb = StringBuilderPool.Acquire();
                                }

                                // output the block of raw characters we have since the last time
                                if (rawStart < index)
                                {
                                    sb.Append(text, rawStart, index - rawStart);
                                }

                                // set raw start to the next character
                                rawStart = index + 1;

                                // output the escape character, then the escaped character
                                sb.Append('\\');
                                sb.Append(ch);
                                break;

                            case '\x2028':
                            case '\x2029':
                                // issue #14398 - unescaped, these characters (Unicode LineSeparator and ParagraphSeparator)
                                // would introduce a line-break in the string.  they ALWAYS need to be escaped, 
                                // no matter what output encoding we may use.
                                if (sb == null)
                                {
                                    sb = StringBuilderPool.Acquire();
                                }

                                // output the block of raw characters we have since the last time
                                if (rawStart < index)
                                {
                                    sb.Append(text.Substring(rawStart, index - rawStart));
                                }

                                // set raw start to the next character
                                rawStart = index + 1;

                                // output the escape character, a "u", then the four-digit escaped character
                                sb.Append(@"\u");
                                sb.Append(((int)ch).ToStringInvariant("x4"));
                                break;

                            default:
                                if (ch < ' ')
                                {
                                    // need to escape control codes that aren't handled
                                    // by the single-letter escape codes
                                    // create the string builder if we haven't already
                                    if (sb == null)
                                    {
                                        sb = StringBuilderPool.Acquire();
                                    }

                                    // output the block of raw characters we have since the last time
                                    if (rawStart < index)
                                    {
                                        sb.Append(text, rawStart, index - rawStart);
                                    }

                                    // set raw start to the next character
                                    rawStart = index + 1;

                                    // strict ECMA-262 does not support octal escapes, but octal will
                                    // crunch down a full character more here than hexadecimal. Plus, if we do
                                    // octal, we'll still need to escape these characters to hex for RexExp
                                    // constructor strings so they don't get confused with back references.
                                    // minifies smaller, but octal is too much trouble.
                                    int intValue = ch;
                                    //if (noOctalEscapes)
                                    {
                                        // output the hex escape sequence
                                        sb.Append(@"\x");
                                        sb.Append(intValue.ToStringInvariant("x2"));
                                    }
                                    //else
                                    //{
                                    //    // octal representation of 0 through 31 are \0 through \37
                                    //    sb.Append('\\');
                                    //    if (intValue < 8)
                                    //    {
                                    //        // single octal digit
                                    //        sb.Append(intValue.ToStringInvariant());
                                    //    }
                                    //    else
                                    //    {
                                    //        // two octal digits
                                    //        sb.Append((intValue / 8).ToStringInvariant());
                                    //        sb.Append((intValue % 8).ToStringInvariant());
                                    //    }
                                    //}
                                }

                                break;
                        }
                    }

                    if (sb != null)
                    {
                        // we had escapes; use the string builder
                        // but first make sure the last batch of raw text is output
                        if (rawStart < text.Length)
                        {
                            sb.Append(text.Substring(rawStart));
                        }

                        escapedText = sb.ToString();
                    }
                    else
                    {
                        // no escaped needed; just use the text as-is
                        escapedText = text;
                    }
                }
            }
            finally
            {
                sb.Release();
            }

            return delimiter + escapedText + delimiter;
        }

        /// <summary>
        /// Counts the number of double-quotes and single-quotes in a string
        /// and returns a numeric indicator for which one should be used as
        /// the string delimiter.
        /// </summary>
        /// <param name="text">string to test</param>
        /// <returns>less than zero use single-quotes, zero or more, use double-quotes</returns>
        private static int QuoteFactor(string text)
        {
            // determine the delimiter to use based on the quote factor.
            // a value less than zero means there are more double-quotes than single-quotes,
            // therefore we should use single-quotes for the delimiter.
            // otherwise there are more single-quotes than double-quotes (or equal values)
            // and it's okay to use double-quotes
            int quoteFactor = 0;
            if (!text.IsNullOrWhiteSpace())
            {
                for (int index = 0; index < text.Length; ++index)
                {
                    if (text[index] == '\'')
                    {
                        ++quoteFactor;
                    }
                    else if (text[index] == '"')
                    {
                        --quoteFactor;
                    }
                }
            }

            return quoteFactor;
        }

        #endregion

        #region Map file methods

        private object StartSymbol(AstNode node)
        {
            if (m_settings.SymbolsMap != null)
            {
                return m_settings.SymbolsMap.StartSymbol(node, m_lineCount, m_lineLength);
            }

            return null;
        }

        private void MarkSegment(AstNode node, string name, SourceContext context)
        {
            if (m_settings.SymbolsMap != null && node != null)
            {
                m_settings.SymbolsMap.MarkSegment(node, m_segmentStartLine, m_segmentStartColumn, name, context);
            }
        }

        private void EndSymbol(object symbol)
        {
            if (m_settings.SymbolsMap != null && symbol != null)
            {
                string parentFunction = null;
                if (m_functionStack.Count > 0)
                {
                    parentFunction = m_functionStack.Peek();
                }

                m_settings.SymbolsMap.EndSymbol(symbol, m_lineCount, m_lineLength, parentFunction);
            }
        }

        #endregion Map file methods

        #region context output position methods

        private void SetContextOutputPosition(SourceContext context)
        {
            if (context != null)
            {
                // segment start line will be zero-based, but we want to have a 1-based line number
                context.OutputLine = m_segmentStartLine + 1;
                context.OutputColumn = m_segmentStartColumn;
            }
        }

        private static void SetContextOutputPosition(SourceContext context, SourceContext fromContext)
        {
            if (context != null && fromContext != null)
            {
                context.OutputLine = fromContext.OutputLine;
                context.OutputColumn = fromContext.OutputColumn;
            }
        }

        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\OutputVisitor.cs(1904,59): error CS8370: Feature 'type pattern' is not available in C# 7.3. Please use language version 9.0 or greater.
######################################################################


######################################################################
Nr: 22 - MergeSequentialChecksRewriterR2
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ReorderScopeVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;

namespace NUglify.JavaScript.Visitors
{
    internal class ReorderScopeVisitor : TreeVisitor
    {
        // list of all function declarations found in this scope
        private List<FunctionObject> m_functionDeclarations;

        // list of all other functions found in this scope
        private List<FunctionObject> m_functionExpressions;

        // list of all modules found in this scope
        private List<ModuleDeclaration> m_moduleDeclarations;

        // all directive prologues we found BEYOND the initial grouping.
        // if we find any, it was probably because they were directive prologues
        // for modules that were batched together and no longer at the top, so
        // we will need to promote them to get them to the proper place.
        private List<DirectivePrologue> m_moduleDirectives;

        // list of all var statements found in this scope
        private List<VarDeclaration> m_varStatements;

        // whether we want to move var statements
        private bool m_moveVarStatements;

        // whether we want to move function declarations
        private bool m_moveFunctionDecls;

        // whether we want to combine adjacent var statements
        private bool m_combineAdjacentVars;

        // whether we are renaming locals
        //private bool m_localRenaming;

        // counter for whether we are inside a conditional-compilation construct.
        // we need to know this because we do NOT move function declarations that
        // are inside that construct (between @if and @end or inside a single
        // conditional comment).
        // encountering @if or /*@ increments it; *@/ or @end decrements it.
        private int m_conditionalCommentLevel;

        // global scope
        private GlobalScope m_globalScope;

        private ReorderScopeVisitor(JSParser parser)
        {
            // save the mods we care about
            var settings = parser.Settings;
            m_moveVarStatements = settings.ReorderScopeDeclarations && settings.IsModificationAllowed(TreeModifications.CombineVarStatementsToTopOfScope);
            m_moveFunctionDecls = settings.ReorderScopeDeclarations && settings.IsModificationAllowed(TreeModifications.MoveFunctionToTopOfScope);
            m_combineAdjacentVars = settings.IsModificationAllowed(TreeModifications.CombineVarStatements);
            //m_localRenaming = settings.LocalRenaming != LocalRenaming.KeepAll && settings.IsModificationAllowed(TreeModifications.LocalRenaming);

            m_globalScope = parser.GlobalScope;
        }

        public static void Apply(BlockStatement block, JSParser parser)
        {
            if (parser == null)
            {
                throw new ArgumentNullException("parser");
            }

            if (block != null)
            {
                // create a new instance of the visitor and apply it to the block
                var visitor = new ReorderScopeVisitor(parser);
                block.Accept(visitor);

                // if there were any module directive prologues we need to promote, do them first
                var insertAt = 0;
                if (visitor.m_moduleDirectives != null)
                {
                    foreach (var directivePrologue in visitor.m_moduleDirectives)
                    {
                        insertAt = RelocateDirectivePrologue(block, insertAt, directivePrologue);
                    }
                }

                // Make sure that we skip over any remaining comments and directive prologues.
                // we do NOT want to insert anything between the start of the scope and any directive prologues.            
                while (insertAt < block.Count
                    && (block[insertAt] is DirectivePrologue || block[insertAt] is ImportantComment))
                {
                    ++insertAt;
                }

                // first, we want to move all function declarations to the top of this block
                if (visitor.m_functionDeclarations != null)
                {
                    foreach (var funcDecl in visitor.m_functionDeclarations)
                    {
                        insertAt = RelocateFunction(block, insertAt, funcDecl);
                    }
                }

                // special case: if there is only one var statement in the entire scope,
                // then just leave it alone because we will only add bytes by moving it around,
                // or be byte-neutral at best (no initializers and not in a for-statement).
                if (visitor.m_varStatements != null && visitor.m_varStatements.Count > 1)
                {
                    // then we want to move all variable declarations after to the top (after the functions)
                    foreach (var varStatement in visitor.m_varStatements)
                    {
                        insertAt = RelocateVar(block, insertAt, varStatement);
                    }
                }

                // then we want to do the same thing for all child functions (declarations AND other)
                if (visitor.m_functionDeclarations != null)
                {
                    foreach (var funcDecl in visitor.m_functionDeclarations)
                    {
                        Apply(funcDecl.Body, parser);
                    }
                }

                if (visitor.m_functionExpressions != null)
                {
                    foreach (var funcExpr in visitor.m_functionExpressions)
                    {
                        Apply(funcExpr.Body, parser);
                    }
                }

                // and then recurse the modules
                if (visitor.m_moduleDeclarations != null)
                {
                    foreach (var moduleDecl in visitor.m_moduleDeclarations)
                    {
                        Apply(moduleDecl.Body, parser);
                    }
                }
            }
        }

        private static int RelocateDirectivePrologue(BlockStatement block, int insertAt, DirectivePrologue directivePrologue)
        {
            // skip over any important comments
            while (insertAt < block.Count && (block[insertAt] is ImportantComment))
            {
                ++insertAt;
            }

            // if the one we want to insert is already at this spot, then we're good to go
            if (block[insertAt] != directivePrologue)
            {
                // remove it from where it is right now and insert it into the proper location
                directivePrologue.Parent.ReplaceChild(directivePrologue, null);
                block.Insert(insertAt, directivePrologue);
            }

            // and move up to the next slot
            return ++insertAt;
        }

        private static int RelocateFunction(BlockStatement block, int insertAt, AstNode funcDecl)
        {
            // if this function declaration is being exported, then we need to work with the export
            // statement, not the function declaration.
            if (funcDecl.Parent is ExportStatement)
            {
                funcDecl = funcDecl.Parent;
            }

            if (block[insertAt] != funcDecl)
            {
                // technically function declarations can only be direct children of the program or a function block.
                // and since we are passing in such a block, the parent of the function declaration better be that
                // block. If it isn't, we don't want to move it because it's not in an allowed place, and different
                // browsers treat that situation differently. Some browsers would process such funcdecls as if
                // they were a direct child of the main block. Others will treat it like a function expression with
                // an external name, and only assign the function to the name if that line of code is actually
                // executed. So since there's a difference, just leave them as-is and only move valid funcdecls.
                if (funcDecl.Parent == block)
                {
                    // remove the function from it's parent, which will take it away from where it is right now.
                    funcDecl.Parent.ReplaceChild(funcDecl, null);

                    // now insert it into the block at the new location, incrementing the location so the next function
                    // will be inserted after it. It is important that they be in the same order as the source, or the semantics
                    // will change when there are functions with the same name.
                    block.Insert(insertAt++, funcDecl);
                }
            }
            else
            {
                // we're already in the right place. Just increment the pointer to move to the next position
                // for next time
                ++insertAt;
            }

            // return the new position
            return insertAt;
        }

        private static int RelocateVar(BlockStatement block, int insertAt, VarDeclaration varStatement)
        {
            var forInParent = varStatement.Parent as ForInStatement;
            if (forInParent != null)
            {
                insertAt = ReorderScopeVisitor.RelocateForInVar(block, insertAt, varStatement, forInParent);
            }
            else
            {
                // if the var statement is at the next position to insert, then we don't need
                // to do anything.
                if (block[insertAt] != varStatement)
                {
                    // check to see if the current position is a var and we are the NEXT statement.
                    // if that's the case, we don't need to break out the initializer, just append all the
                    // vardecls as-is to the current position.
                    ForStatement forStatement;
                    var existingVar = block[insertAt] as VarDeclaration;
                    if (existingVar != null && block[insertAt + 1] == varStatement)
                    {
                        // two var-s one right after the other.
                        // just append our vardecls to the insertion point, then delete our statement
                        existingVar.Append(varStatement);
                        block.RemoveAt(insertAt + 1);
                    }
                    else if (existingVar != null
                        && (forStatement = varStatement.Parent as ForStatement) != null
                        && forStatement.Initializer == varStatement
                        && forStatement == block[insertAt + 1])
                    {
                        // this var statement is the initializer of a for-statement, which is
                        // immediately after the var we would insert our vardecls into.
                        // rather than moving our vardecls into the outside var-statement, let's
                        // move the outside var-statement into our for-statement.
                        varStatement.InsertAt(0, existingVar);
                        block.RemoveAt(insertAt);
                    }
                    else
                    {
                        // iterate through the decls and count how many have initializers
                        var initializerCount = 0;
                        for (var ndx = 0; ndx < varStatement.Count; ++ndx)
                        {
                            // count the number of vardecls with initializers
                            if (varStatement[ndx].Initializer != null)
                            {
                                ++initializerCount;
                            }
                        }

                        // if there are more than two decls with initializers, then we won't actually
                        // be gaining anything by moving the var to the top. We'll get rid of the four
                        // bytes for the "var ", but we'll be adding two bytes for the name and comma
                        // because name=init will still need to remain behind.
                        if (initializerCount <= 2)
                        {
                            // first iterate through all the declarations in the var statement,
                            // constructing an expression statement that is made up of assignment
                            // operators for each of the declarations that have initializers (if any)
                            // and removing all the initializers
                            var assignments = new List<AstNode>();
                            for (var ndx = 0; ndx < varStatement.Count; ++ndx)
                            {
                                var varDecl = varStatement[ndx];
                                if (varDecl.Initializer != null)
                                {
                                    // hold on to the object so we don't lose it to the GC
                                    var initializer = varDecl.Initializer;

                                    // remove it from the vardecl
                                    varDecl.Initializer = null;

                                    var reference = BindingTransform.FromBinding(varDecl.Binding);
                                    if (varDecl.IsCCSpecialCase)
                                    {
                                        // we don't want to add the special-case to the binary operator class,
                                        // so just create a copy of the vardecl for this location, using a reference
                                        // for the "binding"
                                        assignments.Add(new VariableDeclaration(varDecl.Context)
                                            {
                                                Binding = reference,
                                                AssignContext = varDecl.AssignContext,
                                                Initializer = initializer,
                                                IsCCSpecialCase = true,
                                                UseCCOn = varDecl.UseCCOn,
                                                TerminatingContext = varDecl.TerminatingContext
                                            });
                                    }
                                    else
                                    {
                                        assignments.Add(new BinaryExpression(varDecl.Context)
                                            {
                                                Operand1 = reference,
                                                Operand2 = initializer,
                                                OperatorToken = JSToken.Assign,
                                                OperatorContext = varDecl.AssignContext
                                            });
                                    }
                                }

                                // if the vardecl we are moving isn't a binding pattern, we need to 
                                // break it down into a simple list of names.
                                if (!(varDecl.Binding is BindingIdentifier))
                                {
                                    // place the original vardecl with the first one
                                    var first = true;
                                    foreach (var declName in BindingsVisitor.Bindings(varDecl.Binding))
                                    {
                                        if (first)
                                        {
                                            varStatement[ndx] = new VariableDeclaration(declName.Context)
                                                {
                                                    Binding = new BindingIdentifier(declName.Context)
                                                    {
                                                        Name = declName.Name,
                                                        VariableField = declName.VariableField
                                                    }
                                                };
                                            first = false;
                                        }
                                        else
                                        {
                                            // otherwise we want to insert a new one at the current position + 1
                                            varStatement.InsertAt(++ndx, new VariableDeclaration(declName.Context)
                                                {
                                                    Binding = new BindingIdentifier(declName.Context)
                                                    {
                                                        Name = declName.Name,
                                                        VariableField = declName.VariableField
                                                    }
                                                });
                                        }
                                    }
                                }
                            }

                            // now if there were any initializers...
                            if (assignments.Count > 0)
                            {
                                // we want to create one big expression from all the assignments and replace the
                                // var statement with the assignment(s) expression. Start at position n=1 and create
                                // a binary operator of n-1 as the left, n as the right, and using a comma operator.
                                var expression = assignments[0];
                                for (var ndx = 1; ndx < assignments.Count; ++ndx)
                                {
                                    expression = CommaExpression.CombineWithComma(expression.Context.FlattenToStart(), expression, assignments[ndx]);
                                }

                                // replace the var with the expression.
                                // we still have a pointer to the var, so we can insert it back into the proper
                                // place next.
                                varStatement.Parent.ReplaceChild(varStatement, expression);
                            }
                            else
                            {
                                // no initializers.
                                // just remove the var statement altogether
                                varStatement.Parent.ReplaceChild(varStatement, null);
                            }

                            // if the statement at the insertion point is a var-statement already,
                            // then we just need to append our vardecls to it. Otherwise we'll insert our
                            // var statement at the right point
                            if (existingVar != null)
                            {
                                // append the varstatement we want to move to the existing var, which will
                                // transfer all the vardecls to it.
                                existingVar.Append(varStatement);
                            }
                            else
                            {
                                // move the var to the insert point, incrementing the position or next time
                                block.Insert(insertAt, varStatement);
                            }
                        }
                    }
                }
            }

            return insertAt;
        }

        private static int RelocateForInVar(BlockStatement block, int insertAt, VarDeclaration varStatement, ForInStatement forIn)
        {
            // there should only be one decl in the for-in var statement. There should not be any initializer.
            // If not, then ignore it
            VariableDeclaration varDecl;
            if (varStatement.Count == 1 && (varDecl = varStatement[0]).Initializer == null)
            {
                // if there are more than three names, then we don't want to move them
                var bindingNames = BindingsVisitor.Bindings(varDecl.Binding);
                //if (bindingNames.Count < 3)
                {
                    // replace the varStatement in the for-in with a reference version of the binding
                    forIn.Variable = BindingTransform.FromBinding(varDecl.Binding);

                    // if this is a simple binding identifier, then leave it as-is. Otherwise we
                    // need to flatten it for the move to the front of the scope.
                    if (!(varDecl.Binding is BindingIdentifier))
                    {
                        // then flatten all the name in the binding and add them to the 
                        var first = true;
                        foreach (var declName in bindingNames)
                        {
                            if (first)
                            {
                                varStatement[0] = new VariableDeclaration(declName.Context)
                                {
                                    Binding = new BindingIdentifier(declName.Context)
                                    {
                                        Name = declName.Name,
                                        VariableField = declName.VariableField 
                                    }
                                };
                                first = false;
                            }
                            else
                            {
                                // otherwise we want to insert a new one at the current position + 1
                                varStatement.Append(new VariableDeclaration(declName.Context)
                                {
                                    Binding = new BindingIdentifier(declName.Context)
                                    {
                                        Name = declName.Name,
                                        VariableField = declName.VariableField
                                    }
                                });
                            }
                        }
                    }

                    // then move the var statement to the front of the scope
                    // if the statement at the insertion point is a var-statement already,
                    // then we just need to append our vardecls to it. Otherwise we'll insert our
                    // var statement at the right point
                    var existingVar = block[insertAt] as VarDeclaration;
                    if (existingVar != null)
                    {
                        // append the varstatement we want to move to the existing var, which will
                        // transfer all the vardecls to it.
                        existingVar.Append(varStatement);
                    }
                    else
                    {
                        // insert it at the insert point
                        block.Insert(insertAt, varStatement);
                    }
                }
            }

            return insertAt;
        }

        // unnest any child blocks
        private static void UnnestBlocks(BlockStatement node)
        {
            // walk the list of items backwards -- if we come
            // to any blocks, unnest the block recursively. 
            // Remove any empty statements as well.
            // We walk backwards because we could be adding any number of statements 
            // and we don't want to have to modify the counter.
            for (int ndx = node.Count - 1; ndx >= 0; --ndx)
            {
                var nestedBlock = node[ndx] as BlockStatement;
                if (nestedBlock != null)
                {
                    // unnest recursively
                    UnnestBlocks(nestedBlock);

                    // if the block has a block scope, then we can't really unnest it
                    // without merging lexical scopes
                    if (!nestedBlock.HasOwnScope)
                    {
                        // remove the nested block
                        node.RemoveAt(ndx);

                        // then start adding the statements in the nested block to our own.
                        // go backwards so we can just keep using the same index
                        node.InsertRange(ndx, nestedBlock.Children);
                    }
                }
                else if (node[ndx] is EmptyStatement)
                {
                    // remove empty statements (lone semicolons)
                    node.RemoveAt(ndx);
                }
                else if (ndx > 0)
                {
                    // see if the previous node is a conditional-compilation comment, because
                    // we will also combine adjacent those
                    var previousComment = node[ndx - 1] as ConditionalCompilationComment;
                    if (previousComment != null)
                    {
                        ConditionalCompilationComment thisComment = node[ndx] as ConditionalCompilationComment;
                        if (thisComment != null)
                        {
                            // two adjacent conditional comments -- combine them into the first.
                            previousComment.Statements.Append(thisComment.Statements);

                            // and remove the second one (which is now a duplicate)
                            node.RemoveAt(ndx);
                        }
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(BlockStatement node)
        {
            if (node != null)
            {
                // there really is no point in nesting blocks that don't have any special scopes
                // attached to them. Unnest any now, before we start combining var statements.
                UnnestBlocks(node);

                // if we get here, we are going to want to optimize the curly-braces to eliminate
                // unneeded ones in all blocks except try/catch/finally. So make sure we reset the 
                // force-braces properties for all blocks whose parent isn't a try-statement.
                node.ForceBraces = node.Parent is TryStatement;

                if (m_combineAdjacentVars)
                {
                    // look at the statements in the block. 
                    // if there are multiple var statements adjacent to each other, combine them.
                    // walk BACKWARDS down the list because we'll be removing items when we encounter
                    // multiple vars, etc.
                    // we also don't need to check the first one, since there is nothing before it.
                    for (int ndx = node.Count - 1; ndx > 0; --ndx)
                    {
                        var previousDeclaration = node[ndx - 1] as Declaration;
                        if (previousDeclaration != null)
                        {
                            if (previousDeclaration.StatementToken == DeclarationType(node[ndx]))
                            {
                                // add the items in this VAR to the end of the previous
                                previousDeclaration.Append(node[ndx]);

                                // delete this item from the block
                                node.RemoveAt(ndx);
                            }
                        }
                        else
                        {
                            // if this node and hte previous node are both export declaration statements of the same type...
                            var previousExport = node[ndx - 1] as ExportStatement;
                            if (previousExport != null && previousExport.Count == 1 && previousExport.ModuleName.IsNullOrWhiteSpace())
                            {
                                var declarationType = DeclarationType(previousExport[0]);
                                if (declarationType != JSToken.None)
                                {
                                    var thisExport = node[ndx] as ExportStatement;
                                    if (thisExport != null && thisExport.Count == 1 && thisExport.ModuleName.IsNullOrWhiteSpace()
                                        && declarationType == DeclarationType(thisExport[0]))
                                    {
                                        // merge our specifiers into the previous declaration's specifiers
                                        // and remove this statement from the block
                                        ((Declaration)previousExport[0]).Append(thisExport[0]);
                                        node.RemoveAt(ndx);
                                    }
                                }
                            }
                        }
                    }
                }

                if (node.IsModule)
                {
                    // walk backwards until we find the last non-comment statement
                    var ndxLast = node.Count - 1;
                    while (ndxLast >= 0 && node[ndxLast] is ImportantComment)
                    {
                        --ndxLast;
                    }

                    // if the last non-comment statement isn't the first....
                    if (ndxLast > 0)
                    {
                        // check to see if the last statement is already a target export
                        var finalExport = IfTargetExport(node[ndxLast]);
                        var startIndex = node.Count - (finalExport == null ? 1 : 2);

                        // we're going to keep track of any export declarations we may have because
                        // we'll only move them if it makes sense.
                        var exportDeclarations = new List<ExportStatement>();

                        // walk backwards from the last to the first looking for export statements
                        // with no 'from' clause (those would be re-export statements) and specifiers
                        // as children (we don't want to count the export declaration statements yet.
                        for (var ndx = startIndex; ndx >= 0; --ndx)
                        {
                            // we are only interested in exports nodes that DON'T have a module name.
                            // those are re-exports, and we just want to leave them alone for now.
                            var exportNode = node[ndx] as ExportStatement;
                            if (exportNode != null && exportNode.ModuleName.IsNullOrWhiteSpace())
                            {
                                if (IfTargetExport(exportNode) != null)
                                {
                                    if (exportNode != finalExport)
                                    {
                                        // we have a target export statement
                                        if (finalExport != null)
                                        {
                                            // if we already have a final export, then we just need to prepend our specifiers to 
                                            // the existing export's specifiers and delete this one
                                            finalExport.Insert(0, exportNode);
                                            node.RemoveAt(ndx);
                                        }
                                        else
                                        {
                                            // we don't already have a final export, so just move this one to the end
                                            node.RemoveAt(ndx);
                                            node.Append(exportNode);
                                            finalExport = exportNode;
                                        }
                                    }
                                }
                                else if (exportNode.Count == 1)
                                {
                                    // it's not a target export node (one with specifiers), and it's not a re-export,
                                    // and it has only one child -- must be an export declaration statement. Save it for later.
                                    exportDeclarations.Add(exportNode);
                                }
                            }
                        }

                        // if we found any export declarations
                        if (exportDeclarations.Count > 0)
                        {
                            // we need to see if it's worth it to remove the export keyword from the declaration and
                            // add a new specifier to an existing export statement, or create a new one.
                        }
                    }
                }

                // recurse down the tree after we've combined the adjacent var statements
                base.Visit(node);
            }
        }

        private static JSToken DeclarationType(AstNode node)
        {
            var declaration = node as Declaration;
            if (declaration != null)
            {
                return declaration.StatementToken;
            }

            return JSToken.None;
        }

        //private static ImportExportSpecifier CreateSpecifierLookup(BindingIdentifier bindingIdentifier)
        //{
        //    // create the lookup
        //    var lookup = new Lookup(bindingIdentifier.Context)
        //        {
        //            Name = bindingIdentifier.Name,
        //            VariableField = bindingIdentifier.VariableField,
        //        };

        //    // add a new reference to the variable field. And since we are creating a
        //    // specifier for this field, we can now minify it if we wanted to.
        //    bindingIdentifier.VariableField.IfNotNull(v =>
        //        {
        //            v.References.Add(lookup);
        //            v.CanCrunch = true;
        //        });

        //    // create the specifier and return it
        //    return new ImportExportSpecifier(bindingIdentifier.Context)
        //        {
        //            LocalIdentifier = lookup
        //        };
        //}

        private static ExportStatement IfTargetExport(AstNode node)
        {
            var exportNode = node as ExportStatement;
            return (exportNode != null
                && exportNode.ModuleName.IsNullOrWhiteSpace()
                && exportNode.Count > 0
                && exportNode[0] is ImportExportSpecifier) ? exportNode : null;
        }

        public override void Visit(ConditionalCompilationComment node)
        {
            if (node != null && node.Statements != null && node.Statements.Count > 0)
            {
                // increment the conditional comment level, recurse (process all the
                // statements), then decrement the level when we are through.
                ++m_conditionalCommentLevel;
                base.Visit(node);
                --m_conditionalCommentLevel;
            }
        }

        public override void Visit(ConditionalCompilationIf node)
        {
            if (node != null)
            {
                // increment the conditional comment level and then recurse the condition
                ++m_conditionalCommentLevel;
                base.Visit(node);
            }
        }

        public override void Visit(ConditionalCompilationEnd node)
        {
            if (node != null)
            {
                // just decrement the level, because there's nothing to recurse
                --m_conditionalCommentLevel;
            }
        }

        public override void Visit(ConstantWrapper node)
        {
            // by default this node has nothing to do and no children to recurse.
            // but if this node's parent is a block, then this is an expression statement
            // consisting of a single string literal. Normally we would ignore these -- if
            // they occured at the top of the block they would be DirectivePrologues. So because
            // this exists, it must not be at the top. But we still want to check it for the nomunge
            // hints and respect them if that's what it is.
            if (node != null && node.Parent is BlockStatement)
            {
                // if this is a hint, process it as such.
                if (IsMinificationHint(node))
                {
                    // and then remove it. We can do that here, because blocks are processed
                    // in reverse order.
                    node.Parent.ReplaceChild(node, null);
                }
            }
        }

        public override void Visit(DirectivePrologue node)
        {
            if (node != null)
            {
                // if this is a minification hint, then process it now
                // and then remove it. Otherwise treat it as a directive prologue that
                // we need to preserve
                if (IsMinificationHint(node))
                {
                    node.Parent.ReplaceChild(node, null);
                }
                else
                {
                    // no need to call the base, just add it to the list
                    if (m_moduleDirectives == null)
                    {
                        m_moduleDirectives = new List<DirectivePrologue>();
                    }

                    m_moduleDirectives.Add(node);
                }
            }
        }

        public override void Visit(FunctionObject node)
        {
            if (node != null)
            {
                // if we are reordering ANYTHING, then we need to do the reordering on a scope level.
                // so if that's the case, we need to create a list of all the child functions and NOT
                // recurse at this point. Then we'll reorder, then we'll use the lists to recurse.
                // BUT if we are not reordering anything, no sense making the lists and recursing later.
                // if that's the case, we can just recurse now and not have to worry about anything later.
                if (m_moveVarStatements || m_moveFunctionDecls)
                {
                    // add the node to the appropriate list: either function expression or function declaration.
                    // assume if it's not a function declaration, it must be an expression since the other types
                    // are not declaration (getter, setter) and we want to treat declarations special.
                    // if the conditional comment level isn't zero, then something funky is going on with
                    // the conditional-compilation statements, and we don't want to move the declarations, so
                    // don't add them to the declaration list. But we still want to recurse them, so add them
                    // to the expression list (which get recursed but not moved).
                    if (node.FunctionType == FunctionType.Declaration && m_conditionalCommentLevel == 0)
                    {
                        if (m_functionDeclarations == null)
                        {
                            m_functionDeclarations = new List<FunctionObject>();
                        }

                        m_functionDeclarations.Add(node);
                    }
                    else
                    {
                        if (m_functionExpressions == null)
                        {
                            m_functionExpressions = new List<FunctionObject>();
                        }

                        m_functionExpressions.Add(node);
                    }

                    // BUT DO NOT RECURSE!!!!
                    // we only want the functions and variables in THIS scope, not child function scopes.
                    //base.Visit(node);
                }
                else
                {
                    // we're not reordering, so just recurse now to save the hassle
                    base.Visit(node);
                }
            }
        }

        public override void Visit(VarDeclaration node)
        {
            if (node != null)
            {
                // don't bother creating a list of var-statements if we're not going to move them.
                // and if we are inside a conditional-compilation comment level, then don't move them
                // either.
                // don't bother moving const-statements.
                if (m_moveVarStatements && m_conditionalCommentLevel == 0)
                {
                    if (m_varStatements == null)
                    {
                        m_varStatements = new List<VarDeclaration>();
                    }

                    // add the node to the list of variable declarations
                    m_varStatements.Add(node);
                }

                // and recurse
                base.Visit(node);
            }
        }

        public override void Visit(GroupingOperator node)
        {
            if (node != null)
            {
                // if the parent isn't null, we need to run some checks
                // to see if we can be removed for being superfluous.
                if (node.Parent != null)
                {
                    var deleteParens = false;
                    if (node.Operand == null)
                    {
                        // delete self - no operand make the parens superfluous
                        // TODO: or should we leave them to preserve the "error"?
                        deleteParens = true;
                    }
                    else if (node.Parent is BlockStatement)
                    {
                        // function expressions and object literals need to keep the parens 
                        // or they'll be mistaken for function delcarations and blocks, respectively.
                        // all others get axed.
                        if (!(node.Operand is FunctionObject) && !(node.Operand is ObjectLiteral))
                        {
                            // delete self
                            deleteParens = true;
                        }
                    }
                    else if (node.Parent is AstNodeList)
                    {
                        // keep the parens if the node is itself a comma-operator
                        // question: do we need to check for ANY comma-operators in the entire expression,
                        // or will precedence rules dictate that there will be parens lower down if this
                        // expression isn't a comma-operator?
                        var binOp = node.Operand as BinaryExpression;
                        if (binOp == null || binOp.OperatorToken != JSToken.Comma)
                        {
                            // delete self
                            deleteParens = true;
                        }
                    }
                    else if (node.Parent.IsExpression)
                    {
                        var targetPrecedence = node.Parent.Precedence;
                        var conditional = node.Parent as Conditional;
                        if (conditional != null)
                        {
                            // the conditional is weird in that the different parts need to be
                            // compared against different precedences, not the precedence of the
                            // conditional itself. The condition should be compared to logical-or,
                            // and the true/false expressions against assignment.
                            targetPrecedence = conditional.Condition == node
                                ? OperatorPrecedence.LogicalOr
                                : OperatorPrecedence.Assignment;
                        }
                        
                        if (targetPrecedence <= node.Operand.Precedence)
                        {
                            // if the target precedence is less than or equal to the 
                            // precedence of the operand, then the parens are superfluous.
                            deleteParens = true;
                        }
                    }
                    else
                    {
                        // delete self
                        deleteParens = true;
                    }

                    if (deleteParens)
                    {
                        // delete the parens by replacing the grouping opertor node
                        // with its own operand
                        node.Parent.ReplaceChild(node, node.Operand);
                    }
                }
                
                // always recurse the operand
                if (node.Operand != null)
                {
                    node.Operand.Accept(this);
                }
            }
        }

        public override void Visit(ModuleDeclaration node)
        {
            if (node != null)
            {
                if (node.Body != null)
                {
                    // the module is an inline declration. Add it to the list of modules so we will
                    // recurse them later, AFTER this current scope has already been taken care of.
                    // AND DON'T RECURSE NOW
                    if (m_moduleDeclarations == null)
                    {
                        m_moduleDeclarations = new List<ModuleDeclaration>();
                    }

                    m_moduleDeclarations.Add(node);

                }
            }
        }

        private bool IsMinificationHint(ConstantWrapper node)
        {
            var isHint = false;
            if (node.PrimitiveType == PrimitiveType.String)
            {
                // try splitting on commas and removing empty items
                var sections = node.ToString().Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var section in sections)
                {
                    // valid hints are:
                    //      name:nomunge    don't automatically rename the field defined in this scope named "name"
                    //                      if name is missing (colon is the first character) or "*", then don't rename ANY
                    //                      fields defined in the current scope.
                    var ndxColon = section.IndexOf(':');
                    if (ndxColon >= 0)
                    {
                        // make sure this is a "nomunge" hint. If it is, then the entire node is treated as a hint and
                        // will be removed from the AST.
                        if (string.Compare(section.Substring(ndxColon + 1).Trim(), "nomunge", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            // it is.
                            isHint = true;

                            // get the name that we don't want to munge. Null means all. Convert "*"
                            // to null.
                            var identifier = section.Substring(0, ndxColon).Trim();
                            if (string.IsNullOrEmpty(identifier) || string.CompareOrdinal(identifier, "*") == 0)
                            {
                                identifier = null;
                            }

                            // get the current scope and iterate over all the fields within it
                            // looking for just the ones that are defined here (outer is null)
                            var currentScope = node.EnclosingScope ?? m_globalScope;
                            foreach (var field in currentScope.NameTable.Values)
                            {
                                if (field.OuterField == null)
                                {
                                    // if the identifier is null or matches exactly, mark it as not crunchable
                                    if (identifier == null || string.CompareOrdinal(identifier, field.Name) == 0)
                                    {
                                        field.CanCrunch = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return isHint;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;

namespace NUglify.JavaScript.Visitors
{
    internal class ReorderScopeVisitor : TreeVisitor
    {
        // list of all function declarations found in this scope
        private List<FunctionObject> m_functionDeclarations;

        // list of all other functions found in this scope
        private List<FunctionObject> m_functionExpressions;

        // list of all modules found in this scope
        private List<ModuleDeclaration> m_moduleDeclarations;

        // all directive prologues we found BEYOND the initial grouping.
        // if we find any, it was probably because they were directive prologues
        // for modules that were batched together and no longer at the top, so
        // we will need to promote them to get them to the proper place.
        private List<DirectivePrologue> m_moduleDirectives;

        // list of all var statements found in this scope
        private List<VarDeclaration> m_varStatements;

        // whether we want to move var statements
        private bool m_moveVarStatements;

        // whether we want to move function declarations
        private bool m_moveFunctionDecls;

        // whether we want to combine adjacent var statements
        private bool m_combineAdjacentVars;

        // whether we are renaming locals
        //private bool m_localRenaming;

        // counter for whether we are inside a conditional-compilation construct.
        // we need to know this because we do NOT move function declarations that
        // are inside that construct (between @if and @end or inside a single
        // conditional comment).
        // encountering @if or /*@ increments it; *@/ or @end decrements it.
        private int m_conditionalCommentLevel;

        // global scope
        private GlobalScope m_globalScope;

        private ReorderScopeVisitor(JSParser parser)
        {
            // save the mods we care about
            var settings = parser.Settings;
            m_moveVarStatements = settings.ReorderScopeDeclarations && settings.IsModificationAllowed(TreeModifications.CombineVarStatementsToTopOfScope);
            m_moveFunctionDecls = settings.ReorderScopeDeclarations && settings.IsModificationAllowed(TreeModifications.MoveFunctionToTopOfScope);
            m_combineAdjacentVars = settings.IsModificationAllowed(TreeModifications.CombineVarStatements);
            //m_localRenaming = settings.LocalRenaming != LocalRenaming.KeepAll && settings.IsModificationAllowed(TreeModifications.LocalRenaming);

            m_globalScope = parser.GlobalScope;
        }

        public static void Apply(BlockStatement block, JSParser parser)
        {
            if (parser == null)
            {
                throw new ArgumentNullException("parser");
            }

            if (block != null)
            {
                // create a new instance of the visitor and apply it to the block
                var visitor = new ReorderScopeVisitor(parser);
                block.Accept(visitor);

                // if there were any module directive prologues we need to promote, do them first
                var insertAt = 0;
                if (visitor.m_moduleDirectives != null)
                {
                    foreach (var directivePrologue in visitor.m_moduleDirectives)
                    {
                        insertAt = RelocateDirectivePrologue(block, insertAt, directivePrologue);
                    }
                }

                // Make sure that we skip over any remaining comments and directive prologues.
                // we do NOT want to insert anything between the start of the scope and any directive prologues.            
                while (insertAt < block.Count
                    && (block[insertAt] is DirectivePrologue || block[insertAt] is ImportantComment))
                {
                    ++insertAt;
                }

                // first, we want to move all function declarations to the top of this block
                if (visitor.m_functionDeclarations != null)
                {
                    foreach (var funcDecl in visitor.m_functionDeclarations)
                    {
                        insertAt = RelocateFunction(block, insertAt, funcDecl);
                    }
                }

                // special case: if there is only one var statement in the entire scope,
                // then just leave it alone because we will only add bytes by moving it around,
                // or be byte-neutral at best (no initializers and not in a for-statement).
                if (visitor.m_varStatements != null && visitor.m_varStatements.Count > 1)
                {
                    // then we want to move all variable declarations after to the top (after the functions)
                    foreach (var varStatement in visitor.m_varStatements)
                    {
                        insertAt = RelocateVar(block, insertAt, varStatement);
                    }
                }

                // then we want to do the same thing for all child functions (declarations AND other)
                if (visitor.m_functionDeclarations != null)
                {
                    foreach (var funcDecl in visitor.m_functionDeclarations)
                    {
                        Apply(funcDecl.Body, parser);
                    }
                }

                if (visitor.m_functionExpressions != null)
                {
                    foreach (var funcExpr in visitor.m_functionExpressions)
                    {
                        Apply(funcExpr.Body, parser);
                    }
                }

                // and then recurse the modules
                if (visitor.m_moduleDeclarations != null)
                {
                    foreach (var moduleDecl in visitor.m_moduleDeclarations)
                    {
                        Apply(moduleDecl.Body, parser);
                    }
                }
            }
        }

        private static int RelocateDirectivePrologue(BlockStatement block, int insertAt, DirectivePrologue directivePrologue)
        {
            // skip over any important comments
            while (insertAt < block.Count && (block[insertAt] is ImportantComment))
            {
                ++insertAt;
            }

            // if the one we want to insert is already at this spot, then we're good to go
            if (block[insertAt] != directivePrologue)
            {
                // remove it from where it is right now and insert it into the proper location
                directivePrologue.Parent.ReplaceChild(directivePrologue, null);
                block.Insert(insertAt, directivePrologue);
            }

            // and move up to the next slot
            return ++insertAt;
        }

        private static int RelocateFunction(BlockStatement block, int insertAt, AstNode funcDecl)
        {
            // if this function declaration is being exported, then we need to work with the export
            // statement, not the function declaration.
            if (funcDecl.Parent is ExportStatement)
            {
                funcDecl = funcDecl.Parent;
            }

            if (block[insertAt] != funcDecl)
            {
                // technically function declarations can only be direct children of the program or a function block.
                // and since we are passing in such a block, the parent of the function declaration better be that
                // block. If it isn't, we don't want to move it because it's not in an allowed place, and different
                // browsers treat that situation differently. Some browsers would process such funcdecls as if
                // they were a direct child of the main block. Others will treat it like a function expression with
                // an external name, and only assign the function to the name if that line of code is actually
                // executed. So since there's a difference, just leave them as-is and only move valid funcdecls.
                if (funcDecl.Parent == block)
                {
                    // remove the function from it's parent, which will take it away from where it is right now.
                    funcDecl.Parent.ReplaceChild(funcDecl, null);

                    // now insert it into the block at the new location, incrementing the location so the next function
                    // will be inserted after it. It is important that they be in the same order as the source, or the semantics
                    // will change when there are functions with the same name.
                    block.Insert(insertAt++, funcDecl);
                }
            }
            else
            {
                // we're already in the right place. Just increment the pointer to move to the next position
                // for next time
                ++insertAt;
            }

            // return the new position
            return insertAt;
        }

        private static int RelocateVar(BlockStatement block, int insertAt, VarDeclaration varStatement)
        {
            var forInParent = varStatement.Parent as ForInStatement;
            if (forInParent != null)
            {
                insertAt = ReorderScopeVisitor.RelocateForInVar(block, insertAt, varStatement, forInParent);
            }
            else
            {
                // if the var statement is at the next position to insert, then we don't need
                // to do anything.
                if (block[insertAt] != varStatement)
                {
                    // check to see if the current position is a var and we are the NEXT statement.
                    // if that's the case, we don't need to break out the initializer, just append all the
                    // vardecls as-is to the current position.
                    ForStatement forStatement;
                    var existingVar = block[insertAt] as VarDeclaration;
                    if (existingVar != null && block[insertAt + 1] == varStatement)
                    {
                        // two var-s one right after the other.
                        // just append our vardecls to the insertion point, then delete our statement
                        existingVar.Append(varStatement);
                        block.RemoveAt(insertAt + 1);
                    }
                    else if (existingVar != null
                        && (forStatement = varStatement.Parent as ForStatement) != null
                        && forStatement.Initializer == varStatement
                        && forStatement == block[insertAt + 1])
                    {
                        // this var statement is the initializer of a for-statement, which is
                        // immediately after the var we would insert our vardecls into.
                        // rather than moving our vardecls into the outside var-statement, let's
                        // move the outside var-statement into our for-statement.
                        varStatement.InsertAt(0, existingVar);
                        block.RemoveAt(insertAt);
                    }
                    else
                    {
                        // iterate through the decls and count how many have initializers
                        var initializerCount = 0;
                        for (var ndx = 0; ndx < varStatement.Count; ++ndx)
                        {
                            // count the number of vardecls with initializers
                            if (varStatement[ndx].Initializer != null)
                            {
                                ++initializerCount;
                            }
                        }

                        // if there are more than two decls with initializers, then we won't actually
                        // be gaining anything by moving the var to the top. We'll get rid of the four
                        // bytes for the "var ", but we'll be adding two bytes for the name and comma
                        // because name=init will still need to remain behind.
                        if (initializerCount <= 2)
                        {
                            // first iterate through all the declarations in the var statement,
                            // constructing an expression statement that is made up of assignment
                            // operators for each of the declarations that have initializers (if any)
                            // and removing all the initializers
                            var assignments = new List<AstNode>();
                            for (var ndx = 0; ndx < varStatement.Count; ++ndx)
                            {
                                var varDecl = varStatement[ndx];
                                if (varDecl.Initializer != null)
                                {
                                    // hold on to the object so we don't lose it to the GC
                                    var initializer = varDecl.Initializer;

                                    // remove it from the vardecl
                                    varDecl.Initializer = null;

                                    var reference = BindingTransform.FromBinding(varDecl.Binding);
                                    if (varDecl.IsCCSpecialCase)
                                    {
                                        // we don't want to add the special-case to the binary operator class,
                                        // so just create a copy of the vardecl for this location, using a reference
                                        // for the "binding"
                                        assignments.Add(new VariableDeclaration(varDecl.Context)
                                            {
                                                Binding = reference,
                                                AssignContext = varDecl.AssignContext,
                                                Initializer = initializer,
                                                IsCCSpecialCase = true,
                                                UseCCOn = varDecl.UseCCOn,
                                                TerminatingContext = varDecl.TerminatingContext
                                            });
                                    }
                                    else
                                    {
                                        assignments.Add(new BinaryExpression(varDecl.Context)
                                            {
                                                Operand1 = reference,
                                                Operand2 = initializer,
                                                OperatorToken = JSToken.Assign,
                                                OperatorContext = varDecl.AssignContext
                                            });
                                    }
                                }

                                // if the vardecl we are moving isn't a binding pattern, we need to 
                                // break it down into a simple list of names.
                                if (!(varDecl.Binding is BindingIdentifier))
                                {
                                    // place the original vardecl with the first one
                                    var first = true;
                                    foreach (var declName in BindingsVisitor.Bindings(varDecl.Binding))
                                    {
                                        if (first)
                                        {
                                            varStatement[ndx] = new VariableDeclaration(declName.Context)
                                                {
                                                    Binding = new BindingIdentifier(declName.Context)
                                                    {
                                                        Name = declName.Name,
                                                        VariableField = declName.VariableField
                                                    }
                                                };
                                            first = false;
                                        }
                                        else
                                        {
                                            // otherwise we want to insert a new one at the current position + 1
                                            varStatement.InsertAt(++ndx, new VariableDeclaration(declName.Context)
                                                {
                                                    Binding = new BindingIdentifier(declName.Context)
                                                    {
                                                        Name = declName.Name,
                                                        VariableField = declName.VariableField
                                                    }
                                                });
                                        }
                                    }
                                }
                            }

                            // now if there were any initializers...
                            if (assignments.Count > 0)
                            {
                                // we want to create one big expression from all the assignments and replace the
                                // var statement with the assignment(s) expression. Start at position n=1 and create
                                // a binary operator of n-1 as the left, n as the right, and using a comma operator.
                                var expression = assignments[0];
                                for (var ndx = 1; ndx < assignments.Count; ++ndx)
                                {
                                    expression = CommaExpression.CombineWithComma(expression.Context.FlattenToStart(), expression, assignments[ndx]);
                                }

                                // replace the var with the expression.
                                // we still have a pointer to the var, so we can insert it back into the proper
                                // place next.
                                varStatement.Parent.ReplaceChild(varStatement, expression);
                            }
                            else
                            {
                                // no initializers.
                                // just remove the var statement altogether
                                varStatement.Parent.ReplaceChild(varStatement, null);
                            }

                            // if the statement at the insertion point is a var-statement already,
                            // then we just need to append our vardecls to it. Otherwise we'll insert our
                            // var statement at the right point
                            if (existingVar != null)
                            {
                                // append the varstatement we want to move to the existing var, which will
                                // transfer all the vardecls to it.
                                existingVar.Append(varStatement);
                            }
                            else
                            {
                                // move the var to the insert point, incrementing the position or next time
                                block.Insert(insertAt, varStatement);
                            }
                        }
                    }
                }
            }

            return insertAt;
        }

        private static int RelocateForInVar(BlockStatement block, int insertAt, VarDeclaration varStatement, ForInStatement forIn)
        {
            // there should only be one decl in the for-in var statement. There should not be any initializer.
            // If not, then ignore it
            VariableDeclaration varDecl;
            if (varStatement.Count == 1 && (varDecl = varStatement[0]).Initializer == null)
            {
                // if there are more than three names, then we don't want to move them
                var bindingNames = BindingsVisitor.Bindings(varDecl.Binding);
                //if (bindingNames.Count < 3)
                {
                    // replace the varStatement in the for-in with a reference version of the binding
                    forIn.Variable = BindingTransform.FromBinding(varDecl.Binding);

                    // if this is a simple binding identifier, then leave it as-is. Otherwise we
                    // need to flatten it for the move to the front of the scope.
                    if (!(varDecl.Binding is BindingIdentifier))
                    {
                        // then flatten all the name in the binding and add them to the 
                        var first = true;
                        foreach (var declName in bindingNames)
                        {
                            if (first)
                            {
                                varStatement[0] = new VariableDeclaration(declName.Context)
                                {
                                    Binding = new BindingIdentifier(declName.Context)
                                    {
                                        Name = declName.Name,
                                        VariableField = declName.VariableField 
                                    }
                                };
                                first = false;
                            }
                            else
                            {
                                // otherwise we want to insert a new one at the current position + 1
                                varStatement.Append(new VariableDeclaration(declName.Context)
                                {
                                    Binding = new BindingIdentifier(declName.Context)
                                    {
                                        Name = declName.Name,
                                        VariableField = declName.VariableField
                                    }
                                });
                            }
                        }
                    }

                    // then move the var statement to the front of the scope
                    // if the statement at the insertion point is a var-statement already,
                    // then we just need to append our vardecls to it. Otherwise we'll insert our
                    // var statement at the right point
                    var existingVar = block[insertAt] as VarDeclaration;
                    if (existingVar != null)
                    {
                        // append the varstatement we want to move to the existing var, which will
                        // transfer all the vardecls to it.
                        existingVar.Append(varStatement);
                    }
                    else
                    {
                        // insert it at the insert point
                        block.Insert(insertAt, varStatement);
                    }
                }
            }

            return insertAt;
        }

        // unnest any child blocks
        private static void UnnestBlocks(BlockStatement node)
        {
            // walk the list of items backwards -- if we come
            // to any blocks, unnest the block recursively. 
            // Remove any empty statements as well.
            // We walk backwards because we could be adding any number of statements 
            // and we don't want to have to modify the counter.
            for (int ndx = node.Count - 1; ndx >= 0; --ndx)
            {
                var nestedBlock = node[ndx] as BlockStatement;
                if (nestedBlock != null)
                {
                    // unnest recursively
                    UnnestBlocks(nestedBlock);

                    // if the block has a block scope, then we can't really unnest it
                    // without merging lexical scopes
                    if (!nestedBlock.HasOwnScope)
                    {
                        // remove the nested block
                        node.RemoveAt(ndx);

                        // then start adding the statements in the nested block to our own.
                        // go backwards so we can just keep using the same index
                        node.InsertRange(ndx, nestedBlock.Children);
                    }
                }
                else if (node[ndx] is EmptyStatement)
                {
                    // remove empty statements (lone semicolons)
                    node.RemoveAt(ndx);
                }
                else if (ndx > 0)
                {
                    // see if the previous node is a conditional-compilation comment, because
                    // we will also combine adjacent those
                    var previousComment = node[ndx - 1] as ConditionalCompilationComment;
                    if (previousComment != null)
                    {
                        ConditionalCompilationComment thisComment = node[ndx] as ConditionalCompilationComment;
                        if (thisComment != null)
                        {
                            // two adjacent conditional comments -- combine them into the first.
                            previousComment.Statements.Append(thisComment.Statements);

                            // and remove the second one (which is now a duplicate)
                            node.RemoveAt(ndx);
                        }
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(BlockStatement node)
        {
            if (node != null)
            {
                // there really is no point in nesting blocks that don't have any special scopes
                // attached to them. Unnest any now, before we start combining var statements.
                UnnestBlocks(node);

                // if we get here, we are going to want to optimize the curly-braces to eliminate
                // unneeded ones in all blocks except try/catch/finally. So make sure we reset the 
                // force-braces properties for all blocks whose parent isn't a try-statement.
                node.ForceBraces = node.Parent is TryStatement;

                if (m_combineAdjacentVars)
                {
                    // look at the statements in the block. 
                    // if there are multiple var statements adjacent to each other, combine them.
                    // walk BACKWARDS down the list because we'll be removing items when we encounter
                    // multiple vars, etc.
                    // we also don't need to check the first one, since there is nothing before it.
                    for (int ndx = node.Count - 1; ndx > 0; --ndx)
                    {
                        var previousDeclaration = node[ndx - 1] as Declaration;
                        if (previousDeclaration != null)
                        {
                            if (previousDeclaration.StatementToken == DeclarationType(node[ndx]))
                            {
                                // add the items in this VAR to the end of the previous
                                previousDeclaration.Append(node[ndx]);

                                // delete this item from the block
                                node.RemoveAt(ndx);
                            }
                        }
                        else
                        {
                            // if this node and hte previous node are both export declaration statements of the same type...
                            var previousExport = node[ndx - 1] as ExportStatement;
                            if (previousExport != null && previousExport.Count == 1 && previousExport.ModuleName.IsNullOrWhiteSpace())
                            {
                                var declarationType = DeclarationType(previousExport[0]);
                                if (declarationType != JSToken.None)
                                {
                                    var thisExport = node[ndx] as ExportStatement;
                                    if (thisExport != null && thisExport.Count == 1 && thisExport.ModuleName.IsNullOrWhiteSpace()
                                        && declarationType == DeclarationType(thisExport[0]))
                                    {
                                        // merge our specifiers into the previous declaration's specifiers
                                        // and remove this statement from the block
                                        ((Declaration)previousExport[0]).Append(thisExport[0]);
                                        node.RemoveAt(ndx);
                                    }
                                }
                            }
                        }
                    }
                }

                if (node.IsModule)
                {
                    // walk backwards until we find the last non-comment statement
                    var ndxLast = node.Count - 1;
                    while (ndxLast >= 0 && node[ndxLast] is ImportantComment)
                    {
                        --ndxLast;
                    }

                    // if the last non-comment statement isn't the first....
                    if (ndxLast > 0)
                    {
                        // check to see if the last statement is already a target export
                        var finalExport = IfTargetExport(node[ndxLast]);
                        var startIndex = node.Count - (finalExport == null ? 1 : 2);

                        // we're going to keep track of any export declarations we may have because
                        // we'll only move them if it makes sense.
                        var exportDeclarations = new List<ExportStatement>();

                        // walk backwards from the last to the first looking for export statements
                        // with no 'from' clause (those would be re-export statements) and specifiers
                        // as children (we don't want to count the export declaration statements yet.
                        for (var ndx = startIndex; ndx >= 0; --ndx)
                        {
                            // we are only interested in exports nodes that DON'T have a module name.
                            // those are re-exports, and we just want to leave them alone for now.
                            var exportNode = node[ndx] as ExportStatement;
                            if (exportNode != null && exportNode.ModuleName.IsNullOrWhiteSpace())
                            {
                                if (IfTargetExport(exportNode) != null)
                                {
                                    if (exportNode != finalExport)
                                    {
                                        // we have a target export statement
                                        if (finalExport != null)
                                        {
                                            // if we already have a final export, then we just need to prepend our specifiers to 
                                            // the existing export's specifiers and delete this one
                                            finalExport.Insert(0, exportNode);
                                            node.RemoveAt(ndx);
                                        }
                                        else
                                        {
                                            // we don't already have a final export, so just move this one to the end
                                            node.RemoveAt(ndx);
                                            node.Append(exportNode);
                                            finalExport = exportNode;
                                        }
                                    }
                                }
                                else if (exportNode.Count == 1)
                                {
                                    // it's not a target export node (one with specifiers), and it's not a re-export,
                                    // and it has only one child -- must be an export declaration statement. Save it for later.
                                    exportDeclarations.Add(exportNode);
                                }
                            }
                        }

                        // if we found any export declarations
                        if (exportDeclarations.Count > 0)
                        {
                            // we need to see if it's worth it to remove the export keyword from the declaration and
                            // add a new specifier to an existing export statement, or create a new one.
                        }
                    }
                }

                // recurse down the tree after we've combined the adjacent var statements
                base.Visit(node);
            }
        }

        private static JSToken DeclarationType(AstNode node)
        {
            var declaration = node as Declaration;
            if (declaration != null)
            {
                return declaration.StatementToken;
            }

            return JSToken.None;
        }

        //private static ImportExportSpecifier CreateSpecifierLookup(BindingIdentifier bindingIdentifier)
        //{
        //    // create the lookup
        //    var lookup = new Lookup(bindingIdentifier.Context)
        //        {
        //            Name = bindingIdentifier.Name,
        //            VariableField = bindingIdentifier.VariableField,
        //        };

        //    // add a new reference to the variable field. And since we are creating a
        //    // specifier for this field, we can now minify it if we wanted to.
        //    bindingIdentifier.VariableField.IfNotNull(v =>
        //        {
        //            v.References.Add(lookup);
        //            v.CanCrunch = true;
        //        });

        //    // create the specifier and return it
        //    return new ImportExportSpecifier(bindingIdentifier.Context)
        //        {
        //            LocalIdentifier = lookup
        //        };
        //}

        private static ExportStatement IfTargetExport(AstNode node)
        {
            var exportNode = node as ExportStatement;
            return (exportNode != null
                && exportNode.ModuleName.IsNullOrWhiteSpace()
                && exportNode.Count > 0
                && exportNode[0] is ImportExportSpecifier) ? exportNode : null;
        }

        public override void Visit(ConditionalCompilationComment node)
        {
            if (node?.Statements != null && node.Statements.Count > 0)
            {
                // increment the conditional comment level, recurse (process all the
                // statements), then decrement the level when we are through.
                ++m_conditionalCommentLevel;
                base.Visit(node);
                --m_conditionalCommentLevel;
            }
        }

        public override void Visit(ConditionalCompilationIf node)
        {
            if (node != null)
            {
                // increment the conditional comment level and then recurse the condition
                ++m_conditionalCommentLevel;
                base.Visit(node);
            }
        }

        public override void Visit(ConditionalCompilationEnd node)
        {
            if (node != null)
            {
                // just decrement the level, because there's nothing to recurse
                --m_conditionalCommentLevel;
            }
        }

        public override void Visit(ConstantWrapper node)
        {
            // by default this node has nothing to do and no children to recurse.
            // but if this node's parent is a block, then this is an expression statement
            // consisting of a single string literal. Normally we would ignore these -- if
            // they occured at the top of the block they would be DirectivePrologues. So because
            // this exists, it must not be at the top. But we still want to check it for the nomunge
            // hints and respect them if that's what it is.
            if (node?.Parent is BlockStatement)
            {
                // if this is a hint, process it as such.
                if (IsMinificationHint(node))
                {
                    // and then remove it. We can do that here, because blocks are processed
                    // in reverse order.
                    node.Parent.ReplaceChild(node, null);
                }
            }
        }

        public override void Visit(DirectivePrologue node)
        {
            if (node != null)
            {
                // if this is a minification hint, then process it now
                // and then remove it. Otherwise treat it as a directive prologue that
                // we need to preserve
                if (IsMinificationHint(node))
                {
                    node.Parent.ReplaceChild(node, null);
                }
                else
                {
                    // no need to call the base, just add it to the list
                    if (m_moduleDirectives == null)
                    {
                        m_moduleDirectives = new List<DirectivePrologue>();
                    }

                    m_moduleDirectives.Add(node);
                }
            }
        }

        public override void Visit(FunctionObject node)
        {
            if (node != null)
            {
                // if we are reordering ANYTHING, then we need to do the reordering on a scope level.
                // so if that's the case, we need to create a list of all the child functions and NOT
                // recurse at this point. Then we'll reorder, then we'll use the lists to recurse.
                // BUT if we are not reordering anything, no sense making the lists and recursing later.
                // if that's the case, we can just recurse now and not have to worry about anything later.
                if (m_moveVarStatements || m_moveFunctionDecls)
                {
                    // add the node to the appropriate list: either function expression or function declaration.
                    // assume if it's not a function declaration, it must be an expression since the other types
                    // are not declaration (getter, setter) and we want to treat declarations special.
                    // if the conditional comment level isn't zero, then something funky is going on with
                    // the conditional-compilation statements, and we don't want to move the declarations, so
                    // don't add them to the declaration list. But we still want to recurse them, so add them
                    // to the expression list (which get recursed but not moved).
                    if (node.FunctionType == FunctionType.Declaration && m_conditionalCommentLevel == 0)
                    {
                        if (m_functionDeclarations == null)
                        {
                            m_functionDeclarations = new List<FunctionObject>();
                        }

                        m_functionDeclarations.Add(node);
                    }
                    else
                    {
                        if (m_functionExpressions == null)
                        {
                            m_functionExpressions = new List<FunctionObject>();
                        }

                        m_functionExpressions.Add(node);
                    }

                    // BUT DO NOT RECURSE!!!!
                    // we only want the functions and variables in THIS scope, not child function scopes.
                    //base.Visit(node);
                }
                else
                {
                    // we're not reordering, so just recurse now to save the hassle
                    base.Visit(node);
                }
            }
        }

        public override void Visit(VarDeclaration node)
        {
            if (node != null)
            {
                // don't bother creating a list of var-statements if we're not going to move them.
                // and if we are inside a conditional-compilation comment level, then don't move them
                // either.
                // don't bother moving const-statements.
                if (m_moveVarStatements && m_conditionalCommentLevel == 0)
                {
                    if (m_varStatements == null)
                    {
                        m_varStatements = new List<VarDeclaration>();
                    }

                    // add the node to the list of variable declarations
                    m_varStatements.Add(node);
                }

                // and recurse
                base.Visit(node);
            }
        }

        public override void Visit(GroupingOperator node)
        {
            if (node != null)
            {
                // if the parent isn't null, we need to run some checks
                // to see if we can be removed for being superfluous.
                if (node.Parent != null)
                {
                    var deleteParens = false;
                    if (node.Operand == null)
                    {
                        // delete self - no operand make the parens superfluous
                        // TODO: or should we leave them to preserve the "error"?
                        deleteParens = true;
                    }
                    else if (node.Parent is BlockStatement)
                    {
                        // function expressions and object literals need to keep the parens 
                        // or they'll be mistaken for function delcarations and blocks, respectively.
                        // all others get axed.
                        if (!(node.Operand is FunctionObject) && !(node.Operand is ObjectLiteral))
                        {
                            // delete self
                            deleteParens = true;
                        }
                    }
                    else if (node.Parent is AstNodeList)
                    {
                        // keep the parens if the node is itself a comma-operator
                        // question: do we need to check for ANY comma-operators in the entire expression,
                        // or will precedence rules dictate that there will be parens lower down if this
                        // expression isn't a comma-operator?
                        var binOp = node.Operand as BinaryExpression;
                        if (binOp == null || binOp.OperatorToken != JSToken.Comma)
                        {
                            // delete self
                            deleteParens = true;
                        }
                    }
                    else if (node.Parent.IsExpression)
                    {
                        var targetPrecedence = node.Parent.Precedence;
                        var conditional = node.Parent as Conditional;
                        if (conditional != null)
                        {
                            // the conditional is weird in that the different parts need to be
                            // compared against different precedences, not the precedence of the
                            // conditional itself. The condition should be compared to logical-or,
                            // and the true/false expressions against assignment.
                            targetPrecedence = conditional.Condition == node
                                ? OperatorPrecedence.LogicalOr
                                : OperatorPrecedence.Assignment;
                        }
                        
                        if (targetPrecedence <= node.Operand.Precedence)
                        {
                            // if the target precedence is less than or equal to the 
                            // precedence of the operand, then the parens are superfluous.
                            deleteParens = true;
                        }
                    }
                    else
                    {
                        // delete self
                        deleteParens = true;
                    }

                    if (deleteParens)
                    {
                        // delete the parens by replacing the grouping opertor node
                        // with its own operand
                        node.Parent.ReplaceChild(node, node.Operand);
                    }
                }
                
                // always recurse the operand
                if (node.Operand != null)
                {
                    node.Operand.Accept(this);
                }
            }
        }

        public override void Visit(ModuleDeclaration node)
        {
            if (node != null)
            {
                if (node.Body != null)
                {
                    // the module is an inline declration. Add it to the list of modules so we will
                    // recurse them later, AFTER this current scope has already been taken care of.
                    // AND DON'T RECURSE NOW
                    if (m_moduleDeclarations == null)
                    {
                        m_moduleDeclarations = new List<ModuleDeclaration>();
                    }

                    m_moduleDeclarations.Add(node);

                }
            }
        }

        private bool IsMinificationHint(ConstantWrapper node)
        {
            var isHint = false;
            if (node.PrimitiveType == PrimitiveType.String)
            {
                // try splitting on commas and removing empty items
                var sections = node.ToString().Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var section in sections)
                {
                    // valid hints are:
                    //      name:nomunge    don't automatically rename the field defined in this scope named "name"
                    //                      if name is missing (colon is the first character) or "*", then don't rename ANY
                    //                      fields defined in the current scope.
                    var ndxColon = section.IndexOf(':');
                    if (ndxColon >= 0)
                    {
                        // make sure this is a "nomunge" hint. If it is, then the entire node is treated as a hint and
                        // will be removed from the AST.
                        if (string.Compare(section.Substring(ndxColon + 1).Trim(), "nomunge", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            // it is.
                            isHint = true;

                            // get the name that we don't want to munge. Null means all. Convert "*"
                            // to null.
                            var identifier = section.Substring(0, ndxColon).Trim();
                            if (string.IsNullOrEmpty(identifier) || string.CompareOrdinal(identifier, "*") == 0)
                            {
                                identifier = null;
                            }

                            // get the current scope and iterate over all the fields within it
                            // looking for just the ones that are defined here (outer is null)
                            var currentScope = node.EnclosingScope ?? m_globalScope;
                            foreach (var field in currentScope.NameTable.Values)
                            {
                                if (field.OuterField == null)
                                {
                                    // if the identifier is null or matches exactly, mark it as not crunchable
                                    if (identifier == null || string.CompareOrdinal(identifier, field.Name) == 0)
                                    {
                                        field.CanCrunch = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return isHint;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ReorderScopeVisitor.cs(741,33): error CS8370: Feature 'type pattern' is not available in C# 7.3. Please use language version 9.0 or greater.
######################################################################


######################################################################
Nr: 23 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ReorderScopeVisitor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;

namespace NUglify.JavaScript.Visitors
{
    internal class ReorderScopeVisitor : TreeVisitor
    {
        // list of all function declarations found in this scope
        private List<FunctionObject> m_functionDeclarations;

        // list of all other functions found in this scope
        private List<FunctionObject> m_functionExpressions;

        // list of all modules found in this scope
        private List<ModuleDeclaration> m_moduleDeclarations;

        // all directive prologues we found BEYOND the initial grouping.
        // if we find any, it was probably because they were directive prologues
        // for modules that were batched together and no longer at the top, so
        // we will need to promote them to get them to the proper place.
        private List<DirectivePrologue> m_moduleDirectives;

        // list of all var statements found in this scope
        private List<VarDeclaration> m_varStatements;

        // whether we want to move var statements
        private bool m_moveVarStatements;

        // whether we want to move function declarations
        private bool m_moveFunctionDecls;

        // whether we want to combine adjacent var statements
        private bool m_combineAdjacentVars;

        // whether we are renaming locals
        //private bool m_localRenaming;

        // counter for whether we are inside a conditional-compilation construct.
        // we need to know this because we do NOT move function declarations that
        // are inside that construct (between @if and @end or inside a single
        // conditional comment).
        // encountering @if or /*@ increments it; *@/ or @end decrements it.
        private int m_conditionalCommentLevel;

        // global scope
        private GlobalScope m_globalScope;

        private ReorderScopeVisitor(JSParser parser)
        {
            // save the mods we care about
            var settings = parser.Settings;
            m_moveVarStatements = settings.ReorderScopeDeclarations && settings.IsModificationAllowed(TreeModifications.CombineVarStatementsToTopOfScope);
            m_moveFunctionDecls = settings.ReorderScopeDeclarations && settings.IsModificationAllowed(TreeModifications.MoveFunctionToTopOfScope);
            m_combineAdjacentVars = settings.IsModificationAllowed(TreeModifications.CombineVarStatements);
            //m_localRenaming = settings.LocalRenaming != LocalRenaming.KeepAll && settings.IsModificationAllowed(TreeModifications.LocalRenaming);

            m_globalScope = parser.GlobalScope;
        }

        public static void Apply(BlockStatement block, JSParser parser)
        {
            if (parser == null)
            {
                throw new ArgumentNullException("parser");
            }

            if (block != null)
            {
                // create a new instance of the visitor and apply it to the block
                var visitor = new ReorderScopeVisitor(parser);
                block.Accept(visitor);

                // if there were any module directive prologues we need to promote, do them first
                var insertAt = 0;
                if (visitor.m_moduleDirectives != null)
                {
                    foreach (var directivePrologue in visitor.m_moduleDirectives)
                    {
                        insertAt = RelocateDirectivePrologue(block, insertAt, directivePrologue);
                    }
                }

                // Make sure that we skip over any remaining comments and directive prologues.
                // we do NOT want to insert anything between the start of the scope and any directive prologues.            
                while (insertAt < block.Count
                    && (block[insertAt] is DirectivePrologue || block[insertAt] is ImportantComment))
                {
                    ++insertAt;
                }

                // first, we want to move all function declarations to the top of this block
                if (visitor.m_functionDeclarations != null)
                {
                    foreach (var funcDecl in visitor.m_functionDeclarations)
                    {
                        insertAt = RelocateFunction(block, insertAt, funcDecl);
                    }
                }

                // special case: if there is only one var statement in the entire scope,
                // then just leave it alone because we will only add bytes by moving it around,
                // or be byte-neutral at best (no initializers and not in a for-statement).
                if (visitor.m_varStatements != null && visitor.m_varStatements.Count > 1)
                {
                    // then we want to move all variable declarations after to the top (after the functions)
                    foreach (var varStatement in visitor.m_varStatements)
                    {
                        insertAt = RelocateVar(block, insertAt, varStatement);
                    }
                }

                // then we want to do the same thing for all child functions (declarations AND other)
                if (visitor.m_functionDeclarations != null)
                {
                    foreach (var funcDecl in visitor.m_functionDeclarations)
                    {
                        Apply(funcDecl.Body, parser);
                    }
                }

                if (visitor.m_functionExpressions != null)
                {
                    foreach (var funcExpr in visitor.m_functionExpressions)
                    {
                        Apply(funcExpr.Body, parser);
                    }
                }

                // and then recurse the modules
                if (visitor.m_moduleDeclarations != null)
                {
                    foreach (var moduleDecl in visitor.m_moduleDeclarations)
                    {
                        Apply(moduleDecl.Body, parser);
                    }
                }
            }
        }

        private static int RelocateDirectivePrologue(BlockStatement block, int insertAt, DirectivePrologue directivePrologue)
        {
            // skip over any important comments
            while (insertAt < block.Count && (block[insertAt] is ImportantComment))
            {
                ++insertAt;
            }

            // if the one we want to insert is already at this spot, then we're good to go
            if (block[insertAt] != directivePrologue)
            {
                // remove it from where it is right now and insert it into the proper location
                directivePrologue.Parent.ReplaceChild(directivePrologue, null);
                block.Insert(insertAt, directivePrologue);
            }

            // and move up to the next slot
            return ++insertAt;
        }

        private static int RelocateFunction(BlockStatement block, int insertAt, AstNode funcDecl)
        {
            // if this function declaration is being exported, then we need to work with the export
            // statement, not the function declaration.
            if (funcDecl.Parent is ExportStatement)
            {
                funcDecl = funcDecl.Parent;
            }

            if (block[insertAt] != funcDecl)
            {
                // technically function declarations can only be direct children of the program or a function block.
                // and since we are passing in such a block, the parent of the function declaration better be that
                // block. If it isn't, we don't want to move it because it's not in an allowed place, and different
                // browsers treat that situation differently. Some browsers would process such funcdecls as if
                // they were a direct child of the main block. Others will treat it like a function expression with
                // an external name, and only assign the function to the name if that line of code is actually
                // executed. So since there's a difference, just leave them as-is and only move valid funcdecls.
                if (funcDecl.Parent == block)
                {
                    // remove the function from it's parent, which will take it away from where it is right now.
                    funcDecl.Parent.ReplaceChild(funcDecl, null);

                    // now insert it into the block at the new location, incrementing the location so the next function
                    // will be inserted after it. It is important that they be in the same order as the source, or the semantics
                    // will change when there are functions with the same name.
                    block.Insert(insertAt++, funcDecl);
                }
            }
            else
            {
                // we're already in the right place. Just increment the pointer to move to the next position
                // for next time
                ++insertAt;
            }

            // return the new position
            return insertAt;
        }

        private static int RelocateVar(BlockStatement block, int insertAt, VarDeclaration varStatement)
        {
            var forInParent = varStatement.Parent as ForInStatement;
            if (forInParent != null)
            {
                insertAt = ReorderScopeVisitor.RelocateForInVar(block, insertAt, varStatement, forInParent);
            }
            else
            {
                // if the var statement is at the next position to insert, then we don't need
                // to do anything.
                if (block[insertAt] != varStatement)
                {
                    // check to see if the current position is a var and we are the NEXT statement.
                    // if that's the case, we don't need to break out the initializer, just append all the
                    // vardecls as-is to the current position.
                    ForStatement forStatement;
                    var existingVar = block[insertAt] as VarDeclaration;
                    if (existingVar != null && block[insertAt + 1] == varStatement)
                    {
                        // two var-s one right after the other.
                        // just append our vardecls to the insertion point, then delete our statement
                        existingVar.Append(varStatement);
                        block.RemoveAt(insertAt + 1);
                    }
                    else if (existingVar != null
                        && (forStatement = varStatement.Parent as ForStatement) != null
                        && forStatement.Initializer == varStatement
                        && forStatement == block[insertAt + 1])
                    {
                        // this var statement is the initializer of a for-statement, which is
                        // immediately after the var we would insert our vardecls into.
                        // rather than moving our vardecls into the outside var-statement, let's
                        // move the outside var-statement into our for-statement.
                        varStatement.InsertAt(0, existingVar);
                        block.RemoveAt(insertAt);
                    }
                    else
                    {
                        // iterate through the decls and count how many have initializers
                        var initializerCount = 0;
                        for (var ndx = 0; ndx < varStatement.Count; ++ndx)
                        {
                            // count the number of vardecls with initializers
                            if (varStatement[ndx].Initializer != null)
                            {
                                ++initializerCount;
                            }
                        }

                        // if there are more than two decls with initializers, then we won't actually
                        // be gaining anything by moving the var to the top. We'll get rid of the four
                        // bytes for the "var ", but we'll be adding two bytes for the name and comma
                        // because name=init will still need to remain behind.
                        if (initializerCount <= 2)
                        {
                            // first iterate through all the declarations in the var statement,
                            // constructing an expression statement that is made up of assignment
                            // operators for each of the declarations that have initializers (if any)
                            // and removing all the initializers
                            var assignments = new List<AstNode>();
                            for (var ndx = 0; ndx < varStatement.Count; ++ndx)
                            {
                                var varDecl = varStatement[ndx];
                                if (varDecl.Initializer != null)
                                {
                                    // hold on to the object so we don't lose it to the GC
                                    var initializer = varDecl.Initializer;

                                    // remove it from the vardecl
                                    varDecl.Initializer = null;

                                    var reference = BindingTransform.FromBinding(varDecl.Binding);
                                    if (varDecl.IsCCSpecialCase)
                                    {
                                        // we don't want to add the special-case to the binary operator class,
                                        // so just create a copy of the vardecl for this location, using a reference
                                        // for the "binding"
                                        assignments.Add(new VariableDeclaration(varDecl.Context)
                                            {
                                                Binding = reference,
                                                AssignContext = varDecl.AssignContext,
                                                Initializer = initializer,
                                                IsCCSpecialCase = true,
                                                UseCCOn = varDecl.UseCCOn,
                                                TerminatingContext = varDecl.TerminatingContext
                                            });
                                    }
                                    else
                                    {
                                        assignments.Add(new BinaryExpression(varDecl.Context)
                                            {
                                                Operand1 = reference,
                                                Operand2 = initializer,
                                                OperatorToken = JSToken.Assign,
                                                OperatorContext = varDecl.AssignContext
                                            });
                                    }
                                }

                                // if the vardecl we are moving isn't a binding pattern, we need to 
                                // break it down into a simple list of names.
                                if (!(varDecl.Binding is BindingIdentifier))
                                {
                                    // place the original vardecl with the first one
                                    var first = true;
                                    foreach (var declName in BindingsVisitor.Bindings(varDecl.Binding))
                                    {
                                        if (first)
                                        {
                                            varStatement[ndx] = new VariableDeclaration(declName.Context)
                                                {
                                                    Binding = new BindingIdentifier(declName.Context)
                                                    {
                                                        Name = declName.Name,
                                                        VariableField = declName.VariableField
                                                    }
                                                };
                                            first = false;
                                        }
                                        else
                                        {
                                            // otherwise we want to insert a new one at the current position + 1
                                            varStatement.InsertAt(++ndx, new VariableDeclaration(declName.Context)
                                                {
                                                    Binding = new BindingIdentifier(declName.Context)
                                                    {
                                                        Name = declName.Name,
                                                        VariableField = declName.VariableField
                                                    }
                                                });
                                        }
                                    }
                                }
                            }

                            // now if there were any initializers...
                            if (assignments.Count > 0)
                            {
                                // we want to create one big expression from all the assignments and replace the
                                // var statement with the assignment(s) expression. Start at position n=1 and create
                                // a binary operator of n-1 as the left, n as the right, and using a comma operator.
                                var expression = assignments[0];
                                for (var ndx = 1; ndx < assignments.Count; ++ndx)
                                {
                                    expression = CommaExpression.CombineWithComma(expression.Context.FlattenToStart(), expression, assignments[ndx]);
                                }

                                // replace the var with the expression.
                                // we still have a pointer to the var, so we can insert it back into the proper
                                // place next.
                                varStatement.Parent.ReplaceChild(varStatement, expression);
                            }
                            else
                            {
                                // no initializers.
                                // just remove the var statement altogether
                                varStatement.Parent.ReplaceChild(varStatement, null);
                            }

                            // if the statement at the insertion point is a var-statement already,
                            // then we just need to append our vardecls to it. Otherwise we'll insert our
                            // var statement at the right point
                            if (existingVar != null)
                            {
                                // append the varstatement we want to move to the existing var, which will
                                // transfer all the vardecls to it.
                                existingVar.Append(varStatement);
                            }
                            else
                            {
                                // move the var to the insert point, incrementing the position or next time
                                block.Insert(insertAt, varStatement);
                            }
                        }
                    }
                }
            }

            return insertAt;
        }

        private static int RelocateForInVar(BlockStatement block, int insertAt, VarDeclaration varStatement, ForInStatement forIn)
        {
            // there should only be one decl in the for-in var statement. There should not be any initializer.
            // If not, then ignore it
            VariableDeclaration varDecl;
            if (varStatement.Count == 1 && (varDecl = varStatement[0]).Initializer == null)
            {
                // if there are more than three names, then we don't want to move them
                var bindingNames = BindingsVisitor.Bindings(varDecl.Binding);
                //if (bindingNames.Count < 3)
                {
                    // replace the varStatement in the for-in with a reference version of the binding
                    forIn.Variable = BindingTransform.FromBinding(varDecl.Binding);

                    // if this is a simple binding identifier, then leave it as-is. Otherwise we
                    // need to flatten it for the move to the front of the scope.
                    if (!(varDecl.Binding is BindingIdentifier))
                    {
                        // then flatten all the name in the binding and add them to the 
                        var first = true;
                        foreach (var declName in bindingNames)
                        {
                            if (first)
                            {
                                varStatement[0] = new VariableDeclaration(declName.Context)
                                {
                                    Binding = new BindingIdentifier(declName.Context)
                                    {
                                        Name = declName.Name,
                                        VariableField = declName.VariableField 
                                    }
                                };
                                first = false;
                            }
                            else
                            {
                                // otherwise we want to insert a new one at the current position + 1
                                varStatement.Append(new VariableDeclaration(declName.Context)
                                {
                                    Binding = new BindingIdentifier(declName.Context)
                                    {
                                        Name = declName.Name,
                                        VariableField = declName.VariableField
                                    }
                                });
                            }
                        }
                    }

                    // then move the var statement to the front of the scope
                    // if the statement at the insertion point is a var-statement already,
                    // then we just need to append our vardecls to it. Otherwise we'll insert our
                    // var statement at the right point
                    var existingVar = block[insertAt] as VarDeclaration;
                    if (existingVar != null)
                    {
                        // append the varstatement we want to move to the existing var, which will
                        // transfer all the vardecls to it.
                        existingVar.Append(varStatement);
                    }
                    else
                    {
                        // insert it at the insert point
                        block.Insert(insertAt, varStatement);
                    }
                }
            }

            return insertAt;
        }

        // unnest any child blocks
        private static void UnnestBlocks(BlockStatement node)
        {
            // walk the list of items backwards -- if we come
            // to any blocks, unnest the block recursively. 
            // Remove any empty statements as well.
            // We walk backwards because we could be adding any number of statements 
            // and we don't want to have to modify the counter.
            for (int ndx = node.Count - 1; ndx >= 0; --ndx)
            {
                var nestedBlock = node[ndx] as BlockStatement;
                if (nestedBlock != null)
                {
                    // unnest recursively
                    UnnestBlocks(nestedBlock);

                    // if the block has a block scope, then we can't really unnest it
                    // without merging lexical scopes
                    if (!nestedBlock.HasOwnScope)
                    {
                        // remove the nested block
                        node.RemoveAt(ndx);

                        // then start adding the statements in the nested block to our own.
                        // go backwards so we can just keep using the same index
                        node.InsertRange(ndx, nestedBlock.Children);
                    }
                }
                else if (node[ndx] is EmptyStatement)
                {
                    // remove empty statements (lone semicolons)
                    node.RemoveAt(ndx);
                }
                else if (ndx > 0)
                {
                    // see if the previous node is a conditional-compilation comment, because
                    // we will also combine adjacent those
                    var previousComment = node[ndx - 1] as ConditionalCompilationComment;
                    if (previousComment != null)
                    {
                        ConditionalCompilationComment thisComment = node[ndx] as ConditionalCompilationComment;
                        if (thisComment != null)
                        {
                            // two adjacent conditional comments -- combine them into the first.
                            previousComment.Statements.Append(thisComment.Statements);

                            // and remove the second one (which is now a duplicate)
                            node.RemoveAt(ndx);
                        }
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(BlockStatement node)
        {
            if (node != null)
            {
                // there really is no point in nesting blocks that don't have any special scopes
                // attached to them. Unnest any now, before we start combining var statements.
                UnnestBlocks(node);

                // if we get here, we are going to want to optimize the curly-braces to eliminate
                // unneeded ones in all blocks except try/catch/finally. So make sure we reset the 
                // force-braces properties for all blocks whose parent isn't a try-statement.
                node.ForceBraces = node.Parent is TryStatement;

                if (m_combineAdjacentVars)
                {
                    // look at the statements in the block. 
                    // if there are multiple var statements adjacent to each other, combine them.
                    // walk BACKWARDS down the list because we'll be removing items when we encounter
                    // multiple vars, etc.
                    // we also don't need to check the first one, since there is nothing before it.
                    for (int ndx = node.Count - 1; ndx > 0; --ndx)
                    {
                        var previousDeclaration = node[ndx - 1] as Declaration;
                        if (previousDeclaration != null)
                        {
                            if (previousDeclaration.StatementToken == DeclarationType(node[ndx]))
                            {
                                // add the items in this VAR to the end of the previous
                                previousDeclaration.Append(node[ndx]);

                                // delete this item from the block
                                node.RemoveAt(ndx);
                            }
                        }
                        else
                        {
                            // if this node and hte previous node are both export declaration statements of the same type...
                            var previousExport = node[ndx - 1] as ExportStatement;
                            if (previousExport != null && previousExport.Count == 1 && previousExport.ModuleName.IsNullOrWhiteSpace())
                            {
                                var declarationType = DeclarationType(previousExport[0]);
                                if (declarationType != JSToken.None)
                                {
                                    var thisExport = node[ndx] as ExportStatement;
                                    if (thisExport != null && thisExport.Count == 1 && thisExport.ModuleName.IsNullOrWhiteSpace()
                                        && declarationType == DeclarationType(thisExport[0]))
                                    {
                                        // merge our specifiers into the previous declaration's specifiers
                                        // and remove this statement from the block
                                        ((Declaration)previousExport[0]).Append(thisExport[0]);
                                        node.RemoveAt(ndx);
                                    }
                                }
                            }
                        }
                    }
                }

                if (node.IsModule)
                {
                    // walk backwards until we find the last non-comment statement
                    var ndxLast = node.Count - 1;
                    while (ndxLast >= 0 && node[ndxLast] is ImportantComment)
                    {
                        --ndxLast;
                    }

                    // if the last non-comment statement isn't the first....
                    if (ndxLast > 0)
                    {
                        // check to see if the last statement is already a target export
                        var finalExport = IfTargetExport(node[ndxLast]);
                        var startIndex = node.Count - (finalExport == null ? 1 : 2);

                        // we're going to keep track of any export declarations we may have because
                        // we'll only move them if it makes sense.
                        var exportDeclarations = new List<ExportStatement>();

                        // walk backwards from the last to the first looking for export statements
                        // with no 'from' clause (those would be re-export statements) and specifiers
                        // as children (we don't want to count the export declaration statements yet.
                        for (var ndx = startIndex; ndx >= 0; --ndx)
                        {
                            // we are only interested in exports nodes that DON'T have a module name.
                            // those are re-exports, and we just want to leave them alone for now.
                            var exportNode = node[ndx] as ExportStatement;
                            if (exportNode != null && exportNode.ModuleName.IsNullOrWhiteSpace())
                            {
                                if (IfTargetExport(exportNode) != null)
                                {
                                    if (exportNode != finalExport)
                                    {
                                        // we have a target export statement
                                        if (finalExport != null)
                                        {
                                            // if we already have a final export, then we just need to prepend our specifiers to 
                                            // the existing export's specifiers and delete this one
                                            finalExport.Insert(0, exportNode);
                                            node.RemoveAt(ndx);
                                        }
                                        else
                                        {
                                            // we don't already have a final export, so just move this one to the end
                                            node.RemoveAt(ndx);
                                            node.Append(exportNode);
                                            finalExport = exportNode;
                                        }
                                    }
                                }
                                else if (exportNode.Count == 1)
                                {
                                    // it's not a target export node (one with specifiers), and it's not a re-export,
                                    // and it has only one child -- must be an export declaration statement. Save it for later.
                                    exportDeclarations.Add(exportNode);
                                }
                            }
                        }

                        // if we found any export declarations
                        if (exportDeclarations.Count > 0)
                        {
                            // we need to see if it's worth it to remove the export keyword from the declaration and
                            // add a new specifier to an existing export statement, or create a new one.
                        }
                    }
                }

                // recurse down the tree after we've combined the adjacent var statements
                base.Visit(node);
            }
        }

        private static JSToken DeclarationType(AstNode node)
        {
            var declaration = node as Declaration;
            if (declaration != null)
            {
                return declaration.StatementToken;
            }

            return JSToken.None;
        }

        //private static ImportExportSpecifier CreateSpecifierLookup(BindingIdentifier bindingIdentifier)
        //{
        //    // create the lookup
        //    var lookup = new Lookup(bindingIdentifier.Context)
        //        {
        //            Name = bindingIdentifier.Name,
        //            VariableField = bindingIdentifier.VariableField,
        //        };

        //    // add a new reference to the variable field. And since we are creating a
        //    // specifier for this field, we can now minify it if we wanted to.
        //    bindingIdentifier.VariableField.IfNotNull(v =>
        //        {
        //            v.References.Add(lookup);
        //            v.CanCrunch = true;
        //        });

        //    // create the specifier and return it
        //    return new ImportExportSpecifier(bindingIdentifier.Context)
        //        {
        //            LocalIdentifier = lookup
        //        };
        //}

        private static ExportStatement IfTargetExport(AstNode node)
        {
            var exportNode = node as ExportStatement;
            return (exportNode != null
                && exportNode.ModuleName.IsNullOrWhiteSpace()
                && exportNode.Count > 0
                && exportNode[0] is ImportExportSpecifier) ? exportNode : null;
        }

        public override void Visit(ConditionalCompilationComment node)
        {
            if (node != null && node.Statements != null && node.Statements.Count > 0)
            {
                // increment the conditional comment level, recurse (process all the
                // statements), then decrement the level when we are through.
                ++m_conditionalCommentLevel;
                base.Visit(node);
                --m_conditionalCommentLevel;
            }
        }

        public override void Visit(ConditionalCompilationIf node)
        {
            if (node != null)
            {
                // increment the conditional comment level and then recurse the condition
                ++m_conditionalCommentLevel;
                base.Visit(node);
            }
        }

        public override void Visit(ConditionalCompilationEnd node)
        {
            if (node != null)
            {
                // just decrement the level, because there's nothing to recurse
                --m_conditionalCommentLevel;
            }
        }

        public override void Visit(ConstantWrapper node)
        {
            // by default this node has nothing to do and no children to recurse.
            // but if this node's parent is a block, then this is an expression statement
            // consisting of a single string literal. Normally we would ignore these -- if
            // they occured at the top of the block they would be DirectivePrologues. So because
            // this exists, it must not be at the top. But we still want to check it for the nomunge
            // hints and respect them if that's what it is.
            if (node != null && node.Parent is BlockStatement)
            {
                // if this is a hint, process it as such.
                if (IsMinificationHint(node))
                {
                    // and then remove it. We can do that here, because blocks are processed
                    // in reverse order.
                    node.Parent.ReplaceChild(node, null);
                }
            }
        }

        public override void Visit(DirectivePrologue node)
        {
            if (node != null)
            {
                // if this is a minification hint, then process it now
                // and then remove it. Otherwise treat it as a directive prologue that
                // we need to preserve
                if (IsMinificationHint(node))
                {
                    node.Parent.ReplaceChild(node, null);
                }
                else
                {
                    // no need to call the base, just add it to the list
                    if (m_moduleDirectives == null)
                    {
                        m_moduleDirectives = new List<DirectivePrologue>();
                    }

                    m_moduleDirectives.Add(node);
                }
            }
        }

        public override void Visit(FunctionObject node)
        {
            if (node != null)
            {
                // if we are reordering ANYTHING, then we need to do the reordering on a scope level.
                // so if that's the case, we need to create a list of all the child functions and NOT
                // recurse at this point. Then we'll reorder, then we'll use the lists to recurse.
                // BUT if we are not reordering anything, no sense making the lists and recursing later.
                // if that's the case, we can just recurse now and not have to worry about anything later.
                if (m_moveVarStatements || m_moveFunctionDecls)
                {
                    // add the node to the appropriate list: either function expression or function declaration.
                    // assume if it's not a function declaration, it must be an expression since the other types
                    // are not declaration (getter, setter) and we want to treat declarations special.
                    // if the conditional comment level isn't zero, then something funky is going on with
                    // the conditional-compilation statements, and we don't want to move the declarations, so
                    // don't add them to the declaration list. But we still want to recurse them, so add them
                    // to the expression list (which get recursed but not moved).
                    if (node.FunctionType == FunctionType.Declaration && m_conditionalCommentLevel == 0)
                    {
                        if (m_functionDeclarations == null)
                        {
                            m_functionDeclarations = new List<FunctionObject>();
                        }

                        m_functionDeclarations.Add(node);
                    }
                    else
                    {
                        if (m_functionExpressions == null)
                        {
                            m_functionExpressions = new List<FunctionObject>();
                        }

                        m_functionExpressions.Add(node);
                    }

                    // BUT DO NOT RECURSE!!!!
                    // we only want the functions and variables in THIS scope, not child function scopes.
                    //base.Visit(node);
                }
                else
                {
                    // we're not reordering, so just recurse now to save the hassle
                    base.Visit(node);
                }
            }
        }

        public override void Visit(VarDeclaration node)
        {
            if (node != null)
            {
                // don't bother creating a list of var-statements if we're not going to move them.
                // and if we are inside a conditional-compilation comment level, then don't move them
                // either.
                // don't bother moving const-statements.
                if (m_moveVarStatements && m_conditionalCommentLevel == 0)
                {
                    if (m_varStatements == null)
                    {
                        m_varStatements = new List<VarDeclaration>();
                    }

                    // add the node to the list of variable declarations
                    m_varStatements.Add(node);
                }

                // and recurse
                base.Visit(node);
            }
        }

        public override void Visit(GroupingOperator node)
        {
            if (node != null)
            {
                // if the parent isn't null, we need to run some checks
                // to see if we can be removed for being superfluous.
                if (node.Parent != null)
                {
                    var deleteParens = false;
                    if (node.Operand == null)
                    {
                        // delete self - no operand make the parens superfluous
                        // TODO: or should we leave them to preserve the "error"?
                        deleteParens = true;
                    }
                    else if (node.Parent is BlockStatement)
                    {
                        // function expressions and object literals need to keep the parens 
                        // or they'll be mistaken for function delcarations and blocks, respectively.
                        // all others get axed.
                        if (!(node.Operand is FunctionObject) && !(node.Operand is ObjectLiteral))
                        {
                            // delete self
                            deleteParens = true;
                        }
                    }
                    else if (node.Parent is AstNodeList)
                    {
                        // keep the parens if the node is itself a comma-operator
                        // question: do we need to check for ANY comma-operators in the entire expression,
                        // or will precedence rules dictate that there will be parens lower down if this
                        // expression isn't a comma-operator?
                        var binOp = node.Operand as BinaryExpression;
                        if (binOp == null || binOp.OperatorToken != JSToken.Comma)
                        {
                            // delete self
                            deleteParens = true;
                        }
                    }
                    else if (node.Parent.IsExpression)
                    {
                        var targetPrecedence = node.Parent.Precedence;
                        var conditional = node.Parent as Conditional;
                        if (conditional != null)
                        {
                            // the conditional is weird in that the different parts need to be
                            // compared against different precedences, not the precedence of the
                            // conditional itself. The condition should be compared to logical-or,
                            // and the true/false expressions against assignment.
                            targetPrecedence = conditional.Condition == node
                                ? OperatorPrecedence.LogicalOr
                                : OperatorPrecedence.Assignment;
                        }
                        
                        if (targetPrecedence <= node.Operand.Precedence)
                        {
                            // if the target precedence is less than or equal to the 
                            // precedence of the operand, then the parens are superfluous.
                            deleteParens = true;
                        }
                    }
                    else
                    {
                        // delete self
                        deleteParens = true;
                    }

                    if (deleteParens)
                    {
                        // delete the parens by replacing the grouping opertor node
                        // with its own operand
                        node.Parent.ReplaceChild(node, node.Operand);
                    }
                }
                
                // always recurse the operand
                if (node.Operand != null)
                {
                    node.Operand.Accept(this);
                }
            }
        }

        public override void Visit(ModuleDeclaration node)
        {
            if (node != null)
            {
                if (node.Body != null)
                {
                    // the module is an inline declration. Add it to the list of modules so we will
                    // recurse them later, AFTER this current scope has already been taken care of.
                    // AND DON'T RECURSE NOW
                    if (m_moduleDeclarations == null)
                    {
                        m_moduleDeclarations = new List<ModuleDeclaration>();
                    }

                    m_moduleDeclarations.Add(node);

                }
            }
        }

        private bool IsMinificationHint(ConstantWrapper node)
        {
            var isHint = false;
            if (node.PrimitiveType == PrimitiveType.String)
            {
                // try splitting on commas and removing empty items
                var sections = node.ToString().Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var section in sections)
                {
                    // valid hints are:
                    //      name:nomunge    don't automatically rename the field defined in this scope named "name"
                    //                      if name is missing (colon is the first character) or "*", then don't rename ANY
                    //                      fields defined in the current scope.
                    var ndxColon = section.IndexOf(':');
                    if (ndxColon >= 0)
                    {
                        // make sure this is a "nomunge" hint. If it is, then the entire node is treated as a hint and
                        // will be removed from the AST.
                        if (string.Compare(section.Substring(ndxColon + 1).Trim(), "nomunge", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            // it is.
                            isHint = true;

                            // get the name that we don't want to munge. Null means all. Convert "*"
                            // to null.
                            var identifier = section.Substring(0, ndxColon).Trim();
                            if (string.IsNullOrEmpty(identifier) || string.CompareOrdinal(identifier, "*") == 0)
                            {
                                identifier = null;
                            }

                            // get the current scope and iterate over all the fields within it
                            // looking for just the ones that are defined here (outer is null)
                            var currentScope = node.EnclosingScope ?? m_globalScope;
                            foreach (var field in currentScope.NameTable.Values)
                            {
                                if (field.OuterField == null)
                                {
                                    // if the identifier is null or matches exactly, mark it as not crunchable
                                    if (identifier == null || string.CompareOrdinal(identifier, field.Name) == 0)
                                    {
                                        field.CanCrunch = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return isHint;
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using NUglify.Helpers;
using NUglify.JavaScript.Syntax;

namespace NUglify.JavaScript.Visitors
{
    internal class ReorderScopeVisitor : TreeVisitor
    {
        // list of all function declarations found in this scope
        private List<FunctionObject> m_functionDeclarations;

        // list of all other functions found in this scope
        private List<FunctionObject> m_functionExpressions;

        // list of all modules found in this scope
        private List<ModuleDeclaration> m_moduleDeclarations;

        // all directive prologues we found BEYOND the initial grouping.
        // if we find any, it was probably because they were directive prologues
        // for modules that were batched together and no longer at the top, so
        // we will need to promote them to get them to the proper place.
        private List<DirectivePrologue> m_moduleDirectives;

        // list of all var statements found in this scope
        private List<VarDeclaration> m_varStatements;

        // whether we want to move var statements
        private bool m_moveVarStatements;

        // whether we want to move function declarations
        private bool m_moveFunctionDecls;

        // whether we want to combine adjacent var statements
        private bool m_combineAdjacentVars;

        // whether we are renaming locals
        //private bool m_localRenaming;

        // counter for whether we are inside a conditional-compilation construct.
        // we need to know this because we do NOT move function declarations that
        // are inside that construct (between @if and @end or inside a single
        // conditional comment).
        // encountering @if or /*@ increments it; *@/ or @end decrements it.
        private int m_conditionalCommentLevel;

        // global scope
        private GlobalScope m_globalScope;

        private ReorderScopeVisitor(JSParser parser)
        {
            // save the mods we care about
            var settings = parser.Settings;
            m_moveVarStatements = settings.ReorderScopeDeclarations && settings.IsModificationAllowed(TreeModifications.CombineVarStatementsToTopOfScope);
            m_moveFunctionDecls = settings.ReorderScopeDeclarations && settings.IsModificationAllowed(TreeModifications.MoveFunctionToTopOfScope);
            m_combineAdjacentVars = settings.IsModificationAllowed(TreeModifications.CombineVarStatements);
            //m_localRenaming = settings.LocalRenaming != LocalRenaming.KeepAll && settings.IsModificationAllowed(TreeModifications.LocalRenaming);

            m_globalScope = parser.GlobalScope;
        }

        public static void Apply(BlockStatement block, JSParser parser)
        {
            if (parser == null)
            {
                throw new ArgumentNullException("parser");
            }

            if (block != null)
            {
                // create a new instance of the visitor and apply it to the block
                var visitor = new ReorderScopeVisitor(parser);
                block.Accept(visitor);

                // if there were any module directive prologues we need to promote, do them first
                var insertAt = 0;
                if (visitor.m_moduleDirectives != null)
                {
                    foreach (var directivePrologue in visitor.m_moduleDirectives)
                    {
                        insertAt = RelocateDirectivePrologue(block, insertAt, directivePrologue);
                    }
                }

                // Make sure that we skip over any remaining comments and directive prologues.
                // we do NOT want to insert anything between the start of the scope and any directive prologues.            
                while (insertAt < block.Count
                    && (block[insertAt] is DirectivePrologue || block[insertAt] is ImportantComment))
                {
                    ++insertAt;
                }

                // first, we want to move all function declarations to the top of this block
                if (visitor.m_functionDeclarations != null)
                {
                    foreach (var funcDecl in visitor.m_functionDeclarations)
                    {
                        insertAt = RelocateFunction(block, insertAt, funcDecl);
                    }
                }

                // special case: if there is only one var statement in the entire scope,
                // then just leave it alone because we will only add bytes by moving it around,
                // or be byte-neutral at best (no initializers and not in a for-statement).
                if (visitor.m_varStatements != null && visitor.m_varStatements.Count > 1)
                {
                    // then we want to move all variable declarations after to the top (after the functions)
                    foreach (var varStatement in visitor.m_varStatements)
                    {
                        insertAt = RelocateVar(block, insertAt, varStatement);
                    }
                }

                // then we want to do the same thing for all child functions (declarations AND other)
                if (visitor.m_functionDeclarations != null)
                {
                    foreach (var funcDecl in visitor.m_functionDeclarations)
                    {
                        Apply(funcDecl.Body, parser);
                    }
                }

                if (visitor.m_functionExpressions != null)
                {
                    foreach (var funcExpr in visitor.m_functionExpressions)
                    {
                        Apply(funcExpr.Body, parser);
                    }
                }

                // and then recurse the modules
                if (visitor.m_moduleDeclarations != null)
                {
                    foreach (var moduleDecl in visitor.m_moduleDeclarations)
                    {
                        Apply(moduleDecl.Body, parser);
                    }
                }
            }
        }

        private static int RelocateDirectivePrologue(BlockStatement block, int insertAt, DirectivePrologue directivePrologue)
        {
            // skip over any important comments
            while (insertAt < block.Count && (block[insertAt] is ImportantComment))
            {
                ++insertAt;
            }

            // if the one we want to insert is already at this spot, then we're good to go
            if (block[insertAt] != directivePrologue)
            {
                // remove it from where it is right now and insert it into the proper location
                directivePrologue.Parent.ReplaceChild(directivePrologue, null);
                block.Insert(insertAt, directivePrologue);
            }

            // and move up to the next slot
            return ++insertAt;
        }

        private static int RelocateFunction(BlockStatement block, int insertAt, AstNode funcDecl)
        {
            // if this function declaration is being exported, then we need to work with the export
            // statement, not the function declaration.
            if (funcDecl.Parent is ExportStatement)
            {
                funcDecl = funcDecl.Parent;
            }

            if (block[insertAt] != funcDecl)
            {
                // technically function declarations can only be direct children of the program or a function block.
                // and since we are passing in such a block, the parent of the function declaration better be that
                // block. If it isn't, we don't want to move it because it's not in an allowed place, and different
                // browsers treat that situation differently. Some browsers would process such funcdecls as if
                // they were a direct child of the main block. Others will treat it like a function expression with
                // an external name, and only assign the function to the name if that line of code is actually
                // executed. So since there's a difference, just leave them as-is and only move valid funcdecls.
                if (funcDecl.Parent == block)
                {
                    // remove the function from it's parent, which will take it away from where it is right now.
                    funcDecl.Parent.ReplaceChild(funcDecl, null);

                    // now insert it into the block at the new location, incrementing the location so the next function
                    // will be inserted after it. It is important that they be in the same order as the source, or the semantics
                    // will change when there are functions with the same name.
                    block.Insert(insertAt++, funcDecl);
                }
            }
            else
            {
                // we're already in the right place. Just increment the pointer to move to the next position
                // for next time
                ++insertAt;
            }

            // return the new position
            return insertAt;
        }

        private static int RelocateVar(BlockStatement block, int insertAt, VarDeclaration varStatement)
        {
            if (varStatement.Parent is ForInStatement forInParent)
            {
                insertAt = ReorderScopeVisitor.RelocateForInVar(block, insertAt, varStatement, forInParent);
            }
            else
            {
                // if the var statement is at the next position to insert, then we don't need
                // to do anything.
                if (block[insertAt] != varStatement)
                {
                    // check to see if the current position is a var and we are the NEXT statement.
                    // if that's the case, we don't need to break out the initializer, just append all the
                    // vardecls as-is to the current position.
                    ForStatement forStatement;

                    if (block[insertAt] is VarDeclaration existingVar && block[insertAt + 1] == varStatement)
                    {
                        // two var-s one right after the other.
                        // just append our vardecls to the insertion point, then delete our statement
                        existingVar.Append(varStatement);
                        block.RemoveAt(insertAt + 1);
                    }
                    else if (block[insertAt] is VarDeclaration existingVar
                        && (forStatement = varStatement.Parent as ForStatement) != null
                        && forStatement.Initializer == varStatement
                        && forStatement == block[insertAt + 1])
                    {
                        // this var statement is the initializer of a for-statement, which is
                        // immediately after the var we would insert our vardecls into.
                        // rather than moving our vardecls into the outside var-statement, let's
                        // move the outside var-statement into our for-statement.
                        varStatement.InsertAt(0, existingVar);
                        block.RemoveAt(insertAt);
                    }
                    else
                    {
                        // iterate through the decls and count how many have initializers
                        var initializerCount = 0;
                        for (var ndx = 0; ndx < varStatement.Count; ++ndx)
                        {
                            // count the number of vardecls with initializers
                            if (varStatement[ndx].Initializer != null)
                            {
                                ++initializerCount;
                            }
                        }

                        // if there are more than two decls with initializers, then we won't actually
                        // be gaining anything by moving the var to the top. We'll get rid of the four
                        // bytes for the "var ", but we'll be adding two bytes for the name and comma
                        // because name=init will still need to remain behind.
                        if (initializerCount <= 2)
                        {
                            // first iterate through all the declarations in the var statement,
                            // constructing an expression statement that is made up of assignment
                            // operators for each of the declarations that have initializers (if any)
                            // and removing all the initializers
                            var assignments = new List<AstNode>();
                            for (var ndx = 0; ndx < varStatement.Count; ++ndx)
                            {
                                var varDecl = varStatement[ndx];
                                if (varDecl.Initializer != null)
                                {
                                    // hold on to the object so we don't lose it to the GC
                                    var initializer = varDecl.Initializer;

                                    // remove it from the vardecl
                                    varDecl.Initializer = null;

                                    var reference = BindingTransform.FromBinding(varDecl.Binding);
                                    if (varDecl.IsCCSpecialCase)
                                    {
                                        // we don't want to add the special-case to the binary operator class,
                                        // so just create a copy of the vardecl for this location, using a reference
                                        // for the "binding"
                                        assignments.Add(new VariableDeclaration(varDecl.Context)
                                            {
                                                Binding = reference,
                                                AssignContext = varDecl.AssignContext,
                                                Initializer = initializer,
                                                IsCCSpecialCase = true,
                                                UseCCOn = varDecl.UseCCOn,
                                                TerminatingContext = varDecl.TerminatingContext
                                            });
                                    }
                                    else
                                    {
                                        assignments.Add(new BinaryExpression(varDecl.Context)
                                            {
                                                Operand1 = reference,
                                                Operand2 = initializer,
                                                OperatorToken = JSToken.Assign,
                                                OperatorContext = varDecl.AssignContext
                                            });
                                    }
                                }

                                // if the vardecl we are moving isn't a binding pattern, we need to 
                                // break it down into a simple list of names.
                                if (!(varDecl.Binding is BindingIdentifier))
                                {
                                    // place the original vardecl with the first one
                                    var first = true;
                                    foreach (var declName in BindingsVisitor.Bindings(varDecl.Binding))
                                    {
                                        if (first)
                                        {
                                            varStatement[ndx] = new VariableDeclaration(declName.Context)
                                                {
                                                    Binding = new BindingIdentifier(declName.Context)
                                                    {
                                                        Name = declName.Name,
                                                        VariableField = declName.VariableField
                                                    }
                                                };
                                            first = false;
                                        }
                                        else
                                        {
                                            // otherwise we want to insert a new one at the current position + 1
                                            varStatement.InsertAt(++ndx, new VariableDeclaration(declName.Context)
                                                {
                                                    Binding = new BindingIdentifier(declName.Context)
                                                    {
                                                        Name = declName.Name,
                                                        VariableField = declName.VariableField
                                                    }
                                                });
                                        }
                                    }
                                }
                            }

                            // now if there were any initializers...
                            if (assignments.Count > 0)
                            {
                                // we want to create one big expression from all the assignments and replace the
                                // var statement with the assignment(s) expression. Start at position n=1 and create
                                // a binary operator of n-1 as the left, n as the right, and using a comma operator.
                                var expression = assignments[0];
                                for (var ndx = 1; ndx < assignments.Count; ++ndx)
                                {
                                    expression = CommaExpression.CombineWithComma(expression.Context.FlattenToStart(), expression, assignments[ndx]);
                                }

                                // replace the var with the expression.
                                // we still have a pointer to the var, so we can insert it back into the proper
                                // place next.
                                varStatement.Parent.ReplaceChild(varStatement, expression);
                            }
                            else
                            {
                                // no initializers.
                                // just remove the var statement altogether
                                varStatement.Parent.ReplaceChild(varStatement, null);
                            }

                            // if the statement at the insertion point is a var-statement already,
                            // then we just need to append our vardecls to it. Otherwise we'll insert our
                            // var statement at the right point
                            if (block[insertAt] is VarDeclaration existingVar)
                            {
                                // append the varstatement we want to move to the existing var, which will
                                // transfer all the vardecls to it.
                                existingVar.Append(varStatement);
                            }
                            else
                            {
                                // move the var to the insert point, incrementing the position or next time
                                block.Insert(insertAt, varStatement);
                            }
                        }
                    }
                }
            }

            return insertAt;
        }

        private static int RelocateForInVar(BlockStatement block, int insertAt, VarDeclaration varStatement, ForInStatement forIn)
        {
            // there should only be one decl in the for-in var statement. There should not be any initializer.
            // If not, then ignore it
            VariableDeclaration varDecl;
            if (varStatement.Count == 1 && (varDecl = varStatement[0]).Initializer == null)
            {
                // if there are more than three names, then we don't want to move them
                var bindingNames = BindingsVisitor.Bindings(varDecl.Binding);
                //if (bindingNames.Count < 3)
                {
                    // replace the varStatement in the for-in with a reference version of the binding
                    forIn.Variable = BindingTransform.FromBinding(varDecl.Binding);

                    // if this is a simple binding identifier, then leave it as-is. Otherwise we
                    // need to flatten it for the move to the front of the scope.
                    if (!(varDecl.Binding is BindingIdentifier))
                    {
                        // then flatten all the name in the binding and add them to the 
                        var first = true;
                        foreach (var declName in bindingNames)
                        {
                            if (first)
                            {
                                varStatement[0] = new VariableDeclaration(declName.Context)
                                {
                                    Binding = new BindingIdentifier(declName.Context)
                                    {
                                        Name = declName.Name,
                                        VariableField = declName.VariableField 
                                    }
                                };
                                first = false;
                            }
                            else
                            {
                                // otherwise we want to insert a new one at the current position + 1
                                varStatement.Append(new VariableDeclaration(declName.Context)
                                {
                                    Binding = new BindingIdentifier(declName.Context)
                                    {
                                        Name = declName.Name,
                                        VariableField = declName.VariableField
                                    }
                                });
                            }
                        }
                    }

                    // then move the var statement to the front of the scope                    // if the statement at the insertion point is a var-statement already,                    // then we just need to append our vardecls to it. Otherwise we'll insert our                    // var statement at the right point
                    if (block[insertAt] is VarDeclaration existingVar)
                    {
                        // append the varstatement we want to move to the existing var, which will
                        // transfer all the vardecls to it.
                        existingVar.Append(varStatement);
                    }
                    else
                    {
                        // insert it at the insert point
                        block.Insert(insertAt, varStatement);
                    }
                }
            }

            return insertAt;
        }

        // unnest any child blocks
        private static void UnnestBlocks(BlockStatement node)
        {
            // walk the list of items backwards -- if we come
            // to any blocks, unnest the block recursively. 
            // Remove any empty statements as well.
            // We walk backwards because we could be adding any number of statements 
            // and we don't want to have to modify the counter.
            for (int ndx = node.Count - 1; ndx >= 0; --ndx)
            {
                if (node[ndx] is BlockStatement nestedBlock)
                {
                    // unnest recursively
                    UnnestBlocks(nestedBlock);

                    // if the block has a block scope, then we can't really unnest it
                    // without merging lexical scopes
                    if (!nestedBlock.HasOwnScope)
                    {
                        // remove the nested block
                        node.RemoveAt(ndx);

                        // then start adding the statements in the nested block to our own.
                        // go backwards so we can just keep using the same index
                        node.InsertRange(ndx, nestedBlock.Children);
                    }
                }
                else if (node[ndx] is EmptyStatement)
                {
                    // remove empty statements (lone semicolons)
                    node.RemoveAt(ndx);
                }
                else if (ndx > 0)
                {
                    // see if the previous node is a conditional-compilation comment, because                    // we will also combine adjacent those
                    if (node[ndx - 1] is ConditionalCompilationComment previousComment)
                    {
                        if (node[ndx] is ConditionalCompilationComment thisComment)
                        {
                            // two adjacent conditional comments -- combine them into the first.
                            previousComment.Statements.Append(thisComment.Statements);

                            // and remove the second one (which is now a duplicate)
                            node.RemoveAt(ndx);
                        }
                    }
                }
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void Visit(BlockStatement node)
        {
            if (node != null)
            {
                // there really is no point in nesting blocks that don't have any special scopes
                // attached to them. Unnest any now, before we start combining var statements.
                UnnestBlocks(node);

                // if we get here, we are going to want to optimize the curly-braces to eliminate
                // unneeded ones in all blocks except try/catch/finally. So make sure we reset the 
                // force-braces properties for all blocks whose parent isn't a try-statement.
                node.ForceBraces = node.Parent is TryStatement;

                if (m_combineAdjacentVars)
                {
                    // look at the statements in the block. 
                    // if there are multiple var statements adjacent to each other, combine them.
                    // walk BACKWARDS down the list because we'll be removing items when we encounter
                    // multiple vars, etc.
                    // we also don't need to check the first one, since there is nothing before it.
                    for (int ndx = node.Count - 1; ndx > 0; --ndx)
                    {
                        if (node[ndx - 1] is Declaration previousDeclaration)
                        {
                            if (previousDeclaration.StatementToken == DeclarationType(node[ndx]))
                            {
                                // add the items in this VAR to the end of the previous
                                previousDeclaration.Append(node[ndx]);

                                // delete this item from the block
                                node.RemoveAt(ndx);
                            }
                        }
                        else
                        {
                            // if this node and hte previous node are both export declaration statements of the same type...
                            if (node[ndx - 1] is ExportStatement previousExport && previousExport.Count == 1 && previousExport.ModuleName.IsNullOrWhiteSpace())
                            {
                                var declarationType = DeclarationType(previousExport[0]);
                                if (declarationType != JSToken.None)
                                {
                                    if (node[ndx] is ExportStatement thisExport && thisExport.Count == 1 && thisExport.ModuleName.IsNullOrWhiteSpace()
                                        && declarationType == DeclarationType(thisExport[0]))
                                    {
                                        // merge our specifiers into the previous declaration's specifiers
                                        // and remove this statement from the block
                                        ((Declaration)previousExport[0]).Append(thisExport[0]);
                                        node.RemoveAt(ndx);
                                    }
                                }
                            }
                        }
                    }
                }

                if (node.IsModule)
                {
                    // walk backwards until we find the last non-comment statement
                    var ndxLast = node.Count - 1;
                    while (ndxLast >= 0 && node[ndxLast] is ImportantComment)
                    {
                        --ndxLast;
                    }

                    // if the last non-comment statement isn't the first....
                    if (ndxLast > 0)
                    {
                        // check to see if the last statement is already a target export
                        var finalExport = IfTargetExport(node[ndxLast]);
                        var startIndex = node.Count - (finalExport == null ? 1 : 2);

                        // we're going to keep track of any export declarations we may have because
                        // we'll only move them if it makes sense.
                        var exportDeclarations = new List<ExportStatement>();

                        // walk backwards from the last to the first looking for export statements
                        // with no 'from' clause (those would be re-export statements) and specifiers
                        // as children (we don't want to count the export declaration statements yet.
                        for (var ndx = startIndex; ndx >= 0; --ndx)
                        {
                            // we are only interested in exports nodes that DON'T have a module name.                            // those are re-exports, and we just want to leave them alone for now.
                            if (node[ndx] is ExportStatement exportNode && exportNode.ModuleName.IsNullOrWhiteSpace())
                            {
                                if (IfTargetExport(exportNode) != null)
                                {
                                    if (exportNode != finalExport)
                                    {
                                        // we have a target export statement
                                        if (finalExport != null)
                                        {
                                            // if we already have a final export, then we just need to prepend our specifiers to 
                                            // the existing export's specifiers and delete this one
                                            finalExport.Insert(0, exportNode);
                                            node.RemoveAt(ndx);
                                        }
                                        else
                                        {
                                            // we don't already have a final export, so just move this one to the end
                                            node.RemoveAt(ndx);
                                            node.Append(exportNode);
                                            finalExport = exportNode;
                                        }
                                    }
                                }
                                else if (exportNode.Count == 1)
                                {
                                    // it's not a target export node (one with specifiers), and it's not a re-export,
                                    // and it has only one child -- must be an export declaration statement. Save it for later.
                                    exportDeclarations.Add(exportNode);
                                }
                            }
                        }

                        // if we found any export declarations
                        if (exportDeclarations.Count > 0)
                        {
                            // we need to see if it's worth it to remove the export keyword from the declaration and
                            // add a new specifier to an existing export statement, or create a new one.
                        }
                    }
                }

                // recurse down the tree after we've combined the adjacent var statements
                base.Visit(node);
            }
        }

        private static JSToken DeclarationType(AstNode node)
        {
            if (node is Declaration declaration)
            {
                return declaration.StatementToken;
            }

            return JSToken.None;
        }

        //private static ImportExportSpecifier CreateSpecifierLookup(BindingIdentifier bindingIdentifier)
        //{
        //    // create the lookup
        //    var lookup = new Lookup(bindingIdentifier.Context)
        //        {
        //            Name = bindingIdentifier.Name,
        //            VariableField = bindingIdentifier.VariableField,
        //        };

        //    // add a new reference to the variable field. And since we are creating a
        //    // specifier for this field, we can now minify it if we wanted to.
        //    bindingIdentifier.VariableField.IfNotNull(v =>
        //        {
        //            v.References.Add(lookup);
        //            v.CanCrunch = true;
        //        });

        //    // create the specifier and return it
        //    return new ImportExportSpecifier(bindingIdentifier.Context)
        //        {
        //            LocalIdentifier = lookup
        //        };
        //}

        private static ExportStatement IfTargetExport(AstNode node)
        {
            return (node is ExportStatement exportNode
                && exportNode.ModuleName.IsNullOrWhiteSpace()
                && exportNode.Count > 0
                && exportNode[0] is ImportExportSpecifier) ? exportNode : null;
        }

        public override void Visit(ConditionalCompilationComment node)
        {
            if (node != null && node.Statements != null && node.Statements.Count > 0)
            {
                // increment the conditional comment level, recurse (process all the
                // statements), then decrement the level when we are through.
                ++m_conditionalCommentLevel;
                base.Visit(node);
                --m_conditionalCommentLevel;
            }
        }

        public override void Visit(ConditionalCompilationIf node)
        {
            if (node != null)
            {
                // increment the conditional comment level and then recurse the condition
                ++m_conditionalCommentLevel;
                base.Visit(node);
            }
        }

        public override void Visit(ConditionalCompilationEnd node)
        {
            if (node != null)
            {
                // just decrement the level, because there's nothing to recurse
                --m_conditionalCommentLevel;
            }
        }

        public override void Visit(ConstantWrapper node)
        {
            // by default this node has nothing to do and no children to recurse.
            // but if this node's parent is a block, then this is an expression statement
            // consisting of a single string literal. Normally we would ignore these -- if
            // they occured at the top of the block they would be DirectivePrologues. So because
            // this exists, it must not be at the top. But we still want to check it for the nomunge
            // hints and respect them if that's what it is.
            if (node != null && node.Parent is BlockStatement)
            {
                // if this is a hint, process it as such.
                if (IsMinificationHint(node))
                {
                    // and then remove it. We can do that here, because blocks are processed
                    // in reverse order.
                    node.Parent.ReplaceChild(node, null);
                }
            }
        }

        public override void Visit(DirectivePrologue node)
        {
            if (node != null)
            {
                // if this is a minification hint, then process it now
                // and then remove it. Otherwise treat it as a directive prologue that
                // we need to preserve
                if (IsMinificationHint(node))
                {
                    node.Parent.ReplaceChild(node, null);
                }
                else
                {
                    // no need to call the base, just add it to the list
                    if (m_moduleDirectives == null)
                    {
                        m_moduleDirectives = new List<DirectivePrologue>();
                    }

                    m_moduleDirectives.Add(node);
                }
            }
        }

        public override void Visit(FunctionObject node)
        {
            if (node != null)
            {
                // if we are reordering ANYTHING, then we need to do the reordering on a scope level.
                // so if that's the case, we need to create a list of all the child functions and NOT
                // recurse at this point. Then we'll reorder, then we'll use the lists to recurse.
                // BUT if we are not reordering anything, no sense making the lists and recursing later.
                // if that's the case, we can just recurse now and not have to worry about anything later.
                if (m_moveVarStatements || m_moveFunctionDecls)
                {
                    // add the node to the appropriate list: either function expression or function declaration.
                    // assume if it's not a function declaration, it must be an expression since the other types
                    // are not declaration (getter, setter) and we want to treat declarations special.
                    // if the conditional comment level isn't zero, then something funky is going on with
                    // the conditional-compilation statements, and we don't want to move the declarations, so
                    // don't add them to the declaration list. But we still want to recurse them, so add them
                    // to the expression list (which get recursed but not moved).
                    if (node.FunctionType == FunctionType.Declaration && m_conditionalCommentLevel == 0)
                    {
                        if (m_functionDeclarations == null)
                        {
                            m_functionDeclarations = new List<FunctionObject>();
                        }

                        m_functionDeclarations.Add(node);
                    }
                    else
                    {
                        if (m_functionExpressions == null)
                        {
                            m_functionExpressions = new List<FunctionObject>();
                        }

                        m_functionExpressions.Add(node);
                    }

                    // BUT DO NOT RECURSE!!!!
                    // we only want the functions and variables in THIS scope, not child function scopes.
                    //base.Visit(node);
                }
                else
                {
                    // we're not reordering, so just recurse now to save the hassle
                    base.Visit(node);
                }
            }
        }

        public override void Visit(VarDeclaration node)
        {
            if (node != null)
            {
                // don't bother creating a list of var-statements if we're not going to move them.
                // and if we are inside a conditional-compilation comment level, then don't move them
                // either.
                // don't bother moving const-statements.
                if (m_moveVarStatements && m_conditionalCommentLevel == 0)
                {
                    if (m_varStatements == null)
                    {
                        m_varStatements = new List<VarDeclaration>();
                    }

                    // add the node to the list of variable declarations
                    m_varStatements.Add(node);
                }

                // and recurse
                base.Visit(node);
            }
        }

        public override void Visit(GroupingOperator node)
        {
            if (node != null)
            {
                // if the parent isn't null, we need to run some checks
                // to see if we can be removed for being superfluous.
                if (node.Parent != null)
                {
                    var deleteParens = false;
                    if (node.Operand == null)
                    {
                        // delete self - no operand make the parens superfluous
                        // TODO: or should we leave them to preserve the "error"?
                        deleteParens = true;
                    }
                    else if (node.Parent is BlockStatement)
                    {
                        // function expressions and object literals need to keep the parens 
                        // or they'll be mistaken for function delcarations and blocks, respectively.
                        // all others get axed.
                        if (!(node.Operand is FunctionObject) && !(node.Operand is ObjectLiteral))
                        {
                            // delete self
                            deleteParens = true;
                        }
                    }
                    else if (node.Parent is AstNodeList)
                    {
                        // keep the parens if the node is itself a comma-operator
                        // question: do we need to check for ANY comma-operators in the entire expression,
                        // or will precedence rules dictate that there will be parens lower down if this
                        // expression isn't a comma-operator?
                        var binOp = node.Operand as BinaryExpression;
                        if (binOp == null || binOp.OperatorToken != JSToken.Comma)
                        {
                            // delete self
                            deleteParens = true;
                        }
                    }
                    else if (node.Parent.IsExpression)
                    {
                        var targetPrecedence = node.Parent.Precedence;

                        if (node.Parent is Conditional conditional)
                        {
                            // the conditional is weird in that the different parts need to be
                            // compared against different precedences, not the precedence of the
                            // conditional itself. The condition should be compared to logical-or,
                            // and the true/false expressions against assignment.
                            targetPrecedence = conditional.Condition == node
                                ? OperatorPrecedence.LogicalOr
                                : OperatorPrecedence.Assignment;
                        }
                        
                        if (targetPrecedence <= node.Operand.Precedence)
                        {
                            // if the target precedence is less than or equal to the 
                            // precedence of the operand, then the parens are superfluous.
                            deleteParens = true;
                        }
                    }
                    else
                    {
                        // delete self
                        deleteParens = true;
                    }

                    if (deleteParens)
                    {
                        // delete the parens by replacing the grouping opertor node
                        // with its own operand
                        node.Parent.ReplaceChild(node, node.Operand);
                    }
                }
                
                // always recurse the operand
                if (node.Operand != null)
                {
                    node.Operand.Accept(this);
                }
            }
        }

        public override void Visit(ModuleDeclaration node)
        {
            if (node != null)
            {
                if (node.Body != null)
                {
                    // the module is an inline declration. Add it to the list of modules so we will
                    // recurse them later, AFTER this current scope has already been taken care of.
                    // AND DON'T RECURSE NOW
                    if (m_moduleDeclarations == null)
                    {
                        m_moduleDeclarations = new List<ModuleDeclaration>();
                    }

                    m_moduleDeclarations.Add(node);

                }
            }
        }

        private bool IsMinificationHint(ConstantWrapper node)
        {
            var isHint = false;
            if (node.PrimitiveType == PrimitiveType.String)
            {
                // try splitting on commas and removing empty items
                var sections = node.ToString().Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var section in sections)
                {
                    // valid hints are:
                    //      name:nomunge    don't automatically rename the field defined in this scope named "name"
                    //                      if name is missing (colon is the first character) or "*", then don't rename ANY
                    //                      fields defined in the current scope.
                    var ndxColon = section.IndexOf(':');
                    if (ndxColon >= 0)
                    {
                        // make sure this is a "nomunge" hint. If it is, then the entire node is treated as a hint and
                        // will be removed from the AST.
                        if (string.Compare(section.Substring(ndxColon + 1).Trim(), "nomunge", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            // it is.
                            isHint = true;

                            // get the name that we don't want to munge. Null means all. Convert "*"
                            // to null.
                            var identifier = section.Substring(0, ndxColon).Trim();
                            if (string.IsNullOrEmpty(identifier) || string.CompareOrdinal(identifier, "*") == 0)
                            {
                                identifier = null;
                            }

                            // get the current scope and iterate over all the fields within it
                            // looking for just the ones that are defined here (outer is null)
                            var currentScope = node.EnclosingScope ?? m_globalScope;
                            foreach (var field in currentScope.NameTable.Values)
                            {
                                if (field.OuterField == null)
                                {
                                    // if the identifier is null or matches exactly, mark it as not crunchable
                                    if (identifier == null || string.CompareOrdinal(identifier, field.Name) == 0)
                                    {
                                        field.CanCrunch = false;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return isHint;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ReorderScopeVisitor.cs(242,64): error CS0136: A local or parameter named 'existingVar' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Kooboo.Lib\NUglify\JavaScript\Visitors\ReorderScopeVisitor.cs(380,67): error CS0136: A local or parameter named 'existingVar' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 24 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Sites\Helper\ChangeHelper.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Kooboo.Data.Interface;
using Kooboo.Sites.Models;
using Kooboo.Sites.Repository;
using System;
using System.Collections.Generic;

namespace Kooboo.Sites.Helper
{
    public static class ChangeHelper
    {
        public static void ChangeUrl(SiteDb sitedb, IRepository repo, Guid ObjectId, string OldUrl, string NewUrl)
        {
            var UseObject = repo.Get(ObjectId);
            if (UseObject != null)
            {
                if (UseObject is IDomObject)
                {
                    var domobject = UseObject as IDomObject;
                    if (domobject != null)
                    {
                        string body = domobject.Body;
                        string newbody = Service.DomService.UpdateUrl(body, OldUrl, NewUrl);
                        domobject.Body = newbody;
                        repo.AddOrUpdate(domobject);
                    }
                }
                else if (UseObject is Style)
                {
                    var style = UseObject as Style;
                    style.Body = Lib.Helper.StringHelper.ReplaceIgnoreCase(style.Body, OldUrl, NewUrl);
                    sitedb.Styles.AddOrUpdate(style);
                }
                else if (UseObject is CmsCssRule)
                {
                    var rule = UseObject as CmsCssRule;
                    if (rule.IsInline)
                    {
                        var rulerepo = sitedb.GetRepository(rule.OwnerObjectConstType);
                        if (rulerepo != null)
                        {
                            var ownerobject = rulerepo.Get(rule.OwnerObjectId);
                            if (ownerobject is IDomObject)
                            {
                                var domobject = ownerobject as IDomObject;
                                var node = Service.DomService.GetElementByKoobooId(domobject.Dom, rule.KoobooId);
                                if (node != null && node.nodeType == Dom.enumNodeType.ELEMENT)
                                {
                                    var el = node as Kooboo.Dom.Element;
                                    string style = el.getAttribute("style");

                                    if (!string.IsNullOrEmpty(style))
                                    {
                                        style = Lib.Helper.StringHelper.ReplaceIgnoreCase(style, OldUrl, NewUrl);
                                    }
                                    el.setAttribute("style", style);

                                    string newhtml = Service.DomService.ReSerializeElement(el);

                                    List<SourceUpdate> updates = new List<SourceUpdate>();
                                    updates.Add(new SourceUpdate() { StartIndex = el.location.openTokenStartIndex, EndIndex = el.location.endTokenEndIndex, NewValue = newhtml });

                                    domobject.Body = Service.DomService.UpdateSource(domobject.Body, updates);
                                    rulerepo.AddOrUpdate(domobject);
                                }
                            }
                        }
                    }
                    else if (rule.ruleType== RuleType.ImportRule)
                    {

                        string newdecltext = Lib.Helper.StringHelper.ReplaceIgnoreCase(rule.RuleText, OldUrl, NewUrl);
                         
                        List<CmsCssRuleChanges> changelist = new List<CmsCssRuleChanges>();
                        CmsCssRuleChanges changes = new CmsCssRuleChanges();
                        changes.CssRuleId = rule.Id;
                        changes.selectorText = newdecltext; // rule.SelectorText;
                        changes.DeclarationText = newdecltext;
                        changes.ChangeType = ChangeType.Update;
                        changelist.Add(changes);

                        Guid parentstyle = rule.ParentStyleId;
                        if (parentstyle == default(Guid))
                        {
                            parentstyle = rule.OwnerObjectId;
                        }
                        sitedb.CssRules.UpdateStyle(changelist, parentstyle);

                    }
                    else
                    {
                        var declaration = Kooboo.Dom.CSS.CSSSerializer.deserializeDeclarationBlock(rule.CssText);
                        foreach (var item in declaration.item)
                        {
                            if (item.value.IndexOf(OldUrl, StringComparison.OrdinalIgnoreCase) > -1)
                            {
                                item.value = Lib.Helper.StringHelper.ReplaceIgnoreCase(item.value, OldUrl, NewUrl);
                            }
                        }
                        string newdecltext = Kooboo.Dom.CSS.CSSSerializer.serializeDeclarationBlock(declaration);

                        List<CmsCssRuleChanges> changelist = new List<CmsCssRuleChanges>();
                        CmsCssRuleChanges changes = new CmsCssRuleChanges();
                        changes.CssRuleId = rule.Id;
                        changes.selectorText = rule.SelectorText;
                        changes.DeclarationText = newdecltext;
                        changes.ChangeType = ChangeType.Update;
                        changelist.Add(changes);
                        Guid parentstyle = rule.ParentStyleId;
                        if (parentstyle == default(Guid))
                        {
                            parentstyle = rule.OwnerObjectId;
                        }
                        sitedb.CssRules.UpdateStyle(changelist, parentstyle);
                    }
                }

                else if (UseObject is ResourceGroup)
                {
                    var oldid = Data.IDGenerator.GetRouteId(OldUrl);

                    var group = UseObject as ResourceGroup;

                    int neworder = 0;

                    if (group.Children.ContainsKey(oldid))
                    {
                        neworder = group.Children[oldid];
                    }

                    group.Children.Remove(oldid);

                    if (NewUrl != null && !NewUrl.ToLower().StartsWith("http://") && !NewUrl.ToLower().StartsWith("https://"))
                    {
                        var newid = Data.IDGenerator.GetRouteId(NewUrl);
                        group.Children[newid] = neworder;
                        sitedb.ResourceGroups.AddOrUpdate(group);
                    }
                }
            }
        }

        public static void DeleteUrl(SiteDb sitedb, IRepository repo, Guid ObjectId, string OldUrl)
        {
            var UseObject = repo.Get(ObjectId);
            if (UseObject != null)
            {
                if (UseObject is IDomObject)
                {
                    var domobject = UseObject as IDomObject;
                    if (domobject != null)
                    {
                        string body = domobject.Body;
                        string newbody = Service.DomService.DeleteUrl(body, OldUrl);
                        domobject.Body = newbody;
                        repo.AddOrUpdate(domobject);
                    }
                }
                else if (UseObject is Style)
                {
                    var style = UseObject as Style;
                    style.Body = Lib.Helper.StringHelper.ReplaceIgnoreCase(style.Body, OldUrl, "");
                    sitedb.Styles.AddOrUpdate(style);
                }
                else if (UseObject is CmsCssRule)
                {
                    var rule = UseObject as CmsCssRule;
                    if (rule.IsInline)
                    {
                        var rulerepo = sitedb.GetRepository(rule.OwnerObjectConstType);
                        if (rulerepo != null)
                        {
                            var ownerobject = rulerepo.Get(rule.OwnerObjectId);
                            if (ownerobject is IDomObject)
                            {
                                var domobject = ownerobject as IDomObject;
                                var node = Service.DomService.GetElementByKoobooId(domobject.Dom, rule.KoobooId);
                                if (node != null && node.nodeType == Dom.enumNodeType.ELEMENT)
                                {
                                    var el = node as Kooboo.Dom.Element;
                                    string style = el.getAttribute("style");
                                    if (!string.IsNullOrEmpty(style))
                                    {
                                        string[] seperators = new string[1];
                                        seperators[0] = ";";
                                        string[] parts = style.Split(seperators, StringSplitOptions.RemoveEmptyEntries);
                                        int count = parts.Length;
                                        for (int i = 0; i < count; i++)
                                        {
                                            if (parts[i].IndexOf(OldUrl, StringComparison.OrdinalIgnoreCase) > -1)
                                            {
                                                parts[i] = "";
                                            }
                                        }
                                        style = string.Join(";", parts);
                                    }

                                    if (string.IsNullOrWhiteSpace(style))
                                    {
                                        el.removeAttribute("style");
                                    }
                                    else
                                    {
                                        el.setAttribute("style", style);
                                    }

                                    string newhtml = Service.DomService.ReSerializeElement(el);

                                    List<SourceUpdate> updates = new List<SourceUpdate>();
                                    updates.Add(new SourceUpdate() { StartIndex = el.location.openTokenStartIndex, EndIndex = el.location.endTokenEndIndex, NewValue = newhtml });

                                    domobject.Body = Service.DomService.UpdateSource(domobject.Body, updates);
                                    rulerepo.AddOrUpdate(domobject);
                                }
                            }
                        }
                    }
                    else if (rule.ruleType == RuleType.ImportRule)
                    {
                         
                        List<CmsCssRuleChanges> changelist = new List<CmsCssRuleChanges>();
                        CmsCssRuleChanges changes = new CmsCssRuleChanges();
                        changes.CssRuleId = rule.Id;
                        changes.selectorText = rule.SelectorText;
                        changes.DeclarationText = "";
                        changes.ChangeType = ChangeType.Delete;
                        changelist.Add(changes);
                        Guid parentstyle = rule.ParentStyleId;
                        if (parentstyle == default(Guid))
                        {
                            parentstyle = rule.OwnerObjectId;
                        }

                        sitedb.CssRules.UpdateStyle(changelist, parentstyle);

                    }
                    else
                    {
                        var declaration = Kooboo.Dom.CSS.CSSSerializer.deserializeDeclarationBlock(rule.CssText);

                        var found = declaration.item.FindAll(o => !string.IsNullOrEmpty(o.value) && o.value.IndexOf(OldUrl, StringComparison.OrdinalIgnoreCase) > -1);
                        if (found != null && found.Count > 0)
                        {
                            foreach (var founditem in found)
                            {
                                declaration.item.Remove(founditem);
                            }
                        }

                        string newdecltext = Kooboo.Dom.CSS.CSSSerializer.serializeDeclarationBlock(declaration);

                        List<CmsCssRuleChanges> changelist = new List<CmsCssRuleChanges>();
                        CmsCssRuleChanges changes = new CmsCssRuleChanges();
                        changes.CssRuleId = rule.Id;
                        changes.selectorText = rule.SelectorText;
                        changes.DeclarationText = newdecltext;
                        changes.ChangeType = ChangeType.Update;
                        changelist.Add(changes);
                        Guid parentstyle = rule.ParentStyleId;
                        if (parentstyle == default(Guid))
                        {
                            parentstyle = rule.OwnerObjectId;
                        }
                        sitedb.CssRules.UpdateStyle(changelist, parentstyle);
                    }


                }

                else if (UseObject is ResourceGroup)
                {
                    var oldid = Data.IDGenerator.GetRouteId(OldUrl);

                    var group = UseObject as ResourceGroup;

                    group.Children.Remove(oldid);

                    repo.AddOrUpdate(group);

                }

            }
        }

        public static void DeleteRoutableObject(SiteDb sitedb, IRepository repo, ISiteObject value)
        {
            // delete route.. 
            //TODO: 
            // Sites.Helper.ChangeHelper.DeleteUrl(this.SiteDb,)   
            var objectroutes = sitedb.Routes.Query.Where(o => o.objectId == value.Id).SelectAll();
            foreach (var item in objectroutes)
            {
                var referredby = sitedb.Relations.GetReferredByRelations(item.Id);

                foreach (var by in referredby)
                {
                    var repofrom = sitedb.GetRepository(by.ConstTypeX);
                    if (repofrom != null)
                    {
                        Sites.Helper.ChangeHelper.DeleteUrl(sitedb, repofrom, by.objectXId, item.Name);
                    }
                }

                var stillusedby = sitedb.Relations.Query.Where(o => o.objectYId == item.Id).SelectAll();
                if ((stillusedby == null || stillusedby.Count == 0 || (stillusedby.Count == 1 && stillusedby[0].objectXId == value.Id)))
                {
                    sitedb.Routes.Delete(item.Id);
                }
                else
                {
                    item.objectId = default(Guid);
                    sitedb.Routes.AddOrUpdate(item);
                }
            }
        }

    
        public static void DeleteComponentFromSource(SiteDb sitedb, ISiteObject value)
        {
            if (value is IEmbeddable)
            {
                var embed = value as IEmbeddable; 
                if (embed.IsEmbedded)
                {
                    // embedded handled by update source. 
                    return; 
                }
            }

            var com = Kooboo.Sites.Render.Components.Container.GetByConstType(value.ConstType);
            if (com != null)
            {
                var relations = sitedb.Relations.GetReferredByRelations(value.Id);

                if (relations != null && relations.Count > 0)
                {
                    foreach (var relation in relations)
                    {
                        var repo = sitedb.GetRepository(relation.ConstTypeX);

                        var UseObject = repo.Get(relation.objectXId);

                        if (UseObject != null)
                        {
                            if (UseObject is IDomObject)
                            {
                                var domobject = UseObject as IDomObject;
                                if (domobject != null)
                                {
                                    List<SourceUpdate> updates = new List<SourceUpdate>();

                                    var el = domobject.Dom.getElementsByTagName(com.TagName);

                                    foreach (var item in el.item)
                                    {
                                        if (!string.IsNullOrEmpty(com.StoreEngineName))
                                        {
                                            var engine = item.getAttribute("engine");
                                            if (!Lib.Helper.StringHelper.IsSameValue(engine, com.StoreEngineName))
                                            {
                                                continue;
                                            }
                                        }

                                        if (Lib.Helper.StringHelper.IsSameValue(item.id, value.Name))
                                        {
                                            updates.Add(new SourceUpdate() { StartIndex = item.location.openTokenStartIndex, EndIndex = item.location.endTokenEndIndex });
                                        }
                                    }

                                    string newbody = Service.DomService.UpdateSource(domobject.Body, updates);
                                    domobject.Body = newbody;
                                    repo.AddOrUpdate(domobject);
                                }
                            }
                        }
                    }
                }
            }
        }

    }
}

---- Transformed Tree ----
using Kooboo.Data.Interface;
using Kooboo.Sites.Models;
using Kooboo.Sites.Repository;
using System;
using System.Collections.Generic;

namespace Kooboo.Sites.Helper
{
    public static class ChangeHelper
    {
        public static void ChangeUrl(SiteDb sitedb, IRepository repo, Guid ObjectId, string OldUrl, string NewUrl)
        {
            var UseObject = repo.Get(ObjectId);
            if (UseObject != null)
            {
                if (UseObject is IDomObject)
                {
                    if (UseObject is IDomObject domobject)
                    {
                        string body = domobject.Body;
                        string newbody = Service.DomService.UpdateUrl(body, OldUrl, NewUrl);
                        domobject.Body = newbody;
                        repo.AddOrUpdate(domobject);
                    }
                }
                else if (UseObject is Style)
                {
                    var style = UseObject as Style;
                    style.Body = Lib.Helper.StringHelper.ReplaceIgnoreCase(style.Body, OldUrl, NewUrl);
                    sitedb.Styles.AddOrUpdate(style);
                }
                else if (UseObject is CmsCssRule)
                {
                    var rule = UseObject as CmsCssRule;
                    if (rule.IsInline)
                    {
                        var rulerepo = sitedb.GetRepository(rule.OwnerObjectConstType);
                        if (rulerepo != null)
                        {
                            var ownerobject = rulerepo.Get(rule.OwnerObjectId);
                            if (ownerobject is IDomObject)
                            {
                                var node = Service.DomService.GetElementByKoobooId(domobject.Dom, rule.KoobooId);
                                if (node != null && node.nodeType == Dom.enumNodeType.ELEMENT)
                                {
                                    var el = node as Kooboo.Dom.Element;
                                    string style = el.getAttribute("style");

                                    if (!string.IsNullOrEmpty(style))
                                    {
                                        style = Lib.Helper.StringHelper.ReplaceIgnoreCase(style, OldUrl, NewUrl);
                                    }
                                    el.setAttribute("style", style);

                                    string newhtml = Service.DomService.ReSerializeElement(el);

                                    List<SourceUpdate> updates = new List<SourceUpdate>();
                                    updates.Add(new SourceUpdate() { StartIndex = el.location.openTokenStartIndex, EndIndex = el.location.endTokenEndIndex, NewValue = newhtml });

                                    domobject.Body = Service.DomService.UpdateSource(domobject.Body, updates);
                                    rulerepo.AddOrUpdate(domobject);
                                }
                            }
                        }
                    }
                    else if (rule.ruleType== RuleType.ImportRule)
                    {

                        string newdecltext = Lib.Helper.StringHelper.ReplaceIgnoreCase(rule.RuleText, OldUrl, NewUrl);
                         
                        List<CmsCssRuleChanges> changelist = new List<CmsCssRuleChanges>();
                        CmsCssRuleChanges changes = new CmsCssRuleChanges();
                        changes.CssRuleId = rule.Id;
                        changes.selectorText = newdecltext; // rule.SelectorText;
                        changes.DeclarationText = newdecltext;
                        changes.ChangeType = ChangeType.Update;
                        changelist.Add(changes);

                        Guid parentstyle = rule.ParentStyleId;
                        if (parentstyle == default(Guid))
                        {
                            parentstyle = rule.OwnerObjectId;
                        }
                        sitedb.CssRules.UpdateStyle(changelist, parentstyle);

                    }
                    else
                    {
                        var declaration = Kooboo.Dom.CSS.CSSSerializer.deserializeDeclarationBlock(rule.CssText);
                        foreach (var item in declaration.item)
                        {
                            if (item.value.IndexOf(OldUrl, StringComparison.OrdinalIgnoreCase) > -1)
                            {
                                item.value = Lib.Helper.StringHelper.ReplaceIgnoreCase(item.value, OldUrl, NewUrl);
                            }
                        }
                        string newdecltext = Kooboo.Dom.CSS.CSSSerializer.serializeDeclarationBlock(declaration);

                        List<CmsCssRuleChanges> changelist = new List<CmsCssRuleChanges>();
                        CmsCssRuleChanges changes = new CmsCssRuleChanges();
                        changes.CssRuleId = rule.Id;
                        changes.selectorText = rule.SelectorText;
                        changes.DeclarationText = newdecltext;
                        changes.ChangeType = ChangeType.Update;
                        changelist.Add(changes);
                        Guid parentstyle = rule.ParentStyleId;
                        if (parentstyle == default(Guid))
                        {
                            parentstyle = rule.OwnerObjectId;
                        }
                        sitedb.CssRules.UpdateStyle(changelist, parentstyle);
                    }
                }

                else if (UseObject is ResourceGroup)
                {
                    var oldid = Data.IDGenerator.GetRouteId(OldUrl);

                    var group = UseObject as ResourceGroup;

                    int neworder = 0;

                    if (group.Children.ContainsKey(oldid))
                    {
                        neworder = group.Children[oldid];
                    }

                    group.Children.Remove(oldid);

                    if (NewUrl != null && !NewUrl.ToLower().StartsWith("http://") && !NewUrl.ToLower().StartsWith("https://"))
                    {
                        var newid = Data.IDGenerator.GetRouteId(NewUrl);
                        group.Children[newid] = neworder;
                        sitedb.ResourceGroups.AddOrUpdate(group);
                    }
                }
            }
        }

        public static void DeleteUrl(SiteDb sitedb, IRepository repo, Guid ObjectId, string OldUrl)
        {
            var UseObject = repo.Get(ObjectId);
            if (UseObject != null)
            {
                if (UseObject is IDomObject)
                {
                    if (UseObject is IDomObject domobject)
                    {
                        string body = domobject.Body;
                        string newbody = Service.DomService.DeleteUrl(body, OldUrl);
                        domobject.Body = newbody;
                        repo.AddOrUpdate(domobject);
                    }
                }
                else if (UseObject is Style)
                {
                    var style = UseObject as Style;
                    style.Body = Lib.Helper.StringHelper.ReplaceIgnoreCase(style.Body, OldUrl, "");
                    sitedb.Styles.AddOrUpdate(style);
                }
                else if (UseObject is CmsCssRule)
                {
                    var rule = UseObject as CmsCssRule;
                    if (rule.IsInline)
                    {
                        var rulerepo = sitedb.GetRepository(rule.OwnerObjectConstType);
                        if (rulerepo != null)
                        {
                            var ownerobject = rulerepo.Get(rule.OwnerObjectId);
                            if (ownerobject is IDomObject)
                            {
                                var node = Service.DomService.GetElementByKoobooId(domobject.Dom, rule.KoobooId);
                                if (node != null && node.nodeType == Dom.enumNodeType.ELEMENT)
                                {
                                    var el = node as Kooboo.Dom.Element;
                                    string style = el.getAttribute("style");
                                    if (!string.IsNullOrEmpty(style))
                                    {
                                        string[] seperators = new string[1];
                                        seperators[0] = ";";
                                        string[] parts = style.Split(seperators, StringSplitOptions.RemoveEmptyEntries);
                                        int count = parts.Length;
                                        for (int i = 0; i < count; i++)
                                        {
                                            if (parts[i].IndexOf(OldUrl, StringComparison.OrdinalIgnoreCase) > -1)
                                            {
                                                parts[i] = "";
                                            }
                                        }
                                        style = string.Join(";", parts);
                                    }

                                    if (string.IsNullOrWhiteSpace(style))
                                    {
                                        el.removeAttribute("style");
                                    }
                                    else
                                    {
                                        el.setAttribute("style", style);
                                    }

                                    string newhtml = Service.DomService.ReSerializeElement(el);

                                    List<SourceUpdate> updates = new List<SourceUpdate>();
                                    updates.Add(new SourceUpdate() { StartIndex = el.location.openTokenStartIndex, EndIndex = el.location.endTokenEndIndex, NewValue = newhtml });

                                    domobject.Body = Service.DomService.UpdateSource(domobject.Body, updates);
                                    rulerepo.AddOrUpdate(domobject);
                                }
                            }
                        }
                    }
                    else if (rule.ruleType == RuleType.ImportRule)
                    {
                         
                        List<CmsCssRuleChanges> changelist = new List<CmsCssRuleChanges>();
                        CmsCssRuleChanges changes = new CmsCssRuleChanges();
                        changes.CssRuleId = rule.Id;
                        changes.selectorText = rule.SelectorText;
                        changes.DeclarationText = "";
                        changes.ChangeType = ChangeType.Delete;
                        changelist.Add(changes);
                        Guid parentstyle = rule.ParentStyleId;
                        if (parentstyle == default(Guid))
                        {
                            parentstyle = rule.OwnerObjectId;
                        }

                        sitedb.CssRules.UpdateStyle(changelist, parentstyle);

                    }
                    else
                    {
                        var declaration = Kooboo.Dom.CSS.CSSSerializer.deserializeDeclarationBlock(rule.CssText);

                        var found = declaration.item.FindAll(o => !string.IsNullOrEmpty(o.value) && o.value.IndexOf(OldUrl, StringComparison.OrdinalIgnoreCase) > -1);
                        if (found != null && found.Count > 0)
                        {
                            foreach (var founditem in found)
                            {
                                declaration.item.Remove(founditem);
                            }
                        }

                        string newdecltext = Kooboo.Dom.CSS.CSSSerializer.serializeDeclarationBlock(declaration);

                        List<CmsCssRuleChanges> changelist = new List<CmsCssRuleChanges>();
                        CmsCssRuleChanges changes = new CmsCssRuleChanges();
                        changes.CssRuleId = rule.Id;
                        changes.selectorText = rule.SelectorText;
                        changes.DeclarationText = newdecltext;
                        changes.ChangeType = ChangeType.Update;
                        changelist.Add(changes);
                        Guid parentstyle = rule.ParentStyleId;
                        if (parentstyle == default(Guid))
                        {
                            parentstyle = rule.OwnerObjectId;
                        }
                        sitedb.CssRules.UpdateStyle(changelist, parentstyle);
                    }


                }

                else if (UseObject is ResourceGroup)
                {
                    var oldid = Data.IDGenerator.GetRouteId(OldUrl);

                    var group = UseObject as ResourceGroup;

                    group.Children.Remove(oldid);

                    repo.AddOrUpdate(group);

                }

            }
        }

        public static void DeleteRoutableObject(SiteDb sitedb, IRepository repo, ISiteObject value)
        {
            // delete route.. 
            //TODO: 
            // Sites.Helper.ChangeHelper.DeleteUrl(this.SiteDb,)   
            var objectroutes = sitedb.Routes.Query.Where(o => o.objectId == value.Id).SelectAll();
            foreach (var item in objectroutes)
            {
                var referredby = sitedb.Relations.GetReferredByRelations(item.Id);

                foreach (var by in referredby)
                {
                    var repofrom = sitedb.GetRepository(by.ConstTypeX);
                    if (repofrom != null)
                    {
                        Sites.Helper.ChangeHelper.DeleteUrl(sitedb, repofrom, by.objectXId, item.Name);
                    }
                }

                var stillusedby = sitedb.Relations.Query.Where(o => o.objectYId == item.Id).SelectAll();
                if ((stillusedby == null || stillusedby.Count == 0 || (stillusedby.Count == 1 && stillusedby[0].objectXId == value.Id)))
                {
                    sitedb.Routes.Delete(item.Id);
                }
                else
                {
                    item.objectId = default(Guid);
                    sitedb.Routes.AddOrUpdate(item);
                }
            }
        }

    
        public static void DeleteComponentFromSource(SiteDb sitedb, ISiteObject value)
        {
            if (value is IEmbeddable)
            {
                var embed = value as IEmbeddable; 
                if (embed.IsEmbedded)
                {
                    // embedded handled by update source. 
                    return; 
                }
            }

            var com = Kooboo.Sites.Render.Components.Container.GetByConstType(value.ConstType);
            if (com != null)
            {
                var relations = sitedb.Relations.GetReferredByRelations(value.Id);

                if (relations != null && relations.Count > 0)
                {
                    foreach (var relation in relations)
                    {
                        var repo = sitedb.GetRepository(relation.ConstTypeX);

                        var UseObject = repo.Get(relation.objectXId);

                        if (UseObject != null)
                        {
                            if (UseObject is IDomObject)
                            {
                                if (UseObject is IDomObject domobject)
                                {
                                    List<SourceUpdate> updates = new List<SourceUpdate>();

                                    var el = domobject.Dom.getElementsByTagName(com.TagName);

                                    foreach (var item in el.item)
                                    {
                                        if (!string.IsNullOrEmpty(com.StoreEngineName))
                                        {
                                            var engine = item.getAttribute("engine");
                                            if (!Lib.Helper.StringHelper.IsSameValue(engine, com.StoreEngineName))
                                            {
                                                continue;
                                            }
                                        }

                                        if (Lib.Helper.StringHelper.IsSameValue(item.id, value.Name))
                                        {
                                            updates.Add(new SourceUpdate() { StartIndex = item.location.openTokenStartIndex, EndIndex = item.location.endTokenEndIndex });
                                        }
                                    }

                                    string newbody = Service.DomService.UpdateSource(domobject.Body, updates);
                                    domobject.Body = newbody;
                                    repo.AddOrUpdate(domobject);
                                }
                            }
                        }
                    }
                }
            }
        }

    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Sites\Helper\ChangeHelper.cs(45,84): error CS0103: The name 'domobject' does not exist in the current context,D:\a\1\s\Kooboo.Sites\Helper\ChangeHelper.cs(62,37): error CS0103: The name 'domobject' does not exist in the current context,D:\a\1\s\Kooboo.Sites\Helper\ChangeHelper.cs(62,86): error CS0103: The name 'domobject' does not exist in the current context,D:\a\1\s\Kooboo.Sites\Helper\ChangeHelper.cs(63,58): error CS0103: The name 'domobject' does not exist in the current context,D:\a\1\s\Kooboo.Sites\Helper\ChangeHelper.cs(174,84): error CS0103: The name 'domobject' does not exist in the current context,D:\a\1\s\Kooboo.Sites\Helper\ChangeHelper.cs(209,37): error CS0103: The name 'domobject' does not exist in the current context,D:\a\1\s\Kooboo.Sites\Helper\ChangeHelper.cs(209,86): error CS0103: The name 'domobject' does not exist in the current context,D:\a\1\s\Kooboo.Sites\Helper\ChangeHelper.cs(210,58): error CS0103: The name 'domobject' does not exist in the current context
######################################################################


######################################################################
Nr: 25 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Sites\Repository\SiteRepositoryBase.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Kooboo.IndexedDB;
using Kooboo.Data.Models;
using Kooboo.IndexedDB.Query;
using Kooboo.Sites.Models;
using Kooboo.Sites.Routing;
using Kooboo.Events.Cms;
using Kooboo.Data.Interface;
using Kooboo.Lib.Helper;
using System.Threading.Tasks;

namespace Kooboo.Sites.Repository
{
    public class SiteRepositoryBase<TValue> : ISiteRepositoryBase, IRepository, IRepository<TValue> where TValue : class, ISiteObject
    {
        protected object _locker = new object();

        private SiteDb _sitedb;
        public virtual SiteDb SiteDb
        {
            get
            {
                if (_sitedb == null && WebSite != null)
                {
                    _sitedb = Kooboo.Sites.Cache.WebSiteCache.GetSiteDb(WebSite);
                }
                return _sitedb;
            }
            set
            {
                _sitedb = value;
            }
        }

        private Type _SiteObjectType;
        public Type SiteObjectType
        {
            get
            {
                if (_SiteObjectType == null)
                {
                    _SiteObjectType = typeof(TValue);
                }
                return _SiteObjectType;
            }
            set { _SiteObjectType = value; }
        }

        public bool UseCache { get; set; }

        private WebSite _website;
        public WebSite WebSite
        {
            get
            {
                if (_website == null && _sitedb != null)
                {
                    _website = this._sitedb.WebSite;
                }
                return _website;
            }
            set
            {
                _website = value;
            }
        }

        public void init()
        {

            this.UseCache = Cache.WebSiteCache.EnableCache(this.WebSite, this.SiteObjectType);

            if (this.UseCache)
            {
                foreach (var item in All())
                {
                    Kooboo.Sites.Cache.SiteObjectCache<TValue>.AddOrUpdate(this.SiteDb, item);
                }
            }
        }

        public SiteRepositoryBase(WebSite website)
        {
            this.WebSite = website;
            init();
        }
        public SiteRepositoryBase(SiteDb sitedb)
        {
            this.SiteDb = sitedb;
            this.WebSite = sitedb.WebSite;
            init();
        }

        public SiteRepositoryBase()
        {

        }

        public virtual bool IsEqualTo(TValue value)
        {
            return this.GetHashCode() == value.GetHashCode();
        }

        public virtual string StoreName
        {
            get
            {
                return typeof(TValue).Name;
            }
        }

        public virtual ObjectStoreParameters StoreParameters
        {
            get
            {
                ObjectStoreParameters paras = new ObjectStoreParameters();
                return paras;
            }
        }

        private ObjectStore<Guid, TValue> _store;

        public ObjectStore<Guid, TValue> Store
        {
            get
            {
                if (_store == null)
                {
                    lock (_locker)
                    {
                        if (_store == null)
                        {

                            var para = this.StoreParameters;

                            if (Lib.Reflection.TypeHelper.HasInterface(this.SiteObjectType, typeof(ICoreObject)))
                            {
                                para.EnableLog = true;
                                para.EnableVersion = true;
                                para.SetPrimaryKeyField<TValue>(o => o.Id);
                            }
                            else
                            {
                                para.EnableLog = false;
                                para.EnableVersion = false;
                            }

                            _store = this.SiteDb.DatabaseDb.GetOrCreateObjectStore<Guid, TValue>(StoreName, para);

                            if (_store.CheckSameSetting(para) == false)
                            {
                                _store = this.SiteDb.DatabaseDb.RebuildObjectStore<Guid, TValue>(_store, para);
                            }
                        }
                    }
                }
                return _store;
            }
        }
          
        public virtual bool AddOrUpdate(TValue value, Guid UserId)
        {
            lock (_locker)
            {
                var old = Get(value.Id);
                if (old == null)
                {
                    RaiseBeforeEvent(value, ChangeType.Add);
                    Store.CurrentUserId = UserId;
                    Store.add(value.Id, value);
                    RaiseEvent(value, ChangeType.Add);
                    return true;
                }
                else
                {
                    if (!IsEqual(old, value))
                    {
                        value.LastModified = DateTime.UtcNow;
                        RaiseBeforeEvent(value, ChangeType.Add);
                        Store.CurrentUserId = UserId;
                        Store.update(value.Id, value);
                        RaiseEvent(value, ChangeType.Update, old);
                        return true;
                    }
                }
                return false;
            }
        }

        public virtual bool AddOrUpdate(TValue value)
        {
            return this.AddOrUpdate(value, default(Guid));
        }

        public virtual void Delete(Guid id)
        {
            this.Delete(id, default(Guid));
        }

        public virtual void Delete(Guid id, Guid UserId)
        {
            lock (_locker)
            {
                var old = Get(id);
                if (old != null)
                {
                    RaiseBeforeEvent(old, ChangeType.Delete);
                    this.Store.CurrentUserId = UserId;
                    Store.delete(id);
                }
                RaiseEvent(old, ChangeType.Delete);
            }
        }

        public virtual TValue Get(Guid id, bool getColumnDataOnly = false)
        {
            TValue result;
            if (this.UseCache)
            {
                result = Cache.SiteObjectCache<TValue>.Get(this.SiteDb, id);
                if (result != null)
                {
                    return result;
                }
            }

            if (getColumnDataOnly)
            {
                result = Store.GetFromColumns(id);
            }
            else
            {
                result = Store.get(id);
            }

            if (result != null)
            {
                if (this.UseCache)
                {
                    Cache.SiteObjectCache<TValue>.AddOrUpdate(this.SiteDb, result);
                }
            }

            return result;
        }


        public virtual async Task<TValue> GetAsync(Guid id)
        {
            TValue result;
            if (this.UseCache)
            {
                result = Cache.SiteObjectCache<TValue>.Get(this.SiteDb, id);
                if (result != null)
                {
                    return result;
                }
            }

      
            result = await Store.getAsync(id);
           

            if (result != null)
            {
                if (this.UseCache)
                {
                    Cache.SiteObjectCache<TValue>.AddOrUpdate(this.SiteDb, result);
                }
            }

            return result;
        }


        public virtual TValue GetFromCache(Guid id)
        {
            TValue result;
            if (this.UseCache)
            {
                result = Cache.SiteObjectCache<TValue>.Get(this.SiteDb, id);
                if (result != null)
                {
                    return result;
                }
            }
            return default(TValue);
        }

        public virtual TValue Get(string nameorid)
        {
            return this.GetByNameOrId(nameorid);
        }

        public virtual TValue GetWithEvent(Guid id)
        {
            if (this.WebSite.EnableFrontEvents)
            {
                // Fire the event here.. 
            }
            return Get(id);
        }

        public virtual TValue GetByUrl(string relativeUrl)
        {
            string relativeurl = UrlHelper.RelativePath(relativeUrl);

            Route route = this.SiteDb.Routes.GetByUrl(relativeUrl);

            if (route != null)
            {
                var routetype = Service.ConstTypeService.GetModelType(route.DestinationConstType);

                if (routetype == this.SiteObjectType)
                {
                    return Get(route.objectId);
                }
            }
            return default(TValue);
        }


        public virtual TValue GetByNameOrId(string NameOrGuid)
        {
            Guid key;
            bool parseok = Guid.TryParse(NameOrGuid, out key);

            if (!parseok)
            {
                byte consttype = ConstTypeContainer.GetConstType(typeof(TValue));

                key = Data.IDGenerator.Generate(NameOrGuid, consttype);
            }
            return Get(key);
        }

        public virtual List<UsedByRelation> GetUsedBy(Guid ObjectId)
        {
            //var siteojbect = this.Store.getValueFromColumns(ObjectId) as SiteObject;

            //if (siteojbect != null)
            //{
            //    var objectrelations = this.SiteDb.Relations.GetReferredBy(siteojbect);
            //    return Helper.RelationHelper.ShowUsedBy(this.SiteDb, objectrelations);
            //}

            var objectrelations = this.SiteDb.Relations.GetReferredBy(this.SiteObjectType, ObjectId);
            return Helper.RelationHelper.ShowUsedBy(this.SiteDb, objectrelations);

            // return new List<UsedByRelation>(); 
        }


        public WhereFilter<Guid, TValue> Query
        {
            get
            {
                return new WhereFilter<Guid, TValue>(this.Store);
            }
        }

        public int Count()
        {
            return this.Store.Count();
        }

        public FullScan<Guid, TValue> TableScan
        {
            get
            {
                return new FullScan<Guid, TValue>(this.Store);
            }
        }

        /// <summary>
        /// Query all items out..... caution with performance.
        /// </summary>
        /// <param name="UseColumnData"></param>
        /// <returns></returns>
        public virtual List<TValue> All(bool UseColumnData)
        {
            if (UseColumnData)
            {
                return this.Store.Filter.UseColumnData().SelectAll();
            }
            else
            {
                return this.Store.Filter.SelectAll();
            }
        }

        public virtual List<TValue> All()
        {
            return All(false);
        }

        /// <summary>
        /// get a list of the site object. will use cache first if enabled
        /// </summary>
        /// <returns></returns>
        public virtual List<TValue> List(bool UseColumnData = false)
        {
            if (this.UseCache)
            {
                return Cache.SiteObjectCache<TValue>.List(this.SiteDb);
            }
            else
            {
                return All();
            }
        }

        public virtual bool IsEqual(TValue x, TValue y)
        {
            if (x.Id != y.Id)
            { return false; }

            return x.GetHashCode() == y.GetHashCode();
        }

        public virtual void RollBack(LogEntry log)
        {
            Guid key = this.Store.KeyConverter.FromByte(log.KeyBytes);

            if (log.EditType == EditType.Add)
            {
                var siteobject = this.Get(key);
                if (siteobject != null)
                {
                    if (this.SiteObjectType == typeof(Route))
                    {
                        var route = siteobject as Route;
                        if (route != null)
                        {
                            Service.LogService.EnsureDeleteRouteObject(this.SiteDb, route);
                        }
                    }

                    else if (Kooboo.Sites.Service.ObjectService.IsRoutable(siteobject, true))
                    {
                        Service.LogService.EnsureDeleteObjectRoute(this.SiteDb, siteobject as SiteObject);
                    }
                    Delete(key);
                }

            }
            else if (log.EditType == EditType.Update)
            {
                TValue oldvalue = this.Store.getValue(log.OldBlockPosition);
                AddOrUpdate(oldvalue);
            }
            else
            {
                // this is delete of one item. 
                TValue oldvalue = this.Store.getValue(log.OldBlockPosition);
                AddOrUpdate(oldvalue);
                if (this.SiteObjectType == typeof(Route))
                {
                    var route = oldvalue as Route;
                    if (route != null)
                    {
                        Service.LogService.EnsureRestoreRouteObject(this.SiteDb, route);
                    }
                }

                else if (Kooboo.Sites.Service.ObjectService.IsRoutable(oldvalue, true))
                {
                    Service.LogService.EnsureRestoreObjectRoute(this.SiteDb, oldvalue as SiteObject);
                }
            }
        }

        public virtual void RollBack(List<LogEntry> loglist)
        {
            HashSet<Guid> finished = new HashSet<Guid>();

            foreach (var item in loglist.OrderBy(o => o.TimeTick))
            {
                Guid key = this.Store.KeyConverter.FromByte(item.KeyBytes);

                if (!finished.Contains(key))
                {
                    RollBack(item);
                    finished.Add(key);
                }
            }
        }


        public virtual List<Relation.ObjectRelation> CheckBeingUsed(TValue SiteObject)
        {

            var converted = SiteObject as SiteObject;
            if (converted == null)
            {
                return null;
            }
            return this.SiteDb.Relations.GetReferredBy(converted);
        }

        public List<Relation.ObjectRelation> CheckBeingUsed(Guid ObjectId)
        {
            var siteobject = this.Get(ObjectId);
            return this.CheckBeingUsed(siteobject);
        }

        protected void RaiseBeforeEvent(TValue value, ChangeType changetype, TValue oldValue = default(TValue))
        {
            if (this.SiteObjectType == typeof(Page))
            {
                var maxpages = Kooboo.Data.Infrastructure.InfraManager.instance.MaxPages(this.SiteDb.WebSite.OrganizationId);
                if (maxpages != int.MaxValue)
                {
                    var count = this.SiteDb.Pages.Count();
                    if (count >= maxpages)
                    {
                        throw new Exception(Kooboo.Data.Language.Hardcoded.GetValue("Max number of pages per site has been reached, service level upgrade required"));
                    }
                }
            }


            if (this.SiteDb.WebSite.EnableConstraintFixOnSave && changetype != ChangeType.Delete)
            {
                Constraints.ConstraintChecker.FixOnSave(this.SiteDb, value as SiteObject);
            }

            // for kscript parameters. 
            if (value is IScriptable)
            {
                var kscriptobject = value as IScriptable;
                var domobjct = value as IDomObject;
                if (kscriptobject != null && domobjct != null)
                {
                    kscriptobject.RequestParas = Kooboo.Sites.Scripting.ScriptHelper.GetkScriptParaFromDom(this.SiteDb, domobjct.Dom);
                }
            }

            if (value is Kooboo.Sites.Models.Code)
            {
                var code = value as Kooboo.Sites.Models.Code;

                if (code.CodeType == Sites.Models.CodeType.PageScript)
                {
                    code.Parameters = Kooboo.Sites.Scripting.ScriptHelper.GetKScriptParameters(code.Body);
                }
            }

            if (value is Kooboo.Sites.Models.CoreObject && changetype != ChangeType.Delete)
            {
                if (value is Kooboo.Sites.Routing.Route)
                {
                    return;
                }

                var size = Kooboo.Sites.Service.ObjectService.GetSize(value);

                if (!Kooboo.Data.Infrastructure.InfraManager.Test(this.WebSite.OrganizationId, Data.Infrastructure.InfraType.Disk, size))
                {
                    var message = Data.Language.Hardcoded.GetValue("Over Disk Quota");
                    throw new Exception(message);
                }
                else
                {

                    string msg = ConstTypeContainer.GetName(value.ConstType);

                    var objinfo = Kooboo.Sites.Service.ObjectService.GetObjectInfo(this.SiteDb, value);


                    if (objinfo != null)
                    {
                        msg += "| " + objinfo.DisplayName;
                    }
                    else
                    {
                        msg += "| " + value.Name;
                    }

                    Kooboo.Data.Infrastructure.InfraManager.Add(this.WebSite.OrganizationId, Data.Infrastructure.InfraType.Disk, size, msg);

                }

            }

        }

        /// <summary>
        /// After event
        /// </summary>
        /// <param name="value"></param>
        /// <param name="changetype"></param>
        /// <param name="oldValue"></param>
        protected void RaiseEvent(TValue value, ChangeType changetype, TValue oldValue = default(TValue))
        {
            if (value == null)
            { return; }

            if (changetype == ChangeType.Delete && value is ICoreObject)
            {
                var bytes = Service.ObjectService.KeyConverter.ToByte(value.Id);
                var lastdeletelogid = SiteDb.Log.GetJustDeletedVersion(this.StoreName, bytes);
                var core = value as ICoreObject;
                core.Version = lastdeletelogid;
            }

            var siteevent = new SiteObjectEvent<TValue>
            {
                Value = value,
                ChangeType = changetype,
                SiteDb = SiteDb,
                Store = this.Store
            }; 


            if (changetype == ChangeType.Update)
            {
                siteevent.OldValue = oldValue;
            }

            if (this.SiteDb.WebSite.EnableDiskSync)
            {
                Sync.DiskSyncHelper.SyncToDisk(SiteDb, value, changetype, this.StoreName);
            }



            if (this.SiteDb.WebSite.EnableFullTextSearch)
            {
                this.SiteDb.SearchIndex.Sync(SiteDb, value, changetype, this.StoreName);
            }

            if (this.SiteDb.WebSite.EnableCluster && this.SiteDb.ClusterManager != null)
            {
                this.SiteDb.ClusterManager.AddTask(this, value, changetype);
            }

            ///add to cache. 
            if (this.UseCache)
            {
                if (changetype == ChangeType.Delete)
                {
                    Cache.SiteObjectCache<TValue>.Remove(this.SiteDb, value);
                }
                else
                {
                    Cache.SiteObjectCache<TValue>.AddOrUpdate(this.SiteDb, value);
                }
            }

            if (siteevent.ChangeType == ChangeType.Delete)
            {
                var objectvalue = siteevent.Value;
                if (Kooboo.Sites.Service.ObjectService.IsRoutable(objectvalue, false))
                {
                    Sites.Helper.ChangeHelper.DeleteRoutableObject(SiteDb, this, objectvalue);
                }

                else
                {
                    if (objectvalue is Kooboo.Sites.Models.Code)
                    {
                        var code = objectvalue as Code; 
                        if (code.CodeType == CodeType.Api)
                        {
                            Sites.Helper.ChangeHelper.DeleteRoutableObject(SiteDb, this, objectvalue);
                        }
                    }
                }

                Sites.Helper.ChangeHelper.DeleteComponentFromSource(SiteDb, objectvalue); 
            }

            Relation.RelationManager.Compute(siteevent);

            Kooboo.Sites.Events.Handler.HandleChange(siteevent);

            Data.Events.EventBus.Raise(siteevent);

            if (siteevent.Value is DomObject)
            {
                var newojbect = siteevent.Value as DomObject;
                newojbect.DisposeDom();
            }

            if (siteevent.Value is Page)
            {
                PageRoute.UpdatePageRouteParameter(siteevent.SiteDb, siteevent.Value.Id);
            }

            ///close database
            if (value is ICoreObject)
            {
                this.Store.OwnerDatabase.Flush();

                this.Store.Close();
                if (this.SiteObjectType == typeof(Image))
                {
                    lock (this.SiteDb.ImagePool.Locker)
                    {
                        this.SiteDb.ImagePool.ClearAll();
                    }
                }
                 

            }
            else
            {
                //{
                //    this.Store.Close();
                //    if (this.SiteObjectType == typeof(Image))
                //    {
                //        lock (this.SiteDb.ImagePool.Locker)
                //        {
                //            this.SiteDb.ImagePool.ClearAll();
                //        }
                //    }
                //}
            } 
        }



        #region NonGeneric

        bool IRepository.AddOrUpdate(Object value, Guid UserId)
        {
            var tvalue = (TValue)value;

            return this.AddOrUpdate(tvalue, UserId);
        }

        void IRepository.RollBack(LogEntry log)
        {
            this.RollBack(log);
        }

        void IRepository.RollBack(List<LogEntry> loglist)
        {
            this.RollBack(loglist);
        }

        void IRepository.Delete(Guid id, Guid UserId = default(Guid))
        {
            this.Delete(id, UserId);
        }

        ISiteObject IRepository.Get(Guid id, bool getColumnDataOnly)
        {
            return this.Get(id, getColumnDataOnly);
        }

        ISiteObject IRepository.GetByNameOrId(string NameOrId)
        {
            return this.GetByNameOrId(NameOrId);
        }

        ISiteObject IRepository.GetByLog(LogEntry log)
        {
            long blockposition = 0;
            if (log.EditType == EditType.Delete)
            {
                blockposition = log.OldBlockPosition;
            }
            else
            {
                blockposition = log.NewBlockPosition;
            }

            var result = this.Store.getValue(blockposition);

            if (result is ICoreObject)
            {
                // in case it is an delete. 
                var core = result as ICoreObject;
                if (core != null)
                {
                    core.Version = log.Id;
                }
            }
            return result;
        }

        ISiteObject IRepository.GetLastEntryFromLog(Guid ObjectId)
        {
            if (ObjectId == default(Guid))
            { return null; }
            var result = this.Get(ObjectId);
            if (result != null)
            {
                return result;
            }

            var keybytes = this.Store.KeyConverter.ToByte(ObjectId);

            var logentry = this.SiteDb.Log.GetLastLogByStoreNameAndKey(this.StoreName, keybytes);

            if (logentry != null)
            {
                long blockposition = 0;
                if (logentry.EditType == EditType.Delete)
                {
                    blockposition = logentry.OldBlockPosition;
                }
                else
                {
                    blockposition = logentry.NewBlockPosition;
                }

                return this.Store.getValue(blockposition);
            }

            return null;
        }

        List<ISiteObject> IRepository.All(bool UseColumnData)
        {
            var list = this.All(UseColumnData);
            return list.Select(it => (ISiteObject)it).ToList();
        }


        Type IRepository.ModelType
        {
            get { return this.SiteObjectType; }
            set { this.SiteObjectType = value; }
        }

        string IRepository.StoreName
        {
            get
            {
                return this.StoreName;
            }
        }

        IObjectStore IRepository.Store
        {
            get
            {
                return this.Store as IObjectStore;
            }
        }

        void IRepository.CheckOut(Int64 VersionId, IRepository DestinationRepository, bool SelfIncluded)
        {
            List<LogEntry> logs;
            int namehash = this.StoreName.GetHashCode32();
            if (SelfIncluded)
            {
                logs = this.SiteDb.Log.Store.Where(o => o.Id > VersionId && o.StoreNameHash == namehash).Take(99999);
            }
            else
            {
                logs = this.SiteDb.Log.Store.Where(o => o.Id >= VersionId && o.StoreNameHash == namehash).Take(99999);
            }

            CheckOutExcl(logs, DestinationRepository);

        }

        List<UsedByRelation> IRepository.GetUsedBy(Guid ObjectId)
        {
            return this.GetUsedBy(ObjectId);
        }

        internal void CheckOut(List<LogEntry> logs, IRepository DestinationRepository)
        {
            HashSet<Guid> donekeys = new HashSet<Guid>();
            foreach (var item in logs.OrderByDescending(o => o.TimeTick))
            {
                Guid key = this.Store.KeyConverter.FromByte(item.KeyBytes);

                if (donekeys.Contains(key))
                {
                    continue;
                }

                if (item.EditType == EditType.Add || item.EditType == EditType.Update)
                {
                    TValue value = this.Store.getValue(item.NewBlockPosition);
                    DestinationRepository.AddOrUpdate(value);

                    donekeys.Add(key);
                }
                else
                {
                    donekeys.Add(key);
                }
            }
        }

        internal void CheckOutExcl(List<LogEntry> ExclLogs, IRepository DestinationRepository)
        {
            var exclitems = GetExclItems(ExclLogs);

            var processed = new HashSet<Guid>();

            var all = this.All();

            foreach (var item in all)
            {
                var changeitem = exclitems.Find(o => o.Id == item.Id);
                if (changeitem == null)
                {
                    DestinationRepository.AddOrUpdate(item);
                }
                else
                {
                    if (changeitem.Log.EditType == EditType.Update || changeitem.Log.EditType == EditType.Delete)
                    {
                        TValue value = this.Store.getValue(changeitem.Log.OldBlockPosition);
                        DestinationRepository.AddOrUpdate(value);
                    }
                    processed.Add(changeitem.Id);
                }
            }

            foreach (var item in exclitems.Where(o => !processed.Contains(o.Id)))
            {
                if (item.Log.EditType == EditType.Update || item.Log.EditType == EditType.Delete)
                {
                    TValue value = this.Store.getValue(item.Log.OldBlockPosition);
                    DestinationRepository.AddOrUpdate(value);
                }
            }
        }

        private List<ExclLogItem> GetExclItems(List<LogEntry> logs)
        {
            List<ExclLogItem> result = new List<ExclLogItem>();

            foreach (var item in logs.OrderBy(o => o.TimeTick))
            {
                var key = this.Store.KeyConverter.FromByte(item.KeyBytes);

                var exclitem = new ExclLogItem();
                exclitem.Id = key;
                exclitem.Log = item; 

                if (result.Find(o=>o.Id == key)==null)
                { 
                    result.Add(exclitem);
                }
            }

            return result;

        }

        public void Reuild()
        {
            this.Store.OwnerDatabase.RebuildObjectStore<Guid, TValue>(this.Store, this.StoreParameters); 
        }

        public class ExclLogItem : IEquatable<ExclLogItem>
        {
            public Guid Id { get; set; }

            public LogEntry Log { get; set; }

            public override int GetHashCode()
            {
                return Lib.Security.Hash.ComputeIntCaseSensitive(this.Id.ToString());
            }

            public bool Equals(ExclLogItem other)
            {
                return this.Id == other.Id;
            }
        }

        #endregion 

    }

    public interface ISiteRepositoryBase
    {
        SiteDb SiteDb { get; set; }
        void init();

        void Reuild(); 
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Kooboo.IndexedDB;
using Kooboo.Data.Models;
using Kooboo.IndexedDB.Query;
using Kooboo.Sites.Models;
using Kooboo.Sites.Routing;
using Kooboo.Events.Cms;
using Kooboo.Data.Interface;
using Kooboo.Lib.Helper;
using System.Threading.Tasks;

namespace Kooboo.Sites.Repository
{
    public class SiteRepositoryBase<TValue> : ISiteRepositoryBase, IRepository, IRepository<TValue> where TValue : class, ISiteObject
    {
        protected object _locker = new object();

        private SiteDb _sitedb;
        public virtual SiteDb SiteDb
        {
            get
            {
                if (_sitedb == null && WebSite != null)
                {
                    _sitedb = Kooboo.Sites.Cache.WebSiteCache.GetSiteDb(WebSite);
                }
                return _sitedb;
            }
            set
            {
                _sitedb = value;
            }
        }

        private Type _SiteObjectType;
        public Type SiteObjectType
        {
            get
            {
                if (_SiteObjectType == null)
                {
                    _SiteObjectType = typeof(TValue);
                }
                return _SiteObjectType;
            }
            set { _SiteObjectType = value; }
        }

        public bool UseCache { get; set; }

        private WebSite _website;
        public WebSite WebSite
        {
            get
            {
                if (_website == null && _sitedb != null)
                {
                    _website = this._sitedb.WebSite;
                }
                return _website;
            }
            set
            {
                _website = value;
            }
        }

        public void init()
        {

            this.UseCache = Cache.WebSiteCache.EnableCache(this.WebSite, this.SiteObjectType);

            if (this.UseCache)
            {
                foreach (var item in All())
                {
                    Kooboo.Sites.Cache.SiteObjectCache<TValue>.AddOrUpdate(this.SiteDb, item);
                }
            }
        }

        public SiteRepositoryBase(WebSite website)
        {
            this.WebSite = website;
            init();
        }
        public SiteRepositoryBase(SiteDb sitedb)
        {
            this.SiteDb = sitedb;
            this.WebSite = sitedb.WebSite;
            init();
        }

        public SiteRepositoryBase()
        {

        }

        public virtual bool IsEqualTo(TValue value)
        {
            return this.GetHashCode() == value.GetHashCode();
        }

        public virtual string StoreName
        {
            get
            {
                return typeof(TValue).Name;
            }
        }

        public virtual ObjectStoreParameters StoreParameters
        {
            get
            {
                ObjectStoreParameters paras = new ObjectStoreParameters();
                return paras;
            }
        }

        private ObjectStore<Guid, TValue> _store;

        public ObjectStore<Guid, TValue> Store
        {
            get
            {
                if (_store == null)
                {
                    lock (_locker)
                    {
                        if (_store == null)
                        {

                            var para = this.StoreParameters;

                            if (Lib.Reflection.TypeHelper.HasInterface(this.SiteObjectType, typeof(ICoreObject)))
                            {
                                para.EnableLog = true;
                                para.EnableVersion = true;
                                para.SetPrimaryKeyField<TValue>(o => o.Id);
                            }
                            else
                            {
                                para.EnableLog = false;
                                para.EnableVersion = false;
                            }

                            _store = this.SiteDb.DatabaseDb.GetOrCreateObjectStore<Guid, TValue>(StoreName, para);

                            if (_store.CheckSameSetting(para) == false)
                            {
                                _store = this.SiteDb.DatabaseDb.RebuildObjectStore<Guid, TValue>(_store, para);
                            }
                        }
                    }
                }
                return _store;
            }
        }
          
        public virtual bool AddOrUpdate(TValue value, Guid UserId)
        {
            lock (_locker)
            {
                var old = Get(value.Id);
                if (old == null)
                {
                    RaiseBeforeEvent(value, ChangeType.Add);
                    Store.CurrentUserId = UserId;
                    Store.add(value.Id, value);
                    RaiseEvent(value, ChangeType.Add);
                    return true;
                }
                else
                {
                    if (!IsEqual(old, value))
                    {
                        value.LastModified = DateTime.UtcNow;
                        RaiseBeforeEvent(value, ChangeType.Add);
                        Store.CurrentUserId = UserId;
                        Store.update(value.Id, value);
                        RaiseEvent(value, ChangeType.Update, old);
                        return true;
                    }
                }
                return false;
            }
        }

        public virtual bool AddOrUpdate(TValue value)
        {
            return this.AddOrUpdate(value, default(Guid));
        }

        public virtual void Delete(Guid id)
        {
            this.Delete(id, default(Guid));
        }

        public virtual void Delete(Guid id, Guid UserId)
        {
            lock (_locker)
            {
                var old = Get(id);
                if (old != null)
                {
                    RaiseBeforeEvent(old, ChangeType.Delete);
                    this.Store.CurrentUserId = UserId;
                    Store.delete(id);
                }
                RaiseEvent(old, ChangeType.Delete);
            }
        }

        public virtual TValue Get(Guid id, bool getColumnDataOnly = false)
        {
            TValue result;
            if (this.UseCache)
            {
                result = Cache.SiteObjectCache<TValue>.Get(this.SiteDb, id);
                if (result != null)
                {
                    return result;
                }
            }

            if (getColumnDataOnly)
            {
                result = Store.GetFromColumns(id);
            }
            else
            {
                result = Store.get(id);
            }

            if (result != null)
            {
                if (this.UseCache)
                {
                    Cache.SiteObjectCache<TValue>.AddOrUpdate(this.SiteDb, result);
                }
            }

            return result;
        }


        public virtual async Task<TValue> GetAsync(Guid id)
        {
            TValue result;
            if (this.UseCache)
            {
                result = Cache.SiteObjectCache<TValue>.Get(this.SiteDb, id);
                if (result != null)
                {
                    return result;
                }
            }

      
            result = await Store.getAsync(id);
           

            if (result != null)
            {
                if (this.UseCache)
                {
                    Cache.SiteObjectCache<TValue>.AddOrUpdate(this.SiteDb, result);
                }
            }

            return result;
        }


        public virtual TValue GetFromCache(Guid id)
        {
            TValue result;
            if (this.UseCache)
            {
                result = Cache.SiteObjectCache<TValue>.Get(this.SiteDb, id);
                if (result != null)
                {
                    return result;
                }
            }
            return default(TValue);
        }

        public virtual TValue Get(string nameorid)
        {
            return this.GetByNameOrId(nameorid);
        }

        public virtual TValue GetWithEvent(Guid id)
        {
            if (this.WebSite.EnableFrontEvents)
            {
                // Fire the event here.. 
            }
            return Get(id);
        }

        public virtual TValue GetByUrl(string relativeUrl)
        {
            string relativeurl = UrlHelper.RelativePath(relativeUrl);

            Route route = this.SiteDb.Routes.GetByUrl(relativeUrl);

            if (route != null)
            {
                var routetype = Service.ConstTypeService.GetModelType(route.DestinationConstType);

                if (routetype == this.SiteObjectType)
                {
                    return Get(route.objectId);
                }
            }
            return default(TValue);
        }


        public virtual TValue GetByNameOrId(string NameOrGuid)
        {
            Guid key;
            bool parseok = Guid.TryParse(NameOrGuid, out key);

            if (!parseok)
            {
                byte consttype = ConstTypeContainer.GetConstType(typeof(TValue));

                key = Data.IDGenerator.Generate(NameOrGuid, consttype);
            }
            return Get(key);
        }

        public virtual List<UsedByRelation> GetUsedBy(Guid ObjectId)
        {
            //var siteojbect = this.Store.getValueFromColumns(ObjectId) as SiteObject;

            //if (siteojbect != null)
            //{
            //    var objectrelations = this.SiteDb.Relations.GetReferredBy(siteojbect);
            //    return Helper.RelationHelper.ShowUsedBy(this.SiteDb, objectrelations);
            //}

            var objectrelations = this.SiteDb.Relations.GetReferredBy(this.SiteObjectType, ObjectId);
            return Helper.RelationHelper.ShowUsedBy(this.SiteDb, objectrelations);

            // return new List<UsedByRelation>(); 
        }


        public WhereFilter<Guid, TValue> Query
        {
            get
            {
                return new WhereFilter<Guid, TValue>(this.Store);
            }
        }

        public int Count()
        {
            return this.Store.Count();
        }

        public FullScan<Guid, TValue> TableScan
        {
            get
            {
                return new FullScan<Guid, TValue>(this.Store);
            }
        }

        /// <summary>
        /// Query all items out..... caution with performance.
        /// </summary>
        /// <param name="UseColumnData"></param>
        /// <returns></returns>
        public virtual List<TValue> All(bool UseColumnData)
        {
            if (UseColumnData)
            {
                return this.Store.Filter.UseColumnData().SelectAll();
            }
            else
            {
                return this.Store.Filter.SelectAll();
            }
        }

        public virtual List<TValue> All()
        {
            return All(false);
        }

        /// <summary>
        /// get a list of the site object. will use cache first if enabled
        /// </summary>
        /// <returns></returns>
        public virtual List<TValue> List(bool UseColumnData = false)
        {
            if (this.UseCache)
            {
                return Cache.SiteObjectCache<TValue>.List(this.SiteDb);
            }
            else
            {
                return All();
            }
        }

        public virtual bool IsEqual(TValue x, TValue y)
        {
            if (x.Id != y.Id)
            { return false; }

            return x.GetHashCode() == y.GetHashCode();
        }

        public virtual void RollBack(LogEntry log)
        {
            Guid key = this.Store.KeyConverter.FromByte(log.KeyBytes);

            if (log.EditType == EditType.Add)
            {
                var siteobject = this.Get(key);
                if (siteobject != null)
                {
                    if (this.SiteObjectType == typeof(Route))
                    {
                        if (siteobject is Route route)
                        {
                            Service.LogService.EnsureDeleteRouteObject(this.SiteDb, route);
                        }
                    }

                    else if (Kooboo.Sites.Service.ObjectService.IsRoutable(siteobject, true))
                    {
                        Service.LogService.EnsureDeleteObjectRoute(this.SiteDb, siteobject as SiteObject);
                    }
                    Delete(key);
                }

            }
            else if (log.EditType == EditType.Update)
            {
                TValue oldvalue = this.Store.getValue(log.OldBlockPosition);
                AddOrUpdate(oldvalue);
            }
            else
            {
                // this is delete of one item. 
                TValue oldvalue = this.Store.getValue(log.OldBlockPosition);
                AddOrUpdate(oldvalue);
                if (this.SiteObjectType == typeof(Route))
                {
                    if (siteobject is Route route)
                    {
                        Service.LogService.EnsureRestoreRouteObject(this.SiteDb, route);
                    }
                }

                else if (Kooboo.Sites.Service.ObjectService.IsRoutable(oldvalue, true))
                {
                    Service.LogService.EnsureRestoreObjectRoute(this.SiteDb, oldvalue as SiteObject);
                }
            }
        }

        public virtual void RollBack(List<LogEntry> loglist)
        {
            HashSet<Guid> finished = new HashSet<Guid>();

            foreach (var item in loglist.OrderBy(o => o.TimeTick))
            {
                Guid key = this.Store.KeyConverter.FromByte(item.KeyBytes);

                if (!finished.Contains(key))
                {
                    RollBack(item);
                    finished.Add(key);
                }
            }
        }


        public virtual List<Relation.ObjectRelation> CheckBeingUsed(TValue SiteObject)
        {

            var converted = SiteObject as SiteObject;
            if (converted == null)
            {
                return null;
            }
            return this.SiteDb.Relations.GetReferredBy(converted);
        }

        public List<Relation.ObjectRelation> CheckBeingUsed(Guid ObjectId)
        {
            var siteobject = this.Get(ObjectId);
            return this.CheckBeingUsed(siteobject);
        }

        protected void RaiseBeforeEvent(TValue value, ChangeType changetype, TValue oldValue = default(TValue))
        {
            if (this.SiteObjectType == typeof(Page))
            {
                var maxpages = Kooboo.Data.Infrastructure.InfraManager.instance.MaxPages(this.SiteDb.WebSite.OrganizationId);
                if (maxpages != int.MaxValue)
                {
                    var count = this.SiteDb.Pages.Count();
                    if (count >= maxpages)
                    {
                        throw new Exception(Kooboo.Data.Language.Hardcoded.GetValue("Max number of pages per site has been reached, service level upgrade required"));
                    }
                }
            }


            if (this.SiteDb.WebSite.EnableConstraintFixOnSave && changetype != ChangeType.Delete)
            {
                Constraints.ConstraintChecker.FixOnSave(this.SiteDb, value as SiteObject);
            }

            // for kscript parameters. 
            if (value is IScriptable)
            {
                if (value is IScriptable kscriptobject && value is IDomObject domobjct)
                {
                    kscriptobject.RequestParas = Kooboo.Sites.Scripting.ScriptHelper.GetkScriptParaFromDom(this.SiteDb, domobjct.Dom);
                }
            }

            if (value is Kooboo.Sites.Models.Code)
            {
                var code = value as Kooboo.Sites.Models.Code;

                if (code.CodeType == Sites.Models.CodeType.PageScript)
                {
                    code.Parameters = Kooboo.Sites.Scripting.ScriptHelper.GetKScriptParameters(code.Body);
                }
            }

            if (value is Kooboo.Sites.Models.CoreObject && changetype != ChangeType.Delete)
            {
                if (value is Kooboo.Sites.Routing.Route)
                {
                    return;
                }

                var size = Kooboo.Sites.Service.ObjectService.GetSize(value);

                if (!Kooboo.Data.Infrastructure.InfraManager.Test(this.WebSite.OrganizationId, Data.Infrastructure.InfraType.Disk, size))
                {
                    var message = Data.Language.Hardcoded.GetValue("Over Disk Quota");
                    throw new Exception(message);
                }
                else
                {

                    string msg = ConstTypeContainer.GetName(value.ConstType);

                    var objinfo = Kooboo.Sites.Service.ObjectService.GetObjectInfo(this.SiteDb, value);


                    if (objinfo != null)
                    {
                        msg += "| " + objinfo.DisplayName;
                    }
                    else
                    {
                        msg += "| " + value.Name;
                    }

                    Kooboo.Data.Infrastructure.InfraManager.Add(this.WebSite.OrganizationId, Data.Infrastructure.InfraType.Disk, size, msg);

                }

            }

        }

        /// <summary>
        /// After event
        /// </summary>
        /// <param name="value"></param>
        /// <param name="changetype"></param>
        /// <param name="oldValue"></param>
        protected void RaiseEvent(TValue value, ChangeType changetype, TValue oldValue = default(TValue))
        {
            if (value == null)
            { return; }

            if (changetype == ChangeType.Delete && value is ICoreObject)
            {
                var bytes = Service.ObjectService.KeyConverter.ToByte(value.Id);
                var lastdeletelogid = SiteDb.Log.GetJustDeletedVersion(this.StoreName, bytes);
                var core = value as ICoreObject;
                core.Version = lastdeletelogid;
            }

            var siteevent = new SiteObjectEvent<TValue>
            {
                Value = value,
                ChangeType = changetype,
                SiteDb = SiteDb,
                Store = this.Store
            }; 


            if (changetype == ChangeType.Update)
            {
                siteevent.OldValue = oldValue;
            }

            if (this.SiteDb.WebSite.EnableDiskSync)
            {
                Sync.DiskSyncHelper.SyncToDisk(SiteDb, value, changetype, this.StoreName);
            }



            if (this.SiteDb.WebSite.EnableFullTextSearch)
            {
                this.SiteDb.SearchIndex.Sync(SiteDb, value, changetype, this.StoreName);
            }

            if (this.SiteDb.WebSite.EnableCluster && this.SiteDb.ClusterManager != null)
            {
                this.SiteDb.ClusterManager.AddTask(this, value, changetype);
            }

            ///add to cache. 
            if (this.UseCache)
            {
                if (changetype == ChangeType.Delete)
                {
                    Cache.SiteObjectCache<TValue>.Remove(this.SiteDb, value);
                }
                else
                {
                    Cache.SiteObjectCache<TValue>.AddOrUpdate(this.SiteDb, value);
                }
            }

            if (siteevent.ChangeType == ChangeType.Delete)
            {
                var objectvalue = siteevent.Value;
                if (Kooboo.Sites.Service.ObjectService.IsRoutable(objectvalue, false))
                {
                    Sites.Helper.ChangeHelper.DeleteRoutableObject(SiteDb, this, objectvalue);
                }

                else
                {
                    if (objectvalue is Kooboo.Sites.Models.Code)
                    {
                        var code = objectvalue as Code; 
                        if (code.CodeType == CodeType.Api)
                        {
                            Sites.Helper.ChangeHelper.DeleteRoutableObject(SiteDb, this, objectvalue);
                        }
                    }
                }

                Sites.Helper.ChangeHelper.DeleteComponentFromSource(SiteDb, objectvalue); 
            }

            Relation.RelationManager.Compute(siteevent);

            Kooboo.Sites.Events.Handler.HandleChange(siteevent);

            Data.Events.EventBus.Raise(siteevent);

            if (siteevent.Value is DomObject)
            {
                var newojbect = siteevent.Value as DomObject;
                newojbect.DisposeDom();
            }

            if (siteevent.Value is Page)
            {
                PageRoute.UpdatePageRouteParameter(siteevent.SiteDb, siteevent.Value.Id);
            }

            ///close database
            if (value is ICoreObject)
            {
                this.Store.OwnerDatabase.Flush();

                this.Store.Close();
                if (this.SiteObjectType == typeof(Image))
                {
                    lock (this.SiteDb.ImagePool.Locker)
                    {
                        this.SiteDb.ImagePool.ClearAll();
                    }
                }
                 

            }
            else
            {
                //{
                //    this.Store.Close();
                //    if (this.SiteObjectType == typeof(Image))
                //    {
                //        lock (this.SiteDb.ImagePool.Locker)
                //        {
                //            this.SiteDb.ImagePool.ClearAll();
                //        }
                //    }
                //}
            } 
        }



        #region NonGeneric

        bool IRepository.AddOrUpdate(Object value, Guid UserId)
        {
            var tvalue = (TValue)value;

            return this.AddOrUpdate(tvalue, UserId);
        }

        void IRepository.RollBack(LogEntry log)
        {
            this.RollBack(log);
        }

        void IRepository.RollBack(List<LogEntry> loglist)
        {
            this.RollBack(loglist);
        }

        void IRepository.Delete(Guid id, Guid UserId = default(Guid))
        {
            this.Delete(id, UserId);
        }

        ISiteObject IRepository.Get(Guid id, bool getColumnDataOnly)
        {
            return this.Get(id, getColumnDataOnly);
        }

        ISiteObject IRepository.GetByNameOrId(string NameOrId)
        {
            return this.GetByNameOrId(NameOrId);
        }

        ISiteObject IRepository.GetByLog(LogEntry log)
        {
            long blockposition = 0;
            if (log.EditType == EditType.Delete)
            {
                blockposition = log.OldBlockPosition;
            }
            else
            {
                blockposition = log.NewBlockPosition;
            }

            var result = this.Store.getValue(blockposition);

            if (result is ICoreObject)
            {
                // in case it is an delete. 
                if (result is ICoreObject core)
                {
                    core.Version = log.Id;
                }
            }
            return result;
        }

        ISiteObject IRepository.GetLastEntryFromLog(Guid ObjectId)
        {
            if (ObjectId == default(Guid))
            { return null; }
            var result = this.Get(ObjectId);
            if (result != null)
            {
                return result;
            }

            var keybytes = this.Store.KeyConverter.ToByte(ObjectId);

            var logentry = this.SiteDb.Log.GetLastLogByStoreNameAndKey(this.StoreName, keybytes);

            if (logentry != null)
            {
                long blockposition = 0;
                if (logentry.EditType == EditType.Delete)
                {
                    blockposition = logentry.OldBlockPosition;
                }
                else
                {
                    blockposition = logentry.NewBlockPosition;
                }

                return this.Store.getValue(blockposition);
            }

            return null;
        }

        List<ISiteObject> IRepository.All(bool UseColumnData)
        {
            var list = this.All(UseColumnData);
            return list.Select(it => (ISiteObject)it).ToList();
        }


        Type IRepository.ModelType
        {
            get { return this.SiteObjectType; }
            set { this.SiteObjectType = value; }
        }

        string IRepository.StoreName
        {
            get
            {
                return this.StoreName;
            }
        }

        IObjectStore IRepository.Store
        {
            get
            {
                return this.Store as IObjectStore;
            }
        }

        void IRepository.CheckOut(Int64 VersionId, IRepository DestinationRepository, bool SelfIncluded)
        {
            List<LogEntry> logs;
            int namehash = this.StoreName.GetHashCode32();
            if (SelfIncluded)
            {
                logs = this.SiteDb.Log.Store.Where(o => o.Id > VersionId && o.StoreNameHash == namehash).Take(99999);
            }
            else
            {
                logs = this.SiteDb.Log.Store.Where(o => o.Id >= VersionId && o.StoreNameHash == namehash).Take(99999);
            }

            CheckOutExcl(logs, DestinationRepository);

        }

        List<UsedByRelation> IRepository.GetUsedBy(Guid ObjectId)
        {
            return this.GetUsedBy(ObjectId);
        }

        internal void CheckOut(List<LogEntry> logs, IRepository DestinationRepository)
        {
            HashSet<Guid> donekeys = new HashSet<Guid>();
            foreach (var item in logs.OrderByDescending(o => o.TimeTick))
            {
                Guid key = this.Store.KeyConverter.FromByte(item.KeyBytes);

                if (donekeys.Contains(key))
                {
                    continue;
                }

                if (item.EditType == EditType.Add || item.EditType == EditType.Update)
                {
                    TValue value = this.Store.getValue(item.NewBlockPosition);
                    DestinationRepository.AddOrUpdate(value);

                    donekeys.Add(key);
                }
                else
                {
                    donekeys.Add(key);
                }
            }
        }

        internal void CheckOutExcl(List<LogEntry> ExclLogs, IRepository DestinationRepository)
        {
            var exclitems = GetExclItems(ExclLogs);

            var processed = new HashSet<Guid>();

            var all = this.All();

            foreach (var item in all)
            {
                var changeitem = exclitems.Find(o => o.Id == item.Id);
                if (changeitem == null)
                {
                    DestinationRepository.AddOrUpdate(item);
                }
                else
                {
                    if (changeitem.Log.EditType == EditType.Update || changeitem.Log.EditType == EditType.Delete)
                    {
                        TValue value = this.Store.getValue(changeitem.Log.OldBlockPosition);
                        DestinationRepository.AddOrUpdate(value);
                    }
                    processed.Add(changeitem.Id);
                }
            }

            foreach (var item in exclitems.Where(o => !processed.Contains(o.Id)))
            {
                if (item.Log.EditType == EditType.Update || item.Log.EditType == EditType.Delete)
                {
                    TValue value = this.Store.getValue(item.Log.OldBlockPosition);
                    DestinationRepository.AddOrUpdate(value);
                }
            }
        }

        private List<ExclLogItem> GetExclItems(List<LogEntry> logs)
        {
            List<ExclLogItem> result = new List<ExclLogItem>();

            foreach (var item in logs.OrderBy(o => o.TimeTick))
            {
                var key = this.Store.KeyConverter.FromByte(item.KeyBytes);

                var exclitem = new ExclLogItem();
                exclitem.Id = key;
                exclitem.Log = item; 

                if (result.Find(o=>o.Id == key)==null)
                { 
                    result.Add(exclitem);
                }
            }

            return result;

        }

        public void Reuild()
        {
            this.Store.OwnerDatabase.RebuildObjectStore<Guid, TValue>(this.Store, this.StoreParameters); 
        }

        public class ExclLogItem : IEquatable<ExclLogItem>
        {
            public Guid Id { get; set; }

            public LogEntry Log { get; set; }

            public override int GetHashCode()
            {
                return Lib.Security.Hash.ComputeIntCaseSensitive(this.Id.ToString());
            }

            public bool Equals(ExclLogItem other)
            {
                return this.Id == other.Id;
            }
        }

        #endregion 

    }

    public interface ISiteRepositoryBase
    {
        SiteDb SiteDb { get; set; }
        void init();

        void Reuild(); 
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Kooboo.Sites\Repository\SiteRepositoryBase.cs(747,47): warning CS1066: The default value specified for parameter 'UserId' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Sites\Repository\SiteRepositoryBase.cs(743,47): warning CS1066: The default value specified for parameter 'UserId' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments,D:\a\1\s\Kooboo.Sites\Repository\SiteRepositoryBase.cs(462,25): error CS0103: The name 'siteobject' does not exist in the current context
######################################################################


######################################################################
Nr: 26 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Sites\Scripting\Global\Curl.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Kooboo.Lib.Helper;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Text;
using System.Net.Http;
using System.Threading.Tasks;
using System.Net.Http.Headers;
using System.ComponentModel;
using Kooboo.Data.Context;
using Kooboo.Data.Attributes;

namespace KScript
{

    public class Curl
    {
        [KIgnore]
        private RenderContext context { get; set; }

        public Curl(RenderContext context)
        {
            this.context = context;
        }

        #region get

        [Description(@"Get data string from the url
var webcontent = k.url.get(""http://www.kooboo.com""); ")]
        public string get(string url) => _get(url).Result;

        [Description(@"Get data string from remote url using HTTP Bearer authentication
var webcontent = k.url.get(""http://www.kooboo.com"", ""token"");")]
        public string get(string url, string token) => _get(url, null, BuildBearerHeader(token)).Result;

        [Description(@"Get data string from remote url using HTTP Basic authentication
var webcontent = k.url.get(""http://www.kooboo.com"", ""username"", ""password"");")]
        public string get(string url, string username, string password) => _get(url, null, BuildBasicHeader(username, password)).Result;

        [Description(@"Get data string from the url
var webcontent = k.url.get(""http://www.kooboo.com"",{'Authentication','Bearer xxx'}); ")]
        public string get(string url, IDictionary<string, object> headers) => _get(url, null, headers).Result;

        #endregion

        #region getJson

        [Description(@"Get data string from remote url and deserialize the string as a JSON object.
var webcontent = k.url.getJson(""http://www.kooboo.com""); ")]
        public object GetJson(string url)
        {
            string result = get(url);
            Jint.Native.Json.JsonParser praser = new Jint.Native.Json.JsonParser(new Jint.Engine());
            return praser.Parse(result);
        }

        [Description(@"Get data string from remote url using HTTP Basic authentication, and deserialize the string as a JSON object
var webcontent = k.url.getJson(""http://www.kooboo.com"",""xxx"");")]
        public object GetJson(string url, string token)
        {
            string result = get(url, token);
            Jint.Native.Json.JsonParser praser = new Jint.Native.Json.JsonParser(new Jint.Engine());
            return praser.Parse(result);
        }

        [Description(@"Get data string from remote url using HTTP Basic authentication, and deserialize the string as a JSON object
var webcontent = k.url.getJson(""http://www.kooboo.com"",""admin"",""abc123"");")]
        public object GetJson(string url, string username, string password)
        {
            string result = get(url, username, password);
            Jint.Native.Json.JsonParser praser = new Jint.Native.Json.JsonParser(new Jint.Engine());
            return praser.Parse(result);
        }

        [Description(@"Get data string from remote url and deserialize the string as a JSON object
var webcontent = k.url.getJson(""http://www.kooboo.com"",{'Authentication','Bearer xxxx'}); ")]
        public object GetJson(string url, IDictionary<string, object> headers)
        {
            string result = get(url, headers);
            Jint.Native.Json.JsonParser praser = new Jint.Native.Json.JsonParser(new Jint.Engine());
            return praser.Parse(result);
        }

        #endregion

        #region post

        [Description(@"Post data to remote url
var data = ""name=myname&field=value""; 
k.url.post(""http://www.kooboo.com/fakereceiver"", data); ")]
        public string post(string url, string data) => _Post(url, data).Result;

        [Description(@"Post data to remote url using HTTP Basic authentication
var data = ""name=myname&field=value""; 
k.url.post(""http://www.kooboo.com/fakereceiver"", data,'xxx');
")]
        public string post(string url, string data, string token) => _Post(url, data, BuildBearerHeader(token)).Result;

        [Description(@"Post data to remote url using HTTP Basic authentication
var data = ""name=myname&field=value""; 
k.url.post(""http://www.kooboo.com/fakereceiver"", data,'admin','abc123');
")]
        public string post(string url, string data, string userName, string password) => _Post(url, data, BuildBasicHeader(userName, password)).Result;

        [Description(@"Post data to remote url
var data = ""name=myname&field=value""; 
k.url.post(""http://www.kooboo.com/fakereceiver"", data,{'Authentication','Bearer xxxx'}););
")]
        public string post(string url, string data, IDictionary<string, object> headers) => _Post(url, data, headers).Result;


        #endregion

        #region postData

        [Description(@"Post data to remote url
var data = {
    name:'abc',
    age:23
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data); ")]
        public string postData(string url, object data)
        {
            string poststring = Kooboo.Lib.Helper.JsonHelper.Serialize(data);
            return post(url, poststring);
        }

        [Description(@"Post data to remote url using HTTP Bearer authentication
var data = {
    name:'abc',
    age:23
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'xxx'); ")]
        public string postData(string url, object data, string token)
        {
            string poststring = Kooboo.Lib.Helper.JsonHelper.Serialize(data);
            return post(url, poststring, token);
        }

        [Description(@"Post data as a Json string to remote url using HTTP Basic authentication
var data = {
    name:'abc',
    age:23
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'admin','abc123'); 
")]
        public string postData(string url, object data, string userName, string password)
        {
            string poststring = Kooboo.Lib.Helper.JsonHelper.Serialize(data);
            return post(url, poststring, userName, password);
        }

        [Description(@"Post data as a Json string to remote url
var data = {
    name:'abc',
    age:23
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,{'Authentication','Bearer xxxx'}); 
")]
        public string postData(string url, object data, IDictionary<string, object> headers)
        {
            string poststring = Kooboo.Lib.Helper.JsonHelper.Serialize(data);
            return post(url, poststring, headers);
        }

        #endregion

        #region postForm

        [Description(@"Post form data to remote url
var data = '{""name"":""abc"", ""age"":23}'
k.url.postData(""http://www.kooboo.com/fakereceiver"", data); ")]
        public string postform(string url, string data)
        {
            return _PostForm(url, data).Result;
        }

        [Description(@"Post form data to remote url
var data = {
    name:'abc',
    age:123
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data); ")]
        public string postform(string url, object data)
        {
            string json = JsonHelper.Serialize(data);
            return _PostForm(url, json).Result;
        }

        [Description(@"Post form data to remote url
var data = '{""name"":""abc"", ""age"":23}'
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'xxx'); ")]
        public string postform(string url, string data, string token)
        {
            return _PostForm(url, data, BuildBearerHeader(token)).Result;
        }

        [Description(@"Post form data to remote url
var data = {
    name:'abc',
    age:123
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'xxx'); ")]
        public string postform(string url, object data, string token)
        {
            string json = JsonHelper.Serialize(data);
            return _PostForm(url, json, BuildBearerHeader(token)).Result;
        }

        [Description(@"Post form data to remote url
var data = '{""name"":""abc"", ""age"":23}'
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'admin','abc123'); ")]
        public string postform(string url, string data, string userName, string password)
        {
            return _PostForm(url, data, BuildBasicHeader(userName, password)).Result;
        }

        [Description(@"Post form data to remote url
var data = {
    name:'abc',
    age:123
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'admin','abc123'); ")]
        public string postform(string url, object data, string userName, string password)
        {
            string json = JsonHelper.Serialize(data);
            return _PostForm(url, json, BuildBasicHeader(userName, password)).Result;
        }

        [Description(@"Post form data to remote url
var data = '{""name"":""abc"", ""age"":23}'
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,{'Authentication','Bearer xxxx'}); ")]
        public string postform(string url, string data, IDictionary<string, object> headers)
        {
            return _PostForm(url, data, headers).Result;
        }

        [Description(@"Post form data to remote url
var data = {
    name:'abc',
    age:123
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,{'Authentication','Bearer xxxx'}); ")]
        public string postform(string url, object data, IDictionary<string, object> headers)
        {
            string json = JsonHelper.Serialize(data);
            return _PostForm(url, json, headers).Result;
        }

        #endregion

        #region downloadZip

        [Description(@"Download zip package by url.")]
        public void DownloadZip(string url)
        {
            HttpClient client = HttpClientHelper.Client;
            var requestMessage = new HttpRequestMessage
            {
                RequestUri = new Uri(url),
                Method = HttpMethod.Get,
            };

            var response = client.SendAsync(requestMessage).Result;
            var bytes = response.Content.ReadAsByteArrayAsync().Result;
            context.Response.Headers.Add("Content-Disposition", response.Content.Headers.ContentDisposition.ToString());
            context.Response.ContentType = "application/zip";
            context.Response.Body = bytes;
        }

        #endregion

        #region helper
        private Dictionary<string, string> getvalues(object obj)
        {

            Dictionary<string, string> result = new Dictionary<string, string>();

            if (obj is IDictionary)
            {
                var dict = obj as IDictionary;
                foreach (var item in dict.Keys)
                {
                    var value = dict[item];
                    if (value != null)
                    {
                        result.Add(item.ToString(), value.ToString());
                    }
                    else
                    {
                        result.Add(item.ToString(), string.Empty);
                    }
                }

            }

            else if (obj is System.Dynamic.ExpandoObject)
            {
                IDictionary<String, Object> value = obj as IDictionary<String, Object>;
                if (value != null)
                {
                    foreach (var item in value)
                    {
                        if (item.Value != null)
                        {
                            result.Add(item.Key, item.Value.ToString());
                        }
                        else
                        {
                            result.Add(item.Key, string.Empty);
                        }
                    }
                }

            }
            else if (obj is IDictionary<string, object>)
            {
                IDictionary<string, object> value = obj as IDictionary<string, object>;
                if (value != null)
                {
                    foreach (var item in value)
                    {
                        if (item.Value != null)
                        {
                            result.Add(item.Key, item.Value.ToString());
                        }
                        else
                        {
                            result.Add(item.Key, string.Empty);
                        }
                    }
                }
            }

            return result;
        }

        private static async Task<string> _get(string url, Dictionary<string, string> query = null, IDictionary<string, object> headers = null)
        {

            try
            {
                if (query != null)
                {
                    url = UrlHelper.AppendQueryString(url, query);
                }

                HttpClient client = HttpClientHelper.Client;

                var requestMessage = new HttpRequestMessage
                {
                    RequestUri = new Uri(url),
                    Method = HttpMethod.Get
                };

                if (headers != null)
                {
                    foreach (var item in headers)
                    {
                        requestMessage.Headers.Add(item.Key, item.Value?.ToString());
                    }
                }

                var response = await client.SendAsync(requestMessage);
                var byteArray = await response.Content.ReadAsByteArrayAsync();
                return Encoding.UTF8.GetString(byteArray, 0, byteArray.Length);
            }
            catch (Exception ex)
            {
                return ex.Message;
            }

        }

        private static async Task<string> _Post(string url, string json, IDictionary<string, object> headers = null)
        {
            try
            {
                var client = HttpClientHelper.Client;

                var content = new StringContent(json, Encoding.UTF8);
                content.Headers.ContentType = new MediaTypeWithQualityHeaderValue("application/json");
                var requestMessage = new HttpRequestMessage
                {
                    RequestUri = new Uri(url),
                    Method = HttpMethod.Post,
                    Content = content,
                };

                if (headers != null)
                {
                    foreach (var item in headers)
                    {
                        requestMessage.Headers.Add(item.Key, item.Value?.ToString());
                    }
                }

                var response = await client.SendAsync(requestMessage);

                var byteArray = await response.Content.ReadAsByteArrayAsync();
                return Encoding.UTF8.GetString(byteArray, 0, byteArray.Length);

            }
            catch (Exception ex)
            {
                return ex.Message;
            }

        }

        private async Task<string> _PostForm(string url, string json, IDictionary<string, object> headers = null)
        {
            string result;
            try
            {
                HttpClient client = HttpClientHelper.Client;
                FormUrlEncodedContent content = new FormUrlEncodedContent(JsonHelper.Deserialize<IDictionary<string, string>>(json));

                HttpRequestMessage httpRequestMessage = new HttpRequestMessage
                {
                    RequestUri = new Uri(url),
                    Method = HttpMethod.Post,
                    Content = content
                };

                if (headers != null)
                {
                    foreach (var item in headers)
                    {
                        httpRequestMessage.Headers.Add(item.Key, item.Value?.ToString());
                    }
                }

                byte[] array = await (await client.SendAsync(httpRequestMessage)).Content.ReadAsByteArrayAsync();
                result = Encoding.UTF8.GetString(array, 0, array.Length);
            }
            catch (Exception ex)
            {
                result = ex.Message;
            }
            return result;
        }

        private static Dictionary<string, object> BuildBearerHeader(string token)
        {
            var header = new Dictionary<string, object>();

            if (!string.IsNullOrEmpty(token))
            {
                header.Add(HttpRequestHeader.Authorization.ToString(), $"Bearer {token}");
            }

            return header;
        }

        private static Dictionary<string, object> BuildBasicHeader(string username, string password)
        {
            var header = new Dictionary<string, object>();

            if (!string.IsNullOrEmpty(username) && !string.IsNullOrEmpty(password))
            {
                var bytes = Encoding.UTF8.GetBytes(String.Format("{0}:{1}", username, password));
                header.Add(HttpRequestHeader.Authorization.ToString(), "Basic " + Convert.ToBase64String(bytes));
            }

            return header;
        }

        #endregion
    }
}

---- Transformed Tree ----
using Kooboo.Lib.Helper;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Text;
using System.Net.Http;
using System.Threading.Tasks;
using System.Net.Http.Headers;
using System.ComponentModel;
using Kooboo.Data.Context;
using Kooboo.Data.Attributes;

namespace KScript
{

    public class Curl
    {
        [KIgnore]
        private RenderContext context { get; set; }

        public Curl(RenderContext context)
        {
            this.context = context;
        }

        #region get

        [Description(@"Get data string from the url
var webcontent = k.url.get(""http://www.kooboo.com""); ")]
        public string get(string url) => _get(url).Result;

        [Description(@"Get data string from remote url using HTTP Bearer authentication
var webcontent = k.url.get(""http://www.kooboo.com"", ""token"");")]
        public string get(string url, string token) => _get(url, null, BuildBearerHeader(token)).Result;

        [Description(@"Get data string from remote url using HTTP Basic authentication
var webcontent = k.url.get(""http://www.kooboo.com"", ""username"", ""password"");")]
        public string get(string url, string username, string password) => _get(url, null, BuildBasicHeader(username, password)).Result;

        [Description(@"Get data string from the url
var webcontent = k.url.get(""http://www.kooboo.com"",{'Authentication','Bearer xxx'}); ")]
        public string get(string url, IDictionary<string, object> headers) => _get(url, null, headers).Result;

        #endregion

        #region getJson

        [Description(@"Get data string from remote url and deserialize the string as a JSON object.
var webcontent = k.url.getJson(""http://www.kooboo.com""); ")]
        public object GetJson(string url)
        {
            string result = get(url);
            Jint.Native.Json.JsonParser praser = new Jint.Native.Json.JsonParser(new Jint.Engine());
            return praser.Parse(result);
        }

        [Description(@"Get data string from remote url using HTTP Basic authentication, and deserialize the string as a JSON object
var webcontent = k.url.getJson(""http://www.kooboo.com"",""xxx"");")]
        public object GetJson(string url, string token)
        {
            string result = get(url, token);
            Jint.Native.Json.JsonParser praser = new Jint.Native.Json.JsonParser(new Jint.Engine());
            return praser.Parse(result);
        }

        [Description(@"Get data string from remote url using HTTP Basic authentication, and deserialize the string as a JSON object
var webcontent = k.url.getJson(""http://www.kooboo.com"",""admin"",""abc123"");")]
        public object GetJson(string url, string username, string password)
        {
            string result = get(url, username, password);
            Jint.Native.Json.JsonParser praser = new Jint.Native.Json.JsonParser(new Jint.Engine());
            return praser.Parse(result);
        }

        [Description(@"Get data string from remote url and deserialize the string as a JSON object
var webcontent = k.url.getJson(""http://www.kooboo.com"",{'Authentication','Bearer xxxx'}); ")]
        public object GetJson(string url, IDictionary<string, object> headers)
        {
            string result = get(url, headers);
            Jint.Native.Json.JsonParser praser = new Jint.Native.Json.JsonParser(new Jint.Engine());
            return praser.Parse(result);
        }

        #endregion

        #region post

        [Description(@"Post data to remote url
var data = ""name=myname&field=value""; 
k.url.post(""http://www.kooboo.com/fakereceiver"", data); ")]
        public string post(string url, string data) => _Post(url, data).Result;

        [Description(@"Post data to remote url using HTTP Basic authentication
var data = ""name=myname&field=value""; 
k.url.post(""http://www.kooboo.com/fakereceiver"", data,'xxx');
")]
        public string post(string url, string data, string token) => _Post(url, data, BuildBearerHeader(token)).Result;

        [Description(@"Post data to remote url using HTTP Basic authentication
var data = ""name=myname&field=value""; 
k.url.post(""http://www.kooboo.com/fakereceiver"", data,'admin','abc123');
")]
        public string post(string url, string data, string userName, string password) => _Post(url, data, BuildBasicHeader(userName, password)).Result;

        [Description(@"Post data to remote url
var data = ""name=myname&field=value""; 
k.url.post(""http://www.kooboo.com/fakereceiver"", data,{'Authentication','Bearer xxxx'}););
")]
        public string post(string url, string data, IDictionary<string, object> headers) => _Post(url, data, headers).Result;


        #endregion

        #region postData

        [Description(@"Post data to remote url
var data = {
    name:'abc',
    age:23
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data); ")]
        public string postData(string url, object data)
        {
            string poststring = Kooboo.Lib.Helper.JsonHelper.Serialize(data);
            return post(url, poststring);
        }

        [Description(@"Post data to remote url using HTTP Bearer authentication
var data = {
    name:'abc',
    age:23
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'xxx'); ")]
        public string postData(string url, object data, string token)
        {
            string poststring = Kooboo.Lib.Helper.JsonHelper.Serialize(data);
            return post(url, poststring, token);
        }

        [Description(@"Post data as a Json string to remote url using HTTP Basic authentication
var data = {
    name:'abc',
    age:23
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'admin','abc123'); 
")]
        public string postData(string url, object data, string userName, string password)
        {
            string poststring = Kooboo.Lib.Helper.JsonHelper.Serialize(data);
            return post(url, poststring, userName, password);
        }

        [Description(@"Post data as a Json string to remote url
var data = {
    name:'abc',
    age:23
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,{'Authentication','Bearer xxxx'}); 
")]
        public string postData(string url, object data, IDictionary<string, object> headers)
        {
            string poststring = Kooboo.Lib.Helper.JsonHelper.Serialize(data);
            return post(url, poststring, headers);
        }

        #endregion

        #region postForm

        [Description(@"Post form data to remote url
var data = '{""name"":""abc"", ""age"":23}'
k.url.postData(""http://www.kooboo.com/fakereceiver"", data); ")]
        public string postform(string url, string data)
        {
            return _PostForm(url, data).Result;
        }

        [Description(@"Post form data to remote url
var data = {
    name:'abc',
    age:123
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data); ")]
        public string postform(string url, object data)
        {
            string json = JsonHelper.Serialize(data);
            return _PostForm(url, json).Result;
        }

        [Description(@"Post form data to remote url
var data = '{""name"":""abc"", ""age"":23}'
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'xxx'); ")]
        public string postform(string url, string data, string token)
        {
            return _PostForm(url, data, BuildBearerHeader(token)).Result;
        }

        [Description(@"Post form data to remote url
var data = {
    name:'abc',
    age:123
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'xxx'); ")]
        public string postform(string url, object data, string token)
        {
            string json = JsonHelper.Serialize(data);
            return _PostForm(url, json, BuildBearerHeader(token)).Result;
        }

        [Description(@"Post form data to remote url
var data = '{""name"":""abc"", ""age"":23}'
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'admin','abc123'); ")]
        public string postform(string url, string data, string userName, string password)
        {
            return _PostForm(url, data, BuildBasicHeader(userName, password)).Result;
        }

        [Description(@"Post form data to remote url
var data = {
    name:'abc',
    age:123
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,'admin','abc123'); ")]
        public string postform(string url, object data, string userName, string password)
        {
            string json = JsonHelper.Serialize(data);
            return _PostForm(url, json, BuildBasicHeader(userName, password)).Result;
        }

        [Description(@"Post form data to remote url
var data = '{""name"":""abc"", ""age"":23}'
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,{'Authentication','Bearer xxxx'}); ")]
        public string postform(string url, string data, IDictionary<string, object> headers)
        {
            return _PostForm(url, data, headers).Result;
        }

        [Description(@"Post form data to remote url
var data = {
    name:'abc',
    age:123
}
k.url.postData(""http://www.kooboo.com/fakereceiver"", data,{'Authentication','Bearer xxxx'}); ")]
        public string postform(string url, object data, IDictionary<string, object> headers)
        {
            string json = JsonHelper.Serialize(data);
            return _PostForm(url, json, headers).Result;
        }

        #endregion

        #region downloadZip

        [Description(@"Download zip package by url.")]
        public void DownloadZip(string url)
        {
            HttpClient client = HttpClientHelper.Client;
            var requestMessage = new HttpRequestMessage
            {
                RequestUri = new Uri(url),
                Method = HttpMethod.Get,
            };

            var response = client.SendAsync(requestMessage).Result;
            var bytes = response.Content.ReadAsByteArrayAsync().Result;
            context.Response.Headers.Add("Content-Disposition", response.Content.Headers.ContentDisposition.ToString());
            context.Response.ContentType = "application/zip";
            context.Response.Body = bytes;
        }

        #endregion

        #region helper
        private Dictionary<string, string> getvalues(object obj)
        {

            Dictionary<string, string> result = new Dictionary<string, string>();

            if (obj is IDictionary)
            {
                var dict = obj as IDictionary;
                foreach (var item in dict.Keys)
                {
                    var value = dict[item];

                    if (obj is IDictionary<String, Object> value)
                    {
                        result.Add(item.ToString(), value.ToString());
                    }
                    else
                    {
                        result.Add(item.ToString(), string.Empty);
                    }
                }

            }

            else if (obj is System.Dynamic.ExpandoObject)
            {
                if (obj is IDictionary<String, Object> value)
                {
                    foreach (var item in value)
                    {
                        if (item.Value != null)
                        {
                            result.Add(item.Key, item.Value.ToString());
                        }
                        else
                        {
                            result.Add(item.Key, string.Empty);
                        }
                    }
                }

            }
            else if (obj is IDictionary<string, object>)
            {
                if (obj is IDictionary<String, Object> value)
                {
                    foreach (var item in value)
                    {
                        if (item.Value != null)
                        {
                            result.Add(item.Key, item.Value.ToString());
                        }
                        else
                        {
                            result.Add(item.Key, string.Empty);
                        }
                    }
                }
            }

            return result;
        }

        private static async Task<string> _get(string url, Dictionary<string, string> query = null, IDictionary<string, object> headers = null)
        {

            try
            {
                if (query != null)
                {
                    url = UrlHelper.AppendQueryString(url, query);
                }

                HttpClient client = HttpClientHelper.Client;

                var requestMessage = new HttpRequestMessage
                {
                    RequestUri = new Uri(url),
                    Method = HttpMethod.Get
                };

                if (headers != null)
                {
                    foreach (var item in headers)
                    {
                        requestMessage.Headers.Add(item.Key, item.Value?.ToString());
                    }
                }

                var response = await client.SendAsync(requestMessage);
                var byteArray = await response.Content.ReadAsByteArrayAsync();
                return Encoding.UTF8.GetString(byteArray, 0, byteArray.Length);
            }
            catch (Exception ex)
            {
                return ex.Message;
            }

        }

        private static async Task<string> _Post(string url, string json, IDictionary<string, object> headers = null)
        {
            try
            {
                var client = HttpClientHelper.Client;

                var content = new StringContent(json, Encoding.UTF8);
                content.Headers.ContentType = new MediaTypeWithQualityHeaderValue("application/json");
                var requestMessage = new HttpRequestMessage
                {
                    RequestUri = new Uri(url),
                    Method = HttpMethod.Post,
                    Content = content,
                };

                if (headers != null)
                {
                    foreach (var item in headers)
                    {
                        requestMessage.Headers.Add(item.Key, item.Value?.ToString());
                    }
                }

                var response = await client.SendAsync(requestMessage);

                var byteArray = await response.Content.ReadAsByteArrayAsync();
                return Encoding.UTF8.GetString(byteArray, 0, byteArray.Length);

            }
            catch (Exception ex)
            {
                return ex.Message;
            }

        }

        private async Task<string> _PostForm(string url, string json, IDictionary<string, object> headers = null)
        {
            string result;
            try
            {
                HttpClient client = HttpClientHelper.Client;
                FormUrlEncodedContent content = new FormUrlEncodedContent(JsonHelper.Deserialize<IDictionary<string, string>>(json));

                HttpRequestMessage httpRequestMessage = new HttpRequestMessage
                {
                    RequestUri = new Uri(url),
                    Method = HttpMethod.Post,
                    Content = content
                };

                if (headers != null)
                {
                    foreach (var item in headers)
                    {
                        httpRequestMessage.Headers.Add(item.Key, item.Value?.ToString());
                    }
                }

                byte[] array = await (await client.SendAsync(httpRequestMessage)).Content.ReadAsByteArrayAsync();
                result = Encoding.UTF8.GetString(array, 0, array.Length);
            }
            catch (Exception ex)
            {
                result = ex.Message;
            }
            return result;
        }

        private static Dictionary<string, object> BuildBearerHeader(string token)
        {
            var header = new Dictionary<string, object>();

            if (!string.IsNullOrEmpty(token))
            {
                header.Add(HttpRequestHeader.Authorization.ToString(), $"Bearer {token}");
            }

            return header;
        }

        private static Dictionary<string, object> BuildBasicHeader(string username, string password)
        {
            var header = new Dictionary<string, object>();

            if (!string.IsNullOrEmpty(username) && !string.IsNullOrEmpty(password))
            {
                var bytes = Encoding.UTF8.GetBytes(String.Format("{0}:{1}", username, password));
                header.Add(HttpRequestHeader.Authorization.ToString(), "Basic " + Convert.ToBase64String(bytes));
            }

            return header;
        }

        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Sites\Scripting\Global\Curl.cs(289,60): error CS0128: A local variable or function named 'value' is already defined in this scope
######################################################################


######################################################################
Nr: 27 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Sites\Service\MenuService.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Kooboo.Data.Models;
using Kooboo.Sites.Models;
using Kooboo.Dom;
using Kooboo.Sites.ViewModel;
using Kooboo.Sites.Repository;
using Kooboo.Sites.Helper; 

namespace Kooboo.Sites.Service
{
    public class MenuService
    {

        public static RawMenu FindRawMenu(Element element)
        {
            var alllinks = element.getElementsByTagName("a").item;
            if (alllinks != null && alllinks.Any())
            {
                var groupby = SimpleGroupBy(alllinks);

                RawMenu menu = new RawMenu();
                AssignSubMenu(groupby[0], menu);
                menu.SubItemContainer = element;
                return menu;
            }
            return null;
        }

        internal static List<List<Element>> SimpleGroupBy(List<Element> LinkElements)
        {
            Func<List<Element>, int> GetFirstLocation = (elements) =>
            {
                int result = int.MaxValue;
                foreach (var item in elements)
                {
                    if (item.location.openTokenStartIndex < result)
                    {
                        result = item.location.openTokenStartIndex; 
                    }
                }
                return result;
            }; 

            var groupby = LinkElements.GroupBy(o => DomService.getParentPath(o));
            
            List<List<Element>> sortedlist = new List<List<Element>>(); 

            foreach (var item in groupby.OrderBy(o => GetFirstLocation(o.ToList())))
            {
                sortedlist.Add(item.ToList()); 
            } 
            return sortedlist; 
        }

        public static void AssignSubMenu(List<Element> Links, RawMenu ParentMenu)
        {
            var commonparent = DomService.FindParent(Links);

            foreach (var item in Links)
            {
                var menu = new RawMenu();
                menu.Parent = ParentMenu;
                menu.LinkElement = item;
                menu.ContainerElement = FindLinkContainer(item, Links, commonparent);
                menu.Parent = ParentMenu;
                ParentMenu.Children.Add(menu);
            }

            foreach (var item in ParentMenu.Children)
            {
                var sublinks = FindSubLinks(item);
                if (sublinks != null && sublinks.Any())
                {
                    var itemcontainer = DomService.FindParent(sublinks);
                    AssignSubMenu(sublinks, item);
                }
            }
            return;
        }

        public static List<Element> FindSubLinks(RawMenu menu)
        {
            var Sublinks = GetDirectSubLinks(menu.LinkElement, menu.ContainerElement);
            if (Sublinks != null && Sublinks.Any())
            {
                return Sublinks;
            }

            return GetSiblingSubLinks(menu.ContainerElement, menu.NextContainer());
        }

        internal static List<Element> GetDirectSubLinks(Element LinkElement, Element Container)
        {
            var alllinks = Container.getElementsByTagName("a").item;

            alllinks.Remove(LinkElement);

            if (alllinks.Any())
            {
                var groupby = GroupBy(alllinks);
                return groupby[0];
            }
            return null;
        }

        internal static List<Element> GetSiblingSubLinks(Element CurrentContainer, Element NextContainer)
        {
            List<Node> BetweenNodes = new List<Node>();

            int MaxSiblingIndex = 9999;
            if (NextContainer != null)
            {
                MaxSiblingIndex = NextContainer.siblingIndex;
                var parent = DomService.FindParent(CurrentContainer, NextContainer);

                var current = CurrentContainer;
                while (current.depth > parent.depth + 1)
                {
                    current = current.parentElement;
                }

                var next = NextContainer;
                while (next.depth > parent.depth + 1)
                {
                    next = next.parentElement;
                }
                var NodesInBetween = parent.childNodes.item.Where(o => o.siblingIndex > current.siblingIndex && o.siblingIndex < next.siblingIndex).ToList();

                var alllinks = DomService.GetElementsByTagName(NodesInBetween, "a").item;
                if (alllinks.Any())
                {
                    var group = GroupBy(alllinks);
                    return group[0];
                }

            }
            else
            {

                var parent = CurrentContainer.parentElement;

                var NodesInBetween = parent.childNodes.item.Where(o => o.siblingIndex > CurrentContainer.siblingIndex).ToList();

                var alllinks = DomService.GetElementsByTagName(NodesInBetween, "a").item;
                if (alllinks.Any())
                {
                    var group = GroupBy(alllinks);
                    return group[0];
                }

            }


            return null;

        }


        public static void AddNewMenu(SiteDb SiteDb, Page page, MenuViewModel NewMenuViewModel)
        {
            // menu view can start only with item container. 
            Menu menu = CreateMenu(page.Dom, NewMenuViewModel);

            if (string.IsNullOrEmpty(menu.Name))
            {
                menu.Name = SiteDb.Menus.GetNewMenuName();
            }

            SiteDb.Menus.AddOrUpdate(menu);

            var maincontainer = NewMenuViewModel.ItemContainer;

            var element = DomService.GetElementByKoobooId(page.Dom, maincontainer);

            string newbody = page.Body.Substring(0, element.location.openTokenStartIndex);
            newbody += "<menu id='" + menu.Name + "'></menu>";
            newbody += page.Body.Substring(element.location.endTokenEndIndex + 1);

            page.Body = newbody;
            SiteDb.Pages.AddOrUpdate(page);

        }

        public static Element FindLinkContainer(Element Link, List<Element> LinkGroup, Element CommonParent)
        {
            var target = Link;

            var DirectParent = target;

            while (DirectParent != null && !DirectParent.isEqualNode(CommonParent))
            {
                foreach (var item in LinkGroup)
                {
                    if (!item.isEqualNode(Link))
                    {
                        if (DomService.ContainsOrEqualElement(DirectParent, item))
                        {
                            break;
                        }
                    }
                }

                target = DirectParent;
                DirectParent = target.parentElement;
            }

            return target;

        }

        public static Menu CreateMenu(Document doc, MenuViewModel MenuViewModel)
        {
            Menu menu = new Menu();
            Element LinkElement = null;
            Element ItemContainer = null;
            Element ContainerElement = null;

            int MenuTemplateStart = int.MaxValue;
            int MenuTemplaetEnd = 0;

            if (!string.IsNullOrEmpty(MenuViewModel.LinkElement) && !string.IsNullOrEmpty(MenuViewModel.ContainerElement))
            {
                var linkelement = DomService.GetElementByKoobooId(doc, MenuViewModel.LinkElement);
                if (linkelement != null)
                {
                    LinkElement = linkelement as Element;
                }

                var container = DomService.GetElementByKoobooId(doc, MenuViewModel.ContainerElement);
                if (container == null && linkelement != null)
                {
                    container = linkelement;
                }
                if (container != null)
                {
                    ContainerElement = container as Element;
                    MenuTemplateStart = ContainerElement.location.openTokenStartIndex;
                    MenuTemplaetEnd = ContainerElement.location.endTokenEndIndex;
                }
            }

            string SubMenuItemsTemplate = null;
            string SubMenuItemOrginalString = null;
            int SubMenuStart = int.MaxValue;
            int SubMenuEnd = 0;

            if (MenuViewModel.children.Count > 0)
            {
                List<Menu> SubMenus = new List<Menu>();

                foreach (var item in MenuViewModel.children)
                {
                    Menu submenu = CreateMenu(doc, item);
                    if (submenu != null)
                    {
                        SubMenus.Add(submenu);
                        if (submenu.tempdata.StartIndex < SubMenuStart)
                        {
                            SubMenuStart = submenu.tempdata.StartIndex;
                        }
                        if (submenu.tempdata.EndIndex > SubMenuEnd)
                        {
                            SubMenuEnd = submenu.tempdata.EndIndex;
                        }
                    }
                }

                ItemContainer = _GetItemContainer(doc, MenuViewModel);

                string SubMenuString = doc.HtmlSource.Substring(SubMenuStart, SubMenuEnd - SubMenuStart + 1);

                if (ItemContainer != null)
                {
                    // 1, sub item within the link element...
                    if (ContainerElement == null || DomService.ContainsOrEqualElement(ContainerElement, ItemContainer))
                    {
                        SubMenuItemOrginalString = ItemContainer.OuterHtml;
                        SubMenuItemsTemplate = SubMenuItemOrginalString.Replace(SubMenuString, MenuHelper.MarkSubItems); 
                    }
                    else if (ContainerElement.isEqualNode(ItemContainer))
                    {
                        SubMenuItemOrginalString = SubMenuString;
                        SubMenuItemsTemplate = MenuHelper.MarkSubItems;
                    }

                    else
                    {
                        var distance = DomService.GetTreeDistance(ContainerElement, ItemContainer);
                        bool sibling = false;
                        if (distance == 1)
                        {
                            sibling = true;
                        }
                        else if (distance < 5)
                        {
                            var nodes = DomService.GetNodesInBetween(doc, ContainerElement, ItemContainer);
                            if (nodes == null || nodes.Count == 0 || IsPossibleSeperator(nodes))
                            {
                                sibling = true;
                            }
                        }

                        if (sibling)
                        {
                            if (MenuTemplateStart > ItemContainer.location.openTokenStartIndex)
                            {
                                MenuTemplateStart = ItemContainer.location.openTokenStartIndex;
                            }

                            if (MenuTemplaetEnd < ItemContainer.location.endTokenEndIndex)
                            {
                                MenuTemplaetEnd = ItemContainer.location.endTokenEndIndex;
                            }

                            SubMenuItemOrginalString = ItemContainer.OuterHtml;
                            SubMenuItemsTemplate = SubMenuItemOrginalString.Replace(SubMenuString, MenuHelper.MarkSubItems);
                        }

                        else
                        {
                            //menu.RenderSubMenuSeperated = true;
                            SubMenuItemOrginalString = ItemContainer.OuterHtml;
                            SubMenuItemsTemplate = ItemContainer.OuterHtml.Replace(SubMenuString, MenuHelper.MarkSubItems);
                        }
                    }
                }

                if (SubMenus.Count > 0)
                {
                    menu.children.AddRange(SubMenus);
                }
            }

            if (MenuTemplateStart > 0 && MenuTemplaetEnd > 0)
            {
                string menutemplate = doc.HtmlSource.Substring(MenuTemplateStart, MenuTemplaetEnd - MenuTemplateStart + 1);

                if (!string.IsNullOrEmpty(SubMenuItemOrginalString))
                {
                    menutemplate = menutemplate.Replace(SubMenuItemOrginalString, MenuHelper.MarkSubItems);
                }

                string OriginalLink = LinkElement.OuterHtml;
                string NewLInk = DomService.ReplaceLink(LinkElement, MenuHelper.MarkHref, MenuHelper.MarkAnchorText);
                menutemplate = menutemplate.Replace(OriginalLink, NewLInk);
                menu.Template = menutemplate;
                menu.Name = MenuViewModel.text;
                menu.Url = MenuViewModel.href;
            }

            menu.SubItemContainer = SubMenuItemsTemplate;

            menu.tempdata.StartIndex = MenuTemplateStart;
            menu.tempdata.EndIndex = MenuTemplaetEnd;

            if (menu.tempdata.StartIndex == 0 || menu.tempdata.EndIndex == 0)
            {
                if (ItemContainer != null)
                {
                    menu.tempdata.StartIndex = ItemContainer.location.openTokenStartIndex;
                    menu.tempdata.EndIndex = ItemContainer.location.endTokenEndIndex;
                }
            }
            return menu;
        }

        private static Element _GetItemContainer(Document doc, MenuViewModel MenuViewModel)
        {
            // find the item container. 
            if (!string.IsNullOrEmpty(MenuViewModel.ItemContainer))
            {
                var itemcontainer = DomService.GetElementByKoobooId(doc, MenuViewModel.ItemContainer) as Element;
                if (itemcontainer != null)
                {
                    return itemcontainer;
                }
            }

            List<Element> containerlist = new List<Element>();
            foreach (var item in MenuViewModel.children)
            {
                if (!string.IsNullOrEmpty(item.ContainerElement))
                {
                    var element = DomService.GetElementByKoobooId(doc, item.ContainerElement) as Element;
                    if (element != null)
                    {
                        containerlist.Add(element);
                    }
                }
            }

            if (containerlist.Count == 0)
            {
                foreach (var item in MenuViewModel.children)
                {
                    var element = DomService.GetElementByKoobooId(doc, item.LinkElement) as Element;
                    if (element != null)
                    {
                        containerlist.Add(element);
                    }
                }
            }
            if (containerlist.Count > 1)
            {
                var element = DomService.FindParent(containerlist);
                if (element != null)
                {
                    MenuViewModel.ItemContainer = DomService.GetKoobooId(element);
                }
                return element;
            }
            return null;
        }

        /// <summary>
        /// Group by the links into different menu group. 
        /// </summary>
        /// <param name="linkelements"></param>
        /// <param name="ReduceGroup">Reduce the sub group within another group.... like sub menus within the main menu will be reduced.</param>
        /// <returns></returns>
        public static List<List<Element>> GroupBy(List<Element> linkelements, bool ReduceGroup = true)
        {
            List<List<Element>> result = new List<List<Element>>();

            int count = linkelements.Count;

            if (count == 0)
            {
                return result;
            }
            else if (count == 1)
            {
                result.Add(linkelements);
                return result;
            }

            List<Element> sorted = linkelements.OrderBy(o => o.depth).ThenBy(o => o.location.openTokenStartIndex).ToList();

            Element previous = null;
            Element current = null;
            bool addnewgroup = false;

            for (int i = 0; i < count; i++)
            {
                addnewgroup = false;
                ///The first one... 
                if (i == 0)
                {
                    addnewgroup = true;
                }
                else
                {
                    previous = sorted[i - 1];
                    current = sorted[i];

                    if (previous.depth != current.depth)
                    {
                        addnewgroup = true;
                    }
                    else
                    {
                        if (!IsElementNextToEachOther(current, previous))
                        {
                            addnewgroup = true;
                        }
                        else
                        {
                            /// if there is already a group and, this new member belongs to the same parent, then it belongs to the same group. 
                            if (result.LastOrDefault().Count > 1)
                            {
                                var currentlist = result.LastOrDefault();
                                var itemone = currentlist[currentlist.Count - 2];
                                var itemtwo = currentlist[currentlist.Count - 1];
                                var parent = Kooboo.Sites.Service.DomService.FindParent(itemone, itemtwo);

                                /// if there is longer distance.... 
                                if (Kooboo.Sites.Service.DomService.GetTreeDistance(current, itemtwo) > Kooboo.Sites.Service.DomService.GetTreeDistance(itemtwo, itemone))
                                {
                                    addnewgroup = true;
                                }

                                else
                                {
                                    var currentparent = Kooboo.Sites.Service.DomService.FindParent(itemone, current);
                                    if (!parent.isEqualNode(currentparent))
                                    {
                                        addnewgroup = true;
                                    }
                                }
                            }
                            else
                            {
                                // count = 1;     
                                var lastelement = result.LastOrDefault()[0];
                                var parent = Kooboo.Sites.Service.DomService.FindParent(current, lastelement);

                                if (parent.tagName != "ul" || parent.tagName != "nav")
                                {
                                    if (parent.tagName == "body")
                                    {
                                        addnewgroup = true;
                                    }

                                    //TODO: to be improve more rules...... 
                                }
                            }
                        }
                    }
                }

                if (addnewgroup)
                {
                    List<Element> firstlist = new List<Element>();
                    firstlist.Add(sorted[i]);
                    result.Add(firstlist);
                }
                else
                {

                    if (result.Count > 0)
                    {
                        result.LastOrDefault().Add(current);
                    }
                }
            }
            if (ReduceGroup)
            {
                ReduceGroupBy(result);
            }
            return result;
        }

        private static string ConvertToTemplate(Element linkElement, string href, string anchortext)
        {
            string all = linkElement.OuterHtml;
            all = all.Replace(anchortext, "{anchortext}");
            all = all.Replace(href, "{href}");
            return all;
        }
        /// <summary>
        /// Test that this two elements are next to each other, this is for menu detection. 
        /// for the menu with ul/li, this seems like enough. 
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        public static bool IsElementNextToEachOther(Element x, Element y)
        {
            if (x.depth != y.depth)
            {
                return false;
            }

            if (x.tagName != y.tagName)
            {
                return false;
            }

            // first check their physical location is very closer to each other. 
            if (x.location.openTokenStartIndex > y.location.openTokenStartIndex)
            {
                Element t = x;
                x = y;
                y = t;
            }

            int betweencount = y.location.openTokenStartIndex - x.location.endTokenEndIndex;

            if (betweencount < 10)
            {
                return true;
            }

            else
            {
                string betweentext = x.ownerDocument.HtmlSource.Substring(x.location.endTokenEndIndex + 1, betweencount);

                betweentext = betweentext.Replace(" ", "");
                betweentext = betweentext.Replace(Environment.NewLine, "");

                if (betweentext.Length < 10)
                {
                    return true;
                }
            }

            // check parents. 
            if (x.parentElement.tagName == "li" && y.parentElement.tagName == "li")
            {
                return IsElementNextToEachOther(x.parentElement, y.parentElement);
            }

            int treedistance = Kooboo.Sites.Service.DomService.GetTreeDistance(x, y);

            //TODO: Test that they have the same parent path and distance % 10 ==0.
            if (treedistance < 10 || treedistance % 10 == 0)
            {
                if (Kooboo.Sites.Service.DomService.getParentPath(x) == Kooboo.Sites.Service.DomService.getParentPath(y))
                {
                    return true;
                }
            }


            return false;
        }

        /// <summary>
        /// Convert one link item with its parent element into one menu item... 
        /// example: Li, a, website..... Convert the a under li tag into one mentu.... 
        /// </summary>
        /// <param name="parentElement"></param>
        /// <param name="linkElement"></param>
        /// <param name="website"></param>
        /// <returns></returns>
        public static Menu ConvertToMenu(Element parentElement, Element linkElement, WebSite website)
        {
            Menu menu = new Menu();

            string template = parentElement.OuterHtml;

            string anchortext = linkElement.InnerHtml;
            string href = linkElement.getAttribute("href");
            template = template.Replace(linkElement.OuterHtml, ConvertToTemplate(linkElement, href, anchortext));

            menu.Template = template;
            menu.Name = anchortext;
            menu.Url = href;

            // Check if there is a submenu.... 
            var alllinks = parentElement.getElementsByTagName("a").item;

            if (alllinks.Count > 1)
            {
                /// there is sub menu...
                List<Element> sublinks = new List<Element>();

                string mainhref = linkElement.getAttribute("href");

                foreach (var item in alllinks)
                {
                    string subhref = item.getAttribute("href");

                    if (subhref != mainhref)
                    {
                        sublinks.Add(item);
                    }
                }

                if (sublinks.Any())
                {
                    int SubGroupStartIndex;
                    int SubGroupEndIndex;

                    var groupby = GroupBy(sublinks);

                    if (groupby.Count == 1)
                    {
                        var submenulinks = groupby[0];

                        SubGroupStartIndex = submenulinks.First().location.openTokenStartIndex;
                        SubGroupEndIndex = submenulinks.Last().location.endTokenEndIndex;

                        var subcommonparent = DomService.FindParent(submenulinks);
                        bool includeparent = true;

                        if (subcommonparent.isEqualNode(linkElement) || subcommonparent.isEqualNode(parentElement))
                        {
                            includeparent = false;
                        }

                        var submenu = ConvertToMenu(submenulinks, subcommonparent, includeparent, website);

                        if (submenu.tempdata.EndIndex > SubGroupEndIndex)
                        {
                            SubGroupEndIndex = submenu.tempdata.EndIndex;
                        }

                        if (submenu.tempdata.StartIndex < SubGroupStartIndex)
                        {
                            SubGroupStartIndex = submenu.tempdata.StartIndex;
                        }

                        menu.SubItemContainer = submenu.Template;
                        // menu.SubItemSeperator = submenu.SubItemSeperator;
                        menu.children = submenu.children;
                    }

                    else
                    {
                        SubGroupStartIndex = groupby.First().First().location.openTokenStartIndex;
                        SubGroupEndIndex = groupby.Last().Last().location.endTokenEndIndex;

                        foreach (var item in groupby)
                        {
                            var commonparent = DomService.FindParent(item);
                            bool includeparentintemplate = false;

                            if (!commonparent.isEqualNode(parentElement) && commonparent.depth > parentElement.depth)
                            {
                                includeparentintemplate = true;
                            }

                            var submenu = ConvertToMenu(item, commonparent, includeparentintemplate, website);
                            // menu.Template = menu.Template.Replace(submenu.tempdata.TempOriginalText, placeholder);

                            if (submenu.tempdata.EndIndex > SubGroupEndIndex)
                            {
                                SubGroupEndIndex = submenu.tempdata.EndIndex;
                            }

                            if (submenu.tempdata.StartIndex < SubGroupStartIndex)
                            {
                                SubGroupStartIndex = submenu.tempdata.StartIndex;
                            }

                            menu.AddSubMenu(submenu);
                        }

                        // try to find the seperator.... 
                        List<Element> parents = new List<Element>();
                        parents.Add(groupby[0].Last());
                        parents.Add(groupby[1].First());
                        //var seperatorparent = FindCommonParent(parents);
                        //var seperator = FindSeperator(parents, seperatorparent);
                        //if (!string.IsNullOrEmpty(seperator))
                        //{
                        //    menu.SubItemSeperator = seperator;
                        //}
                    }

                    string subgrouptext = parentElement.ownerDocument.HtmlSource.Substring(SubGroupStartIndex, SubGroupEndIndex - SubGroupStartIndex + 1);

                    menu.Template = menu.Template.Replace(subgrouptext, "{items}");

                }
            }

            return menu;

        }

        /// <summary>
        /// Convert one group of links into menu, links must be within one group. 
        /// </summary>
        /// <param name="links"></param>
        /// <param name="website"></param>
        /// <param name="IncludeParentInTemplate"></param>
        /// <param name="maxsiblingindex">if this links group share parents with another link group, should only check sub menu till end of next sibling start. </param>
        /// <returns></returns>
        public static Menu ConvertToMenu(List<Element> links, WebSite website)
        {
            bool includeparentintemplate = true;
            int maxsilbingindex = 9999;

            links = links.OrderBy(o => o.location.openTokenStartIndex).ToList();
            Element commonparent = DomService.FindParent(links);
            var lastlink = links.LastOrDefault();

            TestTemplate(ref includeparentintemplate, ref maxsilbingindex, commonparent, lastlink);

            return ConvertToMenu(links, commonparent, includeparentintemplate, website, maxsilbingindex);
        }


        /// <summary>
        /// This is to test whether the parentelement can be used as the menu template or not. 
        /// </summary>
        /// <param name="includeparentintemplate"></param>
        /// <param name="maxsilbingindex"></param>
        /// <param name="commonparent"></param>
        /// <param name="lastlink"></param>
        private static void TestTemplate(ref bool includeparentintemplate, ref int maxsilbingindex, Element commonparent, Element lastlink)
        {
            var linksafter = FindLinksAfter(commonparent, lastlink);

            foreach (var item in linksafter)
            {
                /// if the link is similiar, it is same level links instead of sub menu..
                if (isSimiliarLink(lastlink, item))
                {
                    includeparentintemplate = false;
                    var parent = item;
                    while (!item.isEqualNode(commonparent))
                    {
                        parent = parent.parentElement;
                    }
                    maxsilbingindex = parent.siblingIndex;
                    break;

                }
            }

            var subparent = lastlink;
            while (true)
            {
                var tempparent = subparent.parentElement;

                if (tempparent != null && !tempparent.isEqualNode(commonparent) && tempparent.depth > commonparent.depth)
                {
                    subparent = tempparent;
                }
                else
                {
                    break;
                }
            }


            foreach (var item in commonparent.childNodes.item.Where(o => o.siblingIndex > subparent.siblingIndex).ToList())
            {
                if (!IsPossibleSeperator(item))
                {
                    includeparentintemplate = false;
                    maxsilbingindex = item.siblingIndex;
                    break;
                }
            }
            /// 
        }

        /// <summary>
        /// convert one parent with sub links into a menu.... 
        /// </summary>
        /// <param name="links"></param>
        /// <param name="CommonParent"></param>
        /// <param name="IncludeParentInTemplate"></param>
        /// <param name="website"></param>
        /// <returns></returns>
        public static Menu ConvertToMenu(List<Element> links, Element CommonParent, bool IncludeParentInTemplate, WebSite website, int maxsiblingindex = 9999)
        {
            Menu menu = new Menu();

            links = links.OrderBy(o => o.location.openTokenStartIndex).ToList();

            List<Element> Parents = new List<Element>();

            int count = links.Count;
            for (int i = 0; i < count; i++)
            {
                var parent = links[i];
                while (!parent.parentElement.isEqualNode(CommonParent) && parent != null)
                {
                    parent = parent.parentElement;
                }
                Parents.Add(parent);
            }

            menu.tempdata.StartIndex = Parents[0].location.openTokenStartIndex;
            menu.tempdata.EndIndex = Parents[count - 1].location.endTokenEndIndex;

            for (int i = 0; i < count; i++)
            {
                var parent = Parents[i];
                var linkelement = links[i];

                Menu submenu = ConvertToMenu(parent, links[i], website);

                if (submenu.children.Count == 0)
                {
                    int nextSiblingEnds = maxsiblingindex;
                    if (i < count - 1)
                    {
                        var nextparent = Parents[i + 1];
                        nextSiblingEnds = nextparent.siblingIndex;
                    }

                    var tempsublinks = FindLinksAfter(CommonParent, links[i], nextSiblingEnds);

                    /// Check and make sure those sub links are not similar, same level links. 
                    List<Element> sublinks = new List<Element>();

                    if (tempsublinks.Count > 0)
                    {
                        foreach (var item in tempsublinks)
                        {
                            if (isSimiliarLink(item, linkelement))
                            {
                                break;
                            }
                            sublinks.Add(item);
                        }

                        var groupbylinks = GroupBy(sublinks);

                        foreach (var item in groupbylinks)
                        {
                            var subcommonparent = DomService.FindParent(item);

                            bool SubIncludeParent = false;

                            if (!subcommonparent.isEqualNode(CommonParent) && subcommonparent.depth < CommonParent.depth)
                            {
                                SubIncludeParent = true;
                            }
                            Menu subsubmenu = ConvertToMenu(item, subcommonparent, SubIncludeParent, website);

                            submenu.AddSubMenu(subsubmenu);
                        }
                    }
                }

                menu.AddSubMenu(submenu);
            }

            string menuitemsstring = CommonParent.ownerDocument.HtmlSource.Substring(menu.tempdata.StartIndex, menu.tempdata.EndIndex - menu.tempdata.StartIndex + 1);

            if (IncludeParentInTemplate)
            {

                string tempTemplate = CommonParent.OuterHtml;
                menu.Template = tempTemplate.Replace(menuitemsstring, "{items}");

                if (CommonParent.location.openTokenStartIndex < menu.tempdata.StartIndex)
                {
                    menu.tempdata.StartIndex = CommonParent.location.openTokenStartIndex;
                }

                if (CommonParent.location.endTokenEndIndex > menu.tempdata.EndIndex)
                {
                    menu.tempdata.EndIndex = CommonParent.location.endTokenEndIndex;
                }
            }
            else
            {
                menu.Template = "{items}";
            }

            return menu;
        }

        /// <summary>
        /// Find link items after one item.... 
        /// </summary>
        /// <param name="CommonParent"></param>
        /// <param name="linkitem"></param>
        /// <param name="SiblingIndex"></param>
        /// <returns></returns>
        public static List<Element> FindLinksAfter(Element CommonParent, Element linkitem, int MaxSiblingIndex = 9999)
        {
            var parent = linkitem;
            while (!parent.parentElement.isEqualNode(CommonParent))
            {
                parent = parent.parentElement;
            }

            var NodesInBetween = CommonParent.childNodes.item.Where(o => o.siblingIndex > parent.siblingIndex && o.siblingIndex < MaxSiblingIndex).ToList();

            return Kooboo.Sites.Service.DomService.GetElementsByTagName(NodesInBetween, "a").item;

        }

        /// <summary>
        /// similar links means same level of menu instead of sub menu.... 
        /// </summary>
        /// <param name="linkx"></param>
        /// <param name="linky"></param>
        /// <returns></returns>
        private static bool isSimiliarLink(Element linkx, Element linky)
        {
            return (linkx.depth == linky.depth && Kooboo.Sites.Service.DomService.getParentPath(linkx) == Kooboo.Sites.Service.DomService.getParentPath(linky));
        }

        internal static void ReduceGroupBy(List<List<Element>> groupbylist)
        {
            //remove links that are within range of another links.
            List<Kooboo.Lib.DataType.MultiItems<int>> items = new List<Lib.DataType.MultiItems<int>>();

            int groupcount = groupbylist.Count;

            for (int i = 0; i < groupcount; i++)
            {
                Kooboo.Lib.DataType.MultiItems<int> newitem = new Lib.DataType.MultiItems<int>();
                newitem.Item1 = i;

                var lists = groupbylist[i].OrderBy(o => o.location.openTokenStartIndex).ToList();

                newitem.Item2 = lists[0].location.openTokenStartIndex;
                newitem.Item3 = lists[lists.Count - 1].location.endTokenEndIndex;

                items.Add(newitem);
            }

            List<int> toberemoved = new List<int>();

            for (int i = 0; i < groupcount; i++)
            {
                List<Element> item = groupbylist[i];

                var itemlist = item.OrderBy(o => o.location.openTokenStartIndex).ToList();
                int beginindex = itemlist.FirstOrDefault().location.openTokenStartIndex;
                int endindex = itemlist.LastOrDefault().location.endTokenEndIndex;

                foreach (var positionitem in items)
                {
                    if (i != positionitem.Item1)
                    {
                        if (beginindex >= positionitem.Item2 && endindex <= positionitem.Item3)
                        {
                            toberemoved.Add(i);
                            break;
                        }
                    }
                }
            }

            toberemoved.Reverse();

            foreach (var item in toberemoved)
            {
                groupbylist.RemoveAt(item);
            }

        }

        private static bool IsPossibleSeperator(Node node)
        {
            if (node is Element)
            {
                Element e = node as Element;
                var links = e.getElementsByTagName("a").item;
                if (links != null && links.Count > 0)
                {
                    return false;
                }
            }

            string textcontent = node.textContent.Trim(new char[] { '\r', '\n', ' ' });

            //if (string.IsNullOrEmpty(textcontent))
            //{ // return false; //}

            textcontent = System.Web.HttpUtility.HtmlDecode(textcontent);

            foreach (var item in textcontent.ToCharArray())
            {
                if (Kooboo.Dom.CommonIdoms.isAlphanumeric(item))
                {
                    return false;
                }
            }
            return true;
        }

        private static bool IsPossibleSeperator(List<Node> nodes)
        {
            foreach (var item in nodes)
            {
                if (!IsPossibleSeperator(item))
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// used when there is only one link 
        /// </summary>
        /// <param name="currentParentFound"></param>
        /// <returns></returns>
        public static Element TryUpgrade(Element currentParentFound)
        {
            // rule 1, if the parent has only one sub element and no other element, should upgrade... 
            var parent = currentParentFound.parentElement;

            foreach (var item in parent.childNodes.item)
            {
                if (!item.isEqualNode(currentParentFound))
                {
                    if (item is Element)
                    {
                        return currentParentFound;
                    }
                    else if (item is Kooboo.Dom.Text)
                    {
                        Kooboo.Dom.Text text = item as Kooboo.Dom.Text;
                        string content = text.textContent;
                        content = content.Trim(new char[] { '\r', '\n', ' ' });

                        if (!string.IsNullOrEmpty(content))
                        {
                            return currentParentFound;
                        }
                    }

                }
            }

            return TryUpgrade(parent);

        }

    }


    public class RawMenu
    {
        public RawMenu()
        {
            this.Children = new List<RawMenu>();
        }
        public Element LinkElement { get; set; }

        public Element ContainerElement { get; set; }

        public Element SubItemContainer { get; set; }

        public List<RawMenu> Children { get; set; }

        public RawMenu Parent { get; set; }

        public Element NextContainer()
        {
            if (Parent == null)
            {
                return null;
            } 
            int currentindex = this.ContainerElement.location.openTokenStartIndex;

            if (currentindex >= 0 && this.Parent.Children.Any())
            {
                var others = this.Parent.Children.Where(o => o.ContainerElement.location.openTokenStartIndex > currentindex);
                if (others != null && others.Any())
                {
                    return others.OrderBy(o => o.ContainerElement.location.openTokenStartIndex).First().ContainerElement;
                }
            }
            return null;
        }

    }

}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Kooboo.Data.Models;
using Kooboo.Sites.Models;
using Kooboo.Dom;
using Kooboo.Sites.ViewModel;
using Kooboo.Sites.Repository;
using Kooboo.Sites.Helper; 

namespace Kooboo.Sites.Service
{
    public class MenuService
    {

        public static RawMenu FindRawMenu(Element element)
        {
            var alllinks = element.getElementsByTagName("a").item;
            if (alllinks != null && alllinks.Any())
            {
                var groupby = SimpleGroupBy(alllinks);

                RawMenu menu = new RawMenu();
                AssignSubMenu(groupby[0], menu);
                menu.SubItemContainer = element;
                return menu;
            }
            return null;
        }

        internal static List<List<Element>> SimpleGroupBy(List<Element> LinkElements)
        {
            Func<List<Element>, int> GetFirstLocation = (elements) =>
            {
                int result = int.MaxValue;
                foreach (var item in elements)
                {
                    if (item.location.openTokenStartIndex < result)
                    {
                        result = item.location.openTokenStartIndex; 
                    }
                }
                return result;
            }; 

            var groupby = LinkElements.GroupBy(o => DomService.getParentPath(o));
            
            List<List<Element>> sortedlist = new List<List<Element>>(); 

            foreach (var item in groupby.OrderBy(o => GetFirstLocation(o.ToList())))
            {
                sortedlist.Add(item.ToList()); 
            } 
            return sortedlist; 
        }

        public static void AssignSubMenu(List<Element> Links, RawMenu ParentMenu)
        {
            var commonparent = DomService.FindParent(Links);

            foreach (var item in Links)
            {
                var menu = new RawMenu();
                menu.Parent = ParentMenu;
                menu.LinkElement = item;
                menu.ContainerElement = FindLinkContainer(item, Links, commonparent);
                menu.Parent = ParentMenu;
                ParentMenu.Children.Add(menu);
            }

            foreach (var item in ParentMenu.Children)
            {
                var sublinks = FindSubLinks(item);
                if (sublinks != null && sublinks.Any())
                {
                    var itemcontainer = DomService.FindParent(sublinks);
                    AssignSubMenu(sublinks, item);
                }
            }
            return;
        }

        public static List<Element> FindSubLinks(RawMenu menu)
        {
            var Sublinks = GetDirectSubLinks(menu.LinkElement, menu.ContainerElement);
            if (Sublinks != null && Sublinks.Any())
            {
                return Sublinks;
            }

            return GetSiblingSubLinks(menu.ContainerElement, menu.NextContainer());
        }

        internal static List<Element> GetDirectSubLinks(Element LinkElement, Element Container)
        {
            var alllinks = Container.getElementsByTagName("a").item;

            alllinks.Remove(LinkElement);

            if (alllinks.Any())
            {
                var groupby = GroupBy(alllinks);
                return groupby[0];
            }
            return null;
        }

        internal static List<Element> GetSiblingSubLinks(Element CurrentContainer, Element NextContainer)
        {
            List<Node> BetweenNodes = new List<Node>();

            int MaxSiblingIndex = 9999;
            if (NextContainer != null)
            {
                MaxSiblingIndex = NextContainer.siblingIndex;
                var parent = DomService.FindParent(CurrentContainer, NextContainer);

                var current = CurrentContainer;
                while (current.depth > parent.depth + 1)
                {
                    current = current.parentElement;
                }

                var next = NextContainer;
                while (next.depth > parent.depth + 1)
                {
                    next = next.parentElement;
                }
                var NodesInBetween = parent.childNodes.item.Where(o => o.siblingIndex > current.siblingIndex && o.siblingIndex < next.siblingIndex).ToList();

                var alllinks = DomService.GetElementsByTagName(NodesInBetween, "a").item;
                if (alllinks.Any())
                {
                    var group = GroupBy(alllinks);
                    return group[0];
                }

            }
            else
            {

                var parent = CurrentContainer.parentElement;

                var NodesInBetween = parent.childNodes.item.Where(o => o.siblingIndex > CurrentContainer.siblingIndex).ToList();

                var alllinks = DomService.GetElementsByTagName(NodesInBetween, "a").item;
                if (alllinks.Any())
                {
                    var group = GroupBy(alllinks);
                    return group[0];
                }

            }


            return null;

        }


        public static void AddNewMenu(SiteDb SiteDb, Page page, MenuViewModel NewMenuViewModel)
        {
            // menu view can start only with item container. 
            Menu menu = CreateMenu(page.Dom, NewMenuViewModel);

            if (string.IsNullOrEmpty(menu.Name))
            {
                menu.Name = SiteDb.Menus.GetNewMenuName();
            }

            SiteDb.Menus.AddOrUpdate(menu);

            var maincontainer = NewMenuViewModel.ItemContainer;

            var element = DomService.GetElementByKoobooId(page.Dom, maincontainer);

            string newbody = page.Body.Substring(0, element.location.openTokenStartIndex);
            newbody += "<menu id='" + menu.Name + "'></menu>";
            newbody += page.Body.Substring(element.location.endTokenEndIndex + 1);

            page.Body = newbody;
            SiteDb.Pages.AddOrUpdate(page);

        }

        public static Element FindLinkContainer(Element Link, List<Element> LinkGroup, Element CommonParent)
        {
            var target = Link;

            var DirectParent = target;

            while (DirectParent != null && !DirectParent.isEqualNode(CommonParent))
            {
                foreach (var item in LinkGroup)
                {
                    if (!item.isEqualNode(Link))
                    {
                        if (DomService.ContainsOrEqualElement(DirectParent, item))
                        {
                            break;
                        }
                    }
                }

                target = DirectParent;
                DirectParent = target.parentElement;
            }

            return target;

        }

        public static Menu CreateMenu(Document doc, MenuViewModel MenuViewModel)
        {
            Menu menu = new Menu();
            Element LinkElement = null;
            Element ItemContainer = null;
            Element ContainerElement = null;

            int MenuTemplateStart = int.MaxValue;
            int MenuTemplaetEnd = 0;

            if (!string.IsNullOrEmpty(MenuViewModel.LinkElement) && !string.IsNullOrEmpty(MenuViewModel.ContainerElement))
            {
                var linkelement = DomService.GetElementByKoobooId(doc, MenuViewModel.LinkElement);
                if (linkelement != null)
                {
                    LinkElement = linkelement as Element;
                }

                var container = DomService.GetElementByKoobooId(doc, MenuViewModel.ContainerElement);
                if (container == null && linkelement != null)
                {
                    container = linkelement;
                }
                if (container != null)
                {
                    ContainerElement = container as Element;
                    MenuTemplateStart = ContainerElement.location.openTokenStartIndex;
                    MenuTemplaetEnd = ContainerElement.location.endTokenEndIndex;
                }
            }

            string SubMenuItemsTemplate = null;
            string SubMenuItemOrginalString = null;
            int SubMenuStart = int.MaxValue;
            int SubMenuEnd = 0;

            if (MenuViewModel.children.Count > 0)
            {
                List<Menu> SubMenus = new List<Menu>();

                foreach (var item in MenuViewModel.children)
                {
                    Menu submenu = CreateMenu(doc, item);
                    if (submenu != null)
                    {
                        SubMenus.Add(submenu);
                        if (submenu.tempdata.StartIndex < SubMenuStart)
                        {
                            SubMenuStart = submenu.tempdata.StartIndex;
                        }
                        if (submenu.tempdata.EndIndex > SubMenuEnd)
                        {
                            SubMenuEnd = submenu.tempdata.EndIndex;
                        }
                    }
                }

                ItemContainer = _GetItemContainer(doc, MenuViewModel);

                string SubMenuString = doc.HtmlSource.Substring(SubMenuStart, SubMenuEnd - SubMenuStart + 1);

                if (ItemContainer != null)
                {
                    // 1, sub item within the link element...
                    if (ContainerElement == null || DomService.ContainsOrEqualElement(ContainerElement, ItemContainer))
                    {
                        SubMenuItemOrginalString = ItemContainer.OuterHtml;
                        SubMenuItemsTemplate = SubMenuItemOrginalString.Replace(SubMenuString, MenuHelper.MarkSubItems); 
                    }
                    else if (ContainerElement.isEqualNode(ItemContainer))
                    {
                        SubMenuItemOrginalString = SubMenuString;
                        SubMenuItemsTemplate = MenuHelper.MarkSubItems;
                    }

                    else
                    {
                        var distance = DomService.GetTreeDistance(ContainerElement, ItemContainer);
                        bool sibling = false;
                        if (distance == 1)
                        {
                            sibling = true;
                        }
                        else if (distance < 5)
                        {
                            var nodes = DomService.GetNodesInBetween(doc, ContainerElement, ItemContainer);
                            if (nodes == null || nodes.Count == 0 || IsPossibleSeperator(nodes))
                            {
                                sibling = true;
                            }
                        }

                        if (sibling)
                        {
                            if (MenuTemplateStart > ItemContainer.location.openTokenStartIndex)
                            {
                                MenuTemplateStart = ItemContainer.location.openTokenStartIndex;
                            }

                            if (MenuTemplaetEnd < ItemContainer.location.endTokenEndIndex)
                            {
                                MenuTemplaetEnd = ItemContainer.location.endTokenEndIndex;
                            }

                            SubMenuItemOrginalString = ItemContainer.OuterHtml;
                            SubMenuItemsTemplate = SubMenuItemOrginalString.Replace(SubMenuString, MenuHelper.MarkSubItems);
                        }

                        else
                        {
                            //menu.RenderSubMenuSeperated = true;
                            SubMenuItemOrginalString = ItemContainer.OuterHtml;
                            SubMenuItemsTemplate = ItemContainer.OuterHtml.Replace(SubMenuString, MenuHelper.MarkSubItems);
                        }
                    }
                }

                if (SubMenus.Count > 0)
                {
                    menu.children.AddRange(SubMenus);
                }
            }

            if (MenuTemplateStart > 0 && MenuTemplaetEnd > 0)
            {
                string menutemplate = doc.HtmlSource.Substring(MenuTemplateStart, MenuTemplaetEnd - MenuTemplateStart + 1);

                if (!string.IsNullOrEmpty(SubMenuItemOrginalString))
                {
                    menutemplate = menutemplate.Replace(SubMenuItemOrginalString, MenuHelper.MarkSubItems);
                }

                string OriginalLink = LinkElement.OuterHtml;
                string NewLInk = DomService.ReplaceLink(LinkElement, MenuHelper.MarkHref, MenuHelper.MarkAnchorText);
                menutemplate = menutemplate.Replace(OriginalLink, NewLInk);
                menu.Template = menutemplate;
                menu.Name = MenuViewModel.text;
                menu.Url = MenuViewModel.href;
            }

            menu.SubItemContainer = SubMenuItemsTemplate;

            menu.tempdata.StartIndex = MenuTemplateStart;
            menu.tempdata.EndIndex = MenuTemplaetEnd;

            if (menu.tempdata.StartIndex == 0 || menu.tempdata.EndIndex == 0)
            {
                if (ItemContainer != null)
                {
                    menu.tempdata.StartIndex = ItemContainer.location.openTokenStartIndex;
                    menu.tempdata.EndIndex = ItemContainer.location.endTokenEndIndex;
                }
            }
            return menu;
        }

        private static Element _GetItemContainer(Document doc, MenuViewModel MenuViewModel)
        {
            // find the item container. 
            if (!string.IsNullOrEmpty(MenuViewModel.ItemContainer))
            {
                if (DomService.GetElementByKoobooId(doc, MenuViewModel.ItemContainer) is Element itemcontainer)
                {
                    return itemcontainer;
                }
            }

            List<Element> containerlist = new List<Element>();
            foreach (var item in MenuViewModel.children)
            {
                if (!string.IsNullOrEmpty(item.ContainerElement))
                {
                    if (DomService.GetElementByKoobooId(doc, item.ContainerElement) is Element element)
                    {
                        containerlist.Add(element);
                    }
                }
            }

            if (containerlist.Count == 0)
            {
                foreach (var item in MenuViewModel.children)
                {
                    if (DomService.GetElementByKoobooId(doc, item.ContainerElement) is Element element)
                    {
                        containerlist.Add(element);
                    }
                }
            }
            if (containerlist.Count > 1)
            {
                var element = DomService.FindParent(containerlist);

                if (DomService.GetElementByKoobooId(doc, item.ContainerElement) is Element element)
                {
                    MenuViewModel.ItemContainer = DomService.GetKoobooId(element);
                }
                return element;
            }
            return null;
        }

        /// <summary>
        /// Group by the links into different menu group. 
        /// </summary>
        /// <param name="linkelements"></param>
        /// <param name="ReduceGroup">Reduce the sub group within another group.... like sub menus within the main menu will be reduced.</param>
        /// <returns></returns>
        public static List<List<Element>> GroupBy(List<Element> linkelements, bool ReduceGroup = true)
        {
            List<List<Element>> result = new List<List<Element>>();

            int count = linkelements.Count;

            if (count == 0)
            {
                return result;
            }
            else if (count == 1)
            {
                result.Add(linkelements);
                return result;
            }

            List<Element> sorted = linkelements.OrderBy(o => o.depth).ThenBy(o => o.location.openTokenStartIndex).ToList();

            Element previous = null;
            Element current = null;
            bool addnewgroup = false;

            for (int i = 0; i < count; i++)
            {
                addnewgroup = false;
                ///The first one... 
                if (i == 0)
                {
                    addnewgroup = true;
                }
                else
                {
                    previous = sorted[i - 1];
                    current = sorted[i];

                    if (previous.depth != current.depth)
                    {
                        addnewgroup = true;
                    }
                    else
                    {
                        if (!IsElementNextToEachOther(current, previous))
                        {
                            addnewgroup = true;
                        }
                        else
                        {
                            /// if there is already a group and, this new member belongs to the same parent, then it belongs to the same group. 
                            if (result.LastOrDefault().Count > 1)
                            {
                                var currentlist = result.LastOrDefault();
                                var itemone = currentlist[currentlist.Count - 2];
                                var itemtwo = currentlist[currentlist.Count - 1];
                                var parent = Kooboo.Sites.Service.DomService.FindParent(itemone, itemtwo);

                                /// if there is longer distance.... 
                                if (Kooboo.Sites.Service.DomService.GetTreeDistance(current, itemtwo) > Kooboo.Sites.Service.DomService.GetTreeDistance(itemtwo, itemone))
                                {
                                    addnewgroup = true;
                                }

                                else
                                {
                                    var currentparent = Kooboo.Sites.Service.DomService.FindParent(itemone, current);
                                    if (!parent.isEqualNode(currentparent))
                                    {
                                        addnewgroup = true;
                                    }
                                }
                            }
                            else
                            {
                                // count = 1;     
                                var lastelement = result.LastOrDefault()[0];
                                var parent = Kooboo.Sites.Service.DomService.FindParent(current, lastelement);

                                if (parent.tagName != "ul" || parent.tagName != "nav")
                                {
                                    if (parent.tagName == "body")
                                    {
                                        addnewgroup = true;
                                    }

                                    //TODO: to be improve more rules...... 
                                }
                            }
                        }
                    }
                }

                if (addnewgroup)
                {
                    List<Element> firstlist = new List<Element>();
                    firstlist.Add(sorted[i]);
                    result.Add(firstlist);
                }
                else
                {

                    if (result.Count > 0)
                    {
                        result.LastOrDefault().Add(current);
                    }
                }
            }
            if (ReduceGroup)
            {
                ReduceGroupBy(result);
            }
            return result;
        }

        private static string ConvertToTemplate(Element linkElement, string href, string anchortext)
        {
            string all = linkElement.OuterHtml;
            all = all.Replace(anchortext, "{anchortext}");
            all = all.Replace(href, "{href}");
            return all;
        }
        /// <summary>
        /// Test that this two elements are next to each other, this is for menu detection. 
        /// for the menu with ul/li, this seems like enough. 
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        public static bool IsElementNextToEachOther(Element x, Element y)
        {
            if (x.depth != y.depth)
            {
                return false;
            }

            if (x.tagName != y.tagName)
            {
                return false;
            }

            // first check their physical location is very closer to each other. 
            if (x.location.openTokenStartIndex > y.location.openTokenStartIndex)
            {
                Element t = x;
                x = y;
                y = t;
            }

            int betweencount = y.location.openTokenStartIndex - x.location.endTokenEndIndex;

            if (betweencount < 10)
            {
                return true;
            }

            else
            {
                string betweentext = x.ownerDocument.HtmlSource.Substring(x.location.endTokenEndIndex + 1, betweencount);

                betweentext = betweentext.Replace(" ", "");
                betweentext = betweentext.Replace(Environment.NewLine, "");

                if (betweentext.Length < 10)
                {
                    return true;
                }
            }

            // check parents. 
            if (x.parentElement.tagName == "li" && y.parentElement.tagName == "li")
            {
                return IsElementNextToEachOther(x.parentElement, y.parentElement);
            }

            int treedistance = Kooboo.Sites.Service.DomService.GetTreeDistance(x, y);

            //TODO: Test that they have the same parent path and distance % 10 ==0.
            if (treedistance < 10 || treedistance % 10 == 0)
            {
                if (Kooboo.Sites.Service.DomService.getParentPath(x) == Kooboo.Sites.Service.DomService.getParentPath(y))
                {
                    return true;
                }
            }


            return false;
        }

        /// <summary>
        /// Convert one link item with its parent element into one menu item... 
        /// example: Li, a, website..... Convert the a under li tag into one mentu.... 
        /// </summary>
        /// <param name="parentElement"></param>
        /// <param name="linkElement"></param>
        /// <param name="website"></param>
        /// <returns></returns>
        public static Menu ConvertToMenu(Element parentElement, Element linkElement, WebSite website)
        {
            Menu menu = new Menu();

            string template = parentElement.OuterHtml;

            string anchortext = linkElement.InnerHtml;
            string href = linkElement.getAttribute("href");
            template = template.Replace(linkElement.OuterHtml, ConvertToTemplate(linkElement, href, anchortext));

            menu.Template = template;
            menu.Name = anchortext;
            menu.Url = href;

            // Check if there is a submenu.... 
            var alllinks = parentElement.getElementsByTagName("a").item;

            if (alllinks.Count > 1)
            {
                /// there is sub menu...
                List<Element> sublinks = new List<Element>();

                string mainhref = linkElement.getAttribute("href");

                foreach (var item in alllinks)
                {
                    string subhref = item.getAttribute("href");

                    if (subhref != mainhref)
                    {
                        sublinks.Add(item);
                    }
                }

                if (sublinks.Any())
                {
                    int SubGroupStartIndex;
                    int SubGroupEndIndex;

                    var groupby = GroupBy(sublinks);

                    if (groupby.Count == 1)
                    {
                        var submenulinks = groupby[0];

                        SubGroupStartIndex = submenulinks.First().location.openTokenStartIndex;
                        SubGroupEndIndex = submenulinks.Last().location.endTokenEndIndex;

                        var subcommonparent = DomService.FindParent(submenulinks);
                        bool includeparent = true;

                        if (subcommonparent.isEqualNode(linkElement) || subcommonparent.isEqualNode(parentElement))
                        {
                            includeparent = false;
                        }

                        var submenu = ConvertToMenu(submenulinks, subcommonparent, includeparent, website);

                        if (submenu.tempdata.EndIndex > SubGroupEndIndex)
                        {
                            SubGroupEndIndex = submenu.tempdata.EndIndex;
                        }

                        if (submenu.tempdata.StartIndex < SubGroupStartIndex)
                        {
                            SubGroupStartIndex = submenu.tempdata.StartIndex;
                        }

                        menu.SubItemContainer = submenu.Template;
                        // menu.SubItemSeperator = submenu.SubItemSeperator;
                        menu.children = submenu.children;
                    }

                    else
                    {
                        SubGroupStartIndex = groupby.First().First().location.openTokenStartIndex;
                        SubGroupEndIndex = groupby.Last().Last().location.endTokenEndIndex;

                        foreach (var item in groupby)
                        {
                            var commonparent = DomService.FindParent(item);
                            bool includeparentintemplate = false;

                            if (!commonparent.isEqualNode(parentElement) && commonparent.depth > parentElement.depth)
                            {
                                includeparentintemplate = true;
                            }

                            var submenu = ConvertToMenu(item, commonparent, includeparentintemplate, website);
                            // menu.Template = menu.Template.Replace(submenu.tempdata.TempOriginalText, placeholder);

                            if (submenu.tempdata.EndIndex > SubGroupEndIndex)
                            {
                                SubGroupEndIndex = submenu.tempdata.EndIndex;
                            }

                            if (submenu.tempdata.StartIndex < SubGroupStartIndex)
                            {
                                SubGroupStartIndex = submenu.tempdata.StartIndex;
                            }

                            menu.AddSubMenu(submenu);
                        }

                        // try to find the seperator.... 
                        List<Element> parents = new List<Element>();
                        parents.Add(groupby[0].Last());
                        parents.Add(groupby[1].First());
                        //var seperatorparent = FindCommonParent(parents);
                        //var seperator = FindSeperator(parents, seperatorparent);
                        //if (!string.IsNullOrEmpty(seperator))
                        //{
                        //    menu.SubItemSeperator = seperator;
                        //}
                    }

                    string subgrouptext = parentElement.ownerDocument.HtmlSource.Substring(SubGroupStartIndex, SubGroupEndIndex - SubGroupStartIndex + 1);

                    menu.Template = menu.Template.Replace(subgrouptext, "{items}");

                }
            }

            return menu;

        }

        /// <summary>
        /// Convert one group of links into menu, links must be within one group. 
        /// </summary>
        /// <param name="links"></param>
        /// <param name="website"></param>
        /// <param name="IncludeParentInTemplate"></param>
        /// <param name="maxsiblingindex">if this links group share parents with another link group, should only check sub menu till end of next sibling start. </param>
        /// <returns></returns>
        public static Menu ConvertToMenu(List<Element> links, WebSite website)
        {
            bool includeparentintemplate = true;
            int maxsilbingindex = 9999;

            links = links.OrderBy(o => o.location.openTokenStartIndex).ToList();
            Element commonparent = DomService.FindParent(links);
            var lastlink = links.LastOrDefault();

            TestTemplate(ref includeparentintemplate, ref maxsilbingindex, commonparent, lastlink);

            return ConvertToMenu(links, commonparent, includeparentintemplate, website, maxsilbingindex);
        }


        /// <summary>
        /// This is to test whether the parentelement can be used as the menu template or not. 
        /// </summary>
        /// <param name="includeparentintemplate"></param>
        /// <param name="maxsilbingindex"></param>
        /// <param name="commonparent"></param>
        /// <param name="lastlink"></param>
        private static void TestTemplate(ref bool includeparentintemplate, ref int maxsilbingindex, Element commonparent, Element lastlink)
        {
            var linksafter = FindLinksAfter(commonparent, lastlink);

            foreach (var item in linksafter)
            {
                /// if the link is similiar, it is same level links instead of sub menu..
                if (isSimiliarLink(lastlink, item))
                {
                    includeparentintemplate = false;
                    var parent = item;
                    while (!item.isEqualNode(commonparent))
                    {
                        parent = parent.parentElement;
                    }
                    maxsilbingindex = parent.siblingIndex;
                    break;

                }
            }

            var subparent = lastlink;
            while (true)
            {
                var tempparent = subparent.parentElement;

                if (tempparent != null && !tempparent.isEqualNode(commonparent) && tempparent.depth > commonparent.depth)
                {
                    subparent = tempparent;
                }
                else
                {
                    break;
                }
            }


            foreach (var item in commonparent.childNodes.item.Where(o => o.siblingIndex > subparent.siblingIndex).ToList())
            {
                if (!IsPossibleSeperator(item))
                {
                    includeparentintemplate = false;
                    maxsilbingindex = item.siblingIndex;
                    break;
                }
            }
            /// 
        }

        /// <summary>
        /// convert one parent with sub links into a menu.... 
        /// </summary>
        /// <param name="links"></param>
        /// <param name="CommonParent"></param>
        /// <param name="IncludeParentInTemplate"></param>
        /// <param name="website"></param>
        /// <returns></returns>
        public static Menu ConvertToMenu(List<Element> links, Element CommonParent, bool IncludeParentInTemplate, WebSite website, int maxsiblingindex = 9999)
        {
            Menu menu = new Menu();

            links = links.OrderBy(o => o.location.openTokenStartIndex).ToList();

            List<Element> Parents = new List<Element>();

            int count = links.Count;
            for (int i = 0; i < count; i++)
            {
                var parent = links[i];
                while (!parent.parentElement.isEqualNode(CommonParent) && parent != null)
                {
                    parent = parent.parentElement;
                }
                Parents.Add(parent);
            }

            menu.tempdata.StartIndex = Parents[0].location.openTokenStartIndex;
            menu.tempdata.EndIndex = Parents[count - 1].location.endTokenEndIndex;

            for (int i = 0; i < count; i++)
            {
                var parent = Parents[i];
                var linkelement = links[i];

                Menu submenu = ConvertToMenu(parent, links[i], website);

                if (submenu.children.Count == 0)
                {
                    int nextSiblingEnds = maxsiblingindex;
                    if (i < count - 1)
                    {
                        var nextparent = Parents[i + 1];
                        nextSiblingEnds = nextparent.siblingIndex;
                    }

                    var tempsublinks = FindLinksAfter(CommonParent, links[i], nextSiblingEnds);

                    /// Check and make sure those sub links are not similar, same level links. 
                    List<Element> sublinks = new List<Element>();

                    if (tempsublinks.Count > 0)
                    {
                        foreach (var item in tempsublinks)
                        {
                            if (isSimiliarLink(item, linkelement))
                            {
                                break;
                            }
                            sublinks.Add(item);
                        }

                        var groupbylinks = GroupBy(sublinks);

                        foreach (var item in groupbylinks)
                        {
                            var subcommonparent = DomService.FindParent(item);

                            bool SubIncludeParent = false;

                            if (!subcommonparent.isEqualNode(CommonParent) && subcommonparent.depth < CommonParent.depth)
                            {
                                SubIncludeParent = true;
                            }
                            Menu subsubmenu = ConvertToMenu(item, subcommonparent, SubIncludeParent, website);

                            submenu.AddSubMenu(subsubmenu);
                        }
                    }
                }

                menu.AddSubMenu(submenu);
            }

            string menuitemsstring = CommonParent.ownerDocument.HtmlSource.Substring(menu.tempdata.StartIndex, menu.tempdata.EndIndex - menu.tempdata.StartIndex + 1);

            if (IncludeParentInTemplate)
            {

                string tempTemplate = CommonParent.OuterHtml;
                menu.Template = tempTemplate.Replace(menuitemsstring, "{items}");

                if (CommonParent.location.openTokenStartIndex < menu.tempdata.StartIndex)
                {
                    menu.tempdata.StartIndex = CommonParent.location.openTokenStartIndex;
                }

                if (CommonParent.location.endTokenEndIndex > menu.tempdata.EndIndex)
                {
                    menu.tempdata.EndIndex = CommonParent.location.endTokenEndIndex;
                }
            }
            else
            {
                menu.Template = "{items}";
            }

            return menu;
        }

        /// <summary>
        /// Find link items after one item.... 
        /// </summary>
        /// <param name="CommonParent"></param>
        /// <param name="linkitem"></param>
        /// <param name="SiblingIndex"></param>
        /// <returns></returns>
        public static List<Element> FindLinksAfter(Element CommonParent, Element linkitem, int MaxSiblingIndex = 9999)
        {
            var parent = linkitem;
            while (!parent.parentElement.isEqualNode(CommonParent))
            {
                parent = parent.parentElement;
            }

            var NodesInBetween = CommonParent.childNodes.item.Where(o => o.siblingIndex > parent.siblingIndex && o.siblingIndex < MaxSiblingIndex).ToList();

            return Kooboo.Sites.Service.DomService.GetElementsByTagName(NodesInBetween, "a").item;

        }

        /// <summary>
        /// similar links means same level of menu instead of sub menu.... 
        /// </summary>
        /// <param name="linkx"></param>
        /// <param name="linky"></param>
        /// <returns></returns>
        private static bool isSimiliarLink(Element linkx, Element linky)
        {
            return (linkx.depth == linky.depth && Kooboo.Sites.Service.DomService.getParentPath(linkx) == Kooboo.Sites.Service.DomService.getParentPath(linky));
        }

        internal static void ReduceGroupBy(List<List<Element>> groupbylist)
        {
            //remove links that are within range of another links.
            List<Kooboo.Lib.DataType.MultiItems<int>> items = new List<Lib.DataType.MultiItems<int>>();

            int groupcount = groupbylist.Count;

            for (int i = 0; i < groupcount; i++)
            {
                Kooboo.Lib.DataType.MultiItems<int> newitem = new Lib.DataType.MultiItems<int>();
                newitem.Item1 = i;

                var lists = groupbylist[i].OrderBy(o => o.location.openTokenStartIndex).ToList();

                newitem.Item2 = lists[0].location.openTokenStartIndex;
                newitem.Item3 = lists[lists.Count - 1].location.endTokenEndIndex;

                items.Add(newitem);
            }

            List<int> toberemoved = new List<int>();

            for (int i = 0; i < groupcount; i++)
            {
                List<Element> item = groupbylist[i];

                var itemlist = item.OrderBy(o => o.location.openTokenStartIndex).ToList();
                int beginindex = itemlist.FirstOrDefault().location.openTokenStartIndex;
                int endindex = itemlist.LastOrDefault().location.endTokenEndIndex;

                foreach (var positionitem in items)
                {
                    if (i != positionitem.Item1)
                    {
                        if (beginindex >= positionitem.Item2 && endindex <= positionitem.Item3)
                        {
                            toberemoved.Add(i);
                            break;
                        }
                    }
                }
            }

            toberemoved.Reverse();

            foreach (var item in toberemoved)
            {
                groupbylist.RemoveAt(item);
            }

        }

        private static bool IsPossibleSeperator(Node node)
        {
            if (node is Element)
            {
                Element e = node as Element;
                var links = e.getElementsByTagName("a").item;
                if (links != null && links.Count > 0)
                {
                    return false;
                }
            }

            string textcontent = node.textContent.Trim(new char[] { '\r', '\n', ' ' });

            //if (string.IsNullOrEmpty(textcontent))
            //{ // return false; //}

            textcontent = System.Web.HttpUtility.HtmlDecode(textcontent);

            foreach (var item in textcontent.ToCharArray())
            {
                if (Kooboo.Dom.CommonIdoms.isAlphanumeric(item))
                {
                    return false;
                }
            }
            return true;
        }

        private static bool IsPossibleSeperator(List<Node> nodes)
        {
            foreach (var item in nodes)
            {
                if (!IsPossibleSeperator(item))
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// used when there is only one link 
        /// </summary>
        /// <param name="currentParentFound"></param>
        /// <returns></returns>
        public static Element TryUpgrade(Element currentParentFound)
        {
            // rule 1, if the parent has only one sub element and no other element, should upgrade... 
            var parent = currentParentFound.parentElement;

            foreach (var item in parent.childNodes.item)
            {
                if (!item.isEqualNode(currentParentFound))
                {
                    if (item is Element)
                    {
                        return currentParentFound;
                    }
                    else if (item is Kooboo.Dom.Text)
                    {
                        Kooboo.Dom.Text text = item as Kooboo.Dom.Text;
                        string content = text.textContent;
                        content = content.Trim(new char[] { '\r', '\n', ' ' });

                        if (!string.IsNullOrEmpty(content))
                        {
                            return currentParentFound;
                        }
                    }

                }
            }

            return TryUpgrade(parent);

        }

    }


    public class RawMenu
    {
        public RawMenu()
        {
            this.Children = new List<RawMenu>();
        }
        public Element LinkElement { get; set; }

        public Element ContainerElement { get; set; }

        public Element SubItemContainer { get; set; }

        public List<RawMenu> Children { get; set; }

        public RawMenu Parent { get; set; }

        public Element NextContainer()
        {
            if (Parent == null)
            {
                return null;
            } 
            int currentindex = this.ContainerElement.location.openTokenStartIndex;

            if (currentindex >= 0 && this.Parent.Children.Any())
            {
                var others = this.Parent.Children.Where(o => o.ContainerElement.location.openTokenStartIndex > currentindex);
                if (others != null && others.Any())
                {
                    return others.OrderBy(o => o.ContainerElement.location.openTokenStartIndex).First().ContainerElement;
                }
            }
            return null;
        }

    }

}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Kooboo.Sites\Service\MenuService.cs(721,29): warning CS0612: 'Menu.AddSubMenu(Menu)' is obsolete,D:\a\1\s\Kooboo.Sites\Service\MenuService.cs(902,29): warning CS0612: 'Menu.AddSubMenu(Menu)' is obsolete,D:\a\1\s\Kooboo.Sites\Service\MenuService.cs(907,17): warning CS0612: 'Menu.AddSubMenu(Menu)' is obsolete
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Sites\Service\MenuService.cs(408,58): error CS0103: The name 'item' does not exist in the current context,D:\a\1\s\Kooboo.Sites\Service\MenuService.cs(408,92): error CS0128: A local variable or function named 'element' is already defined in this scope,D:\a\1\s\Kooboo.Sites\Service\MenuService.cs(719,29): warning CS0612: 'Menu.AddSubMenu(Menu)' is obsolete,D:\a\1\s\Kooboo.Sites\Service\MenuService.cs(900,29): warning CS0612: 'Menu.AddSubMenu(Menu)' is obsolete,D:\a\1\s\Kooboo.Sites\Service\MenuService.cs(905,17): warning CS0612: 'Menu.AddSubMenu(Menu)' is obsolete
######################################################################


######################################################################
Nr: 28 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Sites\Sync\Disk\SyncManager.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using Kooboo.Data.Interface;
using Kooboo.Data.Models;
using Kooboo.Lib.Helper;
using Kooboo.Sites.Extensions;
using Kooboo.Sites.Models;
using Kooboo.Sites.Repository;
using Kooboo.Sites.Sync.DiskSyncLog;
using System.IO;

namespace Kooboo.Sites.Sync.Disk
{

    public class SyncManager
    {
        public SyncManager(Guid WebSiteId)
        {
            this.WebSiteId = WebSiteId;
        }

        private Guid WebSiteId { get; set; }

        internal void ProcessDiskEvent(WebSite website, DiskChangeEvent task)
        {
            var sitedb = website.SiteDb();

            if (task.ChangeType == DiskChangeType.Deleted)
            {
                this.DeleteFromDb(task.FullPath, sitedb);
                DiskSyncLog.DiskLogManager.Delete(task.FullPath, sitedb.WebSite.Id);
            }
            else
            {
                this.SyncToDb(task.FullPath, sitedb, null);
                DiskSyncLog.DiskLogManager.Add(task.FullPath, sitedb.WebSite.Id);
            }
        }

        public void DeleteFromDb(string DiskFullPath, SiteDb sitedb)
        {
            var NonRoutable = DiskPathService.GetNonRoutableObject(DiskFullPath);

            if (NonRoutable != null)
            {
                var repo = sitedb.GetRepository(NonRoutable.StoreName);
                string name = string.IsNullOrWhiteSpace(NonRoutable.Name) ? NonRoutable.Id.ToString() : NonRoutable.Name;
                var result = repo.GetByNameOrId(name) as ISiteObject;
                if (result != null)
                {
                    repo.Delete(result.Id);
                }
            }
            else
            {
                var RelativeUrl = DiskPathService.GetRelativeUrl(sitedb.WebSite, DiskFullPath);
                var route = sitedb.Routes.GetByUrl(RelativeUrl);
                if (route != null)
                {
                    var repo = sitedb.GetRepository(route.DestinationConstType);
                    if (repo != null)
                    {
                        var result = repo.Get(route.objectId) as ISiteObject;
                        if (result != null)
                        {
                            repo.Delete(result.Id);
                        }
                    }
                }
            }
        }

        public void SyncToDb(string FullPath, SiteDb SiteDb, byte[] diskbytes = null)
        {
            if (diskbytes == null)
            {
                diskbytes = this.ReadAllBytes(FullPath);
            }
            if (diskbytes == null)
            {
                return;
            }

            string OldRelativeUrl = null;
            string RelativeUrl = null;

            IRepository repo = null;
            ISiteObject result = null;
            Routing.Route route = null;
            string NameFromFile = null;
            string extension = UrlHelper.FileExtension(FullPath);
            if (!string.IsNullOrEmpty(extension) && !extension.StartsWith("."))
            {
                extension = "." + extension;
            }
            if (!string.IsNullOrEmpty(extension))
            {
                extension = extension.ToLower();
            }

            var NonRoutable = DiskPathService.GetNonRoutableObject(FullPath);

            if (NonRoutable != null)
            {
                repo = SiteDb.GetRepository(NonRoutable.StoreName);
                NameFromFile = NonRoutable.Name;
                string name = string.IsNullOrWhiteSpace(NonRoutable.Name) ? NonRoutable.Id.ToString() : NonRoutable.Name;
                if (!string.IsNullOrEmpty(NonRoutable.Extension))
                {
                    extension = NonRoutable.Extension.ToLower();
                    if (!extension.StartsWith("."))
                    {
                        extension = "." + extension;
                    }
                }

                result = repo.GetByNameOrId(name) as ISiteObject;

                if (result == null)
                {
                    if (name.ToLower().EndsWith(extension))
                    {
                        name = name.Substring(0, name.Length - extension.Length);
                        result = repo.GetByNameOrId(name);
                    }
                    else
                    {
                        name = name + extension;
                        result = repo.GetByNameOrId(name);
                    }
                }
            }
            else
            {
                OldRelativeUrl = DiskPathService.GetRelativeUrl(SiteDb.WebSite, FullPath);
                RelativeUrl = Kooboo.Sites.Helper.RouteHelper.ToValidRoute(OldRelativeUrl);

                route = SiteDb.Routes.GetByUrl(RelativeUrl);
                if (route != null)
                {
                    repo = SiteDb.GetRepository(route.DestinationConstType);
                    result = repo.Get(route.objectId) as ISiteObject;
                }
                else
                {
                    var ModelType = Service.ConstTypeService.GetModelTypeByUrl(RelativeUrl);
                    if (ModelType == null) { return; }
                    repo = SiteDb.GetRepository(ModelType);
                }
                NameFromFile = UrlHelper.FileName(RelativeUrl);
            }

            if (result == null)
            {
                result = Activator.CreateInstance(repo.ModelType) as ISiteObject;
            }

            if (!DiskObjectConverter.FromBytes(ref result, diskbytes, SiteDb))
            {
                return;
            }

            if (result is IExtensionable)
            {
                var extensionfile = result as IExtensionable;
                extensionfile.Extension = extension;
            }

            if (string.IsNullOrEmpty(result.Name))
            {
                result.Name = Lib.Helper.StringHelper.ToValidFileName(NameFromFile);
            }

            #region "Routing"

            if (!string.IsNullOrEmpty(RelativeUrl))
            {
                SiteDb.Routes.AddOrUpdate(RelativeUrl, result as SiteObject);
            }
            else
            {
                // # Rule1, only the API is different...
                if (result is Kooboo.Sites.Models.Code)
                {
                    var code = result as Code;
                    if (code.CodeType == CodeType.Api)
                    {
                        bool shouldUpdateCodeRouteText = false;

                        var diskroute = DiskObjectConverter.GetRouteFromCodeBytes(diskbytes);
                        if (string.IsNullOrWhiteSpace(diskroute))
                        {
                            // # Rule2, Api must have a route defined, otherwise it is a new api. 
                            var newroute = DiskObjectConverter.GetNewRoute(SiteDb, code.Name);
                            SiteDb.Routes.AddOrUpdate(newroute, code);
                            shouldUpdateCodeRouteText = true;
                        }
                        else
                        {
                            // # Rule 3, Check if this is its own route, or someelse routes. 
                            // Own rule, do nothing. 
                            var coderoute = SiteDb.Routes.Get(diskroute);

                            if (coderoute != null && coderoute.objectId != default(Guid) && coderoute.objectId != code.Id)
                            {
                                //Someone else route already. make a new one 
                                diskroute = DiskObjectConverter.GetNewRoute(SiteDb, diskroute);
                                coderoute = null;
                                shouldUpdateCodeRouteText = true;
                            }

                            if (coderoute == null)
                            {
                                //#Rule 4, If route does not exists yet. Add and delte old one if any. 
                                var oldroute = SiteDb.Routes.GetByObjectId(code.Id); 
                                SiteDb.Routes.AddOrUpdate(diskroute, code); 
                                if (oldroute !=null)
                                {
                                    SiteDb.Routes.Delete(oldroute.Id); 
                                } 
                            }
                            else
                            { 
                                // donothing. 
                            }

                        }

                        if (shouldUpdateCodeRouteText)
                        {
                            this.SyncToDisk(SiteDb, code, ChangeType.Update, SiteDb.Code.StoreName);
                        }

                    }

                }
            }

            #endregion

            if (!isSameName(result.Name, NameFromFile, extension) || OldRelativeUrl != RelativeUrl)
            {
                if (File.Exists(FullPath))
                {
                    File.Delete(FullPath);
                }
                repo.AddOrUpdate(result);
            }

            else
            {

                repo.AddOrUpdate(result);

            }
        }

        private bool isSameName(string x, string y, string extension)
        {
            extension = extension.ToLower();
            if (!extension.StartsWith("."))
            {
                extension = "." + extension;
            }

            if (x == null || y == null)
            {
                return true;
            }
            if (string.IsNullOrWhiteSpace(extension))
            {
                return x.ToLower() == y.ToLower();
            }
            else
            {
                if (x.ToLower().EndsWith(extension))
                {
                    x = x.Substring(0, x.Length - extension.Length);
                }

                if (y.ToLower().EndsWith(extension))
                {
                    y = y.Substring(0, y.Length - extension.Length);
                }

                return x.ToLower() == y.ToLower();

            }
        }

        public string SyncToDisk(SiteDb SiteDb, ISiteObject Value, ChangeType ChangeType, string StoreName)
        {
            if (Attributes.AttributeHelper.IsDiskable(Value) && !IsEmbedded(Value) && !string.IsNullOrEmpty(StoreName))
            {
                var value = Value as ISiteObject;
                string relativeurl = DiskPathService.GetObjectRelativeUrl(value, SiteDb, StoreName);

                if (!string.IsNullOrEmpty(relativeurl))
                {
                    string fullpath = DiskPathService.GetFullDiskPath(SiteDb.WebSite, relativeurl);

                    if (ChangeType == ChangeType.Delete)
                    {
                        if (File.Exists(fullpath))
                        {
                            this.Delete(fullpath);
                            DiskSyncLog.DiskLogManager.Delete(fullpath, SiteDb.Id);
                            return fullpath;
                        }
                    }

                    else
                    {
                        var coreobject = value as ICoreObject;

                        if (coreobject != null)
                        {
                            var contentbytes = DiskObjectConverter.ToBytes(SiteDb, value);

                            this.WriteBytes(fullpath, contentbytes);

                            DiskSyncLog.DiskLogManager.Add(fullpath, SiteDb.Id);

                            return fullpath;
                        }
                    }
                }

            }

            return null;
        }

        public void InitSyncToDisk()
        {
            var website = Kooboo.Data.GlobalDb.WebSites.Get(this.WebSiteId);
            var sitedb = website.SiteDb();

            var allrepos = sitedb.ActiveRepositories();
            foreach (var repo in allrepos)
            {
                if (Kooboo.Attributes.AttributeHelper.IsDiskable(repo.ModelType))
                {
                    var allitems = repo.All();

                    foreach (var item in allitems)
                    {
                        SyncToDisk(sitedb, item, ChangeType.Add, repo.StoreName);
                    }
                }
            }
        }

        private bool IsEmbedded(ISiteObject Value)
        {
            if (Value is IEmbeddable)
            {
                IEmbeddable embedded = Value as IEmbeddable;
                return embedded.IsEmbedded;
            }
            return false;
        }

        private object _IOLocker = new object();

        private byte[] ReadAllBytes(string FilePath)
        {
            lock (_IOLocker)
            {
                if (File.Exists(FilePath))
                {
                    int i = 0;
                    System.Threading.Thread.Sleep(10);  //TODO:  this is very strange action, otherwise, file will be being used.  
                    while (i < 10)
                    {
                        try
                        {
                            if (File.Exists(FilePath))
                            {
                                var bytes = File.ReadAllBytes(FilePath);
                                return bytes;
                            }
                        }
                        catch (Exception)
                        {
                            System.Threading.Thread.Sleep(100);
                        }
                        i += 1;
                    }
                }
                return null;
            }
        }

        internal void WriteBytes(string FullPath, byte[] Value)
        {
            if (Value == null)
            {
                Value = new byte[0];
            }
            lock (_IOLocker)
            {
                IOHelper.EnsureFileDirectoryExists(FullPath);

                int i = 0;
                while (i < 10)
                {
                    try
                    {
                        System.IO.FileStream stream = new FileStream(FullPath, FileMode.Create);

                        stream.Write(Value, 0, Value.Length);
                        stream.Close();
                        stream.Dispose();

                    }
                    catch (Exception)
                    {
                        System.Threading.Thread.Sleep(10);
                    }
                    i = i + 1;
                }

            }
        }

        internal void Delete(string fullpath)
        {
            try
            {
                System.IO.File.Delete(fullpath);
            }
            catch (Exception)
            {

            }
        }
    }
}

---- Transformed Tree ----
using System;
using Kooboo.Data.Interface;
using Kooboo.Data.Models;
using Kooboo.Lib.Helper;
using Kooboo.Sites.Extensions;
using Kooboo.Sites.Models;
using Kooboo.Sites.Repository;
using Kooboo.Sites.Sync.DiskSyncLog;
using System.IO;

namespace Kooboo.Sites.Sync.Disk
{

    public class SyncManager
    {
        public SyncManager(Guid WebSiteId)
        {
            this.WebSiteId = WebSiteId;
        }

        private Guid WebSiteId { get; set; }

        internal void ProcessDiskEvent(WebSite website, DiskChangeEvent task)
        {
            var sitedb = website.SiteDb();

            if (task.ChangeType == DiskChangeType.Deleted)
            {
                this.DeleteFromDb(task.FullPath, sitedb);
                DiskSyncLog.DiskLogManager.Delete(task.FullPath, sitedb.WebSite.Id);
            }
            else
            {
                this.SyncToDb(task.FullPath, sitedb, null);
                DiskSyncLog.DiskLogManager.Add(task.FullPath, sitedb.WebSite.Id);
            }
        }

        public void DeleteFromDb(string DiskFullPath, SiteDb sitedb)
        {
            var NonRoutable = DiskPathService.GetNonRoutableObject(DiskFullPath);

            if (NonRoutable != null)
            {
                var repo = sitedb.GetRepository(NonRoutable.StoreName);
                string name = string.IsNullOrWhiteSpace(NonRoutable.Name) ? NonRoutable.Id.ToString() : NonRoutable.Name;

                if (repo.GetByNameOrId(name) is ISiteObject result)
                {
                    repo.Delete(result.Id);
                }
            }
            else
            {
                var RelativeUrl = DiskPathService.GetRelativeUrl(sitedb.WebSite, DiskFullPath);
                var route = sitedb.Routes.GetByUrl(RelativeUrl);
                if (route != null)
                {
                    var repo = sitedb.GetRepository(route.DestinationConstType);
                    if (repo != null)
                    {
                        if (repo.GetByNameOrId(name) is ISiteObject result)
                        {
                            repo.Delete(result.Id);
                        }
                    }
                }
            }
        }

        public void SyncToDb(string FullPath, SiteDb SiteDb, byte[] diskbytes = null)
        {
            if (diskbytes == null)
            {
                diskbytes = this.ReadAllBytes(FullPath);
            }
            if (diskbytes == null)
            {
                return;
            }

            string OldRelativeUrl = null;
            string RelativeUrl = null;

            IRepository repo = null;
            ISiteObject result = null;
            Routing.Route route = null;
            string NameFromFile = null;
            string extension = UrlHelper.FileExtension(FullPath);
            if (!string.IsNullOrEmpty(extension) && !extension.StartsWith("."))
            {
                extension = "." + extension;
            }
            if (!string.IsNullOrEmpty(extension))
            {
                extension = extension.ToLower();
            }

            var NonRoutable = DiskPathService.GetNonRoutableObject(FullPath);

            if (NonRoutable != null)
            {
                repo = SiteDb.GetRepository(NonRoutable.StoreName);
                NameFromFile = NonRoutable.Name;
                string name = string.IsNullOrWhiteSpace(NonRoutable.Name) ? NonRoutable.Id.ToString() : NonRoutable.Name;
                if (!string.IsNullOrEmpty(NonRoutable.Extension))
                {
                    extension = NonRoutable.Extension.ToLower();
                    if (!extension.StartsWith("."))
                    {
                        extension = "." + extension;
                    }
                }

                result = repo.GetByNameOrId(name) as ISiteObject;

                if (result == null)
                {
                    if (name.ToLower().EndsWith(extension))
                    {
                        name = name.Substring(0, name.Length - extension.Length);
                        result = repo.GetByNameOrId(name);
                    }
                    else
                    {
                        name = name + extension;
                        result = repo.GetByNameOrId(name);
                    }
                }
            }
            else
            {
                OldRelativeUrl = DiskPathService.GetRelativeUrl(SiteDb.WebSite, FullPath);
                RelativeUrl = Kooboo.Sites.Helper.RouteHelper.ToValidRoute(OldRelativeUrl);

                route = SiteDb.Routes.GetByUrl(RelativeUrl);
                if (route != null)
                {
                    repo = SiteDb.GetRepository(route.DestinationConstType);
                    result = repo.Get(route.objectId) as ISiteObject;
                }
                else
                {
                    var ModelType = Service.ConstTypeService.GetModelTypeByUrl(RelativeUrl);
                    if (ModelType == null) { return; }
                    repo = SiteDb.GetRepository(ModelType);
                }
                NameFromFile = UrlHelper.FileName(RelativeUrl);
            }

            if (result == null)
            {
                result = Activator.CreateInstance(repo.ModelType) as ISiteObject;
            }

            if (!DiskObjectConverter.FromBytes(ref result, diskbytes, SiteDb))
            {
                return;
            }

            if (result is IExtensionable)
            {
                var extensionfile = result as IExtensionable;
                extensionfile.Extension = extension;
            }

            if (string.IsNullOrEmpty(result.Name))
            {
                result.Name = Lib.Helper.StringHelper.ToValidFileName(NameFromFile);
            }

            #region "Routing"

            if (!string.IsNullOrEmpty(RelativeUrl))
            {
                SiteDb.Routes.AddOrUpdate(RelativeUrl, result as SiteObject);
            }
            else
            {
                // # Rule1, only the API is different...
                if (result is Kooboo.Sites.Models.Code)
                {
                    var code = result as Code;
                    if (code.CodeType == CodeType.Api)
                    {
                        bool shouldUpdateCodeRouteText = false;

                        var diskroute = DiskObjectConverter.GetRouteFromCodeBytes(diskbytes);
                        if (string.IsNullOrWhiteSpace(diskroute))
                        {
                            // # Rule2, Api must have a route defined, otherwise it is a new api. 
                            var newroute = DiskObjectConverter.GetNewRoute(SiteDb, code.Name);
                            SiteDb.Routes.AddOrUpdate(newroute, code);
                            shouldUpdateCodeRouteText = true;
                        }
                        else
                        {
                            // # Rule 3, Check if this is its own route, or someelse routes. 
                            // Own rule, do nothing. 
                            var coderoute = SiteDb.Routes.Get(diskroute);

                            if (coderoute != null && coderoute.objectId != default(Guid) && coderoute.objectId != code.Id)
                            {
                                //Someone else route already. make a new one 
                                diskroute = DiskObjectConverter.GetNewRoute(SiteDb, diskroute);
                                coderoute = null;
                                shouldUpdateCodeRouteText = true;
                            }

                            if (coderoute == null)
                            {
                                //#Rule 4, If route does not exists yet. Add and delte old one if any. 
                                var oldroute = SiteDb.Routes.GetByObjectId(code.Id); 
                                SiteDb.Routes.AddOrUpdate(diskroute, code); 
                                if (oldroute !=null)
                                {
                                    SiteDb.Routes.Delete(oldroute.Id); 
                                } 
                            }
                            else
                            { 
                                // donothing. 
                            }

                        }

                        if (shouldUpdateCodeRouteText)
                        {
                            this.SyncToDisk(SiteDb, code, ChangeType.Update, SiteDb.Code.StoreName);
                        }

                    }

                }
            }

            #endregion

            if (!isSameName(result.Name, NameFromFile, extension) || OldRelativeUrl != RelativeUrl)
            {
                if (File.Exists(FullPath))
                {
                    File.Delete(FullPath);
                }
                repo.AddOrUpdate(result);
            }

            else
            {

                repo.AddOrUpdate(result);

            }
        }

        private bool isSameName(string x, string y, string extension)
        {
            extension = extension.ToLower();
            if (!extension.StartsWith("."))
            {
                extension = "." + extension;
            }

            if (x == null || y == null)
            {
                return true;
            }
            if (string.IsNullOrWhiteSpace(extension))
            {
                return x.ToLower() == y.ToLower();
            }
            else
            {
                if (x.ToLower().EndsWith(extension))
                {
                    x = x.Substring(0, x.Length - extension.Length);
                }

                if (y.ToLower().EndsWith(extension))
                {
                    y = y.Substring(0, y.Length - extension.Length);
                }

                return x.ToLower() == y.ToLower();

            }
        }

        public string SyncToDisk(SiteDb SiteDb, ISiteObject Value, ChangeType ChangeType, string StoreName)
        {
            if (Attributes.AttributeHelper.IsDiskable(Value) && !IsEmbedded(Value) && !string.IsNullOrEmpty(StoreName))
            {
                var value = Value as ISiteObject;
                string relativeurl = DiskPathService.GetObjectRelativeUrl(value, SiteDb, StoreName);

                if (!string.IsNullOrEmpty(relativeurl))
                {
                    string fullpath = DiskPathService.GetFullDiskPath(SiteDb.WebSite, relativeurl);

                    if (ChangeType == ChangeType.Delete)
                    {
                        if (File.Exists(fullpath))
                        {
                            this.Delete(fullpath);
                            DiskSyncLog.DiskLogManager.Delete(fullpath, SiteDb.Id);
                            return fullpath;
                        }
                    }

                    else
                    {
                        if (value is ICoreObject coreobject)
                        {
                            var contentbytes = DiskObjectConverter.ToBytes(SiteDb, value);

                            this.WriteBytes(fullpath, contentbytes);

                            DiskSyncLog.DiskLogManager.Add(fullpath, SiteDb.Id);

                            return fullpath;
                        }
                    }
                }

            }

            return null;
        }

        public void InitSyncToDisk()
        {
            var website = Kooboo.Data.GlobalDb.WebSites.Get(this.WebSiteId);
            var sitedb = website.SiteDb();

            var allrepos = sitedb.ActiveRepositories();
            foreach (var repo in allrepos)
            {
                if (Kooboo.Attributes.AttributeHelper.IsDiskable(repo.ModelType))
                {
                    var allitems = repo.All();

                    foreach (var item in allitems)
                    {
                        SyncToDisk(sitedb, item, ChangeType.Add, repo.StoreName);
                    }
                }
            }
        }

        private bool IsEmbedded(ISiteObject Value)
        {
            if (Value is IEmbeddable)
            {
                IEmbeddable embedded = Value as IEmbeddable;
                return embedded.IsEmbedded;
            }
            return false;
        }

        private object _IOLocker = new object();

        private byte[] ReadAllBytes(string FilePath)
        {
            lock (_IOLocker)
            {
                if (File.Exists(FilePath))
                {
                    int i = 0;
                    System.Threading.Thread.Sleep(10);  //TODO:  this is very strange action, otherwise, file will be being used.  
                    while (i < 10)
                    {
                        try
                        {
                            if (File.Exists(FilePath))
                            {
                                var bytes = File.ReadAllBytes(FilePath);
                                return bytes;
                            }
                        }
                        catch (Exception)
                        {
                            System.Threading.Thread.Sleep(100);
                        }
                        i += 1;
                    }
                }
                return null;
            }
        }

        internal void WriteBytes(string FullPath, byte[] Value)
        {
            if (Value == null)
            {
                Value = new byte[0];
            }
            lock (_IOLocker)
            {
                IOHelper.EnsureFileDirectoryExists(FullPath);

                int i = 0;
                while (i < 10)
                {
                    try
                    {
                        System.IO.FileStream stream = new FileStream(FullPath, FileMode.Create);

                        stream.Write(Value, 0, Value.Length);
                        stream.Close();
                        stream.Dispose();

                    }
                    catch (Exception)
                    {
                        System.Threading.Thread.Sleep(10);
                    }
                    i = i + 1;
                }

            }
        }

        internal void Delete(string fullpath)
        {
            try
            {
                System.IO.File.Delete(fullpath);
            }
            catch (Exception)
            {

            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Sites\Sync\Disk\SyncManager.cs(62,48): error CS0103: The name 'name' does not exist in the current context
######################################################################


######################################################################
Nr: 29 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Data\Context\DataContext.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using Kooboo.Data.Interface;
using Kooboo.Data.Models;
using Newtonsoft.Json.Linq;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;

namespace Kooboo.Data.Context
{
    public class DataContext
    {

        private RenderContext renderContext;
         
        public DataContext(RenderContext context)
        {
            this.renderContext = context;
        }

        private LinkedList<IDictionary> stack = new LinkedList<IDictionary>();

        private RepeatCondition _repeatcounter;
        public RepeatCondition RepeatCounter
        {
            get
            {
                if (_repeatcounter == null)
                {
                    _repeatcounter = new RepeatCondition();
                }
                return _repeatcounter;
            }
            set
            {
                _repeatcounter = value;
            }
        }

        /// <summary>
        /// The culture value from render content.
        /// </summary>
        public string Culture { get; set; }

        public List<string> Keys
        {
            get
            {
                List<string> keylist = new List<string>();

                foreach (var dic in this.stack)
                {
                    foreach (string key in dic.Keys)
                    {
                        keylist.Add(key);
                    }
                }
                return keylist;
            }
        }

        public bool ContainsKeyPrefix(string prefix)
        {
            return Keys.Any(k => k.StartsWith(prefix));
        }

        public IEnumerable<string> GetKeysByPrefix(string prefix)
        {
            return Keys.Where(k => k.StartsWith(prefix));
        }
        /// <summary>
        /// Get Value by object Type, like News.Title. return any datasource that has the object type of news, and the title. 
        /// </summary>
        /// <param name="FullPropertyName"></param>
        /// <returns></returns>
        public object GetValueByObjectType(string FullPropertyName)
        {
            // We assume that the {} has been taken off. 
            // It must be in the format of News.Title. 
            string ObjectType = null;
            string PropertyName = null;

            int dotindex = FullPropertyName.IndexOf(".");
            if (dotindex < 1)
            {
                ObjectType = FullPropertyName.ToLower();
            }
            else
            {
                ObjectType = FullPropertyName.Substring(0, dotindex).ToLower();
                PropertyName = FullPropertyName.Substring(dotindex + 1);
            }
            foreach (var dictitems in this.stack)
            {
                foreach (var item in dictitems.Values)
                {
                    if (item is DataMethodResult)
                    {
                        var result = GetValueFromMethodResultByObjectType(item as DataMethodResult, ObjectType, PropertyName);
                        if (result != null)
                        { return result; }
                    }
                    else if (item.GetType().IsClass)
                    {
                        var type = item.GetType();
                        if (type.Name.ToLower() == ObjectType)
                        {
                            if (!string.IsNullOrEmpty(PropertyName))
                            {
                                var result = getMember(item, PropertyName);
                                if (result != null)
                                {
                                    return result;
                                }
                            }
                            else
                            {
                                return item;
                            }
                        }
                    }
                }
            }

            return null;

        }

        public object GetValueByMemberName(string MemberName)
        {
            if (MemberName.Contains("."))
            {
                return null;
            }

            foreach (var dictitems in this.stack)
            {
                foreach (var item in dictitems.Values)
                {
                    if (Kooboo.Lib.Reflection.TypeHelper.IsGenericCollection(item.GetType()))
                    {
                        continue;
                    }
                    if (item is DataMethodResult)
                    {
                        var methodresult = item as DataMethodResult;
                        var objectvalue = methodresult.Value;

                        if (objectvalue != null)
                        {
                            var result = getMember(objectvalue, MemberName);
                            if (result != null)
                            {
                                return result;
                            }
                        }

                    }
                    else if (item.GetType().IsClass)
                    {

                        var result = getMember(item, MemberName);
                        if (result != null)
                        {
                            return result;
                        }

                    }
                }
            }

            return null;

        }

        internal object GetValueFromMethodResultByObjectType(DataMethodResult MethodResult, string ObjectType, string PropertyName)
        {
            ObjectType = ObjectType.ToLower();
            // the closest children first. 
            if (MethodResult.HasChildren)
            {
                foreach (var item in MethodResult.Children)
                {
                    var result = GetValueFromMethodResultByObjectType(item.Value, ObjectType, PropertyName);
                    if (result != null)
                    { return result; }
                }
            }
            if (MethodResult.ObjectType == ObjectType)
            {
                var result = getMember(MethodResult.Value, PropertyName);
                if (result != null)
                {
                    return result;
                }
            }
            return null;
        }

        private object getDictProperty(IDictionary dic, string FullPropertyName)
        {
            var result = _getDictValueCaseInsensitive(dic, FullPropertyName);
            if (result != null)
            {
                return result;
            }

            int dotindex = FullPropertyName.IndexOf(".");

            if (dotindex > -1)
            {
                string key = FullPropertyName.Substring(0, dotindex);

                string subProperty = FullPropertyName.Substring(dotindex + 1);

                result = _getDictValueCaseInsensitive(dic, key);

                if (result == null)
                {
                    return null;
                }
                else
                {
                    return getObjectProperty(result, subProperty);
                }

            }
            return null;
        }

        private object _getDictValueCaseInsensitive(IDictionary dict, string FullKey)
        {
            if (FullKey == "")
            {
                if (dict.Contains(""))
                {
                    return dict[""];
                }
                else
                {
                    return null;
                }
            }
            string lowerkey = FullKey.ToLower();
            foreach (var item in dict.Keys)
            {
                if (item.ToString().ToLower() == lowerkey)
                {
                    return dict[item];
                }
            }
            return null;
        }

        private object getObjectProperty(object obj, string PropertyName)
        {
            if (obj is DataMethodResult)
            {
                DataMethodResult methodresult = obj as DataMethodResult;

                object value = getObjectProperty(methodresult.Value, PropertyName);

                if (value == null)
                {
                    value = getDictProperty(methodresult.Children, PropertyName);
                }

                return value;
            }
            else
            {
                int dotindex = PropertyName.IndexOf(".");
                if (dotindex > -1)
                {
                    string key = PropertyName.Substring(0, dotindex);
                    string subProperty = PropertyName.Substring(dotindex + 1);

                    object value = getMember(obj, key);

                    if (value == null)
                    {
                        return null;
                    }
                    else
                    {
                        return getObjectProperty(value, subProperty);
                    }
                }
                else
                {
                    return getMember(obj, PropertyName);
                }
            }
        }

        private object getMember(object obj, string PropertyName)
        {
            if (obj is IDynamic)
            {
                var content = obj as IDynamic;
                if (this.renderContext == null)
                {
                    return content.GetValue(PropertyName);
                }
                else
                {
                    return content.GetValue(PropertyName, renderContext);
                }
            }
            else if (obj is IDictionary)
            {
                var dict = obj as IDictionary;
                if (dict.Contains(PropertyName))
                {
                    return dict[PropertyName];
                }
                return null;
            }

            else if (obj is JObject)
            {
                return Lib.Helper.JsonHelper.GetObject(obj as JObject, PropertyName);
            }
            else if (obj is XDocument)
            {
                return Lib.Helper.XmlHelper.GetMember(obj as XDocument, PropertyName);
            }
            else if (obj is XElement)
            {
                return Lib.Helper.XmlHelper.GetMember(obj as XElement, PropertyName);
            }

            else if (obj is System.Dynamic.ExpandoObject)
            {
                IDictionary<String, Object> value = obj as IDictionary<String, Object>;
                if (value != null)
                {
                    object result;
                    value.TryGetValue(PropertyName, out result);
                    return result;
                }
                return null;
            }
            else if (obj is IDictionary<string, object>)
            {
                IDictionary<string, object> value = obj as IDictionary<string, object>;
                if (value != null)
                {
                    object result;
                    value.TryGetValue(PropertyName, out result);
                    return result;
                }
                return null;
            }

            else if (obj is IDictionary<string, string>)
            {
                IDictionary<string, string> value = obj as IDictionary<string, string>;
                if (value != null)
                {
                    string result;
                    value.TryGetValue(PropertyName, out result);
                    return result;
                }
                return null;
            }
            else if (obj is Jint.Native.JsValue)
            {
                var value = obj as Jint.Native.JsValue;

                var jsObject = value.ToObject();
                if (jsObject == null)
                {
                    return null;
                }

                if (jsObject is IDynamic)
                {
                    var content = jsObject as IDynamic;
                    if (this.renderContext == null)
                    {
                        return content.GetValue(PropertyName);
                    }
                    else
                    {
                        return content.GetValue(PropertyName, renderContext);
                    }
                }

                else  if (jsObject is IDictionary<string, object>)
                {
                    IDictionary<String, Object> rightvalue = jsObject as IDictionary<String, Object>;
                    if (rightvalue != null)
                    {
                        object result;
                        rightvalue.TryGetValue(PropertyName, out result);
                        return result;
                    }
                }
                else if (jsObject is IDictionary<string, string>)
                {
                    IDictionary<String, string> rightvalue = jsObject as IDictionary<String, string>;
                    if (rightvalue != null)
                    {
                        string result;
                        rightvalue.TryGetValue(PropertyName, out result);
                        return result;
                    }
                }

                else
                {
                    if (jsObject is System.Dynamic.ExpandoObject)
                    {
                        IDictionary<String, Object> expvalue = obj as IDictionary<String, Object>;
                        if (expvalue != null)
                        {
                            object result;
                            expvalue.TryGetValue(PropertyName, out result);
                            return result;
                        }
                        return null;
                    }
                    else if (jsObject is Newtonsoft.Json.Linq.JObject)
                    {
                        var jobj = jsObject as Newtonsoft.Json.Linq.JObject;
                        return jobj.GetValue(PropertyName); 
                    }
                    else
                    {
                        return Kooboo.Lib.Reflection.Dynamic.GetObjectMember(jsObject, PropertyName);
                    }
                }

            }

            return Kooboo.Lib.Reflection.Dynamic.GetObjectMember(obj, PropertyName);
        }

        internal object GetValueFromStackItem(IDictionary StackItem, GetValueQuery query)
        {
            object result;
            result = _getDictValueCaseInsensitive(StackItem, query.FullPropertyName);
            if (result != null)
            {
                return result;
            }

            if (query.IsMember)
            {
                foreach (var item in StackItem.Values)
                {
                    if (item == null)
                    {
                        continue;
                    }
                    if (item is DataMethodResult)
                    {
                        var methodresult = item as DataMethodResult;
                        var objectvalue = methodresult.Value;

                        if (objectvalue != null)
                        {
                            result = getMember(objectvalue, query.MemberName);
                            if (result != null)
                            {
                                return result;
                            }
                        }

                    }
                    else
                    {

                        if (item is IDictionary)
                        {
                            var idic = item as IDictionary;
                            result = _getDictValueCaseInsensitive(idic, query.MemberName);
                            if (result != null)
                            {
                                return result;
                            }
                        }
                        else
                        { 
                            var type = item.GetType();

                            if (!type.IsValueType || !type.IsPrimitive)
                            {
                                result = getMember(item, query.MemberName);
                                if (result != null)
                                {
                                    return result;
                                }
                            }
                        }

                    }
                }
            }

            else
            {

                result = _getDictValueCaseInsensitive(StackItem, query.Key);

                if (result != null)
                {
                    return getObjectProperty(result, query.SubProperty);
                }

                // by object type...
                string objectType = query.Key.ToLower();

                foreach (var item in StackItem.Values)
                {
                    if (item == null)
                    {
                        continue;
                    }
                    if (item is DataMethodResult)
                    {
                        result = GetValueFromMethodResultByObjectType(item as DataMethodResult, query.Key, query.SubProperty);
                        if (result != null)
                        { return result; }
                    }
                    else if (item.GetType().IsClass)
                    {
                        var type = item.GetType();
                        if (type.Name.ToLower() == objectType)
                        {
                            if (!string.IsNullOrEmpty(query.SubProperty))
                            {
                                result = getMember(item, query.SubProperty);
                                if (result != null)
                                {
                                    return result;
                                }
                            }
                            else
                            {
                                return item;
                            }
                        }
                    }
                }

            }

            return null;
        }


        internal object GetValueFromKScript(GetValueQuery query)
        {
            var item = this.renderContext.GetItem<Jint.Engine>();
            if (item == null)
            {
                var debugger = this.renderContext.GetItem<Jint.Engine>("__kooboodebugger");
                var result = GetValueFromJsEngine(query, debugger);

                if (result != null)
                {
                    return result;
                }
            }
            else
            {
                var result = GetValueFromJsEngine(query, item);

                if (result != null)
                {
                    return result;
                }
                else
                {
                    var debugger = this.renderContext.GetItem<Jint.Engine>("__kooboodebugger");
                    result = GetValueFromJsEngine(query, debugger);

                    if (result != null)
                    {
                        return result;
                    }

                }
            }

            return null;
        }

        internal object GetValueFromJsEngine(GetValueQuery query, Jint.Engine engine)
        {

            if (engine == null)
            {
                return null;
            }

            if (query.IsMember)
            {
                var jsvalue = engine.GetValue(query.MemberName);
                if (jsvalue != null && jsvalue.Type != Jint.Runtime.Types.Undefined)
                {
                    return jsvalue.ToObject();
                }
            }
            else
            {
                var value = engine.GetValue(query.Key);

                if (value != null && value.Type != Jint.Runtime.Types.Undefined)
                {
                    string[] subs = query.SubProperty.Split(".".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);

                    object rightvalue = value;

                    foreach (var sub in subs)
                    {
                        rightvalue = getMember(rightvalue, sub);
                        if (rightvalue == null)
                        {
                            break;
                        }
                    }

                    if (rightvalue != null)
                    {
                        if (rightvalue is Jint.Native.JsValue)
                        {
                            var jsvalue = rightvalue as Jint.Native.JsValue;
                            if (jsvalue != null && jsvalue.Type != Jint.Runtime.Types.Undefined)
                            {
                                return jsvalue.ToObject();
                            }
                        }
                        else
                        {
                            return rightvalue;
                        }

                    }
                }
            }

            return null;

        }

        public object GetValue(string FullPropertyName)
        {
            var query = new GetValueQuery(FullPropertyName);
            return GetValueByQuery(query);
        }

        public object GetValueByQuery(GetValueQuery query)
        {
            object result = null;

            foreach (var item in this.stack)
            {
                result = GetValueFromStackItem(item, query);
                if (result != null)
                {
                    return result;
                }
            }

            // Get Value from KScript variables... 
            if (hasvalidchar(query))
            {
                var jsresult  =  GetValueFromKScript(query);
                if (jsresult !=null)
                {
                    var type = jsresult.GetType(); 
                    if (!type.Name.Contains("Func"))
                    {
                       return jsresult; 
                    }
                }
                
            }
            return null;
        }

        private bool hasvalidchar(GetValueQuery query)
        {
            string checkkey = null;
            if (query.IsMember)
            {
                checkkey = query.MemberName;
            }
            else
            {
                checkkey = query.Key;
            }

            if (!string.IsNullOrEmpty(checkkey))
            {
                for (int i = 0; i < checkkey.Length; i++)
                {
                    var currentchar = checkkey[i];
                    if (!Lib.Helper.CharHelper.isAlphanumeric(currentchar) && currentchar != '_')
                    {
                        return false;
                    }
                }
                return true;
            }

            return false;
        }

        public void Push(string key, object value)
        {
            Push(new Dictionary<string, object> { { key, value } });
        }

        public void Push(IDictionary data)
        { 
            stack.AddFirst(data);
            OnDataPush?.Invoke(data);
        }

        public void Pop()
        {
            if (stack.Count > 0)
            {
                stack.RemoveFirst();
            }
        }

        public Action<IDictionary> OnDataPush { get; set; }
    }

    public class GetValueQuery
    {
        public GetValueQuery(string FullPropertyName)
        {
            if (FullPropertyName.IndexOf("{") > -1 && FullPropertyName.IndexOf("}") > -1)
            {
                int start = FullPropertyName.IndexOf("{");
                int end = FullPropertyName.LastIndexOf("}");

                this.FullPropertyName = FullPropertyName.Substring(start + 1, end - start - 1);

                if (start > 0 || end < FullPropertyName.Length - 1)
                {
                    this.PartialMerge = true;
                    this.OriginalMergeField = "{" + this.FullPropertyName + "}";
                }
            }
            else
            {
                this.FullPropertyName = FullPropertyName;
            }

            int dotindex = this.FullPropertyName.IndexOf(".");
            if (dotindex < 1)
            {
                this.IsMember = true;
                this.MemberName = this.FullPropertyName;
            }
            else
            {
                this.Key = this.FullPropertyName.Substring(0, dotindex);
                this.SubProperty = this.FullPropertyName.Substring(dotindex + 1);
            }

        }
        public string FullPropertyName { get; set; }

        public string Key { get; set; }

        public string SubProperty { get; set; }

        public bool IsMember { get; set; }

        public string MemberName { get; set; }

        public bool PartialMerge { get; set; }

        public string OriginalMergeField { get; set; }
    }

    public class RepeatCondition
    {

        public Stack<RepeaterCounter> stack = new Stack<RepeaterCounter>();

        public void Push(int Total)
        {
            RepeaterCounter counter = new RepeaterCounter();
            counter.Total = Total;
            counter.Current = 0;

            this.stack.Push(counter);
        }

        public void Pop()
        {
            this.stack.Pop();
        }


        public RepeaterCounter CurrentCounter
        {
            get
            {
                if (this.stack.Count == 0)
                { return new RepeaterCounter(); }
                return this.stack.First();
            }
        }


        public bool Check(string condition)
        {

            if (string.IsNullOrEmpty(condition))
            {
                return false;
            }

            string lower = condition.ToLower().Trim();

            if (lower == "odd")
            {
                return IsOdd(this.CurrentCounter.Current);
            }
            else if (lower == "even")
            {
                return !IsOdd(this.CurrentCounter.Current);
            }
            else if (lower == "first")
            {
                return this.CurrentCounter.Current == 1;
            }
           else if (lower == "!first" || lower == "nonfirst")
            {
                return this.CurrentCounter.Current != 1; 
            }
            else if (lower == "last")
            {
                return this.CurrentCounter.Current == this.CurrentCounter.Total;
            }
            else if (lower == "!last" || lower == "nonlast")
            {
                return this.CurrentCounter.Current != this.CurrentCounter.Total;
            }
            else
            {
                int counter;

                if (int.TryParse(lower, out counter))
                {
                    return counter == this.CurrentCounter.Current;
                }

                var nth = GetNth(lower);
                if (nth != null)
                {
                    var left = this.CurrentCounter.Current % nth.N;
                    return left == nth.Th;
                }

                return false;
            }
        }

        private bool IsOdd(int value)
        {
            return value % 2 != 0;
        }

        private Nth GetNth(string input)
        {
            if (string.IsNullOrEmpty(input))
            {
                return null;
            }
            string ntype = input.ToLower().Replace("/", " ");
            ntype = ntype.Replace("\\", " ");
            ntype = ntype.Replace("+", " ");
            ntype = ntype.Replace("n", " ");
            ntype = ntype.Replace("x", " ");
            ntype = ntype.Replace("(", " ");
            ntype = ntype.Replace(")", " ");

            int index = ntype.IndexOf(" ");

            string begin = null;
            string end = null;
            if (index > -1)
            {
                begin = ntype.Substring(0, index);
                end = ntype.Substring(index);
            }

            if (string.IsNullOrWhiteSpace(begin))
            {
                return null;
            }

            Nth result = new Nth();

            int beginint = 0;
            if (!int.TryParse(begin.Trim(), out beginint))
            {
                return null;
            }

            result.N = beginint;

            int thint = 0;

            if (!string.IsNullOrWhiteSpace(end))
            {
                int.TryParse(end.Trim(), out thint);
                result.Th = thint;
            }
            return result;
        }

        public class RepeaterCounter
        {
            public int Total { get; set; }
            public int Current { get; set; }
        }

        public class Nth
        {
            public int N { get; set; }

            public int Th { get; set; }
        }

    }
}

---- Transformed Tree ----
using Kooboo.Data.Interface;
using Kooboo.Data.Models;
using Newtonsoft.Json.Linq;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;

namespace Kooboo.Data.Context
{
    public class DataContext
    {

        private RenderContext renderContext;
         
        public DataContext(RenderContext context)
        {
            this.renderContext = context;
        }

        private LinkedList<IDictionary> stack = new LinkedList<IDictionary>();

        private RepeatCondition _repeatcounter;
        public RepeatCondition RepeatCounter
        {
            get
            {
                if (_repeatcounter == null)
                {
                    _repeatcounter = new RepeatCondition();
                }
                return _repeatcounter;
            }
            set
            {
                _repeatcounter = value;
            }
        }

        /// <summary>
        /// The culture value from render content.
        /// </summary>
        public string Culture { get; set; }

        public List<string> Keys
        {
            get
            {
                List<string> keylist = new List<string>();

                foreach (var dic in this.stack)
                {
                    foreach (string key in dic.Keys)
                    {
                        keylist.Add(key);
                    }
                }
                return keylist;
            }
        }

        public bool ContainsKeyPrefix(string prefix)
        {
            return Keys.Any(k => k.StartsWith(prefix));
        }

        public IEnumerable<string> GetKeysByPrefix(string prefix)
        {
            return Keys.Where(k => k.StartsWith(prefix));
        }
        /// <summary>
        /// Get Value by object Type, like News.Title. return any datasource that has the object type of news, and the title. 
        /// </summary>
        /// <param name="FullPropertyName"></param>
        /// <returns></returns>
        public object GetValueByObjectType(string FullPropertyName)
        {
            // We assume that the {} has been taken off. 
            // It must be in the format of News.Title. 
            string ObjectType = null;
            string PropertyName = null;

            int dotindex = FullPropertyName.IndexOf(".");
            if (dotindex < 1)
            {
                ObjectType = FullPropertyName.ToLower();
            }
            else
            {
                ObjectType = FullPropertyName.Substring(0, dotindex).ToLower();
                PropertyName = FullPropertyName.Substring(dotindex + 1);
            }
            foreach (var dictitems in this.stack)
            {
                foreach (var item in dictitems.Values)
                {
                    if (item is DataMethodResult)
                    {
                        var result = GetValueFromMethodResultByObjectType(item as DataMethodResult, ObjectType, PropertyName);
                        if (result != null)
                        { return result; }
                    }
                    else if (item.GetType().IsClass)
                    {
                        var type = item.GetType();
                        if (type.Name.ToLower() == ObjectType)
                        {
                            if (!string.IsNullOrEmpty(PropertyName))
                            {
                                var result = getMember(item, PropertyName);
                                if (result != null)
                                {
                                    return result;
                                }
                            }
                            else
                            {
                                return item;
                            }
                        }
                    }
                }
            }

            return null;

        }

        public object GetValueByMemberName(string MemberName)
        {
            if (MemberName.Contains("."))
            {
                return null;
            }

            foreach (var dictitems in this.stack)
            {
                foreach (var item in dictitems.Values)
                {
                    if (Kooboo.Lib.Reflection.TypeHelper.IsGenericCollection(item.GetType()))
                    {
                        continue;
                    }
                    if (item is DataMethodResult)
                    {
                        var methodresult = item as DataMethodResult;
                        var objectvalue = methodresult.Value;

                        if (objectvalue != null)
                        {
                            var result = getMember(objectvalue, MemberName);
                            if (result != null)
                            {
                                return result;
                            }
                        }

                    }
                    else if (item.GetType().IsClass)
                    {

                        var result = getMember(item, MemberName);
                        if (result != null)
                        {
                            return result;
                        }

                    }
                }
            }

            return null;

        }

        internal object GetValueFromMethodResultByObjectType(DataMethodResult MethodResult, string ObjectType, string PropertyName)
        {
            ObjectType = ObjectType.ToLower();
            // the closest children first. 
            if (MethodResult.HasChildren)
            {
                foreach (var item in MethodResult.Children)
                {
                    var result = GetValueFromMethodResultByObjectType(item.Value, ObjectType, PropertyName);
                    if (result != null)
                    { return result; }
                }
            }
            if (MethodResult.ObjectType == ObjectType)
            {
                var result = getMember(MethodResult.Value, PropertyName);
                if (result != null)
                {
                    return result;
                }
            }
            return null;
        }

        private object getDictProperty(IDictionary dic, string FullPropertyName)
        {
            var result = _getDictValueCaseInsensitive(dic, FullPropertyName);
            if (result != null)
            {
                return result;
            }

            int dotindex = FullPropertyName.IndexOf(".");

            if (dotindex > -1)
            {
                string key = FullPropertyName.Substring(0, dotindex);

                string subProperty = FullPropertyName.Substring(dotindex + 1);

                result = _getDictValueCaseInsensitive(dic, key);

                if (result == null)
                {
                    return null;
                }
                else
                {
                    return getObjectProperty(result, subProperty);
                }

            }
            return null;
        }

        private object _getDictValueCaseInsensitive(IDictionary dict, string FullKey)
        {
            if (FullKey == "")
            {
                if (dict.Contains(""))
                {
                    return dict[""];
                }
                else
                {
                    return null;
                }
            }
            string lowerkey = FullKey.ToLower();
            foreach (var item in dict.Keys)
            {
                if (item.ToString().ToLower() == lowerkey)
                {
                    return dict[item];
                }
            }
            return null;
        }

        private object getObjectProperty(object obj, string PropertyName)
        {
            if (obj is DataMethodResult)
            {
                DataMethodResult methodresult = obj as DataMethodResult;

                object value = getObjectProperty(methodresult.Value, PropertyName);

                if (value == null)
                {
                    value = getDictProperty(methodresult.Children, PropertyName);
                }

                return value;
            }
            else
            {
                int dotindex = PropertyName.IndexOf(".");
                if (dotindex > -1)
                {
                    string key = PropertyName.Substring(0, dotindex);
                    string subProperty = PropertyName.Substring(dotindex + 1);

                    object value = getMember(obj, key);

                    if (value == null)
                    {
                        return null;
                    }
                    else
                    {
                        return getObjectProperty(value, subProperty);
                    }
                }
                else
                {
                    return getMember(obj, PropertyName);
                }
            }
        }

        private object getMember(object obj, string PropertyName)
        {
            if (obj is IDynamic)
            {
                var content = obj as IDynamic;
                if (this.renderContext == null)
                {
                    return content.GetValue(PropertyName);
                }
                else
                {
                    return content.GetValue(PropertyName, renderContext);
                }
            }
            else if (obj is IDictionary)
            {
                var dict = obj as IDictionary;
                if (dict.Contains(PropertyName))
                {
                    return dict[PropertyName];
                }
                return null;
            }

            else if (obj is JObject)
            {
                return Lib.Helper.JsonHelper.GetObject(obj as JObject, PropertyName);
            }
            else if (obj is XDocument)
            {
                return Lib.Helper.XmlHelper.GetMember(obj as XDocument, PropertyName);
            }
            else if (obj is XElement)
            {
                return Lib.Helper.XmlHelper.GetMember(obj as XElement, PropertyName);
            }

            else if (obj is System.Dynamic.ExpandoObject)
            {
                if (obj is IDictionary<String, Object> value)
                {
                    object result;
                    value.TryGetValue(PropertyName, out result);
                    return result;
                }
                return null;
            }
            else if (obj is IDictionary<string, object>)
            {
                if (obj is IDictionary<String, Object> value)
                {
                    object result;
                    value.TryGetValue(PropertyName, out result);
                    return result;
                }
                return null;
            }

            else if (obj is IDictionary<string, string>)
            {
                if (obj is IDictionary<String, Object> value)
                {
                    string result;
                    value.TryGetValue(PropertyName, out result);
                    return result;
                }
                return null;
            }
            else if (obj is Jint.Native.JsValue)
            {

                var jsObject = value.ToObject();
                if (jsObject == null)
                {
                    return null;
                }

                if (jsObject is IDynamic)
                {
                    var content = jsObject as IDynamic;
                    if (this.renderContext == null)
                    {
                        return content.GetValue(PropertyName);
                    }
                    else
                    {
                        return content.GetValue(PropertyName, renderContext);
                    }
                }

                else  if (jsObject is IDictionary<string, object>)
                {
                    if (jsObject is IDictionary<String, Object> rightvalue)
                    {
                        object result;
                        rightvalue.TryGetValue(PropertyName, out result);
                        return result;
                    }
                }
                else if (jsObject is IDictionary<string, string>)
                {
                    if (jsObject is IDictionary<String, Object> rightvalue)
                    {
                        string result;
                        rightvalue.TryGetValue(PropertyName, out result);
                        return result;
                    }
                }

                else
                {
                    if (jsObject is System.Dynamic.ExpandoObject)
                    {
                        if (obj is IDictionary<String, Object> expvalue)
                        {
                            object result;
                            expvalue.TryGetValue(PropertyName, out result);
                            return result;
                        }
                        return null;
                    }
                    else if (jsObject is Newtonsoft.Json.Linq.JObject)
                    {
                        var jobj = jsObject as Newtonsoft.Json.Linq.JObject;
                        return jobj.GetValue(PropertyName); 
                    }
                    else
                    {
                        return Kooboo.Lib.Reflection.Dynamic.GetObjectMember(jsObject, PropertyName);
                    }
                }

            }

            return Kooboo.Lib.Reflection.Dynamic.GetObjectMember(obj, PropertyName);
        }

        internal object GetValueFromStackItem(IDictionary StackItem, GetValueQuery query)
        {
            object result;
            result = _getDictValueCaseInsensitive(StackItem, query.FullPropertyName);
            if (result != null)
            {
                return result;
            }

            if (query.IsMember)
            {
                foreach (var item in StackItem.Values)
                {
                    if (item == null)
                    {
                        continue;
                    }
                    if (item is DataMethodResult)
                    {
                        var methodresult = item as DataMethodResult;
                        var objectvalue = methodresult.Value;

                        if (objectvalue != null)
                        {
                            result = getMember(objectvalue, query.MemberName);
                            if (result != null)
                            {
                                return result;
                            }
                        }

                    }
                    else
                    {

                        if (item is IDictionary)
                        {
                            var idic = item as IDictionary;
                            result = _getDictValueCaseInsensitive(idic, query.MemberName);
                            if (result != null)
                            {
                                return result;
                            }
                        }
                        else
                        { 
                            var type = item.GetType();

                            if (!type.IsValueType || !type.IsPrimitive)
                            {
                                result = getMember(item, query.MemberName);
                                if (result != null)
                                {
                                    return result;
                                }
                            }
                        }

                    }
                }
            }

            else
            {

                result = _getDictValueCaseInsensitive(StackItem, query.Key);

                if (result != null)
                {
                    return getObjectProperty(result, query.SubProperty);
                }

                // by object type...
                string objectType = query.Key.ToLower();

                foreach (var item in StackItem.Values)
                {
                    if (item == null)
                    {
                        continue;
                    }
                    if (item is DataMethodResult)
                    {
                        result = GetValueFromMethodResultByObjectType(item as DataMethodResult, query.Key, query.SubProperty);
                        if (result != null)
                        { return result; }
                    }
                    else if (item.GetType().IsClass)
                    {
                        var type = item.GetType();
                        if (type.Name.ToLower() == objectType)
                        {
                            if (!string.IsNullOrEmpty(query.SubProperty))
                            {
                                result = getMember(item, query.SubProperty);
                                if (result != null)
                                {
                                    return result;
                                }
                            }
                            else
                            {
                                return item;
                            }
                        }
                    }
                }

            }

            return null;
        }


        internal object GetValueFromKScript(GetValueQuery query)
        {
            var item = this.renderContext.GetItem<Jint.Engine>();
            if (item == null)
            {
                var debugger = this.renderContext.GetItem<Jint.Engine>("__kooboodebugger");
                var result = GetValueFromJsEngine(query, debugger);

                if (result != null)
                {
                    return result;
                }
            }
            else
            {
                var result = GetValueFromJsEngine(query, item);

                if (result != null)
                {
                    return result;
                }
                else
                {
                    var debugger = this.renderContext.GetItem<Jint.Engine>("__kooboodebugger");
                    result = GetValueFromJsEngine(query, debugger);

                    if (result != null)
                    {
                        return result;
                    }

                }
            }

            return null;
        }

        internal object GetValueFromJsEngine(GetValueQuery query, Jint.Engine engine)
        {

            if (engine == null)
            {
                return null;
            }

            if (query.IsMember)
            {
                var jsvalue = engine.GetValue(query.MemberName);

                if (rightvalue is Jint.Native.JsValue jsvalue && jsvalue.Type != Jint.Runtime.Types.Undefined)
                {
                    return jsvalue.ToObject();
                }
            }
            else
            {
                var value = engine.GetValue(query.Key);

                if (value != null && value.Type != Jint.Runtime.Types.Undefined)
                {
                    string[] subs = query.SubProperty.Split(".".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);

                    object rightvalue = value;

                    foreach (var sub in subs)
                    {
                        rightvalue = getMember(rightvalue, sub);
                        if (rightvalue == null)
                        {
                            break;
                        }
                    }

                    if (rightvalue != null)
                    {
                        if (rightvalue is Jint.Native.JsValue)
                        {
                            if (rightvalue is Jint.Native.JsValue jsvalue && jsvalue.Type != Jint.Runtime.Types.Undefined)
                            {
                                return jsvalue.ToObject();
                            }
                        }
                        else
                        {
                            return rightvalue;
                        }

                    }
                }
            }

            return null;

        }

        public object GetValue(string FullPropertyName)
        {
            var query = new GetValueQuery(FullPropertyName);
            return GetValueByQuery(query);
        }

        public object GetValueByQuery(GetValueQuery query)
        {
            object result = null;

            foreach (var item in this.stack)
            {
                result = GetValueFromStackItem(item, query);
                if (result != null)
                {
                    return result;
                }
            }

            // Get Value from KScript variables... 
            if (hasvalidchar(query))
            {
                var jsresult  =  GetValueFromKScript(query);
                if (jsresult !=null)
                {
                    var type = jsresult.GetType(); 
                    if (!type.Name.Contains("Func"))
                    {
                       return jsresult; 
                    }
                }
                
            }
            return null;
        }

        private bool hasvalidchar(GetValueQuery query)
        {
            string checkkey = null;
            if (query.IsMember)
            {
                checkkey = query.MemberName;
            }
            else
            {
                checkkey = query.Key;
            }

            if (!string.IsNullOrEmpty(checkkey))
            {
                for (int i = 0; i < checkkey.Length; i++)
                {
                    var currentchar = checkkey[i];
                    if (!Lib.Helper.CharHelper.isAlphanumeric(currentchar) && currentchar != '_')
                    {
                        return false;
                    }
                }
                return true;
            }

            return false;
        }

        public void Push(string key, object value)
        {
            Push(new Dictionary<string, object> { { key, value } });
        }

        public void Push(IDictionary data)
        { 
            stack.AddFirst(data);
            OnDataPush?.Invoke(data);
        }

        public void Pop()
        {
            if (stack.Count > 0)
            {
                stack.RemoveFirst();
            }
        }

        public Action<IDictionary> OnDataPush { get; set; }
    }

    public class GetValueQuery
    {
        public GetValueQuery(string FullPropertyName)
        {
            if (FullPropertyName.IndexOf("{") > -1 && FullPropertyName.IndexOf("}") > -1)
            {
                int start = FullPropertyName.IndexOf("{");
                int end = FullPropertyName.LastIndexOf("}");

                this.FullPropertyName = FullPropertyName.Substring(start + 1, end - start - 1);

                if (start > 0 || end < FullPropertyName.Length - 1)
                {
                    this.PartialMerge = true;
                    this.OriginalMergeField = "{" + this.FullPropertyName + "}";
                }
            }
            else
            {
                this.FullPropertyName = FullPropertyName;
            }

            int dotindex = this.FullPropertyName.IndexOf(".");
            if (dotindex < 1)
            {
                this.IsMember = true;
                this.MemberName = this.FullPropertyName;
            }
            else
            {
                this.Key = this.FullPropertyName.Substring(0, dotindex);
                this.SubProperty = this.FullPropertyName.Substring(dotindex + 1);
            }

        }
        public string FullPropertyName { get; set; }

        public string Key { get; set; }

        public string SubProperty { get; set; }

        public bool IsMember { get; set; }

        public string MemberName { get; set; }

        public bool PartialMerge { get; set; }

        public string OriginalMergeField { get; set; }
    }

    public class RepeatCondition
    {

        public Stack<RepeaterCounter> stack = new Stack<RepeaterCounter>();

        public void Push(int Total)
        {
            RepeaterCounter counter = new RepeaterCounter();
            counter.Total = Total;
            counter.Current = 0;

            this.stack.Push(counter);
        }

        public void Pop()
        {
            this.stack.Pop();
        }


        public RepeaterCounter CurrentCounter
        {
            get
            {
                if (this.stack.Count == 0)
                { return new RepeaterCounter(); }
                return this.stack.First();
            }
        }


        public bool Check(string condition)
        {

            if (string.IsNullOrEmpty(condition))
            {
                return false;
            }

            string lower = condition.ToLower().Trim();

            if (lower == "odd")
            {
                return IsOdd(this.CurrentCounter.Current);
            }
            else if (lower == "even")
            {
                return !IsOdd(this.CurrentCounter.Current);
            }
            else if (lower == "first")
            {
                return this.CurrentCounter.Current == 1;
            }
           else if (lower == "!first" || lower == "nonfirst")
            {
                return this.CurrentCounter.Current != 1; 
            }
            else if (lower == "last")
            {
                return this.CurrentCounter.Current == this.CurrentCounter.Total;
            }
            else if (lower == "!last" || lower == "nonlast")
            {
                return this.CurrentCounter.Current != this.CurrentCounter.Total;
            }
            else
            {
                int counter;

                if (int.TryParse(lower, out counter))
                {
                    return counter == this.CurrentCounter.Current;
                }

                var nth = GetNth(lower);
                if (nth != null)
                {
                    var left = this.CurrentCounter.Current % nth.N;
                    return left == nth.Th;
                }

                return false;
            }
        }

        private bool IsOdd(int value)
        {
            return value % 2 != 0;
        }

        private Nth GetNth(string input)
        {
            if (string.IsNullOrEmpty(input))
            {
                return null;
            }
            string ntype = input.ToLower().Replace("/", " ");
            ntype = ntype.Replace("\\", " ");
            ntype = ntype.Replace("+", " ");
            ntype = ntype.Replace("n", " ");
            ntype = ntype.Replace("x", " ");
            ntype = ntype.Replace("(", " ");
            ntype = ntype.Replace(")", " ");

            int index = ntype.IndexOf(" ");

            string begin = null;
            string end = null;
            if (index > -1)
            {
                begin = ntype.Substring(0, index);
                end = ntype.Substring(index);
            }

            if (string.IsNullOrWhiteSpace(begin))
            {
                return null;
            }

            Nth result = new Nth();

            int beginint = 0;
            if (!int.TryParse(begin.Trim(), out beginint))
            {
                return null;
            }

            result.N = beginint;

            int thint = 0;

            if (!string.IsNullOrWhiteSpace(end))
            {
                int.TryParse(end.Trim(), out thint);
                result.Th = thint;
            }
            return result;
        }

        public class RepeaterCounter
        {
            public int Total { get; set; }
            public int Current { get; set; }
        }

        public class Nth
        {
            public int N { get; set; }

            public int Th { get; set; }
        }

    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Data\Context\DataContext.cs(362,57): error CS1503: Argument 2: cannot convert from 'out string' to 'out object',D:\a\1\s\Kooboo.Data\Context\DataContext.cs(370,32): error CS0103: The name 'value' does not exist in the current context,D:\a\1\s\Kooboo.Data\Context\DataContext.cs(403,66): error CS1503: Argument 2: cannot convert from 'out string' to 'out object',D:\a\1\s\Kooboo.Data\Context\DataContext.cs(599,21): error CS0103: The name 'rightvalue' does not exist in the current context,D:\a\1\s\Kooboo.Data\Context\DataContext.cs(599,55): error CS0128: A local variable or function named 'jsvalue' is already defined in this scope
######################################################################


######################################################################
Nr: 30 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.Data\Server\ServerHandler.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using Kooboo.Data.Context;
using Kooboo.HttpServer;
using System.Threading.Tasks;
using System.Linq;
using System.IO;
using System.Collections.Specialized;
using System.Collections.Generic;
using Microsoft.AspNetCore.Http;
using System.Text;
using Kooboo.Extensions;
using Kooboo.Lib.Helper;
using Kooboo.HttpServer.Http;

namespace Kooboo.Data.Server
{

    public class ServerHandler : IHttpHandler
    {
        public Func<RenderContext, Task> _handle;

        public ServerHandler(Func<RenderContext, Task> handle)
        {
            _handle = handle;
        }

        public async Task Handle(HttpContext context)
        {
            RenderContext renderContext = await GetRenderContext(context);
            try
            {
                await _handle(renderContext);
                await SetResponse(context, renderContext);
            }
            catch (Exception ex)
            {
                renderContext.Response.StatusCode = 500;
                renderContext.Response.Body = System.Text.Encoding.UTF8.GetBytes(ex.Message);
                await SetResponse(context, renderContext);
            }
        }


        public static async Task<RenderContext> GetRenderContext(HttpContext httpContext)
        {
            RenderContext context = new RenderContext();
            context.Request = await GetRequest(httpContext);
            return context;
        }


        private static async Task<Context.HttpRequest> GetRequest(HttpContext context)
        {
            var header = context.Features.Request.Headers as Kooboo.HttpServer.Http.HttpRequestHeaders;

            Context.HttpRequest httprequest = new Context.HttpRequest();

            // httprequest.Host

            if (header != null && header.HeaderHost.Any())
            {
                string host = header.HeaderHost.First();

                int delimiterIndex = host.IndexOf(":");
                if (delimiterIndex > 0)
                {
                    host = host.Substring(0, delimiterIndex);
                }
                httprequest.Host = host;
            }

            httprequest.Path = context.Features.Request.Path;
            var url = GetUrl(context.Features.Request.RawTarget);

            httprequest.Url = url;
            httprequest.RawRelativeUrl = url;
            httprequest.Method = context.Features.Request.Method.ToUpper();
            httprequest.IP = context.Features.Connection.RemoteEndPoint.Address.ToString();


            httprequest.Port = context.Features.Connection.LocalEndPoint.Port;
            httprequest.Scheme = context.Features.Request.Scheme;

            foreach (var item in header)
            {
                httprequest.Headers.Add(item.Key, item.Value);
            }

            var headerip = httprequest.Headers.Get("X-Forwarded-For");

            if (!string.IsNullOrWhiteSpace(headerip))
            {
                httprequest.IP = headerip;
            }


            foreach (var item in context.Features.Request.Query)
            {
                httprequest.QueryString.Add(item.Key, item.Value);
            }
            httprequest.Cookies = GetCookie(context);

            if (httprequest.Method != "GET")
            {
                if (context.Features.Request.Body != null && context.Features.Request.Body.CanRead)
                {
                    MemoryStream ms = new MemoryStream();
                    var body = context.Features.Request.Body;
                    await context.Features.Request.Body.CopyToAsync(ms);
                    httprequest.PostData = ms.ToArray();
                    ms.Dispose();
                }


                var contenttype = httprequest.Headers.Get("Content-Type");
                if (contenttype != null && contenttype.ToLower().Contains("multipart"))
                {
                    var formresult = Kooboo.Lib.NETMultiplePart.FormReader.ReadForm(httprequest.PostData);

                    httprequest.Forms = new NameValueCollection();
                    if (formresult.FormData != null)
                    {
                        foreach (var item in formresult.FormData)
                        {
                            httprequest.Forms.Add(item.Key, item.Value);
                        }
                    }

                    httprequest.Files = formresult.Files;

                }
                else
                {
                    httprequest.Forms.Add(GetForm(httprequest.PostData, contenttype));
                }

            }
            return httprequest;
        }

        private static string GetUrl(string target)
        {
            if (string.IsNullOrEmpty(target))
            {
                return "/";
            }
            else
            {
                return System.Net.WebUtility.UrlDecode(target);
            }
        }


        internal static NameValueCollection GetForm(byte[] inputstream, string contenttype = null)
        {
            bool hasEncoded = false;
            if (contenttype != null && contenttype.ToLower().Contains("urlencoded"))
            {
                hasEncoded = true;
            }

            // The encoding type of a form is determined by the attribute enctype.It can have three values, 
            //application / x - www - form - urlencoded - Represents an URL encoded form. This is the default value if enctype attribute is not set to anything. 
            //multipart / form - data - Represents a Multipart form.This type of form is used when the user wants to upload files 
            //text / plain - A new form type introduced in HTML5, that as the name suggests, simply sends the data without any encoding


            NameValueCollection result = new NameValueCollection();

            string text = System.Text.Encoding.UTF8.GetString(inputstream);

            if (text == null)
            {
                return result;
            }

            //if (hasEncoded && text !=null)
            //{
            //    text = System.Net.WebUtility.UrlDecode(text); 
            //}

            int textLength = text.Length;
            int equalIndex = text.IndexOf('=');
            if (equalIndex == -1)
            {
                equalIndex = textLength;
            }
            int scanIndex = 0;
            while (scanIndex < textLength)
            {
                int delimiterIndex = text.IndexOf("&", scanIndex);
                if (delimiterIndex == -1)
                {
                    delimiterIndex = textLength;
                }
                if (equalIndex < delimiterIndex)
                {
                    while (scanIndex != equalIndex && char.IsWhiteSpace(text[scanIndex]))
                    {
                        ++scanIndex;
                    }
                    string name = text.Substring(scanIndex, equalIndex - scanIndex);
                    if (hasEncoded)
                    {
                        name = System.Net.WebUtility.UrlDecode(name);
                    }
                    //   name= Uri.UnescapeDataString(name);

                    string value = text.Substring(equalIndex + 1, delimiterIndex - equalIndex - 1);
                    // value= Uri.UnescapeDataString(value);
                    if (hasEncoded)
                    {
                        value = System.Net.WebUtility.UrlDecode(value);
                    }

                    result.Add(name, value);
                    equalIndex = text.IndexOf('=', delimiterIndex);
                    if (equalIndex == -1)
                    {
                        equalIndex = textLength;
                    }
                }
                scanIndex = delimiterIndex + 1;
            }

            return result;
        }

        private static Dictionary<string, string> GetCookie(HttpContext context)
        {
            Dictionary<string, string> cookies = new Dictionary<string, string>();

            foreach (var item in context.Features.Request.Cookies)
            {
                if (!cookies.ContainsKey(item.Key))
                {
                    cookies.Add(item.Key, item.Value);
                }
            }
            return cookies;
        }

        public static async Task SetResponse(HttpContext context, RenderContext renderContext)
        {
            var response = renderContext.Response;

            var header = context.Features.Response.Headers as Kooboo.HttpServer.Http.HttpResponseHeaders;

            context.Features.Response.StatusCode = response.StatusCode;

            if (response.StatusCode == 200)
            {
                context.Features.Response.Headers["Server"] = "http://www.kooboo.com";

                foreach (var item in response.Headers)
                {
                    context.Features.Response.Headers[item.Key] = item.Value;
                }

                foreach (var item in response.DeletedCookieNames)
                {
                    // context.Features.Response.Cookies.Delete(item);
                    var options = new CookieOptions()
                    {
                        Domain = renderContext.Request.Host,
                        Path = "/",
                        Expires = DateTime.Now.AddDays(-30)
                    };
                    context.Features.Response.Cookies.Append(item, "", options);

                    response.AppendedCookies.RemoveAll(o => o.Name == item);
                }

                foreach (var item in response.AppendedCookies)
                {
                    if (string.IsNullOrEmpty(item.Domain))
                    {
                        item.Domain = renderContext.Request.Host;
                    }
                    if (string.IsNullOrEmpty(item.Path))
                    {
                        item.Path = "/";
                    }

                    if (item.Expires == default(DateTime))
                    {
                        var time = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Local);
                        time = time.AddSeconds(-1);
                        item.Expires = time;
                    }

                    var options = new CookieOptions()
                    {
                        Domain = item.Domain,
                        Path = item.Path,
                        Expires = item.Expires
                    };

                    context.Features.Response.Cookies.Append(item.Name, item.Value, options);
                    // }   
                }

                header.HeaderContentType = response.ContentType;

                if (response.Body != null && context.Features.Request.Method.ToLower() != "head")
                {

                    try
                    {
                        header.ContentLength = response.Body.Length;
                        await response.Body.ChunkCopyAsync(context.Features.Response.Body).ConfigureAwait(false);
                    }
                    catch (Exception)
                    {
                        context.Features.Response.Body.Close();
                    }

                }
                else
                {
                    if (response.Stream != null)
                    {
                        await response.Stream.ChunkCopyAsync(context.Features.Response.Body, response.Stream.Length);
                    }
                    else if (response.FilePart != null)
                    {
                        await WritePartToResponse(response.FilePart, context.Features.Response);
                    }

                    else
                    {
                        // 404.
                        //string filename = Lib.Helper.IOHelper.CombinePath(AppSettings.RootPath, Kooboo.DataConstants.Default404Page) + ".html";
                        //if (System.IO.File.Exists(filename))
                        //{
                        //    string text = System.IO.File.ReadAllText(filename);
                        //    var bytes = System.Text.Encoding.UTF8.GetBytes(text);
                        //    header.ContentLength = bytes.Length;
                        //    context.Features.Response.StatusCode = 404;
                        //    await context.Features.Response.Body.WriteAsync(bytes, 0, bytes.Length);
                        //}

                    }
                }
            }
            else
            {

                string location = response.RedirectLocation;

                context.Features.Response.Headers["Server"] = "http://www.kooboo.com";

                foreach (var item in response.Headers)
                {
                    context.Features.Response.Headers[item.Key] = item.Value;
                }

                foreach (var item in response.DeletedCookieNames)
                {
                    var options = new CookieOptions()
                    {
                        Domain = renderContext.Request.Host,
                        Path = "/",
                        Expires = DateTime.Now.AddDays(-30)
                    };

                    context.Features.Response.Cookies.Append(item, "", options);
                }

                foreach (var item in response.AppendedCookies)
                {
                    if (string.IsNullOrEmpty(item.Domain))
                    {
                        item.Domain = renderContext.Request.Host;
                    }
                    if (string.IsNullOrEmpty(item.Path))
                    {
                        item.Path = "/";
                    }

                    var options = new CookieOptions()
                    {
                        Domain = item.Domain,
                        Path = item.Path,
                        Expires = item.Expires
                    };

                    context.Features.Response.Cookies.Append(item.Name, item.Value, options);
                }

                if (!string.IsNullOrEmpty(location))
                {

                    var host = renderContext.Request.Port == 80 || renderContext.Request.Port == 443
                        ? renderContext.Request.Host
                        : string.Format("{0}:{1}", renderContext.Request.Host, renderContext.Request.Port);
                    string BaseUrl = renderContext.Request.Scheme + "://" + host + renderContext.Request.Path;
                    var newUrl = UrlHelper.Combine(BaseUrl, location);
                    if (response.StatusCode != 200)
                    {
                        context.Features.Response.StatusCode = response.StatusCode;
                    }
                    //status code doesn't start with 3xx,it'will not redirect.
                    if (!response.StatusCode.ToString().StartsWith("3"))
                    {
                        context.Features.Response.StatusCode = StatusCodes.Status302Found;
                    }

                    header.HeaderLocation = newUrl;

                    context.Features.Response.Body.Dispose();

                    Log(renderContext);
                    return;
                }

                if (response.Body != null && response.Body.Length > 0)
                {
                    context.Features.Response.StatusCode = response.StatusCode;
                    await response.Body.ChunkCopyAsync(context.Features.Response.Body).ConfigureAwait(false);

                    context.Features.Response.Body.Dispose();
                    Log(renderContext);
                    return;
                }

                context.Features.Response.StatusCode = response.StatusCode;
                string responsebody = null;
                switch (response.StatusCode)
                {
                    case 404:
                        responsebody = " The requested resource not found";
                        break;
                    case 301:
                        responsebody = " The requested resource has moved.";
                        break;
                    case 302:
                        responsebody = " The requested resource has moved.";
                        break;
                    case 401:
                        responsebody = " Unauthorized access";
                        break;
                    case 403:
                        responsebody = " Unauthorized access";
                        break;
                    case 407:
                        responsebody = "Reach Limitation";
                        break;
                    case 500:
                        responsebody = "Internal server error";
                        break;
                    case 503:
                        responsebody = " Service Unavailable";
                        break;
                    default:
                        break;
                }

                if (string.IsNullOrEmpty(responsebody))
                {
                    if (response.StatusCode >= 400 && response.StatusCode < 500)
                    {
                        responsebody = " Client error";
                    }
                    else if (response.StatusCode >= 500)
                    {
                        responsebody = " Server error";
                    }
                    else
                    {
                        responsebody = " Unknown error";
                    }
                }
                var bytes = Encoding.UTF8.GetBytes(responsebody);
                await context.Features.Response.Body.WriteAsync(bytes, 0, bytes.Length).ConfigureAwait(false);
            }


            context.Features.Response.Body.Dispose();
            Log(renderContext);
            context = null;
        }


        private static async Task WritePartToResponse(Kooboo.IndexedDB.FilePart part, HttpResponseFeature Res)
        {
            long offset = part.BlockPosition + part.RelativePosition;
            long totalToSend = part.Length;

            Res.Headers["Content-Length"] = totalToSend.ToString();


            var stream = Kooboo.IndexedDB.StreamManager.OpenReadStream(part.FullFileName);

            stream.Position = offset;

            try
            {
                await stream.ChunkCopyAsync(Res.Body, totalToSend);
            }
            catch (IndexOutOfRangeException)
            {
            }
            finally
            {
                await Res.Body.FlushAsync();
            }
        }


        public static void Log(RenderContext context)
        {
            if (Data.AppSettings.Global.EnableLog)
            {
                string log = context.Response.StatusCode.ToString() + " " + context.Request.IP + ": " + DateTime.Now.ToLongTimeString() + " " + context.Request.Host + " " + context.Request.Method + " " + context.Request.Url;

                Kooboo.Data.Log.Instance.Http.Write(log);
            }
        }

    }

}


#endif

---- Transformed Tree ----
using System;
using Kooboo.Data.Context;
using Kooboo.HttpServer;
using System.Threading.Tasks;
using System.Linq;
using System.IO;
using System.Collections.Specialized;
using System.Collections.Generic;
using Microsoft.AspNetCore.Http;
using System.Text;
using Kooboo.Extensions;
using Kooboo.Lib.Helper;
using Kooboo.HttpServer.Http;

namespace Kooboo.Data.Server
{

    public class ServerHandler : IHttpHandler
    {
        public Func<RenderContext, Task> _handle;

        public ServerHandler(Func<RenderContext, Task> handle)
        {
            _handle = handle;
        }

        public async Task Handle(HttpContext context)
        {
            RenderContext renderContext = await GetRenderContext(context);
            try
            {
                await _handle(renderContext);
                await SetResponse(context, renderContext);
            }
            catch (Exception ex)
            {
                renderContext.Response.StatusCode = 500;
                renderContext.Response.Body = System.Text.Encoding.UTF8.GetBytes(ex.Message);
                await SetResponse(context, renderContext);
            }
        }


        public static async Task<RenderContext> GetRenderContext(HttpContext httpContext)
        {
            RenderContext context = new RenderContext();
            context.Request = await GetRequest(httpContext);
            return context;
        }


        private static async Task<Context.HttpRequest> GetRequest(HttpContext context)
        {

            Context.HttpRequest httprequest = new Context.HttpRequest();

            // httprequest.Host

            if (context.Features.Request.Headers is Kooboo.HttpServer.Http.HttpRequestHeaders header && header.HeaderHost.Any())
            {
                string host = header.HeaderHost.First();

                int delimiterIndex = host.IndexOf(":");
                if (delimiterIndex > 0)
                {
                    host = host.Substring(0, delimiterIndex);
                }
                httprequest.Host = host;
            }

            httprequest.Path = context.Features.Request.Path;
            var url = GetUrl(context.Features.Request.RawTarget);

            httprequest.Url = url;
            httprequest.RawRelativeUrl = url;
            httprequest.Method = context.Features.Request.Method.ToUpper();
            httprequest.IP = context.Features.Connection.RemoteEndPoint.Address.ToString();


            httprequest.Port = context.Features.Connection.LocalEndPoint.Port;
            httprequest.Scheme = context.Features.Request.Scheme;

            foreach (var item in header)
            {
                httprequest.Headers.Add(item.Key, item.Value);
            }

            var headerip = httprequest.Headers.Get("X-Forwarded-For");

            if (!string.IsNullOrWhiteSpace(headerip))
            {
                httprequest.IP = headerip;
            }


            foreach (var item in context.Features.Request.Query)
            {
                httprequest.QueryString.Add(item.Key, item.Value);
            }
            httprequest.Cookies = GetCookie(context);

            if (httprequest.Method != "GET")
            {
                if (context.Features.Request.Body != null && context.Features.Request.Body.CanRead)
                {
                    MemoryStream ms = new MemoryStream();
                    var body = context.Features.Request.Body;
                    await context.Features.Request.Body.CopyToAsync(ms);
                    httprequest.PostData = ms.ToArray();
                    ms.Dispose();
                }


                var contenttype = httprequest.Headers.Get("Content-Type");
                if (contenttype != null && contenttype.ToLower().Contains("multipart"))
                {
                    var formresult = Kooboo.Lib.NETMultiplePart.FormReader.ReadForm(httprequest.PostData);

                    httprequest.Forms = new NameValueCollection();
                    if (formresult.FormData != null)
                    {
                        foreach (var item in formresult.FormData)
                        {
                            httprequest.Forms.Add(item.Key, item.Value);
                        }
                    }

                    httprequest.Files = formresult.Files;

                }
                else
                {
                    httprequest.Forms.Add(GetForm(httprequest.PostData, contenttype));
                }

            }
            return httprequest;
        }

        private static string GetUrl(string target)
        {
            if (string.IsNullOrEmpty(target))
            {
                return "/";
            }
            else
            {
                return System.Net.WebUtility.UrlDecode(target);
            }
        }


        internal static NameValueCollection GetForm(byte[] inputstream, string contenttype = null)
        {
            bool hasEncoded = false;
            if (contenttype != null && contenttype.ToLower().Contains("urlencoded"))
            {
                hasEncoded = true;
            }

            // The encoding type of a form is determined by the attribute enctype.It can have three values, 
            //application / x - www - form - urlencoded - Represents an URL encoded form. This is the default value if enctype attribute is not set to anything. 
            //multipart / form - data - Represents a Multipart form.This type of form is used when the user wants to upload files 
            //text / plain - A new form type introduced in HTML5, that as the name suggests, simply sends the data without any encoding


            NameValueCollection result = new NameValueCollection();

            string text = System.Text.Encoding.UTF8.GetString(inputstream);

            if (text == null)
            {
                return result;
            }

            //if (hasEncoded && text !=null)
            //{
            //    text = System.Net.WebUtility.UrlDecode(text); 
            //}

            int textLength = text.Length;
            int equalIndex = text.IndexOf('=');
            if (equalIndex == -1)
            {
                equalIndex = textLength;
            }
            int scanIndex = 0;
            while (scanIndex < textLength)
            {
                int delimiterIndex = text.IndexOf("&", scanIndex);
                if (delimiterIndex == -1)
                {
                    delimiterIndex = textLength;
                }
                if (equalIndex < delimiterIndex)
                {
                    while (scanIndex != equalIndex && char.IsWhiteSpace(text[scanIndex]))
                    {
                        ++scanIndex;
                    }
                    string name = text.Substring(scanIndex, equalIndex - scanIndex);
                    if (hasEncoded)
                    {
                        name = System.Net.WebUtility.UrlDecode(name);
                    }
                    //   name= Uri.UnescapeDataString(name);

                    string value = text.Substring(equalIndex + 1, delimiterIndex - equalIndex - 1);
                    // value= Uri.UnescapeDataString(value);
                    if (hasEncoded)
                    {
                        value = System.Net.WebUtility.UrlDecode(value);
                    }

                    result.Add(name, value);
                    equalIndex = text.IndexOf('=', delimiterIndex);
                    if (equalIndex == -1)
                    {
                        equalIndex = textLength;
                    }
                }
                scanIndex = delimiterIndex + 1;
            }

            return result;
        }

        private static Dictionary<string, string> GetCookie(HttpContext context)
        {
            Dictionary<string, string> cookies = new Dictionary<string, string>();

            foreach (var item in context.Features.Request.Cookies)
            {
                if (!cookies.ContainsKey(item.Key))
                {
                    cookies.Add(item.Key, item.Value);
                }
            }
            return cookies;
        }

        public static async Task SetResponse(HttpContext context, RenderContext renderContext)
        {
            var response = renderContext.Response;

            var header = context.Features.Response.Headers as Kooboo.HttpServer.Http.HttpResponseHeaders;

            context.Features.Response.StatusCode = response.StatusCode;

            if (response.StatusCode == 200)
            {
                context.Features.Response.Headers["Server"] = "http://www.kooboo.com";

                foreach (var item in response.Headers)
                {
                    context.Features.Response.Headers[item.Key] = item.Value;
                }

                foreach (var item in response.DeletedCookieNames)
                {
                    // context.Features.Response.Cookies.Delete(item);
                    var options = new CookieOptions()
                    {
                        Domain = renderContext.Request.Host,
                        Path = "/",
                        Expires = DateTime.Now.AddDays(-30)
                    };
                    context.Features.Response.Cookies.Append(item, "", options);

                    response.AppendedCookies.RemoveAll(o => o.Name == item);
                }

                foreach (var item in response.AppendedCookies)
                {
                    if (string.IsNullOrEmpty(item.Domain))
                    {
                        item.Domain = renderContext.Request.Host;
                    }
                    if (string.IsNullOrEmpty(item.Path))
                    {
                        item.Path = "/";
                    }

                    if (item.Expires == default(DateTime))
                    {
                        var time = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Local);
                        time = time.AddSeconds(-1);
                        item.Expires = time;
                    }

                    var options = new CookieOptions()
                    {
                        Domain = item.Domain,
                        Path = item.Path,
                        Expires = item.Expires
                    };

                    context.Features.Response.Cookies.Append(item.Name, item.Value, options);
                    // }   
                }

                header.HeaderContentType = response.ContentType;

                if (response.Body != null && context.Features.Request.Method.ToLower() != "head")
                {

                    try
                    {
                        header.ContentLength = response.Body.Length;
                        await response.Body.ChunkCopyAsync(context.Features.Response.Body).ConfigureAwait(false);
                    }
                    catch (Exception)
                    {
                        context.Features.Response.Body.Close();
                    }

                }
                else
                {
                    if (response.Stream != null)
                    {
                        await response.Stream.ChunkCopyAsync(context.Features.Response.Body, response.Stream.Length);
                    }
                    else if (response.FilePart != null)
                    {
                        await WritePartToResponse(response.FilePart, context.Features.Response);
                    }

                    else
                    {
                        // 404.
                        //string filename = Lib.Helper.IOHelper.CombinePath(AppSettings.RootPath, Kooboo.DataConstants.Default404Page) + ".html";
                        //if (System.IO.File.Exists(filename))
                        //{
                        //    string text = System.IO.File.ReadAllText(filename);
                        //    var bytes = System.Text.Encoding.UTF8.GetBytes(text);
                        //    header.ContentLength = bytes.Length;
                        //    context.Features.Response.StatusCode = 404;
                        //    await context.Features.Response.Body.WriteAsync(bytes, 0, bytes.Length);
                        //}

                    }
                }
            }
            else
            {

                string location = response.RedirectLocation;

                context.Features.Response.Headers["Server"] = "http://www.kooboo.com";

                foreach (var item in response.Headers)
                {
                    context.Features.Response.Headers[item.Key] = item.Value;
                }

                foreach (var item in response.DeletedCookieNames)
                {
                    var options = new CookieOptions()
                    {
                        Domain = renderContext.Request.Host,
                        Path = "/",
                        Expires = DateTime.Now.AddDays(-30)
                    };

                    context.Features.Response.Cookies.Append(item, "", options);
                }

                foreach (var item in response.AppendedCookies)
                {
                    if (string.IsNullOrEmpty(item.Domain))
                    {
                        item.Domain = renderContext.Request.Host;
                    }
                    if (string.IsNullOrEmpty(item.Path))
                    {
                        item.Path = "/";
                    }

                    var options = new CookieOptions()
                    {
                        Domain = item.Domain,
                        Path = item.Path,
                        Expires = item.Expires
                    };

                    context.Features.Response.Cookies.Append(item.Name, item.Value, options);
                }

                if (!string.IsNullOrEmpty(location))
                {

                    var host = renderContext.Request.Port == 80 || renderContext.Request.Port == 443
                        ? renderContext.Request.Host
                        : string.Format("{0}:{1}", renderContext.Request.Host, renderContext.Request.Port);
                    string BaseUrl = renderContext.Request.Scheme + "://" + host + renderContext.Request.Path;
                    var newUrl = UrlHelper.Combine(BaseUrl, location);
                    if (response.StatusCode != 200)
                    {
                        context.Features.Response.StatusCode = response.StatusCode;
                    }
                    //status code doesn't start with 3xx,it'will not redirect.
                    if (!response.StatusCode.ToString().StartsWith("3"))
                    {
                        context.Features.Response.StatusCode = StatusCodes.Status302Found;
                    }

                    header.HeaderLocation = newUrl;

                    context.Features.Response.Body.Dispose();

                    Log(renderContext);
                    return;
                }

                if (response.Body != null && response.Body.Length > 0)
                {
                    context.Features.Response.StatusCode = response.StatusCode;
                    await response.Body.ChunkCopyAsync(context.Features.Response.Body).ConfigureAwait(false);

                    context.Features.Response.Body.Dispose();
                    Log(renderContext);
                    return;
                }

                context.Features.Response.StatusCode = response.StatusCode;
                string responsebody = null;
                switch (response.StatusCode)
                {
                    case 404:
                        responsebody = " The requested resource not found";
                        break;
                    case 301:
                        responsebody = " The requested resource has moved.";
                        break;
                    case 302:
                        responsebody = " The requested resource has moved.";
                        break;
                    case 401:
                        responsebody = " Unauthorized access";
                        break;
                    case 403:
                        responsebody = " Unauthorized access";
                        break;
                    case 407:
                        responsebody = "Reach Limitation";
                        break;
                    case 500:
                        responsebody = "Internal server error";
                        break;
                    case 503:
                        responsebody = " Service Unavailable";
                        break;
                    default:
                        break;
                }

                if (string.IsNullOrEmpty(responsebody))
                {
                    if (response.StatusCode >= 400 && response.StatusCode < 500)
                    {
                        responsebody = " Client error";
                    }
                    else if (response.StatusCode >= 500)
                    {
                        responsebody = " Server error";
                    }
                    else
                    {
                        responsebody = " Unknown error";
                    }
                }
                var bytes = Encoding.UTF8.GetBytes(responsebody);
                await context.Features.Response.Body.WriteAsync(bytes, 0, bytes.Length).ConfigureAwait(false);
            }


            context.Features.Response.Body.Dispose();
            Log(renderContext);
            context = null;
        }


        private static async Task WritePartToResponse(Kooboo.IndexedDB.FilePart part, HttpResponseFeature Res)
        {
            long offset = part.BlockPosition + part.RelativePosition;
            long totalToSend = part.Length;

            Res.Headers["Content-Length"] = totalToSend.ToString();


            var stream = Kooboo.IndexedDB.StreamManager.OpenReadStream(part.FullFileName);

            stream.Position = offset;

            try
            {
                await stream.ChunkCopyAsync(Res.Body, totalToSend);
            }
            catch (IndexOutOfRangeException)
            {
            }
            finally
            {
                await Res.Body.FlushAsync();
            }
        }


        public static void Log(RenderContext context)
        {
            if (Data.AppSettings.Global.EnableLog)
            {
                string log = context.Response.StatusCode.ToString() + " " + context.Request.IP + ": " + DateTime.Now.ToLongTimeString() + " " + context.Request.Host + " " + context.Request.Method + " " + context.Request.Url;

                Kooboo.Data.Log.Instance.Http.Write(log);
            }
        }

    }

}


#endif

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.Data\Server\ServerHandler.cs(89,34): error CS0165: Use of unassigned local variable 'header'
######################################################################


######################################################################
Nr: 31 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Diagnostics;
using System.Drawing;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Interop;
using System.Windows.Threading;
using Kooboo.App.SystemTray;
using Point = Kooboo.App.SystemTray.Point;


namespace Kooboo.App.SystemTray
{
    /// <summary>
    /// A WPF proxy to for a taskbar icon (NotifyIcon) that sits in the system's
    /// taskbar notification area ("system tray").
    /// </summary>
    public partial class TaskbarIcon : FrameworkElement, IDisposable
    {
        #region Members

        public Control Parent { get; set; }

        /// <summary>
        /// Represents the current icon data.
        /// </summary>
        private NotifyIconData iconData;

        /// <summary>
        /// Receives messages from the taskbar icon.
        /// </summary>
        private readonly WindowMessageSink messageSink;

        /// <summary>
        /// An action that is being invoked if the
        /// <see cref="singleClickTimer"/> fires.
        /// </summary>
        private Action singleClickTimerAction;

        /// <summary>
        /// A timer that is used to differentiate between single
        /// and double clicks.
        /// </summary>
        private readonly Timer singleClickTimer;

        /// <summary>
        /// A timer that is used to close open balloon tooltips.
        /// </summary>
        private readonly Timer balloonCloseTimer;

        /// <summary>
        /// Indicates whether the taskbar icon has been created or not.
        /// </summary>
        public bool IsTaskbarIconCreated { get; private set; }

        /// <summary>
        /// Indicates whether custom tooltips are supported, which depends
        /// on the OS. Windows Vista or higher is required in order to
        /// support this feature.
        /// </summary>
        public bool SupportsCustomToolTips
        {
            get { return messageSink.Version == NotifyIconVersion.Vista; }
        }


        /// <summary>
        /// Checks whether a non-tooltip popup is currently opened.
        /// </summary>
        private bool IsPopupOpen
        {
            get
            {
                var popup = TrayPopupResolved;
                var menu = ContextMenu;
                var balloon = CustomBalloon;

                return popup != null && popup.IsOpen ||
                       menu != null && menu.IsOpen ||
                       balloon != null && balloon.IsOpen;
            }
        }

        private double scalingFactor = double.NaN;

        #endregion

        #region Construction

        /// <summary>
        /// Inits the taskbar icon and registers a message listener
        /// in order to receive events from the taskbar area.
        /// </summary>
        public TaskbarIcon()
        {
            //using dummy sink in design mode
            messageSink = Util.IsDesignMode
                ? WindowMessageSink.CreateEmpty()
                : new WindowMessageSink(NotifyIconVersion.Win95);

            //init icon data structure
            iconData = NotifyIconData.CreateDefault(messageSink.MessageWindowHandle);

            //create the taskbar icon
            CreateTaskbarIcon();

            //register event listeners
            messageSink.MouseEventReceived += OnMouseEvent;
            messageSink.TaskbarCreated += OnTaskbarCreated;
            messageSink.ChangeToolTipStateRequest += OnToolTipChange;

            //init single click / balloon timers
            singleClickTimer = new Timer(DoSingleClickAction);
            balloonCloseTimer = new Timer(CloseBalloonCallback);

            //register listener in order to get notified when the application closes
            if (Application.Current != null) Application.Current.Exit += OnExit;
        }

        #endregion

        #region Custom Balloons

        /// <summary>
        /// Shows a custom control as a tooltip in the tray location.
        /// </summary>
        /// <param name="balloon"></param>
        /// <param name="animation">An optional animation for the popup.</param>
        /// <param name="timeout">The time after which the popup is being closed.
        /// Submit null in order to keep the balloon open inde
        /// </param>
        /// <exception cref="ArgumentNullException">If <paramref name="balloon"/>
        /// is a null reference.</exception>
        public void ShowCustomBalloon(UIElement balloon, PopupAnimation animation, int? timeout)
        {
            Dispatcher dispatcher = this.GetDispatcher();
            if (!dispatcher.CheckAccess())
            {
                var action = new Action(() => ShowCustomBalloon(balloon, animation, timeout));
                dispatcher.Invoke(DispatcherPriority.Normal, action);
                return;
            }

            if (balloon == null) throw new ArgumentNullException("balloon");
            if (timeout.HasValue && timeout < 500)
            {
                string msg = "Invalid timeout of {0} milliseconds. Timeout must be at least 500 ms";
                msg = String.Format(msg, timeout);
                throw new ArgumentOutOfRangeException("timeout", msg);
            }

            EnsureNotDisposed();

            //make sure we don't have an open balloon
            lock (this)
            {
                CloseBalloon();
            }

            //create an invisible popup that hosts the UIElement
            Popup popup = new Popup();
            popup.AllowsTransparency = true;

            //provide the popup with the taskbar icon's data context
            UpdateDataContext(popup, null, DataContext);

            //don't animate by default - devs can use attached
            //events or override
            popup.PopupAnimation = animation;

            //in case the balloon is cleaned up through routed events, the
            //control didn't remove the balloon from its parent popup when
            //if was closed the last time - just make sure it doesn't have
            //a parent that is a popup
            var parent = LogicalTreeHelper.GetParent(balloon) as Popup;
            if (parent != null) parent.Child = null;

            if (parent != null)
            {
                string msg =
                    "Cannot display control [{0}] in a new balloon popup - that control already has a parent. You may consider creating new balloons every time you want to show one.";
                msg = String.Format(msg, balloon);
                throw new InvalidOperationException(msg);
            }

            popup.Child = balloon;

            //don't set the PlacementTarget as it causes the popup to become hidden if the
            //TaskbarIcon's parent is hidden, too...
            //popup.PlacementTarget = this;

            popup.Placement = PlacementMode.AbsolutePoint;
            popup.StaysOpen = true;

            Point position = TrayInfo.GetTrayLocation();
            position = GetDeviceCoordinates(position);
            popup.HorizontalOffset = position.X - 1;
            popup.VerticalOffset = position.Y - 1;

            //store reference
            lock (this)
            {
                SetCustomBalloon(popup);
            }

            //assign this instance as an attached property
            SetParentTaskbarIcon(balloon, this);

            //fire attached event
            RaiseBalloonShowingEvent(balloon, this);

            //display item
            popup.IsOpen = true;

            if (timeout.HasValue)
            {
                //register timer to close the popup
                balloonCloseTimer.Change(timeout.Value, Timeout.Infinite);
            }
        }


        /// <summary>
        /// Resets the closing timeout, which effectively
        /// keeps a displayed balloon message open until
        /// it is either closed programmatically through
        /// <see cref="CloseBalloon"/> or due to a new
        /// message being displayed.
        /// </summary>
        public void ResetBalloonCloseTimer()
        {
            if (IsDisposed) return;

            lock (this)
            {
                //reset timer in any case
                balloonCloseTimer.Change(Timeout.Infinite, Timeout.Infinite);
            }
        }


        /// <summary>
        /// Closes the current <see cref="CustomBalloon"/>, if the
        /// property is set.
        /// </summary>
        public void CloseBalloon()
        {
            if (IsDisposed) return;

            Dispatcher dispatcher = this.GetDispatcher();
            if (!dispatcher.CheckAccess())
            {
                Action action = CloseBalloon;
                dispatcher.Invoke(DispatcherPriority.Normal, action);
                return;
            }

            lock (this)
            {
                //reset timer in any case
                balloonCloseTimer.Change(Timeout.Infinite, Timeout.Infinite);

                //reset old popup, if we still have one
                Popup popup = CustomBalloon;
                if (popup != null)
                {
                    UIElement element = popup.Child;

                    //announce closing
                    RoutedEventArgs eventArgs = RaiseBalloonClosingEvent(element, this);
                    if (!eventArgs.Handled)
                    {
                        //if the event was handled, clear the reference to the popup,
                        //but don't close it - the handling code has to manage this stuff now

                        //close the popup
                        popup.IsOpen = false;

                        //remove the reference of the popup to the balloon in case we want to reuse
                        //the balloon (then added to a new popup)
                        popup.Child = null;

                        //reset attached property
                        if (element != null) SetParentTaskbarIcon(element, null);
                    }

                    //remove custom balloon anyway
                    SetCustomBalloon(null);
                }
            }
        }


        /// <summary>
        /// Timer-invoke event which closes the currently open balloon and
        /// resets the <see cref="CustomBalloon"/> dependency property.
        /// </summary>
        private void CloseBalloonCallback(object state)
        {
            if (IsDisposed) return;

            //switch to UI thread
            Action action = CloseBalloon;
            this.GetDispatcher().Invoke(action);
        }

        #endregion

        #region Process Incoming Mouse Events

        /// <summary>
        /// Processes mouse events, which are bubbled
        /// through the class' routed events, trigger
        /// certain actions (e.g. show a popup), or
        /// both.
        /// </summary>
        /// <param name="me">Event flag.</param>
        private void OnMouseEvent(MouseEvent me)
        {
            if (IsDisposed) return;

            switch (me)
            {
                case MouseEvent.MouseMove:
                    RaiseTrayMouseMoveEvent();
                    //immediately return - there's nothing left to evaluate
                    return;
                case MouseEvent.IconRightMouseDown:
                    RaiseTrayRightMouseDownEvent();
                    break;
                case MouseEvent.IconLeftMouseDown:
                    RaiseTrayLeftMouseDownEvent();
                    break;
                case MouseEvent.IconRightMouseUp:
                    RaiseTrayRightMouseUpEvent();
                    break;
                case MouseEvent.IconLeftMouseUp:
                    RaiseTrayLeftMouseUpEvent();
                    break;
                case MouseEvent.IconMiddleMouseDown:
                    RaiseTrayMiddleMouseDownEvent();
                    break;
                case MouseEvent.IconMiddleMouseUp:
                    RaiseTrayMiddleMouseUpEvent();
                    break;
                case MouseEvent.IconDoubleClick:
                    //cancel single click timer
                    singleClickTimer.Change(Timeout.Infinite, Timeout.Infinite);
                    //bubble event
                    RaiseTrayMouseDoubleClickEvent();
                    break;
                case MouseEvent.BalloonToolTipClicked:
                    RaiseTrayBalloonTipClickedEvent();
                    break;
                default:
                    throw new ArgumentOutOfRangeException("me", "Missing handler for mouse event flag: " + me);
            }


            //get mouse coordinates
            Point cursorPosition = new Point();
            if (messageSink.Version == NotifyIconVersion.Vista)
            {
                //physical cursor position is supported for Vista and above
                WinApi.GetPhysicalCursorPos(ref cursorPosition);
            }
            else
            {
                WinApi.GetCursorPos(ref cursorPosition);
            }

            cursorPosition = GetDeviceCoordinates(cursorPosition);

            bool isLeftClickCommandInvoked = false;

            //show popup, if requested
            if (me.IsMatch(PopupActivation))
            {
                if (me == MouseEvent.IconLeftMouseUp)
                {
                    //show popup once we are sure it's not a double click
                    singleClickTimerAction = () =>
                    {
                        LeftClickCommand.ExecuteIfEnabled(LeftClickCommandParameter, LeftClickCommandTarget ?? this);
                        ShowTrayPopup(cursorPosition);
                    };
                    singleClickTimer.Change(WinApi.GetDoubleClickTime(), Timeout.Infinite);
                    isLeftClickCommandInvoked = true;
                }
                else
                {
                    //show popup immediately
                    ShowTrayPopup(cursorPosition);
                }
            }


            //show context menu, if requested
            if (me.IsMatch(MenuActivation))
            {
                if (me == MouseEvent.IconLeftMouseUp)
                {
                    //show context menu once we are sure it's not a double click
                    singleClickTimerAction = () =>
                    {
                        LeftClickCommand.ExecuteIfEnabled(LeftClickCommandParameter, LeftClickCommandTarget ?? this);
                        ShowContextMenu(cursorPosition);
                    };
                    singleClickTimer.Change(WinApi.GetDoubleClickTime(), Timeout.Infinite);
                    isLeftClickCommandInvoked = true;
                }
                else
                {
                    //show context menu immediately
                    ShowContextMenu(cursorPosition);
                }
            }

            //make sure the left click command is invoked on mouse clicks
            if (me == MouseEvent.IconLeftMouseUp && !isLeftClickCommandInvoked)
            {
                //show context menu once we are sure it's not a double click
                singleClickTimerAction =
                    () =>
                    {
                        LeftClickCommand.ExecuteIfEnabled(LeftClickCommandParameter, LeftClickCommandTarget ?? this);
                    };
                singleClickTimer.Change(WinApi.GetDoubleClickTime(), Timeout.Infinite);
            }
        }

        #endregion

        #region ToolTips

        /// <summary>
        /// Displays a custom tooltip, if available. This method is only
        /// invoked for Windows Vista and above.
        /// </summary>
        /// <param name="visible">Whether to show or hide the tooltip.</param>
        private void OnToolTipChange(bool visible)
        {
            //if we don't have a tooltip, there's nothing to do here...
            if (TrayToolTipResolved == null) return;

            if (visible)
            {
                if (IsPopupOpen)
                {
                    //ignore if we are already displaying something down there
                    return;
                }

                var args = RaisePreviewTrayToolTipOpenEvent();
                if (args.Handled) return;

                TrayToolTipResolved.IsOpen = true;

                //raise attached event first
                if (TrayToolTip != null) RaiseToolTipOpenedEvent(TrayToolTip);

                //bubble routed event
                RaiseTrayToolTipOpenEvent();
            }
            else
            {
                var args = RaisePreviewTrayToolTipCloseEvent();
                if (args.Handled) return;

                //raise attached event first
                if (TrayToolTip != null) RaiseToolTipCloseEvent(TrayToolTip);

                TrayToolTipResolved.IsOpen = false;

                //bubble event
                RaiseTrayToolTipCloseEvent();
            }
        }


        /// <summary>
        /// Creates a <see cref="ToolTip"/> control that either
        /// wraps the currently set <see cref="TrayToolTip"/>
        /// control or the <see cref="ToolTipText"/> string.<br/>
        /// If <see cref="TrayToolTip"/> itself is already
        /// a <see cref="ToolTip"/> instance, it will be used directly.
        /// </summary>
        /// <remarks>We use a <see cref="ToolTip"/> rather than
        /// <see cref="Popup"/> because there was no way to prevent a
        /// popup from causing cyclic open/close commands if it was
        /// placed under the mouse. ToolTip internally uses a Popup of
        /// its own, but takes advance of Popup's internal <see cref="UIElement.IsHitTestVisible"/>
        /// property which prevents this issue.</remarks>
        private void CreateCustomToolTip()
        {
            //check if the item itself is a tooltip
            ToolTip tt = TrayToolTip as ToolTip;

            if (tt == null && TrayToolTip != null)
            {
                //create an invisible wrapper tooltip that hosts the UIElement
                tt = new ToolTip();
                tt.Placement = PlacementMode.Mouse;

                //do *not* set the placement target, as it causes the popup to become hidden if the
                //TaskbarIcon's parent is hidden, too. At runtime, the parent can be resolved through
                //the ParentTaskbarIcon attached dependency property:
                //tt.PlacementTarget = this;

                //make sure the tooltip is invisible
                tt.HasDropShadow = false;
                tt.BorderThickness = new Thickness(0);
                tt.Background = System.Windows.Media.Brushes.Transparent;

                //setting the 
                tt.StaysOpen = true;
                tt.Content = TrayToolTip;
            }
            else if (tt == null && !String.IsNullOrEmpty(ToolTipText))
            {
                //create a simple tooltip for the ToolTipText string
                tt = new ToolTip();
                tt.Content = ToolTipText;
            }

            //the tooltip explicitly gets the DataContext of this instance.
            //If there is no DataContext, the TaskbarIcon assigns itself
            if (tt != null)
            {
                UpdateDataContext(tt, null, DataContext);
            }

            //store a reference to the used tooltip
            SetTrayToolTipResolved(tt);
        }


        /// <summary>
        /// Sets tooltip settings for the class depending on defined
        /// dependency properties and OS support.
        /// </summary>
        private void WriteToolTipSettings()
        {
            const IconDataMembers flags = IconDataMembers.Tip;
            iconData.ToolTipText = ToolTipText;

            if (messageSink.Version == NotifyIconVersion.Vista)
            {
                //we need to set a tooltip text to get tooltip events from the
                //taskbar icon
                if (String.IsNullOrEmpty(iconData.ToolTipText) && TrayToolTipResolved != null)
                {
                    //if we have not tooltip text but a custom tooltip, we
                    //need to set a dummy value (we're displaying the ToolTip control, not the string)
                    iconData.ToolTipText = "ToolTip";
                }
            }

            //update the tooltip text
            Util.WriteIconData(ref iconData, NotifyCommand.Modify, flags);
        }

        #endregion

        #region Custom Popup

        /// <summary>
        /// Creates a <see cref="ToolTip"/> control that either
        /// wraps the currently set <see cref="TrayToolTip"/>
        /// control or the <see cref="ToolTipText"/> string.<br/>
        /// If <see cref="TrayToolTip"/> itself is already
        /// a <see cref="ToolTip"/> instance, it will be used directly.
        /// </summary>
        /// <remarks>We use a <see cref="ToolTip"/> rather than
        /// <see cref="Popup"/> because there was no way to prevent a
        /// popup from causing cyclic open/close commands if it was
        /// placed under the mouse. ToolTip internally uses a Popup of
        /// its own, but takes advance of Popup's internal <see cref="UIElement.IsHitTestVisible"/>
        /// property which prevents this issue.</remarks>
        private void CreatePopup()
        {
            //check if the item itself is a popup
            Popup popup = TrayPopup as Popup;

            if (popup == null && TrayPopup != null)
            {
                //create an invisible popup that hosts the UIElement
                popup = new Popup();
                popup.AllowsTransparency = true;

                //don't animate by default - devs can use attached
                //events or override
                popup.PopupAnimation = PopupAnimation.None;

                //the CreateRootPopup method outputs binding errors in the debug window because
                //it tries to bind to "Popup-specific" properties in case they are provided by the child.
                //We don't need that so just assign the control as the child.
                popup.Child = TrayPopup;

                //do *not* set the placement target, as it causes the popup to become hidden if the
                //TaskbarIcon's parent is hidden, too. At runtime, the parent can be resolved through
                //the ParentTaskbarIcon attached dependency property:
                //popup.PlacementTarget = this;

                popup.Placement = PlacementMode.AbsolutePoint;
                popup.StaysOpen = false;
            }

            //the popup explicitly gets the DataContext of this instance.
            //If there is no DataContext, the TaskbarIcon assigns itself
            if (popup != null)
            {
                UpdateDataContext(popup, null, DataContext);
            }

            //store a reference to the used tooltip
            SetTrayPopupResolved(popup);
        }


        /// <summary>
        /// Displays the <see cref="TrayPopup"/> control if
        /// it was set.
        /// </summary>
        private void ShowTrayPopup(Point cursorPosition)
        {
            if (IsDisposed) return;

            //raise preview event no matter whether popup is currently set
            //or not (enables client to set it on demand)
            var args = RaisePreviewTrayPopupOpenEvent();
            if (args.Handled) return;

            if (TrayPopup != null)
            {
                //use absolute position, but place the popup centered above the icon
                TrayPopupResolved.Placement = PlacementMode.AbsolutePoint;
                TrayPopupResolved.HorizontalOffset = cursorPosition.X;
                TrayPopupResolved.VerticalOffset = cursorPosition.Y;

                //open popup
                TrayPopupResolved.IsOpen = true;

                IntPtr handle = IntPtr.Zero;
                if (TrayPopupResolved.Child != null)
                {
                    //try to get a handle on the popup itself (via its child)
                    HwndSource source = (HwndSource) PresentationSource.FromVisual(TrayPopupResolved.Child);
                    if (source != null) handle = source.Handle;
                }

                //if we don't have a handle for the popup, fall back to the message sink
                if (handle == IntPtr.Zero) handle = messageSink.MessageWindowHandle;

                //activate either popup or message sink to track deactivation.
                //otherwise, the popup does not close if the user clicks somewhere else
                WinApi.SetForegroundWindow(handle);

                //raise attached event - item should never be null unless developers
                //changed the CustomPopup directly...
                if (TrayPopup != null) RaisePopupOpenedEvent(TrayPopup);

                //bubble routed event
                RaiseTrayPopupOpenEvent();
            }
        }

        #endregion

        #region Context Menu

        /// <summary>
        /// Displays the <see cref="ContextMenu"/> if
        /// it was set.
        /// </summary>
        private void ShowContextMenu(Point cursorPosition)
        {
            if (IsDisposed) return;

            //raise preview event no matter whether context menu is currently set
            //or not (enables client to set it on demand)
            var args = RaisePreviewTrayContextMenuOpenEvent();
            if (args.Handled) return;

            if (ContextMenu != null)
            {
                //use absolute positioning. We need to set the coordinates, or a delayed opening
                //(e.g. when left-clicked) opens the context menu at the wrong place if the mouse
                //is moved!
                ContextMenu.Placement = PlacementMode.AbsolutePoint;
                ContextMenu.HorizontalOffset = cursorPosition.X;
                ContextMenu.VerticalOffset = cursorPosition.Y;
                ContextMenu.IsOpen = true;

                IntPtr handle = IntPtr.Zero;

                //try to get a handle on the context itself
                HwndSource source = (HwndSource) PresentationSource.FromVisual(ContextMenu);
                if (source != null)
                {
                    handle = source.Handle;
                }

                //if we don't have a handle for the popup, fall back to the message sink
                if (handle == IntPtr.Zero) handle = messageSink.MessageWindowHandle;

                //activate the context menu or the message window to track deactivation - otherwise, the context menu
                //does not close if the user clicks somewhere else. With the message window
                //fallback, the context menu can't receive keyboard events - should not happen though
                WinApi.SetForegroundWindow(handle);

                //bubble event
                RaiseTrayContextMenuOpenEvent();
            }
        }

        #endregion

        #region Single Click Timer event

        /// <summary>
        /// Performs a delayed action if the user requested an action
        /// based on a single click of the left mouse.<br/>
        /// This method is invoked by the <see cref="singleClickTimer"/>.
        /// </summary>
        private void DoSingleClickAction(object state)
        {
            if (IsDisposed) return;

            //run action
            Action action = singleClickTimerAction;
            if (action != null)
            {
                //cleanup action
                singleClickTimerAction = null;

                //switch to UI thread
                this.GetDispatcher().Invoke(action);
            }
        }

        #endregion

        #region Set Version (API)

        /// <summary>
        /// Sets the version flag for the <see cref="iconData"/>.
        /// </summary>
        private void SetVersion()
        {
            iconData.VersionOrTimeout = (uint) NotifyIconVersion.Vista;
            bool status = WinApi.Shell_NotifyIcon(NotifyCommand.SetVersion, ref iconData);

            if (!status)
            {
                iconData.VersionOrTimeout = (uint) NotifyIconVersion.Win2000;
                status = Util.WriteIconData(ref iconData, NotifyCommand.SetVersion);
            }

            if (!status)
            {
                iconData.VersionOrTimeout = (uint) NotifyIconVersion.Win95;
                status = Util.WriteIconData(ref iconData, NotifyCommand.SetVersion);
            }

            if (!status)
            {
                Debug.Fail("Could not set version");
            }
        }

        #endregion

        #region Create / Remove Taskbar Icon

        /// <summary>
        /// Recreates the taskbar icon if the whole taskbar was
        /// recreated (e.g. because Explorer was shut down).
        /// </summary>
        private void OnTaskbarCreated()
        {
            IsTaskbarIconCreated = false;
            CreateTaskbarIcon();
        }


        /// <summary>
        /// Creates the taskbar icon. This message is invoked during initialization,
        /// if the taskbar is restarted, and whenever the icon is displayed.
        /// </summary>
        private void CreateTaskbarIcon()
        {
            lock (this)
            {
                if (!IsTaskbarIconCreated)
                {
                    const IconDataMembers members = IconDataMembers.Message
                                                    | IconDataMembers.Icon
                                                    | IconDataMembers.Tip;

                    //write initial configuration
                    var status = Util.WriteIconData(ref iconData, NotifyCommand.Add, members);
                    if (!status)
                    {
                        //couldn't create the icon - we can assume this is because explorer is not running (yet!)
                        //-> try a bit later again rather than throwing an exception. Typically, if the windows
                        // shell is being loaded later, this method is being reinvoked from OnTaskbarCreated
                        // (we could also retry after a delay, but that's currently YAGNI)
                        return;
                    }

                    //set to most recent version
                    SetVersion();
                    messageSink.Version = (NotifyIconVersion) iconData.VersionOrTimeout;

                    IsTaskbarIconCreated = true;
                }
            }
        }

        /// <summary>
        /// Closes the taskbar icon if required.
        /// </summary>
        private void RemoveTaskbarIcon()
        {
            lock (this)
            {
                //make sure we didn't schedule a creation

                if (IsTaskbarIconCreated)
                {
                    Util.WriteIconData(ref iconData, NotifyCommand.Delete, IconDataMembers.Message);
                    IsTaskbarIconCreated = false;
                }
            }
        }

        #endregion

        /// <summary>
        /// Recalculates OS coordinates in order to support WPFs coordinate
        /// system if OS scaling (DPIs) is not 100%.
        /// </summary>
        /// <param name="point"></param>
        /// <returns></returns>
        private Point GetDeviceCoordinates(Point point)
        {
            if (double.IsNaN(scalingFactor))
            {
                //calculate scaling factor in order to support non-standard DPIs
                var presentationSource = PresentationSource.FromVisual(this);
                if (presentationSource == null)
                {
                    scalingFactor = 1;
                }
                else
                {
                    var transform = presentationSource.CompositionTarget.TransformToDevice;
                    scalingFactor = 1/transform.M11;
                }
            }

            //on standard DPI settings, just return the point
            if (scalingFactor == 1.0) return point;

            return new Point() {X = (int) (point.X*scalingFactor), Y = (int) (point.Y*scalingFactor)};
        }

        #region Dispose / Exit

        /// <summary>
        /// Set to true as soon as <c>Dispose</c> has been invoked.
        /// </summary>
        public bool IsDisposed { get; private set; }


        /// <summary>
        /// Checks if the object has been disposed and
        /// raises a <see cref="ObjectDisposedException"/> in case
        /// the <see cref="IsDisposed"/> flag is true.
        /// </summary>
        private void EnsureNotDisposed()
        {
            if (IsDisposed) throw new ObjectDisposedException(Name ?? GetType().FullName);
        }


        /// <summary>
        /// Disposes the class if the application exits.
        /// </summary>
        private void OnExit(object sender, EventArgs e)
        {
            Dispose();
        }


        /// <summary>
        /// This destructor will run only if the <see cref="Dispose()"/>
        /// method does not get called. This gives this base class the
        /// opportunity to finalize.
        /// <para>
        /// Important: Do not provide destructors in types derived from
        /// this class.
        /// </para>
        /// </summary>
        ~TaskbarIcon()
        {
            Dispose(false);
        }


        /// <summary>
        /// Disposes the object.
        /// </summary>
        /// <remarks>This method is not virtual by design. Derived classes
        /// should override <see cref="Dispose(bool)"/>.
        /// </remarks>
        public void Dispose()
        {
            Dispose(true);

            // This object will be cleaned up by the Dispose method.
            // Therefore, you should call GC.SupressFinalize to
            // take this object off the finalization queue 
            // and prevent finalization code for this object
            // from executing a second time.
            GC.SuppressFinalize(this);
        }


        /// <summary>
        /// Closes the tray and releases all resources.
        /// </summary>
        /// <summary>
        /// <c>Dispose(bool disposing)</c> executes in two distinct scenarios.
        /// If disposing equals <c>true</c>, the method has been called directly
        /// or indirectly by a user's code. Managed and unmanaged resources
        /// can be disposed.
        /// </summary>
        /// <param name="disposing">If disposing equals <c>false</c>, the method
        /// has been called by the runtime from inside the finalizer and you
        /// should not reference other objects. Only unmanaged resources can
        /// be disposed.</param>
        /// <remarks>Check the <see cref="IsDisposed"/> property to determine whether
        /// the method has already been called.</remarks>
        private void Dispose(bool disposing)
        {
            //don't do anything if the component is already disposed
            if (IsDisposed || !disposing) return;

            lock (this)
            {
                IsDisposed = true;

                //deregister application event listener
                if (Application.Current != null)
                {
                    Application.Current.Exit -= OnExit;
                }

                //stop timers
                singleClickTimer.Dispose();
                balloonCloseTimer.Dispose();

                //dispose message sink
                messageSink.Dispose();

                //remove icon
                RemoveTaskbarIcon();
            }
        }

        #endregion
    }
}
---- Transformed Tree ----
using System;
using System.Diagnostics;
using System.Drawing;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Interop;
using System.Windows.Threading;
using Kooboo.App.SystemTray;
using Point = Kooboo.App.SystemTray.Point;


namespace Kooboo.App.SystemTray
{
    /// <summary>
    /// A WPF proxy to for a taskbar icon (NotifyIcon) that sits in the system's
    /// taskbar notification area ("system tray").
    /// </summary>
    public partial class TaskbarIcon : FrameworkElement, IDisposable
    {
        #region Members

        public Control Parent { get; set; }

        /// <summary>
        /// Represents the current icon data.
        /// </summary>
        private NotifyIconData iconData;

        /// <summary>
        /// Receives messages from the taskbar icon.
        /// </summary>
        private readonly WindowMessageSink messageSink;

        /// <summary>
        /// An action that is being invoked if the
        /// <see cref="singleClickTimer"/> fires.
        /// </summary>
        private Action singleClickTimerAction;

        /// <summary>
        /// A timer that is used to differentiate between single
        /// and double clicks.
        /// </summary>
        private readonly Timer singleClickTimer;

        /// <summary>
        /// A timer that is used to close open balloon tooltips.
        /// </summary>
        private readonly Timer balloonCloseTimer;

        /// <summary>
        /// Indicates whether the taskbar icon has been created or not.
        /// </summary>
        public bool IsTaskbarIconCreated { get; private set; }

        /// <summary>
        /// Indicates whether custom tooltips are supported, which depends
        /// on the OS. Windows Vista or higher is required in order to
        /// support this feature.
        /// </summary>
        public bool SupportsCustomToolTips
        {
            get { return messageSink.Version == NotifyIconVersion.Vista; }
        }


        /// <summary>
        /// Checks whether a non-tooltip popup is currently opened.
        /// </summary>
        private bool IsPopupOpen
        {
            get
            {
                var popup = TrayPopupResolved;
                var menu = ContextMenu;
                var balloon = CustomBalloon;

                return popup != null && popup.IsOpen ||
                       menu != null && menu.IsOpen ||
                       balloon != null && balloon.IsOpen;
            }
        }

        private double scalingFactor = double.NaN;

        #endregion

        #region Construction

        /// <summary>
        /// Inits the taskbar icon and registers a message listener
        /// in order to receive events from the taskbar area.
        /// </summary>
        public TaskbarIcon()
        {
            //using dummy sink in design mode
            messageSink = Util.IsDesignMode
                ? WindowMessageSink.CreateEmpty()
                : new WindowMessageSink(NotifyIconVersion.Win95);

            //init icon data structure
            iconData = NotifyIconData.CreateDefault(messageSink.MessageWindowHandle);

            //create the taskbar icon
            CreateTaskbarIcon();

            //register event listeners
            messageSink.MouseEventReceived += OnMouseEvent;
            messageSink.TaskbarCreated += OnTaskbarCreated;
            messageSink.ChangeToolTipStateRequest += OnToolTipChange;

            //init single click / balloon timers
            singleClickTimer = new Timer(DoSingleClickAction);
            balloonCloseTimer = new Timer(CloseBalloonCallback);

            //register listener in order to get notified when the application closes
            if (Application.Current != null) Application.Current.Exit += OnExit;
        }

        #endregion

        #region Custom Balloons

        /// <summary>
        /// Shows a custom control as a tooltip in the tray location.
        /// </summary>
        /// <param name="balloon"></param>
        /// <param name="animation">An optional animation for the popup.</param>
        /// <param name="timeout">The time after which the popup is being closed.
        /// Submit null in order to keep the balloon open inde
        /// </param>
        /// <exception cref="ArgumentNullException">If <paramref name="balloon"/>
        /// is a null reference.</exception>
        public void ShowCustomBalloon(UIElement balloon, PopupAnimation animation, int? timeout)
        {
            Dispatcher dispatcher = this.GetDispatcher();
            if (!dispatcher.CheckAccess())
            {
                var action = new Action(() => ShowCustomBalloon(balloon, animation, timeout));
                dispatcher.Invoke(DispatcherPriority.Normal, action);
                return;
            }

            if (balloon == null) throw new ArgumentNullException("balloon");
            if (timeout.HasValue && timeout < 500)
            {
                string msg = "Invalid timeout of {0} milliseconds. Timeout must be at least 500 ms";
                msg = String.Format(msg, timeout);
                throw new ArgumentOutOfRangeException("timeout", msg);
            }

            EnsureNotDisposed();

            //make sure we don't have an open balloon
            lock (this)
            {
                CloseBalloon();
            }

            //create an invisible popup that hosts the UIElement
            Popup popup = new Popup();
            popup.AllowsTransparency = true;

            //provide the popup with the taskbar icon's data context
            UpdateDataContext(popup, null, DataContext);

            //don't animate by default - devs can use attached
            //events or override
            popup.PopupAnimation = animation;

            //in case the balloon is cleaned up through routed events, the            //control didn't remove the balloon from its parent popup when            //if was closed the last time - just make sure it doesn't have            //a parent that is a popup
            if (LogicalTreeHelper.GetParent(balloon) is Popup parent) parent.Child = null;

            if (LogicalTreeHelper.GetParent(balloon) is Popup parent)
            {
                string msg =
                    "Cannot display control [{0}] in a new balloon popup - that control already has a parent. You may consider creating new balloons every time you want to show one.";
                msg = String.Format(msg, balloon);
                throw new InvalidOperationException(msg);
            }

            popup.Child = balloon;

            //don't set the PlacementTarget as it causes the popup to become hidden if the
            //TaskbarIcon's parent is hidden, too...
            //popup.PlacementTarget = this;

            popup.Placement = PlacementMode.AbsolutePoint;
            popup.StaysOpen = true;

            Point position = TrayInfo.GetTrayLocation();
            position = GetDeviceCoordinates(position);
            popup.HorizontalOffset = position.X - 1;
            popup.VerticalOffset = position.Y - 1;

            //store reference
            lock (this)
            {
                SetCustomBalloon(popup);
            }

            //assign this instance as an attached property
            SetParentTaskbarIcon(balloon, this);

            //fire attached event
            RaiseBalloonShowingEvent(balloon, this);

            //display item
            popup.IsOpen = true;

            if (timeout.HasValue)
            {
                //register timer to close the popup
                balloonCloseTimer.Change(timeout.Value, Timeout.Infinite);
            }
        }


        /// <summary>
        /// Resets the closing timeout, which effectively
        /// keeps a displayed balloon message open until
        /// it is either closed programmatically through
        /// <see cref="CloseBalloon"/> or due to a new
        /// message being displayed.
        /// </summary>
        public void ResetBalloonCloseTimer()
        {
            if (IsDisposed) return;

            lock (this)
            {
                //reset timer in any case
                balloonCloseTimer.Change(Timeout.Infinite, Timeout.Infinite);
            }
        }


        /// <summary>
        /// Closes the current <see cref="CustomBalloon"/>, if the
        /// property is set.
        /// </summary>
        public void CloseBalloon()
        {
            if (IsDisposed) return;

            Dispatcher dispatcher = this.GetDispatcher();
            if (!dispatcher.CheckAccess())
            {
                Action action = CloseBalloon;
                dispatcher.Invoke(DispatcherPriority.Normal, action);
                return;
            }

            lock (this)
            {
                //reset timer in any case
                balloonCloseTimer.Change(Timeout.Infinite, Timeout.Infinite);

                //reset old popup, if we still have one
                Popup popup = CustomBalloon;
                if (popup != null)
                {
                    UIElement element = popup.Child;

                    //announce closing
                    RoutedEventArgs eventArgs = RaiseBalloonClosingEvent(element, this);
                    if (!eventArgs.Handled)
                    {
                        //if the event was handled, clear the reference to the popup,
                        //but don't close it - the handling code has to manage this stuff now

                        //close the popup
                        popup.IsOpen = false;

                        //remove the reference of the popup to the balloon in case we want to reuse
                        //the balloon (then added to a new popup)
                        popup.Child = null;

                        //reset attached property
                        if (element != null) SetParentTaskbarIcon(element, null);
                    }

                    //remove custom balloon anyway
                    SetCustomBalloon(null);
                }
            }
        }


        /// <summary>
        /// Timer-invoke event which closes the currently open balloon and
        /// resets the <see cref="CustomBalloon"/> dependency property.
        /// </summary>
        private void CloseBalloonCallback(object state)
        {
            if (IsDisposed) return;

            //switch to UI thread
            Action action = CloseBalloon;
            this.GetDispatcher().Invoke(action);
        }

        #endregion

        #region Process Incoming Mouse Events

        /// <summary>
        /// Processes mouse events, which are bubbled
        /// through the class' routed events, trigger
        /// certain actions (e.g. show a popup), or
        /// both.
        /// </summary>
        /// <param name="me">Event flag.</param>
        private void OnMouseEvent(MouseEvent me)
        {
            if (IsDisposed) return;

            switch (me)
            {
                case MouseEvent.MouseMove:
                    RaiseTrayMouseMoveEvent();
                    //immediately return - there's nothing left to evaluate
                    return;
                case MouseEvent.IconRightMouseDown:
                    RaiseTrayRightMouseDownEvent();
                    break;
                case MouseEvent.IconLeftMouseDown:
                    RaiseTrayLeftMouseDownEvent();
                    break;
                case MouseEvent.IconRightMouseUp:
                    RaiseTrayRightMouseUpEvent();
                    break;
                case MouseEvent.IconLeftMouseUp:
                    RaiseTrayLeftMouseUpEvent();
                    break;
                case MouseEvent.IconMiddleMouseDown:
                    RaiseTrayMiddleMouseDownEvent();
                    break;
                case MouseEvent.IconMiddleMouseUp:
                    RaiseTrayMiddleMouseUpEvent();
                    break;
                case MouseEvent.IconDoubleClick:
                    //cancel single click timer
                    singleClickTimer.Change(Timeout.Infinite, Timeout.Infinite);
                    //bubble event
                    RaiseTrayMouseDoubleClickEvent();
                    break;
                case MouseEvent.BalloonToolTipClicked:
                    RaiseTrayBalloonTipClickedEvent();
                    break;
                default:
                    throw new ArgumentOutOfRangeException("me", "Missing handler for mouse event flag: " + me);
            }


            //get mouse coordinates
            Point cursorPosition = new Point();
            if (messageSink.Version == NotifyIconVersion.Vista)
            {
                //physical cursor position is supported for Vista and above
                WinApi.GetPhysicalCursorPos(ref cursorPosition);
            }
            else
            {
                WinApi.GetCursorPos(ref cursorPosition);
            }

            cursorPosition = GetDeviceCoordinates(cursorPosition);

            bool isLeftClickCommandInvoked = false;

            //show popup, if requested
            if (me.IsMatch(PopupActivation))
            {
                if (me == MouseEvent.IconLeftMouseUp)
                {
                    //show popup once we are sure it's not a double click
                    singleClickTimerAction = () =>
                    {
                        LeftClickCommand.ExecuteIfEnabled(LeftClickCommandParameter, LeftClickCommandTarget ?? this);
                        ShowTrayPopup(cursorPosition);
                    };
                    singleClickTimer.Change(WinApi.GetDoubleClickTime(), Timeout.Infinite);
                    isLeftClickCommandInvoked = true;
                }
                else
                {
                    //show popup immediately
                    ShowTrayPopup(cursorPosition);
                }
            }


            //show context menu, if requested
            if (me.IsMatch(MenuActivation))
            {
                if (me == MouseEvent.IconLeftMouseUp)
                {
                    //show context menu once we are sure it's not a double click
                    singleClickTimerAction = () =>
                    {
                        LeftClickCommand.ExecuteIfEnabled(LeftClickCommandParameter, LeftClickCommandTarget ?? this);
                        ShowContextMenu(cursorPosition);
                    };
                    singleClickTimer.Change(WinApi.GetDoubleClickTime(), Timeout.Infinite);
                    isLeftClickCommandInvoked = true;
                }
                else
                {
                    //show context menu immediately
                    ShowContextMenu(cursorPosition);
                }
            }

            //make sure the left click command is invoked on mouse clicks
            if (me == MouseEvent.IconLeftMouseUp && !isLeftClickCommandInvoked)
            {
                //show context menu once we are sure it's not a double click
                singleClickTimerAction =
                    () =>
                    {
                        LeftClickCommand.ExecuteIfEnabled(LeftClickCommandParameter, LeftClickCommandTarget ?? this);
                    };
                singleClickTimer.Change(WinApi.GetDoubleClickTime(), Timeout.Infinite);
            }
        }

        #endregion

        #region ToolTips

        /// <summary>
        /// Displays a custom tooltip, if available. This method is only
        /// invoked for Windows Vista and above.
        /// </summary>
        /// <param name="visible">Whether to show or hide the tooltip.</param>
        private void OnToolTipChange(bool visible)
        {
            //if we don't have a tooltip, there's nothing to do here...
            if (TrayToolTipResolved == null) return;

            if (visible)
            {
                if (IsPopupOpen)
                {
                    //ignore if we are already displaying something down there
                    return;
                }

                var args = RaisePreviewTrayToolTipOpenEvent();
                if (args.Handled) return;

                TrayToolTipResolved.IsOpen = true;

                //raise attached event first
                if (TrayToolTip != null) RaiseToolTipOpenedEvent(TrayToolTip);

                //bubble routed event
                RaiseTrayToolTipOpenEvent();
            }
            else
            {
                var args = RaisePreviewTrayToolTipCloseEvent();
                if (args.Handled) return;

                //raise attached event first
                if (TrayToolTip != null) RaiseToolTipCloseEvent(TrayToolTip);

                TrayToolTipResolved.IsOpen = false;

                //bubble event
                RaiseTrayToolTipCloseEvent();
            }
        }


        /// <summary>
        /// Creates a <see cref="ToolTip"/> control that either
        /// wraps the currently set <see cref="TrayToolTip"/>
        /// control or the <see cref="ToolTipText"/> string.<br/>
        /// If <see cref="TrayToolTip"/> itself is already
        /// a <see cref="ToolTip"/> instance, it will be used directly.
        /// </summary>
        /// <remarks>We use a <see cref="ToolTip"/> rather than
        /// <see cref="Popup"/> because there was no way to prevent a
        /// popup from causing cyclic open/close commands if it was
        /// placed under the mouse. ToolTip internally uses a Popup of
        /// its own, but takes advance of Popup's internal <see cref="UIElement.IsHitTestVisible"/>
        /// property which prevents this issue.</remarks>
        private void CreateCustomToolTip()
        {
            //check if the item itself is a tooltip

            if (tt == null && TrayToolTip != null)
            {
                //create an invisible wrapper tooltip that hosts the UIElement
                tt = new ToolTip();
                tt.Placement = PlacementMode.Mouse;

                //do *not* set the placement target, as it causes the popup to become hidden if the
                //TaskbarIcon's parent is hidden, too. At runtime, the parent can be resolved through
                //the ParentTaskbarIcon attached dependency property:
                //tt.PlacementTarget = this;

                //make sure the tooltip is invisible
                tt.HasDropShadow = false;
                tt.BorderThickness = new Thickness(0);
                tt.Background = System.Windows.Media.Brushes.Transparent;

                //setting the 
                tt.StaysOpen = true;
                tt.Content = TrayToolTip;
            }
            else if (tt == null && !String.IsNullOrEmpty(ToolTipText))
            {
                //create a simple tooltip for the ToolTipText string
                tt = new ToolTip();
                tt.Content = ToolTipText;
            }

            //the tooltip explicitly gets the DataContext of this instance.
            //If there is no DataContext, the TaskbarIcon assigns itself
            if (TrayToolTip is ToolTip tt)
            {
                UpdateDataContext(tt, null, DataContext);
            }

            //store a reference to the used tooltip
            SetTrayToolTipResolved(tt);
        }


        /// <summary>
        /// Sets tooltip settings for the class depending on defined
        /// dependency properties and OS support.
        /// </summary>
        private void WriteToolTipSettings()
        {
            const IconDataMembers flags = IconDataMembers.Tip;
            iconData.ToolTipText = ToolTipText;

            if (messageSink.Version == NotifyIconVersion.Vista)
            {
                //we need to set a tooltip text to get tooltip events from the
                //taskbar icon
                if (String.IsNullOrEmpty(iconData.ToolTipText) && TrayToolTipResolved != null)
                {
                    //if we have not tooltip text but a custom tooltip, we
                    //need to set a dummy value (we're displaying the ToolTip control, not the string)
                    iconData.ToolTipText = "ToolTip";
                }
            }

            //update the tooltip text
            Util.WriteIconData(ref iconData, NotifyCommand.Modify, flags);
        }

        #endregion

        #region Custom Popup

        /// <summary>
        /// Creates a <see cref="ToolTip"/> control that either
        /// wraps the currently set <see cref="TrayToolTip"/>
        /// control or the <see cref="ToolTipText"/> string.<br/>
        /// If <see cref="TrayToolTip"/> itself is already
        /// a <see cref="ToolTip"/> instance, it will be used directly.
        /// </summary>
        /// <remarks>We use a <see cref="ToolTip"/> rather than
        /// <see cref="Popup"/> because there was no way to prevent a
        /// popup from causing cyclic open/close commands if it was
        /// placed under the mouse. ToolTip internally uses a Popup of
        /// its own, but takes advance of Popup's internal <see cref="UIElement.IsHitTestVisible"/>
        /// property which prevents this issue.</remarks>
        private void CreatePopup()
        {
            //check if the item itself is a popup

            if (popup == null && TrayPopup != null)
            {
                //create an invisible popup that hosts the UIElement
                popup = new Popup();
                popup.AllowsTransparency = true;

                //don't animate by default - devs can use attached
                //events or override
                popup.PopupAnimation = PopupAnimation.None;

                //the CreateRootPopup method outputs binding errors in the debug window because
                //it tries to bind to "Popup-specific" properties in case they are provided by the child.
                //We don't need that so just assign the control as the child.
                popup.Child = TrayPopup;

                //do *not* set the placement target, as it causes the popup to become hidden if the
                //TaskbarIcon's parent is hidden, too. At runtime, the parent can be resolved through
                //the ParentTaskbarIcon attached dependency property:
                //popup.PlacementTarget = this;

                popup.Placement = PlacementMode.AbsolutePoint;
                popup.StaysOpen = false;
            }

            //the popup explicitly gets the DataContext of this instance.
            //If there is no DataContext, the TaskbarIcon assigns itself
            if (TrayPopup is Popup popup)
            {
                UpdateDataContext(popup, null, DataContext);
            }

            //store a reference to the used tooltip
            SetTrayPopupResolved(popup);
        }


        /// <summary>
        /// Displays the <see cref="TrayPopup"/> control if
        /// it was set.
        /// </summary>
        private void ShowTrayPopup(Point cursorPosition)
        {
            if (IsDisposed) return;

            //raise preview event no matter whether popup is currently set
            //or not (enables client to set it on demand)
            var args = RaisePreviewTrayPopupOpenEvent();
            if (args.Handled) return;

            if (TrayPopup != null)
            {
                //use absolute position, but place the popup centered above the icon
                TrayPopupResolved.Placement = PlacementMode.AbsolutePoint;
                TrayPopupResolved.HorizontalOffset = cursorPosition.X;
                TrayPopupResolved.VerticalOffset = cursorPosition.Y;

                //open popup
                TrayPopupResolved.IsOpen = true;

                IntPtr handle = IntPtr.Zero;
                if (TrayPopupResolved.Child != null)
                {
                    //try to get a handle on the popup itself (via its child)
                    HwndSource source = (HwndSource) PresentationSource.FromVisual(TrayPopupResolved.Child);
                    if (source != null) handle = source.Handle;
                }

                //if we don't have a handle for the popup, fall back to the message sink
                if (handle == IntPtr.Zero) handle = messageSink.MessageWindowHandle;

                //activate either popup or message sink to track deactivation.
                //otherwise, the popup does not close if the user clicks somewhere else
                WinApi.SetForegroundWindow(handle);

                //raise attached event - item should never be null unless developers
                //changed the CustomPopup directly...
                if (TrayPopup != null) RaisePopupOpenedEvent(TrayPopup);

                //bubble routed event
                RaiseTrayPopupOpenEvent();
            }
        }

        #endregion

        #region Context Menu

        /// <summary>
        /// Displays the <see cref="ContextMenu"/> if
        /// it was set.
        /// </summary>
        private void ShowContextMenu(Point cursorPosition)
        {
            if (IsDisposed) return;

            //raise preview event no matter whether context menu is currently set
            //or not (enables client to set it on demand)
            var args = RaisePreviewTrayContextMenuOpenEvent();
            if (args.Handled) return;

            if (ContextMenu != null)
            {
                //use absolute positioning. We need to set the coordinates, or a delayed opening
                //(e.g. when left-clicked) opens the context menu at the wrong place if the mouse
                //is moved!
                ContextMenu.Placement = PlacementMode.AbsolutePoint;
                ContextMenu.HorizontalOffset = cursorPosition.X;
                ContextMenu.VerticalOffset = cursorPosition.Y;
                ContextMenu.IsOpen = true;

                IntPtr handle = IntPtr.Zero;

                //try to get a handle on the context itself
                HwndSource source = (HwndSource) PresentationSource.FromVisual(ContextMenu);
                if (source != null)
                {
                    handle = source.Handle;
                }

                //if we don't have a handle for the popup, fall back to the message sink
                if (handle == IntPtr.Zero) handle = messageSink.MessageWindowHandle;

                //activate the context menu or the message window to track deactivation - otherwise, the context menu
                //does not close if the user clicks somewhere else. With the message window
                //fallback, the context menu can't receive keyboard events - should not happen though
                WinApi.SetForegroundWindow(handle);

                //bubble event
                RaiseTrayContextMenuOpenEvent();
            }
        }

        #endregion

        #region Single Click Timer event

        /// <summary>
        /// Performs a delayed action if the user requested an action
        /// based on a single click of the left mouse.<br/>
        /// This method is invoked by the <see cref="singleClickTimer"/>.
        /// </summary>
        private void DoSingleClickAction(object state)
        {
            if (IsDisposed) return;

            //run action
            Action action = singleClickTimerAction;
            if (action != null)
            {
                //cleanup action
                singleClickTimerAction = null;

                //switch to UI thread
                this.GetDispatcher().Invoke(action);
            }
        }

        #endregion

        #region Set Version (API)

        /// <summary>
        /// Sets the version flag for the <see cref="iconData"/>.
        /// </summary>
        private void SetVersion()
        {
            iconData.VersionOrTimeout = (uint) NotifyIconVersion.Vista;
            bool status = WinApi.Shell_NotifyIcon(NotifyCommand.SetVersion, ref iconData);

            if (!status)
            {
                iconData.VersionOrTimeout = (uint) NotifyIconVersion.Win2000;
                status = Util.WriteIconData(ref iconData, NotifyCommand.SetVersion);
            }

            if (!status)
            {
                iconData.VersionOrTimeout = (uint) NotifyIconVersion.Win95;
                status = Util.WriteIconData(ref iconData, NotifyCommand.SetVersion);
            }

            if (!status)
            {
                Debug.Fail("Could not set version");
            }
        }

        #endregion

        #region Create / Remove Taskbar Icon

        /// <summary>
        /// Recreates the taskbar icon if the whole taskbar was
        /// recreated (e.g. because Explorer was shut down).
        /// </summary>
        private void OnTaskbarCreated()
        {
            IsTaskbarIconCreated = false;
            CreateTaskbarIcon();
        }


        /// <summary>
        /// Creates the taskbar icon. This message is invoked during initialization,
        /// if the taskbar is restarted, and whenever the icon is displayed.
        /// </summary>
        private void CreateTaskbarIcon()
        {
            lock (this)
            {
                if (!IsTaskbarIconCreated)
                {
                    const IconDataMembers members = IconDataMembers.Message
                                                    | IconDataMembers.Icon
                                                    | IconDataMembers.Tip;

                    //write initial configuration
                    var status = Util.WriteIconData(ref iconData, NotifyCommand.Add, members);
                    if (!status)
                    {
                        //couldn't create the icon - we can assume this is because explorer is not running (yet!)
                        //-> try a bit later again rather than throwing an exception. Typically, if the windows
                        // shell is being loaded later, this method is being reinvoked from OnTaskbarCreated
                        // (we could also retry after a delay, but that's currently YAGNI)
                        return;
                    }

                    //set to most recent version
                    SetVersion();
                    messageSink.Version = (NotifyIconVersion) iconData.VersionOrTimeout;

                    IsTaskbarIconCreated = true;
                }
            }
        }

        /// <summary>
        /// Closes the taskbar icon if required.
        /// </summary>
        private void RemoveTaskbarIcon()
        {
            lock (this)
            {
                //make sure we didn't schedule a creation

                if (IsTaskbarIconCreated)
                {
                    Util.WriteIconData(ref iconData, NotifyCommand.Delete, IconDataMembers.Message);
                    IsTaskbarIconCreated = false;
                }
            }
        }

        #endregion

        /// <summary>
        /// Recalculates OS coordinates in order to support WPFs coordinate
        /// system if OS scaling (DPIs) is not 100%.
        /// </summary>
        /// <param name="point"></param>
        /// <returns></returns>
        private Point GetDeviceCoordinates(Point point)
        {
            if (double.IsNaN(scalingFactor))
            {
                //calculate scaling factor in order to support non-standard DPIs
                var presentationSource = PresentationSource.FromVisual(this);
                if (presentationSource == null)
                {
                    scalingFactor = 1;
                }
                else
                {
                    var transform = presentationSource.CompositionTarget.TransformToDevice;
                    scalingFactor = 1/transform.M11;
                }
            }

            //on standard DPI settings, just return the point
            if (scalingFactor == 1.0) return point;

            return new Point() {X = (int) (point.X*scalingFactor), Y = (int) (point.Y*scalingFactor)};
        }

        #region Dispose / Exit

        /// <summary>
        /// Set to true as soon as <c>Dispose</c> has been invoked.
        /// </summary>
        public bool IsDisposed { get; private set; }


        /// <summary>
        /// Checks if the object has been disposed and
        /// raises a <see cref="ObjectDisposedException"/> in case
        /// the <see cref="IsDisposed"/> flag is true.
        /// </summary>
        private void EnsureNotDisposed()
        {
            if (IsDisposed) throw new ObjectDisposedException(Name ?? GetType().FullName);
        }


        /// <summary>
        /// Disposes the class if the application exits.
        /// </summary>
        private void OnExit(object sender, EventArgs e)
        {
            Dispose();
        }


        /// <summary>
        /// This destructor will run only if the <see cref="Dispose()"/>
        /// method does not get called. This gives this base class the
        /// opportunity to finalize.
        /// <para>
        /// Important: Do not provide destructors in types derived from
        /// this class.
        /// </para>
        /// </summary>
        ~TaskbarIcon()
        {
            Dispose(false);
        }


        /// <summary>
        /// Disposes the object.
        /// </summary>
        /// <remarks>This method is not virtual by design. Derived classes
        /// should override <see cref="Dispose(bool)"/>.
        /// </remarks>
        public void Dispose()
        {
            Dispose(true);

            // This object will be cleaned up by the Dispose method.
            // Therefore, you should call GC.SupressFinalize to
            // take this object off the finalization queue 
            // and prevent finalization code for this object
            // from executing a second time.
            GC.SuppressFinalize(this);
        }


        /// <summary>
        /// Closes the tray and releases all resources.
        /// </summary>
        /// <summary>
        /// <c>Dispose(bool disposing)</c> executes in two distinct scenarios.
        /// If disposing equals <c>true</c>, the method has been called directly
        /// or indirectly by a user's code. Managed and unmanaged resources
        /// can be disposed.
        /// </summary>
        /// <param name="disposing">If disposing equals <c>false</c>, the method
        /// has been called by the runtime from inside the finalizer and you
        /// should not reference other objects. Only unmanaged resources can
        /// be disposed.</param>
        /// <remarks>Check the <see cref="IsDisposed"/> property to determine whether
        /// the method has already been called.</remarks>
        private void Dispose(bool disposing)
        {
            //don't do anything if the component is already disposed
            if (IsDisposed || !disposing) return;

            lock (this)
            {
                IsDisposed = true;

                //deregister application event listener
                if (Application.Current != null)
                {
                    Application.Current.Exit -= OnExit;
                }

                //stop timers
                singleClickTimer.Dispose();
                balloonCloseTimer.Dispose();

                //dispose message sink
                messageSink.Dispose();

                //remove icon
                RemoveTaskbarIcon();
            }
        }

        #endregion
    }
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(48,24): warning CS0108: 'TaskbarIcon.Parent' hides inherited member 'FrameworkElement.Parent'. Use the new keyword if hiding was intended.,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(34,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(27,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(35,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(48,24): warning CS0108: 'TaskbarIcon.Parent' hides inherited member 'FrameworkElement.Parent'. Use the new keyword if hiding was intended.,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(200,63): error CS0128: A local variable or function named 'parent' is already defined in this scope,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(520,17): error CS0841: Cannot use local variable 'tt' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(523,17): error CS0841: Cannot use local variable 'tt' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(524,17): error CS0841: Cannot use local variable 'tt' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(532,17): error CS0841: Cannot use local variable 'tt' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(533,17): error CS0841: Cannot use local variable 'tt' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(534,17): error CS0841: Cannot use local variable 'tt' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(537,17): error CS0841: Cannot use local variable 'tt' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(538,17): error CS0841: Cannot use local variable 'tt' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(540,22): error CS0841: Cannot use local variable 'tt' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(543,17): error CS0841: Cannot use local variable 'tt' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(544,17): error CS0841: Cannot use local variable 'tt' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(605,17): error CS0841: Cannot use local variable 'popup' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(608,17): error CS0841: Cannot use local variable 'popup' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(609,17): error CS0841: Cannot use local variable 'popup' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(613,17): error CS0841: Cannot use local variable 'popup' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(618,17): error CS0841: Cannot use local variable 'popup' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(625,17): error CS0841: Cannot use local variable 'popup' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(626,17): error CS0841: Cannot use local variable 'popup' before it is declared,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(34,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(27,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Kooboo.App\SystemTray\TaskbarIcon.cs(35,1): hidden CS8019: Unnecessary using directive.
######################################################################


