Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10



Project: dotNetRDF(net40)
    #1 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\CachedObjectKey.cs, Line: 66, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #2 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 1499, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #3 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 1516, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #4 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 456, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #5 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 584, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #6 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 605, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #7 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 626, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #8 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 647, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #9 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 668, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #10 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 689, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #11 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 719, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #12 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 855, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #13 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 905, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #14 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ConfigurationLoader.cs, Line: 950, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #15 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\DataFactories.cs, Line: 153, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #16 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\DataFactories.cs, Line: 264, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #17 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\DataFactories.cs, Line: 363, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #18 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\DataFactories.cs, Line: 383, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #19 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\DataFactories.cs, Line: 422, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #20 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\DataFactories.cs, Line: 440, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #21 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\DataFactories.cs, Line: 9, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #22 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\DataFactories.cs, Line: 92, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #23 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\DatasetFactory.cs, Line: 100, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #24 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\DatasetFactory.cs, Line: 120, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #25 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\DatasetFactory.cs, Line: 69, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #26 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\EndpointFactories.cs, Line: 120, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #27 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\EndpointFactories.cs, Line: 86, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #28 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\OperatorFactory.cs, Line: 56, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #29 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\OptimiserFactory.cs, Line: 74, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #30 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\PermissionFactories.cs, Line: 139, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #31 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\PermissionFactories.cs, Line: 154, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #32 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 106, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #33 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 121, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #34 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 136, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #35 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 150, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #36 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 164, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #37 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 244, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #38 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 258, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #39 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 273, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #40 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 287, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #41 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 358, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #42 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 381, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #43 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 397, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #44 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 4, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #45 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ProcessorFactories.cs, Line: 412, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #46 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ReasonerFactory.cs, Line: 71, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #47 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ReasonerFactory.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #48 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\ReasonerFactory.cs, Line: 97, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #49 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\StorageFactories.cs, Line: 14, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #50 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\StorageFactories.cs, Line: 170, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #51 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\StorageFactories.cs, Line: 186, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #52 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\StorageFactories.cs, Line: 207, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #53 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\StorageFactories.cs, Line: 221, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #54 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\StorageFactories.cs, Line: 290, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #55 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\StorageFactories.cs, Line: 346, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #56 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\StorageFactories.cs, Line: 383, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #57 Path: D:\a\1\s\Libraries\dotNetRDF\Configuration\StorageFactories.cs, Line: 535, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #58 Path: D:\a\1\s\Libraries\dotNetRDF\Core\BlankNode.cs, Line: 157, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #59 Path: D:\a\1\s\Libraries\dotNetRDF\Core\GraphLiteralNode.cs, Line: 120, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #60 Path: D:\a\1\s\Libraries\dotNetRDF\Core\GraphMatcher.cs, Line: 1111, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #61 Path: D:\a\1\s\Libraries\dotNetRDF\Core\GraphPersistenceWrapper.cs, Line: 657, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #62 Path: D:\a\1\s\Libraries\dotNetRDF\Core\LiteralNode.cs, Line: 255, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #63 Path: D:\a\1\s\Libraries\dotNetRDF\Core\MIMETypesHelper.cs, Line: 1082, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #64 Path: D:\a\1\s\Libraries\dotNetRDF\Core\MIMETypesHelper.cs, Line: 1086, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #65 Path: D:\a\1\s\Libraries\dotNetRDF\Core\MIMETypesHelper.cs, Line: 1098, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #66 Path: D:\a\1\s\Libraries\dotNetRDF\Core\PersistentTripleStore.cs, Line: 182, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #67 Path: D:\a\1\s\Libraries\dotNetRDF\Core\PersistentTripleStore.cs, Line: 210, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #68 Path: D:\a\1\s\Libraries\dotNetRDF\Core\Tools.cs, Line: 322, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #69 Path: D:\a\1\s\Libraries\dotNetRDF\Core\Triple.cs, Line: 355, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #70 Path: D:\a\1\s\Libraries\dotNetRDF\Core\URINode.cs, Line: 152, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #71 Path: D:\a\1\s\Libraries\dotNetRDF\Core\VariableNode.cs, Line: 201, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #72 Path: D:\a\1\s\Libraries\dotNetRDF\Core\WrapperGraph.cs, Line: 529, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #73 Path: D:\a\1\s\Libraries\dotNetRDF\JsonLd\JsonLdProcessor.cs, Line: 299, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #74 Path: D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs, Line: 307, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #75 Path: D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs, Line: 342, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #76 Path: D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs, Line: 362, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #77 Path: D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs, Line: 502, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #78 Path: D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\FramingProcessor.cs, Line: 695, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #79 Path: D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\NodeMapGenerator.cs, Line: 75, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #80 Path: D:\a\1\s\Libraries\dotNetRDF\Ontology\OntologyClass.cs, Line: 696, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #81 Path: D:\a\1\s\Libraries\dotNetRDF\Ontology\OntologyResource.cs, Line: 1155, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #82 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\BaseGZipDatasetParser.cs, Line: 103, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #83 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\BaseGZipParser.cs, Line: 120, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #84 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\BaseGZipResultsParser.cs, Line: 121, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #85 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\BlockingTextReader.cs, Line: 57, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #86 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Events\RdfXml\DomBasedEventGenerator.cs, Line: 11, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #87 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Events\RdfXml\DomBasedEventGenerator.cs, Line: 15, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #88 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Events\RdfXml\DomBasedEventGenerator.cs, Line: 17, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #89 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Events\RdfXml\DomBasedEventGenerator.cs, Line: 212, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #90 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Events\RdfXml\DomBasedEventGenerator.cs, Line: 475, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #91 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Events\RdfXml\DomBasedEventGenerator.cs, Line: 534, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #92 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Events\RdfXml\StreamingEventGenerator.cs, Line: 342, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #93 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Events\RdfXml\StreamingEventGenerator.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #94 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Events\RdfXml\StreamingEventGenerator.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #95 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Events\RdfXml\StreamingEventGenerator.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #96 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Events\RdfXml\StreamingEventGenerator.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #97 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Handlers\HandlerExtensions.cs, Line: 46, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #98 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Handlers\HandlerExtensions.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #99 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Handlers\WriteThroughHandler.cs, Line: 153, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #100 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Handlers\WriteThroughHandler.cs, Line: 166, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #101 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Handlers\WriteThroughHandler.cs, Line: 185, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #102 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Handlers\WriteThroughHandler.cs, Line: 190, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #103 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Handlers\WriteThroughHandler.cs, Line: 205, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #104 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\Handlers\WriteThroughHandler.cs, Line: 368, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #105 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\NQuadsParser.cs, Line: 192, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #106 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\RdfAParserBase.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #107 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\RdfAParserBase.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #108 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\RdfAParserBase.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #109 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\RDFXMLParser.cs, Line: 1583, Message: ReSharper: ReplaceWithSingleCallToCount. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #110 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\SPARQLQueryParser.cs, Line: 1113, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #111 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\SPARQLQueryParser.cs, Line: 726, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #112 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\SparqlUpdateParser.cs, Line: 876, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #113 Path: D:\a\1\s\Libraries\dotNetRDF\Parsing\TriXParser.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #114 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\Extend.cs, Line: 104, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #115 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\Filter.cs, Line: 191, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #116 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\FilteredProduct.cs, Line: 88, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #117 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\Having.cs, Line: 72, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #118 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\LazyBgp.cs, Line: 464, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #119 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\Multiset.cs, Line: 229, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #120 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\PropertyPathOperators.cs, Line: 185, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #121 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\PropertyPathOperators.cs, Line: 242, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #122 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\RestrictionFilters.cs, Line: 317, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #123 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\RestrictionFilters.cs, Line: 350, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #124 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Builder\DescribeBuilder.cs, Line: 60, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #125 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Builder\Expressions\LiteralExpressionExtensions.cs, Line: 65, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #126 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Builder\GraphPatternBuilder.cs, Line: 218, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #127 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Builder\GraphPatternBuilder.cs, Line: 233, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #128 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Builder\PatternItemFactory.cs, Line: 112, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #129 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Builder\PatternItemFactory.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #130 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Builder\PatternItemFactory.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #131 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Builder\SelectAssignmentVariableNamePart.cs, Line: 50, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #132 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Datasets\InMemoryDataset.cs, Line: 313, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #133 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Datasets\InMemoryQuadDataset.cs, Line: 394, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #134 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Datasets\WrapperDataset.cs, Line: 367, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #135 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Datasets\WrapperDataset.cs, Line: 66, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #136 Path: D:\a\1\s\Libraries\dotNetRDF\Query\ExplainQueryProcessor.cs, Line: 280, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #137 Path: D:\a\1\s\Libraries\dotNetRDF\Query\ExplainQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #138 Path: D:\a\1\s\Libraries\dotNetRDF\Query\ExplainQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #139 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Expressions\Functions\Sparql\Boolean\ExistsFunction.cs, Line: 313, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #140 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Expressions\Functions\Sparql\Boolean\LangMatchesFunction.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #141 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Expressions\Functions\Sparql\String\StrAfterFunction.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #142 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Expressions\Functions\Sparql\String\StrBeforeFunction.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #143 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 392, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #144 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #145 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #146 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #147 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #148 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #149 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #150 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #151 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #152 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #153 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #154 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #155 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #156 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #157 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #158 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #159 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #160 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #161 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #162 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #163 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #164 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #165 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #166 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #167 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #168 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #169 Path: D:\a\1\s\Libraries\dotNetRDF\Query\LeviathanQueryProcessor.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #170 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\FilteredProductOptimiser.cs, Line: 104, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #171 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\FilteredProductOptimiser.cs, Line: 25, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #172 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\FilteredProductOptimiser.cs, Line: 46, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #173 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\FilteredProductOptimiser.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #174 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\FilteredProductOptimiser.cs, Line: 56, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #175 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\IdentityFilterOptimiser.cs, Line: 121, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #176 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\IdentityFilterOptimiser.cs, Line: 33, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #177 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\IdentityFilterOptimiser.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #178 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\IdentityFilterOptimiser.cs, Line: 55, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #179 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\IdentityFilterOptimiser.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #180 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\ImplicitJoinOptimiser.cs, Line: 174, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #181 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\ImplicitJoinOptimiser.cs, Line: 207, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #182 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\ImplicitJoinOptimiser.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #183 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\ImplicitJoinOptimiser.cs, Line: 54, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #184 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\ImplicitJoinOptimiser.cs, Line: 57, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #185 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\ImplicitJoinOptimiser.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #186 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\ImplicitJoinOptimiser.cs, Line: 87, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #187 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\OrderByDistinctOptimiser.cs, Line: 37, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #188 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\OrderByDistinctOptimiser.cs, Line: 41, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #189 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\OrderByDistinctOptimiser.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #190 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\OrderByDistinctOptimiser.cs, Line: 56, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #191 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\ParallelEvaluationOptimiser.cs, Line: 12, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #192 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\ParallelEvaluationOptimiser.cs, Line: 58, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #193 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\ParallelEvaluationOptimiser.cs, Line: 80, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #194 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\PropertyFunctionOptimiser.cs, Line: 47, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #195 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\PropertyFunctionOptimiser.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #196 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\PropertyFunctionOptimiser.cs, Line: 52, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #197 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\StrictAlgebraOptimiser.cs, Line: 48, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #198 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\StrictAlgebraOptimiser.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #199 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\StrictAlgebraOptimiser.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #200 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\VariableSubstitutionTransformer.cs, Line: 117, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #201 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\VariableSubstitutionTransformer.cs, Line: 249, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #202 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\VariableSubstitutionTransformer.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #203 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\VariableSubstitutionTransformer.cs, Line: 77, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #204 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\VariableSubstitutionTransformer.cs, Line: 77, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #205 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\VirtualAlgebraOptimiser.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #206 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\VirtualAlgebraOptimiser.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #207 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\VirtualAlgebraOptimiser.cs, Line: 70, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #208 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Paths\PartialPath.cs, Line: 169, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #209 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Paths\PathTransformContext.cs, Line: 196, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #210 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Patterns\BindingsPattern.cs, Line: 196, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #211 Path: D:\a\1\s\Libraries\dotNetRDF\Query\Patterns\GraphPattern.cs, Line: 452, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #212 Path: D:\a\1\s\Libraries\dotNetRDF\Query\QueryExtensions.cs, Line: 61, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #213 Path: D:\a\1\s\Libraries\dotNetRDF\Query\SparqlParameterizedString.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #214 Path: D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLRemoteEndpoint.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #215 Path: D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLRemoteEndpoint.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #216 Path: D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLRemoteEndpoint.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #217 Path: D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLRemoteEndpoint.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #218 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\BatchTriple.cs, Line: 80, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #219 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\FusekiConnector.cs, Line: 143, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #220 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\Management\SesameServer.cs, Line: 192, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #221 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\Management\StardogServer.cs, Line: 233, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #222 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\Management\StardogServer.cs, Line: 437, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #223 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\ReadOnlyConnector.cs, Line: 281, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #224 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\SparqlConnector.cs, Line: 543, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #225 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\SparqlConnector.cs, Line: 890, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #226 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\SparqlHttpProtocolConnector.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #227 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\StardogConnector.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #228 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\StardogConnector.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #229 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\StardogConnector.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #230 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\StardogConnector.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #231 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\StardogConnector.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #232 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\StardogConnector.cs, Line: 806, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #233 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\StorageHelper.cs, Line: 124, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #234 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\StorageHelper.cs, Line: 140, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #235 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\StorageHelper.cs, Line: 158, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #236 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\Virtualisation\VirtualNode.cs, Line: 450, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #237 Path: D:\a\1\s\Libraries\dotNetRDF\Storage\Virtualisation\VirtualNode.cs, Line: 553, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #238 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 1000, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #239 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 1098, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #240 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 1149, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #241 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 138, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #242 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 1455, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #243 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 225, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #244 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 292, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #245 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 325, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #246 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 37, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #247 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 37, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #248 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 390, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #249 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 420, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #250 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 55, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #251 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 605, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #252 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #253 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #254 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #255 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 722, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #256 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 815, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #257 Path: D:\a\1\s\Libraries\dotNetRDF\Update\GenericUpdateProcessor.cs, Line: 89, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #258 Path: D:\a\1\s\Libraries\dotNetRDF\Update\Protocol\BaseProtocolProcessor.cs, Line: 246, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #259 Path: D:\a\1\s\Libraries\dotNetRDF\Update\Protocol\GenericProtocolProcessor.cs, Line: 16, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #260 Path: D:\a\1\s\Libraries\dotNetRDF\Update\Protocol\GenericProtocolProcessor.cs, Line: 342, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #261 Path: D:\a\1\s\Libraries\dotNetRDF\Update\Protocol\ProtocolToUpdateProcessor.cs, Line: 220, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #262 Path: D:\a\1\s\Libraries\dotNetRDF\Update\Protocol\ProtocolToUpdateProcessor.cs, Line: 457, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #263 Path: D:\a\1\s\Libraries\dotNetRDF\Update\SimpleUpdateProcessor.cs, Line: 61, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #264 Path: D:\a\1\s\Libraries\dotNetRDF\Web\HttpContextExtensions.cs, Line: 44, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #265 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\BaseGZipDatasetWriter.cs, Line: 76, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #266 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\BaseGZipResultsWriter.cs, Line: 78, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #267 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #268 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #269 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #270 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 10, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #271 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 12, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #272 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 391, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #273 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 391, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #274 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #275 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 574, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #276 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #277 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #278 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 733, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #279 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #280 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #281 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #282 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #283 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 828, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #284 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\Formatting\SparqlFormatter.cs, Line: 934, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #285 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\HtmlSchemaWriter.cs, Line: 182, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #286 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\HtmlSchemaWriter.cs, Line: 352, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #287 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\HtmlSchemaWriter.cs, Line: 402, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #288 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\WriterUtilities.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #289 Path: D:\a\1\s\Libraries\dotNetRDF\Writing\WriterUtilities.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256



Project: dotNetRDF.Query.FullText
    #290 Path: D:\a\1\s\Libraries\dotNetRDF.Query.FullText\FullTextExtensions.cs, Line: 208, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: dotNetRDF.Query.Spin(net40)
    #291 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Constructors\ConstructorExtensions.cs, Line: 53, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #292 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Core\SPINLabels.cs, Line: 71, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #293 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Model\BaseImpl\AggregationImpl.cs, Line: 96, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #294 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Model\BaseImpl\ModifyImpl.cs, Line: 100, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #295 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Model\BaseImpl\ModifyImpl.cs, Line: 87, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #296 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Model\BaseImpl\ModuleImpl.cs, Line: 65, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #297 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Model\BaseImpl\QueryImpl.cs, Line: 156, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #298 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Model\BaseImpl\QueryImpl.cs, Line: 167, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #299 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Model\BaseImpl\QueryImpl.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #300 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Model\BaseImpl\QueryImpl.cs, Line: 81, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #301 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Model\BaseImpl\SelectImpl.cs, Line: 95, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #302 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\SparqlUtil\BaseSparqlPrinter.cs, Line: 436, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #303 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\SparqlUtil\SpinSyntax.cs, Line: 500, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #304 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\SparqlUtil\SpinSyntax.cs, Line: 546, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #305 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\SparqlUtil\SpinSyntax.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #306 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\SparqlUtil\SpinSyntax.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #307 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\SparqlUtil\SpinSyntax.cs, Line: 8, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #308 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\SparqlUtil\SpinSyntax.cs, Line: 9, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #309 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\SpinProcessor.cs, Line: 200, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #310 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs, Line: 260, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #311 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs, Line: 270, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #312 Path: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs, Line: 279, Message: SonarQube: Null checks should not be used with "is". See https://rules.sonarsource.com/csharp/RSPEC-4201 / ReSharper: Merge sequential checks in && or || expressions. See https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: unittest(net452)
    #313 Path: D:\a\1\s\Testing\unittest\Core\GraphDiffTests.cs, Line: 247, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #314 Path: D:\a\1\s\Testing\unittest\Core\GraphDiffTests.cs, Line: 249, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #315 Path: D:\a\1\s\Testing\unittest\Core\HardGraphMatching.cs, Line: 294, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #316 Path: D:\a\1\s\Testing\unittest\Core\HardGraphMatching.cs, Line: 296, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #317 Path: D:\a\1\s\Testing\unittest\JsonLd\JsonLdTestSuiteBase.cs, Line: 488, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #318 Path: D:\a\1\s\Testing\unittest\JsonLd\JsonLdTestSuiteDataSource.cs, Line: 180, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #319 Path: D:\a\1\s\Testing\unittest\JsonLd\JsonLdTestSuiteDataSource.cs, Line: 257, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #320 Path: D:\a\1\s\Testing\unittest\JsonLd\JsonLdTestSuiteDataSource.cs, Line: 82, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #321 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 208, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #322 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 228, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #323 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 247, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #324 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 267, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #325 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 287, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #326 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 306, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #327 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 325, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #328 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 344, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #329 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 377, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #330 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 396, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #331 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 415, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #332 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 460, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #333 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 479, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #334 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 498, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #335 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 543, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #336 Path: D:\a\1\s\Testing\unittest\Parsing\GZipTests.cs, Line: 562, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #337 Path: D:\a\1\s\Testing\unittest\Parsing\LoaderTests.cs, Line: 303, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #338 Path: D:\a\1\s\Testing\unittest\Parsing\LoaderTests.cs, Line: 318, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #339 Path: D:\a\1\s\Testing\unittest\Parsing\RdfATests.cs, Line: 85, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #340 Path: D:\a\1\s\Testing\unittest\Parsing\RdfATests.cs, Line: 88, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #341 Path: D:\a\1\s\Testing\unittest\Parsing\RdfXmlTests.cs, Line: 68, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #342 Path: D:\a\1\s\Testing\unittest\Parsing\Suites\BaseParserSuite.cs, Line: 368, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #343 Path: D:\a\1\s\Testing\unittest\Parsing\Suites\RdfA.cs, Line: 213, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #344 Path: D:\a\1\s\Testing\unittest\Query\ConstructWithOptionalTests.cs, Line: 72, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #345 Path: D:\a\1\s\Testing\unittest\Query\DataTableTests.cs, Line: 106, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #346 Path: D:\a\1\s\Testing\unittest\Query\DataTableTests.cs, Line: 164, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #347 Path: D:\a\1\s\Testing\unittest\Query\DataTableTests.cs, Line: 200, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #348 Path: D:\a\1\s\Testing\unittest\Query\DataTableTests.cs, Line: 236, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #349 Path: D:\a\1\s\Testing\unittest\Query\DataTableTests.cs, Line: 274, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #350 Path: D:\a\1\s\Testing\unittest\Query\DataTableTests.cs, Line: 48, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #351 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests.cs, Line: 110, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #352 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests.cs, Line: 139, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #353 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests.cs, Line: 282, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #354 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests.cs, Line: 312, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #355 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests.cs, Line: 344, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #356 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests.cs, Line: 374, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #357 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests.cs, Line: 407, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #358 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests.cs, Line: 63, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #359 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests.cs, Line: 82, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #360 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests2.cs, Line: 111, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #361 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests2.cs, Line: 141, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #362 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests2.cs, Line: 173, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #363 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests2.cs, Line: 205, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #364 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests2.cs, Line: 237, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #365 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests2.cs, Line: 269, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #366 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests2.cs, Line: 301, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #367 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests2.cs, Line: 333, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #368 Path: D:\a\1\s\Testing\unittest\Query\DefaultGraphTests2.cs, Line: 81, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #369 Path: D:\a\1\s\Testing\unittest\Query\FilterPlacementTests.cs, Line: 53, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #370 Path: D:\a\1\s\Testing\unittest\Query\FullText\FullTextSparqlTests.cs, Line: 106, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #371 Path: D:\a\1\s\Testing\unittest\Query\FullText\FullTextSparqlTests2.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #372 Path: D:\a\1\s\Testing\unittest\Query\GroupByTests.cs, Line: 102, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #373 Path: D:\a\1\s\Testing\unittest\Query\GroupByTests.cs, Line: 130, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #374 Path: D:\a\1\s\Testing\unittest\Query\GroupByTests.cs, Line: 161, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #375 Path: D:\a\1\s\Testing\unittest\Query\GroupByTests.cs, Line: 192, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #376 Path: D:\a\1\s\Testing\unittest\Query\GroupByTests.cs, Line: 74, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #377 Path: D:\a\1\s\Testing\unittest\Query\LeviathanTests.cs, Line: 449, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #378 Path: D:\a\1\s\Testing\unittest\Query\LeviathanTests.cs, Line: 65, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #379 Path: D:\a\1\s\Testing\unittest\Query\ParallelEvaluation.cs, Line: 100, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #380 Path: D:\a\1\s\Testing\unittest\Query\QueryTimeouts.cs, Line: 126, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #381 Path: D:\a\1\s\Testing\unittest\Query\QueryTimeouts.cs, Line: 318, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #382 Path: D:\a\1\s\Testing\unittest\Query\QueryTimeouts.cs, Line: 352, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #383 Path: D:\a\1\s\Testing\unittest\Query\SparqlNewFunctions.cs, Line: 108, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #384 Path: D:\a\1\s\Testing\unittest\Query\SparqlNewFunctions.cs, Line: 90, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #385 Path: D:\a\1\s\Testing\unittest\Query\SparqlParsingComplex.cs, Line: 77, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #386 Path: D:\a\1\s\Testing\unittest\Query\SparqlTests.cs, Line: 349, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #387 Path: D:\a\1\s\Testing\unittest\Query\SparqlTests.cs, Line: 515, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #388 Path: D:\a\1\s\Testing\unittest\Storage\AllegroGraphTests.cs, Line: 193, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #389 Path: D:\a\1\s\Testing\unittest\Storage\AllegroGraphTests.cs, Line: 274, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #390 Path: D:\a\1\s\Testing\unittest\Storage\FusekiTest.cs, Line: 442, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #391 Path: D:\a\1\s\Testing\unittest\Storage\ReadWriteSparqlTest.cs, Line: 411, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #392 Path: D:\a\1\s\Testing\unittest\Storage\VirtuosoTest.cs, Line: 18, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #393 Path: D:\a\1\s\Testing\unittest\Storage\VirtuosoTest.cs, Line: 740, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #394 Path: D:\a\1\s\Testing\unittest\Storage\VirtuosoTest.cs, Line: 771, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #395 Path: D:\a\1\s\Testing\unittest\Storage\VirtuosoTest.cs, Line: 907, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #396 Path: D:\a\1\s\Testing\unittest\TestTools.cs, Line: 107, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #397 Path: D:\a\1\s\Testing\unittest\TestTools.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #398 Path: D:\a\1\s\Testing\unittest\Update\UpdateTests1.cs, Line: 727, Message: ReSharper: ReplaceWithSingleCallToAny. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #399 Path: D:\a\1\s\Testing\unittest\Writing\CompressionTests.cs, Line: 61, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #400 Path: D:\a\1\s\Testing\unittest\Writing\CompressionTests.cs, Line: 65, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #401 Path: D:\a\1\s\Testing\unittest\Writing\SparqlXmlTests.cs, Line: 101, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #402 Path: D:\a\1\s\Testing\unittest\Writing\SparqlXmlTests.cs, Line: 57, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #403 Path: D:\a\1\s\Testing\unittest\Writing\StoreWriterTests.cs, Line: 50, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #404 Path: D:\a\1\s\Testing\unittest\Writing\StoreWriterTests.cs, Line: 54, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: dotNetRDF.Web
    #405 Path: D:\a\1\s\Libraries\dotNetRDF.Web\BaseGraphHandler.cs, Line: 112, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #406 Path: D:\a\1\s\Libraries\dotNetRDF.Web\BaseSparqlServer.cs, Line: 609, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #407 Path: D:\a\1\s\Libraries\dotNetRDF.Web\BaseSparqlUpdateHandler.cs, Line: 242, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #408 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\BaseHandlerConfiguration.cs, Line: 136, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #409 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\BaseHandlerConfiguration.cs, Line: 175, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #410 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\BaseHandlerConfiguration.cs, Line: 190, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #411 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\BaseHandlerConfiguration.cs, Line: 213, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #412 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Protocol\BaseProtocolHandlerConfiguration.cs, Line: 62, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #413 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Protocol\BaseProtocolHandlerConfiguration.cs, Line: 77, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #414 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Query\BaseQueryHandlerConfiguration.cs, Line: 124, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #415 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Query\BaseQueryHandlerConfiguration.cs, Line: 179, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #416 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Query\BaseQueryHandlerConfiguration.cs, Line: 204, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #417 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Query\BaseQueryHandlerConfiguration.cs, Line: 219, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #418 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Query\BaseQueryHandlerConfiguration.cs, Line: 233, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #419 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Resource\BaseDatasetHandlerConfiguration.cs, Line: 55, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #420 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Resource\BaseGraphHandlerConfiguration.cs, Line: 54, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #421 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Server\BaseSparqlServerConfiguration.cs, Line: 331, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #422 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Server\BaseSparqlServerConfiguration.cs, Line: 386, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #423 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Server\BaseSparqlServerConfiguration.cs, Line: 411, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #424 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Server\BaseSparqlServerConfiguration.cs, Line: 425, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #425 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Server\BaseSparqlServerConfiguration.cs, Line: 440, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #426 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Server\BaseSparqlServerConfiguration.cs, Line: 471, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #427 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Server\BaseSparqlServerConfiguration.cs, Line: 491, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #428 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Update\BaseUpdateHandlerConfiguration.cs, Line: 103, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #429 Path: D:\a\1\s\Libraries\dotNetRDF.Web\Configuration\Update\BaseUpdateHandlerConfiguration.cs, Line: 72, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #430 Path: D:\a\1\s\Libraries\dotNetRDF.Web\HandlerHelper.cs, Line: 164, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #431 Path: D:\a\1\s\Libraries\dotNetRDF.Web\HandlerHelper.cs, Line: 295, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #432 Path: D:\a\1\s\Libraries\dotNetRDF.Web\HandlerHelper.cs, Line: 301, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #433 Path: D:\a\1\s\Libraries\dotNetRDF.Web\HandlerHelper.cs, Line: 305, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #434 Path: D:\a\1\s\Libraries\dotNetRDF.Web\HandlerHelper.cs, Line: 309, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #435 Path: D:\a\1\s\Libraries\dotNetRDF.Web\HandlerHelper.cs, Line: 313, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #436 Path: D:\a\1\s\Libraries\dotNetRDF.Web\HandlerHelper.cs, Line: 317, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #437 Path: D:\a\1\s\Libraries\dotNetRDF.Web\HandlerHelper.cs, Line: 321, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #438 Path: D:\a\1\s\Libraries\dotNetRDF.Web\HandlerHelper.cs, Line: 36, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #439 Path: D:\a\1\s\Libraries\dotNetRDF.Web\HandlerHelper.cs, Line: 39, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #440 Path: D:\a\1\s\Libraries\dotNetRDF.Web\HandlerHelper.cs, Line: 39, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



--- Rules Summary ---
R5: 345
R10: 22
R4: 21
R8: 14
R9: 13
R6: 11
R2: 5
R7: 5
R3: 4

--- Summary ---
Fixed ReSharper issues: 435
Fixed SonarQube issues: 403
Total fixed issues: 440

Finished in: 34 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json.Linq;
using VDS.RDF.JsonLd.Syntax;

namespace VDS.RDF.JsonLd.Processors
{
    internal class CompactProcessor : ProcessorBase
    {
        private readonly ContextProcessor _contextProcessor;

        public CompactProcessor(JsonLdProcessorOptions options,
            ContextProcessor contextProcessor,
            IList<JsonLdProcessorWarning> warnings) : base(options, warnings)
        {
            _contextProcessor = contextProcessor;
        }

        /// <summary>
        /// Implementation of the JSON-LD Compact Algorithm
        /// </summary>
        /// <param name="activeContext"></param>
        /// <param name="activeProperty"></param>
        /// <param name="element"></param>
        /// <param name="compactArrays"></param>
        /// <param name="ordered"></param>
        /// <returns></returns>
        public JToken CompactElement(JsonLdContext activeContext, string activeProperty, JToken element, bool compactArrays = false, bool ordered = false)
        {
            JsonLdTermDefinition activeTermDefinition = null;
            if (activeProperty != null)
            {
                activeContext.TryGetTerm(activeProperty, out activeTermDefinition, true);
            }

            // 1 - Initialize type-scoped context to active context. This is used for compacting values that may be relevant to any previous type - scoped context.
            var typeScopedContext = activeContext;

            // 2 - If element is a scalar, it is already in its most compact form, so simply return element.
            if (JsonLdUtils.IsScalar(element)) return element;

            // 3 - If element is an array: 
            if (element is JArray elementArray)
            {
                // 3.1 - Initialize result to an empty array.
                var arrayResult = new JArray();

                // 3.2 - For each item in element: 
                foreach (var item in elementArray)
                {
                    // 3.2.1 - Initialize compacted item to the result of using this algorithm recursively, passing active context, active property, item for element, and the compactArrays and ordered flags.
                    var compactedItem = CompactElement(activeContext, activeProperty, item, compactArrays, ordered);
                    // 3.2.2 - If compacted item is not null, then append it to result.
                    if (compactedItem != null) arrayResult.Add(compactedItem);
                }
                // 3.3 - If result is empty or contains more than one value, or compactArrays is false, or active property is either @graph or @set, or container mapping for active property in active context includes either @list or @set, return result.
                if (arrayResult.Count != 1 || !compactArrays || "@graph".Equals(activeProperty) || "@set".Equals(activeProperty))
                {
                    return arrayResult;
                }
                if (activeTermDefinition != null && (activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.List) ||
                                                     activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.Set)))
                {
                    return arrayResult;
                }

                return arrayResult[0];
            }

            // 4 - Otherwise element is a map.
            var elementObject = element as JObject;

            // 5 - If active context has a previous context, the active context is not propagated.
            // If element does not contain an @value entry, and element does not consist of a single @id entry,
            // set active context to previous context from active context, as the scope of a term-scoped context does not apply when processing new node objects.
            if (activeContext.PreviousContext != null)
            {
                if (!elementObject.ContainsKey("@value") &&
                    (elementObject.Count > 1 || !elementObject.ContainsKey("@id")))
                {
                    activeContext = activeContext.PreviousContext;
                    // KA: Spec implies that step 6 uses the term definition in active context (after revert), but implementation uses typeScopedContext (before revert)
                    // Checking this at https://github.com/w3c/json-ld-api/issues/502
                    //activeTermDefinition = activeContext.GetTerm(activeProperty);
                }
            }

            // 6 - If the term definition for active property in active context has a local context:
            if (activeTermDefinition?.LocalContext != null)
            {
                // 6.1 - Set active context to the result of the Context Processing algorithm, passing active context, the value of the active property's
                // local context as local context, base URL from the term definition for active property in active context, and true for override protected.
                activeContext = _contextProcessor.ProcessContext(activeContext, activeTermDefinition.LocalContext,
                    activeTermDefinition.BaseUrl, overrideProtected: true);
                activeTermDefinition = activeContext.GetTerm(activeProperty);
            }

            // 7 - If element has an @value or @id entry and the result of using the Value Compaction algorithm, passing active context, active property,
            // and element as value is a scalar, or the term definition for active property has a type mapping of @json, return that result.
            if (elementObject.ContainsKey("@value") || elementObject.ContainsKey("@id"))
            {
                var compactValue = CompactValue(activeContext, activeProperty, elementObject);
                if (JsonLdUtils.IsScalar(compactValue) ||
                    (activeTermDefinition != null && "@json".Equals(activeTermDefinition.TypeMapping)))
                {
                    return compactValue;
                }
            }
            // 8 - If element is a list object, and the container mapping for active property in active context includes @list, return the result of using this
            // algorithm recursively, passing active context, active property, value of @list in element for element, and the compactArrays and ordered flags.
            if (JsonLdUtils.IsListObject(elementObject) && activeTermDefinition != null && activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.List))
            {
                return CompactElement(activeContext, activeProperty, elementObject["@list"], compactArrays, ordered);
            }
            // 9 - Initialize inside reverse to true if active property equals @reverse, otherwise to false.
            var insideReverse = "@reverse".Equals(activeProperty);
            // 10 - Initialize result to an empty map.
            var result = new JObject();
            // 11 - If element has an @type entry...
            if (elementObject.ContainsKey("@type"))
            {
                // ...create a new array compacted types initialized by transforming each expanded type of that entry into its
                // compacted form by IRI compacting expanded type. 
                var compactedTypes = new JArray();
                var expandedTypes = JsonLdUtils.EnsureArray(elementObject["@type"]);
                foreach (var expandedType in expandedTypes)
                {
                    var compactedType = CompactIri(activeContext, expandedType.Value<string>(), vocab: true);
                    compactedTypes.Add(compactedType);
                }
                // Then, for each term in compacted types ordered lexicographically: 
                foreach (var term in compactedTypes.Select(t => t.Value<string>()).OrderBy(x => x))
                {
                    // 11.1 - If the term definition for term in type-scoped context has a local context set active context to the result of the
                    // Context Processing algorithm, passing active context and the value of term's local context in type-scoped context as
                    // local context base URL from the term definition for term in type-scoped context, and false for propagate. 
                    if (typeScopedContext.TryGetTerm(term, out var termDef) && termDef.LocalContext != null)
                    {
                        activeContext = _contextProcessor.ProcessContext(activeContext, termDef.LocalContext, termDef.BaseUrl,
                            propagate: false);
                    }
                }
            }
            // 12 - For each key expanded property and value expanded value in element, ordered lexicographically by expanded property if ordered is true: 
            var properties = elementObject.Properties();
            if (ordered) properties = properties.OrderBy(p => p.Name);
            foreach (var p in properties)
            {
                var expandedProperty = p.Name;
                var expandedValue = p.Value;
                // 12.1 - If expanded property is @id:
                if (expandedProperty.Equals("@id"))
                {
                    // 12.1.1 - If expanded value is a string, then initialize compacted value by IRI compacting expanded value with vocab set to false.
                    var compactedValue = CompactIri(activeContext, expandedValue.Value<string>(), vocab: false);
                    // 12.1.2 - Initialize alias by IRI compacting expanded property.
                    var alias = CompactIri(activeContext, expandedProperty, vocab: true);
                    // 12.1.3 - Add an entry alias to result whose value is set to compacted value and continue to the next expanded property.
                    result.Add(new JProperty(alias, compactedValue));
                    continue;
                }

                // 12.2 - If expanded property is @type:
                if (expandedProperty.Equals("@type"))
                {
                    JToken compactedValue;
                    // 12.2.1 - If expanded value is a string, then initialize compacted value by IRI compacting expanded value using type-scoped context for active context.
                    if (expandedValue.Type == JTokenType.String)
                    {
                        compactedValue = CompactIri(typeScopedContext, expandedValue.Value<string>(), vocab: true);
                    }
                    else
                    {
                        // 12.2.2 - Otherwise, expanded value must be a @type array:
                        // 12.2.2.1 - Initialize compacted value to an empty array.
                        var compactedValueArray = new JArray();
                        compactedValue = compactedValueArray;
                        // 12.2.2.2 - For each item expanded type in expanded value:
                        foreach (var item in expandedValue.Children())
                        {
                            // 12.2.2.2.1 - Set term by IRI compacting expanded type using type-scoped context for active context.
                            var term = CompactIri(typeScopedContext, item.Value<string>(), vocab: true);
                            // 12.2.2.2.2 - Append term, to compacted value.
                            compactedValueArray.Add(term);
                        }
                    }

                    // 12.2.3 - Initialize alias by IRI compacting expanded property.
                    var alias = CompactIri(activeContext, expandedProperty, vocab: true);

                    // 12.2.4 - Initialize as array to true if processing mode is json - ld - 1.1 and the container mapping for alias in the active context includes @set, otherwise to the negation of compactArrays.
                    var aliasTermDefinition = activeContext.GetTerm(alias);
                    var asArray =
                        Options.ProcessingMode == JsonLdProcessingMode.JsonLd11 &&
                        aliasTermDefinition != null &&
                        aliasTermDefinition.ContainerMapping.Contains(JsonLdContainer.Set) || !compactArrays;
                    // 12.2.5 - Use add value to add compacted value to the alias entry in result using as array.
                    JsonLdUtils.AddValue(result, alias, compactedValue, asArray);

                    // 12.2.6 - Continue to the next expanded property.
                    continue;
                }
                // 12.3 - If expanded property is @reverse:
                if ("@reverse".Equals(expandedProperty))
                {
                    // 12.3.1 - Initialize compacted value to the result of using this algorithm recursively, passing active context, @reverse for active property, expanded value for element, and the compactArrays and ordered flags.
                    var compactedValue =
                        CompactElement(activeContext, "@reverse", expandedValue, compactArrays, ordered);
                    if (compactedValue is JObject compactedObject)
                    {
                        // 12.3.2 - For each property and value in compacted value:
                        foreach (var compactedObjectProperty in compactedObject.Properties().ToList())
                        {
                            // 12.3.1 - If the term definition for property in the active context indicates that property is a reverse property
                            var td = activeContext.GetTerm(compactedObjectProperty.Name, true);
                            if (td != null && td.Reverse)
                            {
                                // 12.3.2.1.1 - Initialize as array to true if the container mapping for property in the active context includes @set, otherwise the negation of compactArrays.
                                var asArray = td.ContainerMapping.Contains(JsonLdContainer.Set) || !compactArrays;
                                // 12.3.2.1.2 - Use add value to add value to the property entry in result using as array.
                                JsonLdUtils.AddValue(result, compactedObjectProperty.Name, compactedObjectProperty.Value, asArray);
                                // 12.3.2.1.3 - Remove the property entry from compacted value.
                                compactedObjectProperty.Remove();
                            }
                        }
                        // 12.3.3 - If compacted value has some remaining map entries, i.e., it is not an empty map:
                        if (compactedObject.HasValues)
                        {
                            var alias = CompactIri(activeContext, "@reverse", vocab: true);
                            result.Add(alias, compactedValue);
                        }
                    }
                    // 12.3.4 - Continue with the next expanded property from element.
                    continue;
                }
                // 12.4 - If expanded property is @preserve then:
                if ("@preserve".Equals(expandedProperty))
                {
                    if (!JsonLdUtils.IsEmptyArray(expandedValue))
                    {
                        // 12.4.1 - Initialize compacted value to the result of using this algorithm recursively, passing
                        // active context, active property, expanded value for element, and the compactArrays and ordered flags.
                        var compactedValue = CompactElement(activeContext, activeProperty, expandedValue,
                            compactArrays,
                            ordered);
                        // 12.4.2 Add compacted value as the value of @preserve in result unless expanded value is an empty array.
                        result.Add("@preserve", compactedValue);
                    }
                }
                // 12.5 - If expanded property is @index and active property has a container mapping in active context that includes
                // @index, then the compacted result will be inside of an @index container, drop the @index entry by continuing to
                // the next expanded property.
                if ("@index".Equals(expandedProperty) &&
                    activeTermDefinition != null &&
                    activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.Index))
                {
                    continue;
                }
                // 12.6 - Otherwise, if expanded property is @direction, @index, @language, or @value: 
                else if ("@direction".Equals(expandedProperty) ||
                           "@index".Equals(expandedProperty) ||
                           "@language".Equals(expandedProperty) ||
                           "@value".Equals(expandedProperty))
                {
                    // 12.6.1 - Initialize alias by IRI compacting expanded property.
                    var alias = CompactIri(activeContext, expandedProperty, vocab: true);
                    // 12.6.2 - Add an entry alias to result whose value is set to expanded value and continue with the next expanded property.
                    result.Add(alias, expandedValue);
                    continue;
                }
                // 12.7 - If expanded value is an empty array: 
                if (JsonLdUtils.IsEmptyArray(expandedValue))
                {
                    // 12.7.1 - Initialize item active property by IRI compacting expanded property using expanded value for value and inside reverse for reverse.
                    var itemActiveProperty =
                        CompactIri(activeContext, expandedProperty, expandedValue, true, insideReverse);
                    // 12.7.2 - If the term definition for item active property in the active context has a nest value entry(nest term): 
                    var td = activeContext.GetTerm(itemActiveProperty);
                    JObject nestResult = null;
                    if (td?.Nest != null)
                    {

                        // 12.7.2.1 - If nest term is not @nest, or a term in the active context that expands to @nest, an invalid @nest value error has been detected, and processing is aborted.
                        var nestTerm = _contextProcessor.ExpandIri(activeContext, td.Nest, true);
                        if (!"@nest".Equals(nestTerm))
                        {
                            throw new JsonLdProcessorException(JsonLdErrorCode.InvalidNestValue,
                                $"Invalid Nest Value. Error compacting property {expandedProperty} of {activeProperty}. The value of {expandedProperty} should be '@nest' or a term that expands to '@nest'.");
                        }
                        // 12.7.2.2 - If result does not have a nest term entry, initialize it to an empty map.
                        if (!result.ContainsKey("@nest"))
                        {
                            result.Add("@nest", new JObject());
                        }
                        // 12.7.2.3 - Initialize nest result to the value of nest term in result.
                        nestResult = result["@nest"] as JObject;
                    }
                    // 12.7.3 - Otherwise, initialize nest result to result.
                    else
                    {
                        nestResult = result;
                    }
                    // 12.7.4 - Use add value to add an empty array to the item active property entry in nest result using true for as array.
                    JsonLdUtils.AddValue(nestResult, itemActiveProperty, new JArray(), true);
                }
                // 12.8 -  At this point, expanded value must be an array due to the Expansion algorithm. For each item expanded item in expanded value: 
                foreach (var expandedItem in expandedValue.Children())
                {
                    // 12.8.1 - Initialize item active property by IRI compacting expanded property using expanded item for value and inside reverse for reverse.
                    var itemActiveProperty =
                        CompactIri(activeContext, expandedProperty, expandedItem, true, insideReverse);
                    // 12.8.2 - If the term definition for item active property in the active context has a nest value entry (nest term):
                    var itemActiveTermDefinition = activeContext.GetTerm(itemActiveProperty);
                    JObject nestResult = null;
                    if (itemActiveTermDefinition?.Nest != null)
                    {
                        // 12.8.2.1 - If nest term is not @nest, or a term in the active context that expands to @nest, an invalid @nest value error has been detected, and processing is aborted.
                        var nestTerm = itemActiveTermDefinition.Nest;
                        if (!"@nest".Equals(_contextProcessor.ExpandIri(activeContext, nestTerm, true)))
                        {
                            throw new JsonLdProcessorException(JsonLdErrorCode.InvalidNestValue,
                                $"Invalid Nest Value. Error compacting property {expandedProperty} of {activeProperty}. The value of {expandedProperty} should be '@nest' or a term that expands to '@nest'.");
                        }
                        // 12.8.2.2 - If result does not have a nest term entry, initialize it to an empty map.
                        // 12.8.2.3 - Initialize nest result to the value of nest term in result.
                        nestResult = EnsureMapEntry(result, nestTerm);
                    }
                    // 12.8.3 - Otherwise, initialize nest result to result.
                    else
                    {
                        nestResult = result;
                    }

                    // 12.8.4 - Initialize container to container mapping for item active property in active context, or to a new empty array, if there is no such container mapping.
                    var container = (itemActiveTermDefinition?.ContainerMapping != null)
                        ? itemActiveTermDefinition.ContainerMapping
                        : new HashSet<JsonLdContainer>();
                    // 12.8.5 - Initialize as array to true if container includes @set, or if item active property is @graph or @list, otherwise the negation of compactArrays.
                    var asArray = container.Contains(JsonLdContainer.Set) ||
                                  "@graph".Equals(itemActiveProperty) ||
                                   "@list".Equals(itemActiveProperty) ||
                                  !compactArrays;
                    // 12.8.6 - Initialize compacted item to the result of using this algorithm recursively, passing active context,
                    // item active property for active property, expanded item for element, along with the compactArrays and ordered flags.
                    // If expanded item is a list object or a graph object, use the value of the @list or @graph entries, respectively, for element instead of expanded item.
                    var elementToCompact = JsonLdUtils.IsListObject(expandedItem) ? expandedItem["@list"] :
                        JsonLdUtils.IsGraphObject(expandedItem) ? expandedItem["@graph"] : expandedItem;
                    var compactedItem = CompactElement(activeContext, itemActiveProperty, elementToCompact,
                        compactArrays, ordered);
                    // 12.8.7 - If expanded item is a list object: 
                    if (JsonLdUtils.IsListObject(expandedItem))
                    {
                        // 12.8.7.1 - If compacted item is not an array, then set compacted item to an array containing only compacted item.
                        compactedItem = JsonLdUtils.EnsureArray(compactedItem);
                        // 12.8.7.2 - If container does not include @list: 
                        if (!container.Contains(JsonLdContainer.List))
                        {
                            // 12.8.7.2.1 - Convert compacted item to a list object by setting it to a map containing an entry where the key is
                            // the result of IRI compacting @list and the value is the original compacted item.
                            compactedItem = new JObject(new JProperty(CompactIri(activeContext, "@list", vocab: true), compactedItem));

                            // 12.8.7.2.2 - If expanded item contains the entry @index - value, then add an entry to compacted item where the key is the result of IRI compacting @index and value is value.
                            if (expandedItem is JObject expandedItemObject && expandedItemObject.ContainsKey("@index"))
                            {
                                (compactedItem as JObject).Add(new JProperty(CompactIri(activeContext, "@index", vocab: true), expandedItemObject["@index"]));
                            }
                            // 12.8.7.2.3 - Use add value to add compacted item to the item active property entry in nest result using as array.
                            JsonLdUtils.AddValue(nestResult, itemActiveProperty, compactedItem, asArray);
                        }
                        // 12.8.7.3 - Otherwise, set the value of the item active property entry in nest result to compacted item.
                        else
                        {
                            nestResult[itemActiveProperty] = compactedItem;
                        }
                    }
                    // 12.8.8 - If expanded item is a graph object: 
                    // KA: Although algorithm doesn't say "Otherwise", I think this is an else-if branch as nestResult gets updated in the preceding if branch.
                    else if (JsonLdUtils.IsGraphObject(expandedItem))
                    {
                        // 12.8.8.1 - If container includes @graph and @id: 
                        if (container.Contains(JsonLdContainer.Graph) && container.Contains(JsonLdContainer.Id))
                        {
                            // 12.8.8.1.1 - Initialize map object to the value of item active property in nest result, initializing it to a new empty map, if necessary.
                            var mapObject = EnsureMapEntry(nestResult, itemActiveProperty);

                            // 12.8.8.1.2 - Initialize map key by IRI compacting the value of @id in expanded item or @none if no such value exists with vocab set to false if there is an @id entry in expanded item.
                            var mapKey =
                                (expandedItem is JObject expandedItemObject && expandedItemObject.ContainsKey("@id"))
                                    ? CompactIri(activeContext, expandedItemObject["@id"].Value<string>(),
                                        vocab: false)
                                    : CompactIri(activeContext, "@none", vocab: true);
                            // 12.8.8.1.3 - Use add value to add compacted item to the map key entry in map object using as array.
                            JsonLdUtils.AddValue(mapObject, mapKey, compactedItem, asArray);
                        }
                        // 12.8.8.2 - Otherwise, if container includes @graph and @index and expanded item is a simple graph object: 
                        else if (JsonLdUtils.IsSimpleGraphObject(expandedItem) && container.Contains(JsonLdContainer.Graph) &&
                                 container.Contains(JsonLdContainer.Index))
                        {
                            // 12.8.8.2.1 - Initialize map object to the value of item active property in nest result, initializing it to a new empty map, if necessary.
                            var mapObject = EnsureMapEntry(nestResult, itemActiveProperty);
                            // 12.8.8.2.2 - Initialize map key the value of @index in expanded item or @none, if no such value exists.
                            var mapKey =
                                expandedItem is JObject expandedItemObject && expandedItemObject.ContainsKey("@index")
                                    ? expandedItemObject["@index"].Value<string>()
                                    : "@none";
                            // 12.8.8.2.3 - Use add value to add compacted item to the map key entry in map object using as array.
                            JsonLdUtils.AddValue(mapObject, mapKey, compactedItem, asArray);
                        }
                        // 12.8.8.3 - Otherwise, if container includes @graph and expanded item is a simple graph object the value cannot be represented as a map object. 
                        else if (JsonLdUtils.IsSimpleGraphObject(expandedItem) && container.Contains(JsonLdContainer.Graph))
                        {
                            // 12.8.8.3.1 - If compacted item is an array with more than one value, it cannot be directly represented, as multiple objects would be interpreted as different named graphs.
                            if ((compactedItem is JArray compactedItemArray) && compactedItemArray.Count > 1)
                            {
                                // Set compacted item to a new map, containing the key from IRI compacting @included and the original compacted item as the value.
                                compactedItem =
                                    new JObject(new JProperty(CompactIri(activeContext, "@included", vocab: true),
                                        compactedItem));
                            }

                            // 12.8.8.3.2 - Use add value to add compacted item to the item active property entry in nest result using as array.
                            JsonLdUtils.AddValue(nestResult, itemActiveProperty, compactedItem, asArray);
                        }
                        // 12.8.8.4 - Otherwise, container does not include @graph or otherwise does not match one of the previous cases.
                        else
                        {
                            // 12.8.8.4.1 - Set compacted item to a new map containing the key from IRI compacting @graph using the original compacted item as a value.
                            compactedItem = new JObject(new JProperty(CompactIri(activeContext, "@graph", vocab: true), compactedItem));
                            if (expandedItem is JObject expandedItemObject)
                            {
                                // 12.8.8.4.2 - If expanded item contains an @id entry, add an entry in compacted item using the key from IRI
                                // compacting @id using the value of IRI compacting the value of @id in expanded item using false for vocab.
                                if (expandedItemObject.ContainsKey("@id"))
                                {
                                    (compactedItem as JObject).Add(
                                        CompactIri(activeContext, "@id", vocab: true),
                                        CompactIri(activeContext, expandedItemObject["@id"].Value<string>(),
                                            vocab: false));
                                }
                                // 12.8.8.4.3 - If expanded item contains an @index entry, add an entry in compacted item using the key from IRI compacting @index and the value of @index in expanded item.
                                if (expandedItemObject.ContainsKey("@index"))
                                {
                                    (compactedItem as JObject).Add(
                                        CompactIri(activeContext, "@index", vocab: true),
                                        CompactIri(activeContext, expandedItemObject["@index"].Value<string>(),
                                            vocab: true));
                                }
                            }
                            // 12.8.8.4.4 - Use add value to add compacted item to the item active property entry in nest result using as array.
                            JsonLdUtils.AddValue(nestResult, itemActiveProperty, compactedItem, asArray);
                        }
                    }
                    // 12.8.9 - Otherwise, if container includes @language, @index, @id, or @type and container does not include @graph: 
                    else if ((container.Contains(JsonLdContainer.Language) ||
                              container.Contains(JsonLdContainer.Index) ||
                              container.Contains(JsonLdContainer.Id) ||
                              container.Contains(JsonLdContainer.Type)) && !container.Contains(JsonLdContainer.Graph))
                    {
                        // 12.8.9.1 - Initialize map object to the value of item active property in nest result, initializing it to a new empty map, if necessary.
                        if (!nestResult.ContainsKey(itemActiveProperty))
                        {
                            nestResult[itemActiveProperty] = new JObject();
                        }
                        var mapObject = nestResult[itemActiveProperty] as JObject;

                        // 12.8.9.2 - Initialize container key by IRI compacting either @language, @index, @id, or @type based on the contents of container.
                        string expandedKey = null;
                        if (container.Contains(JsonLdContainer.Language)) expandedKey = "@language";
                        if (container.Contains(JsonLdContainer.Index)) expandedKey = "@index";
                        if (container.Contains(JsonLdContainer.Id)) expandedKey = "@id";
                        if (container.Contains(JsonLdContainer.Type)) expandedKey = "@type";
                        var containerKey = CompactIri(activeContext, expandedKey, vocab: true);

                        // 12.8.9.3 - Initialize index key to the value of index mapping in the term definition associated with item active property in active context, or @index, if no such value exists.
                        var indexKey = itemActiveTermDefinition?.IndexMapping != null
                            ? itemActiveTermDefinition.IndexMapping
                            : "@index";

                        // 12.8.9.4 - If container includes @language and expanded item contains a @value entry, then set compacted item to the value associated with its @value entry.
                        // Set map key to the value of @language in expanded item, if any.
                        string mapKey = null;
                        var expandedItemObject = expandedItem as JObject;
                        if (container.Contains(JsonLdContainer.Language) && expandedItemObject != null &&
                            expandedItemObject.ContainsKey("@value"))
                        {
                            compactedItem = expandedItemObject["@value"];
                            if (expandedItemObject.ContainsKey("@language"))
                            {
                                mapKey = expandedItemObject["@language"].Value<string>();
                            }
                        }
                        // 12.8.9.5 - Otherwise, if container includes @index and index key is @index, set map key to the value of @index in expanded item, if any.
                        else if (container.Contains(JsonLdContainer.Index) && "@index".Equals(indexKey))
                        {
                            if (expandedItemObject != null && expandedItemObject.ContainsKey("@index"))
                            {
                                mapKey = expandedItemObject["@index"].Value<string>();
                            }
                        }
                        // 12.8.9.6 - Otherwise, if container includes @index and index key is not @index: 
                        else if (container.Contains(JsonLdContainer.Index) && compactedItem is JObject)
                        {
                            // 12.8.9.6.1 - Reinitialize container key by IRI compacting index key.
                            containerKey = CompactIri(activeContext, indexKey, vocab: true);
                            // 12.8.9.6.2 - Set map key to the first value of container key in compacted item, if any.
                            // 12.8.9.6.3 - If there are remaining values in compacted item for container key, use add value to add those remaining values to the container key in compacted item.
                            // Otherwise, remove that entry from compacted item.
                            var array = JsonLdUtils.EnsureArray(compactedItem[containerKey]);

                            (compactedItem as JObject).Remove(containerKey);
                            foreach (var item in array)
                            {
                                if (mapKey == null && item.Type == JTokenType.String)
                                {
                                    mapKey = item.Value<string>();
                                }
                                else
                                {
                                    JsonLdUtils.AddValue(compactedItem as JObject, containerKey, item);
                                }
                            }
                        }
                        // 12.8.9.7 - Otherwise, if container includes @id, set map key to the value of container key in compacted item and remove container key from compacted item.
                        else if (container.Contains(JsonLdContainer.Id))
                        {
                            if (compactedItem is JObject compactedItemObject &&
                                compactedItemObject.ContainsKey(containerKey))
                            {
                                mapKey = compactedItemObject[containerKey].Value<string>();
                                compactedItemObject.Remove(containerKey);
                            }
                        }
                        // 12.8.9.8 - Otherwise, if container includes @type: 
                        else if (container.Contains(JsonLdContainer.Type))
                        {
                            // 12.8.9.8.1 - Set map key to the first value of container key in compacted item, if any.
                            // 12.8.9.8.2 - If there are remaining values in compacted item for container key, use add value to add those remaining values to the container key in compacted item.
                            // 12.8.9.8.3 - Otherwise, remove that entry from compacted item.
                            var array = JsonLdUtils.EnsureArray(compactedItem[containerKey]);
                            if (array.Count > 0)
                            {
                                mapKey = array[0].Value<string>();
                                array.RemoveAt(0);
                                if (array.Count == 0) (compactedItem as JObject).Remove(containerKey);
                                else if (array.Count == 1) compactedItem[containerKey] = array[0];
                            }
                            // 12.8.9.8.4 - If compacted item contains a single entry with a key expanding to @id, set compacted item to the result of using this algorithm recursively, passing active context, item active property for active property, and a map composed of the single entry for @id from expanded item for element.
                            if ((compactedItem is JObject compactedItemObject) && compactedItemObject.Count == 1)
                            {
                                if (_contextProcessor.ExpandIri(activeContext, compactedItemObject.Properties().First().Name, vocab: true)
                                    .Equals("@id"))
                                {
                                    compactedItem = CompactElement(activeContext, itemActiveProperty,
                                        new JObject(new JProperty("@id", expandedItemObject["@id"])));
                                }
                            }
                        }
                        // 12.8.9.9 - If map key is null, set it to the result of IRI compacting @none.
                        if (mapKey == null) mapKey = CompactIri(activeContext, "@none", vocab: true);
                        // 12.8.9.10 - Use add value to add compacted item to the map key entry in map object using as array.
                        JsonLdUtils.AddValue(mapObject, mapKey, compactedItem, asArray);
                    }
                    // 12.8.10 - Otherwise, use add value to add compacted item to the item active property entry in nest result using as array.
                    else
                    {
                        JsonLdUtils.AddValue(nestResult, itemActiveProperty, compactedItem, asArray);
                    }
                }
            }

            return result;
        }

        public string CompactIri(JsonLdContext activeContext, string iri, JToken value = null,
    bool vocab = false, bool reverse = false)
        {
            // 1 - If var is null, return null.
            // KA - note local name for var is iri to avoid clash with C# keyword
            if (iri == null) return null;

            // 2 - If the active context has a null inverse context, set inverse context in active context to the result of calling the Inverse Context Creation algorithm using active context.
            // Initialize inverse context to the value of inverse context in active context.
            var inverseContext = activeContext.InverseContext;

            // 4 - If vocab is true and var is an entry of inverse context:
            if (vocab && inverseContext.ContainsKey(iri))
            {
                var defaultLanguage = "@none";
                // 4.1 - Initialize default language based on the active context's default language, normalized to lower case and default base direction: 
                // 4.1.1 - If the active context's default base direction is not null, to the concatenation of the active context's default language and default base direction, separated by an underscore("_"), normalized to lower case.
                // 4.1.2 - Otherwise, to the active context's default language, if it has one, normalized to lower case, otherwise to @none.
                if (activeContext.BaseDirection.HasValue &&
                    activeContext.BaseDirection != LanguageDirection.Unspecified)
                {
                    defaultLanguage =
                        (JsonLdUtils.SerializeLanguageDirection(activeContext.BaseDirection.Value) + "_" + activeContext.Language)
                        .ToLowerInvariant();
                }
                else if (!string.IsNullOrEmpty(activeContext.Language))
                {
                    defaultLanguage = activeContext.Language.ToLowerInvariant();
                }

                // 4.2 - If value is a map containing an @preserve entry, use the first element from the value of @preserve as value.
                if ((value is JObject valueMap) && valueMap.ContainsKey("@preserve"))
                {
                    value = valueMap["@preserve"];
                    if (value is JArray valueArray)
                    {
                        value = valueArray[0];
                    }
                }

                // 4.3 - Initialize containers to an empty array. This array will be used to keep track of an ordered list of preferred container mapping for a term, based on what is compatible with value. 
                var containers = new List<string>();
                // 4.4 - Initialize type/language to @language, and type/language value to @null. These two variables will keep track of the preferred type mapping or language mapping for a term, based on what is compatible with value.
                var typeLanguage = "@language";
                var typeLanguageValue = "@null";
                // 4.5 - If value is a map containing an @index entry, and value is not a graph object then append the values @index and @index@set to containers.
                if (value is JObject && (value as JObject).ContainsKey("@index") && !JsonLdUtils.IsGraphObject(value))
                {
                    containers.Add("@index");
                    containers.Add("@index@set");
                }

                // 4.6 - If reverse is true, set type/language to @type, type/language value to @reverse, and append @set to containers.
                if (reverse)
                {
                    typeLanguage = "@type";
                    typeLanguageValue = "@reverse";
                    containers.Add("@set");
                }
                else if (JsonLdUtils.IsListObject(value))
                {
                    // 4.7 - Otherwise, if value is a list object, then set type/language and type/language value to the most specific values that work for all items in the list as follows: 
                    var valueObject = value as JObject;
                    // 4.7.1 - If @index is not an entry in value, then append @list to containers.
                    if (!valueObject.ContainsKey("@index")) containers.Add("@list");
                    // 4.7.2 - Initialize list to the array associated with the @list entry in value.
                    var list = JsonLdUtils.EnsureArray(valueObject["@list"]);
                    // 4.7.3 - Initialize common type and common language to null.If list is empty, set common language to default language.
                    string commonType = null;
                    string commonLanguage = null;
                    if (list.Count == 0)
                    {
                        commonLanguage = defaultLanguage;
                    }

                    // 4.7.4 - For each item in list:
                    foreach (var item in list)
                    {
                        var itemObject = item as JObject;
                        // 4.7.4.1 - Initialize item language to @none and item type to @none.
                        var itemLanguage = "@none";
                        var itemType = "@none";
                        // 4.7.4.2 - If item contains an @value entry:
                        if (itemObject != null && itemObject.ContainsKey("@value"))
                        {
                            if (itemObject.ContainsKey("@direction"))
                            {
                                if (itemObject.ContainsKey("@language"))
                                {
                                    itemLanguage =
                                        (itemObject["@language"].Value<string>() + "_" +
                                         itemObject["@direction"].Value<string>()).ToLowerInvariant();
                                }
                                else
                                {
                                    itemLanguage = "_" + itemObject["@direction"].Value<string>().ToLowerInvariant();
                                }
                            }
                            else if (itemObject.ContainsKey("@language"))
                            {
                                itemLanguage = itemObject["@language"].Value<string>().ToLowerInvariant();
                            }
                            else if (itemObject.ContainsKey("@type"))
                            {
                                itemType = itemObject["@type"].Value<string>();
                            }
                            else
                            {
                                itemLanguage = "@null";
                            }
                        }
                        // 4.7.4.3 - Otherwise, set item type to @id.
                        else
                        {
                            itemType = "@id";
                        }

                        // 4.7.4.4 - If common language is null, set common language to item language.
                        if (commonLanguage == null)
                        {
                            commonLanguage = itemLanguage;
                        }
                        else
                        {
                            // 4.7.4.5 - Otherwise, if item language does not equal common language and item contains a @value entry, then set common language to @none because list items have conflicting languages.
                            if (!itemLanguage.Equals(commonLanguage) && itemObject.ContainsKey("@value"))
                            {
                                commonLanguage = "@none";
                            }
                        }

                        // 4.7.4.6 - If common type is null, set common type to item type.
                        if (commonType == null)
                        {
                            commonType = itemType;
                        }
                        else
                        {
                            // 4.7.4.7 - Otherwise, if item type does not equal common type, then set common type to @none because list items have conflicting types.
                            if (!itemType.Equals(commonType))
                            {
                                commonType = "@none";
                            }
                        }

                        // 4.7.4.8 - If common language is @none and common type is @none, then stop processing items in the list because it has been detected that there is no common language or type amongst the items.
                        if ("@none".Equals(commonLanguage) && "@none".Equals(commonType)) break;
                    }

                    // 4.7.5 - If common language is null, set common language to @none.
                    if (commonLanguage == null) commonLanguage = "@none";
                    // 4.7.6 - If common type is null, set common type to @none.
                    if (commonType == null) commonType = "@none";
                    // 4.7.7 - If common type is not @none then set type / language to @type and type/ language value to common type.
                    if (!"@none".Equals(commonType))
                    {
                        typeLanguage = "@type";
                        typeLanguageValue = commonType;
                    }
                    else
                    {
                        // 4.7.8 - Otherwise, set type/ language value to common language.
                        typeLanguageValue = commonLanguage;
                    }
                }
                else if (JsonLdUtils.IsGraphObject(value))
                {
                    // 4.8 - Otherwise, if value is a graph object, prefer a mapping most appropriate for the particular value. 
                    var valueObject = value as JObject;
                    // 4.8.1 - If value contains an @index entry, append the values @graph@index and @graph@index@set to containers.
                    if (valueObject != null && valueObject.ContainsKey("@index"))
                    {
                        containers.Add("@graph@index");
                        containers.Add("@graph@index@set");
                    }

                    // 4.8.2 - If value contains an @id entry, append the values @graph @id and @graph@id @set to containers.
                    if (valueObject != null && valueObject.ContainsKey("@id"))
                    {
                        containers.Add("@graph@id");
                        containers.Add("@graph@id@set");
                    }

                    // 4.8.3 - Append the values @graph @graph @set, and @set to containers.
                    containers.Add("@graph");
                    containers.Add("@graph@set");
                    containers.Add("@set");
                    // 4.8.4 - If value does not contain an @index entry, append the values @graph @index and @graph@index @set to containers.
                    if (valueObject == null || !valueObject.ContainsKey("@index"))
                    {
                        containers.Add("@graph@index");
                        containers.Add("@graph@index@set");

                    }

                    // 4.8.5 - If the value does not contain an @id entry, append the values @graph@id and @graph @id@set to containers.
                    if (valueObject == null || !valueObject.ContainsKey("@id"))
                    {
                        containers.Add("@graph@id");
                        containers.Add("@graph@id@set");
                    }

                    // 4.8.6 - Append the values @index and @index@set to containers.
                    containers.Add("@index");
                    containers.Add("@index@set");
                    // 4.8.7 - Set type / language to @type and set type / language value to @id.
                    typeLanguage = "@type";
                    typeLanguageValue = "@id";
                }
                // 4.9 - Otherwise
                else
                {
                    // 4.9.1 - If value is a value object: 
                    if (JsonLdUtils.IsValueObject(value))
                    {
                        var valueObject = value as JObject;
                        // 4.9.1.1 - If value contains an @direction entry and does not contain an @index entry, then set type/language value to the concatenation of the value's @language entry (if any) and the value's @direction entry, separated by an underscore ("_"), normalized to lower case. Append @language and @language@set to containers.
                        if (valueObject.ContainsKey("@direction") && !valueObject.ContainsKey("@index"))
                        {
                            if (valueObject.ContainsKey("@language"))
                            {
                                typeLanguageValue =
                                    (valueObject["@language"].Value<string>() + "_" +
                                     valueObject["@direction"].Value<string>()).ToLowerInvariant();
                            }
                            else
                            {
                                typeLanguageValue = ("_" + valueObject["direction"].Value<string>()).ToLowerInvariant();
                            }

                            containers.Add("@language");
                            containers.Add("@language@set");
                        }
                        // 4.9.1.2 - Otherwise, if value contains an @language entry and does not contain an @index entry, then set type/language value to the value of @language normalized to lower case, and append @language, and @language@set to containers.
                        else if (valueObject.ContainsKey("@language") && !valueObject.ContainsKey("@index"))
                        {
                            typeLanguageValue = valueObject["@language"].Value<string>().ToLowerInvariant();
                            containers.Add("@language");
                            containers.Add("@language@set");
                        }
                        // 4.9.1.3 - Otherwise, if value contains an @type entry, then set type/language value to its associated value and set type/language to @type.
                        else if (valueObject.ContainsKey("@type"))
                        {
                            typeLanguageValue = valueObject["@type"].Value<string>();
                            typeLanguage = "@type";
                        }

                    }
                    // 4.9.2 - Otherwise, set type/language to @type and set type/language value to @id, and append @id, @id@set, @type, and @set@type, to containers.
                    else
                    {
                        typeLanguage = "@type";
                        typeLanguageValue = "@id";
                        containers.Add("@id");
                        containers.Add("@id@set");
                        containers.Add("@type");
                        containers.Add("@set@type");
                    }

                    // 4.9.3 - Append @set to containers.
                    containers.Add("@set");
                }

                // 4.10 - Append @none to containers. This represents the non-existence of a container mapping, and it will be the last container mapping value to be checked as it is the most generic.
                containers.Add("@none");
                if (Options.ProcessingMode != JsonLdProcessingMode.JsonLd10)
                {
                    // 4.11 - If processing mode is not json-ld-1.0 and value is not a map or does not contain an @index entry, append @index and @index@set to containers.
                    if (value == null || value.Type != JTokenType.Object || !(value as JObject).ContainsKey("@index"))
                    {
                        containers.Add("@index");
                        containers.Add("@index@set");
                    }

                    // 4.12 - If processing mode is not json - ld - 1.0 and value is a map containing only an @value entry, append @language and @language@set to containers.
                    if (value is JObject valueObject &&
                        valueObject.Count == 1 &&
                        valueObject.ContainsKey("@value"))
                    {
                        containers.Add("@language");
                        containers.Add("@language@set");
                    }
                }

                // 4.13 - If type / language value is null, set type/ language value to @null.This is the key under which null values are stored in the inverse context entry.
                if (typeLanguageValue == null) typeLanguageValue = "@null";
                // 4.14 - Initialize preferred values to an empty array.This array will indicate, in order, the preferred values for a term's type mapping or language mapping.
                var preferredValues = new List<string>();
                // 4.15 - If type / language value is @reverse, append @reverse to preferred values.
                if (typeLanguageValue.Equals("@reverse"))
                {
                    preferredValues.Add("@reverse");
                }

                // 4.16 - type/language value is @id or @reverse and value is a map containing an @id entry: 
                if ((typeLanguageValue.Equals("@id") || typeLanguageValue.Equals("@reverse")) && (value is JObject) &&
                    (value as JObject).ContainsKey("@id"))
                {
                    // 4.16.1 If the result of IRI compacting the value of the @id entry in value has a term definition in the active context with an IRI mapping that equals the value of the @id entry in value, then append @vocab, @id, and @none, in that order, to preferred values.
                    var idValue = value["@id"].Value<string>();
                    var compactedId = CompactIri(activeContext, idValue, vocab: true);
                    if (activeContext.TryGetTerm(compactedId, out var td2) && td2.IriMapping.Equals(idValue))
                    {
                        preferredValues.Add("@vocab");
                        preferredValues.Add("@id");
                        preferredValues.Add("@none");
                    }
                    else
                    {
                        // 4.16.2 - Otherwise, append @id, @vocab, and @none, in that order, to preferred values.
                        preferredValues.Add("@id");
                        preferredValues.Add("@vocab");
                        preferredValues.Add("@none");
                    }
                }
                else
                {
                    // 4.17 - Otherwise, append type/language value and @none, in that order, to preferred values.
                    // If value is a list object with an empty array as the value of @list, set type/language to @any.
                    preferredValues.Add(typeLanguageValue);
                    preferredValues.Add("@none");
                    if (JsonLdUtils.IsListObject(value) && (value["@list"] as JArray).Count == 0)
                    {
                        typeLanguage = "@any";
                    }
                }

                // 4.18 - Append @any to preferred values.
                preferredValues.Add("@any");
                
                // 4.19 - If preferred values contains any entry having an underscore ("_"), append the substring of that entry from the underscore to the end of the string to preferred values.
                var toAppend = preferredValues
                    .Where(pv => pv.Contains("_"))
                    .Select(pv => pv.Substring(pv.IndexOf("_", StringComparison.Ordinal)))
                    .ToList();
                preferredValues.AddRange(toAppend);

                // 4.20 - Initialize term to the result of the Term Selection algorithm, passing var, containers, type/language, and preferred values.
                var term = activeContext.SelectTerm(iri, containers, typeLanguage, preferredValues);
                if (term != null)
                {
                    return term;
                }
            }

            // 5 - At this point, there is no simple term that var can be compacted to. If vocab is true and active context has a vocabulary mapping: 
            if (vocab && !string.IsNullOrEmpty(activeContext.Vocab))
            {
                if (iri.StartsWith(activeContext.Vocab) && iri.Length > activeContext.Vocab.Length)
                {
                    var suffix = iri.Substring(activeContext.Vocab.Length);
                    if (!activeContext.TryGetTerm(suffix, out _)) return suffix;
                }
            }

            // 6 - The var could not be compacted using the active context's vocabulary mapping.
            // Try to create a compact IRI, starting by initializing compact IRI to null. This variable will be used to store the created compact IRI, if any.
            string compactIri = null;
            // 7 - For each term definition definition in active context:
            foreach (var definitionKey in activeContext.Terms)
            {
                var termDefinition = activeContext.GetTerm(definitionKey);
                // 7.1 - If the IRI mapping of definition is null, its IRI mapping equals var, its IRI mapping is not a substring at the beginning of var, or definition does not have a true prefix flag, definition's key cannot be used as a prefix. Continue with the next definition.
                if (termDefinition.IriMapping == null ||
                    termDefinition.IriMapping.Equals(iri) ||
                    !iri.StartsWith(termDefinition.IriMapping) ||
                    !termDefinition.Prefix) continue;
                // 7.2 - Initialize candidate by concatenating definition key, a colon(:), and the substring of var that follows after the value of the definition's IRI mapping.
                var candidate = definitionKey + ":" + iri.Substring(termDefinition.IriMapping.Length);
                // 7.1 - If either compact IRI is null, candidate is shorter or the same length but lexicographically less than compact IRI and candidate does not have a term definition in active context, or if that term definition has an IRI mapping that equals var and value is null, set compact IRI to candidate.
                if (!activeContext.HasTerm(candidate) && (compactIri == null || candidate.Length < compactIri.Length ||
                                                          string.Compare(candidate, compactIri, StringComparison.Ordinal) < 0))
                {
                    compactIri = candidate;
                }
                else if (activeContext.HasTerm(candidate))
                {
                    var candidateTermDef = activeContext.GetTerm(candidate);
                    if (candidateTermDef.IriMapping.Equals(iri) && value == null)
                    {
                        compactIri = candidate;
                    }
                }
            }

            // 8 - If compact IRI is not null, return compact IRI.
            if (compactIri != null)
            {
                return compactIri;
            }

            // 9 - To ensure that the IRI var is not confused with a compact IRI, if the IRI scheme of var matches any term in active context with prefix flag set to true, and var has no IRI authority (preceded by double-forward-slash (//), an IRI confused with prefix error has been detected, and processing is aborted.
            var ix = iri.IndexOf(':');
            if (ix > 0 && iri.IndexOf("://", StringComparison.Ordinal) != ix)
            {
                var scheme = iri.Substring(0, ix);
                if (activeContext.TryGetTerm(scheme, out var td) && td.Prefix)
                {
                    throw new JsonLdProcessorException(JsonLdErrorCode.IriConfusedWithPrefix,
                        $"IRI confused with prefix. The {iri} has a scheme that is confusable with a term in the JSON-LD context and no authority to disabmiguate it from a JSON-LD term.");
                }
            }

            // 10 - If vocab is false, transform var to a relative IRI reference using the base IRI from active context, if it exists.
            if (!vocab && activeContext.Base != null)
            {
                if (iri.StartsWith("_:"))
                {
                    // Just return a blank node identifier unchanged
                    return iri;
                }
                var parsedIri = new Uri(iri);
                var relativeIri = activeContext.Base.MakeRelativeUri(parsedIri);
                // KA: If IRI is equivalent to base IRI just return last path segment rather than an empty string
                if (string.Empty.Equals(relativeIri.ToString()))
                {
                    var lastSlashIx = parsedIri.PathAndQuery.LastIndexOf('/');
                    return parsedIri.PathAndQuery.Substring(lastSlashIx + 1);
                }
                return relativeIri.ToString();
            }

            // 11 - Finally, return var as is.
            return iri;
        }


        

        private JToken CompactValue(JsonLdContext activeContext, string activeProperty, JObject value)
        {
            var activeTermDefinition = activeProperty == null ? null : activeContext.GetTerm(activeProperty);

            // 1 - Initialize result to a copy of value.
            var result = value.DeepClone();

            // 2 - If the active context has a null inverse context, set inverse context in active context to the result of calling the
            // Inverse Context Creation algorithm using active context.
            // 3 - Initialize inverse context to the value of inverse context in active context.
            // var inverseContext = activeContext.InverseContext; -- Not used?


            // 4 - Initialize language to the language mapping for active property in active context, if any, otherwise to the default language of active context.
            // 5 - Initialize direction to the direction mapping for active property in active context, if any, otherwise to the default base direction of active context.
            var languageMapping = activeContext.Language;
            var direction = activeContext.BaseDirection;
            if (activeTermDefinition != null)
            {
                if (activeTermDefinition.HasLanguageMapping) languageMapping = activeTermDefinition.LanguageMapping;
                if (activeTermDefinition.DirectionMapping.HasValue) direction = activeTermDefinition.DirectionMapping;
            }

            var activeTermDefinitionTypeMapping = activeTermDefinition?.TypeMapping ?? null;
            var valueHasType = value.ContainsKey("@type");
            var valueType = valueHasType && value["@type"].Type == JTokenType.String ? value["@type"].Value<string>() : null;

            // 6 - If value has an @id entry and has no other entries other than @index:
            if (value.ContainsKey("@id") &&
                value.Properties().All(p => p.Name.Equals("@id") || p.Name.Equals("@index")))
            {
                var typeMapping = activeTermDefinition?.TypeMapping;
                if (typeMapping != null)
                {
                    // 6.1 - If the type mapping of active property is set to @id, set result to the result of IRI compacting the value associated with the @id entry using false for vocab.
                    // 6.2 - Otherwise, if the type mapping of active property is set to @vocab, set result to the result of IRI compacting the value associated with the @id entry.
                    if (typeMapping.Equals("@id") || typeMapping.Equals("@vocab"))
                    {
                        result = CompactIri(activeContext, value["@id"].Value<string>(),
                            vocab: typeMapping.Equals("@vocab"));
                    }
                }
            }
            // 7 - Otherwise, if value has an @type entry whose value matches the type mapping of active property, set result to the value associated with the @value entry of value.
            else if (valueType != null && valueType.Equals(activeTermDefinitionTypeMapping))
            {
                result = value["@value"];
            }
            // 8 - Otherwise, if the type mapping of active property is @none, or value has an @type entry, and the value of @type in value does not match the type mapping of active property, leave value as is, as value compaction is disabled.
            else if ("@none".Equals(activeTermDefinitionTypeMapping) ||
                     valueHasType && (valueType == null || valueType != activeTermDefinitionTypeMapping))
            {
                // 8.1 - Replace any value of @type in result with the result of IRI compacting the value of the @type entry.
                if (result is JObject resultObject && resultObject.ContainsKey("@type"))
                {
                    var typeValue = resultObject["@type"];
                    if (typeValue is JArray typeArray)
                    {
                        var newArray = new JArray();
                        foreach (var item in typeArray)
                        {
                            newArray.Add(CompactIri(activeContext, item.Value<string>(), vocab: true));
                        }

                        resultObject["@type"] = newArray;
                    }
                    else
                    {
                        resultObject["@type"] = CompactIri(activeContext, typeValue.Value<string>(), vocab: true);
                    }
                }
            }
            // 9 - Otherwise, if the value of the @value entry is not a string:
            else if (value.ContainsKey("@value") && value["@value"].Type != JTokenType.String)
            {
                // 9.1 - If value has an @index entry, and the container mapping associated to active property includes @index, or if value has no @index entry, set result to the value associated with the @value entry.
                if ((value.ContainsKey("@index") && activeTermDefinition != null &&
                     activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.Index)) ||
                    (!value.ContainsKey("@index")))
                {
                    result = value["@value"];
                }
            }
            // 10 - Otherwise, if value has an @language entry whose value exactly matches language, using a case-insensitive comparison if it is not null, or is not present, if language is null, and the value has an @direction entry whose value exactly matches direction, if it is not null, or is not present, if direction is null:
            else if (SafeEquals(languageMapping, value.ContainsKey("@language") ? value["@language"] : null, StringComparison.OrdinalIgnoreCase) &&
                     SafeEquals(direction.HasValue ? JsonLdUtils.SerializeLanguageDirection(direction.Value) : null,
                         value.ContainsKey("@direction") ? value["@direction"] : null, StringComparison.OrdinalIgnoreCase))
            {
                // 10.1 - If value has an @index entry, and the container mapping associated to active property includes @index, or value has no @index entry, set result to the value associated with the @value entry.
                if ((value.ContainsKey("@index") && activeTermDefinition != null &&
                     activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.Index)) ||
                    (!value.ContainsKey("@index")))
                {
                    result = value["@value"];
                }
            }
            // 11 - If result is a map, replace each key in result with the result of IRI compacting that key.
            if (result is JObject r)
            {
                foreach (var p in r.Properties().ToList())
                {
                    var compactKey = CompactIri(activeContext, p.Name, vocab: true);
                    if (!compactKey.Equals(p.Name))
                    {
                        r.Remove(p.Name);
                        r.Add(new JProperty(compactKey, p.Value));
                    }
                }
            }
            // 12 - Return result
            return result;
        }

        /// <summary>
        /// Compare a possibly null string and a possibly null JToken for equality.
        /// </summary>
        /// <remarks>If <paramref name="str"/> is null, return true if <paramref name="t"/> is null and false if it is not null.
        /// If <paramref name="str"/> is not null, return true if <paramref name="t"/> is a non-null token of type string and the string value of <paramref name="t"/>
        /// matches the value of <paramref name="str"/> using the comparison method specified by the <paramref name="comparisonOptions"/> parameter.</remarks>
        /// <param name="str"></param>
        /// <param name="t"></param>
        /// <param name="comparisonOptions"></param>
        /// <returns></returns>
        private static bool SafeEquals(string str, JToken t, StringComparison comparisonOptions)
        {
            if (str == null)
            {
                return t == null || t.Type == JTokenType.Null;
            }

            return t != null && t.Type == JTokenType.String && t.Value<string>().Equals(str, comparisonOptions);
        }

        

        /// <summary>
        /// Ensure that a JObject has an entry for a given property, initializing it to an empty map if it does not exist.
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="property"></param>
        /// <returns></returns>
        private static JObject EnsureMapEntry(JObject parent, string property)
        {
            if (!parent.ContainsKey(property))
            {
                parent[property] = new JObject();
            }
            return parent[property] as JObject;
        }


    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json.Linq;
using VDS.RDF.JsonLd.Syntax;

namespace VDS.RDF.JsonLd.Processors
{
    internal class CompactProcessor : ProcessorBase
    {
        private readonly ContextProcessor _contextProcessor;

        public CompactProcessor(JsonLdProcessorOptions options,
            ContextProcessor contextProcessor,
            IList<JsonLdProcessorWarning> warnings) : base(options, warnings)
        {
            _contextProcessor = contextProcessor;
        }

        /// <summary>
        /// Implementation of the JSON-LD Compact Algorithm
        /// </summary>
        /// <param name="activeContext"></param>
        /// <param name="activeProperty"></param>
        /// <param name="element"></param>
        /// <param name="compactArrays"></param>
        /// <param name="ordered"></param>
        /// <returns></returns>
        public JToken CompactElement(JsonLdContext activeContext, string activeProperty, JToken element, bool compactArrays = false, bool ordered = false)
        {
            JsonLdTermDefinition activeTermDefinition = null;
            if (activeProperty != null)
            {
                activeContext.TryGetTerm(activeProperty, out activeTermDefinition, true);
            }

            // 1 - Initialize type-scoped context to active context. This is used for compacting values that may be relevant to any previous type - scoped context.
            var typeScopedContext = activeContext;

            // 2 - If element is a scalar, it is already in its most compact form, so simply return element.
            if (JsonLdUtils.IsScalar(element)) return element;

            // 3 - If element is an array: 
            if (element is JArray elementArray)
            {
                // 3.1 - Initialize result to an empty array.
                var arrayResult = new JArray();

                // 3.2 - For each item in element: 
                foreach (var item in elementArray)
                {
                    // 3.2.1 - Initialize compacted item to the result of using this algorithm recursively, passing active context, active property, item for element, and the compactArrays and ordered flags.
                    var compactedItem = CompactElement(activeContext, activeProperty, item, compactArrays, ordered);
                    // 3.2.2 - If compacted item is not null, then append it to result.
                    if (compactedItem != null) arrayResult.Add(compactedItem);
                }
                // 3.3 - If result is empty or contains more than one value, or compactArrays is false, or active property is either @graph or @set, or container mapping for active property in active context includes either @list or @set, return result.
                if (arrayResult.Count != 1 || !compactArrays || "@graph".Equals(activeProperty) || "@set".Equals(activeProperty))
                {
                    return arrayResult;
                }
                if (activeTermDefinition != null && (activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.List) ||
                                                     activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.Set)))
                {
                    return arrayResult;
                }

                return arrayResult[0];
            }

            // 4 - Otherwise element is a map.
            var elementObject = element as JObject;

            // 5 - If active context has a previous context, the active context is not propagated.
            // If element does not contain an @value entry, and element does not consist of a single @id entry,
            // set active context to previous context from active context, as the scope of a term-scoped context does not apply when processing new node objects.
            if (activeContext.PreviousContext != null)
            {
                if (!elementObject.ContainsKey("@value") &&
                    (elementObject.Count > 1 || !elementObject.ContainsKey("@id")))
                {
                    activeContext = activeContext.PreviousContext;
                    // KA: Spec implies that step 6 uses the term definition in active context (after revert), but implementation uses typeScopedContext (before revert)
                    // Checking this at https://github.com/w3c/json-ld-api/issues/502
                    //activeTermDefinition = activeContext.GetTerm(activeProperty);
                }
            }

            // 6 - If the term definition for active property in active context has a local context:
            if (activeTermDefinition?.LocalContext != null)
            {
                // 6.1 - Set active context to the result of the Context Processing algorithm, passing active context, the value of the active property's
                // local context as local context, base URL from the term definition for active property in active context, and true for override protected.
                activeContext = _contextProcessor.ProcessContext(activeContext, activeTermDefinition.LocalContext,
                    activeTermDefinition.BaseUrl, overrideProtected: true);
                activeTermDefinition = activeContext.GetTerm(activeProperty);
            }

            // 7 - If element has an @value or @id entry and the result of using the Value Compaction algorithm, passing active context, active property,
            // and element as value is a scalar, or the term definition for active property has a type mapping of @json, return that result.
            if (elementObject.ContainsKey("@value") || elementObject.ContainsKey("@id"))
            {
                var compactValue = CompactValue(activeContext, activeProperty, elementObject);
                if (JsonLdUtils.IsScalar(compactValue) ||
                    (activeTermDefinition != null && "@json".Equals(activeTermDefinition.TypeMapping)))
                {
                    return compactValue;
                }
            }
            // 8 - If element is a list object, and the container mapping for active property in active context includes @list, return the result of using this
            // algorithm recursively, passing active context, active property, value of @list in element for element, and the compactArrays and ordered flags.
            if (JsonLdUtils.IsListObject(elementObject) && activeTermDefinition != null && activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.List))
            {
                return CompactElement(activeContext, activeProperty, elementObject["@list"], compactArrays, ordered);
            }
            // 9 - Initialize inside reverse to true if active property equals @reverse, otherwise to false.
            var insideReverse = "@reverse".Equals(activeProperty);
            // 10 - Initialize result to an empty map.
            var result = new JObject();
            // 11 - If element has an @type entry...
            if (elementObject.ContainsKey("@type"))
            {
                // ...create a new array compacted types initialized by transforming each expanded type of that entry into its
                // compacted form by IRI compacting expanded type. 
                var compactedTypes = new JArray();
                var expandedTypes = JsonLdUtils.EnsureArray(elementObject["@type"]);
                foreach (var expandedType in expandedTypes)
                {
                    var compactedType = CompactIri(activeContext, expandedType.Value<string>(), vocab: true);
                    compactedTypes.Add(compactedType);
                }
                // Then, for each term in compacted types ordered lexicographically: 
                foreach (var term in compactedTypes.Select(t => t.Value<string>()).OrderBy(x => x))
                {
                    // 11.1 - If the term definition for term in type-scoped context has a local context set active context to the result of the
                    // Context Processing algorithm, passing active context and the value of term's local context in type-scoped context as
                    // local context base URL from the term definition for term in type-scoped context, and false for propagate. 
                    if (typeScopedContext.TryGetTerm(term, out var termDef) && termDef.LocalContext != null)
                    {
                        activeContext = _contextProcessor.ProcessContext(activeContext, termDef.LocalContext, termDef.BaseUrl,
                            propagate: false);
                    }
                }
            }
            // 12 - For each key expanded property and value expanded value in element, ordered lexicographically by expanded property if ordered is true: 
            var properties = elementObject.Properties();
            if (ordered) properties = properties.OrderBy(p => p.Name);
            foreach (var p in properties)
            {
                var expandedProperty = p.Name;
                var expandedValue = p.Value;
                // 12.1 - If expanded property is @id:
                if (expandedProperty.Equals("@id"))
                {
                    // 12.1.1 - If expanded value is a string, then initialize compacted value by IRI compacting expanded value with vocab set to false.
                    var compactedValue = CompactIri(activeContext, expandedValue.Value<string>(), vocab: false);
                    // 12.1.2 - Initialize alias by IRI compacting expanded property.
                    var alias = CompactIri(activeContext, expandedProperty, vocab: true);
                    // 12.1.3 - Add an entry alias to result whose value is set to compacted value and continue to the next expanded property.
                    result.Add(new JProperty(alias, compactedValue));
                    continue;
                }

                // 12.2 - If expanded property is @type:
                if (expandedProperty.Equals("@type"))
                {
                    JToken compactedValue;
                    // 12.2.1 - If expanded value is a string, then initialize compacted value by IRI compacting expanded value using type-scoped context for active context.
                    if (expandedValue.Type == JTokenType.String)
                    {
                        compactedValue = CompactIri(typeScopedContext, expandedValue.Value<string>(), vocab: true);
                    }
                    else
                    {
                        // 12.2.2 - Otherwise, expanded value must be a @type array:
                        // 12.2.2.1 - Initialize compacted value to an empty array.
                        var compactedValueArray = new JArray();
                        compactedValue = compactedValueArray;
                        // 12.2.2.2 - For each item expanded type in expanded value:
                        foreach (var item in expandedValue.Children())
                        {
                            // 12.2.2.2.1 - Set term by IRI compacting expanded type using type-scoped context for active context.
                            var term = CompactIri(typeScopedContext, item.Value<string>(), vocab: true);
                            // 12.2.2.2.2 - Append term, to compacted value.
                            compactedValueArray.Add(term);
                        }
                    }

                    // 12.2.3 - Initialize alias by IRI compacting expanded property.
                    var alias = CompactIri(activeContext, expandedProperty, vocab: true);

                    // 12.2.4 - Initialize as array to true if processing mode is json - ld - 1.1 and the container mapping for alias in the active context includes @set, otherwise to the negation of compactArrays.
                    var aliasTermDefinition = activeContext.GetTerm(alias);
                    var asArray =
                        Options.ProcessingMode == JsonLdProcessingMode.JsonLd11 &&
                        aliasTermDefinition != null &&
                        aliasTermDefinition.ContainerMapping.Contains(JsonLdContainer.Set) || !compactArrays;
                    // 12.2.5 - Use add value to add compacted value to the alias entry in result using as array.
                    JsonLdUtils.AddValue(result, alias, compactedValue, asArray);

                    // 12.2.6 - Continue to the next expanded property.
                    continue;
                }
                // 12.3 - If expanded property is @reverse:
                if ("@reverse".Equals(expandedProperty))
                {
                    // 12.3.1 - Initialize compacted value to the result of using this algorithm recursively, passing active context, @reverse for active property, expanded value for element, and the compactArrays and ordered flags.
                    var compactedValue =
                        CompactElement(activeContext, "@reverse", expandedValue, compactArrays, ordered);
                    if (compactedValue is JObject compactedObject)
                    {
                        // 12.3.2 - For each property and value in compacted value:
                        foreach (var compactedObjectProperty in compactedObject.Properties().ToList())
                        {
                            // 12.3.1 - If the term definition for property in the active context indicates that property is a reverse property
                            var td = activeContext.GetTerm(compactedObjectProperty.Name, true);
                            if (td != null && td.Reverse)
                            {
                                // 12.3.2.1.1 - Initialize as array to true if the container mapping for property in the active context includes @set, otherwise the negation of compactArrays.
                                var asArray = td.ContainerMapping.Contains(JsonLdContainer.Set) || !compactArrays;
                                // 12.3.2.1.2 - Use add value to add value to the property entry in result using as array.
                                JsonLdUtils.AddValue(result, compactedObjectProperty.Name, compactedObjectProperty.Value, asArray);
                                // 12.3.2.1.3 - Remove the property entry from compacted value.
                                compactedObjectProperty.Remove();
                            }
                        }
                        // 12.3.3 - If compacted value has some remaining map entries, i.e., it is not an empty map:
                        if (compactedObject.HasValues)
                        {
                            var alias = CompactIri(activeContext, "@reverse", vocab: true);
                            result.Add(alias, compactedValue);
                        }
                    }
                    // 12.3.4 - Continue with the next expanded property from element.
                    continue;
                }
                // 12.4 - If expanded property is @preserve then:
                if ("@preserve".Equals(expandedProperty))
                {
                    if (!JsonLdUtils.IsEmptyArray(expandedValue))
                    {
                        // 12.4.1 - Initialize compacted value to the result of using this algorithm recursively, passing
                        // active context, active property, expanded value for element, and the compactArrays and ordered flags.
                        var compactedValue = CompactElement(activeContext, activeProperty, expandedValue,
                            compactArrays,
                            ordered);
                        // 12.4.2 Add compacted value as the value of @preserve in result unless expanded value is an empty array.
                        result.Add("@preserve", compactedValue);
                    }
                }
                // 12.5 - If expanded property is @index and active property has a container mapping in active context that includes
                // @index, then the compacted result will be inside of an @index container, drop the @index entry by continuing to
                // the next expanded property.
                if ("@index".Equals(expandedProperty) &&
                    activeTermDefinition != null &&
                    activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.Index))
                {
                    continue;
                }
                // 12.6 - Otherwise, if expanded property is @direction, @index, @language, or @value: 
                else if ("@direction".Equals(expandedProperty) ||
                           "@index".Equals(expandedProperty) ||
                           "@language".Equals(expandedProperty) ||
                           "@value".Equals(expandedProperty))
                {
                    // 12.6.1 - Initialize alias by IRI compacting expanded property.
                    var alias = CompactIri(activeContext, expandedProperty, vocab: true);
                    // 12.6.2 - Add an entry alias to result whose value is set to expanded value and continue with the next expanded property.
                    result.Add(alias, expandedValue);
                    continue;
                }
                // 12.7 - If expanded value is an empty array: 
                if (JsonLdUtils.IsEmptyArray(expandedValue))
                {
                    // 12.7.1 - Initialize item active property by IRI compacting expanded property using expanded value for value and inside reverse for reverse.
                    var itemActiveProperty =
                        CompactIri(activeContext, expandedProperty, expandedValue, true, insideReverse);
                    // 12.7.2 - If the term definition for item active property in the active context has a nest value entry(nest term): 
                    var td = activeContext.GetTerm(itemActiveProperty);
                    JObject nestResult = null;
                    if (td?.Nest != null)
                    {

                        // 12.7.2.1 - If nest term is not @nest, or a term in the active context that expands to @nest, an invalid @nest value error has been detected, and processing is aborted.
                        var nestTerm = _contextProcessor.ExpandIri(activeContext, td.Nest, true);
                        if (!"@nest".Equals(nestTerm))
                        {
                            throw new JsonLdProcessorException(JsonLdErrorCode.InvalidNestValue,
                                $"Invalid Nest Value. Error compacting property {expandedProperty} of {activeProperty}. The value of {expandedProperty} should be '@nest' or a term that expands to '@nest'.");
                        }
                        // 12.7.2.2 - If result does not have a nest term entry, initialize it to an empty map.
                        if (!result.ContainsKey("@nest"))
                        {
                            result.Add("@nest", new JObject());
                        }
                        // 12.7.2.3 - Initialize nest result to the value of nest term in result.
                        nestResult = result["@nest"] as JObject;
                    }
                    // 12.7.3 - Otherwise, initialize nest result to result.
                    else
                    {
                        nestResult = result;
                    }
                    // 12.7.4 - Use add value to add an empty array to the item active property entry in nest result using true for as array.
                    JsonLdUtils.AddValue(nestResult, itemActiveProperty, new JArray(), true);
                }
                // 12.8 -  At this point, expanded value must be an array due to the Expansion algorithm. For each item expanded item in expanded value: 
                foreach (var expandedItem in expandedValue.Children())
                {
                    // 12.8.1 - Initialize item active property by IRI compacting expanded property using expanded item for value and inside reverse for reverse.
                    var itemActiveProperty =
                        CompactIri(activeContext, expandedProperty, expandedItem, true, insideReverse);
                    // 12.8.2 - If the term definition for item active property in the active context has a nest value entry (nest term):
                    var itemActiveTermDefinition = activeContext.GetTerm(itemActiveProperty);
                    JObject nestResult = null;
                    if (itemActiveTermDefinition?.Nest != null)
                    {
                        // 12.8.2.1 - If nest term is not @nest, or a term in the active context that expands to @nest, an invalid @nest value error has been detected, and processing is aborted.
                        var nestTerm = itemActiveTermDefinition.Nest;
                        if (!"@nest".Equals(_contextProcessor.ExpandIri(activeContext, nestTerm, true)))
                        {
                            throw new JsonLdProcessorException(JsonLdErrorCode.InvalidNestValue,
                                $"Invalid Nest Value. Error compacting property {expandedProperty} of {activeProperty}. The value of {expandedProperty} should be '@nest' or a term that expands to '@nest'.");
                        }
                        // 12.8.2.2 - If result does not have a nest term entry, initialize it to an empty map.
                        // 12.8.2.3 - Initialize nest result to the value of nest term in result.
                        nestResult = EnsureMapEntry(result, nestTerm);
                    }
                    // 12.8.3 - Otherwise, initialize nest result to result.
                    else
                    {
                        nestResult = result;
                    }

                    // 12.8.4 - Initialize container to container mapping for item active property in active context, or to a new empty array, if there is no such container mapping.
                    var container = (itemActiveTermDefinition?.ContainerMapping != null)
                        ? itemActiveTermDefinition.ContainerMapping
                        : new HashSet<JsonLdContainer>();
                    // 12.8.5 - Initialize as array to true if container includes @set, or if item active property is @graph or @list, otherwise the negation of compactArrays.
                    var asArray = container.Contains(JsonLdContainer.Set) ||
                                  "@graph".Equals(itemActiveProperty) ||
                                   "@list".Equals(itemActiveProperty) ||
                                  !compactArrays;
                    // 12.8.6 - Initialize compacted item to the result of using this algorithm recursively, passing active context,
                    // item active property for active property, expanded item for element, along with the compactArrays and ordered flags.
                    // If expanded item is a list object or a graph object, use the value of the @list or @graph entries, respectively, for element instead of expanded item.
                    var elementToCompact = JsonLdUtils.IsListObject(expandedItem) ? expandedItem["@list"] :
                        JsonLdUtils.IsGraphObject(expandedItem) ? expandedItem["@graph"] : expandedItem;
                    var compactedItem = CompactElement(activeContext, itemActiveProperty, elementToCompact,
                        compactArrays, ordered);
                    // 12.8.7 - If expanded item is a list object: 
                    if (JsonLdUtils.IsListObject(expandedItem))
                    {
                        // 12.8.7.1 - If compacted item is not an array, then set compacted item to an array containing only compacted item.
                        compactedItem = JsonLdUtils.EnsureArray(compactedItem);
                        // 12.8.7.2 - If container does not include @list: 
                        if (!container.Contains(JsonLdContainer.List))
                        {
                            // 12.8.7.2.1 - Convert compacted item to a list object by setting it to a map containing an entry where the key is
                            // the result of IRI compacting @list and the value is the original compacted item.
                            compactedItem = new JObject(new JProperty(CompactIri(activeContext, "@list", vocab: true), compactedItem));

                            // 12.8.7.2.2 - If expanded item contains the entry @index - value, then add an entry to compacted item where the key is the result of IRI compacting @index and value is value.
                            if (expandedItem is JObject expandedItemObject && expandedItemObject.ContainsKey("@index"))
                            {
                                (compactedItem as JObject).Add(new JProperty(CompactIri(activeContext, "@index", vocab: true), expandedItemObject["@index"]));
                            }
                            // 12.8.7.2.3 - Use add value to add compacted item to the item active property entry in nest result using as array.
                            JsonLdUtils.AddValue(nestResult, itemActiveProperty, compactedItem, asArray);
                        }
                        // 12.8.7.3 - Otherwise, set the value of the item active property entry in nest result to compacted item.
                        else
                        {
                            nestResult[itemActiveProperty] = compactedItem;
                        }
                    }
                    // 12.8.8 - If expanded item is a graph object: 
                    // KA: Although algorithm doesn't say "Otherwise", I think this is an else-if branch as nestResult gets updated in the preceding if branch.
                    else if (JsonLdUtils.IsGraphObject(expandedItem))
                    {
                        // 12.8.8.1 - If container includes @graph and @id: 
                        if (container.Contains(JsonLdContainer.Graph) && container.Contains(JsonLdContainer.Id))
                        {
                            // 12.8.8.1.1 - Initialize map object to the value of item active property in nest result, initializing it to a new empty map, if necessary.
                            var mapObject = EnsureMapEntry(nestResult, itemActiveProperty);

                            // 12.8.8.1.2 - Initialize map key by IRI compacting the value of @id in expanded item or @none if no such value exists with vocab set to false if there is an @id entry in expanded item.
                            var mapKey =
                                (expandedItem is JObject expandedItemObject && expandedItemObject.ContainsKey("@id"))
                                    ? CompactIri(activeContext, expandedItemObject["@id"].Value<string>(),
                                        vocab: false)
                                    : CompactIri(activeContext, "@none", vocab: true);
                            // 12.8.8.1.3 - Use add value to add compacted item to the map key entry in map object using as array.
                            JsonLdUtils.AddValue(mapObject, mapKey, compactedItem, asArray);
                        }
                        // 12.8.8.2 - Otherwise, if container includes @graph and @index and expanded item is a simple graph object: 
                        else if (JsonLdUtils.IsSimpleGraphObject(expandedItem) && container.Contains(JsonLdContainer.Graph) &&
                                 container.Contains(JsonLdContainer.Index))
                        {
                            // 12.8.8.2.1 - Initialize map object to the value of item active property in nest result, initializing it to a new empty map, if necessary.
                            var mapObject = EnsureMapEntry(nestResult, itemActiveProperty);
                            // 12.8.8.2.2 - Initialize map key the value of @index in expanded item or @none, if no such value exists.
                            var mapKey =
                                expandedItem is JObject expandedItemObject && expandedItemObject.ContainsKey("@index")
                                    ? expandedItemObject["@index"].Value<string>()
                                    : "@none";
                            // 12.8.8.2.3 - Use add value to add compacted item to the map key entry in map object using as array.
                            JsonLdUtils.AddValue(mapObject, mapKey, compactedItem, asArray);
                        }
                        // 12.8.8.3 - Otherwise, if container includes @graph and expanded item is a simple graph object the value cannot be represented as a map object. 
                        else if (JsonLdUtils.IsSimpleGraphObject(expandedItem) && container.Contains(JsonLdContainer.Graph))
                        {
                            // 12.8.8.3.1 - If compacted item is an array with more than one value, it cannot be directly represented, as multiple objects would be interpreted as different named graphs.
                            if ((compactedItem is JArray compactedItemArray) && compactedItemArray.Count > 1)
                            {
                                // Set compacted item to a new map, containing the key from IRI compacting @included and the original compacted item as the value.
                                compactedItem =
                                    new JObject(new JProperty(CompactIri(activeContext, "@included", vocab: true),
                                        compactedItem));
                            }

                            // 12.8.8.3.2 - Use add value to add compacted item to the item active property entry in nest result using as array.
                            JsonLdUtils.AddValue(nestResult, itemActiveProperty, compactedItem, asArray);
                        }
                        // 12.8.8.4 - Otherwise, container does not include @graph or otherwise does not match one of the previous cases.
                        else
                        {
                            // 12.8.8.4.1 - Set compacted item to a new map containing the key from IRI compacting @graph using the original compacted item as a value.
                            compactedItem = new JObject(new JProperty(CompactIri(activeContext, "@graph", vocab: true), compactedItem));
                            if (expandedItem is JObject expandedItemObject)
                            {
                                // 12.8.8.4.2 - If expanded item contains an @id entry, add an entry in compacted item using the key from IRI
                                // compacting @id using the value of IRI compacting the value of @id in expanded item using false for vocab.
                                if (expandedItemObject.ContainsKey("@id"))
                                {
                                    (compactedItem as JObject).Add(
                                        CompactIri(activeContext, "@id", vocab: true),
                                        CompactIri(activeContext, expandedItemObject["@id"].Value<string>(),
                                            vocab: false));
                                }
                                // 12.8.8.4.3 - If expanded item contains an @index entry, add an entry in compacted item using the key from IRI compacting @index and the value of @index in expanded item.
                                if (expandedItemObject.ContainsKey("@index"))
                                {
                                    (compactedItem as JObject).Add(
                                        CompactIri(activeContext, "@index", vocab: true),
                                        CompactIri(activeContext, expandedItemObject["@index"].Value<string>(),
                                            vocab: true));
                                }
                            }
                            // 12.8.8.4.4 - Use add value to add compacted item to the item active property entry in nest result using as array.
                            JsonLdUtils.AddValue(nestResult, itemActiveProperty, compactedItem, asArray);
                        }
                    }
                    // 12.8.9 - Otherwise, if container includes @language, @index, @id, or @type and container does not include @graph: 
                    else if ((container.Contains(JsonLdContainer.Language) ||
                              container.Contains(JsonLdContainer.Index) ||
                              container.Contains(JsonLdContainer.Id) ||
                              container.Contains(JsonLdContainer.Type)) && !container.Contains(JsonLdContainer.Graph))
                    {
                        // 12.8.9.1 - Initialize map object to the value of item active property in nest result, initializing it to a new empty map, if necessary.
                        if (!nestResult.ContainsKey(itemActiveProperty))
                        {
                            nestResult[itemActiveProperty] = new JObject();
                        }
                        var mapObject = nestResult[itemActiveProperty] as JObject;

                        // 12.8.9.2 - Initialize container key by IRI compacting either @language, @index, @id, or @type based on the contents of container.
                        string expandedKey = null;
                        if (container.Contains(JsonLdContainer.Language)) expandedKey = "@language";
                        if (container.Contains(JsonLdContainer.Index)) expandedKey = "@index";
                        if (container.Contains(JsonLdContainer.Id)) expandedKey = "@id";
                        if (container.Contains(JsonLdContainer.Type)) expandedKey = "@type";
                        var containerKey = CompactIri(activeContext, expandedKey, vocab: true);

                        // 12.8.9.3 - Initialize index key to the value of index mapping in the term definition associated with item active property in active context, or @index, if no such value exists.
                        var indexKey = itemActiveTermDefinition?.IndexMapping != null
                            ? itemActiveTermDefinition.IndexMapping
                            : "@index";

                        // 12.8.9.4 - If container includes @language and expanded item contains a @value entry, then set compacted item to the value associated with its @value entry.
                        // Set map key to the value of @language in expanded item, if any.
                        string mapKey = null;
                        if (container.Contains(JsonLdContainer.Language) && expandedItem is JObject expandedItemObject &&
                            expandedItemObject.ContainsKey("@value"))
                        {
                            compactedItem = expandedItemObject["@value"];
                            if (expandedItemObject.ContainsKey("@language"))
                            {
                                mapKey = expandedItemObject["@language"].Value<string>();
                            }
                        }
                        // 12.8.9.5 - Otherwise, if container includes @index and index key is @index, set map key to the value of @index in expanded item, if any.
                        else if (container.Contains(JsonLdContainer.Index) && "@index".Equals(indexKey))
                        {
                            if (expandedItem is JObject expandedItemObject && expandedItemObject.ContainsKey("@index"))
                            {
                                mapKey = expandedItemObject["@index"].Value<string>();
                            }
                        }
                        // 12.8.9.6 - Otherwise, if container includes @index and index key is not @index: 
                        else if (container.Contains(JsonLdContainer.Index) && compactedItem is JObject)
                        {
                            // 12.8.9.6.1 - Reinitialize container key by IRI compacting index key.
                            containerKey = CompactIri(activeContext, indexKey, vocab: true);
                            // 12.8.9.6.2 - Set map key to the first value of container key in compacted item, if any.
                            // 12.8.9.6.3 - If there are remaining values in compacted item for container key, use add value to add those remaining values to the container key in compacted item.
                            // Otherwise, remove that entry from compacted item.
                            var array = JsonLdUtils.EnsureArray(compactedItem[containerKey]);

                            (compactedItem as JObject).Remove(containerKey);
                            foreach (var item in array)
                            {
                                if (mapKey == null && item.Type == JTokenType.String)
                                {
                                    mapKey = item.Value<string>();
                                }
                                else
                                {
                                    JsonLdUtils.AddValue(compactedItem as JObject, containerKey, item);
                                }
                            }
                        }
                        // 12.8.9.7 - Otherwise, if container includes @id, set map key to the value of container key in compacted item and remove container key from compacted item.
                        else if (container.Contains(JsonLdContainer.Id))
                        {
                            if (compactedItem is JObject compactedItemObject &&
                                compactedItemObject.ContainsKey(containerKey))
                            {
                                mapKey = compactedItemObject[containerKey].Value<string>();
                                compactedItemObject.Remove(containerKey);
                            }
                        }
                        // 12.8.9.8 - Otherwise, if container includes @type: 
                        else if (container.Contains(JsonLdContainer.Type))
                        {
                            // 12.8.9.8.1 - Set map key to the first value of container key in compacted item, if any.
                            // 12.8.9.8.2 - If there are remaining values in compacted item for container key, use add value to add those remaining values to the container key in compacted item.
                            // 12.8.9.8.3 - Otherwise, remove that entry from compacted item.
                            var array = JsonLdUtils.EnsureArray(compactedItem[containerKey]);
                            if (array.Count > 0)
                            {
                                mapKey = array[0].Value<string>();
                                array.RemoveAt(0);
                                if (array.Count == 0) (compactedItem as JObject).Remove(containerKey);
                                else if (array.Count == 1) compactedItem[containerKey] = array[0];
                            }
                            // 12.8.9.8.4 - If compacted item contains a single entry with a key expanding to @id, set compacted item to the result of using this algorithm recursively, passing active context, item active property for active property, and a map composed of the single entry for @id from expanded item for element.
                            if ((compactedItem is JObject compactedItemObject) && compactedItemObject.Count == 1)
                            {
                                if (_contextProcessor.ExpandIri(activeContext, compactedItemObject.Properties().First().Name, vocab: true)
                                    .Equals("@id"))
                                {
                                    compactedItem = CompactElement(activeContext, itemActiveProperty,
                                        new JObject(new JProperty("@id", expandedItemObject["@id"])));
                                }
                            }
                        }
                        // 12.8.9.9 - If map key is null, set it to the result of IRI compacting @none.
                        if (mapKey == null) mapKey = CompactIri(activeContext, "@none", vocab: true);
                        // 12.8.9.10 - Use add value to add compacted item to the map key entry in map object using as array.
                        JsonLdUtils.AddValue(mapObject, mapKey, compactedItem, asArray);
                    }
                    // 12.8.10 - Otherwise, use add value to add compacted item to the item active property entry in nest result using as array.
                    else
                    {
                        JsonLdUtils.AddValue(nestResult, itemActiveProperty, compactedItem, asArray);
                    }
                }
            }

            return result;
        }

        public string CompactIri(JsonLdContext activeContext, string iri, JToken value = null,
    bool vocab = false, bool reverse = false)
        {
            // 1 - If var is null, return null.
            // KA - note local name for var is iri to avoid clash with C# keyword
            if (iri == null) return null;

            // 2 - If the active context has a null inverse context, set inverse context in active context to the result of calling the Inverse Context Creation algorithm using active context.
            // Initialize inverse context to the value of inverse context in active context.
            var inverseContext = activeContext.InverseContext;

            // 4 - If vocab is true and var is an entry of inverse context:
            if (vocab && inverseContext.ContainsKey(iri))
            {
                var defaultLanguage = "@none";
                // 4.1 - Initialize default language based on the active context's default language, normalized to lower case and default base direction: 
                // 4.1.1 - If the active context's default base direction is not null, to the concatenation of the active context's default language and default base direction, separated by an underscore("_"), normalized to lower case.
                // 4.1.2 - Otherwise, to the active context's default language, if it has one, normalized to lower case, otherwise to @none.
                if (activeContext.BaseDirection.HasValue &&
                    activeContext.BaseDirection != LanguageDirection.Unspecified)
                {
                    defaultLanguage =
                        (JsonLdUtils.SerializeLanguageDirection(activeContext.BaseDirection.Value) + "_" + activeContext.Language)
                        .ToLowerInvariant();
                }
                else if (!string.IsNullOrEmpty(activeContext.Language))
                {
                    defaultLanguage = activeContext.Language.ToLowerInvariant();
                }

                // 4.2 - If value is a map containing an @preserve entry, use the first element from the value of @preserve as value.
                if ((value is JObject valueMap) && valueMap.ContainsKey("@preserve"))
                {
                    value = valueMap["@preserve"];
                    if (value is JArray valueArray)
                    {
                        value = valueArray[0];
                    }
                }

                // 4.3 - Initialize containers to an empty array. This array will be used to keep track of an ordered list of preferred container mapping for a term, based on what is compatible with value. 
                var containers = new List<string>();
                // 4.4 - Initialize type/language to @language, and type/language value to @null. These two variables will keep track of the preferred type mapping or language mapping for a term, based on what is compatible with value.
                var typeLanguage = "@language";
                var typeLanguageValue = "@null";
                // 4.5 - If value is a map containing an @index entry, and value is not a graph object then append the values @index and @index@set to containers.
                if (value is JObject && (value as JObject).ContainsKey("@index") && !JsonLdUtils.IsGraphObject(value))
                {
                    containers.Add("@index");
                    containers.Add("@index@set");
                }

                // 4.6 - If reverse is true, set type/language to @type, type/language value to @reverse, and append @set to containers.
                if (reverse)
                {
                    typeLanguage = "@type";
                    typeLanguageValue = "@reverse";
                    containers.Add("@set");
                }
                else if (JsonLdUtils.IsListObject(value))
                {
                    // 4.7 - Otherwise, if value is a list object, then set type/language and type/language value to the most specific values that work for all items in the list as follows: 
                    // 4.7.1 - If @index is not an entry in value, then append @list to containers.
                    if (!valueObject.ContainsKey("@index")) containers.Add("@list");
                    // 4.7.2 - Initialize list to the array associated with the @list entry in value.
                    var list = JsonLdUtils.EnsureArray(valueObject["@list"]);
                    // 4.7.3 - Initialize common type and common language to null.If list is empty, set common language to default language.
                    string commonType = null;
                    string commonLanguage = null;
                    if (list.Count == 0)
                    {
                        commonLanguage = defaultLanguage;
                    }

                    // 4.7.4 - For each item in list:
                    foreach (var item in list)
                    {
                        // 4.7.4.1 - Initialize item language to @none and item type to @none.
                        var itemLanguage = "@none";
                        var itemType = "@none";

                        // 4.7.4.2 - If item contains an @value entry:
                        if (item is JObject itemObject && itemObject.ContainsKey("@value"))
                        {
                            if (itemObject.ContainsKey("@direction"))
                            {
                                if (itemObject.ContainsKey("@language"))
                                {
                                    itemLanguage =
                                        (itemObject["@language"].Value<string>() + "_" +
                                         itemObject["@direction"].Value<string>()).ToLowerInvariant();
                                }
                                else
                                {
                                    itemLanguage = "_" + itemObject["@direction"].Value<string>().ToLowerInvariant();
                                }
                            }
                            else if (itemObject.ContainsKey("@language"))
                            {
                                itemLanguage = itemObject["@language"].Value<string>().ToLowerInvariant();
                            }
                            else if (itemObject.ContainsKey("@type"))
                            {
                                itemType = itemObject["@type"].Value<string>();
                            }
                            else
                            {
                                itemLanguage = "@null";
                            }
                        }
                        // 4.7.4.3 - Otherwise, set item type to @id.
                        else
                        {
                            itemType = "@id";
                        }

                        // 4.7.4.4 - If common language is null, set common language to item language.
                        if (commonLanguage == null)
                        {
                            commonLanguage = itemLanguage;
                        }
                        else
                        {
                            // 4.7.4.5 - Otherwise, if item language does not equal common language and item contains a @value entry, then set common language to @none because list items have conflicting languages.
                            if (!itemLanguage.Equals(commonLanguage) && itemObject.ContainsKey("@value"))
                            {
                                commonLanguage = "@none";
                            }
                        }

                        // 4.7.4.6 - If common type is null, set common type to item type.
                        if (commonType == null)
                        {
                            commonType = itemType;
                        }
                        else
                        {
                            // 4.7.4.7 - Otherwise, if item type does not equal common type, then set common type to @none because list items have conflicting types.
                            if (!itemType.Equals(commonType))
                            {
                                commonType = "@none";
                            }
                        }

                        // 4.7.4.8 - If common language is @none and common type is @none, then stop processing items in the list because it has been detected that there is no common language or type amongst the items.
                        if ("@none".Equals(commonLanguage) && "@none".Equals(commonType)) break;
                    }

                    // 4.7.5 - If common language is null, set common language to @none.
                    if (commonLanguage == null) commonLanguage = "@none";
                    // 4.7.6 - If common type is null, set common type to @none.
                    if (commonType == null) commonType = "@none";
                    // 4.7.7 - If common type is not @none then set type / language to @type and type/ language value to common type.
                    if (!"@none".Equals(commonType))
                    {
                        typeLanguage = "@type";
                        typeLanguageValue = commonType;
                    }
                    else
                    {
                        // 4.7.8 - Otherwise, set type/ language value to common language.
                        typeLanguageValue = commonLanguage;
                    }
                }
                else if (JsonLdUtils.IsGraphObject(value))
                {
                    // 4.8 - Otherwise, if value is a graph object, prefer a mapping most appropriate for the particular value. 
                    // 4.8.1 - If value contains an @index entry, append the values @graph@index and @graph@index@set to containers.
                    if (value is JObject valueObject && valueObject.ContainsKey("@index"))
                    {
                        containers.Add("@graph@index");
                        containers.Add("@graph@index@set");
                    }

                    // 4.8.2 - If value contains an @id entry, append the values @graph @id and @graph@id @set to containers.
                    if (value is JObject valueObject && valueObject.ContainsKey("@id"))
                    {
                        containers.Add("@graph@id");
                        containers.Add("@graph@id@set");
                    }

                    // 4.8.3 - Append the values @graph @graph @set, and @set to containers.
                    containers.Add("@graph");
                    containers.Add("@graph@set");
                    containers.Add("@set");
                    // 4.8.4 - If value does not contain an @index entry, append the values @graph @index and @graph@index @set to containers.
                    if (valueObject == null || !valueObject.ContainsKey("@index"))
                    {
                        containers.Add("@graph@index");
                        containers.Add("@graph@index@set");

                    }

                    // 4.8.5 - If the value does not contain an @id entry, append the values @graph@id and @graph @id@set to containers.
                    if (valueObject == null || !valueObject.ContainsKey("@id"))
                    {
                        containers.Add("@graph@id");
                        containers.Add("@graph@id@set");
                    }

                    // 4.8.6 - Append the values @index and @index@set to containers.
                    containers.Add("@index");
                    containers.Add("@index@set");
                    // 4.8.7 - Set type / language to @type and set type / language value to @id.
                    typeLanguage = "@type";
                    typeLanguageValue = "@id";
                }
                // 4.9 - Otherwise
                else
                {
                    // 4.9.1 - If value is a value object: 
                    if (JsonLdUtils.IsValueObject(value))
                    {
                        // 4.9.1.1 - If value contains an @direction entry and does not contain an @index entry, then set type/language value to the concatenation of the value's @language entry (if any) and the value's @direction entry, separated by an underscore ("_"), normalized to lower case. Append @language and @language@set to containers.
                        if (valueObject.ContainsKey("@direction") && !valueObject.ContainsKey("@index"))
                        {
                            if (valueObject.ContainsKey("@language"))
                            {
                                typeLanguageValue =
                                    (valueObject["@language"].Value<string>() + "_" +
                                     valueObject["@direction"].Value<string>()).ToLowerInvariant();
                            }
                            else
                            {
                                typeLanguageValue = ("_" + valueObject["direction"].Value<string>()).ToLowerInvariant();
                            }

                            containers.Add("@language");
                            containers.Add("@language@set");
                        }
                        // 4.9.1.2 - Otherwise, if value contains an @language entry and does not contain an @index entry, then set type/language value to the value of @language normalized to lower case, and append @language, and @language@set to containers.
                        else if (valueObject.ContainsKey("@language") && !valueObject.ContainsKey("@index"))
                        {
                            typeLanguageValue = valueObject["@language"].Value<string>().ToLowerInvariant();
                            containers.Add("@language");
                            containers.Add("@language@set");
                        }
                        // 4.9.1.3 - Otherwise, if value contains an @type entry, then set type/language value to its associated value and set type/language to @type.
                        else if (valueObject.ContainsKey("@type"))
                        {
                            typeLanguageValue = valueObject["@type"].Value<string>();
                            typeLanguage = "@type";
                        }

                    }
                    // 4.9.2 - Otherwise, set type/language to @type and set type/language value to @id, and append @id, @id@set, @type, and @set@type, to containers.
                    else
                    {
                        typeLanguage = "@type";
                        typeLanguageValue = "@id";
                        containers.Add("@id");
                        containers.Add("@id@set");
                        containers.Add("@type");
                        containers.Add("@set@type");
                    }

                    // 4.9.3 - Append @set to containers.
                    containers.Add("@set");
                }

                // 4.10 - Append @none to containers. This represents the non-existence of a container mapping, and it will be the last container mapping value to be checked as it is the most generic.
                containers.Add("@none");
                if (Options.ProcessingMode != JsonLdProcessingMode.JsonLd10)
                {
                    // 4.11 - If processing mode is not json-ld-1.0 and value is not a map or does not contain an @index entry, append @index and @index@set to containers.
                    if (value == null || value.Type != JTokenType.Object || !(value as JObject).ContainsKey("@index"))
                    {
                        containers.Add("@index");
                        containers.Add("@index@set");
                    }

                    // 4.12 - If processing mode is not json - ld - 1.0 and value is a map containing only an @value entry, append @language and @language@set to containers.
                    if (value is JObject valueObject &&
                        valueObject.Count == 1 &&
                        valueObject.ContainsKey("@value"))
                    {
                        containers.Add("@language");
                        containers.Add("@language@set");
                    }
                }

                // 4.13 - If type / language value is null, set type/ language value to @null.This is the key under which null values are stored in the inverse context entry.
                if (typeLanguageValue == null) typeLanguageValue = "@null";
                // 4.14 - Initialize preferred values to an empty array.This array will indicate, in order, the preferred values for a term's type mapping or language mapping.
                var preferredValues = new List<string>();
                // 4.15 - If type / language value is @reverse, append @reverse to preferred values.
                if (typeLanguageValue.Equals("@reverse"))
                {
                    preferredValues.Add("@reverse");
                }

                // 4.16 - type/language value is @id or @reverse and value is a map containing an @id entry: 
                if ((typeLanguageValue.Equals("@id") || typeLanguageValue.Equals("@reverse")) && (value is JObject) &&
                    (value as JObject).ContainsKey("@id"))
                {
                    // 4.16.1 If the result of IRI compacting the value of the @id entry in value has a term definition in the active context with an IRI mapping that equals the value of the @id entry in value, then append @vocab, @id, and @none, in that order, to preferred values.
                    var idValue = value["@id"].Value<string>();
                    var compactedId = CompactIri(activeContext, idValue, vocab: true);
                    if (activeContext.TryGetTerm(compactedId, out var td2) && td2.IriMapping.Equals(idValue))
                    {
                        preferredValues.Add("@vocab");
                        preferredValues.Add("@id");
                        preferredValues.Add("@none");
                    }
                    else
                    {
                        // 4.16.2 - Otherwise, append @id, @vocab, and @none, in that order, to preferred values.
                        preferredValues.Add("@id");
                        preferredValues.Add("@vocab");
                        preferredValues.Add("@none");
                    }
                }
                else
                {
                    // 4.17 - Otherwise, append type/language value and @none, in that order, to preferred values.
                    // If value is a list object with an empty array as the value of @list, set type/language to @any.
                    preferredValues.Add(typeLanguageValue);
                    preferredValues.Add("@none");
                    if (JsonLdUtils.IsListObject(value) && (value["@list"] as JArray).Count == 0)
                    {
                        typeLanguage = "@any";
                    }
                }

                // 4.18 - Append @any to preferred values.
                preferredValues.Add("@any");
                
                // 4.19 - If preferred values contains any entry having an underscore ("_"), append the substring of that entry from the underscore to the end of the string to preferred values.
                var toAppend = preferredValues
                    .Where(pv => pv.Contains("_"))
                    .Select(pv => pv.Substring(pv.IndexOf("_", StringComparison.Ordinal)))
                    .ToList();
                preferredValues.AddRange(toAppend);

                // 4.20 - Initialize term to the result of the Term Selection algorithm, passing var, containers, type/language, and preferred values.
                var term = activeContext.SelectTerm(iri, containers, typeLanguage, preferredValues);
                if (term != null)
                {
                    return term;
                }
            }

            // 5 - At this point, there is no simple term that var can be compacted to. If vocab is true and active context has a vocabulary mapping: 
            if (vocab && !string.IsNullOrEmpty(activeContext.Vocab))
            {
                if (iri.StartsWith(activeContext.Vocab) && iri.Length > activeContext.Vocab.Length)
                {
                    var suffix = iri.Substring(activeContext.Vocab.Length);
                    if (!activeContext.TryGetTerm(suffix, out _)) return suffix;
                }
            }

            // 6 - The var could not be compacted using the active context's vocabulary mapping.
            // Try to create a compact IRI, starting by initializing compact IRI to null. This variable will be used to store the created compact IRI, if any.
            string compactIri = null;
            // 7 - For each term definition definition in active context:
            foreach (var definitionKey in activeContext.Terms)
            {
                var termDefinition = activeContext.GetTerm(definitionKey);
                // 7.1 - If the IRI mapping of definition is null, its IRI mapping equals var, its IRI mapping is not a substring at the beginning of var, or definition does not have a true prefix flag, definition's key cannot be used as a prefix. Continue with the next definition.
                if (termDefinition.IriMapping == null ||
                    termDefinition.IriMapping.Equals(iri) ||
                    !iri.StartsWith(termDefinition.IriMapping) ||
                    !termDefinition.Prefix) continue;
                // 7.2 - Initialize candidate by concatenating definition key, a colon(:), and the substring of var that follows after the value of the definition's IRI mapping.
                var candidate = definitionKey + ":" + iri.Substring(termDefinition.IriMapping.Length);
                // 7.1 - If either compact IRI is null, candidate is shorter or the same length but lexicographically less than compact IRI and candidate does not have a term definition in active context, or if that term definition has an IRI mapping that equals var and value is null, set compact IRI to candidate.
                if (!activeContext.HasTerm(candidate) && (compactIri == null || candidate.Length < compactIri.Length ||
                                                          string.Compare(candidate, compactIri, StringComparison.Ordinal) < 0))
                {
                    compactIri = candidate;
                }
                else if (activeContext.HasTerm(candidate))
                {
                    var candidateTermDef = activeContext.GetTerm(candidate);
                    if (candidateTermDef.IriMapping.Equals(iri) && value == null)
                    {
                        compactIri = candidate;
                    }
                }
            }

            // 8 - If compact IRI is not null, return compact IRI.
            if (compactIri != null)
            {
                return compactIri;
            }

            // 9 - To ensure that the IRI var is not confused with a compact IRI, if the IRI scheme of var matches any term in active context with prefix flag set to true, and var has no IRI authority (preceded by double-forward-slash (//), an IRI confused with prefix error has been detected, and processing is aborted.
            var ix = iri.IndexOf(':');
            if (ix > 0 && iri.IndexOf("://", StringComparison.Ordinal) != ix)
            {
                var scheme = iri.Substring(0, ix);
                if (activeContext.TryGetTerm(scheme, out var td) && td.Prefix)
                {
                    throw new JsonLdProcessorException(JsonLdErrorCode.IriConfusedWithPrefix,
                        $"IRI confused with prefix. The {iri} has a scheme that is confusable with a term in the JSON-LD context and no authority to disabmiguate it from a JSON-LD term.");
                }
            }

            // 10 - If vocab is false, transform var to a relative IRI reference using the base IRI from active context, if it exists.
            if (!vocab && activeContext.Base != null)
            {
                if (iri.StartsWith("_:"))
                {
                    // Just return a blank node identifier unchanged
                    return iri;
                }
                var parsedIri = new Uri(iri);
                var relativeIri = activeContext.Base.MakeRelativeUri(parsedIri);
                // KA: If IRI is equivalent to base IRI just return last path segment rather than an empty string
                if (string.Empty.Equals(relativeIri.ToString()))
                {
                    var lastSlashIx = parsedIri.PathAndQuery.LastIndexOf('/');
                    return parsedIri.PathAndQuery.Substring(lastSlashIx + 1);
                }
                return relativeIri.ToString();
            }

            // 11 - Finally, return var as is.
            return iri;
        }


        

        private JToken CompactValue(JsonLdContext activeContext, string activeProperty, JObject value)
        {
            var activeTermDefinition = activeProperty == null ? null : activeContext.GetTerm(activeProperty);

            // 1 - Initialize result to a copy of value.
            var result = value.DeepClone();

            // 2 - If the active context has a null inverse context, set inverse context in active context to the result of calling the
            // Inverse Context Creation algorithm using active context.
            // 3 - Initialize inverse context to the value of inverse context in active context.
            // var inverseContext = activeContext.InverseContext; -- Not used?


            // 4 - Initialize language to the language mapping for active property in active context, if any, otherwise to the default language of active context.
            // 5 - Initialize direction to the direction mapping for active property in active context, if any, otherwise to the default base direction of active context.
            var languageMapping = activeContext.Language;
            var direction = activeContext.BaseDirection;
            if (activeTermDefinition != null)
            {
                if (activeTermDefinition.HasLanguageMapping) languageMapping = activeTermDefinition.LanguageMapping;
                if (activeTermDefinition.DirectionMapping.HasValue) direction = activeTermDefinition.DirectionMapping;
            }

            var activeTermDefinitionTypeMapping = activeTermDefinition?.TypeMapping ?? null;
            var valueHasType = value.ContainsKey("@type");
            var valueType = valueHasType && value["@type"].Type == JTokenType.String ? value["@type"].Value<string>() : null;

            // 6 - If value has an @id entry and has no other entries other than @index:
            if (value.ContainsKey("@id") &&
                value.Properties().All(p => p.Name.Equals("@id") || p.Name.Equals("@index")))
            {
                var typeMapping = activeTermDefinition?.TypeMapping;
                if (typeMapping != null)
                {
                    // 6.1 - If the type mapping of active property is set to @id, set result to the result of IRI compacting the value associated with the @id entry using false for vocab.
                    // 6.2 - Otherwise, if the type mapping of active property is set to @vocab, set result to the result of IRI compacting the value associated with the @id entry.
                    if (typeMapping.Equals("@id") || typeMapping.Equals("@vocab"))
                    {
                        result = CompactIri(activeContext, value["@id"].Value<string>(),
                            vocab: typeMapping.Equals("@vocab"));
                    }
                }
            }
            // 7 - Otherwise, if value has an @type entry whose value matches the type mapping of active property, set result to the value associated with the @value entry of value.
            else if (valueType != null && valueType.Equals(activeTermDefinitionTypeMapping))
            {
                result = value["@value"];
            }
            // 8 - Otherwise, if the type mapping of active property is @none, or value has an @type entry, and the value of @type in value does not match the type mapping of active property, leave value as is, as value compaction is disabled.
            else if ("@none".Equals(activeTermDefinitionTypeMapping) ||
                     valueHasType && (valueType == null || valueType != activeTermDefinitionTypeMapping))
            {
                // 8.1 - Replace any value of @type in result with the result of IRI compacting the value of the @type entry.
                if (result is JObject resultObject && resultObject.ContainsKey("@type"))
                {
                    var typeValue = resultObject["@type"];
                    if (typeValue is JArray typeArray)
                    {
                        var newArray = new JArray();
                        foreach (var item in typeArray)
                        {
                            newArray.Add(CompactIri(activeContext, item.Value<string>(), vocab: true));
                        }

                        resultObject["@type"] = newArray;
                    }
                    else
                    {
                        resultObject["@type"] = CompactIri(activeContext, typeValue.Value<string>(), vocab: true);
                    }
                }
            }
            // 9 - Otherwise, if the value of the @value entry is not a string:
            else if (value.ContainsKey("@value") && value["@value"].Type != JTokenType.String)
            {
                // 9.1 - If value has an @index entry, and the container mapping associated to active property includes @index, or if value has no @index entry, set result to the value associated with the @value entry.
                if ((value.ContainsKey("@index") && activeTermDefinition != null &&
                     activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.Index)) ||
                    (!value.ContainsKey("@index")))
                {
                    result = value["@value"];
                }
            }
            // 10 - Otherwise, if value has an @language entry whose value exactly matches language, using a case-insensitive comparison if it is not null, or is not present, if language is null, and the value has an @direction entry whose value exactly matches direction, if it is not null, or is not present, if direction is null:
            else if (SafeEquals(languageMapping, value.ContainsKey("@language") ? value["@language"] : null, StringComparison.OrdinalIgnoreCase) &&
                     SafeEquals(direction.HasValue ? JsonLdUtils.SerializeLanguageDirection(direction.Value) : null,
                         value.ContainsKey("@direction") ? value["@direction"] : null, StringComparison.OrdinalIgnoreCase))
            {
                // 10.1 - If value has an @index entry, and the container mapping associated to active property includes @index, or value has no @index entry, set result to the value associated with the @value entry.
                if ((value.ContainsKey("@index") && activeTermDefinition != null &&
                     activeTermDefinition.ContainerMapping.Contains(JsonLdContainer.Index)) ||
                    (!value.ContainsKey("@index")))
                {
                    result = value["@value"];
                }
            }
            // 11 - If result is a map, replace each key in result with the result of IRI compacting that key.
            if (result is JObject r)
            {
                foreach (var p in r.Properties().ToList())
                {
                    var compactKey = CompactIri(activeContext, p.Name, vocab: true);
                    if (!compactKey.Equals(p.Name))
                    {
                        r.Remove(p.Name);
                        r.Add(new JProperty(compactKey, p.Value));
                    }
                }
            }
            // 12 - Return result
            return result;
        }

        /// <summary>
        /// Compare a possibly null string and a possibly null JToken for equality.
        /// </summary>
        /// <remarks>If <paramref name="str"/> is null, return true if <paramref name="t"/> is null and false if it is not null.
        /// If <paramref name="str"/> is not null, return true if <paramref name="t"/> is a non-null token of type string and the string value of <paramref name="t"/>
        /// matches the value of <paramref name="str"/> using the comparison method specified by the <paramref name="comparisonOptions"/> parameter.</remarks>
        /// <param name="str"></param>
        /// <param name="t"></param>
        /// <param name="comparisonOptions"></param>
        /// <returns></returns>
        private static bool SafeEquals(string str, JToken t, StringComparison comparisonOptions)
        {
            if (str == null)
            {
                return t == null || t.Type == JTokenType.Null;
            }

            return t != null && t.Type == JTokenType.String && t.Value<string>().Equals(str, comparisonOptions);
        }

        

        /// <summary>
        /// Ensure that a JObject has an entry for a given property, initializing it to an empty map if it does not exist.
        /// </summary>
        /// <param name="parent"></param>
        /// <param name="property"></param>
        /// <returns></returns>
        private static JObject EnsureMapEntry(JObject parent, string property)
        {
            if (!parent.ContainsKey(property))
            {
                parent[property] = new JObject();
            }
            return parent[property] as JObject;
        }


    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(521,57): error CS0136: A local or parameter named 'expandedItemObject' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(580,74): error CS0165: Use of unassigned local variable 'expandedItemObject',D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(663,26): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(665,56): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(775,42): error CS0128: A local variable or function named 'valueObject' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(814,29): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(814,71): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(816,33): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(819,38): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(820,38): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(824,60): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(831,34): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(831,75): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(833,49): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(838,34): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(840,49): error CS0103: The name 'valueObject' does not exist in the current context,D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(724,73): error CS0165: Use of unassigned local variable 'itemObject',D:\a\1\s\Libraries\dotNetRDF\JsonLd\Processors\CompactProcessor.cs(775,57): error CS0165: Use of unassigned local variable 'valueObject'
######################################################################


######################################################################
Nr: 2 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Libraries\dotNetRDF\Parsing\RdfAParserBase.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using VDS.RDF.Parsing.Contexts;
using VDS.RDF.Parsing.Handlers;
using VDS.RDF.Query;

namespace VDS.RDF.Parsing
{
    /// <summary>
    /// Base class for the framework-specific RDFa parser implementations.
    /// </summary>
    /// <typeparam name="THtmlDocument"></typeparam>
    /// <typeparam name="TElement"></typeparam>
    /// <typeparam name="TNode"></typeparam>
    /// <typeparam name="TAttribute"></typeparam>
    public abstract class RdfAParserBase<THtmlDocument, TElement, TNode, TAttribute> : IRdfReader
        where TElement : class, TNode
    {
        /// <summary>
        /// XHTML Vocab Namespace.
        /// </summary>
        public const string XHtmlVocabNamespace = "http://www.w3.org/1999/xhtml/vocab#";
        /// <summary>
        /// URI for the XHTML+RDFa DTD.
        /// </summary>
        public const string XHtmlPlusRdfADoctype = "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd";
        /// <summary>
        /// Namespace URI for XHTML.
        /// </summary>
        public const string XHtmlNamespace = "http://www.w3.org/1999/xhtml#";
        /// <summary>
        /// Namespace URI for RDFa.
        /// </summary>
        public const string RdfANamespace = "http://www.w3.org/ns/rdfa#";

        /// <summary>
        /// RDFa Version Constants.
        /// </summary>
        public const string XHtmlPlusRdfA11Version = "XHTML+RDFa 1.1",
                             HtmlPlusRdfA11Version = "HTML+RDFa 1.1",
                             XHtmlPlusRdfA10Version = "XHTML+RDFa 1.0",
                             HtmlPlusRdfA10Version = "HTML+RDFa 1.0";

        private readonly RdfASyntax _syntax = RdfASyntax.AutoDetectLegacy;

        /// <summary>
        /// Creates a new RDFa Parser which will auto-detect which RDFa version to use (assumes 1.1 if none explicitly specified).
        /// </summary>
        protected RdfAParserBase()
        {

        }

        /// <summary>
        /// Creates a new RDFa Parser which will use the specified RDFa syntax.
        /// </summary>
        /// <param name="syntax">RDFa Syntax Version.</param>
        protected RdfAParserBase(RdfASyntax syntax)
        {
            _syntax = syntax;
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given input.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="input">Stream to read from.</param>
        public void Load(IGraph g, StreamReader input)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            Load(new GraphHandler(g), input);
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given input.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="input">Input to read from.</param>
        public void Load(IGraph g, TextReader input)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            Load(new GraphHandler(g), input);
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given file.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="filename">File to read from.</param>
        public void Load(IGraph g, string filename)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            if (filename == null) throw new RdfParseException("Cannot read RDF from a null File");
            Load(new GraphHandler(g), filename);
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given input.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="input">Stream to read from.</param>
        public void Load(IRdfHandler handler, StreamReader input)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (input == null) throw new RdfParseException("Cannot read RDF from a null Stream");
            Load(handler, (TextReader)input);
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given input.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="input">Input to read from.</param>
        public void Load(IRdfHandler handler, TextReader input)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (input == null) throw new RdfParseException("Cannot read RDF from a null TextReader");

            try
            {
                var doc = LoadAndParse(input);

                var context = new RdfAParserContext<THtmlDocument>(handler, doc);
                Parse(context);
            }
            finally
            {
                try
                {
                    input.Close();
                }
                catch
                {
                    // Catch is just here in case something goes wrong with closing the stream
                    // This error can be ignored
                }
            }
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given input.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="filename">File to read from.</param>
        public void Load(IRdfHandler handler, string filename)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (filename == null) throw new RdfParseException("Cannot read RDF from a null File");
            Load(handler, File.OpenText(filename));
        }

        /// <summary>
        /// Parse the input stream as an HTML document.
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        protected abstract THtmlDocument LoadAndParse(TextReader input);

        /// <summary>
        /// Determine if an element has a particular attribute.
        /// </summary>
        /// <param name="element">The element to check.</param>
        /// <param name="attributeName">The name of the attribute to check for.</param>
        /// <returns>True if the element has an attribute named <paramref name="attributeName"/>, false otherwise.</returns>
        protected abstract bool HasAttribute(TElement element, string attributeName);

        /// <summary>
        /// Get the value of a particular attribute of an element.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <param name="attributeName">The name of the attribute on the element.</param>
        /// <returns>The value of the attribute.</returns>
        protected abstract string GetAttribute(TElement element, string attributeName);

        /// <summary>
        /// Set the value of a particular attribute of an element.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <param name="attributeName">The name of the attribute to set/update.</param>
        /// <param name="value">The new value for the attribute.</param>
        protected abstract void SetAttribute(TElement element, string attributeName, string value);

        /// <summary>
        /// Get the base element of the specified document.
        /// </summary>
        /// <param name="document"></param>
        /// <returns></returns>
        protected abstract TElement GetBaseElement(THtmlDocument document);

        /// <summary>
        /// Deterine if the HTML document can have an xml:base element.
        /// </summary>
        /// <param name="document"></param>
        /// <returns></returns>
        protected abstract bool IsXmlBaseIsPermissible(THtmlDocument document);

        /// <summary>
        /// Get the html element of the document.
        /// </summary>
        /// <param name="document"></param>
        /// <returns></returns>
        protected abstract TElement GetHtmlElement(THtmlDocument document);

        /// <summary>
        /// Process the content of an HTML document.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="evalContext"></param>
        protected abstract void ProcessDocument(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext);

        /// <summary>
        /// Get all attributes of an element.
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected abstract IEnumerable<TAttribute> GetAttributes(TElement element);

        /// <summary>
        /// Get the name of an attribute.
        /// </summary>
        /// <param name="attribute"></param>
        /// <returns></returns>
        protected abstract string GetAttributeName(TAttribute attribute);

        /// <summary>
        /// Get the value of an attribute.
        /// </summary>
        /// <param name="attribute"></param>
        /// <returns></returns>
        protected abstract string GetAttributeValue(TAttribute attribute);

        /// <summary>
        /// Get the name of an element.
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected abstract string GetElementName(TElement element);

        /// <summary>
        /// Return the children of an element (in order).
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected abstract IEnumerable<TNode> GetChildren(TElement element);

        /// <summary>
        /// Get the inner text of an element or a text node.
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        protected abstract string GetInnerText(TNode node);

        /// <summary>
        /// Get the HTML contained within an element as a string.
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected abstract string GetInnerHtml(TElement element);

        /// <summary>
        /// Determine if an element has children.
        /// </summary>
        /// <param name="element"></param>
        /// <returns>True if the element has children, false otherwise.</returns>
        protected abstract bool HasChildren(TElement element);

        /// <summary>
        /// Determine if a node in the parsed Html document tree is a text node.
        /// </summary>
        /// <param name="node"></param>
        /// <returns>True if <paramref name="node"/> is a text node, false otherwise.</returns>
        protected abstract bool IsTextNode(TNode node);

        private void Parse(RdfAParserContext<THtmlDocument> context)
        {
            try
            {
                context.Handler.StartRdf();

                // Setup the basic evaluation context and start processing
                var evalContext = new RdfAEvaluationContext(context.BaseUri);
                evalContext.NamespaceMap.AddNamespace(string.Empty, UriFactory.Create(XHtmlVocabNamespace));

                // Set the Default and Local Vocabularly
                context.DefaultVocabulary = new XHtmlRdfAVocabulary();
                evalContext.LocalVocabulary = new TermMappings();

                // If there's a base element this permanently changes the Base URI
                var baseEl = GetBaseElement(context.Document);
                if (baseEl != null)
                {
                    var uri = GetAttribute(baseEl, "href");
                    if (!string.IsNullOrEmpty(uri))
                    {
                        if (uri.Contains("?"))
                        {
                            evalContext.BaseUri = UriFactory.Create(uri.Substring(0, uri.IndexOf('?')));
                        }
                        else if (uri.Contains("#"))
                        {
                            evalContext.BaseUri = UriFactory.Create(uri.Substring(0, uri.IndexOf('#')));
                        }
                        else
                        {
                            evalContext.BaseUri = UriFactory.Create(GetAttribute(baseEl, "href"));
                        }
                    }
                }

                // Check whether xml:base is permissible
                context.XmlBaseAllowed = IsXmlBaseIsPermissible(context.Document);

                // Select the Syntax Version to use
                context.Syntax = _syntax;
                if (context.Syntax == RdfASyntax.AutoDetect || context.Syntax == RdfASyntax.AutoDetectLegacy)
                {
                    var docNode = GetHtmlElement(context.Document);
                    if (docNode != null && HasAttribute(docNode, "version"))
                    {
                        var version = GetAttribute(docNode, "version");
                        switch (version)
                        {
                            case XHtmlPlusRdfA10Version:
                            case HtmlPlusRdfA10Version:
                                context.Syntax = RdfASyntax.RDFa_1_0;
                                break;
                            case XHtmlPlusRdfA11Version:
                            case HtmlPlusRdfA11Version:
                                context.Syntax = RdfASyntax.RDFa_1_1;
                                break;
                            default:
                                if (context.Syntax == RdfASyntax.AutoDetect)
                                {
                                    context.Syntax = RdfASyntax.RDFa_1_1;
                                    OnWarning("The value '" + version + "' is not a known value for the @version attribute - assuming RDFa 1.1");
                                }
                                else
                                {
                                    context.Syntax = RdfASyntax.RDFa_1_0;
                                    OnWarning("The value '" + version + "' is not a known value for the @version attribute - assuming RDFa 1.0");
                                }
                                break;
                        }
                    }
                    else if (context.Syntax == RdfASyntax.AutoDetect)
                    {
                        context.Syntax = RdfASyntax.RDFa_1_1;
                        OnWarning("No @version attribute on document node - assuming RDFa 1.1");
                    }
                    else if (context.Syntax == RdfASyntax.AutoDetectLegacy)
                    {
                        context.Syntax = RdfASyntax.RDFa_1_0;
                        OnWarning("No @version attribute on document node - assuming RDFa 1.0");
                    }
                    else
                    {
                        context.Syntax = RdfASyntax.RDFa_1_1;
                        OnWarning("No @version attribute on document node - assuming RDFa 1.1");
                    }
                }

                ProcessDocument(context, evalContext);

                context.Handler.EndRdf(true);
            }
            catch (RdfParsingTerminatedException)
            {
                context.Handler.EndRdf(true);
                // Discard this - it justs means the Handler told us to stop
            }
            catch
            {
                context.Handler.EndRdf(false);
                throw;
            }
        }

        /// <summary>
        /// Process the content of an element of the document.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="evalContext"></param>
        /// <param name="currElement"></param>
        protected void ProcessElement(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, TElement currElement)
        {
            bool recurse = true, skip = false;
            bool rel = false,
                 rev = false,
                 about = false,
                 src = false,
                 href = false,
                 property = false,
                 type = false,
                 resource = false,
                 content = false,
                 datatype = false;
            var noDefaultNamespace = false;

            INode newSubj = null, currObj = null;
            var incomplete = new List<IncompleteTriple>();
            var inScopePrefixes = new List<string>();
            Dictionary<string, Uri> hiddenPrefixes = null;
            var lang = evalContext.Language;
            var oldBase = evalContext.BaseUri;
            var baseChanged = false;
            var oldLang = lang;
            var langChanged = false;
            var baseUri = (evalContext.BaseUri == null) ? string.Empty : evalContext.BaseUri.AbsoluteUri;

#region Steps 2-5 of the RDFa Processing Rules

            // Locate namespaces and other relevant attributes
            foreach (var attr in GetAttributes(currElement))
            {
                string uri;
                if (GetAttributeName(attr).StartsWith("xmlns:"))
                {
                    uri = Tools.ResolveUri(GetAttributeValue(attr), baseUri);
                    if (!(uri.EndsWith("/") || uri.EndsWith("#"))) uri += "#";
                    var prefix = GetAttributeName(attr).Substring(GetAttributeName(attr).IndexOf(':') + 1);
                    if (evalContext.NamespaceMap.HasNamespace(prefix))
                    {
                        if (hiddenPrefixes == null) hiddenPrefixes = new Dictionary<string, Uri>();
                        hiddenPrefixes.Add(prefix, evalContext.NamespaceMap.GetNamespaceUri(prefix));
                    }
                    evalContext.NamespaceMap.AddNamespace(prefix, UriFactory.Create(uri));
                    inScopePrefixes.Add(prefix);
                }
                else
                {
                    switch (GetAttributeName(attr))
                    {
                        case "xml:lang":
                        case "lang":
                            // @lang and @xml:lang have the same affect
                            if (!langChanged)
                            {
                                oldLang = lang;
                                lang = GetAttributeValue(attr);
                                langChanged = true;
                            }
                            break;
                        case "xml:base":
                            // @xml:base may be permitted in some cases
                            if (context.XmlBaseAllowed)
                            {
                                baseUri = Tools.ResolveUri(GetAttributeValue(attr), baseUri);
                                if (!(baseUri.EndsWith("/") || baseUri.EndsWith("#"))) baseUri += "#";
                                oldBase = evalContext.BaseUri;
                                baseChanged = true;
                                evalContext.BaseUri = UriFactory.Create(baseUri);
                            }
                            break;
                        case "xmlns":
                            // Can use @xmlns to override the default namespace
                            uri = GetAttributeValue(attr);
                            if (!(uri.EndsWith("/") || uri.EndsWith("#"))) uri += "#";
                            if (evalContext.NamespaceMap.HasNamespace(string.Empty))
                            {
                                if (hiddenPrefixes == null) hiddenPrefixes = new Dictionary<string, Uri>();
                                hiddenPrefixes.Add(string.Empty, evalContext.NamespaceMap.GetNamespaceUri(string.Empty));
                            }
                            evalContext.NamespaceMap.AddNamespace(string.Empty, UriFactory.Create(uri));
                            inScopePrefixes.Add(string.Empty);
                            noDefaultNamespace = true;
                            break;
                        case "prefix":
                            // Can use @prefix to set multiple namespaces with one attribute
                            if (context.Syntax == RdfASyntax.RDFa_1_0)
                            {
                                OnWarning("Cannot use the @prefix attribute to define prefixes in RDFa 1.0");
                            }
                            else
                            {
                                ParsePrefixAttribute(context, evalContext, attr, baseUri, hiddenPrefixes, inScopePrefixes);
                            }
                            break;
                        case "rel":
                            rel = true;
                            break;
                        case "rev":
                            rev = true;
                            break;
                        case "about":
                            about = true;
                            break;
                        case "src":
                            src = true;
                            break;
                        case "href":
                            href = true;
                            break;
                        case "resource":
                            resource = true;
                            break;
                        case "typeof":
                            type = true;
                            break;
                        case "content":
                            content = true;
                            break;
                        case "datatype":
                            datatype = true;
                            break;
                        case "property":
                            property = true;
                            break;
                        case "profile":
                            if (context.Syntax == RdfASyntax.RDFa_1_0)
                            {
                                OnWarning("Cannot use the @profile attribute in RDFa 1.0");
                            }
                            else
                            {
                                if (ParseProfileAttribute(context, evalContext, attr))
                                {
                                    foreach (var ns in evalContext.LocalVocabulary.Namespaces)
                                    {
                                        uri = Tools.ResolveUri(ns.Value, baseUri);
                                        if (!(uri.EndsWith("/") || uri.EndsWith("#"))) uri += "#";
                                        if (evalContext.NamespaceMap.HasNamespace(ns.Key))
                                        {
                                            if (hiddenPrefixes == null) hiddenPrefixes = new Dictionary<string, Uri>();
                                            hiddenPrefixes.Add(ns.Key, evalContext.NamespaceMap.GetNamespaceUri(ns.Key));
                                        }
                                        evalContext.NamespaceMap.AddNamespace(ns.Key, UriFactory.Create(uri));
                                        inScopePrefixes.Add(ns.Key);
                                    }
                                }
                                else
                                {
                                    OnWarning("Unable to resolve a Profile document specified by the @profile attribute on the element <" + GetElementName(currElement) + "> - ignoring the DOM subtree of this element");
                                    return;
                                }
                            }
                            break;
                        case "vocab":
                            if (context.Syntax == RdfASyntax.RDFa_1_0)
                            {
                                OnWarning("Cannot use the @vocab attribute in RDFa 1.0");
                            }
                            else
                            {
                                ParseVocabAttribute(context, evalContext, attr);
                            }
                            break;
                    }
                }
            }

#endregion

#region Steps 6-7 of the RDFa Processing Rules

            // If we hit an invalid CURIE/URI at any point then ResolveUriOrCurie will return a null and 
            // later processing steps will be skipped for this element
            // Calls to Tools.ResolveUri which error will still cause the parser to halt
            if (!rel && !rev)
            {
                // No @rel or @rev attributes
                if (about && !GetAttribute(currElement, "about").Equals("[]"))
                {
                    // New Subject is the URI
                    newSubj = ResolveUriOrCurie(context, evalContext, GetAttribute(currElement, "about"));
                }
                else if (src)
                {
                    // New Subject is the URI
                    newSubj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(GetAttribute(currElement, "src"), baseUri)));
                }
                else if (resource && !GetAttribute(currElement, "resource").Equals("[]"))
                {
                    // New Subject is the URI
                    newSubj = ResolveUriOrCurie(context, evalContext, GetAttribute(currElement, "resource"));
                }
                else if (href)
                {
                    // New Subject is the URI
                    newSubj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(GetAttribute(currElement, "href"), baseUri)));
                }
                else if (GetElementName(currElement).Equals("head") || GetElementName(currElement).Equals("body"))
                {
                    // New Subject is the Base URI
                    try
                    {
                        newSubj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(string.Empty, baseUri)));
                    }
                    catch (RdfException)
                    {
                        if (baseUri.Equals(string.Empty))
                        {
                            OnWarning("Unable to generate a valid Subject for a Triple since the Base URI should be used but there is no in-scope Base URI");
                            newSubj = null;
                        }
                        else
                        {
                            throw;
                        }
                    }
                }
                else if (type)
                {
                    // New Subject is a Blank Node
                    newSubj = context.Handler.CreateBlankNode();
                }
                else if (evalContext.ParentObject != null)
                {
                    // New Subject is the Parent Object and will skip if no property attributes
                    newSubj = evalContext.ParentObject;
                    if (!property) skip = true;
                }
            }
            else
            {
                // A @rel or @rev attribute was encountered

                // For this we first set the Subject
                if (about && !GetAttribute(currElement, "about").Equals("[]"))
                {
                    // New Subject is the URI
                    newSubj = ResolveUriOrCurie(context, evalContext, GetAttribute(currElement, "about"));
                }
                else if (src)
                {
                    // New Subject is the URI
                    newSubj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(GetAttribute(currElement, "src"), baseUri)));
                }
                else if (GetElementName(currElement).Equals("head") || GetElementName(currElement).Equals("body"))
                {
                    // New Subject is the Base URI
                    try
                    {
                        newSubj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(string.Empty, baseUri)));
                    }
                    catch (RdfException)
                    {
                        if (baseUri.Equals(string.Empty))
                        {
                            OnWarning("Unable to generate a valid Subject for a Triple since the Base URI should be used but there is no in-scope Base URI");
                            newSubj = null;
                        }
                        else
                        {
                            throw;
                        }
                    }
                }
                else if (type)
                {
                    // New Subject is a Blank Node
                    newSubj = context.Handler.CreateBlankNode();
                }
                else if (evalContext.ParentObject != null)
                {
                    // New Subject is the Parent Object and will skip if no property attributes
                    newSubj = evalContext.ParentObject;
                }

                // Then we set the Object as well
                if (resource && !GetAttribute(currElement, "resource").Equals("[]"))
                {
                    // New Object is the URI
                    currObj = ResolveUriOrCurie(context, evalContext, GetAttribute(currElement, "resource"));
                }
                else if (href)
                {
                    // New Object is the URI
                    currObj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(GetAttribute(currElement, "href"), baseUri)));
                }
            }

#endregion

#region Step 8 of the RDFa Processing Rules

            // If the Subject is not a null then we'll generate type triples if there's any @typeof attributes
            if (newSubj != null)
            {
                INode rdfType = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType));
                if (type)
                {
                    foreach (var dtObj in ParseComplexAttribute(context, evalContext, GetAttribute(currElement, "typeof")))
                    {
                        if (!context.Handler.HandleTriple(new Triple(newSubj, rdfType, dtObj))) ParserHelper.Stop();
                    }
                }
            }

#endregion

#region Steps 9-10 of the RDFa Processing Rules

            // If the Object is not null we'll generate triples
            if (newSubj != null && currObj != null)
            {
                // We can generate some complete triples
                if (rel)
                {
                    foreach (var pred in ParseComplexAttribute(context, evalContext, GetAttribute(currElement, "rel")))
                    {
                        if (!context.Handler.HandleTriple(new Triple(newSubj, pred, currObj))) ParserHelper.Stop();
                    }
                }
                if (rev)
                {
                    foreach (var pred in ParseComplexAttribute(context, evalContext, GetAttribute(currElement, "rev")))
                    {
                        if (!context.Handler.HandleTriple(new Triple(currObj, pred, newSubj))) ParserHelper.Stop();
                    }
                }
            }
            else
            {
                // We can generate some incomplete triples
                var preds = false;
                if (rel)
                {
                    foreach (var pred in ParseComplexAttribute(context, evalContext, GetAttribute(currElement, "rel")))
                    {
                        preds = true;
                        incomplete.Add(new IncompleteTriple(pred, IncompleteTripleDirection.Forward));
                    }
                }
                if (rev)
                {
                    foreach (var pred in ParseComplexAttribute(context, evalContext, GetAttribute(currElement, "rev")))
                    {
                        preds = true;
                        incomplete.Add(new IncompleteTriple(pred, IncompleteTripleDirection.Reverse));
                    }
                }

                if (preds)
                {
                    // Current Object becomes a Blank Node only if there were predicates
                    currObj = context.Handler.CreateBlankNode();
                }
            }

#endregion

#region Step 11 of the RDFa Processing Rules

            // Get the Current Object Literal
            if (newSubj != null && property)
            {
                // We only look for this if there is a property attribute
                INode currLiteral = null;
                Uri dt;
                INode dtNode = null;

                if (datatype && !GetAttribute(currElement, "datatype").Equals(string.Empty))
                {
                    // Some kind of Typed Literal
                    // Resolve the Datatype attribute into URIs
                    try
                    {
                        dtNode = ResolveTermOrCurieOrUri(context, evalContext, GetAttribute(currElement, "datatype"));
                    }
                    catch (RdfException)
                    {
                        OnWarning("Unable to resolve a valid Datatype for the Literal since the value '" + GetAttribute(currElement, "datatype") + "' is not a valid CURIE or it cannot be resolved into a URI given the in-scope namespace prefixes and Base URI - assuming a Plain Literal instead");
                    }
                }
                if (dtNode != null)
                {
                    // We can only process this Triple if we were able to get a valid URI Node for the Datatype
                    if (dtNode.NodeType != NodeType.Uri) throw new RdfParseException("Cannot use a non-URI Node as a Dataype");
                    dt = ((IUriNode)dtNode).Uri;

                    if (!dt.AbsoluteUri.Equals(RdfSpecsHelper.RdfXmlLiteral))
                    {
                        // There's a Datatype and it's not XML Literal
                        if (content)
                        {
                            // Content attribute is used as the value
                            currLiteral = context.Handler.CreateLiteralNode(GetAttribute(currElement, "content"), dt);
                        }
                        else
                        {
                            // Value is concatentation of child text nodes
                            var lit = new StringBuilder();
                            foreach (var n in GetChildren(currElement))
                            {
                                GrabText(lit, n);
                            }
                            currLiteral = context.Handler.CreateLiteralNode(HttpUtility.HtmlDecode(lit.ToString()), dt);
                        }
                    }
                    else if (context.Syntax == RdfASyntax.RDFa_1_0)
                    {
                        // It's an XML Literal - this is now RDFa 1.0 Only
                        // This is an incompatability with RDFa 1.1
                        foreach (var child in GetChildren(currElement).OfType<TElement>().Where(c=>!IsTextNode(c)))
                        {
                            ProcessXmlLiteral(evalContext, child, noDefaultNamespace);
                        }
                        currLiteral = context.Handler.CreateLiteralNode(GetInnerHtml(currElement), dt);
                    }
                    else if (context.Syntax == RdfASyntax.RDFa_1_1)
                    {
                        // For RDFa 1.1 we now treat as a plain literal instead
                        // Setting this to null forces us to go into the if that processes plain literals
                        dtNode = null;
                    }
                }

                if (dtNode == null)
                {
                    // A Plain Literal
                    if (content)
                    {
                        // Content attribute is used as the value
                        currLiteral = context.Handler.CreateLiteralNode(GetAttribute(currElement, "content"), lang);
                    }
                    else if (!HasChildren(currElement))
                    {
                        // Value is content of the element (if any)
                        currLiteral = context.Handler.CreateLiteralNode(HttpUtility.HtmlDecode(GetInnerText(currElement)), lang);
                    }
                    else if (GetChildren(currElement).All(IsTextNode))
                    {
                        // Value is concatenation of all Text Child Nodes
                        var lit = new StringBuilder();
                        foreach (var n in GetChildren(currElement).Where(IsTextNode))
                        {
                            lit.Append(GetInnerText(n));
                        }
                        currLiteral = context.Handler.CreateLiteralNode(HttpUtility.HtmlDecode(lit.ToString()), lang);
                    }
                    else if (!datatype || (datatype && GetAttribute(currElement, "datatype").Equals(string.Empty)))
                    {
                        // Value is an XML Literal
                        foreach (var child in GetChildren(currElement).OfType<TElement>().Where(c=>!IsTextNode(c)))
                        {
                            ProcessXmlLiteral(evalContext, child, noDefaultNamespace);
                        }
                        currLiteral = context.Handler.CreateLiteralNode(GetInnerHtml(currElement), UriFactory.Create(RdfSpecsHelper.RdfXmlLiteral));
                    }
                }

                // Get the Properties which we are connecting this literal with
                if (currLiteral != null)
                {
                    foreach (var pred in ParseAttribute(context, evalContext, GetAttribute(currElement, "property")))
                    {
                        if (!context.Handler.HandleTriple(new Triple(newSubj, pred, currLiteral))) ParserHelper.Stop();
                    }
                }
            }

#endregion

#region Step 12 of the RDFa Processing Rules

            // Complete incomplete Triples if this is possible
            if (!skip && newSubj != null && evalContext.ParentSubject != null)
            {
                foreach (var i in evalContext.IncompleteTriples)
                {
                    if (i.Direction == IncompleteTripleDirection.Forward)
                    {
                        if (!context.Handler.HandleTriple(new Triple(evalContext.ParentSubject, i.Predicate, newSubj))) ParserHelper.Stop();
                    }
                    else
                    {
                        if (!context.Handler.HandleTriple(new Triple(newSubj, i.Predicate, evalContext.ParentSubject))) ParserHelper.Stop();
                    }
                }
            }

#endregion

#region Step 13 of the RDFa Processing Rules

            // Recurse if necessary
            if (recurse)
            {
                if (HasChildren(currElement))
                {
                    // Generate the new Evaluation Context (if applicable)
                    RdfAEvaluationContext newEvalContext;
                    if (skip)
                    {
                        newEvalContext = evalContext;
                        newEvalContext.Language = lang;
                    }
                    else
                    {
                        var newBase = (baseUri.Equals(string.Empty)) ? null : UriFactory.Create(baseUri);
                        newEvalContext = new RdfAEvaluationContext(newBase, evalContext.NamespaceMap);
                        // Set the Parent Subject for the new Context
                        if (newSubj != null)
                        {
                            newEvalContext.ParentSubject = newSubj;
                        }
                        else
                        {
                            newEvalContext.ParentSubject = evalContext.ParentSubject;
                        }
                        // Set the Parent Object for the new Context
                        if (currObj != null)
                        {
                            newEvalContext.ParentObject = currObj;
                        }
                        else if (newSubj != null)
                        {
                            newEvalContext.ParentObject = newSubj;
                        }
                        else
                        {
                            newEvalContext.ParentObject = evalContext.ParentSubject;
                        }
                        newEvalContext.IncompleteTriples.AddRange(incomplete);
                        newEvalContext.Language = lang;
                    }

                    newEvalContext.LocalVocabulary = new TermMappings(evalContext.LocalVocabulary);

                    // Iterate over the Nodes
                    foreach (var element in GetChildren(currElement).OfType<TElement>())
                    {
                        ProcessElement(context, newEvalContext, element);
                    }
                }
            }

#endregion

            // Now any in-scope prefixes go out of scope
            foreach (var prefix in inScopePrefixes)
            {
                evalContext.NamespaceMap.RemoveNamespace(prefix);
                // If they were hiding another prefix then that comes back into scope
                if (hiddenPrefixes != null)
                {
                    if (hiddenPrefixes.ContainsKey(prefix))
                    {
                        evalContext.NamespaceMap.AddNamespace(prefix, hiddenPrefixes[prefix]);
                    }
                }
            }

            // And the Base URI resets if it was changed
            if (baseChanged)
            {
                evalContext.BaseUri = oldBase;
            }

            // And the Language resets if it was changed
            if (langChanged)
            {
                evalContext.Language = oldLang;
            }
        }

        /// <summary>
        /// Resolves a CURIE to a Node.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evalContext">Evaluation Context.</param>
        /// <param name="curie">CURIE.</param>
        /// <returns></returns>
        private INode ResolveCurie(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string curie)
        {
            if (curie.StartsWith("_:"))
            {
                // The CURIE is for a Blank Node
                if (curie.Equals("_:"))
                {
                    return context.Handler.CreateBlankNode("_");
                }
                else
                {
                    return context.Handler.CreateBlankNode(curie.Substring(2));
                }
            }
            else
            {
                // CURIE is for a URI
                if (context.Syntax == RdfASyntax.RDFa_1_0)
                {
                    // RDFa 1.0
                    if (curie.StartsWith(":"))
                    {
                        return context.Handler.CreateUriNode(UriFactory.Create(XHtmlVocabNamespace + curie.Substring(1)));
                    }
                    else if (curie.Contains(":"))
                    {
                        return context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveQName(curie, evalContext.NamespaceMap, evalContext.BaseUri)));
                    }
                    else
                    {
                        throw new RdfParseException("The value '" + curie + "' is not valid as a CURIE as it does not have a prefix");
                    }
                }
                else
                {
                    // RDFa 1.1
                    return context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveQName(curie, evalContext.NamespaceMap, evalContext.BaseUri)));
                }
            }
        }

        /// <summary>
        /// Resolves an Attribute which may be a CURIE/URI to a Node.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evalContext">Evaluation Context.</param>
        /// <param name="uriref">URI/CURIE.</param>
        /// <returns></returns>
        private INode ResolveUriOrCurie(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string uriref)
        {
            try
            {
                if (uriref.StartsWith("["))
                {
                    // CURIE
                    var curie = uriref.Substring(1, uriref.Length - 2);
                    return ResolveCurie(context, evalContext, curie);
                }
                else if (IsCurie(evalContext, uriref))
                {
                    // CURIE
                    return ResolveCurie(context, evalContext, uriref);
                }
                else
                {
                    // URI
                    return context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(uriref, evalContext.BaseUri.ToSafeString())));
                }
            }
            catch (RdfException)
            {
                OnWarning("Unable to resolve a URI or CURIE since the value '" + uriref + "' does not contain a valid URI/CURIE or it cannot be resolved to a URI given the in-scope namespace prefixes and Base URI");
                return null;
            }
        }

        /// <summary>
        /// Resolves an Attribute which may be a Term/CURIE/URI to a Node where one/more of the values may be special values permissible in a complex attribute.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evalContext">Evaluation Context.</param>
        /// <param name="curie">URI/CURIE/Term.</param>
        /// <returns></returns>
        private INode ResolveTermOrCurie(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string curie)
        {
            if (context.Syntax == RdfASyntax.RDFa_1_0)
            {
                // RDFa 1.0
                var vocab = new XHtmlRdfAVocabulary();
                if (curie.StartsWith(":"))
                {
                    return context.Handler.CreateUriNode(UriFactory.Create(vocab.ResolveTerm(curie.Substring(1))));
                }
                else if (curie.Contains(":"))
                {
                    return ResolveCurie(context, evalContext, curie);
                }
                else
                {
                    if (vocab.HasTerm(curie))
                    {
                        return context.Handler.CreateUriNode(UriFactory.Create(vocab.ResolveTerm(curie)));
                    }
                    else
                    {
                        throw new RdfParseException("Cannot use an unprefixed CURIE in RDFa 1.0 - only reserved XHTML terms are permitted");
                    }
                }
            }
            else
            {
                // RDFa 1.1
                if (curie.StartsWith(":"))
                {
                    if (evalContext.LocalVocabulary != null)
                    {
                        if (evalContext.LocalVocabulary.HasTerm(curie.Substring(1)) || !evalContext.LocalVocabulary.VocabularyUri.Equals(string.Empty))
                        {
                            return context.Handler.CreateUriNode(UriFactory.Create(evalContext.LocalVocabulary.ResolveTerm(curie.Substring(1))));
                        }
                        else if (context.DefaultVocabulary != null && context.DefaultVocabulary.HasTerm(curie.Substring(1)))
                        {
                            return context.Handler.CreateUriNode(UriFactory.Create(context.DefaultVocabulary.ResolveTerm(curie.Substring(1))));
                        }
                        else
                        {
                            return ResolveCurie(context, evalContext, curie);
                        }
                    }
                    else if (context.DefaultVocabulary != null && context.DefaultVocabulary.HasTerm(curie.Substring(1)))
                    {
                        return context.Handler.CreateUriNode(UriFactory.Create(context.DefaultVocabulary.ResolveTerm(curie.Substring(1))));
                    }
                    else
                    {
                        return ResolveCurie(context, evalContext, curie);
                    }
                }
                else
                {
                    if (evalContext.LocalVocabulary != null)
                    {
                        if (evalContext.LocalVocabulary.HasTerm(curie) || !evalContext.LocalVocabulary.VocabularyUri.Equals(string.Empty))
                        {
                            return context.Handler.CreateUriNode(UriFactory.Create(evalContext.LocalVocabulary.ResolveTerm(curie)));
                        }
                        else if (context.DefaultVocabulary != null && context.DefaultVocabulary.HasTerm(curie))
                        {
                            return context.Handler.CreateUriNode(UriFactory.Create(context.DefaultVocabulary.ResolveTerm(curie)));
                        }
                        else
                        {
                            throw new RdfParseException("Unable to resolve a Term since there is no appropriate Local/Default Vocabulary in scope");
                        }
                    }
                    else if (context.DefaultVocabulary != null)
                    {
                        return context.Handler.CreateUriNode(UriFactory.Create(context.DefaultVocabulary.ResolveTerm(curie)));
                    }
                    else
                    {
                        throw new RdfParseException("Unable to resolve a Term since there is no appropriate Local/Default Vocabularly in scope");
                    }
                }
            }
        }

        private INode ResolveTermOrCurieOrUri(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string value)
        {
            if (IsTerm(value))
            {
                return ResolveTermOrCurie(context, evalContext, value);
            }
            else if (IsCurie(evalContext, value))
            {
                return ResolveCurie(context, evalContext, value);
            }
            else
            {
                return context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(value, evalContext.BaseUri.ToSafeString())));
            }
        }

        /// <summary>
        /// Parses an complex attribute into a number of Nodes.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evalContext">Evaluation Context.</param>
        /// <param name="value">Attribute Value.</param>
        /// <returns></returns>
        /// <remarks>
        /// A complex attribute is any attribute which accepts multiple URIs, CURIEs or Terms.
        /// </remarks>
        private List<INode> ParseComplexAttribute(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string value)
        {
            var nodes = new List<INode>();

            string[] values;
            if (value.Contains(" "))
            {
                values = value.Split(' ');
            }
            else
            {
                values = new string[] { value };
            }
            foreach (var val in values)
            {
                try
                {
                    var n = ResolveTermOrCurieOrUri(context, evalContext, val);
                    nodes.Add(n);
                }
                catch
                {
                    // Errors are ignored, they don't produce a URI
                    // Raise a warning anyway
                    OnWarning("Ignoring the value '" + val + "' since this is not a valid Term/CURIE/URI or it cannot be resolved into a URI given the in-scope Namespace Prefixes and Base URI");
                }
            }

            return nodes;
        }

        /// <summary>
        /// Parses an attribute into a number of Nodes from the CURIEs contained in the Attribute.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evalContext">Evaluation Context.</param>
        /// <param name="value">Attribute Value.</param>
        /// <returns></returns>
        private List<INode> ParseAttribute(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string value)
        {
            var nodes = new List<INode>();

            string[] values;
            if (value.Contains(" "))
            {
                values = value.Split(' ');
            }
            else
            {
                values = new string[] { value };
            }
            foreach (var val in values)
            {
                try
                {
                    var n = ResolveCurie(context, evalContext, val);
                    nodes.Add(n);
                }
                catch
                {
                    // Errors are ignored, they don't produce a URI
                    // Raise a warning anyway
                    OnWarning("Ignoring the value '" + val + "' since this is not a valid CURIE or it cannot be resolved into a URI given the in-scope Namespace Prefixes and Base URI");
                }
            }

            return nodes;
        }

        private void ParsePrefixAttribute(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, TAttribute attr, string baseUri, Dictionary<string, Uri> hiddenPrefixes, List<string> inScopePrefixes)
        {
            // Do nothing if the @prefix attribute is empty
            if (GetAttributeValue(attr).Equals(string.Empty)) return;

            var reader = new StringReader(GetAttributeValue(attr));
            char next;
            var canExit = false;

            do
            {
                var prefixData = new StringBuilder();
                var uriData = new StringBuilder();

                // Grab a Prefix - characters up to the next colon
                next = (char)reader.Peek();
                while (next != ':')
                {
                    // Add the Character and discard it
                    prefixData.Append(next);
                    reader.Read();
                    if (reader.Peek() == -1)
                    {
                        OnWarning("Aborted parsing a prefix attribute since failed to find a prefix of the form prefix: from the following content: " + prefixData.ToString());
                        return;
                    }
                    else
                    {
                        next = (char)reader.Peek();
                    }
                }

                // Discard the colon
                reader.Read();

                // Discard the whitespace
                next = (char)reader.Peek();
                while (char.IsWhiteSpace(next))
                {
                    reader.Read();
                    if (reader.Peek() == -1)
                    {
                        OnWarning("Aborted parsing a prefix attribute since reached the end of the attribute without finding a URI to go with the prefix '" + prefixData.ToString() + ":'");
                        return;
                    }
                    else
                    {
                        next = (char)reader.Peek();
                    }
                }

                // Grab the URI - characters up to the next whitespace or end of string
                next = (char)reader.Peek();
                while (!char.IsWhiteSpace(next))
                {
                    uriData.Append(next);
                    reader.Read();
                    if (reader.Peek() == -1)
                    {
                        // End of string so will exit after this
                        canExit = true;
                        break;
                    }
                    else
                    {
                        next = (char)reader.Peek();
                    }
                }

                // Now resolve the URI and apply it
                var uri = Tools.ResolveUri(uriData.ToString(), baseUri);
                if (!(uri.EndsWith("/") || uri.EndsWith("#"))) uri += "#";
                var prefix = prefixData.ToString();
                if (evalContext.NamespaceMap.HasNamespace(prefix))
                {
                    if (hiddenPrefixes == null) hiddenPrefixes = new Dictionary<string, Uri>();
                    hiddenPrefixes.Add(prefix, UriFactory.Create(uri));
                }
                evalContext.NamespaceMap.AddNamespace(prefix, UriFactory.Create(uri));
                inScopePrefixes.Add(prefix);
            } while (!canExit);
        }

        private bool ParseProfileAttribute(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, TAttribute attr)
        {
            string[] profiles;
            if (GetAttributeValue(attr).Contains(" "))
            {
                profiles = GetAttributeValue(attr).Split(' ');
            }
            else
            {
                profiles = new string[] { GetAttributeValue(attr) };
            }

            var prefixQuery = "PREFIX rdfa: <" + RdfANamespace + "> SELECT SAMPLE(?prefix) AS ?NamespacePrefix SAMPLE(?uri) AS ?NamespaceURI WHERE { ?s rdfa:prefix ?prefix ; rdfa:uri ?uri } GROUP BY ?s HAVING (COUNT(?prefix) = 1 && COUNT(?uri) = 1)";
            var termQuery = "PREFIX rdfa: <" + RdfANamespace + "> SELECT SAMPLE(?term) AS ?Term SAMPLE(?uri) AS ?URI WHERE {?s rdfa:term ?term ; rdfa:uri ?uri } GROUP BY ?s HAVING (COUNT(?term) = 1 && COUNT(?uri) = 1)";

            foreach (var profile in profiles)
            {
                try
                {
                    var g = new Graph();

                    if (profile.Equals(XHtmlVocabNamespace) || profile.Equals(XHtmlVocabNamespace.Substring(0, XHtmlVocabNamespace.Length - 1)))
                    {
                        // XHTML Vocabulary is a fixed vocabulary
                        evalContext.LocalVocabulary.Merge(new XHtmlRdfAVocabulary());
                    }
                    else
                    {
                        try
                        {
                            UriLoader.Load(g, UriFactory.Create(profile));
                        }
                        catch
                        {
                            // If we fail then we return false which indicates that the DOM subtree is ignored
                            OnWarning("Unable to retrieve a Profile document which the library could parse from the URI '" + profile + "'");
                            return false;
                        }

                        // Namespace Mappings
                        var results = g.ExecuteQuery(prefixQuery);
                        if (results is SparqlResultSet)
                        {
                            var rset = (SparqlResultSet)results;
                            foreach (var r in rset.Results)
                            {
                                var prefixNode = r["NamespacePrefix"];
                                var nsNode = r["NamespaceURI"];
                                if (prefixNode.NodeType == NodeType.Literal && nsNode.NodeType == NodeType.Literal)
                                {
                                    var prefix = ((ILiteralNode)prefixNode).Value.ToLower();
                                    var ns = ((ILiteralNode)nsNode).Value;
                                    evalContext.LocalVocabulary.AddNamespace(prefix, ns);
                                }
                            }
                        }

                        // Term Mappings
                        results = g.ExecuteQuery(termQuery);
                        if (results is SparqlResultSet)
                        {
                            var rset = (SparqlResultSet)results;
                            foreach (var r in rset.Results)
                            {
                                var termNode = r["Term"];
                                var uriNode = r["URI"];
                                if (termNode.NodeType == NodeType.Literal && uriNode.NodeType == NodeType.Literal)
                                {
                                    var term = ((ILiteralNode)termNode).Value;
                                    var uri = ((ILiteralNode)uriNode).Value;
                                    evalContext.LocalVocabulary.AddTerm(term, uri);
                                }
                            }
                        }
                    }
                }
                catch
                {
                    // Ignore errors and continue processing
                    OnWarning("Ignoring the value '" + profile + "' since this is not a valid URI or a profile document was not successfully retrieved and parsed from this URI");
                    return false;
                }
            }

            return true;
        }

        private void ParseVocabAttribute(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, TAttribute attr)
        {
            if (GetAttributeValue(attr).Equals(string.Empty))
            {
                // Reset Local Vocabulary
                evalContext.LocalVocabulary = new TermMappings(context.DefaultVocabulary);
            }
            else
            {
                evalContext.LocalVocabulary.VocabularyUri = GetAttributeValue(attr);
            }
        }

        /// <summary>
        /// Get the text content of a node and add it to the provided output buffer.
        /// </summary>
        /// <param name="output"></param>
        /// <param name="node"></param>
        protected abstract void GrabText(StringBuilder output, TNode node);

        private void ProcessXmlLiteral(RdfAEvaluationContext evalContext, TElement n, bool noDefaultNamespace)
        {
            // Add Default Namespace as XHTML Namespace unless this would override an existing namespace
            if (!HasAttribute(n, "xmlns"))
            {
                if (!noDefaultNamespace) SetAttribute(n, "xmlns", XHtmlNamespace);
            }
            else
            {
                noDefaultNamespace = true;
            }

            // Add specific namespaces if necessary
            if (GetElementName(n).Contains(":"))
            {
                var prefix = GetElementName(n).Substring(0, GetElementName(n).IndexOf(':'));
                if (HasAttribute(n, "xmlns:" + prefix))
                {
                    // If the Node itself declares the Namespace then we don't need to do anything
                }
                else if (evalContext.NamespaceMap.HasNamespace(prefix))
                {
                    // If the Node doesn't declare the Namespace
                    SetAttribute(n, "xmlns:" + prefix, evalContext.NamespaceMap.GetNamespaceUri(prefix).AbsoluteUri);
                }
                else
                {
                    throw new RdfParseException("Malformed XML Literal - the undefined namespace prefix '" + prefix + "' is used");
                }
            }
            // Add Language (but don't override existing language)
            if (!evalContext.Language.Equals(string.Empty))
            {
                if (!HasAttribute(n, "xml:lang"))
                {
                    SetAttribute(n, "xml:lang", evalContext.Language);
                }
            }

            // Recurse on any child nodes
            foreach (var child in GetChildren(n).OfType<TElement>().Where(c=>!IsTextNode(c)))
            {
                ProcessXmlLiteral(evalContext, child, noDefaultNamespace);
            }
        }

        private bool IsTerm(string value)
        {
            return XmlSpecsHelper.IsNCName(value);
        }

        private bool IsCurie(RdfAEvaluationContext evalContext, string value)
        {
            if (value.StartsWith(":"))
            {
                var reference = value.Substring(1);
                return evalContext.NamespaceMap.HasNamespace(string.Empty) && IriSpecsHelper.IsIrelativeRef(value);
            }
            else if (value.Contains(':'))
            {
                var prefix = value.Substring(0, value.IndexOf(':'));
                var reference = value.Substring(value.IndexOf(':') + 1);
                return (XmlSpecsHelper.IsNCName(prefix) || prefix.Equals("_")) && evalContext.NamespaceMap.HasNamespace(prefix) && IriSpecsHelper.IsIrelativeRef(reference);
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Internal Helper for raising the Warning Event.
        /// </summary>
        /// <param name="message">Warning Message.</param>
        private void OnWarning(string message)
        {
            Warning?.Invoke(message);
        }

        /// <summary>
        /// Event which is raised when there is a non-fatal error with the input being read
        /// </summary>
        public event RdfReaderWarning Warning;
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using VDS.RDF.Parsing.Contexts;
using VDS.RDF.Parsing.Handlers;
using VDS.RDF.Query;

namespace VDS.RDF.Parsing
{
    /// <summary>
    /// Base class for the framework-specific RDFa parser implementations.
    /// </summary>
    /// <typeparam name="THtmlDocument"></typeparam>
    /// <typeparam name="TElement"></typeparam>
    /// <typeparam name="TNode"></typeparam>
    /// <typeparam name="TAttribute"></typeparam>
    public abstract class RdfAParserBase<THtmlDocument, TElement, TNode, TAttribute> : IRdfReader
        where TElement : class, TNode
    {
        /// <summary>
        /// XHTML Vocab Namespace.
        /// </summary>
        public const string XHtmlVocabNamespace = "http://www.w3.org/1999/xhtml/vocab#";
        /// <summary>
        /// URI for the XHTML+RDFa DTD.
        /// </summary>
        public const string XHtmlPlusRdfADoctype = "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd";
        /// <summary>
        /// Namespace URI for XHTML.
        /// </summary>
        public const string XHtmlNamespace = "http://www.w3.org/1999/xhtml#";
        /// <summary>
        /// Namespace URI for RDFa.
        /// </summary>
        public const string RdfANamespace = "http://www.w3.org/ns/rdfa#";

        /// <summary>
        /// RDFa Version Constants.
        /// </summary>
        public const string XHtmlPlusRdfA11Version = "XHTML+RDFa 1.1",
                             HtmlPlusRdfA11Version = "HTML+RDFa 1.1",
                             XHtmlPlusRdfA10Version = "XHTML+RDFa 1.0",
                             HtmlPlusRdfA10Version = "HTML+RDFa 1.0";

        private readonly RdfASyntax _syntax = RdfASyntax.AutoDetectLegacy;

        /// <summary>
        /// Creates a new RDFa Parser which will auto-detect which RDFa version to use (assumes 1.1 if none explicitly specified).
        /// </summary>
        protected RdfAParserBase()
        {

        }

        /// <summary>
        /// Creates a new RDFa Parser which will use the specified RDFa syntax.
        /// </summary>
        /// <param name="syntax">RDFa Syntax Version.</param>
        protected RdfAParserBase(RdfASyntax syntax)
        {
            _syntax = syntax;
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given input.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="input">Stream to read from.</param>
        public void Load(IGraph g, StreamReader input)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            Load(new GraphHandler(g), input);
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given input.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="input">Input to read from.</param>
        public void Load(IGraph g, TextReader input)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            Load(new GraphHandler(g), input);
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given file.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="filename">File to read from.</param>
        public void Load(IGraph g, string filename)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            if (filename == null) throw new RdfParseException("Cannot read RDF from a null File");
            Load(new GraphHandler(g), filename);
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given input.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="input">Stream to read from.</param>
        public void Load(IRdfHandler handler, StreamReader input)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (input == null) throw new RdfParseException("Cannot read RDF from a null Stream");
            Load(handler, (TextReader)input);
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given input.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="input">Input to read from.</param>
        public void Load(IRdfHandler handler, TextReader input)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (input == null) throw new RdfParseException("Cannot read RDF from a null TextReader");

            try
            {
                var doc = LoadAndParse(input);

                var context = new RdfAParserContext<THtmlDocument>(handler, doc);
                Parse(context);
            }
            finally
            {
                try
                {
                    input.Close();
                }
                catch
                {
                    // Catch is just here in case something goes wrong with closing the stream
                    // This error can be ignored
                }
            }
        }

        /// <summary>
        /// Parses RDFa by extracting it from the HTML from the given input.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="filename">File to read from.</param>
        public void Load(IRdfHandler handler, string filename)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (filename == null) throw new RdfParseException("Cannot read RDF from a null File");
            Load(handler, File.OpenText(filename));
        }

        /// <summary>
        /// Parse the input stream as an HTML document.
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        protected abstract THtmlDocument LoadAndParse(TextReader input);

        /// <summary>
        /// Determine if an element has a particular attribute.
        /// </summary>
        /// <param name="element">The element to check.</param>
        /// <param name="attributeName">The name of the attribute to check for.</param>
        /// <returns>True if the element has an attribute named <paramref name="attributeName"/>, false otherwise.</returns>
        protected abstract bool HasAttribute(TElement element, string attributeName);

        /// <summary>
        /// Get the value of a particular attribute of an element.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <param name="attributeName">The name of the attribute on the element.</param>
        /// <returns>The value of the attribute.</returns>
        protected abstract string GetAttribute(TElement element, string attributeName);

        /// <summary>
        /// Set the value of a particular attribute of an element.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <param name="attributeName">The name of the attribute to set/update.</param>
        /// <param name="value">The new value for the attribute.</param>
        protected abstract void SetAttribute(TElement element, string attributeName, string value);

        /// <summary>
        /// Get the base element of the specified document.
        /// </summary>
        /// <param name="document"></param>
        /// <returns></returns>
        protected abstract TElement GetBaseElement(THtmlDocument document);

        /// <summary>
        /// Deterine if the HTML document can have an xml:base element.
        /// </summary>
        /// <param name="document"></param>
        /// <returns></returns>
        protected abstract bool IsXmlBaseIsPermissible(THtmlDocument document);

        /// <summary>
        /// Get the html element of the document.
        /// </summary>
        /// <param name="document"></param>
        /// <returns></returns>
        protected abstract TElement GetHtmlElement(THtmlDocument document);

        /// <summary>
        /// Process the content of an HTML document.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="evalContext"></param>
        protected abstract void ProcessDocument(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext);

        /// <summary>
        /// Get all attributes of an element.
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected abstract IEnumerable<TAttribute> GetAttributes(TElement element);

        /// <summary>
        /// Get the name of an attribute.
        /// </summary>
        /// <param name="attribute"></param>
        /// <returns></returns>
        protected abstract string GetAttributeName(TAttribute attribute);

        /// <summary>
        /// Get the value of an attribute.
        /// </summary>
        /// <param name="attribute"></param>
        /// <returns></returns>
        protected abstract string GetAttributeValue(TAttribute attribute);

        /// <summary>
        /// Get the name of an element.
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected abstract string GetElementName(TElement element);

        /// <summary>
        /// Return the children of an element (in order).
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected abstract IEnumerable<TNode> GetChildren(TElement element);

        /// <summary>
        /// Get the inner text of an element or a text node.
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        protected abstract string GetInnerText(TNode node);

        /// <summary>
        /// Get the HTML contained within an element as a string.
        /// </summary>
        /// <param name="element"></param>
        /// <returns></returns>
        protected abstract string GetInnerHtml(TElement element);

        /// <summary>
        /// Determine if an element has children.
        /// </summary>
        /// <param name="element"></param>
        /// <returns>True if the element has children, false otherwise.</returns>
        protected abstract bool HasChildren(TElement element);

        /// <summary>
        /// Determine if a node in the parsed Html document tree is a text node.
        /// </summary>
        /// <param name="node"></param>
        /// <returns>True if <paramref name="node"/> is a text node, false otherwise.</returns>
        protected abstract bool IsTextNode(TNode node);

        private void Parse(RdfAParserContext<THtmlDocument> context)
        {
            try
            {
                context.Handler.StartRdf();

                // Setup the basic evaluation context and start processing
                var evalContext = new RdfAEvaluationContext(context.BaseUri);
                evalContext.NamespaceMap.AddNamespace(string.Empty, UriFactory.Create(XHtmlVocabNamespace));

                // Set the Default and Local Vocabularly
                context.DefaultVocabulary = new XHtmlRdfAVocabulary();
                evalContext.LocalVocabulary = new TermMappings();

                // If there's a base element this permanently changes the Base URI
                var baseEl = GetBaseElement(context.Document);
                if (baseEl != null)
                {
                    var uri = GetAttribute(baseEl, "href");
                    if (!string.IsNullOrEmpty(uri))
                    {
                        if (uri.Contains("?"))
                        {
                            evalContext.BaseUri = UriFactory.Create(uri.Substring(0, uri.IndexOf('?')));
                        }
                        else if (uri.Contains("#"))
                        {
                            evalContext.BaseUri = UriFactory.Create(uri.Substring(0, uri.IndexOf('#')));
                        }
                        else
                        {
                            evalContext.BaseUri = UriFactory.Create(GetAttribute(baseEl, "href"));
                        }
                    }
                }

                // Check whether xml:base is permissible
                context.XmlBaseAllowed = IsXmlBaseIsPermissible(context.Document);

                // Select the Syntax Version to use
                context.Syntax = _syntax;
                if (context.Syntax == RdfASyntax.AutoDetect || context.Syntax == RdfASyntax.AutoDetectLegacy)
                {
                    var docNode = GetHtmlElement(context.Document);
                    if (docNode != null && HasAttribute(docNode, "version"))
                    {
                        var version = GetAttribute(docNode, "version");
                        switch (version)
                        {
                            case XHtmlPlusRdfA10Version:
                            case HtmlPlusRdfA10Version:
                                context.Syntax = RdfASyntax.RDFa_1_0;
                                break;
                            case XHtmlPlusRdfA11Version:
                            case HtmlPlusRdfA11Version:
                                context.Syntax = RdfASyntax.RDFa_1_1;
                                break;
                            default:
                                if (context.Syntax == RdfASyntax.AutoDetect)
                                {
                                    context.Syntax = RdfASyntax.RDFa_1_1;
                                    OnWarning("The value '" + version + "' is not a known value for the @version attribute - assuming RDFa 1.1");
                                }
                                else
                                {
                                    context.Syntax = RdfASyntax.RDFa_1_0;
                                    OnWarning("The value '" + version + "' is not a known value for the @version attribute - assuming RDFa 1.0");
                                }
                                break;
                        }
                    }
                    else if (context.Syntax == RdfASyntax.AutoDetect)
                    {
                        context.Syntax = RdfASyntax.RDFa_1_1;
                        OnWarning("No @version attribute on document node - assuming RDFa 1.1");
                    }
                    else if (context.Syntax == RdfASyntax.AutoDetectLegacy)
                    {
                        context.Syntax = RdfASyntax.RDFa_1_0;
                        OnWarning("No @version attribute on document node - assuming RDFa 1.0");
                    }
                    else
                    {
                        context.Syntax = RdfASyntax.RDFa_1_1;
                        OnWarning("No @version attribute on document node - assuming RDFa 1.1");
                    }
                }

                ProcessDocument(context, evalContext);

                context.Handler.EndRdf(true);
            }
            catch (RdfParsingTerminatedException)
            {
                context.Handler.EndRdf(true);
                // Discard this - it justs means the Handler told us to stop
            }
            catch
            {
                context.Handler.EndRdf(false);
                throw;
            }
        }

        /// <summary>
        /// Process the content of an element of the document.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="evalContext"></param>
        /// <param name="currElement"></param>
        protected void ProcessElement(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, TElement currElement)
        {
            bool recurse = true, skip = false;
            bool rel = false,
                 rev = false,
                 about = false,
                 src = false,
                 href = false,
                 property = false,
                 type = false,
                 resource = false,
                 content = false,
                 datatype = false;
            var noDefaultNamespace = false;

            INode newSubj = null, currObj = null;
            var incomplete = new List<IncompleteTriple>();
            var inScopePrefixes = new List<string>();
            Dictionary<string, Uri> hiddenPrefixes = null;
            var lang = evalContext.Language;
            var oldBase = evalContext.BaseUri;
            var baseChanged = false;
            var oldLang = lang;
            var langChanged = false;
            var baseUri = (evalContext.BaseUri == null) ? string.Empty : evalContext.BaseUri.AbsoluteUri;

#region Steps 2-5 of the RDFa Processing Rules

            // Locate namespaces and other relevant attributes
            foreach (var attr in GetAttributes(currElement))
            {
                string uri;
                if (GetAttributeName(attr).StartsWith("xmlns:"))
                {
                    uri = Tools.ResolveUri(GetAttributeValue(attr), baseUri);
                    if (!(uri.EndsWith("/") || uri.EndsWith("#"))) uri += "#";
                    var prefix = GetAttributeName(attr).Substring(GetAttributeName(attr).IndexOf(':') + 1);
                    if (evalContext.NamespaceMap.HasNamespace(prefix))
                    {
                        if (hiddenPrefixes == null) hiddenPrefixes = new Dictionary<string, Uri>();
                        hiddenPrefixes.Add(prefix, evalContext.NamespaceMap.GetNamespaceUri(prefix));
                    }
                    evalContext.NamespaceMap.AddNamespace(prefix, UriFactory.Create(uri));
                    inScopePrefixes.Add(prefix);
                }
                else
                {
                    switch (GetAttributeName(attr))
                    {
                        case "xml:lang":
                        case "lang":
                            // @lang and @xml:lang have the same affect
                            if (!langChanged)
                            {
                                oldLang = lang;
                                lang = GetAttributeValue(attr);
                                langChanged = true;
                            }
                            break;
                        case "xml:base":
                            // @xml:base may be permitted in some cases
                            if (context.XmlBaseAllowed)
                            {
                                baseUri = Tools.ResolveUri(GetAttributeValue(attr), baseUri);
                                if (!(baseUri.EndsWith("/") || baseUri.EndsWith("#"))) baseUri += "#";
                                oldBase = evalContext.BaseUri;
                                baseChanged = true;
                                evalContext.BaseUri = UriFactory.Create(baseUri);
                            }
                            break;
                        case "xmlns":
                            // Can use @xmlns to override the default namespace
                            uri = GetAttributeValue(attr);
                            if (!(uri.EndsWith("/") || uri.EndsWith("#"))) uri += "#";
                            if (evalContext.NamespaceMap.HasNamespace(string.Empty))
                            {
                                if (hiddenPrefixes == null) hiddenPrefixes = new Dictionary<string, Uri>();
                                hiddenPrefixes.Add(string.Empty, evalContext.NamespaceMap.GetNamespaceUri(string.Empty));
                            }
                            evalContext.NamespaceMap.AddNamespace(string.Empty, UriFactory.Create(uri));
                            inScopePrefixes.Add(string.Empty);
                            noDefaultNamespace = true;
                            break;
                        case "prefix":
                            // Can use @prefix to set multiple namespaces with one attribute
                            if (context.Syntax == RdfASyntax.RDFa_1_0)
                            {
                                OnWarning("Cannot use the @prefix attribute to define prefixes in RDFa 1.0");
                            }
                            else
                            {
                                ParsePrefixAttribute(context, evalContext, attr, baseUri, hiddenPrefixes, inScopePrefixes);
                            }
                            break;
                        case "rel":
                            rel = true;
                            break;
                        case "rev":
                            rev = true;
                            break;
                        case "about":
                            about = true;
                            break;
                        case "src":
                            src = true;
                            break;
                        case "href":
                            href = true;
                            break;
                        case "resource":
                            resource = true;
                            break;
                        case "typeof":
                            type = true;
                            break;
                        case "content":
                            content = true;
                            break;
                        case "datatype":
                            datatype = true;
                            break;
                        case "property":
                            property = true;
                            break;
                        case "profile":
                            if (context.Syntax == RdfASyntax.RDFa_1_0)
                            {
                                OnWarning("Cannot use the @profile attribute in RDFa 1.0");
                            }
                            else
                            {
                                if (ParseProfileAttribute(context, evalContext, attr))
                                {
                                    foreach (var ns in evalContext.LocalVocabulary.Namespaces)
                                    {
                                        uri = Tools.ResolveUri(ns.Value, baseUri);
                                        if (!(uri.EndsWith("/") || uri.EndsWith("#"))) uri += "#";
                                        if (evalContext.NamespaceMap.HasNamespace(ns.Key))
                                        {
                                            if (hiddenPrefixes == null) hiddenPrefixes = new Dictionary<string, Uri>();
                                            hiddenPrefixes.Add(ns.Key, evalContext.NamespaceMap.GetNamespaceUri(ns.Key));
                                        }
                                        evalContext.NamespaceMap.AddNamespace(ns.Key, UriFactory.Create(uri));
                                        inScopePrefixes.Add(ns.Key);
                                    }
                                }
                                else
                                {
                                    OnWarning("Unable to resolve a Profile document specified by the @profile attribute on the element <" + GetElementName(currElement) + "> - ignoring the DOM subtree of this element");
                                    return;
                                }
                            }
                            break;
                        case "vocab":
                            if (context.Syntax == RdfASyntax.RDFa_1_0)
                            {
                                OnWarning("Cannot use the @vocab attribute in RDFa 1.0");
                            }
                            else
                            {
                                ParseVocabAttribute(context, evalContext, attr);
                            }
                            break;
                    }
                }
            }

#endregion

#region Steps 6-7 of the RDFa Processing Rules

            // If we hit an invalid CURIE/URI at any point then ResolveUriOrCurie will return a null and 
            // later processing steps will be skipped for this element
            // Calls to Tools.ResolveUri which error will still cause the parser to halt
            if (!rel && !rev)
            {
                // No @rel or @rev attributes
                if (about && !GetAttribute(currElement, "about").Equals("[]"))
                {
                    // New Subject is the URI
                    newSubj = ResolveUriOrCurie(context, evalContext, GetAttribute(currElement, "about"));
                }
                else if (src)
                {
                    // New Subject is the URI
                    newSubj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(GetAttribute(currElement, "src"), baseUri)));
                }
                else if (resource && !GetAttribute(currElement, "resource").Equals("[]"))
                {
                    // New Subject is the URI
                    newSubj = ResolveUriOrCurie(context, evalContext, GetAttribute(currElement, "resource"));
                }
                else if (href)
                {
                    // New Subject is the URI
                    newSubj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(GetAttribute(currElement, "href"), baseUri)));
                }
                else if (GetElementName(currElement).Equals("head") || GetElementName(currElement).Equals("body"))
                {
                    // New Subject is the Base URI
                    try
                    {
                        newSubj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(string.Empty, baseUri)));
                    }
                    catch (RdfException)
                    {
                        if (baseUri.Equals(string.Empty))
                        {
                            OnWarning("Unable to generate a valid Subject for a Triple since the Base URI should be used but there is no in-scope Base URI");
                            newSubj = null;
                        }
                        else
                        {
                            throw;
                        }
                    }
                }
                else if (type)
                {
                    // New Subject is a Blank Node
                    newSubj = context.Handler.CreateBlankNode();
                }
                else if (evalContext.ParentObject != null)
                {
                    // New Subject is the Parent Object and will skip if no property attributes
                    newSubj = evalContext.ParentObject;
                    if (!property) skip = true;
                }
            }
            else
            {
                // A @rel or @rev attribute was encountered

                // For this we first set the Subject
                if (about && !GetAttribute(currElement, "about").Equals("[]"))
                {
                    // New Subject is the URI
                    newSubj = ResolveUriOrCurie(context, evalContext, GetAttribute(currElement, "about"));
                }
                else if (src)
                {
                    // New Subject is the URI
                    newSubj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(GetAttribute(currElement, "src"), baseUri)));
                }
                else if (GetElementName(currElement).Equals("head") || GetElementName(currElement).Equals("body"))
                {
                    // New Subject is the Base URI
                    try
                    {
                        newSubj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(string.Empty, baseUri)));
                    }
                    catch (RdfException)
                    {
                        if (baseUri.Equals(string.Empty))
                        {
                            OnWarning("Unable to generate a valid Subject for a Triple since the Base URI should be used but there is no in-scope Base URI");
                            newSubj = null;
                        }
                        else
                        {
                            throw;
                        }
                    }
                }
                else if (type)
                {
                    // New Subject is a Blank Node
                    newSubj = context.Handler.CreateBlankNode();
                }
                else if (evalContext.ParentObject != null)
                {
                    // New Subject is the Parent Object and will skip if no property attributes
                    newSubj = evalContext.ParentObject;
                }

                // Then we set the Object as well
                if (resource && !GetAttribute(currElement, "resource").Equals("[]"))
                {
                    // New Object is the URI
                    currObj = ResolveUriOrCurie(context, evalContext, GetAttribute(currElement, "resource"));
                }
                else if (href)
                {
                    // New Object is the URI
                    currObj = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(GetAttribute(currElement, "href"), baseUri)));
                }
            }

#endregion

#region Step 8 of the RDFa Processing Rules

            // If the Subject is not a null then we'll generate type triples if there's any @typeof attributes
            if (newSubj != null)
            {
                INode rdfType = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType));
                if (type)
                {
                    foreach (var dtObj in ParseComplexAttribute(context, evalContext, GetAttribute(currElement, "typeof")))
                    {
                        if (!context.Handler.HandleTriple(new Triple(newSubj, rdfType, dtObj))) ParserHelper.Stop();
                    }
                }
            }

#endregion

#region Steps 9-10 of the RDFa Processing Rules

            // If the Object is not null we'll generate triples
            if (newSubj != null && currObj != null)
            {
                // We can generate some complete triples
                if (rel)
                {
                    foreach (var pred in ParseComplexAttribute(context, evalContext, GetAttribute(currElement, "rel")))
                    {
                        if (!context.Handler.HandleTriple(new Triple(newSubj, pred, currObj))) ParserHelper.Stop();
                    }
                }
                if (rev)
                {
                    foreach (var pred in ParseComplexAttribute(context, evalContext, GetAttribute(currElement, "rev")))
                    {
                        if (!context.Handler.HandleTriple(new Triple(currObj, pred, newSubj))) ParserHelper.Stop();
                    }
                }
            }
            else
            {
                // We can generate some incomplete triples
                var preds = false;
                if (rel)
                {
                    foreach (var pred in ParseComplexAttribute(context, evalContext, GetAttribute(currElement, "rel")))
                    {
                        preds = true;
                        incomplete.Add(new IncompleteTriple(pred, IncompleteTripleDirection.Forward));
                    }
                }
                if (rev)
                {
                    foreach (var pred in ParseComplexAttribute(context, evalContext, GetAttribute(currElement, "rev")))
                    {
                        preds = true;
                        incomplete.Add(new IncompleteTriple(pred, IncompleteTripleDirection.Reverse));
                    }
                }

                if (preds)
                {
                    // Current Object becomes a Blank Node only if there were predicates
                    currObj = context.Handler.CreateBlankNode();
                }
            }

#endregion

#region Step 11 of the RDFa Processing Rules

            // Get the Current Object Literal
            if (newSubj != null && property)
            {
                // We only look for this if there is a property attribute
                INode currLiteral = null;
                Uri dt;
                INode dtNode = null;

                if (datatype && !GetAttribute(currElement, "datatype").Equals(string.Empty))
                {
                    // Some kind of Typed Literal
                    // Resolve the Datatype attribute into URIs
                    try
                    {
                        dtNode = ResolveTermOrCurieOrUri(context, evalContext, GetAttribute(currElement, "datatype"));
                    }
                    catch (RdfException)
                    {
                        OnWarning("Unable to resolve a valid Datatype for the Literal since the value '" + GetAttribute(currElement, "datatype") + "' is not a valid CURIE or it cannot be resolved into a URI given the in-scope namespace prefixes and Base URI - assuming a Plain Literal instead");
                    }
                }
                if (dtNode != null)
                {
                    // We can only process this Triple if we were able to get a valid URI Node for the Datatype
                    if (dtNode.NodeType != NodeType.Uri) throw new RdfParseException("Cannot use a non-URI Node as a Dataype");
                    dt = ((IUriNode)dtNode).Uri;

                    if (!dt.AbsoluteUri.Equals(RdfSpecsHelper.RdfXmlLiteral))
                    {
                        // There's a Datatype and it's not XML Literal
                        if (content)
                        {
                            // Content attribute is used as the value
                            currLiteral = context.Handler.CreateLiteralNode(GetAttribute(currElement, "content"), dt);
                        }
                        else
                        {
                            // Value is concatentation of child text nodes
                            var lit = new StringBuilder();
                            foreach (var n in GetChildren(currElement))
                            {
                                GrabText(lit, n);
                            }
                            currLiteral = context.Handler.CreateLiteralNode(HttpUtility.HtmlDecode(lit.ToString()), dt);
                        }
                    }
                    else if (context.Syntax == RdfASyntax.RDFa_1_0)
                    {
                        // It's an XML Literal - this is now RDFa 1.0 Only
                        // This is an incompatability with RDFa 1.1
                        foreach (var child in GetChildren(currElement).OfType<TElement>().Where(c=>!IsTextNode(c)))
                        {
                            ProcessXmlLiteral(evalContext, child, noDefaultNamespace);
                        }
                        currLiteral = context.Handler.CreateLiteralNode(GetInnerHtml(currElement), dt);
                    }
                    else if (context.Syntax == RdfASyntax.RDFa_1_1)
                    {
                        // For RDFa 1.1 we now treat as a plain literal instead
                        // Setting this to null forces us to go into the if that processes plain literals
                        dtNode = null;
                    }
                }

                if (dtNode == null)
                {
                    // A Plain Literal
                    if (content)
                    {
                        // Content attribute is used as the value
                        currLiteral = context.Handler.CreateLiteralNode(GetAttribute(currElement, "content"), lang);
                    }
                    else if (!HasChildren(currElement))
                    {
                        // Value is content of the element (if any)
                        currLiteral = context.Handler.CreateLiteralNode(HttpUtility.HtmlDecode(GetInnerText(currElement)), lang);
                    }
                    else if (GetChildren(currElement).All(IsTextNode))
                    {
                        // Value is concatenation of all Text Child Nodes
                        var lit = new StringBuilder();
                        foreach (var n in GetChildren(currElement).Where(IsTextNode))
                        {
                            lit.Append(GetInnerText(n));
                        }
                        currLiteral = context.Handler.CreateLiteralNode(HttpUtility.HtmlDecode(lit.ToString()), lang);
                    }
                    else if (!datatype || (datatype && GetAttribute(currElement, "datatype").Equals(string.Empty)))
                    {
                        // Value is an XML Literal
                        foreach (var child in GetChildren(currElement).OfType<TElement>().Where(c=>!IsTextNode(c)))
                        {
                            ProcessXmlLiteral(evalContext, child, noDefaultNamespace);
                        }
                        currLiteral = context.Handler.CreateLiteralNode(GetInnerHtml(currElement), UriFactory.Create(RdfSpecsHelper.RdfXmlLiteral));
                    }
                }

                // Get the Properties which we are connecting this literal with
                if (currLiteral != null)
                {
                    foreach (var pred in ParseAttribute(context, evalContext, GetAttribute(currElement, "property")))
                    {
                        if (!context.Handler.HandleTriple(new Triple(newSubj, pred, currLiteral))) ParserHelper.Stop();
                    }
                }
            }

#endregion

#region Step 12 of the RDFa Processing Rules

            // Complete incomplete Triples if this is possible
            if (!skip && newSubj != null && evalContext.ParentSubject != null)
            {
                foreach (var i in evalContext.IncompleteTriples)
                {
                    if (i.Direction == IncompleteTripleDirection.Forward)
                    {
                        if (!context.Handler.HandleTriple(new Triple(evalContext.ParentSubject, i.Predicate, newSubj))) ParserHelper.Stop();
                    }
                    else
                    {
                        if (!context.Handler.HandleTriple(new Triple(newSubj, i.Predicate, evalContext.ParentSubject))) ParserHelper.Stop();
                    }
                }
            }

#endregion

#region Step 13 of the RDFa Processing Rules

            // Recurse if necessary
            if (recurse)
            {
                if (HasChildren(currElement))
                {
                    // Generate the new Evaluation Context (if applicable)
                    RdfAEvaluationContext newEvalContext;
                    if (skip)
                    {
                        newEvalContext = evalContext;
                        newEvalContext.Language = lang;
                    }
                    else
                    {
                        var newBase = (baseUri.Equals(string.Empty)) ? null : UriFactory.Create(baseUri);
                        newEvalContext = new RdfAEvaluationContext(newBase, evalContext.NamespaceMap);
                        // Set the Parent Subject for the new Context
                        if (newSubj != null)
                        {
                            newEvalContext.ParentSubject = newSubj;
                        }
                        else
                        {
                            newEvalContext.ParentSubject = evalContext.ParentSubject;
                        }
                        // Set the Parent Object for the new Context
                        if (currObj != null)
                        {
                            newEvalContext.ParentObject = currObj;
                        }
                        else if (newSubj != null)
                        {
                            newEvalContext.ParentObject = newSubj;
                        }
                        else
                        {
                            newEvalContext.ParentObject = evalContext.ParentSubject;
                        }
                        newEvalContext.IncompleteTriples.AddRange(incomplete);
                        newEvalContext.Language = lang;
                    }

                    newEvalContext.LocalVocabulary = new TermMappings(evalContext.LocalVocabulary);

                    // Iterate over the Nodes
                    foreach (var element in GetChildren(currElement).OfType<TElement>())
                    {
                        ProcessElement(context, newEvalContext, element);
                    }
                }
            }

#endregion

            // Now any in-scope prefixes go out of scope
            foreach (var prefix in inScopePrefixes)
            {
                evalContext.NamespaceMap.RemoveNamespace(prefix);
                // If they were hiding another prefix then that comes back into scope
                if (hiddenPrefixes != null)
                {
                    if (hiddenPrefixes.ContainsKey(prefix))
                    {
                        evalContext.NamespaceMap.AddNamespace(prefix, hiddenPrefixes[prefix]);
                    }
                }
            }

            // And the Base URI resets if it was changed
            if (baseChanged)
            {
                evalContext.BaseUri = oldBase;
            }

            // And the Language resets if it was changed
            if (langChanged)
            {
                evalContext.Language = oldLang;
            }
        }

        /// <summary>
        /// Resolves a CURIE to a Node.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evalContext">Evaluation Context.</param>
        /// <param name="curie">CURIE.</param>
        /// <returns></returns>
        private INode ResolveCurie(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string curie)
        {
            if (curie.StartsWith("_:"))
            {
                // The CURIE is for a Blank Node
                if (curie.Equals("_:"))
                {
                    return context.Handler.CreateBlankNode("_");
                }
                else
                {
                    return context.Handler.CreateBlankNode(curie.Substring(2));
                }
            }
            else
            {
                // CURIE is for a URI
                if (context.Syntax == RdfASyntax.RDFa_1_0)
                {
                    // RDFa 1.0
                    if (curie.StartsWith(":"))
                    {
                        return context.Handler.CreateUriNode(UriFactory.Create(XHtmlVocabNamespace + curie.Substring(1)));
                    }
                    else if (curie.Contains(":"))
                    {
                        return context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveQName(curie, evalContext.NamespaceMap, evalContext.BaseUri)));
                    }
                    else
                    {
                        throw new RdfParseException("The value '" + curie + "' is not valid as a CURIE as it does not have a prefix");
                    }
                }
                else
                {
                    // RDFa 1.1
                    return context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveQName(curie, evalContext.NamespaceMap, evalContext.BaseUri)));
                }
            }
        }

        /// <summary>
        /// Resolves an Attribute which may be a CURIE/URI to a Node.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evalContext">Evaluation Context.</param>
        /// <param name="uriref">URI/CURIE.</param>
        /// <returns></returns>
        private INode ResolveUriOrCurie(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string uriref)
        {
            try
            {
                if (uriref.StartsWith("["))
                {
                    // CURIE
                    var curie = uriref.Substring(1, uriref.Length - 2);
                    return ResolveCurie(context, evalContext, curie);
                }
                else if (IsCurie(evalContext, uriref))
                {
                    // CURIE
                    return ResolveCurie(context, evalContext, uriref);
                }
                else
                {
                    // URI
                    return context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(uriref, evalContext.BaseUri.ToSafeString())));
                }
            }
            catch (RdfException)
            {
                OnWarning("Unable to resolve a URI or CURIE since the value '" + uriref + "' does not contain a valid URI/CURIE or it cannot be resolved to a URI given the in-scope namespace prefixes and Base URI");
                return null;
            }
        }

        /// <summary>
        /// Resolves an Attribute which may be a Term/CURIE/URI to a Node where one/more of the values may be special values permissible in a complex attribute.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evalContext">Evaluation Context.</param>
        /// <param name="curie">URI/CURIE/Term.</param>
        /// <returns></returns>
        private INode ResolveTermOrCurie(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string curie)
        {
            if (context.Syntax == RdfASyntax.RDFa_1_0)
            {
                // RDFa 1.0
                var vocab = new XHtmlRdfAVocabulary();
                if (curie.StartsWith(":"))
                {
                    return context.Handler.CreateUriNode(UriFactory.Create(vocab.ResolveTerm(curie.Substring(1))));
                }
                else if (curie.Contains(":"))
                {
                    return ResolveCurie(context, evalContext, curie);
                }
                else
                {
                    if (vocab.HasTerm(curie))
                    {
                        return context.Handler.CreateUriNode(UriFactory.Create(vocab.ResolveTerm(curie)));
                    }
                    else
                    {
                        throw new RdfParseException("Cannot use an unprefixed CURIE in RDFa 1.0 - only reserved XHTML terms are permitted");
                    }
                }
            }
            else
            {
                // RDFa 1.1
                if (curie.StartsWith(":"))
                {
                    if (evalContext.LocalVocabulary != null)
                    {
                        if (evalContext.LocalVocabulary.HasTerm(curie.Substring(1)) || !evalContext.LocalVocabulary.VocabularyUri.Equals(string.Empty))
                        {
                            return context.Handler.CreateUriNode(UriFactory.Create(evalContext.LocalVocabulary.ResolveTerm(curie.Substring(1))));
                        }
                        else if (context.DefaultVocabulary != null && context.DefaultVocabulary.HasTerm(curie.Substring(1)))
                        {
                            return context.Handler.CreateUriNode(UriFactory.Create(context.DefaultVocabulary.ResolveTerm(curie.Substring(1))));
                        }
                        else
                        {
                            return ResolveCurie(context, evalContext, curie);
                        }
                    }
                    else if (context.DefaultVocabulary != null && context.DefaultVocabulary.HasTerm(curie.Substring(1)))
                    {
                        return context.Handler.CreateUriNode(UriFactory.Create(context.DefaultVocabulary.ResolveTerm(curie.Substring(1))));
                    }
                    else
                    {
                        return ResolveCurie(context, evalContext, curie);
                    }
                }
                else
                {
                    if (evalContext.LocalVocabulary != null)
                    {
                        if (evalContext.LocalVocabulary.HasTerm(curie) || !evalContext.LocalVocabulary.VocabularyUri.Equals(string.Empty))
                        {
                            return context.Handler.CreateUriNode(UriFactory.Create(evalContext.LocalVocabulary.ResolveTerm(curie)));
                        }
                        else if (context.DefaultVocabulary != null && context.DefaultVocabulary.HasTerm(curie))
                        {
                            return context.Handler.CreateUriNode(UriFactory.Create(context.DefaultVocabulary.ResolveTerm(curie)));
                        }
                        else
                        {
                            throw new RdfParseException("Unable to resolve a Term since there is no appropriate Local/Default Vocabulary in scope");
                        }
                    }
                    else if (context.DefaultVocabulary != null)
                    {
                        return context.Handler.CreateUriNode(UriFactory.Create(context.DefaultVocabulary.ResolveTerm(curie)));
                    }
                    else
                    {
                        throw new RdfParseException("Unable to resolve a Term since there is no appropriate Local/Default Vocabularly in scope");
                    }
                }
            }
        }

        private INode ResolveTermOrCurieOrUri(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string value)
        {
            if (IsTerm(value))
            {
                return ResolveTermOrCurie(context, evalContext, value);
            }
            else if (IsCurie(evalContext, value))
            {
                return ResolveCurie(context, evalContext, value);
            }
            else
            {
                return context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(value, evalContext.BaseUri.ToSafeString())));
            }
        }

        /// <summary>
        /// Parses an complex attribute into a number of Nodes.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evalContext">Evaluation Context.</param>
        /// <param name="value">Attribute Value.</param>
        /// <returns></returns>
        /// <remarks>
        /// A complex attribute is any attribute which accepts multiple URIs, CURIEs or Terms.
        /// </remarks>
        private List<INode> ParseComplexAttribute(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string value)
        {
            var nodes = new List<INode>();

            string[] values;
            if (value.Contains(" "))
            {
                values = value.Split(' ');
            }
            else
            {
                values = new string[] { value };
            }
            foreach (var val in values)
            {
                try
                {
                    var n = ResolveTermOrCurieOrUri(context, evalContext, val);
                    nodes.Add(n);
                }
                catch
                {
                    // Errors are ignored, they don't produce a URI
                    // Raise a warning anyway
                    OnWarning("Ignoring the value '" + val + "' since this is not a valid Term/CURIE/URI or it cannot be resolved into a URI given the in-scope Namespace Prefixes and Base URI");
                }
            }

            return nodes;
        }

        /// <summary>
        /// Parses an attribute into a number of Nodes from the CURIEs contained in the Attribute.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evalContext">Evaluation Context.</param>
        /// <param name="value">Attribute Value.</param>
        /// <returns></returns>
        private List<INode> ParseAttribute(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, string value)
        {
            var nodes = new List<INode>();

            string[] values;
            if (value.Contains(" "))
            {
                values = value.Split(' ');
            }
            else
            {
                values = new string[] { value };
            }
            foreach (var val in values)
            {
                try
                {
                    var n = ResolveCurie(context, evalContext, val);
                    nodes.Add(n);
                }
                catch
                {
                    // Errors are ignored, they don't produce a URI
                    // Raise a warning anyway
                    OnWarning("Ignoring the value '" + val + "' since this is not a valid CURIE or it cannot be resolved into a URI given the in-scope Namespace Prefixes and Base URI");
                }
            }

            return nodes;
        }

        private void ParsePrefixAttribute(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, TAttribute attr, string baseUri, Dictionary<string, Uri> hiddenPrefixes, List<string> inScopePrefixes)
        {
            // Do nothing if the @prefix attribute is empty
            if (GetAttributeValue(attr).Equals(string.Empty)) return;

            var reader = new StringReader(GetAttributeValue(attr));
            char next;
            var canExit = false;

            do
            {
                var prefixData = new StringBuilder();
                var uriData = new StringBuilder();

                // Grab a Prefix - characters up to the next colon
                next = (char)reader.Peek();
                while (next != ':')
                {
                    // Add the Character and discard it
                    prefixData.Append(next);
                    reader.Read();
                    if (reader.Peek() == -1)
                    {
                        OnWarning("Aborted parsing a prefix attribute since failed to find a prefix of the form prefix: from the following content: " + prefixData.ToString());
                        return;
                    }
                    else
                    {
                        next = (char)reader.Peek();
                    }
                }

                // Discard the colon
                reader.Read();

                // Discard the whitespace
                next = (char)reader.Peek();
                while (char.IsWhiteSpace(next))
                {
                    reader.Read();
                    if (reader.Peek() == -1)
                    {
                        OnWarning("Aborted parsing a prefix attribute since reached the end of the attribute without finding a URI to go with the prefix '" + prefixData.ToString() + ":'");
                        return;
                    }
                    else
                    {
                        next = (char)reader.Peek();
                    }
                }

                // Grab the URI - characters up to the next whitespace or end of string
                next = (char)reader.Peek();
                while (!char.IsWhiteSpace(next))
                {
                    uriData.Append(next);
                    reader.Read();
                    if (reader.Peek() == -1)
                    {
                        // End of string so will exit after this
                        canExit = true;
                        break;
                    }
                    else
                    {
                        next = (char)reader.Peek();
                    }
                }

                // Now resolve the URI and apply it
                var uri = Tools.ResolveUri(uriData.ToString(), baseUri);
                if (!(uri.EndsWith("/") || uri.EndsWith("#"))) uri += "#";
                var prefix = prefixData.ToString();
                if (evalContext.NamespaceMap.HasNamespace(prefix))
                {
                    if (hiddenPrefixes == null) hiddenPrefixes = new Dictionary<string, Uri>();
                    hiddenPrefixes.Add(prefix, UriFactory.Create(uri));
                }
                evalContext.NamespaceMap.AddNamespace(prefix, UriFactory.Create(uri));
                inScopePrefixes.Add(prefix);
            } while (!canExit);
        }

        private bool ParseProfileAttribute(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, TAttribute attr)
        {
            string[] profiles;
            if (GetAttributeValue(attr).Contains(" "))
            {
                profiles = GetAttributeValue(attr).Split(' ');
            }
            else
            {
                profiles = new string[] { GetAttributeValue(attr) };
            }

            var prefixQuery = "PREFIX rdfa: <" + RdfANamespace + "> SELECT SAMPLE(?prefix) AS ?NamespacePrefix SAMPLE(?uri) AS ?NamespaceURI WHERE { ?s rdfa:prefix ?prefix ; rdfa:uri ?uri } GROUP BY ?s HAVING (COUNT(?prefix) = 1 && COUNT(?uri) = 1)";
            var termQuery = "PREFIX rdfa: <" + RdfANamespace + "> SELECT SAMPLE(?term) AS ?Term SAMPLE(?uri) AS ?URI WHERE {?s rdfa:term ?term ; rdfa:uri ?uri } GROUP BY ?s HAVING (COUNT(?term) = 1 && COUNT(?uri) = 1)";

            foreach (var profile in profiles)
            {
                try
                {
                    var g = new Graph();

                    if (profile.Equals(XHtmlVocabNamespace) || profile.Equals(XHtmlVocabNamespace.Substring(0, XHtmlVocabNamespace.Length - 1)))
                    {
                        // XHTML Vocabulary is a fixed vocabulary
                        evalContext.LocalVocabulary.Merge(new XHtmlRdfAVocabulary());
                    }
                    else
                    {
                        try
                        {
                            UriLoader.Load(g, UriFactory.Create(profile));
                        }
                        catch
                        {
                            // If we fail then we return false which indicates that the DOM subtree is ignored
                            OnWarning("Unable to retrieve a Profile document which the library could parse from the URI '" + profile + "'");
                            return false;
                        }

                        // Namespace Mappings
                        var results = g.ExecuteQuery(prefixQuery);
                        if (results is SparqlResultSet rset)
                        {
                            foreach (var r in rset.Results)
                            {
                                var prefixNode = r["NamespacePrefix"];
                                var nsNode = r["NamespaceURI"];
                                if (prefixNode.NodeType == NodeType.Literal && nsNode.NodeType == NodeType.Literal)
                                {
                                    var prefix = ((ILiteralNode)prefixNode).Value.ToLower();
                                    var ns = ((ILiteralNode)nsNode).Value;
                                    evalContext.LocalVocabulary.AddNamespace(prefix, ns);
                                }
                            }
                        }

                        // Term Mappings
                        results = g.ExecuteQuery(termQuery);
                        if (results is SparqlResultSet rset)
                        {
                            foreach (var r in rset.Results)
                            {
                                var termNode = r["Term"];
                                var uriNode = r["URI"];
                                if (termNode.NodeType == NodeType.Literal && uriNode.NodeType == NodeType.Literal)
                                {
                                    var term = ((ILiteralNode)termNode).Value;
                                    var uri = ((ILiteralNode)uriNode).Value;
                                    evalContext.LocalVocabulary.AddTerm(term, uri);
                                }
                            }
                        }
                    }
                }
                catch
                {
                    // Ignore errors and continue processing
                    OnWarning("Ignoring the value '" + profile + "' since this is not a valid URI or a profile document was not successfully retrieved and parsed from this URI");
                    return false;
                }
            }

            return true;
        }

        private void ParseVocabAttribute(RdfAParserContext<THtmlDocument> context, RdfAEvaluationContext evalContext, TAttribute attr)
        {
            if (GetAttributeValue(attr).Equals(string.Empty))
            {
                // Reset Local Vocabulary
                evalContext.LocalVocabulary = new TermMappings(context.DefaultVocabulary);
            }
            else
            {
                evalContext.LocalVocabulary.VocabularyUri = GetAttributeValue(attr);
            }
        }

        /// <summary>
        /// Get the text content of a node and add it to the provided output buffer.
        /// </summary>
        /// <param name="output"></param>
        /// <param name="node"></param>
        protected abstract void GrabText(StringBuilder output, TNode node);

        private void ProcessXmlLiteral(RdfAEvaluationContext evalContext, TElement n, bool noDefaultNamespace)
        {
            // Add Default Namespace as XHTML Namespace unless this would override an existing namespace
            if (!HasAttribute(n, "xmlns"))
            {
                if (!noDefaultNamespace) SetAttribute(n, "xmlns", XHtmlNamespace);
            }
            else
            {
                noDefaultNamespace = true;
            }

            // Add specific namespaces if necessary
            if (GetElementName(n).Contains(":"))
            {
                var prefix = GetElementName(n).Substring(0, GetElementName(n).IndexOf(':'));
                if (HasAttribute(n, "xmlns:" + prefix))
                {
                    // If the Node itself declares the Namespace then we don't need to do anything
                }
                else if (evalContext.NamespaceMap.HasNamespace(prefix))
                {
                    // If the Node doesn't declare the Namespace
                    SetAttribute(n, "xmlns:" + prefix, evalContext.NamespaceMap.GetNamespaceUri(prefix).AbsoluteUri);
                }
                else
                {
                    throw new RdfParseException("Malformed XML Literal - the undefined namespace prefix '" + prefix + "' is used");
                }
            }
            // Add Language (but don't override existing language)
            if (!evalContext.Language.Equals(string.Empty))
            {
                if (!HasAttribute(n, "xml:lang"))
                {
                    SetAttribute(n, "xml:lang", evalContext.Language);
                }
            }

            // Recurse on any child nodes
            foreach (var child in GetChildren(n).OfType<TElement>().Where(c=>!IsTextNode(c)))
            {
                ProcessXmlLiteral(evalContext, child, noDefaultNamespace);
            }
        }

        private bool IsTerm(string value)
        {
            return XmlSpecsHelper.IsNCName(value);
        }

        private bool IsCurie(RdfAEvaluationContext evalContext, string value)
        {
            if (value.StartsWith(":"))
            {
                var reference = value.Substring(1);
                return evalContext.NamespaceMap.HasNamespace(string.Empty) && IriSpecsHelper.IsIrelativeRef(value);
            }
            else if (value.Contains(':'))
            {
                var prefix = value.Substring(0, value.IndexOf(':'));
                var reference = value.Substring(value.IndexOf(':') + 1);
                return (XmlSpecsHelper.IsNCName(prefix) || prefix.Equals("_")) && evalContext.NamespaceMap.HasNamespace(prefix) && IriSpecsHelper.IsIrelativeRef(reference);
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Internal Helper for raising the Warning Event.
        /// </summary>
        /// <param name="message">Warning Message.</param>
        private void OnWarning(string message)
        {
            Warning?.Invoke(message);
        }

        /// <summary>
        /// Event which is raised when there is a non-fatal error with the input being read
        /// </summary>
        public event RdfReaderWarning Warning;
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\dotNetRDF\Parsing\RdfAParserBase.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF\Parsing\RdfAParserBase.cs(1398,56): error CS0128: A local variable or function named 'rset' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF\Parsing\RdfAParserBase.cs(1400,47): error CS0165: Use of unassigned local variable 'rset',D:\a\1\s\Libraries\dotNetRDF\Parsing\RdfAParserBase.cs(32,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 3 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Libraries\dotNetRDF\Parsing\RDFXMLParser.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using VDS.RDF.Parsing.Contexts;
using VDS.RDF.Parsing.Events;
using VDS.RDF.Parsing.Events.RdfXml;
using VDS.RDF.Parsing.Handlers;

namespace VDS.RDF.Parsing
{
    /// <summary>
    /// Possible RDF/XML Parse Types.
    /// </summary>
    public enum RdfXmlParseType : int
    {
        /// <summary>
        /// No specific Parse Type is specified (Default Parsing Rules will be used)
        /// </summary>
        None = -1,
        /// <summary>
        /// Literal Parse Type
        /// </summary>
        Literal = 0,
        /// <summary>
        /// Resource Parse Type
        /// </summary>
        Resource = 1,
        /// <summary>
        /// Collection Parse Type
        /// </summary>
        Collection = 2,
        /// <summary>
        /// Other Parse Type
        /// </summary>
        /// <remarks>This is never used since any other Parse Type encountered is assumed to be Literal as per the RDF/XML Specification</remarks>
        Other = 3,
    }

    /// <summary>
    /// Possible RDF/XML Parser Modes.
    /// </summary>
    public enum RdfXmlParserMode
    {
        /// <summary>
        /// Uses DOM Based parsing (not fully supported under .NET Standard/Core)
        /// </summary>
        DOM,
        /// <summary>
        /// Uses Streaming Based parsing (default)
        /// </summary>
        Streaming,
    }

    /// <summary>
    /// Parser for RDF/XML syntax.
    /// </summary>
    public class RdfXmlParser
        : IRdfReader, ITraceableParser
    {

        #region Variables and Properties

        private bool _traceparsing = false;
        private RdfXmlParserMode _mode = RdfXmlParserMode.Streaming;

        /// <summary>
        /// Controls whether Parser progress will be traced by writing output to the Console.
        /// </summary>
        public bool TraceParsing
        {
            get
            {
                return _traceparsing;
            }
            set
            {
                _traceparsing = value;
            }
        }

        #endregion

        /// <summary>
        /// Creates a new RDF/XML Parser.
        /// </summary>
        public RdfXmlParser()
        {

        }

        /// <summary>
        /// Creates a new RDF/XML Parser which uses the given parsing mode.
        /// </summary>
        /// <param name="mode">RDF/XML Parse Mode.</param>
        public RdfXmlParser(RdfXmlParserMode mode)
        {
            _mode = mode;
        }

        #region Load Method Implementations

        /// <summary>
        /// Reads RDF/XML syntax from some Stream into the given Graph.
        /// </summary>
        /// <param name="g">Graph to create Triples in.</param>
        /// <param name="input">Input Stream.</param>
        public void Load(IGraph g, StreamReader input)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            Load(new GraphHandler(g), input);
        }

        /// <summary>
        /// Reads RDF/XML syntax from some Input into the given Graph.
        /// </summary>
        /// <param name="g">Graph to create Triples in.</param>
        /// <param name="input">Input to read from.</param>
        public void Load(IGraph g, TextReader input)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            Load(new GraphHandler(g), input);
        }

        /// <summary>
        /// Reads RDF/XML syntax from some File into the given Graph.
        /// </summary>
        /// <param name="g">Graph to create Triples in.</param>
        /// <param name="filename">Filename of File containg XML/RDF.</param>
        /// <remarks>Simply opens a Stream for the File then calls the other version of Load to do the actual parsing.</remarks>
        public void Load(IGraph g, string filename)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            if (filename == null) throw new RdfParseException("Cannot read RDF from a null File");

            // Open a Stream for the File and call other variant of Load
            StreamReader input = new StreamReader(File.OpenRead(filename), Encoding.UTF8);
            Load(g, input);
        }

        /// <summary>
        /// Reads RDF/XML syntax from some Stream using a RDF Handler.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="input">Input Stream.</param>
        public void Load(IRdfHandler handler, StreamReader input)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (input == null) throw new RdfParseException("Cannot read RDF from a null Stream");

            // Issue a Warning if the Encoding of the Stream is not UTF-8
            if (!input.CurrentEncoding.Equals(Encoding.UTF8))
            {
                RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result");
            }

            Load(handler, (TextReader)input);
        }

        /// <summary>
        /// Reads RDF/XML syntax from some Input using a RDF Handler.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="input">Input to read from.</param>
        public void Load(IRdfHandler handler, TextReader input)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (input == null) throw new RdfParseException("Cannot read RDF from a null TextReader");

            try
            {
                // Silverlight only supports XmlReader not the full XmlDocument API
                if (_mode == RdfXmlParserMode.DOM)
                {
                    // Load XML from Stream
                    XmlDocument doc = new XmlDocument();
                    doc.Load(input);

                    // Create a new Parser Context and Parse
                    RdfXmlParserContext context = new RdfXmlParserContext(handler, doc, _traceparsing);
                    Parse(context);
                }
                else
                {
                    RdfXmlParserContext context = new RdfXmlParserContext(handler, input);
                    Parse(context);
                }
            }
            catch (XmlException xmlEx)
            {
                // Wrap in a RDF Parse Exception
                throw new RdfParseException("Unable to Parse this RDF/XML since System.Xml was unable to parse the document, see Inner Exception for details of the XML exception that occurred", new PositionInfo(xmlEx.LineNumber, xmlEx.LinePosition), xmlEx);
            }
            catch (IOException ioEx)
            {
                // Wrap in a RDF Parse Exception
                throw new RdfParseException("Unable to Parse this RDF/XML due to an IO Exception, see Inner Exception for details of the IO exception that occurred", ioEx);
            }
            finally
            {
                try
                {
                    input.Close();
                }
                catch
                {
                    // Ignore exceptions here - just trying to clean up properly
                }
            }
        }

        /// <summary>
        /// Reads RDF/XML syntax from a file using a RDF Handler.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="filename">File to read from.</param>
        public void Load(IRdfHandler handler, String filename)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (filename == null) throw new RdfParseException("Cannot read RDF from a null File");
            Load(handler, new StreamReader(File.OpenRead(filename), Encoding.UTF8));
        }

        /// <summary>
        /// Reads RDF/XML from the given XML Document.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="document">XML Document.</param>
        public void Load(IGraph g, XmlDocument document)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            if (document == null) throw new RdfParseException("Cannot read RDF from a null XML Document");

            try 
            {
                // Create a new Parser Context and Parse
                RdfXmlParserContext context = new RdfXmlParserContext(g, document, _traceparsing);
                Parse(context);
            }
            catch (XmlException xmlEx)
            {
                // Wrap in a RDF Parse Exception
                throw new RdfParseException("Unable to Parse this RDF/XML since System.Xml was unable to parse the document into a DOM Tree", xmlEx);
            }
            catch (IOException ioEx)
            {
                // Wrap in a RDF Parse Exception
                throw new RdfParseException("Unable to Parse this RDF/XML due to an IO Exception", ioEx);
            }
            catch (Exception)
            {
                // Throw unexpected errors upwards as-is
                throw;
            }
        }

        #endregion

        /// <summary>
        /// Helper Method for raising the <see cref="RdfXmlParser.Warning">Warning</see> event.
        /// </summary>
        /// <param name="warning">Warning Message.</param>
        private void RaiseWarning(String warning)
        {
            RdfReaderWarning d = Warning;
            if (d != null)
            {
                d(warning);
            }
        }

        /// <summary>
        /// Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
        /// </summary>
        public event RdfReaderWarning Warning;

        /// <summary>
        /// Function which does the actual Parsing by invoking the various steps of the Parser.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        private void Parse(RdfXmlParserContext context)
        {
            try
            {
                context.Handler.StartRdf();

                // Trace Parser Information
                if (_traceparsing)
                {
                    Console.WriteLine("Trace Format is as follows:");
                    Console.WriteLine("NestingLevel EventType [Description]");
                    Console.WriteLine();
                }

                // Define XML namespace
                context.Handler.HandleNamespace("xml", UriFactory.Create(XmlSpecsHelper.NamespaceXml));
                context.Namespaces.AddNamespace("xml", UriFactory.Create(XmlSpecsHelper.NamespaceXml));

                // Process the Queue
                ProcessEventQueue(context);

                context.Handler.EndRdf(true);
            }
            catch (RdfParsingTerminatedException)
            {
                context.Handler.EndRdf(true);
                // Discard this - it justs means the Handler told us to stop
            }
            catch
            {
                context.Handler.EndRdf(false);
                throw;
            }
        }

        #region Queue Processing

        /// <summary>
        /// Starts the Parsing of the flattened Event Tree by calling the appropriate Grammar Production based on the type of the First Event in the Queue.
        /// </summary>
        private void ProcessEventQueue(RdfXmlParserContext context)
        {
            // Get First Event
            IRdfXmlEvent first = context.Events.Dequeue();
            bool setBaseUri = (context.BaseUri == null);
            Uri baseUri;

            if (first is RootEvent)
            {
                GrammarProductionDoc(context, (RootEvent)first);
                if (setBaseUri && !((RootEvent)first).BaseUri.Equals(String.Empty))
                {
                    baseUri = UriFactory.Create(Tools.ResolveUri(((RootEvent)first).BaseUri, String.Empty));
                    context.BaseUri = baseUri;
                    if (!context.Handler.HandleBaseUri(baseUri)) ParserHelper.Stop();
                }
            }
            else
            {
                GrammarProductionRDF(context, (ElementEvent)first);
                if (setBaseUri && !((ElementEvent)first).BaseUri.Equals(String.Empty))
                {
                    baseUri = UriFactory.Create(Tools.ResolveUri(((ElementEvent)first).BaseUri, String.Empty));
                    context.BaseUri = baseUri;
                    if (!context.Handler.HandleBaseUri(baseUri)) ParserHelper.Stop();
                }
            }

        }

        #endregion

        #region Grammar Productions

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'doc'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="root">Root Event to start applying Productions from.</param>
        private void GrammarProductionDoc(RdfXmlParserContext context, RootEvent root)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTrace("Doc");
            }

            // Call the RDF Production on the first child if it's an rdf:RDF element
            // if (root.Children[0].QName.Equals("rdf:RDF") || root.Children[0].QName.Equals(":RDF"))
            String localName = root.Children[0].LocalName;
            String prefix = root.Children[0].Namespace;
            if (localName.Equals("RDF") && 
                ((context.Namespaces.HasNamespace(prefix) && context.Namespaces.GetNamespaceUri(prefix).AbsoluteUri.Equals(NamespaceMapper.RDF)) 
                 || root.DocumentElement.NamespaceAttributes.Any(ns => ns.Prefix.Equals(prefix) && ns.Uri.Equals(NamespaceMapper.RDF))))
            {
                GrammarProductionRDF(context, root.Children[0]);
            }
            else
            {
                // No rdf:RDF element
                // Drop first element from Queue (which will be a RootEvent)
                // Skip straight to NodeElementList production
                // context.Events.Dequeue();
                GrammarProductionNodeElementList(context, context.Events);
            }
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'RDF'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="element">RDF Element to apply Production to.</param>
        private void GrammarProductionRDF(RdfXmlParserContext context, ElementEvent element)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTrace("RDF", element);
            }

            // Check Uri is correct
            String localName = element.LocalName;
            String prefix = element.Namespace;
            if (localName.Equals("RDF") || 
                ((context.Namespaces.HasNamespace(prefix) && context.Namespaces.GetNamespaceUri(prefix).AbsoluteUri.Equals(NamespaceMapper.RDF)) 
                 || element.NamespaceAttributes.Any(ns => ns.Prefix.Equals(prefix) && ns.Uri.Equals(NamespaceMapper.RDF))))
            {
                // This is OK
            }
            else
            {
                throw ParserHelper.Error("Unexpected Node '" + element.QName + "', an 'rdf:RDF' node was expected", "RDF", element);
            }
            // Check has no Attributes
            if (element.Attributes.Count > 0)
            {
                throw ParserHelper.Error("Root Node should not contain any attributes other than XML Namespace Declarations", "RDF", element);
            }

            // Start a new namespace scope
            ApplyNamespaces(context, element);

            // Make sure we discard the current ElementEvent which will be at the front of the queue
            context.Events.Dequeue();

            // Build a virtual Sublist of all Nodes up to the matching EndElement to avoid copying the events around too much
            IEventQueue<IRdfXmlEvent> subevents = new SublistEventQueue<IRdfXmlEvent>(context.Events, 1);

            // Call the NodeElementList Grammer Production
            GrammarProductionNodeElementList(context, subevents);

            // Next Event in queue should be an EndElementEvent or we Error
            IRdfXmlEvent next = context.Events.Dequeue();
            if (!(next is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', an EndElementEvent was expected", "RDF", element);
            }

            // Exit the current namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'nodeElementList'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events to apply the Production to.</param>
        private void GrammarProductionNodeElementList(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTrace("Node Element List");
            }

            IRdfXmlEvent next;

            // Want to break up into a number of sublists
            while (eventlist.Count > 0) 
            {
                // Create a new Sublist
                IEventQueue<IRdfXmlEvent> subevents = new EventQueue<IRdfXmlEvent>();
                int nesting = 0;

                // Gather the Sublist taking account of nesting
                do
                {
                    next = eventlist.Dequeue();
                    subevents.Enqueue(next);

                    if (next is ElementEvent)
                    {
                        nesting++;
                    }
                    else if (next is EndElementEvent)
                    {
                        nesting--;
                    }
                } while (nesting > 0);

                // Call the next Grammar Production
                GrammarProductionNodeElement(context, subevents);
            }
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'nodeElement'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Node Element and its Children to apply the Production to.</param>
        private void GrammarProductionNodeElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Node Element");
            }

            // Get First Event in the Queue
            IRdfXmlEvent first = eventlist.Dequeue();

            // Check it's an ElementEvent
            if (!(first is ElementEvent))
            {
                // Unexpected Event
                throw ParserHelper.Error("Expected an ElementEvent but encountered a '" + first.GetType().ToString() + "'", "Node Element", first);
            }

            // Check it has a valid Uri
            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);
            // Start a new namespace scope
            ApplyNamespaces(context, element);
            if (!RdfXmlSpecsHelper.IsNodeElementUri(context.Namespaces.GetNamespaceUri(element.Namespace), element.LocalName))
            {
                throw ParserHelper.Error("A Node Element was encountered with an invalid URI '" + element.QName + "' \nCore Syntax Terms, Old Syntax Terms and rdf:li cannot be used as Node Element URIs", "Node Element", element);
            }

            // Check the set of Attributes is Valid
            int limitedAttributesFound = 0;
            String ID = String.Empty;
            foreach (AttributeEvent attr in element.Attributes)
            {
                if (RdfXmlSpecsHelper.IsIDAttribute(attr, context.Namespaces))
                {
                    ID = attr.Value;
                    limitedAttributesFound++;

                    // Set the Subject
                    element.Subject = new UriReferenceEvent("#" + attr.Value, attr.SourceXml);
                }
                else if (RdfXmlSpecsHelper.IsNodeIDAttribute(attr, context.Namespaces))
                {
                    limitedAttributesFound++;

                    // Validate the Node ID
                    if (!XmlSpecsHelper.IsName(attr.Value))
                    {
                        throw ParserHelper.Error("The value '" + attr.Value + "' for rdf:nodeID is not valid, RDF Node IDs can only be valid Names as defined by the W3C XML Specification", "Node Element", attr);
                    }

                    // Set the Subject
                    element.Subject = new BlankNodeIDEvent(attr.Value, attr.SourceXml);
                }
                else if (RdfXmlSpecsHelper.IsAboutAttribute(attr, context.Namespaces))
                {
                    limitedAttributesFound++;

                    // Set the Subject
                    element.Subject = new UriReferenceEvent(attr.Value, attr.SourceXml);
                }
                else if (RdfXmlSpecsHelper.IsPropertyAttribute(attr, context.Namespaces))
                {
                    // Don't need to do anything here yet
                }
                else
                {
                    // Unknown and Unexpected Attribute Type
                    throw ParserHelper.Error("Unexpected Attribute '" + attr.QName + "' was encountered!", "Node Element", element);
                }

                // Can't have more than 1 of ID, Node ID or About Attributes
                if (limitedAttributesFound > 1)
                {
                    throw ParserHelper.Error("A Node Element can only have 1 of the following attributes: rdf:id, rdf:nodeID, rdf:about", "Node Element", element);
                }
            }

            // Generate a Blank Node ID if our Subject is empty
            if (element.Subject == null)
            {
                element.Subject = new BlankNodeIDEvent(element.SourceXml);
            }

            // Add statements as necessary
            INode subj, pred, obj;
            if (element.SubjectNode == null)
            {
                // Don't always want to drop in here since the SubjectNode may already be set elsewhere
                if (element.Subject is UriReferenceEvent)
                {
                    UriReferenceEvent uri = (UriReferenceEvent)element.Subject;
                    subj = Resolve(context, uri, element.BaseUri);
                }
                else if (element.Subject is BlankNodeIDEvent)
                {
                    BlankNodeIDEvent blank = (BlankNodeIDEvent)element.Subject;

                    // Select whether we need to generate an ID or if there's one given for the Blank Node
                    // Note that we let the Graph class handle generation of IDs
                    if (blank.Identifier.Equals(String.Empty))
                    {
                        subj = context.Handler.CreateBlankNode();
                    }
                    else
                    {
                        subj = context.Handler.CreateBlankNode(blank.Identifier);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Unexpected Subject generated for a Triple", "Node Element", element.Subject);
                }
            } 
            else
            {
                subj = element.SubjectNode;
            }

            // Set the Subject Node property of the Event for later reuse
            element.SubjectNode = subj;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID, subj);
            }

            //if (!element.QName.Equals("rdf:Description") && !element.QName.Equals(":Description"))
            if (!ElementHasName(element, "Description", NamespaceMapper.RDF, context))
            {
                // Assert a Triple regarding Type
                pred = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType));
                obj = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);
                if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();
            }

            // Go back over Attributes looking for property attributes
            foreach (AttributeEvent attr in element.Attributes)
            {
                if (RdfXmlSpecsHelper.IsPropertyAttribute(attr, context.Namespaces))
                {
                    if (attr.Namespace.Equals(NamespaceMapper.RDF) && attr.LocalName.Equals("type"))
                    //if (attr.QName.Equals("rdf:type"))
                    {
                        // Generate a Type Triple
                        pred = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType));

                        // Resolve URIRef into a Uri Node
                        UriReferenceEvent uriref = new UriReferenceEvent(attr.Value, attr.SourceXml);
                        obj = Resolve(context, uriref, element.BaseUri);

                        if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();
                    }
                    else
                    {
                        // Generate a Property Triple
                        pred = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveQName(attr.QName, context.Namespaces, null)));

                        // Add Language to Literal if necessary
                        if (element.Language.Equals(String.Empty))
                        {
                            obj = context.Handler.CreateLiteralNode(attr.Value);
                        }
                        else
                        {
                            obj = context.Handler.CreateLiteralNode(attr.Value, element.Language);
                        }

                        if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();
                    }
                }
            }

            // Handle Child Elements
            IEventQueue<IRdfXmlEvent> children = new EventQueue<IRdfXmlEvent>();
            while (eventlist.Count > 1)
            {
                children.Enqueue(eventlist.Dequeue());
            }
            if (children.Count > 0) GrammarProductionPropertyElementList(context, children, element);

            // Check Last Event in queue is an EndElement event
            IRdfXmlEvent last = eventlist.Dequeue();
            if (!(last is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + last.GetType().ToString() + "', expected an EndElement Event", "NodeElement", last);
            }

            // Exit the current namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'propertyEltList'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events to apply the Production to.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Elements.</param>
        private void GrammarProductionPropertyElementList(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTrace("Property Element List");
            }

            IRdfXmlEvent next;

            // Want to break up into a number of sublists
            while (eventlist.Count > 0)
            {
                // Create a new Sublist
                IEventQueue<IRdfXmlEvent> subevents = new EventQueue<IRdfXmlEvent>();
                int nesting = 0;

                // Gather the Sublist taking account of nesting
                do
                {
                    next = eventlist.Dequeue();
                    subevents.Enqueue(next);

                    if (next is ElementEvent)
                    {
                        nesting++;
                    }
                    else if (next is EndElementEvent)
                    {
                        nesting--;
                    }
                } while (nesting > 0);

                // Call the next Grammar Production
                if (subevents.Count > 0) GrammarProductionPropertyElement(context, subevents, parent);
            }
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'propertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionPropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Property Element");
            }

            // Get first thing from the Queue
            IRdfXmlEvent first = eventlist.Dequeue();
            ElementEvent element;

            // Must be an ElementEvent
            if (!(first is ElementEvent))
            {
                // Unexpected Event
                throw ParserHelper.Error("Expected an ElementEvent but encountered a '" + first.GetType().ToString() + "'", "PropertyElement", first);
            }

            // Validate the Uri
            element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start a new namespace scope
            ApplyNamespaces(context, element);
            if (!RdfXmlSpecsHelper.IsPropertyElement(element, context.Namespaces))
            {
                // Invalid Uri
                throw ParserHelper.Error("A Property Element was encountered with an invalid URI '" + element.QName + "'\nCore Syntax Terms, Old Syntax Terms and rdf:Description cannot be used as Property Element URIs", "PropertyElement", element);
            }

            // List Expansion
            if (RdfXmlSpecsHelper.IsLiElement(element, context.Namespaces))
            {
                var u = ListExpand(parent, context.Namespaces);
                element.SetUri(u, context.Namespaces);
            }

            // Need to select what to do based on the Type of Property Element
            IRdfXmlEvent next = eventlist.Peek();

            // This call inserts the first element back at the head of the queue
            // Most of the sub-productions here need this
            // Would ideally use Stacks instead of Queues but Queues make more sense for most of the Parsing
            QueueJump(eventlist, first);

            if (element.ParseType == RdfXmlParseType.None)
            {
                // A Resource/Literal Property Element

                if (next is ElementEvent)
                {
                    // Resource
                    GrammarProductionResourcePropertyElement(context, eventlist, parent);
                }
                else if (next is TextEvent)
                {
                    // Literal
                    GrammarProductionLiteralPropertyElement(context, eventlist, parent);
                }
                else if (next is EndElementEvent)
                {
                    // An Empty Property Element
                    GrammarProductionEmptyPropertyElement(context, element, parent);
                }
                else
                {
                    // Error
                    throw ParserHelper.Error("An Element which should be Parsed with the Default Parsing Rules was encountered without a valid subsequent Event - Parser cannot proceed!", "Property Element", element);
                }
            }
            else if (element.ParseType == RdfXmlParseType.Literal)
            {
                // A rdf:parseType="Literal" Property Element

                GrammarProductionParseTypeLiteralPropertyElement(context, eventlist, parent);
            }
            else if (element.ParseType == RdfXmlParseType.Collection)
            {
                // A rdf:parseType="Collection" Property Element

                GrammarProductionParseTypeCollectionPropertyElement(context, eventlist, parent);
            }
            else if (element.ParseType == RdfXmlParseType.Resource)
            {
                // A rdf:parseType="Resource" Property Element

                GrammarProductionParseTypeResourcePropertyElement(context, eventlist, parent);
            }
            else if (next is EndElementEvent)
            {
                // An Empty Property Element
                GrammarProductionEmptyPropertyElement(context, element, parent);
            }
            else
            {
                // Error
                throw ParserHelper.Error("An Element without a known Parse Type was encountered Or the Parser was unable to determine what to do based on the subsequent event - Parser cannot proceed!", "Node Element", element);
            }
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'resourcePropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Resource Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionResourcePropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Resource Property Element");
            }

            // Cast to an ElementEvent
            // We don't validate type here since we know this will be an ElementEvent because the calling function
            // will have done this validation previously
            IRdfXmlEvent first = eventlist.Dequeue();
            IRdfXmlEvent next = eventlist.Peek();
            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start new namespace scope
            ApplyNamespaces(context, element);

            // Only allowed one attribute max which must be an ID attribute
            String ID = String.Empty;
            if (element.Attributes.Count > 1)
            {
                throw ParserHelper.Error("A Resource Property Element contains too many Attributes, only rdf:ID is permitted", element);
            }
            else if (element.Attributes.Count == 1)
            {
                if (!RdfXmlSpecsHelper.IsIDAttribute(element.Attributes.First(), context.Namespaces))
                {
                    throw ParserHelper.Error("A Resource Property Element was encountered with a single attribute which was not rdf:ID, only rdf:ID is permitted", element);
                }
                else
                {
                    ID = element.Attributes.First().Value;
                }
            }

            // Next must be an ElementEvent
            if (!(next is ElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', expected an ElementEvent as the first Event in a Resource Property Elements Event list", next);
            }

            // Get list of Sub Events
            IEventQueue<IRdfXmlEvent> subevents = new EventQueue<IRdfXmlEvent>();
            while (eventlist.Count > 1)
            {
                subevents.Enqueue(eventlist.Dequeue());
            }
            GrammarProductionNodeElement(context, subevents);

            // Check Last is an EndElementEvent
            IRdfXmlEvent last = eventlist.Dequeue();
            if (!(last is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + last.GetType().ToString() + "', expected an EndElement Event", last);
            }

            // Now we can generate the relevant RDF
            INode subj, pred, obj;

            // Validate the Type of the Parent
            if (!(parent is ElementEvent))
            {
                throw ParserHelper.Error("Unexpected Parent Event '" + parent.GetType().ToString() + "', expected an ElementEvent", parent);
            }
            ElementEvent parentEl = (ElementEvent)parent;

            // Get the Subject Node from the Parent
            subj = parentEl.SubjectNode;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID, subj);
            }

            // Create a Predicate from this Element
            pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

            // Get the Object Node from the Child Node
            ElementEvent child = (ElementEvent)next;
            obj = child.SubjectNode;

            // Assert the Triple
            if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

            // Add Reification where appropriate
            if (element.Attributes.Count == 1)
            {
                // Must be an rdf:ID attribute as we've validated this earlier

                // Get the Attribute Event and generate a Uri from it
                AttributeEvent attr = element.Attributes.First();
                UriReferenceEvent uriref = new UriReferenceEvent("#" + attr.Value, attr.SourceXml);
                IUriNode uri = Resolve(context, uriref, element.BaseUri);

                Reify(context, uri, subj, pred, obj);
            }

            // End current namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'literalPropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Literal Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionLiteralPropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Literal Property Element");
            }

            // Get the 3 Events (should only be three)
            IRdfXmlEvent first, middle, last;
            first = eventlist.Dequeue();
            middle = eventlist.Dequeue();
            last = eventlist.Dequeue();

            // If Queue is non-empty then Error
            if (eventlist.Count > 0)
            {
                throw ParserHelper.Error("Too many events encountered while trying to parse a Literal Property Element", first);
            }

            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start a new namespace sscope
            ApplyNamespaces(context, element);

            // Validate that the middle event is a TextEvent
            if (!(middle is TextEvent))
            {
                throw ParserHelper.Error("Unexpected event '" + middle.GetType().ToString() + "', expected a TextEvent in a Literal Property Element", middle);
            }
            TextEvent text = (TextEvent)middle;

            // Validate the Attributes
            String ID = String.Empty;
            String datatype = String.Empty;
            if (element.Attributes.Count > 2)
            {
                throw ParserHelper.Error("A Literal Property Element contains too many attributes, only rdf:ID and rdf:datatype are permitted", element);
            }
            else
            {
                // Only rdf:ID and rdf:datatype allowed
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces)) {
                        ID = "#" + a.Value;
                    }
                    else if (RdfXmlSpecsHelper.IsDataTypeAttribute(a, context.Namespaces))
                    {
                        datatype = a.Value;
                    } 
                    else 
                    {
                        throw ParserHelper.Error("A Literal Property Element contains an unexpected attribute, only rdf:ID and rdf:datatype are permitted", element);
                    }
                }
            }

            // Create the Nodes for the Graph
            INode subj, pred, obj;
            
            // Get the Subject from the Parent
            ElementEvent parentEl = (ElementEvent)parent;
            subj = parentEl.SubjectNode;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID.Substring(1), subj);
            }

            // Create a Predicate from this Element
            pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

            // Create an Object from the Text Event
            if (datatype.Equals(String.Empty))
            {
                // No Type with possible Language
                if (element.Language.Equals(String.Empty))
                {
                    obj = context.Handler.CreateLiteralNode(text.Value);
                }
                else
                {
                    obj = context.Handler.CreateLiteralNode(text.Value, element.Language);
                }
            }
            else
            {
                // Typed

                // Resolve the Datatype Uri
                UriReferenceEvent dtref = new UriReferenceEvent(datatype, String.Empty);
                IUriNode dturi = Resolve(context, dtref, element.BaseUri);

                obj = context.Handler.CreateLiteralNode(text.Value, dturi.Uri);
            }

            // Assert the Triple
            if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

            // Reify if applicable
            if (!ID.Equals(String.Empty))
            {
                // Resolve the Uri
                UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                IUriNode uri = Resolve(context, uriref,element.BaseUri);

                Reify(context, uri, subj, pred, obj);
            }

            // End namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'parseTypeLiteralPropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Literal Parse Type Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionParseTypeLiteralPropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Parse Type Literal Property Element");
            }

            // Get the first Event, should be an ElementEvent
            // Type checking is done by the Parent Production
            IRdfXmlEvent first = eventlist.Dequeue();
            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start new namespace scope
            ApplyNamespaces(context, element);

            // Validate Attributes
            String ID = String.Empty;
            if (element.Attributes.Count > 2)
            {
                // Can't be more than 2 Attributes, only allowed an optional rdf:ID and a required rdf:parseType
                throw ParserHelper.Error("An Property Element with Parse Type 'Literal' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Literal'", "Parse Type Literal Property Element", element);
            }
            else
            {
                // Check the attributes that do exist
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces))
                    {
                        ID = "#" + a.Value;
                    }
                    else if (RdfXmlSpecsHelper.IsParseTypeAttribute(a, context.Namespaces))
                    {
                        // OK
                    }
                    else
                    {
                        // Invalid Attribute
                        throw ParserHelper.Error("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Literal'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Literal'", "Parse Type Literal Property Element", element);
                    }
                }
            }

            // Get the next event in the Queue which should be a TypedLiteralEvent
            // Validate this
            IRdfXmlEvent lit = eventlist.Dequeue();
            if (!(lit is TypedLiteralEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + lit.GetType().ToString() + "', expected a TypedLiteralEvent after a Property Element with Parse Type 'Literal'", "Parse Type Literal Property Element", lit);
            }

            // Get the Subject from the Parent
            INode subj, pred, obj;
            ElementEvent parentEl = (ElementEvent) parent;
            subj = parentEl.SubjectNode;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID.Substring(1), subj);
            }

            // Create the Predicate from the Element
            pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

            // Create the Object from the Typed Literal
            TypedLiteralEvent tlit = (TypedLiteralEvent)lit;
            // At the moment we're just going to ensure that we normalize it to Unicode Normal Form C
            String xmllit = tlit.Value;
            xmllit = xmllit.Normalize();
            obj = context.Handler.CreateLiteralNode(xmllit, UriFactory.Create(tlit.DataType));

            // Assert the Triple
            if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

            // Reify if applicable
            if (!ID.Equals(String.Empty))
            {
                // Resolve the Uri
                UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                IUriNode uri = Resolve(context, uriref,element.BaseUri);

                Reify(context, uri, subj, pred, obj);
            }

            // Check for the last thing being an EndElement Event
            IRdfXmlEvent next = eventlist.Dequeue();
            if (!(next is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', expected an EndElementEvent to terminate a Parse Type Literal Property Element!", "Parse Type Literal Property Element", next);
            }

            // End the namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'parseTypeResourcePropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Resource Parse Type Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionParseTypeResourcePropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Parse Type Resource Property Element");
            }

            // Get the first Event, should be an ElementEvent
            // Type checking is done by the Parent Production
            IRdfXmlEvent first = eventlist.Dequeue();
            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start a new namespace scope
            ApplyNamespaces(context, element);

            // Validate Attributes
            String ID = String.Empty;
            if (element.Attributes.Count > 2)
            {
                // Can't be more than 2 Attributes, only allowed an optional rdf:ID and a required rdf:parseType
                throw ParserHelper.Error("An Property Element with Parse Type 'Resource' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Resource'", "Parse Type Resource Property Element", element);
            }
            else
            {
                // Check the attributes that do exist
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces))
                    {
                        ID = "#" + a.Value;
                    }
                    else if (RdfXmlSpecsHelper.IsParseTypeAttribute(a, context.Namespaces))
                    {
                        // OK
                    }
                    else
                    {
                        // Invalid Attribute
                        throw ParserHelper.Error("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Resource'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Resource'", "Parse Type Resource Property Element", element);
                    }
                }
            }

            // Add a Triple about this
            INode subj, pred, obj;

            // Get the Subject from the Parent
            ElementEvent parentEvent = (ElementEvent)parent;
            subj = parentEvent.SubjectNode;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID.Substring(1), subj);
            }

            // Create the Predicate from the Element
            pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

            // Generate a Blank Node ID for the Object
            obj = context.Handler.CreateBlankNode();

            // Assert
            if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

            // Reify if applicable
            if (!ID.Equals(String.Empty))
            {
                // Resolve the Uri
                UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                IUriNode uri = Resolve(context, uriref,element.BaseUri);

                Reify(context, uri, subj, pred, obj);
            }

            // Get the next event in the Queue which should be either an Element Event or a End Element Event
            // Validate this
            IRdfXmlEvent next = eventlist.Dequeue();
            if (next is EndElementEvent)
            {
                // Content is Empty so nothing else to do
            }
            else if (next is ElementEvent)
            {
                // Non-Empty Content so need to build a sequence of new events
                IEventQueue<IRdfXmlEvent> subEvents = new EventQueue<IRdfXmlEvent>();

                // Create an rdf:Description event as the container
                var prefix = context.Namespaces.GetPrefix(new Uri(NamespaceMapper.RDF));
                var descrip = new ElementEvent(prefix+":Description", element.BaseUri, string.Empty);
                descrip.Subject = new BlankNodeIDEvent(string.Empty);
                descrip.SubjectNode = obj;
                subEvents.Enqueue(descrip);

                // Add the current element we were looking at
                subEvents.Enqueue(next);

                // Add rest of events in list (except the last)
                while (eventlist.Count > 1)
                {
                    subEvents.Enqueue(eventlist.Dequeue());
                }

                // Terminate with an EndElement Event
                subEvents.Enqueue(new EndElementEvent());

                // Process with Node Element Production
                GrammarProductionNodeElement(context, subEvents);

                // Get the last thing in the List
                next = eventlist.Dequeue();
            }
            else
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', expected an ElementEvent or EndElementEvent after a Parse Type Resource Property Element!", "Parse Type Resource Property Element", next);
            }

            // Check for the last thing being an EndElement Event
            if (!(next is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', expected an EndElementEvent to terminate a Parse Type Resource Property Element!", "Parse Type Resource Property Element", next);
            }

            // End the namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'parseTypeCollectionPropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Collection Parse Type Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionParseTypeCollectionPropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Parse Type Collection Property Element");
            }

            // Get the first Event, should be an ElementEvent
            // Type checking is done by the Parent Production
            IRdfXmlEvent first = eventlist.Dequeue();
            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start a new namespace scope
            ApplyNamespaces(context, element);

            // Validate Attributes
            String ID = String.Empty;
            if (element.Attributes.Count > 2)
            {
                // Can't be more than 2 Attributes, only allowed an optional rdf:ID and a required rdf:parseType
                throw ParserHelper.Error("An Property Element with Parse Type 'Collection' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Collection'", "Parse Type Collection Property Element", element);
            }
            else
            {
                // Check the attributes that do exist
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces))
                    {
                        ID = "#" + a.Value;
                    }
                    else if (RdfXmlSpecsHelper.IsParseTypeAttribute(a, context.Namespaces))
                    {
                        // OK
                    }
                    else
                    {
                        // Invalid Attribute
                        throw ParserHelper.Error("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Collection'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Collection'", "Parse Type Collection Property Element", element);
                    }
                }
            }

            // Build sequence of Blank Nodes
            IRdfXmlEvent next;
            IRdfXmlEvent nodeElement;

            Queue<ElementEvent> seqNodes = new Queue<ElementEvent>();
            while (eventlist.Count > 1)
            {
                #region Node Element Processing
                // Need to process the Node Element first

                // Create a new Sublist
                IEventQueue<IRdfXmlEvent> subevents = new EventQueue<IRdfXmlEvent>();
                int nesting = 0;
                nodeElement = eventlist.Peek();

                // Add Node Element to sequence
                seqNodes.Enqueue((ElementEvent)nodeElement);

                // Gather the Sublist taking account of nesting
                do
                {
                    next = eventlist.Dequeue();
                    subevents.Enqueue(next);

                    if (next is ElementEvent)
                    {
                        nesting++;
                    }
                    else if (next is EndElementEvent)
                    {
                        nesting--;
                    }
                } while (nesting > 0);

                // Call the next Grammar Production
                GrammarProductionNodeElement(context, subevents);

                #endregion
            }

            // Build a triple expressing the start of the list (which may be an empty list)
            INode subj, pred, obj;
            INode firstPred, restPred;
            INode b1, b2;

            // Subject comes from Parent
            ElementEvent parentElement = (ElementEvent)parent;
            subj = parentElement.SubjectNode;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID.Substring(1), subj);
            }

            // Predicate from the Element
            pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

            if (seqNodes.Count > 0)
            {
                // Non-empty list
                ElementEvent node;

                // Get first Element from the Queue
                node = seqNodes.Dequeue();

                // Object is first thing in the Sequence which we create a Blank Node for
                b1 = context.Handler.CreateBlankNode();

                // Assert
                if (!context.Handler.HandleTriple(new Triple(subj, pred, b1))) ParserHelper.Stop();

                // Reify if applicable
                if (!ID.Equals(String.Empty))
                {
                    // Resolve the Uri
                    UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                    IUriNode uri = Resolve(context, uriref, element.BaseUri);

                    Reify(context, uri, subj, pred, b1);
                }

                // Set the first element in the list
                subj = b1;
                firstPred = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfListFirst));
                if (!context.Handler.HandleTriple(new Triple(subj, firstPred, node.SubjectNode))) ParserHelper.Stop();

                // Middle elements of the list
                restPred = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfListRest));
                while (seqNodes.Count >= 1)
                {
                    node = seqNodes.Dequeue();

                    // Set Node 2 to be the rest of the previous items list
                    b2 = context.Handler.CreateBlankNode();
                    if (!context.Handler.HandleTriple(new Triple(b1, restPred, b2))) ParserHelper.Stop();

                    // Set Node 2 to be the start of it's own list
                    if (!context.Handler.HandleTriple(new Triple(b2, firstPred, node.SubjectNode))) ParserHelper.Stop();

                    b1 = b2;
                }

                // Set last element of the list to have its rest as nil
                if (!context.Handler.HandleTriple(new Triple(b1, restPred, context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfListNil))))) ParserHelper.Stop();
            }
            else
            {
                // Empty list

                // Object is therefore rdf:nil
                obj = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfListNil));

                // Assert
                if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

                // Reify if applicable
                if (!ID.Equals(String.Empty))
                {
                    // Resolve the Uri
                    UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                    IUriNode uri = Resolve(context, uriref, element.BaseUri);

                    Reify(context, uri, subj, pred, obj);
                }
            }

            // Check last event is an EndElementEvent
            next = eventlist.Dequeue();
            if (!(next is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', expected an EndElementEvent to terminate a Parse Type Collection Property Element!", "Parse Type Collection Property Element", next);
            }

            // End the current namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'emptyPropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="element">Element Event for the Empty Property Element.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionEmptyPropertyElement(RdfXmlParserContext context, ElementEvent element, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTrace("Empty Property Element");
            }

            // Start a new namespace scope
            ApplyNamespaces(context, element);

            INode subj, pred, obj;
            ElementEvent parentEl;

            // Are there any attributes OR Only a rdf:ID attribute?
            if (element.Attributes.Count == 0 || (element.Attributes.Count == 1 && RdfXmlSpecsHelper.IsIDAttribute(element.Attributes[0], context.Namespaces)))
            {
                // No Attributes/Only rdf:ID

                // Get the Subject Node from the Parent
                parentEl = (ElementEvent)parent;
                subj = parentEl.SubjectNode;

                // Create the Predicate from the Element
                pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

                // Create the Object
                if (!element.Language.Equals(String.Empty))
                {
                    obj = context.Handler.CreateLiteralNode(String.Empty, element.Language);
                }
                else
                {
                    obj = context.Handler.CreateLiteralNode(String.Empty);
                }

                // Make the Assertion
                if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

                // Reifiy if applicable
                if (element.Attributes.Count == 1)
                {
                    // Validate the ID
                    ValidateID(context, element.Attributes[0].Value, subj);

                    // Resolve the Uri
                    UriReferenceEvent uriref = new UriReferenceEvent("#" + element.Attributes[0].Value, String.Empty);
                    IUriNode uri = Resolve(context, uriref, element.BaseUri);

                    Reify(context, uri, subj, pred, obj);
                }

            }
            else if (element.Attributes.Count > 0 && element.Attributes.Count(a => RdfXmlSpecsHelper.IsDataTypeAttribute(a, context.Namespaces))== 1)
            {
                // Should be processed as a Typed Literal Event instead
                EventQueue<IRdfXmlEvent> temp = new EventQueue<IRdfXmlEvent>();
                temp.Enqueue(element);
                temp.Enqueue(new TextEvent(String.Empty, String.Empty));
                temp.Enqueue(new EndElementEvent());
                GrammarProductionLiteralPropertyElement(context, temp, parent);
            }
            else
            {

                // Check through attributes
                IRdfXmlEvent res = null;

                // Check through attributes to decide the Subject of the Triple(s)
                String ID = String.Empty;
                int limitedAttributes = 0;
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsResourceAttribute(a, context.Namespaces))
                    {
                        // An rdf:resource attribute so a Uri Reference
                        res = new UriReferenceEvent(a.Value, a.SourceXml);
                        limitedAttributes++;
                    }
                    else if (RdfXmlSpecsHelper.IsNodeIDAttribute(a, context.Namespaces))
                    {
                        // An rdf:nodeID attribute so a Blank Node

                        // Validate the Node ID
                        if (!XmlSpecsHelper.IsName(a.Value))
                        {
                            // Invalid nodeID
                            throw ParserHelper.Error("The value '" + a.Value + "' for rdf:nodeID is not valid, RDF Node IDs can only be valid Names as defined by the W3C XML Specification", "Empty Property Element", a);
                        }
                        res = new BlankNodeIDEvent(a.Value, a.SourceXml);
                        limitedAttributes++;
                    }
                    else if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces))
                    {
                        // Set the ID for later use in reification
                        ID = "#" + a.Value;
                    }

                    // Check we haven't got more than 1 of the Limited Attributes
                    if (limitedAttributes > 1)
                    {
                        throw ParserHelper.Error("A Property Element can only have 1 of the following attributes: rdf:nodeID or rdf:resource", "Empty Property Element", element);
                    }
                }
                if (res == null)
                {
                    // No relevant attributes so an anonymous Blank Node
                    res = new BlankNodeIDEvent(String.Empty);
                }

                // Now create the actual Subject Node
                if (res is UriReferenceEvent)
                {
                    // Resolve the Uri Reference
                    UriReferenceEvent uriref = (UriReferenceEvent)res;
                    subj = Resolve(context, uriref, element.BaseUri);
                }
                else if (res is BlankNodeIDEvent)
                {
                    BlankNodeIDEvent blank = (BlankNodeIDEvent)res;
                    if (blank.Identifier.Equals(String.Empty))
                    {
                        // Have the Graph generate a Blank Node ID
                        subj = context.Handler.CreateBlankNode();
                    }
                    else
                    {
                        // Use the supplied Blank Node ID
                        subj = context.Handler.CreateBlankNode(blank.Identifier);
                    }
                }
                else
                {
                    // Should never hit this case but required to get the Code to Compile
                    // Have the Graph generate a Blank Node ID
                    subj = context.Handler.CreateBlankNode();
                }

                // Validate the ID (if any)
                if (!ID.Equals(String.Empty))
                {
                    ValidateID(context, ID.Substring(1), subj);
                }

                // Relate the Property element to its parent
                parentEl = (ElementEvent)parent;
                pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);
                if (!context.Handler.HandleTriple(new Triple(parentEl.SubjectNode, pred, subj))) ParserHelper.Stop();

                // Reify if applicable
                if (!ID.Equals(String.Empty))
                {
                    // Resolve the Uri
                    UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                    IUriNode uri = Resolve(context, uriref, element.BaseUri);

                    Reify(context, uri, parentEl.SubjectNode, pred, subj);
                }

                // Process the rest of the Attributes
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsTypeAttribute(a, context.Namespaces))
                    {
                        // A Property Attribute giving a Type

                        // Assert a Type Triple
                        UriReferenceEvent type = new UriReferenceEvent(a.Value, a.SourceXml);
                        pred = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType));
                        obj = Resolve(context, type, element.BaseUri);

                        if (!context.Handler.HandleTriple(new Triple(parentEl.SubjectNode, pred, obj))) ParserHelper.Stop();
                    }
                    else if (RdfXmlSpecsHelper.IsPropertyAttribute(a, context.Namespaces))
                    {
                        // A Property Attribute

                        // Validate the Normalization of the Attribute Value
                        if (!a.Value.IsNormalized())
                        {
                            throw ParserHelper.Error("Encountered a Property Attribute '" + a.QName + "' whose value was not correctly normalized in Unicode Normal Form C", "Empty Property Element", a);
                        }
                        else
                        {
                            // Create the Predicate from the Attribute QName
                            pred = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveQName(a.QName, context.Namespaces, null)));

                            // Create the Object from the Attribute Value
                            if (element.Language.Equals(String.Empty))
                            {
                                obj = context.Handler.CreateLiteralNode(a.Value);
                            }
                            else
                            {
                                obj = context.Handler.CreateLiteralNode(a.Value, element.Language);
                            }

                            // Assert the Property Triple
                            if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();
                        }
                    }
                    else if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces) || RdfXmlSpecsHelper.IsNodeIDAttribute(a, context.Namespaces) || RdfXmlSpecsHelper.IsResourceAttribute(a, context.Namespaces))
                    {
                        // These have already been processed
                        // We test for them so that we can then throw ParserHelper.Errors in the final case for unexpected attributes
                    }
                    else
                    {
                        // Unexpected Attribute
                        throw ParserHelper.Error("Unexpected Attribute '" + a.QName + "' encountered on a Property Element!  Only rdf:ID, rdf:resource, rdf:nodeID and Property Attributes are permitted on Property Elements", "Empty Property Element", element);
                    }
                }
            }
            // End the current namespace scope
            PopNamespaces(context);
        }

        // Useful Functions defined as part of the Grammar
        #region Useful Grammar Helper Functions

        /// <summary>
        /// Applies the Namespace Attributes of an Element Event to the Namespace Map.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evt">Element Event.</param>
        private static void ApplyNamespaces(RdfXmlParserContext context, ElementEvent evt)
        {
            context.Namespaces.IncrementNesting();
            if (!evt.BaseUri.Equals(String.Empty))
            {
                Uri baseUri = UriFactory.Create(Tools.ResolveUri(evt.BaseUri, context.BaseUri.ToSafeString()));
                context.BaseUri = baseUri;
                if (!context.Handler.HandleBaseUri(baseUri)) ParserHelper.Stop();
            }
            foreach (NamespaceAttributeEvent ns in evt.NamespaceAttributes)
            {
                if (!context.Namespaces.HasNamespace(ns.Prefix) || !context.Namespaces.GetNamespaceUri(ns.Prefix).AbsoluteUri.Equals(ns.Uri))
                {
                    context.Namespaces.AddNamespace(ns.Prefix, UriFactory.Create(ns.Uri));
                    if (!context.Handler.HandleNamespace(ns.Prefix, UriFactory.Create(ns.Uri))) ParserHelper.Stop();
                }
            }
        }

        private static void PopNamespaces(RdfXmlParserContext context)
        {
            context.Namespaces.DecrementNesting();
        }

        /// <summary>
        /// Resolves a Uri Reference into a Uri Node against a given Base Uri.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="uriref">Uri Reference to Resolve.</param>
        /// <param name="baseUri">Base Uri to Resolve against.</param>
        /// <returns></returns>
        private IUriNode Resolve(RdfXmlParserContext context, UriReferenceEvent uriref, String baseUri)
        {
            try
            {
                if (baseUri.Equals(String.Empty)) baseUri = context.BaseUri.ToSafeString();
                if (string.Empty.Equals(uriref.Identifier))
                    baseUri = Tools.StripUriFragment(UriFactory.Create(baseUri)).ToSafeString();
                IUriNode u = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(uriref.Identifier, baseUri)));
                return u;
            }
            catch (Exception ex)
            {
                // Catch the error so we can wrap in in our own error function
                // If it fails then we know we got an error caused by this Event
                throw ParserHelper.Error(ex.Message, uriref);
            }
        }

        private IUriNode Resolve(RdfXmlParserContext context, ElementEvent el)
        {
            try
            {
                IUriNode u = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveQName(el.QName, context.Namespaces, null)));
                return u;
            }
            catch (Exception ex)
            {
                throw ParserHelper.Error(ex.Message, el);
            }
        }

        /// <summary>
        /// Reifies a Triple.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="uriref">Uri Reference for the Reified Triple.</param>
        /// <param name="subj">Subject of the Triple.</param>
        /// <param name="pred">Predicate of the Triple.</param>
        /// <param name="obj">Object of the Triple.</param>
        private void Reify(RdfXmlParserContext context, IUriNode uriref, INode subj, INode pred, INode obj)
        {
            if (!context.Handler.HandleTriple(new Triple(uriref, context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfSubject)), subj))) ParserHelper.Stop();
            if (!context.Handler.HandleTriple(new Triple(uriref, context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfPredicate)), pred))) ParserHelper.Stop();
            if (!context.Handler.HandleTriple(new Triple(uriref, context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfObject)), obj))) ParserHelper.Stop();
            if (!context.Handler.HandleTriple(new Triple(uriref, context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType)), context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfStatement))))) ParserHelper.Stop();
        }

        /// <summary>
        /// Helper function which inserts an Element back on the front of a Queue.
        /// </summary>
        /// <param name="eventlist">Queue to insert onto the Front of.</param>
        /// <param name="evt">Event to put on the front of the Queue.</param>
        private void QueueJump(IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent evt)
        {
            Stack<IRdfXmlEvent> temp = new Stack<IRdfXmlEvent>();
            temp.Push(evt);

            while (eventlist.Count > 0)
            {
                temp.Push(eventlist.Dequeue());
            }

            foreach (IRdfXmlEvent e in temp.Reverse())
            {
                eventlist.Enqueue(e);
            }
        }

        /// <summary>
        /// Applies List Expansion to the given Event.
        /// </summary>
        /// <param name="evt">Element to apply List Expansion to.</param>
        /// <returns>Uri Reference for the List Item.</returns>
        /// <remarks>List Expansion only works on Element Events.</remarks>
        private UriReferenceEvent ListExpand(IRdfXmlEvent evt, INamespaceMapper nsMapper)
        {
            if (evt is ElementEvent)
            {
                // Cast to an ElementEvent
                var e = (ElementEvent)evt;

                var nsPrefix = nsMapper.GetPrefix(new Uri(NamespaceMapper.RDF));
                // Form a new Uri Reference
                var u = new UriReferenceEvent(nsPrefix + ":_" + e.ListCounter, string.Empty);

                // Increment the List Counter
                e.ListCounter = e.ListCounter + 1;

                // Return the new Uri Reference
                return u;
            }
            else
            {
                throw ParserHelper.Error("Cannot perform List Expansion on an Event which is not an ElementEvent", evt);
            }
        }

        /// <summary>
        /// Validates that an ID is correctly formed and has only been used once in the context of a given Subject.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="id">ID to Validate.</param>
        /// <param name="subj">Subject that the ID pertains to.</param>
        private void ValidateID(RdfXmlParserContext context, String id, INode subj)
        {
            // Validate the actual ID value
            if (!XmlSpecsHelper.IsName(id))
            {
                throw new RdfParseException("The value '" + id + "' for rdf:ID is not valid, RDF IDs can only be valid Names as defined by the W3C XML Specification");
            }

            // Validate that the ID hasn't been used more than once in the same Base Uri context
            if (context.IDs.ContainsKey(id))
            {
                if (context.IDs[id].Contains(subj))
                {
                    throw new RdfParseException("An rdf:ID must be unique to a Node within a File, the rdf:ID '" + id + "' has already been used for a Node in this RDF/XML File!");
                }
                else
                {
                    context.IDs[id].Add(subj);
                }
            }
            else
            {
                context.IDs.Add(id, new List<INode>() { subj });
            }
        }

        #endregion

        #endregion

        #region Tracing Methods

        /// <summary>
        /// Tracing function used when Parse Tracing is enabled.
        /// </summary>
        /// <param name="production">Production.</param>
        private void ProductionTrace(String production)
        {
            Console.WriteLine("Production '" + production + "' called");
        }

        private void ProductionTracePartial(String production)
        {
            Console.Write("Production '" + production + "' called");
        }

        private void ProductionTracePartial(ElementEvent evt)
        {
            Console.WriteLine(" on element <" + evt.QName + ">" + (evt.Position != null ? " at Line " + evt.Position.StartLine + " Column " + evt.Position.StartPosition : String.Empty));
        }

        /// <summary>
        /// Tracing function used when Parse Tracing is enabled.
        /// </summary>
        /// <param name="production">Production.</param>
        /// <param name="evt"></param>
        private void ProductionTrace(String production, ElementEvent evt)
        {
            Console.WriteLine("Production '" + production + "' called on element <" + evt.QName + ">" + (evt.Position != null ? " at Line " + evt.Position.StartLine + " Column " + evt.Position.StartPosition : String.Empty));
        }

        #endregion

        /// <summary>
        /// Gets the String representation of the Parser which is a description of the syntax it parses.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            switch (_mode)
            {
                case RdfXmlParserMode.DOM:
                    return "RDF/XML (DOM)";
                case RdfXmlParserMode.Streaming:
                default:
                    return "RDF/XML (Streaming)";
            }
        }
        private static bool ElementHasName(ElementEvent el, string localName, string namespaceUri, RdfXmlParserContext context)
        {
            return el.LocalName.Equals(localName) && 
                   context.Namespaces.HasNamespace(el.Namespace) && 
                   context.Namespaces.GetNamespaceUri(el.Namespace).ToString().Equals(namespaceUri);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using VDS.RDF.Parsing.Contexts;
using VDS.RDF.Parsing.Events;
using VDS.RDF.Parsing.Events.RdfXml;
using VDS.RDF.Parsing.Handlers;

namespace VDS.RDF.Parsing
{
    /// <summary>
    /// Possible RDF/XML Parse Types.
    /// </summary>
    public enum RdfXmlParseType : int
    {
        /// <summary>
        /// No specific Parse Type is specified (Default Parsing Rules will be used)
        /// </summary>
        None = -1,
        /// <summary>
        /// Literal Parse Type
        /// </summary>
        Literal = 0,
        /// <summary>
        /// Resource Parse Type
        /// </summary>
        Resource = 1,
        /// <summary>
        /// Collection Parse Type
        /// </summary>
        Collection = 2,
        /// <summary>
        /// Other Parse Type
        /// </summary>
        /// <remarks>This is never used since any other Parse Type encountered is assumed to be Literal as per the RDF/XML Specification</remarks>
        Other = 3,
    }

    /// <summary>
    /// Possible RDF/XML Parser Modes.
    /// </summary>
    public enum RdfXmlParserMode
    {
        /// <summary>
        /// Uses DOM Based parsing (not fully supported under .NET Standard/Core)
        /// </summary>
        DOM,
        /// <summary>
        /// Uses Streaming Based parsing (default)
        /// </summary>
        Streaming,
    }

    /// <summary>
    /// Parser for RDF/XML syntax.
    /// </summary>
    public class RdfXmlParser
        : IRdfReader, ITraceableParser
    {

        #region Variables and Properties

        private bool _traceparsing = false;
        private RdfXmlParserMode _mode = RdfXmlParserMode.Streaming;

        /// <summary>
        /// Controls whether Parser progress will be traced by writing output to the Console.
        /// </summary>
        public bool TraceParsing
        {
            get
            {
                return _traceparsing;
            }
            set
            {
                _traceparsing = value;
            }
        }

        #endregion

        /// <summary>
        /// Creates a new RDF/XML Parser.
        /// </summary>
        public RdfXmlParser()
        {

        }

        /// <summary>
        /// Creates a new RDF/XML Parser which uses the given parsing mode.
        /// </summary>
        /// <param name="mode">RDF/XML Parse Mode.</param>
        public RdfXmlParser(RdfXmlParserMode mode)
        {
            _mode = mode;
        }

        #region Load Method Implementations

        /// <summary>
        /// Reads RDF/XML syntax from some Stream into the given Graph.
        /// </summary>
        /// <param name="g">Graph to create Triples in.</param>
        /// <param name="input">Input Stream.</param>
        public void Load(IGraph g, StreamReader input)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            Load(new GraphHandler(g), input);
        }

        /// <summary>
        /// Reads RDF/XML syntax from some Input into the given Graph.
        /// </summary>
        /// <param name="g">Graph to create Triples in.</param>
        /// <param name="input">Input to read from.</param>
        public void Load(IGraph g, TextReader input)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            Load(new GraphHandler(g), input);
        }

        /// <summary>
        /// Reads RDF/XML syntax from some File into the given Graph.
        /// </summary>
        /// <param name="g">Graph to create Triples in.</param>
        /// <param name="filename">Filename of File containg XML/RDF.</param>
        /// <remarks>Simply opens a Stream for the File then calls the other version of Load to do the actual parsing.</remarks>
        public void Load(IGraph g, string filename)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            if (filename == null) throw new RdfParseException("Cannot read RDF from a null File");

            // Open a Stream for the File and call other variant of Load
            StreamReader input = new StreamReader(File.OpenRead(filename), Encoding.UTF8);
            Load(g, input);
        }

        /// <summary>
        /// Reads RDF/XML syntax from some Stream using a RDF Handler.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="input">Input Stream.</param>
        public void Load(IRdfHandler handler, StreamReader input)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (input == null) throw new RdfParseException("Cannot read RDF from a null Stream");

            // Issue a Warning if the Encoding of the Stream is not UTF-8
            if (!input.CurrentEncoding.Equals(Encoding.UTF8))
            {
                RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result");
            }

            Load(handler, (TextReader)input);
        }

        /// <summary>
        /// Reads RDF/XML syntax from some Input using a RDF Handler.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="input">Input to read from.</param>
        public void Load(IRdfHandler handler, TextReader input)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (input == null) throw new RdfParseException("Cannot read RDF from a null TextReader");

            try
            {
                // Silverlight only supports XmlReader not the full XmlDocument API
                if (_mode == RdfXmlParserMode.DOM)
                {
                    // Load XML from Stream
                    XmlDocument doc = new XmlDocument();
                    doc.Load(input);

                    // Create a new Parser Context and Parse
                    RdfXmlParserContext context = new RdfXmlParserContext(handler, doc, _traceparsing);
                    Parse(context);
                }
                else
                {
                    RdfXmlParserContext context = new RdfXmlParserContext(handler, input);
                    Parse(context);
                }
            }
            catch (XmlException xmlEx)
            {
                // Wrap in a RDF Parse Exception
                throw new RdfParseException("Unable to Parse this RDF/XML since System.Xml was unable to parse the document, see Inner Exception for details of the XML exception that occurred", new PositionInfo(xmlEx.LineNumber, xmlEx.LinePosition), xmlEx);
            }
            catch (IOException ioEx)
            {
                // Wrap in a RDF Parse Exception
                throw new RdfParseException("Unable to Parse this RDF/XML due to an IO Exception, see Inner Exception for details of the IO exception that occurred", ioEx);
            }
            finally
            {
                try
                {
                    input.Close();
                }
                catch
                {
                    // Ignore exceptions here - just trying to clean up properly
                }
            }
        }

        /// <summary>
        /// Reads RDF/XML syntax from a file using a RDF Handler.
        /// </summary>
        /// <param name="handler">RDF Handler to use.</param>
        /// <param name="filename">File to read from.</param>
        public void Load(IRdfHandler handler, String filename)
        {
            if (handler == null) throw new RdfParseException("Cannot read RDF into a null RDF Handler");
            if (filename == null) throw new RdfParseException("Cannot read RDF from a null File");
            Load(handler, new StreamReader(File.OpenRead(filename), Encoding.UTF8));
        }

        /// <summary>
        /// Reads RDF/XML from the given XML Document.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="document">XML Document.</param>
        public void Load(IGraph g, XmlDocument document)
        {
            if (g == null) throw new RdfParseException("Cannot read RDF into a null Graph");
            if (document == null) throw new RdfParseException("Cannot read RDF from a null XML Document");

            try 
            {
                // Create a new Parser Context and Parse
                RdfXmlParserContext context = new RdfXmlParserContext(g, document, _traceparsing);
                Parse(context);
            }
            catch (XmlException xmlEx)
            {
                // Wrap in a RDF Parse Exception
                throw new RdfParseException("Unable to Parse this RDF/XML since System.Xml was unable to parse the document into a DOM Tree", xmlEx);
            }
            catch (IOException ioEx)
            {
                // Wrap in a RDF Parse Exception
                throw new RdfParseException("Unable to Parse this RDF/XML due to an IO Exception", ioEx);
            }
            catch (Exception)
            {
                // Throw unexpected errors upwards as-is
                throw;
            }
        }

        #endregion

        /// <summary>
        /// Helper Method for raising the <see cref="RdfXmlParser.Warning">Warning</see> event.
        /// </summary>
        /// <param name="warning">Warning Message.</param>
        private void RaiseWarning(String warning)
        {
            RdfReaderWarning d = Warning;
            if (d != null)
            {
                d(warning);
            }
        }

        /// <summary>
        /// Event which Readers can raise when they notice syntax that is ambigious/deprecated etc which can still be parsed
        /// </summary>
        public event RdfReaderWarning Warning;

        /// <summary>
        /// Function which does the actual Parsing by invoking the various steps of the Parser.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        private void Parse(RdfXmlParserContext context)
        {
            try
            {
                context.Handler.StartRdf();

                // Trace Parser Information
                if (_traceparsing)
                {
                    Console.WriteLine("Trace Format is as follows:");
                    Console.WriteLine("NestingLevel EventType [Description]");
                    Console.WriteLine();
                }

                // Define XML namespace
                context.Handler.HandleNamespace("xml", UriFactory.Create(XmlSpecsHelper.NamespaceXml));
                context.Namespaces.AddNamespace("xml", UriFactory.Create(XmlSpecsHelper.NamespaceXml));

                // Process the Queue
                ProcessEventQueue(context);

                context.Handler.EndRdf(true);
            }
            catch (RdfParsingTerminatedException)
            {
                context.Handler.EndRdf(true);
                // Discard this - it justs means the Handler told us to stop
            }
            catch
            {
                context.Handler.EndRdf(false);
                throw;
            }
        }

        #region Queue Processing

        /// <summary>
        /// Starts the Parsing of the flattened Event Tree by calling the appropriate Grammar Production based on the type of the First Event in the Queue.
        /// </summary>
        private void ProcessEventQueue(RdfXmlParserContext context)
        {
            // Get First Event
            IRdfXmlEvent first = context.Events.Dequeue();
            bool setBaseUri = (context.BaseUri == null);
            Uri baseUri;

            if (first is RootEvent rootEvent)
            {
                GrammarProductionDoc(context, rootEvent);
                if (setBaseUri && !((RootEvent)first).BaseUri.Equals(String.Empty))
                {
                    baseUri = UriFactory.Create(Tools.ResolveUri(((RootEvent)first).BaseUri, String.Empty));
                    context.BaseUri = baseUri;
                    if (!context.Handler.HandleBaseUri(baseUri)) ParserHelper.Stop();
                }
            }
            else
            {
                GrammarProductionRDF(context, (ElementEvent)first);
                if (setBaseUri && !((ElementEvent)first).BaseUri.Equals(String.Empty))
                {
                    baseUri = UriFactory.Create(Tools.ResolveUri(((ElementEvent)first).BaseUri, String.Empty));
                    context.BaseUri = baseUri;
                    if (!context.Handler.HandleBaseUri(baseUri)) ParserHelper.Stop();
                }
            }

        }

        #endregion

        #region Grammar Productions

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'doc'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="root">Root Event to start applying Productions from.</param>
        private void GrammarProductionDoc(RdfXmlParserContext context, RootEvent root)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTrace("Doc");
            }

            // Call the RDF Production on the first child if it's an rdf:RDF element
            // if (root.Children[0].QName.Equals("rdf:RDF") || root.Children[0].QName.Equals(":RDF"))
            String localName = root.Children[0].LocalName;
            String prefix = root.Children[0].Namespace;
            if (localName.Equals("RDF") && 
                ((context.Namespaces.HasNamespace(prefix) && context.Namespaces.GetNamespaceUri(prefix).AbsoluteUri.Equals(NamespaceMapper.RDF)) 
                 || root.DocumentElement.NamespaceAttributes.Any(ns => ns.Prefix.Equals(prefix) && ns.Uri.Equals(NamespaceMapper.RDF))))
            {
                GrammarProductionRDF(context, root.Children[0]);
            }
            else
            {
                // No rdf:RDF element
                // Drop first element from Queue (which will be a RootEvent)
                // Skip straight to NodeElementList production
                // context.Events.Dequeue();
                GrammarProductionNodeElementList(context, context.Events);
            }
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'RDF'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="element">RDF Element to apply Production to.</param>
        private void GrammarProductionRDF(RdfXmlParserContext context, ElementEvent element)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTrace("RDF", element);
            }

            // Check Uri is correct
            String localName = element.LocalName;
            String prefix = element.Namespace;
            if (localName.Equals("RDF") || 
                ((context.Namespaces.HasNamespace(prefix) && context.Namespaces.GetNamespaceUri(prefix).AbsoluteUri.Equals(NamespaceMapper.RDF)) 
                 || element.NamespaceAttributes.Any(ns => ns.Prefix.Equals(prefix) && ns.Uri.Equals(NamespaceMapper.RDF))))
            {
                // This is OK
            }
            else
            {
                throw ParserHelper.Error("Unexpected Node '" + element.QName + "', an 'rdf:RDF' node was expected", "RDF", element);
            }
            // Check has no Attributes
            if (element.Attributes.Count > 0)
            {
                throw ParserHelper.Error("Root Node should not contain any attributes other than XML Namespace Declarations", "RDF", element);
            }

            // Start a new namespace scope
            ApplyNamespaces(context, element);

            // Make sure we discard the current ElementEvent which will be at the front of the queue
            context.Events.Dequeue();

            // Build a virtual Sublist of all Nodes up to the matching EndElement to avoid copying the events around too much
            IEventQueue<IRdfXmlEvent> subevents = new SublistEventQueue<IRdfXmlEvent>(context.Events, 1);

            // Call the NodeElementList Grammer Production
            GrammarProductionNodeElementList(context, subevents);

            // Next Event in queue should be an EndElementEvent or we Error
            IRdfXmlEvent next = context.Events.Dequeue();
            if (!(next is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', an EndElementEvent was expected", "RDF", element);
            }

            // Exit the current namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'nodeElementList'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events to apply the Production to.</param>
        private void GrammarProductionNodeElementList(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTrace("Node Element List");
            }

            IRdfXmlEvent next;

            // Want to break up into a number of sublists
            while (eventlist.Count > 0) 
            {
                // Create a new Sublist
                IEventQueue<IRdfXmlEvent> subevents = new EventQueue<IRdfXmlEvent>();
                int nesting = 0;

                // Gather the Sublist taking account of nesting
                do
                {
                    next = eventlist.Dequeue();
                    subevents.Enqueue(next);

                    if (next is ElementEvent)
                    {
                        nesting++;
                    }
                    else if (next is EndElementEvent)
                    {
                        nesting--;
                    }
                } while (nesting > 0);

                // Call the next Grammar Production
                GrammarProductionNodeElement(context, subevents);
            }
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'nodeElement'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Node Element and its Children to apply the Production to.</param>
        private void GrammarProductionNodeElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Node Element");
            }

            // Get First Event in the Queue
            IRdfXmlEvent first = eventlist.Dequeue();

            // Check it's an ElementEvent
            if (!(first is ElementEvent))
            {
                // Unexpected Event
                throw ParserHelper.Error("Expected an ElementEvent but encountered a '" + first.GetType().ToString() + "'", "Node Element", first);
            }

            // Check it has a valid Uri
            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);
            // Start a new namespace scope
            ApplyNamespaces(context, element);
            if (!RdfXmlSpecsHelper.IsNodeElementUri(context.Namespaces.GetNamespaceUri(element.Namespace), element.LocalName))
            {
                throw ParserHelper.Error("A Node Element was encountered with an invalid URI '" + element.QName + "' \nCore Syntax Terms, Old Syntax Terms and rdf:li cannot be used as Node Element URIs", "Node Element", element);
            }

            // Check the set of Attributes is Valid
            int limitedAttributesFound = 0;
            String ID = String.Empty;
            foreach (AttributeEvent attr in element.Attributes)
            {
                if (RdfXmlSpecsHelper.IsIDAttribute(attr, context.Namespaces))
                {
                    ID = attr.Value;
                    limitedAttributesFound++;

                    // Set the Subject
                    element.Subject = new UriReferenceEvent("#" + attr.Value, attr.SourceXml);
                }
                else if (RdfXmlSpecsHelper.IsNodeIDAttribute(attr, context.Namespaces))
                {
                    limitedAttributesFound++;

                    // Validate the Node ID
                    if (!XmlSpecsHelper.IsName(attr.Value))
                    {
                        throw ParserHelper.Error("The value '" + attr.Value + "' for rdf:nodeID is not valid, RDF Node IDs can only be valid Names as defined by the W3C XML Specification", "Node Element", attr);
                    }

                    // Set the Subject
                    element.Subject = new BlankNodeIDEvent(attr.Value, attr.SourceXml);
                }
                else if (RdfXmlSpecsHelper.IsAboutAttribute(attr, context.Namespaces))
                {
                    limitedAttributesFound++;

                    // Set the Subject
                    element.Subject = new UriReferenceEvent(attr.Value, attr.SourceXml);
                }
                else if (RdfXmlSpecsHelper.IsPropertyAttribute(attr, context.Namespaces))
                {
                    // Don't need to do anything here yet
                }
                else
                {
                    // Unknown and Unexpected Attribute Type
                    throw ParserHelper.Error("Unexpected Attribute '" + attr.QName + "' was encountered!", "Node Element", element);
                }

                // Can't have more than 1 of ID, Node ID or About Attributes
                if (limitedAttributesFound > 1)
                {
                    throw ParserHelper.Error("A Node Element can only have 1 of the following attributes: rdf:id, rdf:nodeID, rdf:about", "Node Element", element);
                }
            }

            // Generate a Blank Node ID if our Subject is empty
            if (element.Subject == null)
            {
                element.Subject = new BlankNodeIDEvent(element.SourceXml);
            }

            // Add statements as necessary
            INode subj, pred, obj;
            if (element.SubjectNode == null)
            {
                // Don't always want to drop in here since the SubjectNode may already be set elsewhere
                if (element.Subject is UriReferenceEvent)
                {
                    UriReferenceEvent uri = (UriReferenceEvent)element.Subject;
                    subj = Resolve(context, uri, element.BaseUri);
                }
                else if (element.Subject is BlankNodeIDEvent)
                {
                    BlankNodeIDEvent blank = (BlankNodeIDEvent)element.Subject;

                    // Select whether we need to generate an ID or if there's one given for the Blank Node
                    // Note that we let the Graph class handle generation of IDs
                    if (blank.Identifier.Equals(String.Empty))
                    {
                        subj = context.Handler.CreateBlankNode();
                    }
                    else
                    {
                        subj = context.Handler.CreateBlankNode(blank.Identifier);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Unexpected Subject generated for a Triple", "Node Element", element.Subject);
                }
            } 
            else
            {
                subj = element.SubjectNode;
            }

            // Set the Subject Node property of the Event for later reuse
            element.SubjectNode = subj;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID, subj);
            }

            //if (!element.QName.Equals("rdf:Description") && !element.QName.Equals(":Description"))
            if (!ElementHasName(element, "Description", NamespaceMapper.RDF, context))
            {
                // Assert a Triple regarding Type
                pred = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType));
                obj = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);
                if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();
            }

            // Go back over Attributes looking for property attributes
            foreach (AttributeEvent attr in element.Attributes)
            {
                if (RdfXmlSpecsHelper.IsPropertyAttribute(attr, context.Namespaces))
                {
                    if (attr.Namespace.Equals(NamespaceMapper.RDF) && attr.LocalName.Equals("type"))
                    //if (attr.QName.Equals("rdf:type"))
                    {
                        // Generate a Type Triple
                        pred = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType));

                        // Resolve URIRef into a Uri Node
                        UriReferenceEvent uriref = new UriReferenceEvent(attr.Value, attr.SourceXml);
                        obj = Resolve(context, uriref, element.BaseUri);

                        if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();
                    }
                    else
                    {
                        // Generate a Property Triple
                        pred = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveQName(attr.QName, context.Namespaces, null)));

                        // Add Language to Literal if necessary
                        if (element.Language.Equals(String.Empty))
                        {
                            obj = context.Handler.CreateLiteralNode(attr.Value);
                        }
                        else
                        {
                            obj = context.Handler.CreateLiteralNode(attr.Value, element.Language);
                        }

                        if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();
                    }
                }
            }

            // Handle Child Elements
            IEventQueue<IRdfXmlEvent> children = new EventQueue<IRdfXmlEvent>();
            while (eventlist.Count > 1)
            {
                children.Enqueue(eventlist.Dequeue());
            }
            if (children.Count > 0) GrammarProductionPropertyElementList(context, children, element);

            // Check Last Event in queue is an EndElement event
            IRdfXmlEvent last = eventlist.Dequeue();
            if (!(last is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + last.GetType().ToString() + "', expected an EndElement Event", "NodeElement", last);
            }

            // Exit the current namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'propertyEltList'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events to apply the Production to.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Elements.</param>
        private void GrammarProductionPropertyElementList(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTrace("Property Element List");
            }

            IRdfXmlEvent next;

            // Want to break up into a number of sublists
            while (eventlist.Count > 0)
            {
                // Create a new Sublist
                IEventQueue<IRdfXmlEvent> subevents = new EventQueue<IRdfXmlEvent>();
                int nesting = 0;

                // Gather the Sublist taking account of nesting
                do
                {
                    next = eventlist.Dequeue();
                    subevents.Enqueue(next);

                    if (next is ElementEvent)
                    {
                        nesting++;
                    }
                    else if (next is EndElementEvent)
                    {
                        nesting--;
                    }
                } while (nesting > 0);

                // Call the next Grammar Production
                if (subevents.Count > 0) GrammarProductionPropertyElement(context, subevents, parent);
            }
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'propertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionPropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Property Element");
            }

            // Get first thing from the Queue
            IRdfXmlEvent first = eventlist.Dequeue();
            ElementEvent element;

            // Must be an ElementEvent
            if (!(first is ElementEvent))
            {
                // Unexpected Event
                throw ParserHelper.Error("Expected an ElementEvent but encountered a '" + first.GetType().ToString() + "'", "PropertyElement", first);
            }

            // Validate the Uri
            element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start a new namespace scope
            ApplyNamespaces(context, element);
            if (!RdfXmlSpecsHelper.IsPropertyElement(element, context.Namespaces))
            {
                // Invalid Uri
                throw ParserHelper.Error("A Property Element was encountered with an invalid URI '" + element.QName + "'\nCore Syntax Terms, Old Syntax Terms and rdf:Description cannot be used as Property Element URIs", "PropertyElement", element);
            }

            // List Expansion
            if (RdfXmlSpecsHelper.IsLiElement(element, context.Namespaces))
            {
                var u = ListExpand(parent, context.Namespaces);
                element.SetUri(u, context.Namespaces);
            }

            // Need to select what to do based on the Type of Property Element
            IRdfXmlEvent next = eventlist.Peek();

            // This call inserts the first element back at the head of the queue
            // Most of the sub-productions here need this
            // Would ideally use Stacks instead of Queues but Queues make more sense for most of the Parsing
            QueueJump(eventlist, first);

            if (element.ParseType == RdfXmlParseType.None)
            {
                // A Resource/Literal Property Element

                if (next is ElementEvent)
                {
                    // Resource
                    GrammarProductionResourcePropertyElement(context, eventlist, parent);
                }
                else if (next is TextEvent)
                {
                    // Literal
                    GrammarProductionLiteralPropertyElement(context, eventlist, parent);
                }
                else if (next is EndElementEvent)
                {
                    // An Empty Property Element
                    GrammarProductionEmptyPropertyElement(context, element, parent);
                }
                else
                {
                    // Error
                    throw ParserHelper.Error("An Element which should be Parsed with the Default Parsing Rules was encountered without a valid subsequent Event - Parser cannot proceed!", "Property Element", element);
                }
            }
            else if (element.ParseType == RdfXmlParseType.Literal)
            {
                // A rdf:parseType="Literal" Property Element

                GrammarProductionParseTypeLiteralPropertyElement(context, eventlist, parent);
            }
            else if (element.ParseType == RdfXmlParseType.Collection)
            {
                // A rdf:parseType="Collection" Property Element

                GrammarProductionParseTypeCollectionPropertyElement(context, eventlist, parent);
            }
            else if (element.ParseType == RdfXmlParseType.Resource)
            {
                // A rdf:parseType="Resource" Property Element

                GrammarProductionParseTypeResourcePropertyElement(context, eventlist, parent);
            }
            else if (next is EndElementEvent)
            {
                // An Empty Property Element
                GrammarProductionEmptyPropertyElement(context, element, parent);
            }
            else
            {
                // Error
                throw ParserHelper.Error("An Element without a known Parse Type was encountered Or the Parser was unable to determine what to do based on the subsequent event - Parser cannot proceed!", "Node Element", element);
            }
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'resourcePropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Resource Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionResourcePropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Resource Property Element");
            }

            // Cast to an ElementEvent
            // We don't validate type here since we know this will be an ElementEvent because the calling function
            // will have done this validation previously
            IRdfXmlEvent first = eventlist.Dequeue();
            IRdfXmlEvent next = eventlist.Peek();
            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start new namespace scope
            ApplyNamespaces(context, element);

            // Only allowed one attribute max which must be an ID attribute
            String ID = String.Empty;
            if (element.Attributes.Count > 1)
            {
                throw ParserHelper.Error("A Resource Property Element contains too many Attributes, only rdf:ID is permitted", element);
            }
            else if (element.Attributes.Count == 1)
            {
                if (!RdfXmlSpecsHelper.IsIDAttribute(element.Attributes.First(), context.Namespaces))
                {
                    throw ParserHelper.Error("A Resource Property Element was encountered with a single attribute which was not rdf:ID, only rdf:ID is permitted", element);
                }
                else
                {
                    ID = element.Attributes.First().Value;
                }
            }

            // Next must be an ElementEvent
            if (!(next is ElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', expected an ElementEvent as the first Event in a Resource Property Elements Event list", next);
            }

            // Get list of Sub Events
            IEventQueue<IRdfXmlEvent> subevents = new EventQueue<IRdfXmlEvent>();
            while (eventlist.Count > 1)
            {
                subevents.Enqueue(eventlist.Dequeue());
            }
            GrammarProductionNodeElement(context, subevents);

            // Check Last is an EndElementEvent
            IRdfXmlEvent last = eventlist.Dequeue();
            if (!(last is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + last.GetType().ToString() + "', expected an EndElement Event", last);
            }

            // Now we can generate the relevant RDF
            INode subj, pred, obj;

            // Validate the Type of the Parent
            if (!(parent is ElementEvent))
            {
                throw ParserHelper.Error("Unexpected Parent Event '" + parent.GetType().ToString() + "', expected an ElementEvent", parent);
            }
            ElementEvent parentEl = (ElementEvent)parent;

            // Get the Subject Node from the Parent
            subj = parentEl.SubjectNode;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID, subj);
            }

            // Create a Predicate from this Element
            pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

            // Get the Object Node from the Child Node
            ElementEvent child = (ElementEvent)next;
            obj = child.SubjectNode;

            // Assert the Triple
            if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

            // Add Reification where appropriate
            if (element.Attributes.Count == 1)
            {
                // Must be an rdf:ID attribute as we've validated this earlier

                // Get the Attribute Event and generate a Uri from it
                AttributeEvent attr = element.Attributes.First();
                UriReferenceEvent uriref = new UriReferenceEvent("#" + attr.Value, attr.SourceXml);
                IUriNode uri = Resolve(context, uriref, element.BaseUri);

                Reify(context, uri, subj, pred, obj);
            }

            // End current namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'literalPropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Literal Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionLiteralPropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Literal Property Element");
            }

            // Get the 3 Events (should only be three)
            IRdfXmlEvent first, middle, last;
            first = eventlist.Dequeue();
            middle = eventlist.Dequeue();
            last = eventlist.Dequeue();

            // If Queue is non-empty then Error
            if (eventlist.Count > 0)
            {
                throw ParserHelper.Error("Too many events encountered while trying to parse a Literal Property Element", first);
            }

            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start a new namespace sscope
            ApplyNamespaces(context, element);

            // Validate that the middle event is a TextEvent
            if (!(middle is TextEvent))
            {
                throw ParserHelper.Error("Unexpected event '" + middle.GetType().ToString() + "', expected a TextEvent in a Literal Property Element", middle);
            }
            TextEvent text = (TextEvent)middle;

            // Validate the Attributes
            String ID = String.Empty;
            String datatype = String.Empty;
            if (element.Attributes.Count > 2)
            {
                throw ParserHelper.Error("A Literal Property Element contains too many attributes, only rdf:ID and rdf:datatype are permitted", element);
            }
            else
            {
                // Only rdf:ID and rdf:datatype allowed
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces)) {
                        ID = "#" + a.Value;
                    }
                    else if (RdfXmlSpecsHelper.IsDataTypeAttribute(a, context.Namespaces))
                    {
                        datatype = a.Value;
                    } 
                    else 
                    {
                        throw ParserHelper.Error("A Literal Property Element contains an unexpected attribute, only rdf:ID and rdf:datatype are permitted", element);
                    }
                }
            }

            // Create the Nodes for the Graph
            INode subj, pred, obj;
            
            // Get the Subject from the Parent
            ElementEvent parentEl = (ElementEvent)parent;
            subj = parentEl.SubjectNode;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID.Substring(1), subj);
            }

            // Create a Predicate from this Element
            pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

            // Create an Object from the Text Event
            if (datatype.Equals(String.Empty))
            {
                // No Type with possible Language
                if (element.Language.Equals(String.Empty))
                {
                    obj = context.Handler.CreateLiteralNode(text.Value);
                }
                else
                {
                    obj = context.Handler.CreateLiteralNode(text.Value, element.Language);
                }
            }
            else
            {
                // Typed

                // Resolve the Datatype Uri
                UriReferenceEvent dtref = new UriReferenceEvent(datatype, String.Empty);
                IUriNode dturi = Resolve(context, dtref, element.BaseUri);

                obj = context.Handler.CreateLiteralNode(text.Value, dturi.Uri);
            }

            // Assert the Triple
            if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

            // Reify if applicable
            if (!ID.Equals(String.Empty))
            {
                // Resolve the Uri
                UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                IUriNode uri = Resolve(context, uriref,element.BaseUri);

                Reify(context, uri, subj, pred, obj);
            }

            // End namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'parseTypeLiteralPropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Literal Parse Type Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionParseTypeLiteralPropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Parse Type Literal Property Element");
            }

            // Get the first Event, should be an ElementEvent
            // Type checking is done by the Parent Production
            IRdfXmlEvent first = eventlist.Dequeue();
            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start new namespace scope
            ApplyNamespaces(context, element);

            // Validate Attributes
            String ID = String.Empty;
            if (element.Attributes.Count > 2)
            {
                // Can't be more than 2 Attributes, only allowed an optional rdf:ID and a required rdf:parseType
                throw ParserHelper.Error("An Property Element with Parse Type 'Literal' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Literal'", "Parse Type Literal Property Element", element);
            }
            else
            {
                // Check the attributes that do exist
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces))
                    {
                        ID = "#" + a.Value;
                    }
                    else if (RdfXmlSpecsHelper.IsParseTypeAttribute(a, context.Namespaces))
                    {
                        // OK
                    }
                    else
                    {
                        // Invalid Attribute
                        throw ParserHelper.Error("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Literal'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Literal'", "Parse Type Literal Property Element", element);
                    }
                }
            }

            // Get the next event in the Queue which should be a TypedLiteralEvent
            // Validate this
            IRdfXmlEvent lit = eventlist.Dequeue();
            if (!(lit is TypedLiteralEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + lit.GetType().ToString() + "', expected a TypedLiteralEvent after a Property Element with Parse Type 'Literal'", "Parse Type Literal Property Element", lit);
            }

            // Get the Subject from the Parent
            INode subj, pred, obj;
            ElementEvent parentEl = (ElementEvent) parent;
            subj = parentEl.SubjectNode;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID.Substring(1), subj);
            }

            // Create the Predicate from the Element
            pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

            // Create the Object from the Typed Literal
            TypedLiteralEvent tlit = (TypedLiteralEvent)lit;
            // At the moment we're just going to ensure that we normalize it to Unicode Normal Form C
            String xmllit = tlit.Value;
            xmllit = xmllit.Normalize();
            obj = context.Handler.CreateLiteralNode(xmllit, UriFactory.Create(tlit.DataType));

            // Assert the Triple
            if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

            // Reify if applicable
            if (!ID.Equals(String.Empty))
            {
                // Resolve the Uri
                UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                IUriNode uri = Resolve(context, uriref,element.BaseUri);

                Reify(context, uri, subj, pred, obj);
            }

            // Check for the last thing being an EndElement Event
            IRdfXmlEvent next = eventlist.Dequeue();
            if (!(next is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', expected an EndElementEvent to terminate a Parse Type Literal Property Element!", "Parse Type Literal Property Element", next);
            }

            // End the namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'parseTypeResourcePropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Resource Parse Type Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionParseTypeResourcePropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Parse Type Resource Property Element");
            }

            // Get the first Event, should be an ElementEvent
            // Type checking is done by the Parent Production
            IRdfXmlEvent first = eventlist.Dequeue();
            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start a new namespace scope
            ApplyNamespaces(context, element);

            // Validate Attributes
            String ID = String.Empty;
            if (element.Attributes.Count > 2)
            {
                // Can't be more than 2 Attributes, only allowed an optional rdf:ID and a required rdf:parseType
                throw ParserHelper.Error("An Property Element with Parse Type 'Resource' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Resource'", "Parse Type Resource Property Element", element);
            }
            else
            {
                // Check the attributes that do exist
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces))
                    {
                        ID = "#" + a.Value;
                    }
                    else if (RdfXmlSpecsHelper.IsParseTypeAttribute(a, context.Namespaces))
                    {
                        // OK
                    }
                    else
                    {
                        // Invalid Attribute
                        throw ParserHelper.Error("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Resource'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Resource'", "Parse Type Resource Property Element", element);
                    }
                }
            }

            // Add a Triple about this
            INode subj, pred, obj;

            // Get the Subject from the Parent
            ElementEvent parentEvent = (ElementEvent)parent;
            subj = parentEvent.SubjectNode;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID.Substring(1), subj);
            }

            // Create the Predicate from the Element
            pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

            // Generate a Blank Node ID for the Object
            obj = context.Handler.CreateBlankNode();

            // Assert
            if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

            // Reify if applicable
            if (!ID.Equals(String.Empty))
            {
                // Resolve the Uri
                UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                IUriNode uri = Resolve(context, uriref,element.BaseUri);

                Reify(context, uri, subj, pred, obj);
            }

            // Get the next event in the Queue which should be either an Element Event or a End Element Event
            // Validate this
            IRdfXmlEvent next = eventlist.Dequeue();
            if (next is EndElementEvent)
            {
                // Content is Empty so nothing else to do
            }
            else if (next is ElementEvent)
            {
                // Non-Empty Content so need to build a sequence of new events
                IEventQueue<IRdfXmlEvent> subEvents = new EventQueue<IRdfXmlEvent>();

                // Create an rdf:Description event as the container
                var prefix = context.Namespaces.GetPrefix(new Uri(NamespaceMapper.RDF));
                var descrip = new ElementEvent(prefix+":Description", element.BaseUri, string.Empty);
                descrip.Subject = new BlankNodeIDEvent(string.Empty);
                descrip.SubjectNode = obj;
                subEvents.Enqueue(descrip);

                // Add the current element we were looking at
                subEvents.Enqueue(next);

                // Add rest of events in list (except the last)
                while (eventlist.Count > 1)
                {
                    subEvents.Enqueue(eventlist.Dequeue());
                }

                // Terminate with an EndElement Event
                subEvents.Enqueue(new EndElementEvent());

                // Process with Node Element Production
                GrammarProductionNodeElement(context, subEvents);

                // Get the last thing in the List
                next = eventlist.Dequeue();
            }
            else
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', expected an ElementEvent or EndElementEvent after a Parse Type Resource Property Element!", "Parse Type Resource Property Element", next);
            }

            // Check for the last thing being an EndElement Event
            if (!(next is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', expected an EndElementEvent to terminate a Parse Type Resource Property Element!", "Parse Type Resource Property Element", next);
            }

            // End the namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'parseTypeCollectionPropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="eventlist">Queue of Events that make up the Collection Parse Type Property Element and its Children.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionParseTypeCollectionPropertyElement(RdfXmlParserContext context, IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTracePartial("Parse Type Collection Property Element");
            }

            // Get the first Event, should be an ElementEvent
            // Type checking is done by the Parent Production
            IRdfXmlEvent first = eventlist.Dequeue();
            ElementEvent element = (ElementEvent)first;
            if (_traceparsing) ProductionTracePartial(element);

            // Start a new namespace scope
            ApplyNamespaces(context, element);

            // Validate Attributes
            String ID = String.Empty;
            if (element.Attributes.Count > 2)
            {
                // Can't be more than 2 Attributes, only allowed an optional rdf:ID and a required rdf:parseType
                throw ParserHelper.Error("An Property Element with Parse Type 'Collection' was encountered with too many Attributes.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Collection'", "Parse Type Collection Property Element", element);
            }
            else
            {
                // Check the attributes that do exist
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces))
                    {
                        ID = "#" + a.Value;
                    }
                    else if (RdfXmlSpecsHelper.IsParseTypeAttribute(a, context.Namespaces))
                    {
                        // OK
                    }
                    else
                    {
                        // Invalid Attribute
                        throw ParserHelper.Error("Unexpected Attribute '" + a.QName + "' was encountered on a Property Element with Parse Type 'Collection'.  Only rdf:ID and rdf:parseType are allowed on Property Elements with Parse Type 'Collection'", "Parse Type Collection Property Element", element);
                    }
                }
            }

            // Build sequence of Blank Nodes
            IRdfXmlEvent next;
            IRdfXmlEvent nodeElement;

            Queue<ElementEvent> seqNodes = new Queue<ElementEvent>();
            while (eventlist.Count > 1)
            {
                #region Node Element Processing
                // Need to process the Node Element first

                // Create a new Sublist
                IEventQueue<IRdfXmlEvent> subevents = new EventQueue<IRdfXmlEvent>();
                int nesting = 0;
                nodeElement = eventlist.Peek();

                // Add Node Element to sequence
                seqNodes.Enqueue((ElementEvent)nodeElement);

                // Gather the Sublist taking account of nesting
                do
                {
                    next = eventlist.Dequeue();
                    subevents.Enqueue(next);

                    if (next is ElementEvent)
                    {
                        nesting++;
                    }
                    else if (next is EndElementEvent)
                    {
                        nesting--;
                    }
                } while (nesting > 0);

                // Call the next Grammar Production
                GrammarProductionNodeElement(context, subevents);

                #endregion
            }

            // Build a triple expressing the start of the list (which may be an empty list)
            INode subj, pred, obj;
            INode firstPred, restPred;
            INode b1, b2;

            // Subject comes from Parent
            ElementEvent parentElement = (ElementEvent)parent;
            subj = parentElement.SubjectNode;

            // Validate the ID (if any)
            if (!ID.Equals(String.Empty))
            {
                ValidateID(context, ID.Substring(1), subj);
            }

            // Predicate from the Element
            pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

            if (seqNodes.Count > 0)
            {
                // Non-empty list
                ElementEvent node;

                // Get first Element from the Queue
                node = seqNodes.Dequeue();

                // Object is first thing in the Sequence which we create a Blank Node for
                b1 = context.Handler.CreateBlankNode();

                // Assert
                if (!context.Handler.HandleTriple(new Triple(subj, pred, b1))) ParserHelper.Stop();

                // Reify if applicable
                if (!ID.Equals(String.Empty))
                {
                    // Resolve the Uri
                    UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                    IUriNode uri = Resolve(context, uriref, element.BaseUri);

                    Reify(context, uri, subj, pred, b1);
                }

                // Set the first element in the list
                subj = b1;
                firstPred = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfListFirst));
                if (!context.Handler.HandleTriple(new Triple(subj, firstPred, node.SubjectNode))) ParserHelper.Stop();

                // Middle elements of the list
                restPred = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfListRest));
                while (seqNodes.Count >= 1)
                {
                    node = seqNodes.Dequeue();

                    // Set Node 2 to be the rest of the previous items list
                    b2 = context.Handler.CreateBlankNode();
                    if (!context.Handler.HandleTriple(new Triple(b1, restPred, b2))) ParserHelper.Stop();

                    // Set Node 2 to be the start of it's own list
                    if (!context.Handler.HandleTriple(new Triple(b2, firstPred, node.SubjectNode))) ParserHelper.Stop();

                    b1 = b2;
                }

                // Set last element of the list to have its rest as nil
                if (!context.Handler.HandleTriple(new Triple(b1, restPred, context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfListNil))))) ParserHelper.Stop();
            }
            else
            {
                // Empty list

                // Object is therefore rdf:nil
                obj = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfListNil));

                // Assert
                if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

                // Reify if applicable
                if (!ID.Equals(String.Empty))
                {
                    // Resolve the Uri
                    UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                    IUriNode uri = Resolve(context, uriref, element.BaseUri);

                    Reify(context, uri, subj, pred, obj);
                }
            }

            // Check last event is an EndElementEvent
            next = eventlist.Dequeue();
            if (!(next is EndElementEvent))
            {
                throw ParserHelper.Error("Unexpected Event '" + next.GetType().ToString() + "', expected an EndElementEvent to terminate a Parse Type Collection Property Element!", "Parse Type Collection Property Element", next);
            }

            // End the current namespace scope
            PopNamespaces(context);
        }

        /// <summary>
        /// Implementation of the RDF/XML Grammar Production 'emptyPropertyElt'.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="element">Element Event for the Empty Property Element.</param>
        /// <param name="parent">Parent Event (ie. Node) of the Property Element.</param>
        private void GrammarProductionEmptyPropertyElement(RdfXmlParserContext context, ElementEvent element, IRdfXmlEvent parent)
        {
            // Tracing
            if (_traceparsing)
            {
                ProductionTrace("Empty Property Element");
            }

            // Start a new namespace scope
            ApplyNamespaces(context, element);

            INode subj, pred, obj;
            ElementEvent parentEl;

            // Are there any attributes OR Only a rdf:ID attribute?
            if (element.Attributes.Count == 0 || (element.Attributes.Count == 1 && RdfXmlSpecsHelper.IsIDAttribute(element.Attributes[0], context.Namespaces)))
            {
                // No Attributes/Only rdf:ID

                // Get the Subject Node from the Parent
                parentEl = (ElementEvent)parent;
                subj = parentEl.SubjectNode;

                // Create the Predicate from the Element
                pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);

                // Create the Object
                if (!element.Language.Equals(String.Empty))
                {
                    obj = context.Handler.CreateLiteralNode(String.Empty, element.Language);
                }
                else
                {
                    obj = context.Handler.CreateLiteralNode(String.Empty);
                }

                // Make the Assertion
                if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();

                // Reifiy if applicable
                if (element.Attributes.Count == 1)
                {
                    // Validate the ID
                    ValidateID(context, element.Attributes[0].Value, subj);

                    // Resolve the Uri
                    UriReferenceEvent uriref = new UriReferenceEvent("#" + element.Attributes[0].Value, String.Empty);
                    IUriNode uri = Resolve(context, uriref, element.BaseUri);

                    Reify(context, uri, subj, pred, obj);
                }

            }
            else if (element.Attributes.Count > 0 && element.Attributes.Count(a => RdfXmlSpecsHelper.IsDataTypeAttribute(a, context.Namespaces))== 1)
            {
                // Should be processed as a Typed Literal Event instead
                EventQueue<IRdfXmlEvent> temp = new EventQueue<IRdfXmlEvent>();
                temp.Enqueue(element);
                temp.Enqueue(new TextEvent(String.Empty, String.Empty));
                temp.Enqueue(new EndElementEvent());
                GrammarProductionLiteralPropertyElement(context, temp, parent);
            }
            else
            {

                // Check through attributes
                IRdfXmlEvent res = null;

                // Check through attributes to decide the Subject of the Triple(s)
                String ID = String.Empty;
                int limitedAttributes = 0;
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsResourceAttribute(a, context.Namespaces))
                    {
                        // An rdf:resource attribute so a Uri Reference
                        res = new UriReferenceEvent(a.Value, a.SourceXml);
                        limitedAttributes++;
                    }
                    else if (RdfXmlSpecsHelper.IsNodeIDAttribute(a, context.Namespaces))
                    {
                        // An rdf:nodeID attribute so a Blank Node

                        // Validate the Node ID
                        if (!XmlSpecsHelper.IsName(a.Value))
                        {
                            // Invalid nodeID
                            throw ParserHelper.Error("The value '" + a.Value + "' for rdf:nodeID is not valid, RDF Node IDs can only be valid Names as defined by the W3C XML Specification", "Empty Property Element", a);
                        }
                        res = new BlankNodeIDEvent(a.Value, a.SourceXml);
                        limitedAttributes++;
                    }
                    else if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces))
                    {
                        // Set the ID for later use in reification
                        ID = "#" + a.Value;
                    }

                    // Check we haven't got more than 1 of the Limited Attributes
                    if (limitedAttributes > 1)
                    {
                        throw ParserHelper.Error("A Property Element can only have 1 of the following attributes: rdf:nodeID or rdf:resource", "Empty Property Element", element);
                    }
                }
                if (res == null)
                {
                    // No relevant attributes so an anonymous Blank Node
                    res = new BlankNodeIDEvent(String.Empty);
                }

                // Now create the actual Subject Node
                if (res is UriReferenceEvent uriref)
                {
                    // Resolve the Uri Reference
                    subj = Resolve(context, uriref, element.BaseUri);
                }
                else if (res is BlankNodeIDEvent blank)
                {
                    if (blank.Identifier.Equals(String.Empty))
                    {
                        // Have the Graph generate a Blank Node ID
                        subj = context.Handler.CreateBlankNode();
                    }
                    else
                    {
                        // Use the supplied Blank Node ID
                        subj = context.Handler.CreateBlankNode(blank.Identifier);
                    }
                }
                else
                {
                    // Should never hit this case but required to get the Code to Compile
                    // Have the Graph generate a Blank Node ID
                    subj = context.Handler.CreateBlankNode();
                }

                // Validate the ID (if any)
                if (!ID.Equals(String.Empty))
                {
                    ValidateID(context, ID.Substring(1), subj);
                }

                // Relate the Property element to its parent
                parentEl = (ElementEvent)parent;
                pred = Resolve(context, element);//context.Handler.CreateUriNode(element.QName);
                if (!context.Handler.HandleTriple(new Triple(parentEl.SubjectNode, pred, subj))) ParserHelper.Stop();

                // Reify if applicable
                if (!ID.Equals(String.Empty))
                {
                    // Resolve the Uri
                    UriReferenceEvent uriref = new UriReferenceEvent(ID, String.Empty);
                    IUriNode uri = Resolve(context, uriref, element.BaseUri);

                    Reify(context, uri, parentEl.SubjectNode, pred, subj);
                }

                // Process the rest of the Attributes
                foreach (AttributeEvent a in element.Attributes)
                {
                    if (RdfXmlSpecsHelper.IsTypeAttribute(a, context.Namespaces))
                    {
                        // A Property Attribute giving a Type

                        // Assert a Type Triple
                        UriReferenceEvent type = new UriReferenceEvent(a.Value, a.SourceXml);
                        pred = context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType));
                        obj = Resolve(context, type, element.BaseUri);

                        if (!context.Handler.HandleTriple(new Triple(parentEl.SubjectNode, pred, obj))) ParserHelper.Stop();
                    }
                    else if (RdfXmlSpecsHelper.IsPropertyAttribute(a, context.Namespaces))
                    {
                        // A Property Attribute

                        // Validate the Normalization of the Attribute Value
                        if (!a.Value.IsNormalized())
                        {
                            throw ParserHelper.Error("Encountered a Property Attribute '" + a.QName + "' whose value was not correctly normalized in Unicode Normal Form C", "Empty Property Element", a);
                        }
                        else
                        {
                            // Create the Predicate from the Attribute QName
                            pred = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveQName(a.QName, context.Namespaces, null)));

                            // Create the Object from the Attribute Value
                            if (element.Language.Equals(String.Empty))
                            {
                                obj = context.Handler.CreateLiteralNode(a.Value);
                            }
                            else
                            {
                                obj = context.Handler.CreateLiteralNode(a.Value, element.Language);
                            }

                            // Assert the Property Triple
                            if (!context.Handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();
                        }
                    }
                    else if (RdfXmlSpecsHelper.IsIDAttribute(a, context.Namespaces) || RdfXmlSpecsHelper.IsNodeIDAttribute(a, context.Namespaces) || RdfXmlSpecsHelper.IsResourceAttribute(a, context.Namespaces))
                    {
                        // These have already been processed
                        // We test for them so that we can then throw ParserHelper.Errors in the final case for unexpected attributes
                    }
                    else
                    {
                        // Unexpected Attribute
                        throw ParserHelper.Error("Unexpected Attribute '" + a.QName + "' encountered on a Property Element!  Only rdf:ID, rdf:resource, rdf:nodeID and Property Attributes are permitted on Property Elements", "Empty Property Element", element);
                    }
                }
            }
            // End the current namespace scope
            PopNamespaces(context);
        }

        // Useful Functions defined as part of the Grammar
        #region Useful Grammar Helper Functions

        /// <summary>
        /// Applies the Namespace Attributes of an Element Event to the Namespace Map.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="evt">Element Event.</param>
        private static void ApplyNamespaces(RdfXmlParserContext context, ElementEvent evt)
        {
            context.Namespaces.IncrementNesting();
            if (!evt.BaseUri.Equals(String.Empty))
            {
                Uri baseUri = UriFactory.Create(Tools.ResolveUri(evt.BaseUri, context.BaseUri.ToSafeString()));
                context.BaseUri = baseUri;
                if (!context.Handler.HandleBaseUri(baseUri)) ParserHelper.Stop();
            }
            foreach (NamespaceAttributeEvent ns in evt.NamespaceAttributes)
            {
                if (!context.Namespaces.HasNamespace(ns.Prefix) || !context.Namespaces.GetNamespaceUri(ns.Prefix).AbsoluteUri.Equals(ns.Uri))
                {
                    context.Namespaces.AddNamespace(ns.Prefix, UriFactory.Create(ns.Uri));
                    if (!context.Handler.HandleNamespace(ns.Prefix, UriFactory.Create(ns.Uri))) ParserHelper.Stop();
                }
            }
        }

        private static void PopNamespaces(RdfXmlParserContext context)
        {
            context.Namespaces.DecrementNesting();
        }

        /// <summary>
        /// Resolves a Uri Reference into a Uri Node against a given Base Uri.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="uriref">Uri Reference to Resolve.</param>
        /// <param name="baseUri">Base Uri to Resolve against.</param>
        /// <returns></returns>
        private IUriNode Resolve(RdfXmlParserContext context, UriReferenceEvent uriref, String baseUri)
        {
            try
            {
                if (baseUri.Equals(String.Empty)) baseUri = context.BaseUri.ToSafeString();
                if (string.Empty.Equals(uriref.Identifier))
                    baseUri = Tools.StripUriFragment(UriFactory.Create(baseUri)).ToSafeString();
                IUriNode u = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveUri(uriref.Identifier, baseUri)));
                return u;
            }
            catch (Exception ex)
            {
                // Catch the error so we can wrap in in our own error function
                // If it fails then we know we got an error caused by this Event
                throw ParserHelper.Error(ex.Message, uriref);
            }
        }

        private IUriNode Resolve(RdfXmlParserContext context, ElementEvent el)
        {
            try
            {
                IUriNode u = context.Handler.CreateUriNode(UriFactory.Create(Tools.ResolveQName(el.QName, context.Namespaces, null)));
                return u;
            }
            catch (Exception ex)
            {
                throw ParserHelper.Error(ex.Message, el);
            }
        }

        /// <summary>
        /// Reifies a Triple.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="uriref">Uri Reference for the Reified Triple.</param>
        /// <param name="subj">Subject of the Triple.</param>
        /// <param name="pred">Predicate of the Triple.</param>
        /// <param name="obj">Object of the Triple.</param>
        private void Reify(RdfXmlParserContext context, IUriNode uriref, INode subj, INode pred, INode obj)
        {
            if (!context.Handler.HandleTriple(new Triple(uriref, context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfSubject)), subj))) ParserHelper.Stop();
            if (!context.Handler.HandleTriple(new Triple(uriref, context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfPredicate)), pred))) ParserHelper.Stop();
            if (!context.Handler.HandleTriple(new Triple(uriref, context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfObject)), obj))) ParserHelper.Stop();
            if (!context.Handler.HandleTriple(new Triple(uriref, context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType)), context.Handler.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfStatement))))) ParserHelper.Stop();
        }

        /// <summary>
        /// Helper function which inserts an Element back on the front of a Queue.
        /// </summary>
        /// <param name="eventlist">Queue to insert onto the Front of.</param>
        /// <param name="evt">Event to put on the front of the Queue.</param>
        private void QueueJump(IEventQueue<IRdfXmlEvent> eventlist, IRdfXmlEvent evt)
        {
            Stack<IRdfXmlEvent> temp = new Stack<IRdfXmlEvent>();
            temp.Push(evt);

            while (eventlist.Count > 0)
            {
                temp.Push(eventlist.Dequeue());
            }

            foreach (IRdfXmlEvent e in temp.Reverse())
            {
                eventlist.Enqueue(e);
            }
        }

        /// <summary>
        /// Applies List Expansion to the given Event.
        /// </summary>
        /// <param name="evt">Element to apply List Expansion to.</param>
        /// <returns>Uri Reference for the List Item.</returns>
        /// <remarks>List Expansion only works on Element Events.</remarks>
        private UriReferenceEvent ListExpand(IRdfXmlEvent evt, INamespaceMapper nsMapper)
        {
            if (evt is ElementEvent e)
            {
                // Cast to an ElementEvent

                var nsPrefix = nsMapper.GetPrefix(new Uri(NamespaceMapper.RDF));
                // Form a new Uri Reference
                var u = new UriReferenceEvent(nsPrefix + ":_" + e.ListCounter, string.Empty);

                // Increment the List Counter
                e.ListCounter = e.ListCounter + 1;

                // Return the new Uri Reference
                return u;
            }
            else
            {
                throw ParserHelper.Error("Cannot perform List Expansion on an Event which is not an ElementEvent", evt);
            }
        }

        /// <summary>
        /// Validates that an ID is correctly formed and has only been used once in the context of a given Subject.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="id">ID to Validate.</param>
        /// <param name="subj">Subject that the ID pertains to.</param>
        private void ValidateID(RdfXmlParserContext context, String id, INode subj)
        {
            // Validate the actual ID value
            if (!XmlSpecsHelper.IsName(id))
            {
                throw new RdfParseException("The value '" + id + "' for rdf:ID is not valid, RDF IDs can only be valid Names as defined by the W3C XML Specification");
            }

            // Validate that the ID hasn't been used more than once in the same Base Uri context
            if (context.IDs.ContainsKey(id))
            {
                if (context.IDs[id].Contains(subj))
                {
                    throw new RdfParseException("An rdf:ID must be unique to a Node within a File, the rdf:ID '" + id + "' has already been used for a Node in this RDF/XML File!");
                }
                else
                {
                    context.IDs[id].Add(subj);
                }
            }
            else
            {
                context.IDs.Add(id, new List<INode>() { subj });
            }
        }

        #endregion

        #endregion

        #region Tracing Methods

        /// <summary>
        /// Tracing function used when Parse Tracing is enabled.
        /// </summary>
        /// <param name="production">Production.</param>
        private void ProductionTrace(String production)
        {
            Console.WriteLine("Production '" + production + "' called");
        }

        private void ProductionTracePartial(String production)
        {
            Console.Write("Production '" + production + "' called");
        }

        private void ProductionTracePartial(ElementEvent evt)
        {
            Console.WriteLine(" on element <" + evt.QName + ">" + (evt.Position != null ? " at Line " + evt.Position.StartLine + " Column " + evt.Position.StartPosition : String.Empty));
        }

        /// <summary>
        /// Tracing function used when Parse Tracing is enabled.
        /// </summary>
        /// <param name="production">Production.</param>
        /// <param name="evt"></param>
        private void ProductionTrace(String production, ElementEvent evt)
        {
            Console.WriteLine("Production '" + production + "' called on element <" + evt.QName + ">" + (evt.Position != null ? " at Line " + evt.Position.StartLine + " Column " + evt.Position.StartPosition : String.Empty));
        }

        #endregion

        /// <summary>
        /// Gets the String representation of the Parser which is a description of the syntax it parses.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            switch (_mode)
            {
                case RdfXmlParserMode.DOM:
                    return "RDF/XML (DOM)";
                case RdfXmlParserMode.Streaming:
                default:
                    return "RDF/XML (Streaming)";
            }
        }
        private static bool ElementHasName(ElementEvent el, string localName, string namespaceUri, RdfXmlParserContext context)
        {
            return el.LocalName.Equals(localName) && 
                   context.Namespaces.HasNamespace(el.Namespace) && 
                   context.Namespaces.GetNamespaceUri(el.Namespace).ToString().Equals(namespaceUri);
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\dotNetRDF\Parsing\RDFXMLParser.cs(1860,81): warning CS1573: Parameter 'nsMapper' has no matching param tag in the XML comment for 'RdfXmlParser.ListExpand(IRdfXmlEvent, INamespaceMapper)' (but other parameters do)
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF\Parsing\RDFXMLParser.cs(1681,39): error CS0136: A local or parameter named 'uriref' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Libraries\dotNetRDF\Parsing\RDFXMLParser.cs(1858,81): warning CS1573: Parameter 'nsMapper' has no matching param tag in the XML comment for 'RdfXmlParser.ListExpand(IRdfXmlEvent, INamespaceMapper)' (but other parameters do)
######################################################################


######################################################################
Nr: 4 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Libraries\dotNetRDF\Parsing\SPARQLQueryParser.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using VDS.RDF.Parsing.Contexts;
using VDS.RDF.Parsing.Tokens;
using VDS.RDF.Query;
using VDS.RDF.Query.Aggregates;
using VDS.RDF.Query.Expressions;
using VDS.RDF.Query.Expressions.Functions.Sparql.Boolean;
using VDS.RDF.Query.Expressions.Primary;
using VDS.RDF.Query.Filters;
using VDS.RDF.Query.Grouping;
using VDS.RDF.Query.Optimisation;
using VDS.RDF.Query.Ordering;
using VDS.RDF.Query.Paths;
using VDS.RDF.Query.Patterns;

namespace VDS.RDF.Parsing
{
    /// <summary>
    /// Available Query Syntaxes.
    /// </summary>
    public enum SparqlQuerySyntax
    {
        /// <summary>
        /// Use SPARQL 1.0
        /// </summary>
        Sparql_1_0,
        /// <summary>
        /// Use SPARQL 1.1
        /// </summary>
        Sparql_1_1,
        /// <summary>
        /// Use the latest SPARQL specification supported by the library (currently SPARQL 1.1) with some extensions
        /// </summary>
        /// <remarks>
        /// <para>
        /// Extensions include the following:
        /// </para>
        /// <ul>
        /// <li><strong>LET</strong> assignments (we recommend using the SPARQL 1.1 standards BIND instead)</li>
        /// <li>Additional aggregates - <strong>NMAX</strong>, <strong>NMIN</strong>, <strong>MEDIAN</strong> and <strong>MODE</strong> (we recommend using the Leviathan Function Library URIs for these instead to make them usable in SPARQL 1.1 mode)</li>
        /// <li><strong>UNSAID</strong> alias for <strong>NOT EXISTS</strong> (we recommend using the SPARQL 1.1 standard NOT EXISTS instead</li>
        /// <li><strong>EXISTS</strong> and <strong>NOT EXISTS</strong> are permitted as Graph Patterns (only allowed in FILTERs in SPARQL 1.1)</li>
        /// </ul>
        /// </remarks>
        Extended,
    }

    /// <summary>
    /// Class for parsing SPARQL Queries into <see cref="SparqlQuery">SparqlQuery</see> objects that can be used to query a Graph or Triple Store.
    /// </summary>
    public class SparqlQueryParser
        : ITraceableTokeniser, IObjectParser<SparqlQuery>
    {
        private readonly TokenQueueMode _queuemode = TokenQueueMode.QueueAllBeforeParsing;
        private bool _tracetokeniser = false;
        private Uri _defaultBaseUri = null;
        private SparqlQuerySyntax _syntax = Options.QueryDefaultSyntax;
        private IEnumerable<ISparqlCustomExpressionFactory> _factories = Enumerable.Empty<ISparqlCustomExpressionFactory>();
        private IQueryOptimiser _optimiser = null;

        #region Constructors and Properties

        /// <summary>
        /// Creates a new instance of the SPARQL Query Parser.
        /// </summary>
        public SparqlQueryParser()
            : this(TokenQueueMode.QueueAllBeforeParsing) { }

        /// <summary>
        /// Creates a new instance of the SPARQL Query Parser which supports the given SPARQL Syntax.
        /// </summary>
        /// <param name="syntax">SPARQL Syntax.</param>
        public SparqlQueryParser(SparqlQuerySyntax syntax)
            : this(TokenQueueMode.QueueAllBeforeParsing, syntax) { }

        /// <summary>
        /// Creates a new instance of the SPARQL Query Parser using the given Tokeniser Queue Mode.
        /// </summary>
        /// <param name="queueMode">Token Queue Mode.</param>
        public SparqlQueryParser(TokenQueueMode queueMode)
            : this(queueMode, Options.QueryDefaultSyntax) { }

        /// <summary>
        /// Creates a new instance of the SPARQL Query Parser using the given Tokeniser which supports the given SPARQL Syntax.
        /// </summary>
        /// <param name="queueMode">Token Queue Mode.</param>
        /// <param name="syntax">SPARQL Syntax.</param>
        public SparqlQueryParser(TokenQueueMode queueMode, SparqlQuerySyntax syntax)
        {
            _queuemode = queueMode;
            _syntax = syntax;
        }

        /// <summary>
        /// Gets/Sets whether Tokeniser progress is Traced to the Console.
        /// </summary>
        public bool TraceTokeniser
        {
            get
            {
                return _tracetokeniser;
            }
            set
            {
                _tracetokeniser = value;
            }
        }

        /// <summary>
        /// Gets/Sets the Default Base URI for Queries parsed by this Parser instance.
        /// </summary>
        public Uri DefaultBaseUri
        {
            get
            {
                return _defaultBaseUri;
            }
            set
            {
                _defaultBaseUri = value;
            }
        }

        /// <summary>
        /// Gets/Sets the Syntax that should be supported.
        /// </summary>
        public SparqlQuerySyntax SyntaxMode
        {
            get
            {
                return _syntax;
            }
            set
            {
                _syntax = value;
            }
        }

        /// <summary>
        /// Gets/Sets the locally scoped custom expression factories.
        /// </summary>
        public IEnumerable<ISparqlCustomExpressionFactory> ExpressionFactories
        {
            get
            {
                return _factories;
            }
            set
            {
                if (value != null)
                {
                    _factories = value;
                }
                else
                {
                    _factories = Enumerable.Empty<ISparqlCustomExpressionFactory>();
                }
            }
        }

        /// <summary>
        /// Gets/Sets the locally scoped Query Optimiser applied to queries at the end of the parsing process.
        /// </summary>
        /// <remarks>
        /// <para>
        /// May be null if no locally scoped optimiser is set in which case the globally scoped optimiser will be used.
        /// </para>
        /// </remarks>
        public IQueryOptimiser QueryOptimiser
        {
            get
            {
                return _optimiser;
            }
            set
            {
                _optimiser = value;
            }
        }

        #endregion

        #region Events

        /// <summary>
        /// Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Query being parsed is detected.
        /// </summary>
        /// <param name="message">Warning Message.</param>
        private void RaiseWarning(String message)
        {
            SparqlWarning d = Warning;
            if (d != null)
            {
                d(message);
            }
        }

        /// <summary>
        /// Event raised when a non-fatal issue with the SPARQL Query being parsed is detected
        /// </summary>
        public event SparqlWarning Warning;

        #endregion

        #region Public Parser Methods

        /// <summary>
        /// Parses a SPARQL Query from a File.
        /// </summary>
        /// <param name="queryFile">File containing the Query.</param>
        /// <returns></returns>
        public SparqlQuery ParseFromFile(String queryFile)
        {
            if (queryFile == null) throw new RdfParseException("Cannot parse a SPARQL Query from a null File");
            StreamReader reader = new StreamReader(File.OpenRead(queryFile), Encoding.UTF8);
            return ParseInternal(reader);
        }

        /// <summary>
        /// Parses a SPARQL Query from an arbitrary Input Stream.
        /// </summary>
        /// <param name="input">Input Stream.</param>
        /// <returns></returns>
        public SparqlQuery Parse(StreamReader input)
        {
            if (input == null) throw new RdfParseException("Cannot parse a SPARQL Query from a null Stream");

            // Issue a Warning if the Encoding of the Stream is not UTF-8
            if (!input.CurrentEncoding.Equals(Encoding.UTF8))
            {
                RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result");
            }

            return ParseInternal(input);
        }

        /// <summary>
        /// Parses a SPARQL Query from an arbitrary Input.
        /// </summary>
        /// <param name="input">Input.</param>
        /// <returns></returns>
        public SparqlQuery Parse(TextReader input)
        {
            if (input == null) throw new RdfParseException("Cannot parse a SPARQL Query from a null TextReader");
            return ParseInternal(input);
        }

        /// <summary>
        /// Parses a SPARQL Query from a String.
        /// </summary>
        /// <param name="queryString">A SPARQL Query.</param>
        /// <returns></returns>
        public SparqlQuery ParseFromString(String queryString)
        {
            if (queryString == null) throw new RdfParseException("Cannot parse a SPARQL Query from a null String");
            return ParseInternal(new StringReader(queryString));
        }

        /// <summary>
        /// Parses a SPARQL Query from a SPARQL Parameterized String.
        /// </summary>
        /// <param name="queryString">A SPARQL Parameterized String.</param>
        /// <returns></returns>
        /// <remarks>
        /// The <see cref="SparqlParameterizedString">SparqlParameterizedString</see> class allows you to use parameters in a String in a manner similar to SQL Commands in the ADO.Net model.  See the documentation for <see cref="SparqlParameterizedString">SparqlParameterizedString</see> for details of this.
        /// </remarks>
        public SparqlQuery ParseFromString(SparqlParameterizedString queryString)
        {
            if (queryString == null) throw new RdfParseException("Cannot parse a SPARQL Query from a null String");
            return ParseFromString(queryString.ToString());
        }

        #endregion

        #region Internal Parsing Logic

        private SparqlQuery ParseInternal(TextReader input)
        {
            try
            {
                // Create the Parser Context
                SparqlQueryParserContext context = new SparqlQueryParserContext(new SparqlTokeniser(input, _syntax), _queuemode, false, _tracetokeniser);
                context.SyntaxMode = _syntax;
                context.ExpressionParser.SyntaxMode = context.SyntaxMode;
                context.ExpressionFactories = _factories;

                return ParseInternal(context);
            }
            catch
            {
                throw;
            }
            finally
            {
                try
                {
                    input.Close();
                }
                catch
                {
                    // No catch actions just trying to clean up the stream
                }
            }
        }

        private SparqlQuery ParseInternal(SparqlQueryParserContext context)
        {
            IToken temp = null;

            // Initialise Context with relevant data
            context.DefaultBaseUri = _defaultBaseUri;
            context.ExpressionParser.NamespaceMap = context.Query.NamespaceMap;
            context.ExpressionParser.QueryParser = this;
            context.ExpressionParser.ExpressionFactories = context.ExpressionFactories;
            context.Tokens.InitialiseBuffer();
            context.SyntaxMode = _syntax;
            context.Query.ExpressionFactories = context.ExpressionFactories.ToList();

            do
            {
                temp = context.Tokens.Dequeue();

                switch (temp.TokenType)
                {
                    case Token.BOF:
                    case Token.COMMENT:
                    case Token.EOF:
                        // Discardable Tokens
                        break;

                    case Token.BASEDIRECTIVE:
                        TryParseBaseDeclaration(context);
                        break;
                    case Token.PREFIXDIRECTIVE:
                        TryParsePrefixDeclaration(context);
                        break;

                    case Token.ASK:
                    case Token.CONSTRUCT:
                    case Token.DESCRIBE:
                    case Token.SELECT:
                        TryParseQueryVerb(context, temp);

                        // Get Variables for a Select or Describe or Construct
                        if (context.Query.QueryType == SparqlQueryType.Select)
                        {
                            TryParseSelectVariables(context);
                        }
                        else if (context.Query.QueryType == SparqlQueryType.Describe)
                        {
                            TryParseDescribeVariables(context);
                        }
                        else if (context.Query.QueryType == SparqlQueryType.Construct)
                        {
                            TryParseConstructTemplate(context);
                        }

                        // Get Datasets (FROM Clauses)
                        temp = context.Tokens.Peek();
                        while (temp.TokenType == Token.FROM)
                        {
                            TryParseFrom(context);
                            temp = context.Tokens.Peek();
                        }

                        // Unless a SHORT Form CONSTRUCT then we need to check for a WHERE { } clause
                        // If the Query is a DESCRIBE then if there is no WHERE keyword the WHERE clause is not required
                        if (context.Query.QueryType != SparqlQueryType.Construct || (context.Query.QueryType == SparqlQueryType.Construct && context.Query.RootGraphPattern == null))
                        {
                            // Check for Optional WHERE and Discard
                            temp = context.Tokens.Peek();
                            bool whereSeen = false;
                            if (temp.TokenType == Token.WHERE)
                            {
                                context.Tokens.Dequeue();
                                whereSeen = true;
                            }

                            // Unless it's a DESCRIBE we must now see a Graph Pattern 
                            // OR if the next Token is a { then it must be a Graph Pattern regardless
                            // OR we saw a WHERE in which case we must have a Graph Pattern
                            temp = context.Tokens.Peek();
                            if (whereSeen || context.Query.QueryType != SparqlQueryType.Describe || temp.TokenType == Token.LEFTCURLYBRACKET)
                            {
                                TryParseGraphPatterns(context);
                            }
                        }

                        // If we're an ASK then we shouldn't have any Solution Modifier for SPARQL 1.0
                        // SPARQL 1.1 allows modifiers so we don't continue if using SPARQL 1.1
                        if (context.Query.QueryType == SparqlQueryType.Ask && context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) continue;

                        // Otherwise we can now have a Solution Modifier

                        // Firstly a possible GROUP BY clause
                        temp = context.Tokens.Peek();
                        if (temp.TokenType == Token.GROUPBY)
                        {
                            context.Tokens.Dequeue();
                            TryParseGroupByClause(context);

                            // Then a possible HAVING clause
                            temp = context.Tokens.Peek();
                            if (temp.TokenType == Token.HAVING)
                            {
                                context.Tokens.Dequeue();
                                TryParseHavingClause(context);
                            }
                        }
                        else if (temp.TokenType == Token.HAVING)
                        {
                            // Can have a HAVING without a GROUP BY
                            context.Tokens.Dequeue();
                            TryParseHavingClause(context);
                        }

                        // Check that either there are no Aggregates used or only Aggregates used
                        if (SparqlSpecsHelper.IsSelectQuery(context.Query.QueryType) && (context.Query.IsAggregate && context.Query.GroupBy == null))
                        {
                            // CORE-446
                            // Cope with the case where aggregates are used inside other functions
                            foreach (SparqlVariable var in context.Query.Variables)
                            {
                                if (!var.IsResultVariable) continue;
                                if (var.IsAggregate) continue;

                                if (var.IsProjection)
                                {
                                    // Maybe OK if the projection operates over aggregates or group keys
                                    ISparqlExpression expr = var.Projection;
                                    Queue<ISparqlExpression> exprs = new Queue<ISparqlExpression>(expr.Arguments);
                                    while (exprs.Count > 0)
                                    {
                                        expr = exprs.Dequeue();

                                        // Aggregates are OK
                                        if (expr is AggregateTerm) continue;

                                        // Other primary expressions are OK
                                        if (expr is ConstantTerm) continue;
                                        if (expr is AllModifier) continue;
                                        if (expr is DistinctModifier) continue;

                                        // Variables may 
                                        if (expr is VariableTerm)
                                        {
                                            String exprVar = expr.Variables.First();
                                            if (!context.Query.Variables.Any(v => v.IsAggregate && v.Name.Equals(exprVar)))
                                            {
                                                throw new RdfParseException("The Select Query is invalid since it contains both Aggregates and Variables in the SELECT Clause but it does not contain a GROUP BY clause");
                                            }
                                        }

                                        // Anything else need to check its arguments
                                        foreach (ISparqlExpression arg in expr.Arguments)
                                        {
                                            exprs.Enqueue(arg);
                                        }
                                    }
                                }
                                else
                                {
                                    throw new RdfParseException("The Select Query is invalid since it contains both Aggregates and Variables in the SELECT Clause but it does not contain a GROUP BY clause");
                                }
                            }
                            
                        }

                        // Then a possible ORDER BY clause
                        temp = context.Tokens.Peek();
                        if (temp.TokenType == Token.ORDERBY)
                        {
                            context.Tokens.Dequeue();
                            TryParseOrderByClause(context);
                        }

                        // Then a possible LIMIT/OFFSET clause
                        temp = context.Tokens.Peek();
                        if (temp.TokenType == Token.LIMIT || temp.TokenType == Token.OFFSET)
                        {
                            TryParseLimitOffsetClause(context);
                        }

                        // Finally if we're a SELECT then we can have a BINDINGS clause
                        if (SparqlSpecsHelper.IsSelectQuery(context.Query.QueryType))
                        {
                            temp = context.Tokens.Peek();
                            if (temp.TokenType == Token.BINDINGS || temp.TokenType == Token.VALUES)
                            {
                                if (temp.TokenType == Token.BINDINGS && context.SyntaxMode != SparqlQuerySyntax.Extended) throw ParserHelper.Error("The BINDINGS keyword is the old name for the VALUES keyword, use the VALUES keyword instead", temp);
                                if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw ParserHelper.Error("Inline Data blocks (VALUES clauses) are not permitted in SPARQL 1.0", temp);
                                context.Tokens.Dequeue();
                                context.Query.Bindings = TryParseInlineData(context);
                            }
                        }

                        break;

                    default:
                        if (context.Query.QueryType == SparqlQueryType.Ask)
                        {
                            throw ParserHelper.Error("Unexpected Token encountered, a valid ASK query has been parsed but additional invalid tokens are present after the Graph pattern", temp);
                        }
                        else
                        {
                            throw ParserHelper.Error("Unexpected Token encountered - expected a BASE/PREFIX directive or a Query Keyword to start a Query", temp);
                        }
                }
            } while (temp.TokenType != Token.EOF);

            // If not SPARQL 1.0 then do additional post parsing checks
            if (_syntax != SparqlQuerySyntax.Sparql_1_0)
            {
                switch (context.Query.QueryType)
                {
                    case SparqlQueryType.Select:
                    case SparqlQueryType.SelectDistinct:
                    case SparqlQueryType.SelectReduced:
                    case SparqlQueryType.Describe:
                        // Check Variable Usage
                        List<String> projectedSoFar = new List<string>();
                        List<String> mainBodyVars = (context.Query.RootGraphPattern != null ? context.Query.RootGraphPattern.Variables : Enumerable.Empty<String>()).Distinct().ToList();
                        foreach (SparqlVariable var in context.Query.Variables)
                        {
                            if (!var.IsResultVariable) continue;

                            if (projectedSoFar.Contains(var.Name) && (var.IsAggregate || var.IsProjection))
                            {
                                throw new RdfParseException("Cannot assign the results of an Aggregate/Project Expression to the variable " + var.ToString() + " as this variable is already Projected to earlier in the SELECT");
                            }

                            if (var.IsProjection)
                            {
                                if (mainBodyVars.Contains(var.Name)) throw new RdfParseException("Cannot project an expression to the variable " + var.Name + " as this variable is a bound variable from the main body of the query");
                                if (context.Query.GroupBy != null)
                                {
                                    if (!IsProjectableExpression(context, var.Projection, projectedSoFar))
                                    {
                                        throw new RdfParseException("Your SELECT uses the Project Expression " + var.Projection.ToString() + " which uses one/more variables which are either not projectable from the GROUP BY or not projected earlier in the SELECT.  All Variables used must be projectable from the GROUP BY, projected earlier in the SELECT or within an aggregate");
                                    }
                                }
                            }
                            else if (var.IsAggregate)
                            {
                                if (mainBodyVars.Contains(var.Name)) throw new RdfParseException("Cannot project an aggregate to the variable " + var.Name + " as this variable is a bound variable from the main body of the query");
                                if (context.Query.GroupBy != null)
                                {
                                    // Q: Does ISparqlAggregate needs to expose a Variables property?
                                    // if (!var.Aggregate.Var
                                }
                            }
                            else
                            {
                                if (context.Query.GroupBy != null)
                                {
                                    // If there is a GROUP BY then the Variable must either be projectable from there
                                    if (!context.Query.GroupBy.ProjectableVariables.Contains(var.Name))
                                    {
                                        throw new RdfParseException("Your SELECT/DESCRIBE query tries to project the variable " + var.ToString() + " but this Variable is not Grouped By");
                                    }
                                }
                            }

                            projectedSoFar.Add(var.Name);
                        }
                        break;

                    case SparqlQueryType.DescribeAll:
                    case SparqlQueryType.SelectAll:
                    case SparqlQueryType.SelectAllDistinct:
                    case SparqlQueryType.SelectAllReduced:
                        // Check that a GROUP BY has not been used
                        if (context.Query.GroupBy != null)
                        {
                            throw new RdfParseException("SELECT/DESCRIBE * is not permitted when a GROUP BY is used");
                        }
                        break;
                }
            }

            // Optimise the Query if the global option is enabled
            if (Options.QueryOptimisation)
            {
                // If a locally scoped optimiser is available use that
                if (_optimiser != null)
                {
                    context.Query.Optimise(_optimiser);
                }
                else
                {
                    context.Query.Optimise();
                }
            }

            return context.Query;
        }

        private void TryParseBaseDeclaration(SparqlQueryParserContext context)
        {
            if (context.SubQueryMode) throw new RdfQueryException("BASE Directives are not supported in Sub-queries");

            // Get the next Token which should be a Uri Token
            IToken next = context.Tokens.Dequeue();
            if (next.TokenType == Token.URI)
            {
                context.Query.BaseUri = UriFactory.Create(next.Value);
                context.ExpressionParser.BaseUri = context.Query.BaseUri;
            }
            else
            {
                throw ParserHelper.Error("Expected a URI Token to follow the BASE Verb in a Query", next);
            }
        }

        private void TryParsePrefixDeclaration(SparqlQueryParserContext context)
        {
            if (context.SubQueryMode) throw new RdfQueryException("PREFIX Directives are not supported in Sub-queries");

            // Get the next Two Tokens which should be a Prefix and a Uri
            IToken prefix = context.Tokens.Dequeue();
            IToken uri = context.Tokens.Dequeue();

            if (prefix.TokenType == Token.PREFIX)
            {
                if (uri.TokenType == Token.URI)
                {
                    String baseUri = (context.Query.BaseUri != null) ? context.Query.BaseUri.AbsoluteUri : String.Empty;
                    Uri u = UriFactory.Create(Tools.ResolveUri(uri.Value, baseUri));
                    if (prefix.Value.Length == 1)
                    {
                        // Defining prefix for Default Namespace
                        context.Query.NamespaceMap.AddNamespace("", u);
                    }
                    else
                    {
                        // Defining prefix for some other Namespace
                        context.Query.NamespaceMap.AddNamespace(prefix.Value.Substring(0, prefix.Value.Length - 1), u);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Expected a URI Token to follow a Prefix Token to follow the PREFIX Verb in a Query", uri);
                }
            }
            else
            {
                throw ParserHelper.Error("Expected a Prefix Token to follow the PREFIX Verb in a Query", prefix);
            }
        }

        private void TryParseQueryVerb(SparqlQueryParserContext context, IToken t)
        {
            if (context.VerbSeen)
            {
                throw ParserHelper.Error("Only 1 Query Verb can occur in a Query", t);
            }
            else
            {
                context.VerbSeen = true;

                switch (t.TokenType) {
                    case Token.ASK:
                        if (context.SubQueryMode) throw ParserHelper.Error("ASK is not supported in Sub-queries",t);
                        context.Query.QueryType = SparqlQueryType.Ask;
                        break;
                    case Token.CONSTRUCT:
                        if (context.SubQueryMode) throw ParserHelper.Error("CONSTRUCT is not supported in Sub-queries",t);
                        context.Query.QueryType = SparqlQueryType.Construct;
                        break;
                    case Token.DESCRIBE:
                        if (context.SubQueryMode) throw ParserHelper.Error("DESCRIBE is not supported in Sub-queries", t);
                        context.Query.QueryType = SparqlQueryType.Describe;
                        break;
                    case Token.SELECT:
                        context.Query.QueryType = SparqlQueryType.Select;
                        break;
                }
            }
        }

        private void TryParseSelectVariables(SparqlQueryParserContext context)
        {
            IToken next; 
            bool firstToken = true;
            ISparqlExpression expr;

            // Any Expression we parse from the Select Variables segment may be an aggregate
            context.ExpressionParser.AllowAggregates = true;

            do {
                next = context.Tokens.Peek();

                switch (next.TokenType)
                {
                    case Token.ALL:
                        if (context.Query.Variables.Any())
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Select All and specify Variables in the SELECT Clause", next);
                        }
                        // Change the Query Type to a Select All
                        switch (context.Query.QueryType)
                        {
                            case SparqlQueryType.Select:
                                context.Query.QueryType = SparqlQueryType.SelectAll;
                                break;
                            case SparqlQueryType.SelectDistinct:
                                context.Query.QueryType = SparqlQueryType.SelectAllDistinct;
                                break;
                            case SparqlQueryType.SelectReduced:
                                context.Query.QueryType = SparqlQueryType.SelectAllReduced;
                                break;
                        }
                        break;

                    case Token.VARIABLE:
                        if ((int)context.Query.QueryType >= (int)SparqlQueryType.SelectAll)
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Select All and specify Variables in the SELECT Clause", next);
                        }

                        context.Query.AddVariable(next.Value, true);
                        break;

                    case Token.AVG:
                    case Token.COUNT:
                    case Token.GROUPCONCAT:
                    case Token.MAX:
                    case Token.MEDIAN:
                    case Token.MIN:
                    case Token.MODE:
                    case Token.NMAX:
                    case Token.NMIN:
                    case Token.SAMPLE:
                    case Token.SUM:
                        if ((int)context.Query.QueryType >= (int)SparqlQueryType.SelectAll)
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Select All and specify an Aggregate in the SELECT Clause", next);
                        }

                        context.Tokens.Dequeue();
                        SparqlVariable aggVar = TryParseAggregate(context, next);
                        context.Query.AddVariable(aggVar);
                        firstToken = false;
                        continue;

                    case Token.ABS:
                    case Token.BNODE:
                    case Token.BOUND:
                    case Token.CALL:
                    case Token.CEIL:
                    case Token.COALESCE:
                    case Token.CONCAT:
                    case Token.DATATYPEFUNC:
                    case Token.DAY:
                    case Token.ENCODEFORURI:
                    case Token.EXISTS:
                    case Token.FLOOR:
                    case Token.HOURS:
                    case Token.IF:
                    case Token.IRI:
                    case Token.ISBLANK:
                    case Token.ISIRI:
                    case Token.ISLITERAL:
                    case Token.ISNUMERIC:
                    case Token.ISURI:
                    case Token.LANG:
                    case Token.LANGMATCHES:
                    case Token.LCASE:
                    case Token.MINUTES:
                    case Token.MONTH:
                    case Token.NOTEXISTS:
                    case Token.NOW:
                    case Token.RAND:
                    case Token.REGEX:
                    case Token.REPLACE:
                    case Token.ROUND:
                    case Token.SAMETERM:
                    case Token.SECONDS:
                    case Token.SHA1:
                    case Token.SHA224:
                    case Token.SHA256:
                    case Token.SHA384:
                    case Token.SHA512:
                    case Token.STR:
                    case Token.STRAFTER:
                    case Token.STRBEFORE:
                    case Token.CONTAINS:
                    case Token.STRDT:
                    case Token.STRENDS:
                    case Token.STRLANG:
                    case Token.STRLEN:
                    case Token.STRSTARTS:
                    case Token.STRUUID:
                    case Token.SUBSTR:
                    case Token.TIMEZONE:
                    case Token.TZ:
                    case Token.UCASE:
                    case Token.URIFUNC:
                    case Token.UUID:
                    case Token.YEAR:
                        if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Project Expressions are not supported in SPARQL 1.0");

                        expr = TryParseFunctionExpression(context);

                        // Need to see the Alias
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.AS)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected an AS Keyword after a Projection Expression", next);
                        }
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.VARIABLE)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable as an alias after an AS Keyword", next);
                        }

                        context.Query.AddVariable(new SparqlVariable(next.Value.Substring(1), expr));
                        firstToken = false;
                        continue;

                    case Token.QNAME:
                    case Token.URI:
                        if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Project Expressions are not supported in SPARQL 1.0");

                        // Try and parse a Project Expression which is a naked function call
                        // Resolve the URI
                        Uri u = UriFactory.Create(Tools.ResolveUriOrQName(next, context.Query.NamespaceMap, context.Query.BaseUri));
                        context.Tokens.Dequeue();

                        // Ensure we then see a Open Bracket
                        if (context.Tokens.Peek().TokenType != Token.LEFTBRACKET)
                        {
                            throw ParserHelper.Error("Expected a Left Bracket after a URI/QName in Select Variables for the arguments of a function call", context.Tokens.Peek());
                        }
                        context.Tokens.Dequeue();

                        // Then get the arguments (if any)
                        List<ISparqlExpression> args = new List<ISparqlExpression>();
                        if (context.Tokens.Peek().TokenType == Token.RIGHTBRACKET)
                        {
                            context.Tokens.Dequeue();
                        }
                        else
                        {
                            bool comma = false;
                            do
                            {
                                args.Add(TryParseExpression(context, true));
                                comma = (context.Tokens.LastTokenType == Token.COMMA || context.Tokens.LastTokenType == Token.DISTINCT);

                            } while (comma);
                        }

                        // If there are no arguments (one null argument) then discard
                        if (args.Count == 1 && args.First() == null) args.Clear();

                        // Then try and create an Expression
                        expr = SparqlExpressionFactory.CreateExpression(u, args, _factories);

                        // Need to see the Alias
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.AS)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected an AS Keyword after a Projection Expression", next);
                        }
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.VARIABLE)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable as an alias after an AS Keyword", next);
                        }

                        // Turn into the appropriate type of Variable
                        if (expr is AggregateTerm)
                        {
                            context.Query.AddVariable(new SparqlVariable(next.Value.Substring(1), ((AggregateTerm)expr).Aggregate));
                        }
                        else
                        {
                            context.Query.AddVariable(new SparqlVariable(next.Value.Substring(1), expr));
                        }
                        
                        firstToken = false;
                        continue;

                    case Token.LEFTBRACKET:
                        if ((int)context.Query.QueryType >= (int)SparqlQueryType.SelectAll)
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Select All and specify a Projection Expression in the SELECT Clause", next);
                        }

                        if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Project Expressions are not supported in SPARQL 1.0");

                        // Parse the Expression
                        context.Tokens.Dequeue();
                        expr = TryParseExpression(context, false, true);

                        // Require an alias for a Projection Expression
                        bool asTerminated = (context.Tokens.LastTokenType == Token.AS);
                        if (!asTerminated)
                        {
                            // Still need to see an AS
                            next = context.Tokens.Dequeue();
                            if (next.TokenType != Token.AS)
                            {
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected an AS Keyword after a Projection Expression", next);
                            }
                        }
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.VARIABLE)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable as an alias after an AS Keyword", next);
                        }

                        // Turn into the appropriate type of Variable
                        if (expr is AggregateTerm)
                        {
                            context.Query.AddVariable(new SparqlVariable(next.Value.Substring(1), ((AggregateTerm)expr).Aggregate));
                        }
                        else
                        {
                            context.Query.AddVariable(new SparqlVariable(next.Value.Substring(1), expr));
                        }

                        firstToken = false;
                        if (asTerminated)
                        {
                            // Still need a Right Bracket to terminate the expression since the alias was within the outer brackets
                            next = context.Tokens.Dequeue();
                            if (next.TokenType != Token.RIGHTBRACKET)
                            {
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Right Bracket to terminate the Projection Expression after the alias", next);
                            }
                        }
                        continue;

                    case Token.DISTINCT:
                        if (firstToken)
                        {
                            context.Query.QueryType = SparqlQueryType.SelectDistinct;
                        }
                        else
                        {
                            throw ParserHelper.Error("The DISTINCT Keyword must occur immediately after the SELECT Verb in a Query", next);
                        }
                        break;

                    case Token.REDUCED:
                        if (firstToken)
                        {
                            context.Query.QueryType = SparqlQueryType.SelectReduced;
                        }
                        else
                        {
                            throw ParserHelper.Error("The REDUCED Keyword must occur immediately after the SELECT Verb in a Query", next);
                        }
                        break;

                    case Token.COMMENT:
                        // Discard Comments
                        context.Tokens.Dequeue();
                        continue;

                    default:
                        if (firstToken)
                        {
                            throw ParserHelper.Error("The SELECT Keyword must be followed by a list of one/more variables or a * to specify all variables", next);
                        }
                        context.ExpressionParser.AllowAggregates = false;
                        return;
                }

                context.Tokens.Dequeue();
                firstToken = false;
            } while (true);
        }

        private SparqlVariable TryParseAggregate(SparqlQueryParserContext context, IToken agg)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw ParserHelper.Error("Aggregates are not supported in SPARQL 1.0", agg);

            IToken next;
            SparqlVariable var;
            ISparqlAggregate aggregate;

            // Check that the Token is an Aggregate Keyword Token
            switch (agg.TokenType)
            {
                case Token.AVG:
                case Token.COUNT:
                case Token.GROUPCONCAT:
                case Token.MAX:
                case Token.MEDIAN:
                case Token.MIN:
                case Token.MODE:
                case Token.NMAX:
                case Token.NMIN:
                case Token.SAMPLE:
                case Token.SUM:
                    // OK
                    break;

                default:
                    throw ParserHelper.Error("Cannot parse an Aggregate since '" + agg.GetType().ToString() + "' is not an Aggregate Keyword Token", agg);
            }

            // Gather up the Tokens and call into the Expression Parser to get this parsed
            Queue<IToken> tokens = new Queue<IToken>();
            tokens.Enqueue(agg);
            int openBrackets = 0;
            do
            {
                next = context.Tokens.Dequeue();
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }

                tokens.Enqueue(next);
            } while (openBrackets > 0);

            context.ExpressionParser.AllowAggregates = true;
            ISparqlExpression aggExpr = context.ExpressionParser.Parse(tokens);
            context.ExpressionParser.AllowAggregates = false;

            if (aggExpr is AggregateTerm)
            {
                aggregate = ((AggregateTerm)aggExpr).Aggregate;
            }
            else
            {
                throw new RdfParseException("Unexpected expression was parsed when an Aggregate was expected: " + aggExpr.ToString());
            }

            // See if there is an alias
            String alias = "Result";
            next = context.Tokens.Peek();
            if (next.TokenType == Token.AS)
            {
                context.Tokens.Dequeue();
                next = context.Tokens.Dequeue();
                if (next.TokenType != Token.VARIABLE)
                {
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "', expected a Variable Token after an AS Keyword to act as an aliased name for the Aggregate", next);
                }
                alias = next.Value.Substring(1);
            }
            else
            {
                if (context.SyntaxMode != SparqlQuerySyntax.Extended) throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected an AS keyword after an Aggregate", next);

                int nextID = context.NextAliasID;
                if (nextID > 0) alias += nextID.ToString();
                while (context.Query.Variables.Any(v => v.Name.Equals(alias)))
                {
                    alias = "Result" + context.NextAliasID;
                }
                RaiseWarning("No AS ?variable given for the Aggregate " + aggregate.ToString() + " so assigning alias '" + alias + "'");
            }


            var = new SparqlVariable(alias, aggregate);

            return var;
        }

        private void TryParseDescribeVariables(SparqlQueryParserContext context)
        {
            if (context.SubQueryMode) throw new RdfQueryException("DESCRIBE not permitted as a sub-query");

            IToken next;
            bool firstToken = true;

            do {
                next = context.Tokens.Peek();

                switch (next.TokenType)
                {
                    case Token.ALL:
                        if (context.Query.DescribeVariables.Any())
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Describe All and specify Variables/URIs/QNames in the DESCRIBE Clause", next);
                        }
                        // Change the Query Type to a Describe All
                        context.Query.QueryType = SparqlQueryType.DescribeAll;
                        break;

                    case Token.VARIABLE:
                        if (context.Query.QueryType == SparqlQueryType.DescribeAll)
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Describe All and specify Variables/URIs/QNames in the DESCRIBE Clause", next);
                        }
                        context.Query.AddVariable(next.Value, true);
                        context.Query.AddDescribeVariable(next);
                        break;

                    case Token.QNAME:
                    case Token.URI:
                        context.Query.AddDescribeVariable(next);
                        break;

                    case Token.COMMENT:
                        // Discard Comments
                        context.Tokens.Dequeue();
                        continue;

                    default:
                        if (firstToken)
                        {
                            throw ParserHelper.Error("The DESCRIBE keyword must be followed by a list of one/more variables/IRI References or a * to specify all variables", next);
                        }
                        return;
                }

                context.Tokens.Dequeue();
                firstToken = false;
            } while (true);
        }

        private void TryParseConstructTemplate(SparqlQueryParserContext context)
        {
            if (context.SubQueryMode) throw new RdfQueryException("CONSTRUCT not permitted as a sub-query");

            bool shortForm = (context.Tokens.Peek().TokenType == Token.WHERE || context.Tokens.Peek().TokenType == Token.FROM);
            if (shortForm && context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)
            {
                throw ParserHelper.Error("Short Form CONSTRUCT queries are not permitted in SPARQL 1.0", context.Tokens.Peek());
            }
            else if (shortForm)
            {
                IToken temp = context.Tokens.Peek();
                if (context.Tokens.Peek().TokenType == Token.FROM)
                {
                    while (temp.TokenType == Token.FROM)
                    {
                        TryParseFrom(context);
                        temp = context.Tokens.Peek();
                    }
                }
                if (temp.TokenType == Token.WHERE)
                {
                    // For Short Form CONSTRUCT discard the WHERE
                    context.Tokens.Dequeue();
                }
                else
                {
                    throw ParserHelper.Error("Unexpected Token '" + temp.GetType().Name + " encountered, expected the WHERE of a Short Form Construct to come after the FROM/FROM NAMED clauses of a Short Form Construct", temp);
                }
            }

            // Discard the opening {
            IToken next = context.Tokens.Dequeue();
            if (next.TokenType != Token.LEFTCURLYBRACKET)
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Curly Bracket to start a CONSTRUCT Template", next);
            }

            // Use a Graph Pattern for the Construct Template
            GraphPattern constructTemplate = TryParseGraphPattern(context, false);

            // Check it doesn't contain anything other than Triple Patterns
            if (constructTemplate.IsFiltered)
            {
                throw new RdfParseException("A FILTER Clause cannot occur in a CONSTRUCT Template");
            }
            else if (constructTemplate.IsGraph)
            {
                throw new RdfParseException("A GRAPH Clause cannot occur in a CONSTRUCT Template");
            }
            else if (constructTemplate.IsOptional || constructTemplate.IsMinus || constructTemplate.IsExists || constructTemplate.IsNotExists  || constructTemplate.IsService || constructTemplate.IsSubQuery)
            {
                throw new RdfParseException("Graph Clauses (e.g. OPTIONAL, MINUS etc.) cannot occur in a CONSTRUCT Template");
            }
            else if (constructTemplate.IsUnion)
            {
                throw new RdfParseException("A UNION Clause cannot occur in a CONSTRUCT Template");
            }
            else if (constructTemplate.HasChildGraphPatterns)
            {
                throw new RdfParseException("Nested Graph Patterns cannot occur in a CONSTRUCT Template");
            }
            else if (!constructTemplate.TriplePatterns.All(p => p is IConstructTriplePattern))
            {
                throw new RdfParseException("A Construct Template may only be composed of Triple Patterns - Assignments, Property Paths, Sub-queries etc. are not permitted");
            }
            else if (constructTemplate.UnplacedAssignments.Any())
            {
                throw new RdfParseException("A Construct Template may not contain any Assignments");
            }
            else
            {
                // OK
                context.Query.ConstructTemplate = constructTemplate;
                if (shortForm) context.Query.RootGraphPattern = constructTemplate;
            }
        }

        private void TryParseFrom(SparqlQueryParserContext context)
        {
            if (context.SubQueryMode) throw new RdfQueryException("Dataset Descriptions are not permitted in Sub-queries");

            IToken next = context.Tokens.Dequeue();

            // Should be a FROM
            if (next.TokenType == Token.FROM)
            {
                // Default Graph/Named Graph Specified

                next = context.Tokens.Peek();
                if (next.TokenType == Token.URI)
                {
                    // Default Graph Specified
                    String baseUri = (context.Query.BaseUri == null) ? String.Empty : context.Query.BaseUri.AbsoluteUri;
                    context.Query.AddDefaultGraph(UriFactory.Create(Tools.ResolveUri(next.Value, baseUri)));
                    context.Tokens.Dequeue();
                }
                else if (next.TokenType == Token.QNAME)
                {
                    // Default Graph Specified
                    context.Query.AddDefaultGraph(ResolveQName(context, next.Value));
                    context.Tokens.Dequeue();
                }
                else if (next.TokenType == Token.NAMED)
                {
                    // Named Graph Specified
                    context.Tokens.Dequeue();
                    next = context.Tokens.Peek();
                    if (next.TokenType == Token.URI) 
                    {
                        String baseUri = (context.Query.BaseUri == null) ? String.Empty : context.Query.BaseUri.AbsoluteUri;
                        context.Query.AddNamedGraph(UriFactory.Create(Tools.ResolveUri(next.Value, baseUri)));
                        context.Tokens.Dequeue();
                    }
                    else if (next.TokenType == Token.QNAME)
                    {
                        context.Query.AddNamedGraph(ResolveQName(context, next.Value));
                        context.Tokens.Dequeue();
                    }
                    else
                    {
                        throw ParserHelper.Error("Expected a QName/URI Token to occur after a FROM NAMED Keyword to specify a Named Graph URI", next);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Expected a QName/URI Token to occur after a FROM Keyword to specify a Default Graph URI", next);
                }
            }
        }

        private void TryParseGraphPatterns(SparqlQueryParserContext context)
        {
            // Parse a Graph Pattern Object
            context.Query.RootGraphPattern = TryParseGraphPattern(context);
        }

        /// <summary>
        /// Tries to parse a Graph Pattern from the given Parser Context.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="requireOpeningLeftBracket">Whether the opening Left Curly Bracket is required.</param>
        /// <returns></returns>
        protected internal GraphPattern TryParseGraphPattern(SparqlQueryParserContext context, bool requireOpeningLeftBracket)
        {
            context.GraphPatternID++;
            IToken next;

            if (requireOpeningLeftBracket)
            {
                // Discard the opening {
                next = context.Tokens.Dequeue();
                if (next.TokenType != Token.LEFTCURLYBRACKET)
                {
                    throw ParserHelper.Error("Unexpected Token encountered, expected the start of a Graph Pattern", next);
                }
            }

            next = context.Tokens.Peek();

            if (next.TokenType == Token.RIGHTCURLYBRACKET)
            {
                // Empty Graph Pattern - Selects nothing
                context.Tokens.Dequeue();
                GraphPattern pattern = new GraphPattern();
                return pattern;
            }
            else if (next.TokenType == Token.LEFTCURLYBRACKET)
            {
                // Nested Graph Pattern
                GraphPattern pattern = new GraphPattern();
                GraphPattern child;// = new GraphPattern();

                child = TryParseGraphPattern(context, true);
                // this.TryParseTriplePatterns(context, child);
                pattern.AddGraphPattern(child);
                child = new GraphPattern();
                IToken lastToken = null;

                // Keep Parsing Graph Patterns until we hit a Right Curly Bracket
                do
                {
                    next = context.Tokens.Peek();
                    if (next.TokenType == Token.RIGHTCURLYBRACKET)
                    {
                        // This isn't in the switch as we want to break out of the loop when we get here
                        context.Tokens.Dequeue();
                        break;
                    }
                    else
                    {
                        switch (next.TokenType)
                        {
                            case Token.UNION:
                                // UNION Clause
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseUnionClause(context, pattern);
                                break;

                            case Token.FILTER:
                                // FILTER Clause
                                lastToken = context.Tokens.Dequeue();
                                TryParseFilterClause(context, pattern);
                                break;

                            case Token.BIND:
                                // BIND Clause
                                lastToken = context.Tokens.Dequeue();
                                TryParseBindAssignment(context, pattern);
                                break;

                            case Token.OPTIONAL:
                                // OPTIONAL Clause
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseOptionalClause(context, pattern);
                                break;

                            case Token.GRAPH:
                                // GRAPH Clause
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseGraphClause(context, pattern);
                                break;

                            case Token.EXISTS:
                            case Token.NOTEXISTS:
                            case Token.UNSAID:
                                // EXISTS/NOT EXISTS/UNSAID Clause
                                if (next.TokenType == Token.UNSAID && context.SyntaxMode != SparqlQuerySyntax.Extended) throw new RdfParseException("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended");
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseExistsClause(context, pattern, (next.TokenType == Token.EXISTS));
                                break;

                            case Token.MINUS_P:
                                // MINUS Clause
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseMinusClause(context, pattern);
                                break;

                            case Token.SERVICE:
                                // SERVICE clause
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseServiceClause(context, pattern);
                                break;

                            case Token.VALUES:
                                // VALUES clause
                                if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw ParserHelper.Error("Inline Data blocks (VALUES clauses) are not permitted in SPARQL 1.0", next);
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                pattern.AddInlineData(TryParseInlineData(context));
                                break;

                            case Token.DOT:
                                // Allowed after non-triple patterns
                                if (lastToken == null)
                                {
                                    throw ParserHelper.Error("Unexpected DOT in graph pattern.", next);
                                }
                                context.Tokens.Dequeue();
                                lastToken = null;
                                break;

                            case Token.VARIABLE:
                            case Token.URI:
                            case Token.QNAME:
                            case Token.LITERAL:
                            case Token.LONGLITERAL:
                            case Token.PLAINLITERAL:
                            case Token.BLANKNODE:
                            case Token.BLANKNODEWITHID:
                            case Token.LET:
                            case Token.LEFTSQBRACKET:
                            case Token.LEFTBRACKET:
                                // Start of some Triple Patterns
                                context.GraphPatternID++;
                                TryParseTriplePatterns(context, child);
                                lastToken = null;
                                break;

                            default:
                                // Otherwise we'll expect a new Graph Pattern
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                pattern.AddGraphPattern(TryParseGraphPattern(context, true));
                                break;
                        }
                    }
                } while (true);

                if (!child.IsEmpty)
                {
                    pattern.AddGraphPattern(child);
                }
                return pattern;
            }
            else
            {
                // Non-Empty Graph Pattern
                GraphPattern pattern = new GraphPattern();
                TryParseTriplePatterns(context, pattern);

                // Keep parsing Triple Patterns until we hit a Right Curly Bracket
                do
                {
                    next = context.Tokens.Peek();
                    if (next.TokenType == Token.RIGHTCURLYBRACKET)
                    {
                        break;
                    }
                    else
                    {
                        TryParseTriplePatterns(context, pattern);
                    }
                } while (true);

                // Discard the Right Curly Bracket
                context.Tokens.Dequeue();
                return pattern;
            }
        }

        private GraphPattern TryParseGraphPattern(SparqlQueryParserContext context)
        {
            return TryParseGraphPattern(context, true);
        }

        private void TryParseTriplePatterns(SparqlQueryParserContext context, GraphPattern p)
        {
            int lasttoken = context.Tokens.LastTokenType;
            IToken next = context.Tokens.Dequeue();

            // Allowed a Variable/RDF Term/Collection
            // OR we might go straight to a OPTIONAL/GRAPH/UNION/FILTER/EXISTS/NOT EXISTS/LET

            switch (next.TokenType)
            {
                case Token.COMMENT:
                    // Comments are discardable
                    TryParseTriplePatterns(context, p);
                    break;

                case Token.VARIABLE:
                    // Variable
                    context.LocalTokens.Push(next);
                    context.Query.AddVariable(next.Value);
                    TryParsePredicateObjectList(context, p,2);
                    break;

                case Token.URI:
                case Token.QNAME:
                case Token.LITERAL:
                case Token.LONGLITERAL:
                case Token.PLAINLITERAL:
                    // Must then be followed be a non-empty Property List
                    context.LocalTokens.Push(next);
                    TryParsePredicateObjectList(context, p,2);
                    break;

                case Token.BLANKNODE:
                case Token.BLANKNODEWITHID:
                    // Check list of Blank Node usages
                    if (context.BlankNodeIDUsages.ContainsKey(next.Value))
                    {
                        if (context.CheckBlankNodeScope && context.BlankNodeIDUsages[next.Value] != context.GraphPatternID)
                        {
                            throw ParserHelper.Error("Invalid use of Blank Node Label '" + next.Value + "', this Label has already been used in a different Graph Pattern", next);
                        }
                    }
                    else
                    {
                        context.BlankNodeIDUsages.Add(next.Value, context.GraphPatternID);
                    }

                    // Must then be followed be a non-empty Property List
                    context.LocalTokens.Push(next);
                    TryParsePredicateObjectList(context, p, 2);
                    break;

                case Token.LET:
                    // LET assignment
                    TryParseLetAssignment(context, p);
                    break;

                case Token.BIND:
                    // BIND assignment
                    TryParseBindAssignment(context, p);
                    break;

                case Token.LEFTSQBRACKET:
                    // Start of Blank Node Collection
                    // Create a new Blank Node Token
                    BlankNodeWithIDToken bnode = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), 0, 0, 0);

                    // Push twice, once for Subject of Collection
                    context.LocalTokens.Push(bnode);

                    next = context.Tokens.Peek();
                    if (next.TokenType == Token.RIGHTSQBRACKET)
                    {
                        // Single anonymous blank node
                        context.Tokens.Dequeue();

                        // Parse as Subject of Triples
                        TryParsePredicateObjectList(context, p, 2);
                    }
                    else
                    {

                        // Parse the Collection
                        TryParsePredicateObjectList(context, p, 2);

                        // Push again for subject of Triples
                        context.LocalTokens.Push(bnode);
                        TryParsePredicateObjectList(context, p, 2);
                    }
                    break;

                case Token.LEFTBRACKET:
                    // Collection
                    TryParseCollection(context, p, false);
                    TryParsePredicateObjectList(context, p, 2);
                    break;

                case Token.FILTER:
                    // FILTER Pattern
                    TryParseFilterClause(context, p);
                    break;

                case Token.OPTIONAL:
                    // OPTIONAL Clause
                    TryParseOptionalClause(context, p);
                    break;

                case Token.EXISTS:
                case Token.NOTEXISTS:
                case Token.UNSAID:
                    // EXISTS/NOT EXISTS clause
                    if (next.TokenType == Token.UNSAID && context.SyntaxMode != SparqlQuerySyntax.Extended) throw new RdfParseException("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended");
                    TryParseExistsClause(context, p, (next.TokenType == Token.EXISTS));
                    break;

                case Token.MINUS_P:
                    // MINUS clause
                    TryParseMinusClause(context, p);
                    break;

                case Token.SERVICE:
                    // SERVICE clause
                    TryParseServiceClause(context, p);
                    break;

                case Token.SELECT:
                    // Sub-query
                    TryParseSubquery(context, p);
                    break;

                case Token.GRAPH:
                    // GRAPH Clause
                    TryParseGraphClause(context, p);
                    break;

                case Token.UNION:
                    // UNION Clause
                    TryParseUnionClause(context, p);
                    break;

                case Token.VALUES:
                    // VALUES Clause
                    if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw ParserHelper.Error("Inline Data blocks (VALUES clauses) are not permitted in SPARQL 1.0", next);
                    p.AddInlineData(TryParseInlineData(context));
                    break;

                case Token.LEFTCURLYBRACKET:
                    // Nested Graph Pattern
                    p.AddGraphPattern(TryParseGraphPattern(context, false));

                    // Simplify Subqueries
                    if (p.ChildGraphPatterns.Last().IsSubQuery)
                    {
                        GraphPattern temp = p.LastChildPattern();
                        p.AddTriplePattern(temp.TriplePatterns.First());
                    }
                    break;

                case Token.DOT:
                    // Can Discard this if last character was the end of a nested Graph pattern
                    if (lasttoken == Token.RIGHTCURLYBRACKET || lasttoken == Token.RIGHTBRACKET)
                    {
                        // Can Discard this if the next character is not another DOT
                        next = context.Tokens.Peek();
                        if (next.TokenType != Token.DOT)
                        {
                            if (next.TokenType != Token.RIGHTCURLYBRACKET)
                            {
                                TryParseTriplePatterns(context, p);
                            }
                            else
                            {
                                return;
                            }
                        }
                        else
                        {
                            throw ParserHelper.Error("A DOT Token cannot follow another DOT Token within a Graph Pattern", next);
                        }
                    }
                    else if (lasttoken == Token.SEMICOLON)
                    {
                        // Allow Trailing Semicolon
                        return;
                    }
                    else
                    {
                        throw ParserHelper.Error("A DOT Token can only be used to terminate a Triple Pattern or a Nested Graph Pattern", next);
                    }
                    break;

                default:
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered when the start of a Triple Pattern was expected", next);
            }
        }

        private void TryParsePredicateObjectList(SparqlQueryParserContext context, GraphPattern p, int expectedCount)
        {
            PatternItem subj, pred, obj;
            
            // Subject is first thing on the Stack
            subj = TryCreatePatternItem(context, context.LocalTokens.Pop());

            // Start grabbing other stuff off the Stack and Parsing
            IToken next, lit, temp;
            ISparqlPath path;

            do
            {
                // Peek at the Next Token
                next = context.Tokens.Peek();
                switch (next.TokenType)
                {
                    case Token.COMMENT:
                        // Ignore Comments
                        context.Tokens.Dequeue();
                        break;

                    case Token.VARIABLE:
                        context.LocalTokens.Push(next);
                        context.Query.AddVariable(next.Value);
                        context.Tokens.Dequeue();
                        break;

                    case Token.URI:
                    case Token.QNAME:
                    case Token.LITERAL:
                    case Token.LONGLITERAL:
                    case Token.PLAINLITERAL:
                    case Token.KEYWORDA:
                        context.LocalTokens.Push(next);
                        context.Tokens.Dequeue();
                        break;

                    case Token.HAT:
                    case Token.DIVIDE:
                    case Token.BITWISEOR:
                    case Token.MULTIPLY:
                    case Token.PLUS:
                    case Token.QUESTION:
                    case Token.NEGATION:
                        // If we see any of these Tokens then it's a Property Path
                        if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Property Paths are not permitted in SPARQL 1.0");

                        if (context.LocalTokens.Count == expectedCount - 1)
                        {
                            path = context.PathParser.Parse(context, context.LocalTokens.Pop());
                            PathToken pathToken = new PathToken(path);
                            context.LocalTokens.Push(pathToken);
                        }
                        else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2)
                        {
                            // ^ and ! may be used to start a pattern
                            context.Tokens.Dequeue();
                            path = context.PathParser.Parse(context, next);
                            PathToken pathToken = new PathToken(path);
                            context.LocalTokens.Push(pathToken);
                        }
                        else
                        {
                            throw ParserHelper.Error("Encountered a '" + next.GetType().ToString() + "' Token which is valid only after a Predicate to indicate Path Cardinality", next);
                        }
                        break;

                    case Token.BLANKNODE:
                    case Token.BLANKNODEWITHID:
                        // Generate a new Blank Node ID if required
                        if (next.TokenType == Token.BLANKNODE)
                        {
                            next = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), 0, 0, 0);
                        }

                        // Check list of Blank Node usages
                        if (context.BlankNodeIDUsages.ContainsKey(next.Value))
                        {
                            if (context.CheckBlankNodeScope && context.BlankNodeIDUsages[next.Value] != context.GraphPatternID)
                            {
                                throw ParserHelper.Error("Invalid use of Blank Node Label '" + next.Value + "', this Label has already been used in a different Graph Pattern", next);
                            }
                        }
                        else
                        {
                            context.BlankNodeIDUsages.Add(next.Value, context.GraphPatternID);
                        }

                        context.LocalTokens.Push(next);
                        context.Tokens.Dequeue();
                        break;

                    case Token.HATHAT:
                        // Get the next Token which should be a Datatype Token
                        context.Tokens.Dequeue();
                        next = context.Tokens.Peek();
                        if (next.TokenType == Token.DATATYPE)
                        {
                            // Get the previous Token off the Stack and ensure it's a Literal
                            lit = context.LocalTokens.Pop();
                            if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL)
                            {
                                // Create a DataTyped Literal
                                context.LocalTokens.Push(new LiteralWithDataTypeToken(lit, (DataTypeToken)next));
                            }
                            else
                            {
                                throw ParserHelper.Error("Unexpected Datatype Token, a Datatype may only be specified after a quoted Literal/Long Literal", lit);
                            }
                        }
                        else
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token", next);
                        }
                        context.Tokens.Dequeue();
                        break;

                    case Token.LEFTSQBRACKET:
                        // Start of Blank Node Collection
                        // Create a new Blank Node Token
                        BlankNodeWithIDToken bnode = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), 0, 0, 0);

                        // Push twice, once for Object of the current Triple
                        context.LocalTokens.Push(bnode);

                        context.Tokens.Dequeue();
                        next = context.Tokens.Peek();
                        if (next.TokenType == Token.RIGHTSQBRACKET)
                        {
                            // Single anonymous blank node
                            context.Tokens.Dequeue();
                            break;
                        }

                        // Blank Node Collection
                        // Push again for Subject of new Triple
                        context.LocalTokens.Push(bnode);

                        // Recursively call self to parse the new Triple list
                        TryParsePredicateObjectList(context, p, expectedCount + 2);
                        break;

                    case Token.RIGHTSQBRACKET:
                        // End of Blank Node Collection

                        // Allow for trailing semicolon
                        if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON)
                        {
                            context.Tokens.Dequeue();
                            return;
                        }

                        // Check length of Stack
                        if (context.LocalTokens.Count < expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern", next);
                        }
                        else if (context.LocalTokens.Count > expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern - " + ExcessTokensString(context, expectedCount), next);
                        }
                        obj = TryCreatePatternItem(context, context.LocalTokens.Pop());

                        if (context.LocalTokens.Peek() is PathToken)
                        {
                            PathToken pathToken = context.LocalTokens.Pop() as PathToken;
                            p.AddTriplePattern(new PropertyPathPattern(subj, pathToken.Path, obj));
                        }
                        else
                        {
                            pred = TryCreatePatternItem(context, context.LocalTokens.Pop());
                            p.AddTriplePattern(new TriplePattern(subj, pred, obj));
                        }
                        context.Tokens.Dequeue();
                        return;

                    case Token.LEFTBRACKET:
                        // Property Path if it's the Predicate or Collection if it's the Object
                        if (context.LocalTokens.Count == expectedCount - 2)
                        {
                            // Property Path
                            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Property Paths are not permitted in SPARQL 1.0");
 
                            path = context.PathParser.Parse(context, context.Tokens.Dequeue());
                            PathToken pathToken = new PathToken(path);
                            context.LocalTokens.Push(pathToken);
                        }
                        else
                        {
                            // Collection
                            context.Tokens.Dequeue();
                            TryParseCollection(context, p, false);
                        }
                        break;

                    case Token.LANGSPEC:
                        // Get the previous Token off the Stack and ensure it's a Literal
                        lit = context.LocalTokens.Pop();
                        if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL)
                        {
                            // Create a Language Specified Literal
                            context.LocalTokens.Push(new LiteralWithLanguageSpecifierToken(lit, (LanguageSpecifierToken)next));
                        }
                        else
                        {
                            throw ParserHelper.Error("Unexpected Language Specifier Token, a Language Specifier may only be specified after a quoted Literal/Long Literal", lit);
                        }
                        context.Tokens.Dequeue();
                        break;

                    case Token.COMMA:
                        // End of a Triple Pattern

                        // Check length of stack
                        if (context.LocalTokens.Count < expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern", next);
                        }
                        else if (context.LocalTokens.Count > expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern - " + ExcessTokensString(context, expectedCount), next);
                        }
                        obj = TryCreatePatternItem(context, context.LocalTokens.Pop());
                        temp = context.LocalTokens.Pop();
                        if (temp.TokenType == Token.PATH)
                        {
                            path = ((PathToken)temp).Path;
                            p.AddTriplePattern(new PropertyPathPattern(subj, path, obj));
                        }
                        else
                        {
                            pred = TryCreatePatternItem(context, temp);

                            // Add Pattern to the Graph Pattern
                            p.AddTriplePattern(new TriplePattern(subj, pred, obj));
                        }

                        // Push Predicate back on Stack
                        context.LocalTokens.Push(temp);

                        context.Tokens.Dequeue();
                        break;

                    case Token.SEMICOLON:
                        // End of a Triple Pattern

                        // Check length of stack
                        if (context.LocalTokens.Count < expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern", next);
                        }
                        else if (context.LocalTokens.Count > expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern - " + ExcessTokensString(context, expectedCount), next);
                        }
                        obj = TryCreatePatternItem(context, context.LocalTokens.Pop());
                        temp = context.LocalTokens.Pop();
                        if (temp.TokenType == Token.PATH)
                        {
                            path = ((PathToken)temp).Path;
                            p.AddTriplePattern(new PropertyPathPattern(subj, path, obj));
                        }
                        else
                        {
                            pred = TryCreatePatternItem(context, temp);

                            // Add Pattern to the Graph Pattern
                            p.AddTriplePattern(new TriplePattern(subj, pred, obj));
                        }

                        context.Tokens.Dequeue();
                        break;

                    case Token.DOT:
                        // End of the Triple Patterns

                        // Allow for trailing semicolon and Blank Node Collection lists
                        if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0)))
                        {
                            if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET)
                            {
                                context.Tokens.Dequeue();
                            }
                            return;
                        }

                        // Check length of Stack
                        if (context.LocalTokens.Count < expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern", next);
                        }
                        else if (context.LocalTokens.Count > expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern - " + ExcessTokensString(context, expectedCount), next);
                        }
                        obj = TryCreatePatternItem(context, context.LocalTokens.Pop());
                        temp = context.LocalTokens.Pop();
                        if (temp.TokenType == Token.PATH)
                        {
                            path = ((PathToken)temp).Path;
                            p.AddTriplePattern(new PropertyPathPattern(subj, path, obj));
                        }
                        else
                        {
                            pred = TryCreatePatternItem(context, temp);

                            // Add Pattern to the Graph Pattern
                            p.AddTriplePattern(new TriplePattern(subj, pred, obj));
                        }
                        context.Tokens.Dequeue();
                        return;

                    case Token.LEFTCURLYBRACKET:
                    case Token.RIGHTCURLYBRACKET:
                    case Token.OPTIONAL:
                    case Token.EXISTS:
                    case Token.NOTEXISTS:
                    case Token.UNSAID:
                    case Token.MINUS_P:
                    case Token.SERVICE:
                    case Token.GRAPH:
                    case Token.FILTER:
                    case Token.VALUES:
                        // End of the Triple Patterns

                        // Allow for trailing semicolon and Blank Node Collection lists
                        if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0)))
                        {
                            return;
                        }

                        // Check length of Stack
                        if (context.LocalTokens.Count < expectedCount)
                        {
                            temp = context.LocalTokens.Peek();
                            if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA))
                            {
                                // In this case this should be a Cardinality Modifier on a path (we hope)
                                path = context.PathParser.Parse(context, context.LocalTokens.Pop());
                                IToken pathToken = new PathToken(path);
                                context.LocalTokens.Push(pathToken);
                                continue;
                            }
                            else
                            {
                                throw ParserHelper.Error("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern", next);
                            }
                        }
                        else if (context.LocalTokens.Count > expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern - " + ExcessTokensString(context, expectedCount), next);
                        }
                        obj = TryCreatePatternItem(context, context.LocalTokens.Pop());
                        temp = context.LocalTokens.Pop();
                        if (temp.TokenType == Token.PATH)
                        {
                            path = ((PathToken)temp).Path;
                            p.AddTriplePattern(new PropertyPathPattern(subj, path, obj));
                        }
                        else
                        {
                            pred = TryCreatePatternItem(context, temp);

                            // Add Pattern to the Graph Pattern
                            p.AddTriplePattern(new TriplePattern(subj, pred, obj));
                        }
                        return;
                    
                    default:
                        throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' while trying to Parse Triple Patterns", next);
                }
            } while (true);

        }

        private void TryParseCollection(SparqlQueryParserContext context, GraphPattern p, bool nested)
        {

            // Check the next Token
            IToken next = context.Tokens.Peek();
            if (next.TokenType == Token.RIGHTBRACKET)
            {
                // Empty Collection
                context.Tokens.Dequeue();

                if (!nested)
                {
                    // Push an rdf:nil Uri on the Stack
                    context.LocalTokens.Push(new UriToken("<" + NamespaceMapper.RDF + "nil>", next.StartLine, next.StartPosition, next.EndPosition));
                }
            }
            else
            {
                // Push a Blank Node Token onto the stack for the start of the collection
                BlankNodeWithIDToken blank; 
                if (!nested)
                {
                    blank = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);
                    context.LocalTokens.Push(blank);
                } 
                else 
                {
                    blank = new BlankNodeWithIDToken("_:sparql-autos" + context.BlankNodeID, next.StartLine, next.StartPosition, next.EndPosition);
                }

                bool first = true;

                IUriNode rdfFirst, rdfRest, rdfNil;
                rdfFirst = new UriNode(null, UriFactory.Create(NamespaceMapper.RDF + "first"));
                rdfRest = new UriNode(null, UriFactory.Create(NamespaceMapper.RDF + "rest"));
                rdfNil = new UriNode(null, UriFactory.Create(NamespaceMapper.RDF + "nil"));

                do
                {
                    next = context.Tokens.Peek();

                    switch (next.TokenType)
                    {
                        case Token.BLANKNODE:
                        case Token.BLANKNODEWITHID:
                        case Token.KEYWORDA:
                        case Token.LITERAL:
                        case Token.LONGLITERAL:
                        case Token.PLAINLITERAL:
                        case Token.QNAME:
                        case Token.URI:
                        case Token.VARIABLE:
                            // Create the Triple pattern

                            if (first)
                            {
                                // rdf:first Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, next)));
                                first = false;
                            }
                            else
                            {
                                // Get new Blank Node ID
                                BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine,next.StartPosition,next.EndPosition);

                                // rdf:rest Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfRest), TryCreatePatternItem(context, blank2)));

                                blank = blank2;

                                // rdf:first Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, next)));
                            }

                            break;

                        case Token.LEFTSQBRACKET:
                            // Is the next token a Right Square Bracket?
                            // ie. a [] for an anonymous blank node
                            context.Tokens.Dequeue();
                            next = context.Tokens.Peek();

                            if (next.TokenType == Token.RIGHTSQBRACKET)
                            {
                                BlankNodeWithIDToken anon = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                                if (first)
                                {
                                    // rdf:first Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, anon)));
                                    first = false;
                                }
                                else
                                {
                                    // Get new Blank Node ID
                                    BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                                    // rdf:rest Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfRest), TryCreatePatternItem(context, blank2)));

                                    blank = blank2;

                                    // rdf:first Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, anon)));
                                }
                            }
                            else
                            {
                                BlankNodeWithIDToken anon = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                                if (first)
                                {
                                    // rdf:first Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, anon)));
                                    first = false;
                                }
                                else
                                {
                                    // Get new Blank Node ID
                                    BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                                    // rdf:rest Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfRest), TryCreatePatternItem(context, blank2)));

                                    blank = blank2;

                                    // rdf:first Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, anon)));
                                }

                                // Parse the Blank Node Collection
                                context.LocalTokens.Push(anon);
                                TryParsePredicateObjectList(context, p, context.LocalTokens.Count + 1);
                                continue;
                            }
                            break;

                        case Token.LEFTBRACKET:

                            BlankNodeWithIDToken innerCollection = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                            if (first)
                            {
                                // rdf:first Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, innerCollection)));
                                first = false;
                            }
                            else
                            {
                                // Get new Blank Node ID
                                BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                                // rdf:rest Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfRest), TryCreatePatternItem(context, blank2)));

                                blank = blank2;

                                // rdf:first Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, innerCollection)));
                            }

                            context.Tokens.Dequeue();
                            TryParseCollection(context, p, true);
                            continue;

                        case Token.RIGHTBRACKET:
                            // End of Collection

                            // rdf:rest Pattern
                            p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfRest), new NodeMatchPattern(rdfNil)));
                            break;

                        default:
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Collection", next);
                    }

                    context.Tokens.Dequeue();
                } while (next.TokenType != Token.RIGHTBRACKET);
            }
        }

        private void TryParseFilterClause(SparqlQueryParserContext context, GraphPattern p)
        {
            // TODO: Refactor entire function to just rely on SparqlExpressionParser instead

            IToken next = context.Tokens.Dequeue();
            switch (next.TokenType)
            {
                case Token.LEFTBRACKET:
                    TryParseFilterExpression(context, p);
                    break;

                case Token.ABS:
                case Token.BNODE:
                case Token.BOUND:
                case Token.CALL:
                case Token.CEIL:
                case Token.COALESCE:
                case Token.CONCAT:
                case Token.DATATYPEFUNC:
                case Token.DAY:
                case Token.ENCODEFORURI:
                case Token.FLOOR:
                case Token.HOURS:
                case Token.IF:
                case Token.IRI:
                case Token.ISBLANK:
                case Token.ISIRI:
                case Token.ISLITERAL:
                case Token.ISNUMERIC:
                case Token.ISURI:
                case Token.LANG:
                case Token.LANGMATCHES:
                case Token.LCASE:
                case Token.MINUTES:
                case Token.MONTH:
                case Token.NOW:
                case Token.RAND:
                case Token.REPLACE:
                case Token.ROUND:
                case Token.SAMETERM:
                case Token.SECONDS:
                case Token.SHA1:
                case Token.SHA224:
                case Token.SHA256:
                case Token.SHA384:
                case Token.SHA512:
                case Token.STR:
                case Token.STRAFTER:
                case Token.STRBEFORE:
                case Token.CONTAINS:
                case Token.STRDT:
                case Token.STRENDS:
                case Token.STRLANG:
                case Token.STRLEN:
                case Token.STRSTARTS:
                case Token.STRUUID:
                case Token.SUBSTR:
                case Token.TIMEZONE:
                case Token.TZ:
                case Token.UCASE:
                case Token.URIFUNC:
                case Token.UUID:
                case Token.YEAR:
                    // Built-in functions
                    TryParseFilterBuiltInCall(context, next, p);
                    break;

                case Token.EXISTS:
                case Token.NOTEXISTS:
                    // EXISTS/NOT EXISTS
                    TryParseFilterExists(context, p, (next.TokenType == Token.EXISTS));
                    break;
                
                case Token.REGEX:
                    // Regular Expression
                    TryParseFilterRegex(context, next, p);
                    break;

                case Token.URI:
                case Token.QNAME:
                    // Extension function
                    TryParseFilterFunctionCall(context, next, p);
                    break;

                default:
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a FILTER Clause", next);
            }
        }

        private void TryParseFilterExpression(SparqlQueryParserContext context, GraphPattern p)
        {
            UnaryExpressionFilter filter = new UnaryExpressionFilter(TryParseExpression(context, false));
            p.IsFiltered = true;
            p.AddFilter(filter);
        }

        private void TryParseFilterBuiltInCall(SparqlQueryParserContext context, IToken t, GraphPattern p)
        {
            ISparqlFilter filter;
            IToken next = context.Tokens.Dequeue();

            // Should get a LeftBracket next
            if (next.TokenType != Token.LEFTBRACKET)
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Built-in Function call", next);
            }

            // Gather tokens for the FILTER expression
            Queue<IToken> subtokens = new Queue<IToken>();
            subtokens.Enqueue(t);
            subtokens.Enqueue(next);
            int openBrackets = 1;
            while (openBrackets > 0)
            {
                next = context.Tokens.Dequeue();
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }

                subtokens.Enqueue(next);
            }

            ISparqlExpression expr = context.ExpressionParser.Parse(subtokens);
            if (expr is BoundFunction)
            {
                filter = new BoundFilter((VariableTerm)expr.Arguments.First());
            }
            else
            {
                filter = new UnaryExpressionFilter(expr);
            }

            p.IsFiltered = true;
            p.AddFilter(filter);
        }

        private void TryParseFilterRegex(SparqlQueryParserContext context, IToken t, GraphPattern p)
        {
            // Gather all the Tokens that make up the Regex
            IToken next = context.Tokens.Peek();
            Queue<IToken> regexTokens = new Queue<IToken>();
            regexTokens.Enqueue(t);

            int openBrackets = 0;
            do
            {
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }

                regexTokens.Enqueue(next);
                context.Tokens.Dequeue();
                next = context.Tokens.Peek();

            } while (openBrackets > 0);

            UnaryExpressionFilter filter = new UnaryExpressionFilter(context.ExpressionParser.Parse(regexTokens));
            p.IsFiltered = true;
            p.AddFilter(filter);
        }

        private void TryParseFilterExists(SparqlQueryParserContext context, GraphPattern p, bool exists)
        {
            if (_syntax == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("EXISTS/NOT EXISTS is not supported in SPARQL 1.0");

            // EXISTS/NOT EXISTS generate a new Graph Pattern
            GraphPattern existsClause = TryParseGraphPattern(context);

            UnaryExpressionFilter filter = new UnaryExpressionFilter(new ExistsFunction(existsClause, exists));
            p.IsFiltered = true;
            p.AddFilter(filter);
        }

        private void TryParseFilterFunctionCall(SparqlQueryParserContext context, IToken t, GraphPattern p)
        {
            // Gather the Terms of the Function Call
            Queue<IToken> funcTokens = new Queue<IToken>();
            funcTokens.Enqueue(t);

            int openBrackets = 0;
            IToken next = context.Tokens.Peek();
            do
            {
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }

                funcTokens.Enqueue(next);
                context.Tokens.Dequeue();
                next = context.Tokens.Peek();

            } while (openBrackets > 0);

            UnaryExpressionFilter filter = new UnaryExpressionFilter(context.ExpressionParser.Parse(funcTokens));
            p.IsFiltered = true;
            p.AddFilter(filter);
        }

        private void TryParseOptionalClause(SparqlQueryParserContext context, GraphPattern p)
        {
            // Optional Clauses generate a child Graph Pattern
            GraphPattern child = TryParseGraphPattern(context);
            child.IsOptional = true;

            p.AddGraphPattern(child);
        }

        private void TryParseGraphClause(SparqlQueryParserContext context, GraphPattern p)
        {
            // Graph Clauses generate a child Graph Pattern

            // Get the Graph Specifier - must be a Variable/IRIRef
            IToken graphspec = context.Tokens.Dequeue();
            if (graphspec.TokenType != Token.URI && graphspec.TokenType != Token.QNAME && graphspec.TokenType != Token.VARIABLE)
            {
                throw ParserHelper.Error("Unexpected Token '" + graphspec.GetType().ToString() + "' encountered, expected a URI/QName/Variable Token to specify the active Graph for a GRAPH Clause", graphspec);
            }

            // Convert a QName or Relative Uri to a Absolute Uri
            if (graphspec.TokenType != Token.VARIABLE)
            {
                String u = Tools.ResolveUriOrQName(graphspec, context.Query.NamespaceMap, context.Query.BaseUri);
                if (!u.Equals(graphspec.Value))
                {
                    graphspec = new UriToken("<" + u + ">", graphspec.StartLine, graphspec.StartPosition, graphspec.EndPosition);
                }
            }
            else
            {
                context.Query.AddVariable(graphspec.Value);
            }

            GraphPattern child = TryParseGraphPattern(context);
            child.IsGraph = true;
            child.GraphSpecifier = graphspec;

            p.AddGraphPattern(child);

        }

        private void TryParseUnionClause(SparqlQueryParserContext context, GraphPattern p)
        {
            // Create a new Pattern which will hold the UNION
            GraphPattern union = new GraphPattern();
            union.IsUnion = true;

            // Add the Last Child Pattern of the Parent as that is the start of the UNION
            GraphPattern lastchild = p.LastChildPattern();
            if (lastchild.IsSimplifiable)
            {
                union.AddGraphPattern(lastchild.LastChildPattern());
            }
            else
            {
                union.AddGraphPattern(lastchild);
            }

            GraphPattern child = TryParseGraphPattern(context, true);
            union.AddGraphPattern(child);

            // Check for multiple
            IToken next = context.Tokens.Peek();
            while (next.TokenType == Token.UNION)
            {
                context.Tokens.Dequeue();
                union.AddGraphPattern(TryParseGraphPattern(context, true));
                next = context.Tokens.Peek();
            }

            p.AddGraphPattern(union);
        }

        private ISparqlExpression TryParseExpression(SparqlQueryParserContext context, bool commasTerminate)
        {
            return TryParseExpression(context, commasTerminate, false);
        }

        private ISparqlExpression TryParseExpression(SparqlQueryParserContext context, bool commasTerminate, bool asTerminates)
        {
            // Opening Bracket ( has already been discarded
            int openBrackets = 1;
            Queue<IToken> exprTerms = new Queue<IToken>();

            IToken next;
            while (openBrackets > 0)
            {
                // Get next Token
                next = context.Tokens.Peek();

                // Take account of nesting
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }
                else if (next.TokenType == Token.COMMA && openBrackets == 1 && commasTerminate)
                {
                    // Comma can terminate the Tokens that make an expression when only 1 bracket is open
                    openBrackets--;
                }
                else if (next.TokenType == Token.AS && openBrackets == 1 && asTerminates)
                {
                    // AS can terminate the Tokens that make an expression when only 1 bracket is open
                    openBrackets--;
                }
                else if (next.TokenType == Token.DISTINCT && openBrackets == 1 && commasTerminate)
                {
                    // DISTINCT can terminate the Tokens that make an expression if it occurs as the first thing and only 1 bracket is open
                    if (exprTerms.Count == 0)
                    {
                        context.Tokens.Dequeue();
                        return new DistinctModifier();
                    }
                    else
                    {
                        throw ParserHelper.Error("Unexpected DISTINCT Keyword Token encountered, DISTINCT modifier keyword may only occur as the first argument to an aggregate function", next);
                    }
                }

                if (openBrackets > 0)
                {
                    exprTerms.Enqueue(next);
                }
                context.Tokens.Dequeue();
            }

            // Use the internal Expression Parser
            return context.ExpressionParser.Parse(exprTerms);
        }

        private ISparqlExpression TryParseFunctionExpression(SparqlQueryParserContext context)
        {
            // Gather the Terms of the Function Call
            // We've already encountered a function keyword/QName/URI which is the start point
            Queue<IToken> funcTokens = new Queue<IToken>();
            funcTokens.Enqueue(context.Tokens.Dequeue());

            int openBrackets = 0;
            IToken next = context.Tokens.Peek();
            do
            {
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }

                funcTokens.Enqueue(next);
                context.Tokens.Dequeue();
                next = context.Tokens.Peek();

            } while (openBrackets > 0);

            return context.ExpressionParser.Parse(funcTokens);
        }

        private void TryParseOrderByClause(SparqlQueryParserContext context)
        {
            // ORDER BY has already been discarded
            IToken next = context.Tokens.Peek();

            // If SPARQL 1.1 then aggregates are permitted in ORDER BY
            if (context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0) context.ExpressionParser.AllowAggregates = true;

            ISparqlOrderBy first, last;
            first = last = null;
            int termsSeen = 0;
            bool exit = false;

            while (true)
            {
                switch (next.TokenType)
                {
                    case Token.VARIABLE:
                        // Simple Variable Order By
                        if (first == null)
                        {
                            first = new OrderByVariable(next.Value);
                            last = first;
                        }
                        else
                        {
                            last.Child = new OrderByVariable(next.Value);
                            last = last.Child;
                        }
                        context.Tokens.Dequeue();
                        break;

                    case Token.ASC:
                    case Token.DESC:
                        // Ascending/Descending Expression Order By

                        // Discard the ASC/DESC token
                        context.Tokens.Dequeue();
                        bool desc = (next.TokenType == Token.DESC);

                        // Discard the ( token
                        next = context.Tokens.Peek();
                        if (next.TokenType != Token.LEFTBRACKET)
                        {
                            throw new RdfParseException("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Bracket Token to start a Bracketted Expression after an ASC/DESC Token");
                        }
                        context.Tokens.Dequeue();

                        if (first == null)
                        {
                            first = new OrderByExpression(TryParseExpression(context, false));
                            first.Descending = desc;
                            last = first;
                        }
                        else
                        {
                            last.Child = new OrderByExpression(TryParseExpression(context, false));
                            last.Child.Descending = desc;
                            last = last.Child;
                        }
                        break;

                    case Token.LEFTBRACKET:
                        // Ascending Expression Order By

                        // Discard the Left Bracket
                        context.Tokens.Dequeue();

                        if (first == null)
                        {
                            first = new OrderByExpression(TryParseExpression(context, false));
                            last = first;
                        }
                        else
                        {
                            last.Child = new OrderByExpression(TryParseExpression(context, false));
                            last = last.Child;
                        }
                        break;

                    case Token.ABS:
                    case Token.BNODE:
                    case Token.BOUND:
                    case Token.CALL:
                    case Token.CEIL:
                    case Token.COALESCE:
                    case Token.CONCAT:
                    case Token.DATATYPEFUNC:
                    case Token.DAY:
                    case Token.ENCODEFORURI:
                    case Token.EXISTS:
                    case Token.FLOOR:
                    case Token.HOURS:
                    case Token.IF:
                    case Token.IRI:
                    case Token.ISBLANK:
                    case Token.ISIRI:
                    case Token.ISLITERAL:
                    case Token.ISNUMERIC:
                    case Token.ISURI:
                    case Token.LANG:
                    case Token.LANGMATCHES:
                    case Token.LCASE:
                    case Token.MINUTES:
                    case Token.MONTH:
                    case Token.NOTEXISTS:
                    case Token.NOW:
                    case Token.RAND:
                    case Token.REGEX:
                    case Token.REPLACE:
                    case Token.ROUND:
                    case Token.SAMETERM:
                    case Token.SECONDS:
                    case Token.SHA1:
                    case Token.SHA224:
                    case Token.SHA256:
                    case Token.SHA384:
                    case Token.SHA512:
                    case Token.STR:
                    case Token.STRAFTER:
                    case Token.STRBEFORE:
                    case Token.CONTAINS:
                    case Token.STRDT:
                    case Token.STRENDS:
                    case Token.STRLANG:
                    case Token.STRLEN:
                    case Token.STRSTARTS:
                    case Token.STRUUID:
                    case Token.SUBSTR:
                    case Token.TIMEZONE:
                    case Token.TZ:
                    case Token.UCASE:
                    case Token.URIFUNC:
                    case Token.UUID:
                    case Token.YEAR:
                    case Token.QNAME:
                    case Token.URI:
                        // Built-in/Extension Function Call Order By
                        ISparqlExpression expr = TryParseFunctionExpression(context);

                        if (first == null)
                        {
                            first = new OrderByExpression(expr);
                            last = first;
                        }
                        else
                        {
                            last.Child = new OrderByExpression(expr);
                            last = last.Child;
                        }
                        break;

                    case Token.AVG:
                    case Token.COUNT:
                    case Token.GROUPCONCAT:
                    case Token.MAX:
                    case Token.MIN:
                    case Token.SUM:
                    case Token.SAMPLE:
                        if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToSafeString() + "' encountered, aggregates are not permitted in an ORDER BY in SPARQL 1.0", next);

                        // Built-in/Extension Function Call Order By
                        ISparqlExpression aggExpr = TryParseFunctionExpression(context);

                        if (first == null)
                        {
                            first = new OrderByExpression(aggExpr);
                            last = first;
                        }
                        else
                        {
                            last.Child = new OrderByExpression(aggExpr);
                            last = last.Child;
                        }
                        break;

                    default:
                        if (termsSeen == 0)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a valid ORDER BY clause term", next);
                        }
                        else
                        {
                            exit = true;
                        }
                        break;
                }
                if (exit) break;

                termsSeen++;
                next = context.Tokens.Peek();
            }

            context.ExpressionParser.AllowAggregates = false;

            // Set to Query
            context.Query.OrderBy = first;
        }

        private void TryParseGroupByClause(SparqlQueryParserContext context)
        {
            if (_syntax == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("GROUP BY clauses are not supported in SPARQL 1.0");

            // GROUP BY has already been discarded
            IToken next = context.Tokens.Peek();

            ISparqlGroupBy first, last, current;
            ISparqlExpression expr;
            first = last = current = null;
            int termsSeen = 0;
            bool exit = false;
            bool terminateExpression = false;

            while (true)
            {
                switch (next.TokenType)
                {
                    case Token.VARIABLE:
                        // Simple Variable Group By

                        String name = next.Value.Substring(1);
                        terminateExpression = (context.Tokens.Peek().TokenType == Token.AS);
                        if (!terminateExpression)
                        {
                            current = new GroupByVariable(name, name);
                        }
                        else
                        {
                            current = new GroupByVariable(name);
                        }
                        if (first == null)
                        {
                            first = current;
                            last = first;
                        }
                        else
                        {
                            last.Child = current;
                            last = last.Child;
                        }
                        context.Tokens.Dequeue();
                        break;

                    case Token.LEFTBRACKET:
                        // Bracketted Expression Group By
                        context.Tokens.Dequeue();
                        expr = TryParseExpression(context, false, true);
                        terminateExpression = (context.Tokens.LastTokenType == Token.AS);
                        if (!terminateExpression && expr is VariableTerm)
                        {
                            current = new GroupByVariable(expr.Variables.First());
                        }
                        else
                        {
                            current = new GroupByExpression(expr);
                        }
                        if (first == null)
                        {
                            first = current;
                            last = first;
                        }
                        else
                        {
                            last.Child = current;
                            last = last.Child;
                        }
                        break;

                    case Token.ABS:
                    case Token.BNODE:
                    case Token.BOUND:
                    case Token.CALL:
                    case Token.CEIL:
                    case Token.COALESCE:
                    case Token.CONCAT:
                    case Token.DATATYPEFUNC:
                    case Token.DAY:
                    case Token.ENCODEFORURI:
                    case Token.EXISTS:
                    case Token.FLOOR:
                    case Token.HOURS:
                    case Token.IF:
                    case Token.IRI:
                    case Token.ISBLANK:
                    case Token.ISIRI:
                    case Token.ISLITERAL:
                    case Token.ISNUMERIC:
                    case Token.ISURI:
                    case Token.LANG:
                    case Token.LANGMATCHES:
                    case Token.LCASE:
                    case Token.MINUTES:
                    case Token.MONTH:
                    case Token.NOTEXISTS:
                    case Token.NOW:
                    case Token.RAND:
                    case Token.REGEX:
                    case Token.REPLACE:
                    case Token.ROUND:
                    case Token.SAMETERM:
                    case Token.SECONDS:
                    case Token.SHA1:
                    case Token.SHA224:
                    case Token.SHA256:
                    case Token.SHA384:
                    case Token.SHA512:
                    case Token.STR:
                    case Token.STRAFTER:
                    case Token.STRBEFORE:
                    case Token.CONTAINS:
                    case Token.STRDT:
                    case Token.STRENDS:
                    case Token.STRLANG:
                    case Token.STRLEN:
                    case Token.STRSTARTS:
                    case Token.STRUUID:
                    case Token.SUBSTR:
                    case Token.TIMEZONE:
                    case Token.TZ:
                    case Token.UCASE:
                    case Token.URIFUNC:
                    case Token.YEAR:
                    case Token.URI:
                    case Token.UUID:
                    case Token.QNAME:
                        // Function Expression Group By
                        expr = TryParseFunctionExpression(context);
                        terminateExpression = (context.Tokens.Peek().TokenType == Token.AS);
                        current = new GroupByExpression(expr);
                        if (first == null)
                        {
                            first = current;
                            last = first;
                        }
                        else
                        {
                            last.Child = current;
                            last = last.Child;
                        }
                        break;

                    default:
                        if (termsSeen == 0)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a valid GROUP BY clause term", next);
                        }
                        else
                        {
                            exit = true;
                        }
                        break;
                }
                if (exit) break;

                termsSeen++;
                next = context.Tokens.Peek();

                // Allow an AS ?var after an expression
                if (next.TokenType == Token.AS || terminateExpression)
                {
                    if (!terminateExpression) context.Tokens.Dequeue();
                    next = context.Tokens.Peek();
                    if (next.TokenType == Token.VARIABLE)
                    {
                        context.Tokens.Dequeue();
                        if (current != null) current.AssignVariable = next.Value.Substring(1);
                        next = context.Tokens.Peek();

                        // Find the terminating right bracket if required
                        if (terminateExpression)
                        {
                            if (next.TokenType != Token.RIGHTBRACKET)
                            {
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a ) to terminate the AS clause in a bracketted expression", next);
                            }
                            context.Tokens.Dequeue();
                            next = context.Tokens.Peek();
                        }
                    }
                    else
                    {
                        throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable Token after an AS token in a GROUP BY clause to specify the value to assign the GROUPed value to", next);
                    }
                }

                terminateExpression = false;
            }

            // Set to Query
            context.Query.GroupBy = first;
        }

        private void TryParseHavingClause(SparqlQueryParserContext context)
        {
            if (_syntax == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("HAVING clauses are not supported in SPARQL 1.0");
            // HAVING Keyword has already been discarded
            IToken next = context.Tokens.Peek();
            ISparqlExpression havingExpr;

            switch (next.TokenType)
            {
                case Token.LEFTBRACKET:
                    // Find and parse the Expression
                    context.Tokens.Dequeue();
                    int openBrackets = 1;
                    Queue<IToken> exprTerms = new Queue<IToken>();
                    while (openBrackets > 0)
                    {
                        // Get next Token
                        next = context.Tokens.Peek();

                        // Take account of nesting
                        if (next.TokenType == Token.LEFTBRACKET)
                        {
                            openBrackets++;
                        }
                        else if (next.TokenType == Token.RIGHTBRACKET)
                        {
                            openBrackets--;
                        }

                        if (openBrackets > 0)
                        {
                            exprTerms.Enqueue(next);
                        }
                        context.Tokens.Dequeue();
                    }

                    // Permit aggregates in the Expression
                    context.ExpressionParser.AllowAggregates = true;
                    havingExpr = context.ExpressionParser.Parse(exprTerms);
                    context.ExpressionParser.AllowAggregates = false;
                    break;

                case Token.ABS:
                case Token.BNODE:
                case Token.BOUND:
                case Token.CALL:
                case Token.CEIL:
                case Token.COALESCE:
                case Token.CONCAT:
                case Token.DATATYPEFUNC:
                case Token.DAY:
                case Token.ENCODEFORURI:
                case Token.EXISTS:
                case Token.FLOOR:
                case Token.HOURS:
                case Token.IF:
                case Token.IRI:
                case Token.ISBLANK:
                case Token.ISIRI:
                case Token.ISLITERAL:
                case Token.ISNUMERIC:
                case Token.ISURI:
                case Token.LANG:
                case Token.LANGMATCHES:
                case Token.LCASE:
                case Token.MINUTES:
                case Token.MONTH:
                case Token.NOTEXISTS:
                case Token.NOW:
                case Token.RAND:
                case Token.REGEX:
                case Token.REPLACE:
                case Token.ROUND:
                case Token.SAMETERM:
                case Token.SECONDS:
                case Token.SHA1:
                case Token.SHA224:
                case Token.SHA256:
                case Token.SHA384:
                case Token.SHA512:
                case Token.STR:
                case Token.STRAFTER:
                case Token.STRBEFORE:
                case Token.CONTAINS:
                case Token.STRDT:
                case Token.STRENDS:
                case Token.STRLANG:
                case Token.STRLEN:
                case Token.STRSTARTS:
                case Token.STRUUID:
                case Token.SUBSTR:
                case Token.TIMEZONE:
                case Token.TZ:
                case Token.UCASE:
                case Token.URIFUNC:
                case Token.YEAR:
                case Token.URI:
                case Token.UUID:
                case Token.QNAME:
                    // Built-in function/expression
                    context.ExpressionParser.AllowAggregates = true;
                    havingExpr = TryParseFunctionExpression(context);
                    context.ExpressionParser.AllowAggregates = false;
                    break;

                default:
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Bracket to start a bracketted expression in a HAVING Clause", next);
            }

            // Set the Having Clause of the Group By
            // For Leviathan we can just wrap in a standard Unary Expression Filter
            context.Query.Having = new UnaryExpressionFilter(havingExpr);
       }

        private void TryParseLimitOffsetClause(SparqlQueryParserContext context)
        {
            IToken next = context.Tokens.Dequeue();

            int limit, offset;
            limit = offset = 0;

            if (next.TokenType == Token.LIMIT)
            {
                // Expect a Plain Literal which can be parsed to an Integer
                next = context.Tokens.Dequeue();
                if (next.TokenType == Token.PLAINLITERAL)
                {
                    if (Int32.TryParse(next.Value, out limit))
                    {
                        context.Query.Limit = limit;

                        // Is there a subsequent OFFSET?
                        next = context.Tokens.Peek();
                        if (next.TokenType == Token.OFFSET)
                        {
                            context.Tokens.Dequeue();
                            next = context.Tokens.Dequeue();
                            if (next.TokenType == Token.PLAINLITERAL)
                            {
                                if (Int32.TryParse(next.Value, out offset))
                                {
                                    context.Query.Offset = offset;
                                }
                                else
                                {
                                    throw ParserHelper.Error("Unable to convert string '" + next.Value + "' into an Integer to use as the results offset for a OFFSET Clause", next);
                                }
                            }
                            else
                            {
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Plain Literal containing an Integer value as part of the OFFSET Clause", next);
                            }
                        }
                    }
                    else
                    {
                        throw ParserHelper.Error("Unable to convert string '" + next.Value + "' into an Integer to use as the results limit for a LIMIT Clause", next);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Plain Literal containing an Integer value as part of the LIMIT Clause", next);
                }
            }
            else if (next.TokenType == Token.OFFSET)
            {
                // Expect a Plain Literal which can be parsed to an Integer
                next = context.Tokens.Dequeue();
                if (next.TokenType == Token.PLAINLITERAL)
                {
                    if (Int32.TryParse(next.Value, out offset))
                    {
                        context.Query.Offset = offset;

                        // Is there a subsequent LIMIT?
                        next = context.Tokens.Peek();
                        if (next.TokenType == Token.LIMIT)
                        {
                            context.Tokens.Dequeue();
                            next = context.Tokens.Dequeue();
                            if (next.TokenType == Token.PLAINLITERAL)
                            {
                                if (Int32.TryParse(next.Value, out limit))
                                {
                                    context.Query.Limit = limit;
                                }
                                else
                                {
                                    throw ParserHelper.Error("Unable to convert string '" + next.Value + "' into an Integer to use as the results limit for a LIMIT Clause", next);
                                }
                            }
                            else
                            {
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Plain Literal containing an Integer value as part of the LIMIT Clause", next);
                            }
                        }
                    }
                    else
                    {
                        throw ParserHelper.Error("Unable to convert string '" + next.Value + "' into an Integer to use as the results offset for a OFFSET Clause", next);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Plain Literal containing an Integer value as part of the OFFSET Clause", next);
                }
            }
            else
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Limit/Offset Token to start a Limit Offset Clause", next);
            }
        }

        private void TryParseExistsClause(SparqlQueryParserContext context, GraphPattern p, bool exists)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("EXISTS and NOT EXISTS clauses are not supported in SPARQL 1.0");
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_1) throw new RdfParseException("EXISTS and NOT EXISTS clauses can only be used inside FILTER clauses in SPARQL 1.1");

            // EXISTS and NOT EXISTS generate a new Child Graph Pattern
            GraphPattern child = TryParseGraphPattern(context);

            if (exists)
            {
                child.IsExists = true;
            }
            else
            {
                child.IsNotExists = true;
            }

            p.AddGraphPattern(child);
        }

        private void TryParseMinusClause(SparqlQueryParserContext context, GraphPattern p)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("MINUS clauses are not supported in SPARQL 1.0");

            // MINUS generates a new child graph pattern
            GraphPattern child = TryParseGraphPattern(context);
            child.IsMinus = true;
            p.AddGraphPattern(child);
        }

        private void TryParseLetAssignment(SparqlQueryParserContext context, GraphPattern p)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("LET assignment is not supported in SPARQL 1.0");
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_1) throw new RdfParseException("LET assignment is not supported in SPARQL 1.1 - use BIND assignment instead");

            IToken variable;
            ISparqlExpression expr;

            // Firstly we expect an opening bracket, a variable and then an assignment operator
            IToken next = context.Tokens.Dequeue();
            if (next.TokenType == Token.LEFTBRACKET)
            {
                next = context.Tokens.Dequeue();
                if (next.TokenType == Token.VARIABLE)
                {
                    variable = next;
                    context.Query.AddVariable(variable.Value, false);
                    next = context.Tokens.Dequeue();
                    if (next.TokenType == Token.ASSIGNMENT)
                    {
                        // See if there is a valid expression for the right hand side of the assignment
                        next = context.Tokens.Peek();
                        switch (next.TokenType)
                        {
                            case Token.ABS:
                            case Token.BNODE:
                            case Token.BOUND:
                            case Token.CALL:
                            case Token.CEIL:
                            case Token.COALESCE:
                            case Token.CONCAT:
                            case Token.DATATYPEFUNC:
                            case Token.DAY:
                            case Token.ENCODEFORURI:
                            case Token.EXISTS:
                            case Token.FLOOR:
                            case Token.HOURS:
                            case Token.IF:
                            case Token.IRI:
                            case Token.ISBLANK:
                            case Token.ISIRI:
                            case Token.ISLITERAL:
                            case Token.ISNUMERIC:
                            case Token.ISURI:
                            case Token.LANG:
                            case Token.LANGMATCHES:
                            case Token.LCASE:
                            case Token.MINUTES:
                            case Token.MONTH:
                            case Token.NOTEXISTS:
                            case Token.NOW:
                            case Token.RAND:
                            case Token.REGEX:
                            case Token.REPLACE:
                            case Token.ROUND:
                            case Token.SAMETERM:
                            case Token.SECONDS:
                            case Token.SHA1:
                            case Token.SHA224:
                            case Token.SHA256:
                            case Token.SHA384:
                            case Token.SHA512:
                            case Token.STR:
                            case Token.STRAFTER:
                            case Token.STRBEFORE:
                            case Token.CONTAINS:
                            case Token.STRDT:
                            case Token.STRENDS:
                            case Token.STRLANG:
                            case Token.STRLEN:
                            case Token.STRSTARTS:
                            case Token.STRUUID:
                            case Token.SUBSTR:
                            case Token.TIMEZONE:
                            case Token.TZ:
                            case Token.UCASE:
                            case Token.URIFUNC:
                            case Token.UUID:
                            case Token.YEAR:
                            case Token.URI:
                            case Token.QNAME:
                                expr = TryParseFunctionExpression(context);
                                break;
                            case Token.LEFTBRACKET:
                                context.Tokens.Dequeue();
                                expr = TryParseExpression(context, false);
                                break;
                            case Token.VARIABLE:
                                context.Tokens.Dequeue();
                                expr = new VariableTerm(next.Value);
                                break;
                            default:
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Token which was valid as the start of an expression for the right hand side of a LET assignment", next);
                        }

                        // Finally expect a Right Bracket to terminate the LET
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.RIGHTBRACKET)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Right Bracket to terminate the LET assignment", next);
                        }
                        
                        // Create a Let Pattern and add to the Query appropriately
                        LetPattern let = new LetPattern(variable.Value.Substring(1), expr);
                        if (Options.QueryOptimisation)
                        {
                            p.AddAssignment(let);
                        }
                        else
                        {
                            // When Optimisation is turned off we'll just stick the Let in the Triples Pattern where it occurs
                            // since we're not going to do any Triple Pattern ordering, Assignment or FILTER placement
                            p.AddTriplePattern(let);
                        }
                    }
                    else
                    {
                        throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected an Assignment operator as part of a LET assignment", next);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable as the first item in a LET assignment", next);
                }
            }
            else
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Bracket to start a LET assignment after a LET Keyword", next);
            }
        }

        private void TryParseBindAssignment(SparqlQueryParserContext context, GraphPattern p)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("BIND assignment is not supported in SPARQL 1.0");

            // First need to discard opening (
            IToken next = context.Tokens.Dequeue();
            if (next.TokenType != Token.LEFTBRACKET) throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a ( to start a BIND assignment after a BIND keyword", next);

            // Expect a bracketted expression terminated by an AS
            ISparqlExpression expr = TryParseExpression(context, false, true);
            if (context.Tokens.LastTokenType != Token.AS)
            {
                throw ParserHelper.Error("A BIND assignment did not end with an AS ?var as expected, BIND assignment must be of the general form BIND(expr AS ?var)", next);
            }

            // Ensure there is a Variable after the AS
            next = context.Tokens.Dequeue();
            if (next.TokenType == Token.VARIABLE)
            {
                BindPattern bind = new BindPattern(next.Value.Substring(1), expr);

                // Check that the Variable has not already been used
                if (context.Query.RootGraphPattern != null && context.Query.RootGraphPattern.Variables.Contains(bind.VariableName))
                {
                    throw ParserHelper.Error("A BIND assignment is attempting to bind to the variable ?" + bind.VariableName + " but this variable is already in use in the query", next);
                }
                else if (p.Variables.Contains(bind.VariableName))
                {
                    throw ParserHelper.Error("A BIND assignment is attempting to bind to the variable ?" + bind.VariableName + " but this variable is already in use earlier in the Graph pattern", next);
                }

                if (Options.QueryOptimisation)
                {
                    p.AddAssignment(bind);
                }
                else
                {
                    // When Optimisation is turned off we'll just stick the BIND in the Triples Pattern where it occurs
                    // since we're not going to do any Triple Pattern ordering, Assignment or FILTER placement
                    p.AddTriplePattern(bind);
                    // In this case the BIND must break the BGP since using AddTriplePattern will not do it automatically
                    p.BreakBGP();
                }

                // Ensure the BIND assignment is terminated with a )
                next = context.Tokens.Dequeue();
                if (next.TokenType != Token.RIGHTBRACKET) throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a ) to terminate a BIND assignment", next);
            }
            else
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable after the AS in a BIND assignment", next);
            }
        }

        private void TryParseSubquery(SparqlQueryParserContext context, GraphPattern p)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Sub-queries are not supported in SPARQL 1.0");

            // We're going to make a temporary Token Queue which we will populate and then
            // use to create a new SPARQL Query Parser Context
            NonTokenisedTokenQueue tokens = new NonTokenisedTokenQueue();

            // Assume we've already seen a SELECT
            tokens.Enqueue(new BOFToken());
            tokens.Enqueue(new SelectKeywordToken(1, 1));

            // Now collect Tokens until we hit the closing Right Bracket
            int openBrackets = 1;
            do
            {
                IToken next = context.Tokens.Peek();

                if (next.TokenType == Token.LEFTCURLYBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTCURLYBRACKET)
                {
                    openBrackets--;
                }
                else if (next.TokenType == Token.EOF)
                {
                    throw ParserHelper.Error("Unexpected End of File encountered while trying to gather Tokens to parse a Sub-Query from", next);
                }

                if (openBrackets > 0)
                {
                    tokens.Enqueue(context.Tokens.Dequeue());
                }
            } while (openBrackets > 0);

            tokens.Enqueue(new EOFToken(0, 0));

            // Create a Sub-query Parser Context
            SparqlQueryParserContext subcontext = new SparqlQueryParserContext(context, tokens);
            subcontext.Query.NamespaceMap.Import(context.Query.NamespaceMap);
            SparqlQuery subquery = ParseInternal(subcontext);
            foreach (SparqlVariable var in subquery.Variables)
            {
                if (var.IsResultVariable) context.Query.AddVariable("?" + var.Name, false);
            }
            SubQueryPattern subqueryPattern = new SubQueryPattern(subquery);
            GraphPattern p2 = new GraphPattern();
            p2.AddTriplePattern(subqueryPattern);
            p.AddGraphPattern(p2);
        }

        private void TryParseServiceClause(SparqlQueryParserContext context, GraphPattern p)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("SERVICE clauses are not supported in SPARQL 1.0");

            // May allow an optional SILENT keyword
            bool silent = false;
            if (context.Tokens.Peek().TokenType == Token.SILENT)
            {
                context.Tokens.Dequeue();
                silent = true;
            }

            // SERVICE first has a URI/Variable service specifier
            IToken specifier = context.Tokens.Dequeue();
            if (specifier.TokenType != Token.URI && specifier.TokenType != Token.VARIABLE)
            {
                throw ParserHelper.Error("Unexpected Token '" + specifier.GetType().ToString() + "' encountered, expected a URI/Variable after a SERVICE keyword", specifier);
            }

            // Then a Graph Pattern
            GraphPattern child = TryParseGraphPattern(context);
            child.IsService = true;
            child.GraphSpecifier = specifier;
            child.IsSilent = silent;
            p.AddGraphPattern(child);
        }

        private BindingsPattern TryParseInlineData(SparqlQueryParserContext context)
        {
            // First expect either a single variable or a sequence of variables enclosed in ( )
            IToken next = context.Tokens.Peek();
            List<String> vars = new List<String>();
            bool simpleForm = false;
            if (next.TokenType == Token.LEFTBRACKET)
            {
                context.Tokens.Dequeue();
                next = context.Tokens.Peek();
                while (next.TokenType == Token.VARIABLE)
                {
                    vars.Add(next.Value.Substring(1));
                    context.Tokens.Dequeue();
                    next = context.Tokens.Peek();
                }
                if (next.TokenType != Token.RIGHTBRACKET) throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' ecountered, expected a ) to terminate the variables list for a VALUES clause", next);
                context.Tokens.Dequeue();
            }
            else if (next.TokenType == Token.VARIABLE)
            {
                // Using the simplified form of the syntax
                simpleForm = true;
                vars.Add(next.Value.Substring(1));
                context.Tokens.Dequeue();
            }
            else
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected variables list for a VALUES clause", next);
            }

            // Then expect a Left Curly Bracket
            next = context.Tokens.Peek();
            if (next.TokenType == Token.LEFTCURLYBRACKET)
            {
                context.Tokens.Dequeue();
                BindingsPattern bindings = new BindingsPattern(vars);

                // Each Binding tuple must start with a ( unless using simplified single variable syntax form
                next = context.Tokens.Peek();
                while ((simpleForm && next.TokenType != Token.RIGHTCURLYBRACKET) || next.TokenType == Token.LEFTBRACKET)
                {
                    if (!simpleForm)
                    {
                        // Discard the ( and peek the next token
                        context.Tokens.Dequeue();
                        next = context.Tokens.Peek();
                    }

                    // Expect a sequence of values in the tuple
                    List<PatternItem> values = new List<PatternItem>();
                    while (next.TokenType != Token.RIGHTBRACKET)
                    {
                        next = context.Tokens.Dequeue();

                        // Get the value
                        switch (next.TokenType)
                        {
                            case Token.URI:
                            case Token.QNAME:
                            case Token.LITERALWITHDT:
                            case Token.LITERALWITHLANG:
                            case Token.PLAINLITERAL:
                                values.Add(TryCreatePatternItem(context, next));
                                break;

                            case Token.LONGLITERAL:
                            case Token.LITERAL:
                                // Need to check for subsequent datatype or language declaration
                                IToken lit = next;
                                next = context.Tokens.Peek();
                                if (next.TokenType == Token.HATHAT)
                                {
                                    context.Tokens.Dequeue();
                                    next = context.Tokens.Dequeue();
                                    if (next.TokenType == Token.DATATYPE)
                                    {
                                        LiteralWithDataTypeToken dtlit = new LiteralWithDataTypeToken(lit, (DataTypeToken)next);
                                        values.Add(TryCreatePatternItem(context, dtlit));
                                    }
                                    else
                                    {
                                        throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Datatype Token to specify the datatype for a Literal", next);
                                    }
                                }
                                else if (next.TokenType == Token.LANGSPEC)
                                {
                                    context.Tokens.Dequeue();
                                    LiteralWithLanguageSpecifierToken langlit = new LiteralWithLanguageSpecifierToken(lit, (LanguageSpecifierToken)next);
                                    values.Add(TryCreatePatternItem(context, langlit));
                                }
                                else
                                {
                                    values.Add(TryCreatePatternItem(context, lit));
                                }
                                break;

                            case Token.UNDEF:
                                // UNDEF indicates an unbound variable which equates to a null
                                values.Add(null);
                                break;

                            default:
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Token for a URI/Literal or an UNDEF keyword as part of a tuple in a VALUES clause", next);
                        }

                        next = context.Tokens.Peek();

                        // For simplified syntax just break after each value
                        if (simpleForm) break;
                    }

                    if (vars.Count != values.Count)
                    {
                        throw new RdfParseException("Invalid tuple in the VALUES clause, each Binding should contain " + vars.Count + " values but got a tuple containing " + values.Count + " values");
                    }

                    // Generate a representation of this possible solution and add it to our Bindings object
                    bindings.AddTuple(new BindingTuple(vars, values));

                    // Discard the ) and peek the next token
                    if (!simpleForm) context.Tokens.Dequeue();
                    next = context.Tokens.Peek();
                }

                // Finally we need to see a Right Curly Bracket
                if (next.TokenType != Token.RIGHTCURLYBRACKET)
                {
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Right Curly Bracket to terminate the VALUES clause", next);
                }
                context.Tokens.Dequeue();

                return bindings;
            }
            else
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Curly Bracket after the list of variables as part of a VALUES clause", next);
            }
        }

        private PatternItem TryCreatePatternItem(SparqlQueryParserContext context, IToken t)
        {
            String baseUri;
            Uri u;

            switch (t.TokenType)
            {
                case Token.VARIABLE:
                    // Variables accept any Node as a substitution
                    return new VariablePattern(t.Value);

                case Token.URI:
                    // Uri uses a Node Match
                    if (t.Value.StartsWith("_:"))
                    {
                        return new FixedBlankNodePattern(t.Value);
                    }
                    else
                    {
                        String uri = Tools.ResolveUri(t.Value, context.Query.BaseUri.ToSafeString());
                        u = UriFactory.Create(uri);
                        return new NodeMatchPattern(new UriNode(null, u));
                    }

                case Token.QNAME:
                    // QName uses a Node Match
                    return new NodeMatchPattern(new UriNode(null, ResolveQName(context, t.Value)));

                case Token.LITERAL:
                case Token.LONGLITERAL:
                    // Literals use Node Matches
                    return new NodeMatchPattern(new NonNormalizedLiteralNode(null, t.Value));

                case Token.PLAINLITERAL:
                    // Plain Literals either use an inferred Literal Node Match
                    // We know it must be one of the inferrable types or the Parser would have failed at the Tokenisation stage for the Literal
                    if (TurtleSpecsHelper.IsValidDouble(t.Value))
                    {
                        // Double - Check first since to be considered a double must contain an exponent so is unique compared to 
                        // the other two numeric types
                        return new NodeMatchPattern(new LiteralNode(null, t.Value, UriFactory.Create(XmlSpecsHelper.XmlSchemaDataTypeDouble)));
                    }
                    else if (TurtleSpecsHelper.IsValidInteger(t.Value))
                    {
                        // Integer - Check before decimal as any valid integer is a valid decimal
                        return new NodeMatchPattern(new LiteralNode(null, t.Value, UriFactory.Create(XmlSpecsHelper.XmlSchemaDataTypeInteger)));
                    }
                    else if (TurtleSpecsHelper.IsValidDecimal(t.Value))
                    {
                        // Decimal - Check last since any valid integer is also a valid decimal
                        return new NodeMatchPattern(new LiteralNode(null, t.Value, UriFactory.Create(XmlSpecsHelper.XmlSchemaDataTypeDecimal)));
                    }
                    else
                    {
                        // Boolean
                        return new NodeMatchPattern(new LiteralNode(null, t.Value, UriFactory.Create(XmlSpecsHelper.XmlSchemaDataTypeBoolean)));
                    }


                case Token.LITERALWITHDT:
                    // Literal with Datatype use Node Matches
                    LiteralWithDataTypeToken litdt = (LiteralWithDataTypeToken)t;
                    if (litdt.DataType.StartsWith("<"))
                    {
                        baseUri = (context.Query.BaseUri == null) ? String.Empty : context.Query.BaseUri.AbsoluteUri;
                        u = UriFactory.Create(Tools.ResolveUri(litdt.DataType.Substring(1, litdt.DataType.Length - 2), baseUri));
                        return new NodeMatchPattern(new NonNormalizedLiteralNode(null, litdt.Value, u));
                    }
                    else
                    {
                        // Resolve the QName                       
                        return new NodeMatchPattern(new NonNormalizedLiteralNode(null, litdt.Value, ResolveQName(context, litdt.DataType)));
                    }

                case Token.LITERALWITHLANG:
                    // Literal with Lang Spec use Node Matches
                    LiteralWithLanguageSpecifierToken litls = (LiteralWithLanguageSpecifierToken)t;
                    return new NodeMatchPattern(new NonNormalizedLiteralNode(null, litls.Value, litls.Language));

                case Token.BLANKNODEWITHID:
                    // Blanks accept any Blank
                    return new BlankNodePattern(t.Value.Substring(2));

                case Token.KEYWORDA:
                    return new NodeMatchPattern(new UriNode(null, UriFactory.Create(NamespaceMapper.RDF + "type")));

                default:
                    throw ParserHelper.Error("Unable to Convert a '" + t.GetType().ToString() + "' to a Pattern Item in a Triple Pattern", t);
            }
        }

        private Uri ResolveQName(SparqlQueryParserContext context, String qname)
        {
            return UriFactory.Create(Tools.ResolveQName(qname, context.Query.NamespaceMap, context.Query.BaseUri));
        }

        private bool IsProjectableExpression(SparqlQueryParserContext context, ISparqlExpression expr, List<String> projectedSoFar)
        {
            if (expr.Type == SparqlExpressionType.Aggregate) return true;
            if (expr.Type == SparqlExpressionType.Primary)
            {
                return expr.Variables.All(v => context.Query.GroupBy.ProjectableVariables.Contains(v) || projectedSoFar.Contains(v));
            }
            else
            {
                return expr.Arguments.All(arg => IsProjectableExpression(context, arg, projectedSoFar));
            }
        }

        /// <summary>
        /// Constructs an error message that informs the user about unexpected excess tokens in a SPARQL qery.
        /// </summary>
        /// <param name="context">Current parser context.</param>
        /// <param name="expectedCount">The expected number of tokens.</param>
        /// <returns></returns>
        public string ExcessTokensString(SparqlQueryParserContext context, int expectedCount)
        {
            var builder = new StringBuilder();
            builder.Append("The following excess tokens were ecountered from Line ");

            List<IToken> excessTokens = new List<IToken>();
            while (context.LocalTokens.Count > expectedCount)
            {
                excessTokens.Add(context.LocalTokens.Pop());
            }
            excessTokens.Reverse();

            IToken first = excessTokens[0];
            builder.AppendLine(first.StartLine + " Column " + first.StartPosition + " onwards:");
            for (int i = 0; i < excessTokens.Count; i++)
            {
                builder.Append(excessTokens[i].Value);
                builder.Append(' ');
            }
            builder.AppendLine();
            builder.Append("You may be missing some syntax to divide these tokens into multiple triple patterns");
            return builder.ToString();
        }
        
        #endregion
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using VDS.RDF.Parsing.Contexts;
using VDS.RDF.Parsing.Tokens;
using VDS.RDF.Query;
using VDS.RDF.Query.Aggregates;
using VDS.RDF.Query.Expressions;
using VDS.RDF.Query.Expressions.Functions.Sparql.Boolean;
using VDS.RDF.Query.Expressions.Primary;
using VDS.RDF.Query.Filters;
using VDS.RDF.Query.Grouping;
using VDS.RDF.Query.Optimisation;
using VDS.RDF.Query.Ordering;
using VDS.RDF.Query.Paths;
using VDS.RDF.Query.Patterns;

namespace VDS.RDF.Parsing
{
    /// <summary>
    /// Available Query Syntaxes.
    /// </summary>
    public enum SparqlQuerySyntax
    {
        /// <summary>
        /// Use SPARQL 1.0
        /// </summary>
        Sparql_1_0,
        /// <summary>
        /// Use SPARQL 1.1
        /// </summary>
        Sparql_1_1,
        /// <summary>
        /// Use the latest SPARQL specification supported by the library (currently SPARQL 1.1) with some extensions
        /// </summary>
        /// <remarks>
        /// <para>
        /// Extensions include the following:
        /// </para>
        /// <ul>
        /// <li><strong>LET</strong> assignments (we recommend using the SPARQL 1.1 standards BIND instead)</li>
        /// <li>Additional aggregates - <strong>NMAX</strong>, <strong>NMIN</strong>, <strong>MEDIAN</strong> and <strong>MODE</strong> (we recommend using the Leviathan Function Library URIs for these instead to make them usable in SPARQL 1.1 mode)</li>
        /// <li><strong>UNSAID</strong> alias for <strong>NOT EXISTS</strong> (we recommend using the SPARQL 1.1 standard NOT EXISTS instead</li>
        /// <li><strong>EXISTS</strong> and <strong>NOT EXISTS</strong> are permitted as Graph Patterns (only allowed in FILTERs in SPARQL 1.1)</li>
        /// </ul>
        /// </remarks>
        Extended,
    }

    /// <summary>
    /// Class for parsing SPARQL Queries into <see cref="SparqlQuery">SparqlQuery</see> objects that can be used to query a Graph or Triple Store.
    /// </summary>
    public class SparqlQueryParser
        : ITraceableTokeniser, IObjectParser<SparqlQuery>
    {
        private readonly TokenQueueMode _queuemode = TokenQueueMode.QueueAllBeforeParsing;
        private bool _tracetokeniser = false;
        private Uri _defaultBaseUri = null;
        private SparqlQuerySyntax _syntax = Options.QueryDefaultSyntax;
        private IEnumerable<ISparqlCustomExpressionFactory> _factories = Enumerable.Empty<ISparqlCustomExpressionFactory>();
        private IQueryOptimiser _optimiser = null;

        #region Constructors and Properties

        /// <summary>
        /// Creates a new instance of the SPARQL Query Parser.
        /// </summary>
        public SparqlQueryParser()
            : this(TokenQueueMode.QueueAllBeforeParsing) { }

        /// <summary>
        /// Creates a new instance of the SPARQL Query Parser which supports the given SPARQL Syntax.
        /// </summary>
        /// <param name="syntax">SPARQL Syntax.</param>
        public SparqlQueryParser(SparqlQuerySyntax syntax)
            : this(TokenQueueMode.QueueAllBeforeParsing, syntax) { }

        /// <summary>
        /// Creates a new instance of the SPARQL Query Parser using the given Tokeniser Queue Mode.
        /// </summary>
        /// <param name="queueMode">Token Queue Mode.</param>
        public SparqlQueryParser(TokenQueueMode queueMode)
            : this(queueMode, Options.QueryDefaultSyntax) { }

        /// <summary>
        /// Creates a new instance of the SPARQL Query Parser using the given Tokeniser which supports the given SPARQL Syntax.
        /// </summary>
        /// <param name="queueMode">Token Queue Mode.</param>
        /// <param name="syntax">SPARQL Syntax.</param>
        public SparqlQueryParser(TokenQueueMode queueMode, SparqlQuerySyntax syntax)
        {
            _queuemode = queueMode;
            _syntax = syntax;
        }

        /// <summary>
        /// Gets/Sets whether Tokeniser progress is Traced to the Console.
        /// </summary>
        public bool TraceTokeniser
        {
            get
            {
                return _tracetokeniser;
            }
            set
            {
                _tracetokeniser = value;
            }
        }

        /// <summary>
        /// Gets/Sets the Default Base URI for Queries parsed by this Parser instance.
        /// </summary>
        public Uri DefaultBaseUri
        {
            get
            {
                return _defaultBaseUri;
            }
            set
            {
                _defaultBaseUri = value;
            }
        }

        /// <summary>
        /// Gets/Sets the Syntax that should be supported.
        /// </summary>
        public SparqlQuerySyntax SyntaxMode
        {
            get
            {
                return _syntax;
            }
            set
            {
                _syntax = value;
            }
        }

        /// <summary>
        /// Gets/Sets the locally scoped custom expression factories.
        /// </summary>
        public IEnumerable<ISparqlCustomExpressionFactory> ExpressionFactories
        {
            get
            {
                return _factories;
            }
            set
            {
                if (value != null)
                {
                    _factories = value;
                }
                else
                {
                    _factories = Enumerable.Empty<ISparqlCustomExpressionFactory>();
                }
            }
        }

        /// <summary>
        /// Gets/Sets the locally scoped Query Optimiser applied to queries at the end of the parsing process.
        /// </summary>
        /// <remarks>
        /// <para>
        /// May be null if no locally scoped optimiser is set in which case the globally scoped optimiser will be used.
        /// </para>
        /// </remarks>
        public IQueryOptimiser QueryOptimiser
        {
            get
            {
                return _optimiser;
            }
            set
            {
                _optimiser = value;
            }
        }

        #endregion

        #region Events

        /// <summary>
        /// Helper Method which raises the Warning event when a non-fatal issue with the SPARQL Query being parsed is detected.
        /// </summary>
        /// <param name="message">Warning Message.</param>
        private void RaiseWarning(String message)
        {
            SparqlWarning d = Warning;
            if (d != null)
            {
                d(message);
            }
        }

        /// <summary>
        /// Event raised when a non-fatal issue with the SPARQL Query being parsed is detected
        /// </summary>
        public event SparqlWarning Warning;

        #endregion

        #region Public Parser Methods

        /// <summary>
        /// Parses a SPARQL Query from a File.
        /// </summary>
        /// <param name="queryFile">File containing the Query.</param>
        /// <returns></returns>
        public SparqlQuery ParseFromFile(String queryFile)
        {
            if (queryFile == null) throw new RdfParseException("Cannot parse a SPARQL Query from a null File");
            StreamReader reader = new StreamReader(File.OpenRead(queryFile), Encoding.UTF8);
            return ParseInternal(reader);
        }

        /// <summary>
        /// Parses a SPARQL Query from an arbitrary Input Stream.
        /// </summary>
        /// <param name="input">Input Stream.</param>
        /// <returns></returns>
        public SparqlQuery Parse(StreamReader input)
        {
            if (input == null) throw new RdfParseException("Cannot parse a SPARQL Query from a null Stream");

            // Issue a Warning if the Encoding of the Stream is not UTF-8
            if (!input.CurrentEncoding.Equals(Encoding.UTF8))
            {
                RaiseWarning("Expected Input Stream to be encoded as UTF-8 but got a Stream encoded as " + input.CurrentEncoding.EncodingName + " - Please be aware that parsing errors may occur as a result");
            }

            return ParseInternal(input);
        }

        /// <summary>
        /// Parses a SPARQL Query from an arbitrary Input.
        /// </summary>
        /// <param name="input">Input.</param>
        /// <returns></returns>
        public SparqlQuery Parse(TextReader input)
        {
            if (input == null) throw new RdfParseException("Cannot parse a SPARQL Query from a null TextReader");
            return ParseInternal(input);
        }

        /// <summary>
        /// Parses a SPARQL Query from a String.
        /// </summary>
        /// <param name="queryString">A SPARQL Query.</param>
        /// <returns></returns>
        public SparqlQuery ParseFromString(String queryString)
        {
            if (queryString == null) throw new RdfParseException("Cannot parse a SPARQL Query from a null String");
            return ParseInternal(new StringReader(queryString));
        }

        /// <summary>
        /// Parses a SPARQL Query from a SPARQL Parameterized String.
        /// </summary>
        /// <param name="queryString">A SPARQL Parameterized String.</param>
        /// <returns></returns>
        /// <remarks>
        /// The <see cref="SparqlParameterizedString">SparqlParameterizedString</see> class allows you to use parameters in a String in a manner similar to SQL Commands in the ADO.Net model.  See the documentation for <see cref="SparqlParameterizedString">SparqlParameterizedString</see> for details of this.
        /// </remarks>
        public SparqlQuery ParseFromString(SparqlParameterizedString queryString)
        {
            if (queryString == null) throw new RdfParseException("Cannot parse a SPARQL Query from a null String");
            return ParseFromString(queryString.ToString());
        }

        #endregion

        #region Internal Parsing Logic

        private SparqlQuery ParseInternal(TextReader input)
        {
            try
            {
                // Create the Parser Context
                SparqlQueryParserContext context = new SparqlQueryParserContext(new SparqlTokeniser(input, _syntax), _queuemode, false, _tracetokeniser);
                context.SyntaxMode = _syntax;
                context.ExpressionParser.SyntaxMode = context.SyntaxMode;
                context.ExpressionFactories = _factories;

                return ParseInternal(context);
            }
            catch
            {
                throw;
            }
            finally
            {
                try
                {
                    input.Close();
                }
                catch
                {
                    // No catch actions just trying to clean up the stream
                }
            }
        }

        private SparqlQuery ParseInternal(SparqlQueryParserContext context)
        {
            IToken temp = null;

            // Initialise Context with relevant data
            context.DefaultBaseUri = _defaultBaseUri;
            context.ExpressionParser.NamespaceMap = context.Query.NamespaceMap;
            context.ExpressionParser.QueryParser = this;
            context.ExpressionParser.ExpressionFactories = context.ExpressionFactories;
            context.Tokens.InitialiseBuffer();
            context.SyntaxMode = _syntax;
            context.Query.ExpressionFactories = context.ExpressionFactories.ToList();

            do
            {
                temp = context.Tokens.Dequeue();

                switch (temp.TokenType)
                {
                    case Token.BOF:
                    case Token.COMMENT:
                    case Token.EOF:
                        // Discardable Tokens
                        break;

                    case Token.BASEDIRECTIVE:
                        TryParseBaseDeclaration(context);
                        break;
                    case Token.PREFIXDIRECTIVE:
                        TryParsePrefixDeclaration(context);
                        break;

                    case Token.ASK:
                    case Token.CONSTRUCT:
                    case Token.DESCRIBE:
                    case Token.SELECT:
                        TryParseQueryVerb(context, temp);

                        // Get Variables for a Select or Describe or Construct
                        if (context.Query.QueryType == SparqlQueryType.Select)
                        {
                            TryParseSelectVariables(context);
                        }
                        else if (context.Query.QueryType == SparqlQueryType.Describe)
                        {
                            TryParseDescribeVariables(context);
                        }
                        else if (context.Query.QueryType == SparqlQueryType.Construct)
                        {
                            TryParseConstructTemplate(context);
                        }

                        // Get Datasets (FROM Clauses)
                        temp = context.Tokens.Peek();
                        while (temp.TokenType == Token.FROM)
                        {
                            TryParseFrom(context);
                            temp = context.Tokens.Peek();
                        }

                        // Unless a SHORT Form CONSTRUCT then we need to check for a WHERE { } clause
                        // If the Query is a DESCRIBE then if there is no WHERE keyword the WHERE clause is not required
                        if (context.Query.QueryType != SparqlQueryType.Construct || (context.Query.QueryType == SparqlQueryType.Construct && context.Query.RootGraphPattern == null))
                        {
                            // Check for Optional WHERE and Discard
                            temp = context.Tokens.Peek();
                            bool whereSeen = false;
                            if (temp.TokenType == Token.WHERE)
                            {
                                context.Tokens.Dequeue();
                                whereSeen = true;
                            }

                            // Unless it's a DESCRIBE we must now see a Graph Pattern 
                            // OR if the next Token is a { then it must be a Graph Pattern regardless
                            // OR we saw a WHERE in which case we must have a Graph Pattern
                            temp = context.Tokens.Peek();
                            if (whereSeen || context.Query.QueryType != SparqlQueryType.Describe || temp.TokenType == Token.LEFTCURLYBRACKET)
                            {
                                TryParseGraphPatterns(context);
                            }
                        }

                        // If we're an ASK then we shouldn't have any Solution Modifier for SPARQL 1.0
                        // SPARQL 1.1 allows modifiers so we don't continue if using SPARQL 1.1
                        if (context.Query.QueryType == SparqlQueryType.Ask && context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) continue;

                        // Otherwise we can now have a Solution Modifier

                        // Firstly a possible GROUP BY clause
                        temp = context.Tokens.Peek();
                        if (temp.TokenType == Token.GROUPBY)
                        {
                            context.Tokens.Dequeue();
                            TryParseGroupByClause(context);

                            // Then a possible HAVING clause
                            temp = context.Tokens.Peek();
                            if (temp.TokenType == Token.HAVING)
                            {
                                context.Tokens.Dequeue();
                                TryParseHavingClause(context);
                            }
                        }
                        else if (temp.TokenType == Token.HAVING)
                        {
                            // Can have a HAVING without a GROUP BY
                            context.Tokens.Dequeue();
                            TryParseHavingClause(context);
                        }

                        // Check that either there are no Aggregates used or only Aggregates used
                        if (SparqlSpecsHelper.IsSelectQuery(context.Query.QueryType) && (context.Query.IsAggregate && context.Query.GroupBy == null))
                        {
                            // CORE-446
                            // Cope with the case where aggregates are used inside other functions
                            foreach (SparqlVariable var in context.Query.Variables)
                            {
                                if (!var.IsResultVariable) continue;
                                if (var.IsAggregate) continue;

                                if (var.IsProjection)
                                {
                                    // Maybe OK if the projection operates over aggregates or group keys
                                    ISparqlExpression expr = var.Projection;
                                    Queue<ISparqlExpression> exprs = new Queue<ISparqlExpression>(expr.Arguments);
                                    while (exprs.Count > 0)
                                    {
                                        expr = exprs.Dequeue();

                                        // Aggregates are OK
                                        if (expr is AggregateTerm) continue;

                                        // Other primary expressions are OK
                                        if (expr is ConstantTerm) continue;
                                        if (expr is AllModifier) continue;
                                        if (expr is DistinctModifier) continue;

                                        // Variables may 
                                        if (expr is VariableTerm)
                                        {
                                            String exprVar = expr.Variables.First();
                                            if (!context.Query.Variables.Any(v => v.IsAggregate && v.Name.Equals(exprVar)))
                                            {
                                                throw new RdfParseException("The Select Query is invalid since it contains both Aggregates and Variables in the SELECT Clause but it does not contain a GROUP BY clause");
                                            }
                                        }

                                        // Anything else need to check its arguments
                                        foreach (ISparqlExpression arg in expr.Arguments)
                                        {
                                            exprs.Enqueue(arg);
                                        }
                                    }
                                }
                                else
                                {
                                    throw new RdfParseException("The Select Query is invalid since it contains both Aggregates and Variables in the SELECT Clause but it does not contain a GROUP BY clause");
                                }
                            }
                            
                        }

                        // Then a possible ORDER BY clause
                        temp = context.Tokens.Peek();
                        if (temp.TokenType == Token.ORDERBY)
                        {
                            context.Tokens.Dequeue();
                            TryParseOrderByClause(context);
                        }

                        // Then a possible LIMIT/OFFSET clause
                        temp = context.Tokens.Peek();
                        if (temp.TokenType == Token.LIMIT || temp.TokenType == Token.OFFSET)
                        {
                            TryParseLimitOffsetClause(context);
                        }

                        // Finally if we're a SELECT then we can have a BINDINGS clause
                        if (SparqlSpecsHelper.IsSelectQuery(context.Query.QueryType))
                        {
                            temp = context.Tokens.Peek();
                            if (temp.TokenType == Token.BINDINGS || temp.TokenType == Token.VALUES)
                            {
                                if (temp.TokenType == Token.BINDINGS && context.SyntaxMode != SparqlQuerySyntax.Extended) throw ParserHelper.Error("The BINDINGS keyword is the old name for the VALUES keyword, use the VALUES keyword instead", temp);
                                if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw ParserHelper.Error("Inline Data blocks (VALUES clauses) are not permitted in SPARQL 1.0", temp);
                                context.Tokens.Dequeue();
                                context.Query.Bindings = TryParseInlineData(context);
                            }
                        }

                        break;

                    default:
                        if (context.Query.QueryType == SparqlQueryType.Ask)
                        {
                            throw ParserHelper.Error("Unexpected Token encountered, a valid ASK query has been parsed but additional invalid tokens are present after the Graph pattern", temp);
                        }
                        else
                        {
                            throw ParserHelper.Error("Unexpected Token encountered - expected a BASE/PREFIX directive or a Query Keyword to start a Query", temp);
                        }
                }
            } while (temp.TokenType != Token.EOF);

            // If not SPARQL 1.0 then do additional post parsing checks
            if (_syntax != SparqlQuerySyntax.Sparql_1_0)
            {
                switch (context.Query.QueryType)
                {
                    case SparqlQueryType.Select:
                    case SparqlQueryType.SelectDistinct:
                    case SparqlQueryType.SelectReduced:
                    case SparqlQueryType.Describe:
                        // Check Variable Usage
                        List<String> projectedSoFar = new List<string>();
                        List<String> mainBodyVars = (context.Query.RootGraphPattern != null ? context.Query.RootGraphPattern.Variables : Enumerable.Empty<String>()).Distinct().ToList();
                        foreach (SparqlVariable var in context.Query.Variables)
                        {
                            if (!var.IsResultVariable) continue;

                            if (projectedSoFar.Contains(var.Name) && (var.IsAggregate || var.IsProjection))
                            {
                                throw new RdfParseException("Cannot assign the results of an Aggregate/Project Expression to the variable " + var.ToString() + " as this variable is already Projected to earlier in the SELECT");
                            }

                            if (var.IsProjection)
                            {
                                if (mainBodyVars.Contains(var.Name)) throw new RdfParseException("Cannot project an expression to the variable " + var.Name + " as this variable is a bound variable from the main body of the query");
                                if (context.Query.GroupBy != null)
                                {
                                    if (!IsProjectableExpression(context, var.Projection, projectedSoFar))
                                    {
                                        throw new RdfParseException("Your SELECT uses the Project Expression " + var.Projection.ToString() + " which uses one/more variables which are either not projectable from the GROUP BY or not projected earlier in the SELECT.  All Variables used must be projectable from the GROUP BY, projected earlier in the SELECT or within an aggregate");
                                    }
                                }
                            }
                            else if (var.IsAggregate)
                            {
                                if (mainBodyVars.Contains(var.Name)) throw new RdfParseException("Cannot project an aggregate to the variable " + var.Name + " as this variable is a bound variable from the main body of the query");
                                if (context.Query.GroupBy != null)
                                {
                                    // Q: Does ISparqlAggregate needs to expose a Variables property?
                                    // if (!var.Aggregate.Var
                                }
                            }
                            else
                            {
                                if (context.Query.GroupBy != null)
                                {
                                    // If there is a GROUP BY then the Variable must either be projectable from there
                                    if (!context.Query.GroupBy.ProjectableVariables.Contains(var.Name))
                                    {
                                        throw new RdfParseException("Your SELECT/DESCRIBE query tries to project the variable " + var.ToString() + " but this Variable is not Grouped By");
                                    }
                                }
                            }

                            projectedSoFar.Add(var.Name);
                        }
                        break;

                    case SparqlQueryType.DescribeAll:
                    case SparqlQueryType.SelectAll:
                    case SparqlQueryType.SelectAllDistinct:
                    case SparqlQueryType.SelectAllReduced:
                        // Check that a GROUP BY has not been used
                        if (context.Query.GroupBy != null)
                        {
                            throw new RdfParseException("SELECT/DESCRIBE * is not permitted when a GROUP BY is used");
                        }
                        break;
                }
            }

            // Optimise the Query if the global option is enabled
            if (Options.QueryOptimisation)
            {
                // If a locally scoped optimiser is available use that
                if (_optimiser != null)
                {
                    context.Query.Optimise(_optimiser);
                }
                else
                {
                    context.Query.Optimise();
                }
            }

            return context.Query;
        }

        private void TryParseBaseDeclaration(SparqlQueryParserContext context)
        {
            if (context.SubQueryMode) throw new RdfQueryException("BASE Directives are not supported in Sub-queries");

            // Get the next Token which should be a Uri Token
            IToken next = context.Tokens.Dequeue();
            if (next.TokenType == Token.URI)
            {
                context.Query.BaseUri = UriFactory.Create(next.Value);
                context.ExpressionParser.BaseUri = context.Query.BaseUri;
            }
            else
            {
                throw ParserHelper.Error("Expected a URI Token to follow the BASE Verb in a Query", next);
            }
        }

        private void TryParsePrefixDeclaration(SparqlQueryParserContext context)
        {
            if (context.SubQueryMode) throw new RdfQueryException("PREFIX Directives are not supported in Sub-queries");

            // Get the next Two Tokens which should be a Prefix and a Uri
            IToken prefix = context.Tokens.Dequeue();
            IToken uri = context.Tokens.Dequeue();

            if (prefix.TokenType == Token.PREFIX)
            {
                if (uri.TokenType == Token.URI)
                {
                    String baseUri = (context.Query.BaseUri != null) ? context.Query.BaseUri.AbsoluteUri : String.Empty;
                    Uri u = UriFactory.Create(Tools.ResolveUri(uri.Value, baseUri));
                    if (prefix.Value.Length == 1)
                    {
                        // Defining prefix for Default Namespace
                        context.Query.NamespaceMap.AddNamespace("", u);
                    }
                    else
                    {
                        // Defining prefix for some other Namespace
                        context.Query.NamespaceMap.AddNamespace(prefix.Value.Substring(0, prefix.Value.Length - 1), u);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Expected a URI Token to follow a Prefix Token to follow the PREFIX Verb in a Query", uri);
                }
            }
            else
            {
                throw ParserHelper.Error("Expected a Prefix Token to follow the PREFIX Verb in a Query", prefix);
            }
        }

        private void TryParseQueryVerb(SparqlQueryParserContext context, IToken t)
        {
            if (context.VerbSeen)
            {
                throw ParserHelper.Error("Only 1 Query Verb can occur in a Query", t);
            }
            else
            {
                context.VerbSeen = true;

                switch (t.TokenType) {
                    case Token.ASK:
                        if (context.SubQueryMode) throw ParserHelper.Error("ASK is not supported in Sub-queries",t);
                        context.Query.QueryType = SparqlQueryType.Ask;
                        break;
                    case Token.CONSTRUCT:
                        if (context.SubQueryMode) throw ParserHelper.Error("CONSTRUCT is not supported in Sub-queries",t);
                        context.Query.QueryType = SparqlQueryType.Construct;
                        break;
                    case Token.DESCRIBE:
                        if (context.SubQueryMode) throw ParserHelper.Error("DESCRIBE is not supported in Sub-queries", t);
                        context.Query.QueryType = SparqlQueryType.Describe;
                        break;
                    case Token.SELECT:
                        context.Query.QueryType = SparqlQueryType.Select;
                        break;
                }
            }
        }

        private void TryParseSelectVariables(SparqlQueryParserContext context)
        {
            IToken next; 
            bool firstToken = true;
            ISparqlExpression expr;

            // Any Expression we parse from the Select Variables segment may be an aggregate
            context.ExpressionParser.AllowAggregates = true;

            do {
                next = context.Tokens.Peek();

                switch (next.TokenType)
                {
                    case Token.ALL:
                        if (context.Query.Variables.Any())
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Select All and specify Variables in the SELECT Clause", next);
                        }
                        // Change the Query Type to a Select All
                        switch (context.Query.QueryType)
                        {
                            case SparqlQueryType.Select:
                                context.Query.QueryType = SparqlQueryType.SelectAll;
                                break;
                            case SparqlQueryType.SelectDistinct:
                                context.Query.QueryType = SparqlQueryType.SelectAllDistinct;
                                break;
                            case SparqlQueryType.SelectReduced:
                                context.Query.QueryType = SparqlQueryType.SelectAllReduced;
                                break;
                        }
                        break;

                    case Token.VARIABLE:
                        if ((int)context.Query.QueryType >= (int)SparqlQueryType.SelectAll)
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Select All and specify Variables in the SELECT Clause", next);
                        }

                        context.Query.AddVariable(next.Value, true);
                        break;

                    case Token.AVG:
                    case Token.COUNT:
                    case Token.GROUPCONCAT:
                    case Token.MAX:
                    case Token.MEDIAN:
                    case Token.MIN:
                    case Token.MODE:
                    case Token.NMAX:
                    case Token.NMIN:
                    case Token.SAMPLE:
                    case Token.SUM:
                        if ((int)context.Query.QueryType >= (int)SparqlQueryType.SelectAll)
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Select All and specify an Aggregate in the SELECT Clause", next);
                        }

                        context.Tokens.Dequeue();
                        SparqlVariable aggVar = TryParseAggregate(context, next);
                        context.Query.AddVariable(aggVar);
                        firstToken = false;
                        continue;

                    case Token.ABS:
                    case Token.BNODE:
                    case Token.BOUND:
                    case Token.CALL:
                    case Token.CEIL:
                    case Token.COALESCE:
                    case Token.CONCAT:
                    case Token.DATATYPEFUNC:
                    case Token.DAY:
                    case Token.ENCODEFORURI:
                    case Token.EXISTS:
                    case Token.FLOOR:
                    case Token.HOURS:
                    case Token.IF:
                    case Token.IRI:
                    case Token.ISBLANK:
                    case Token.ISIRI:
                    case Token.ISLITERAL:
                    case Token.ISNUMERIC:
                    case Token.ISURI:
                    case Token.LANG:
                    case Token.LANGMATCHES:
                    case Token.LCASE:
                    case Token.MINUTES:
                    case Token.MONTH:
                    case Token.NOTEXISTS:
                    case Token.NOW:
                    case Token.RAND:
                    case Token.REGEX:
                    case Token.REPLACE:
                    case Token.ROUND:
                    case Token.SAMETERM:
                    case Token.SECONDS:
                    case Token.SHA1:
                    case Token.SHA224:
                    case Token.SHA256:
                    case Token.SHA384:
                    case Token.SHA512:
                    case Token.STR:
                    case Token.STRAFTER:
                    case Token.STRBEFORE:
                    case Token.CONTAINS:
                    case Token.STRDT:
                    case Token.STRENDS:
                    case Token.STRLANG:
                    case Token.STRLEN:
                    case Token.STRSTARTS:
                    case Token.STRUUID:
                    case Token.SUBSTR:
                    case Token.TIMEZONE:
                    case Token.TZ:
                    case Token.UCASE:
                    case Token.URIFUNC:
                    case Token.UUID:
                    case Token.YEAR:
                        if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Project Expressions are not supported in SPARQL 1.0");

                        expr = TryParseFunctionExpression(context);

                        // Need to see the Alias
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.AS)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected an AS Keyword after a Projection Expression", next);
                        }
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.VARIABLE)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable as an alias after an AS Keyword", next);
                        }

                        context.Query.AddVariable(new SparqlVariable(next.Value.Substring(1), expr));
                        firstToken = false;
                        continue;

                    case Token.QNAME:
                    case Token.URI:
                        if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Project Expressions are not supported in SPARQL 1.0");

                        // Try and parse a Project Expression which is a naked function call
                        // Resolve the URI
                        Uri u = UriFactory.Create(Tools.ResolveUriOrQName(next, context.Query.NamespaceMap, context.Query.BaseUri));
                        context.Tokens.Dequeue();

                        // Ensure we then see a Open Bracket
                        if (context.Tokens.Peek().TokenType != Token.LEFTBRACKET)
                        {
                            throw ParserHelper.Error("Expected a Left Bracket after a URI/QName in Select Variables for the arguments of a function call", context.Tokens.Peek());
                        }
                        context.Tokens.Dequeue();

                        // Then get the arguments (if any)
                        List<ISparqlExpression> args = new List<ISparqlExpression>();
                        if (context.Tokens.Peek().TokenType == Token.RIGHTBRACKET)
                        {
                            context.Tokens.Dequeue();
                        }
                        else
                        {
                            bool comma = false;
                            do
                            {
                                args.Add(TryParseExpression(context, true));
                                comma = (context.Tokens.LastTokenType == Token.COMMA || context.Tokens.LastTokenType == Token.DISTINCT);

                            } while (comma);
                        }

                        // If there are no arguments (one null argument) then discard
                        if (args.Count == 1 && args.First() == null) args.Clear();

                        // Then try and create an Expression
                        expr = SparqlExpressionFactory.CreateExpression(u, args, _factories);

                        // Need to see the Alias
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.AS)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected an AS Keyword after a Projection Expression", next);
                        }
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.VARIABLE)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable as an alias after an AS Keyword", next);
                        }

                        // Turn into the appropriate type of Variable
                        if (expr is AggregateTerm aggregateTerm)
                        {
                            context.Query.AddVariable(new SparqlVariable(next.Value.Substring(1), aggregateTerm.Aggregate));
                        }
                        else
                        {
                            context.Query.AddVariable(new SparqlVariable(next.Value.Substring(1), expr));
                        }
                        
                        firstToken = false;
                        continue;

                    case Token.LEFTBRACKET:
                        if ((int)context.Query.QueryType >= (int)SparqlQueryType.SelectAll)
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Select All and specify a Projection Expression in the SELECT Clause", next);
                        }

                        if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Project Expressions are not supported in SPARQL 1.0");

                        // Parse the Expression
                        context.Tokens.Dequeue();
                        expr = TryParseExpression(context, false, true);

                        // Require an alias for a Projection Expression
                        bool asTerminated = (context.Tokens.LastTokenType == Token.AS);
                        if (!asTerminated)
                        {
                            // Still need to see an AS
                            next = context.Tokens.Dequeue();
                            if (next.TokenType != Token.AS)
                            {
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected an AS Keyword after a Projection Expression", next);
                            }
                        }
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.VARIABLE)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable as an alias after an AS Keyword", next);
                        }

                        // Turn into the appropriate type of Variable
                        if (expr is AggregateTerm aggregateTerm)
                        {
                            context.Query.AddVariable(new SparqlVariable(next.Value.Substring(1), aggregateTerm.Aggregate));
                        }
                        else
                        {
                            context.Query.AddVariable(new SparqlVariable(next.Value.Substring(1), expr));
                        }

                        firstToken = false;
                        if (asTerminated)
                        {
                            // Still need a Right Bracket to terminate the expression since the alias was within the outer brackets
                            next = context.Tokens.Dequeue();
                            if (next.TokenType != Token.RIGHTBRACKET)
                            {
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Right Bracket to terminate the Projection Expression after the alias", next);
                            }
                        }
                        continue;

                    case Token.DISTINCT:
                        if (firstToken)
                        {
                            context.Query.QueryType = SparqlQueryType.SelectDistinct;
                        }
                        else
                        {
                            throw ParserHelper.Error("The DISTINCT Keyword must occur immediately after the SELECT Verb in a Query", next);
                        }
                        break;

                    case Token.REDUCED:
                        if (firstToken)
                        {
                            context.Query.QueryType = SparqlQueryType.SelectReduced;
                        }
                        else
                        {
                            throw ParserHelper.Error("The REDUCED Keyword must occur immediately after the SELECT Verb in a Query", next);
                        }
                        break;

                    case Token.COMMENT:
                        // Discard Comments
                        context.Tokens.Dequeue();
                        continue;

                    default:
                        if (firstToken)
                        {
                            throw ParserHelper.Error("The SELECT Keyword must be followed by a list of one/more variables or a * to specify all variables", next);
                        }
                        context.ExpressionParser.AllowAggregates = false;
                        return;
                }

                context.Tokens.Dequeue();
                firstToken = false;
            } while (true);
        }

        private SparqlVariable TryParseAggregate(SparqlQueryParserContext context, IToken agg)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw ParserHelper.Error("Aggregates are not supported in SPARQL 1.0", agg);

            IToken next;
            SparqlVariable var;
            ISparqlAggregate aggregate;

            // Check that the Token is an Aggregate Keyword Token
            switch (agg.TokenType)
            {
                case Token.AVG:
                case Token.COUNT:
                case Token.GROUPCONCAT:
                case Token.MAX:
                case Token.MEDIAN:
                case Token.MIN:
                case Token.MODE:
                case Token.NMAX:
                case Token.NMIN:
                case Token.SAMPLE:
                case Token.SUM:
                    // OK
                    break;

                default:
                    throw ParserHelper.Error("Cannot parse an Aggregate since '" + agg.GetType().ToString() + "' is not an Aggregate Keyword Token", agg);
            }

            // Gather up the Tokens and call into the Expression Parser to get this parsed
            Queue<IToken> tokens = new Queue<IToken>();
            tokens.Enqueue(agg);
            int openBrackets = 0;
            do
            {
                next = context.Tokens.Dequeue();
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }

                tokens.Enqueue(next);
            } while (openBrackets > 0);

            context.ExpressionParser.AllowAggregates = true;
            ISparqlExpression aggExpr = context.ExpressionParser.Parse(tokens);
            context.ExpressionParser.AllowAggregates = false;

            if (aggExpr is AggregateTerm aggregateTerm)
            {
                aggregate = aggregateTerm.Aggregate;
            }
            else
            {
                throw new RdfParseException("Unexpected expression was parsed when an Aggregate was expected: " + aggExpr.ToString());
            }

            // See if there is an alias
            String alias = "Result";
            next = context.Tokens.Peek();
            if (next.TokenType == Token.AS)
            {
                context.Tokens.Dequeue();
                next = context.Tokens.Dequeue();
                if (next.TokenType != Token.VARIABLE)
                {
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "', expected a Variable Token after an AS Keyword to act as an aliased name for the Aggregate", next);
                }
                alias = next.Value.Substring(1);
            }
            else
            {
                if (context.SyntaxMode != SparqlQuerySyntax.Extended) throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected an AS keyword after an Aggregate", next);

                int nextID = context.NextAliasID;
                if (nextID > 0) alias += nextID.ToString();
                while (context.Query.Variables.Any(v => v.Name.Equals(alias)))
                {
                    alias = "Result" + context.NextAliasID;
                }
                RaiseWarning("No AS ?variable given for the Aggregate " + aggregate.ToString() + " so assigning alias '" + alias + "'");
            }


            var = new SparqlVariable(alias, aggregate);

            return var;
        }

        private void TryParseDescribeVariables(SparqlQueryParserContext context)
        {
            if (context.SubQueryMode) throw new RdfQueryException("DESCRIBE not permitted as a sub-query");

            IToken next;
            bool firstToken = true;

            do {
                next = context.Tokens.Peek();

                switch (next.TokenType)
                {
                    case Token.ALL:
                        if (context.Query.DescribeVariables.Any())
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Describe All and specify Variables/URIs/QNames in the DESCRIBE Clause", next);
                        }
                        // Change the Query Type to a Describe All
                        context.Query.QueryType = SparqlQueryType.DescribeAll;
                        break;

                    case Token.VARIABLE:
                        if (context.Query.QueryType == SparqlQueryType.DescribeAll)
                        {
                            throw ParserHelper.Error("Can't use the * symbol to specify Describe All and specify Variables/URIs/QNames in the DESCRIBE Clause", next);
                        }
                        context.Query.AddVariable(next.Value, true);
                        context.Query.AddDescribeVariable(next);
                        break;

                    case Token.QNAME:
                    case Token.URI:
                        context.Query.AddDescribeVariable(next);
                        break;

                    case Token.COMMENT:
                        // Discard Comments
                        context.Tokens.Dequeue();
                        continue;

                    default:
                        if (firstToken)
                        {
                            throw ParserHelper.Error("The DESCRIBE keyword must be followed by a list of one/more variables/IRI References or a * to specify all variables", next);
                        }
                        return;
                }

                context.Tokens.Dequeue();
                firstToken = false;
            } while (true);
        }

        private void TryParseConstructTemplate(SparqlQueryParserContext context)
        {
            if (context.SubQueryMode) throw new RdfQueryException("CONSTRUCT not permitted as a sub-query");

            bool shortForm = (context.Tokens.Peek().TokenType == Token.WHERE || context.Tokens.Peek().TokenType == Token.FROM);
            if (shortForm && context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0)
            {
                throw ParserHelper.Error("Short Form CONSTRUCT queries are not permitted in SPARQL 1.0", context.Tokens.Peek());
            }
            else if (shortForm)
            {
                IToken temp = context.Tokens.Peek();
                if (context.Tokens.Peek().TokenType == Token.FROM)
                {
                    while (temp.TokenType == Token.FROM)
                    {
                        TryParseFrom(context);
                        temp = context.Tokens.Peek();
                    }
                }
                if (temp.TokenType == Token.WHERE)
                {
                    // For Short Form CONSTRUCT discard the WHERE
                    context.Tokens.Dequeue();
                }
                else
                {
                    throw ParserHelper.Error("Unexpected Token '" + temp.GetType().Name + " encountered, expected the WHERE of a Short Form Construct to come after the FROM/FROM NAMED clauses of a Short Form Construct", temp);
                }
            }

            // Discard the opening {
            IToken next = context.Tokens.Dequeue();
            if (next.TokenType != Token.LEFTCURLYBRACKET)
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Curly Bracket to start a CONSTRUCT Template", next);
            }

            // Use a Graph Pattern for the Construct Template
            GraphPattern constructTemplate = TryParseGraphPattern(context, false);

            // Check it doesn't contain anything other than Triple Patterns
            if (constructTemplate.IsFiltered)
            {
                throw new RdfParseException("A FILTER Clause cannot occur in a CONSTRUCT Template");
            }
            else if (constructTemplate.IsGraph)
            {
                throw new RdfParseException("A GRAPH Clause cannot occur in a CONSTRUCT Template");
            }
            else if (constructTemplate.IsOptional || constructTemplate.IsMinus || constructTemplate.IsExists || constructTemplate.IsNotExists  || constructTemplate.IsService || constructTemplate.IsSubQuery)
            {
                throw new RdfParseException("Graph Clauses (e.g. OPTIONAL, MINUS etc.) cannot occur in a CONSTRUCT Template");
            }
            else if (constructTemplate.IsUnion)
            {
                throw new RdfParseException("A UNION Clause cannot occur in a CONSTRUCT Template");
            }
            else if (constructTemplate.HasChildGraphPatterns)
            {
                throw new RdfParseException("Nested Graph Patterns cannot occur in a CONSTRUCT Template");
            }
            else if (!constructTemplate.TriplePatterns.All(p => p is IConstructTriplePattern))
            {
                throw new RdfParseException("A Construct Template may only be composed of Triple Patterns - Assignments, Property Paths, Sub-queries etc. are not permitted");
            }
            else if (constructTemplate.UnplacedAssignments.Any())
            {
                throw new RdfParseException("A Construct Template may not contain any Assignments");
            }
            else
            {
                // OK
                context.Query.ConstructTemplate = constructTemplate;
                if (shortForm) context.Query.RootGraphPattern = constructTemplate;
            }
        }

        private void TryParseFrom(SparqlQueryParserContext context)
        {
            if (context.SubQueryMode) throw new RdfQueryException("Dataset Descriptions are not permitted in Sub-queries");

            IToken next = context.Tokens.Dequeue();

            // Should be a FROM
            if (next.TokenType == Token.FROM)
            {
                // Default Graph/Named Graph Specified

                next = context.Tokens.Peek();
                if (next.TokenType == Token.URI)
                {
                    // Default Graph Specified
                    String baseUri = (context.Query.BaseUri == null) ? String.Empty : context.Query.BaseUri.AbsoluteUri;
                    context.Query.AddDefaultGraph(UriFactory.Create(Tools.ResolveUri(next.Value, baseUri)));
                    context.Tokens.Dequeue();
                }
                else if (next.TokenType == Token.QNAME)
                {
                    // Default Graph Specified
                    context.Query.AddDefaultGraph(ResolveQName(context, next.Value));
                    context.Tokens.Dequeue();
                }
                else if (next.TokenType == Token.NAMED)
                {
                    // Named Graph Specified
                    context.Tokens.Dequeue();
                    next = context.Tokens.Peek();
                    if (next.TokenType == Token.URI) 
                    {
                        String baseUri = (context.Query.BaseUri == null) ? String.Empty : context.Query.BaseUri.AbsoluteUri;
                        context.Query.AddNamedGraph(UriFactory.Create(Tools.ResolveUri(next.Value, baseUri)));
                        context.Tokens.Dequeue();
                    }
                    else if (next.TokenType == Token.QNAME)
                    {
                        context.Query.AddNamedGraph(ResolveQName(context, next.Value));
                        context.Tokens.Dequeue();
                    }
                    else
                    {
                        throw ParserHelper.Error("Expected a QName/URI Token to occur after a FROM NAMED Keyword to specify a Named Graph URI", next);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Expected a QName/URI Token to occur after a FROM Keyword to specify a Default Graph URI", next);
                }
            }
        }

        private void TryParseGraphPatterns(SparqlQueryParserContext context)
        {
            // Parse a Graph Pattern Object
            context.Query.RootGraphPattern = TryParseGraphPattern(context);
        }

        /// <summary>
        /// Tries to parse a Graph Pattern from the given Parser Context.
        /// </summary>
        /// <param name="context">Parser Context.</param>
        /// <param name="requireOpeningLeftBracket">Whether the opening Left Curly Bracket is required.</param>
        /// <returns></returns>
        protected internal GraphPattern TryParseGraphPattern(SparqlQueryParserContext context, bool requireOpeningLeftBracket)
        {
            context.GraphPatternID++;
            IToken next;

            if (requireOpeningLeftBracket)
            {
                // Discard the opening {
                next = context.Tokens.Dequeue();
                if (next.TokenType != Token.LEFTCURLYBRACKET)
                {
                    throw ParserHelper.Error("Unexpected Token encountered, expected the start of a Graph Pattern", next);
                }
            }

            next = context.Tokens.Peek();

            if (next.TokenType == Token.RIGHTCURLYBRACKET)
            {
                // Empty Graph Pattern - Selects nothing
                context.Tokens.Dequeue();
                GraphPattern pattern = new GraphPattern();
                return pattern;
            }
            else if (next.TokenType == Token.LEFTCURLYBRACKET)
            {
                // Nested Graph Pattern
                GraphPattern pattern = new GraphPattern();
                GraphPattern child;// = new GraphPattern();

                child = TryParseGraphPattern(context, true);
                // this.TryParseTriplePatterns(context, child);
                pattern.AddGraphPattern(child);
                child = new GraphPattern();
                IToken lastToken = null;

                // Keep Parsing Graph Patterns until we hit a Right Curly Bracket
                do
                {
                    next = context.Tokens.Peek();
                    if (next.TokenType == Token.RIGHTCURLYBRACKET)
                    {
                        // This isn't in the switch as we want to break out of the loop when we get here
                        context.Tokens.Dequeue();
                        break;
                    }
                    else
                    {
                        switch (next.TokenType)
                        {
                            case Token.UNION:
                                // UNION Clause
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseUnionClause(context, pattern);
                                break;

                            case Token.FILTER:
                                // FILTER Clause
                                lastToken = context.Tokens.Dequeue();
                                TryParseFilterClause(context, pattern);
                                break;

                            case Token.BIND:
                                // BIND Clause
                                lastToken = context.Tokens.Dequeue();
                                TryParseBindAssignment(context, pattern);
                                break;

                            case Token.OPTIONAL:
                                // OPTIONAL Clause
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseOptionalClause(context, pattern);
                                break;

                            case Token.GRAPH:
                                // GRAPH Clause
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseGraphClause(context, pattern);
                                break;

                            case Token.EXISTS:
                            case Token.NOTEXISTS:
                            case Token.UNSAID:
                                // EXISTS/NOT EXISTS/UNSAID Clause
                                if (next.TokenType == Token.UNSAID && context.SyntaxMode != SparqlQuerySyntax.Extended) throw new RdfParseException("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended");
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseExistsClause(context, pattern, (next.TokenType == Token.EXISTS));
                                break;

                            case Token.MINUS_P:
                                // MINUS Clause
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseMinusClause(context, pattern);
                                break;

                            case Token.SERVICE:
                                // SERVICE clause
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                TryParseServiceClause(context, pattern);
                                break;

                            case Token.VALUES:
                                // VALUES clause
                                if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw ParserHelper.Error("Inline Data blocks (VALUES clauses) are not permitted in SPARQL 1.0", next);
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                lastToken = context.Tokens.Dequeue();
                                pattern.AddInlineData(TryParseInlineData(context));
                                break;

                            case Token.DOT:
                                // Allowed after non-triple patterns
                                if (lastToken == null)
                                {
                                    throw ParserHelper.Error("Unexpected DOT in graph pattern.", next);
                                }
                                context.Tokens.Dequeue();
                                lastToken = null;
                                break;

                            case Token.VARIABLE:
                            case Token.URI:
                            case Token.QNAME:
                            case Token.LITERAL:
                            case Token.LONGLITERAL:
                            case Token.PLAINLITERAL:
                            case Token.BLANKNODE:
                            case Token.BLANKNODEWITHID:
                            case Token.LET:
                            case Token.LEFTSQBRACKET:
                            case Token.LEFTBRACKET:
                                // Start of some Triple Patterns
                                context.GraphPatternID++;
                                TryParseTriplePatterns(context, child);
                                lastToken = null;
                                break;

                            default:
                                // Otherwise we'll expect a new Graph Pattern
                                if (!child.IsEmpty)
                                {
                                    pattern.AddGraphPattern(child);
                                    child = new GraphPattern();
                                }
                                pattern.AddGraphPattern(TryParseGraphPattern(context, true));
                                break;
                        }
                    }
                } while (true);

                if (!child.IsEmpty)
                {
                    pattern.AddGraphPattern(child);
                }
                return pattern;
            }
            else
            {
                // Non-Empty Graph Pattern
                GraphPattern pattern = new GraphPattern();
                TryParseTriplePatterns(context, pattern);

                // Keep parsing Triple Patterns until we hit a Right Curly Bracket
                do
                {
                    next = context.Tokens.Peek();
                    if (next.TokenType == Token.RIGHTCURLYBRACKET)
                    {
                        break;
                    }
                    else
                    {
                        TryParseTriplePatterns(context, pattern);
                    }
                } while (true);

                // Discard the Right Curly Bracket
                context.Tokens.Dequeue();
                return pattern;
            }
        }

        private GraphPattern TryParseGraphPattern(SparqlQueryParserContext context)
        {
            return TryParseGraphPattern(context, true);
        }

        private void TryParseTriplePatterns(SparqlQueryParserContext context, GraphPattern p)
        {
            int lasttoken = context.Tokens.LastTokenType;
            IToken next = context.Tokens.Dequeue();

            // Allowed a Variable/RDF Term/Collection
            // OR we might go straight to a OPTIONAL/GRAPH/UNION/FILTER/EXISTS/NOT EXISTS/LET

            switch (next.TokenType)
            {
                case Token.COMMENT:
                    // Comments are discardable
                    TryParseTriplePatterns(context, p);
                    break;

                case Token.VARIABLE:
                    // Variable
                    context.LocalTokens.Push(next);
                    context.Query.AddVariable(next.Value);
                    TryParsePredicateObjectList(context, p,2);
                    break;

                case Token.URI:
                case Token.QNAME:
                case Token.LITERAL:
                case Token.LONGLITERAL:
                case Token.PLAINLITERAL:
                    // Must then be followed be a non-empty Property List
                    context.LocalTokens.Push(next);
                    TryParsePredicateObjectList(context, p,2);
                    break;

                case Token.BLANKNODE:
                case Token.BLANKNODEWITHID:
                    // Check list of Blank Node usages
                    if (context.BlankNodeIDUsages.ContainsKey(next.Value))
                    {
                        if (context.CheckBlankNodeScope && context.BlankNodeIDUsages[next.Value] != context.GraphPatternID)
                        {
                            throw ParserHelper.Error("Invalid use of Blank Node Label '" + next.Value + "', this Label has already been used in a different Graph Pattern", next);
                        }
                    }
                    else
                    {
                        context.BlankNodeIDUsages.Add(next.Value, context.GraphPatternID);
                    }

                    // Must then be followed be a non-empty Property List
                    context.LocalTokens.Push(next);
                    TryParsePredicateObjectList(context, p, 2);
                    break;

                case Token.LET:
                    // LET assignment
                    TryParseLetAssignment(context, p);
                    break;

                case Token.BIND:
                    // BIND assignment
                    TryParseBindAssignment(context, p);
                    break;

                case Token.LEFTSQBRACKET:
                    // Start of Blank Node Collection
                    // Create a new Blank Node Token
                    BlankNodeWithIDToken bnode = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), 0, 0, 0);

                    // Push twice, once for Subject of Collection
                    context.LocalTokens.Push(bnode);

                    next = context.Tokens.Peek();
                    if (next.TokenType == Token.RIGHTSQBRACKET)
                    {
                        // Single anonymous blank node
                        context.Tokens.Dequeue();

                        // Parse as Subject of Triples
                        TryParsePredicateObjectList(context, p, 2);
                    }
                    else
                    {

                        // Parse the Collection
                        TryParsePredicateObjectList(context, p, 2);

                        // Push again for subject of Triples
                        context.LocalTokens.Push(bnode);
                        TryParsePredicateObjectList(context, p, 2);
                    }
                    break;

                case Token.LEFTBRACKET:
                    // Collection
                    TryParseCollection(context, p, false);
                    TryParsePredicateObjectList(context, p, 2);
                    break;

                case Token.FILTER:
                    // FILTER Pattern
                    TryParseFilterClause(context, p);
                    break;

                case Token.OPTIONAL:
                    // OPTIONAL Clause
                    TryParseOptionalClause(context, p);
                    break;

                case Token.EXISTS:
                case Token.NOTEXISTS:
                case Token.UNSAID:
                    // EXISTS/NOT EXISTS clause
                    if (next.TokenType == Token.UNSAID && context.SyntaxMode != SparqlQuerySyntax.Extended) throw new RdfParseException("The UNSAID Keyword is only supported when syntax is set to Extended.  It is an alias for NOT EXISTS which can be used when the syntax is set to SPARQL 1.1/Extended");
                    TryParseExistsClause(context, p, (next.TokenType == Token.EXISTS));
                    break;

                case Token.MINUS_P:
                    // MINUS clause
                    TryParseMinusClause(context, p);
                    break;

                case Token.SERVICE:
                    // SERVICE clause
                    TryParseServiceClause(context, p);
                    break;

                case Token.SELECT:
                    // Sub-query
                    TryParseSubquery(context, p);
                    break;

                case Token.GRAPH:
                    // GRAPH Clause
                    TryParseGraphClause(context, p);
                    break;

                case Token.UNION:
                    // UNION Clause
                    TryParseUnionClause(context, p);
                    break;

                case Token.VALUES:
                    // VALUES Clause
                    if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw ParserHelper.Error("Inline Data blocks (VALUES clauses) are not permitted in SPARQL 1.0", next);
                    p.AddInlineData(TryParseInlineData(context));
                    break;

                case Token.LEFTCURLYBRACKET:
                    // Nested Graph Pattern
                    p.AddGraphPattern(TryParseGraphPattern(context, false));

                    // Simplify Subqueries
                    if (p.ChildGraphPatterns.Last().IsSubQuery)
                    {
                        GraphPattern temp = p.LastChildPattern();
                        p.AddTriplePattern(temp.TriplePatterns.First());
                    }
                    break;

                case Token.DOT:
                    // Can Discard this if last character was the end of a nested Graph pattern
                    if (lasttoken == Token.RIGHTCURLYBRACKET || lasttoken == Token.RIGHTBRACKET)
                    {
                        // Can Discard this if the next character is not another DOT
                        next = context.Tokens.Peek();
                        if (next.TokenType != Token.DOT)
                        {
                            if (next.TokenType != Token.RIGHTCURLYBRACKET)
                            {
                                TryParseTriplePatterns(context, p);
                            }
                            else
                            {
                                return;
                            }
                        }
                        else
                        {
                            throw ParserHelper.Error("A DOT Token cannot follow another DOT Token within a Graph Pattern", next);
                        }
                    }
                    else if (lasttoken == Token.SEMICOLON)
                    {
                        // Allow Trailing Semicolon
                        return;
                    }
                    else
                    {
                        throw ParserHelper.Error("A DOT Token can only be used to terminate a Triple Pattern or a Nested Graph Pattern", next);
                    }
                    break;

                default:
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered when the start of a Triple Pattern was expected", next);
            }
        }

        private void TryParsePredicateObjectList(SparqlQueryParserContext context, GraphPattern p, int expectedCount)
        {
            PatternItem subj, pred, obj;
            
            // Subject is first thing on the Stack
            subj = TryCreatePatternItem(context, context.LocalTokens.Pop());

            // Start grabbing other stuff off the Stack and Parsing
            IToken next, lit, temp;
            ISparqlPath path;

            do
            {
                // Peek at the Next Token
                next = context.Tokens.Peek();
                switch (next.TokenType)
                {
                    case Token.COMMENT:
                        // Ignore Comments
                        context.Tokens.Dequeue();
                        break;

                    case Token.VARIABLE:
                        context.LocalTokens.Push(next);
                        context.Query.AddVariable(next.Value);
                        context.Tokens.Dequeue();
                        break;

                    case Token.URI:
                    case Token.QNAME:
                    case Token.LITERAL:
                    case Token.LONGLITERAL:
                    case Token.PLAINLITERAL:
                    case Token.KEYWORDA:
                        context.LocalTokens.Push(next);
                        context.Tokens.Dequeue();
                        break;

                    case Token.HAT:
                    case Token.DIVIDE:
                    case Token.BITWISEOR:
                    case Token.MULTIPLY:
                    case Token.PLUS:
                    case Token.QUESTION:
                    case Token.NEGATION:
                        // If we see any of these Tokens then it's a Property Path
                        if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Property Paths are not permitted in SPARQL 1.0");

                        if (context.LocalTokens.Count == expectedCount - 1)
                        {
                            path = context.PathParser.Parse(context, context.LocalTokens.Pop());
                            PathToken pathToken = new PathToken(path);
                            context.LocalTokens.Push(pathToken);
                        }
                        else if ((next.TokenType == Token.HAT || next.TokenType == Token.NEGATION) && context.LocalTokens.Count == expectedCount - 2)
                        {
                            // ^ and ! may be used to start a pattern
                            context.Tokens.Dequeue();
                            path = context.PathParser.Parse(context, next);
                            PathToken pathToken = new PathToken(path);
                            context.LocalTokens.Push(pathToken);
                        }
                        else
                        {
                            throw ParserHelper.Error("Encountered a '" + next.GetType().ToString() + "' Token which is valid only after a Predicate to indicate Path Cardinality", next);
                        }
                        break;

                    case Token.BLANKNODE:
                    case Token.BLANKNODEWITHID:
                        // Generate a new Blank Node ID if required
                        if (next.TokenType == Token.BLANKNODE)
                        {
                            next = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), 0, 0, 0);
                        }

                        // Check list of Blank Node usages
                        if (context.BlankNodeIDUsages.ContainsKey(next.Value))
                        {
                            if (context.CheckBlankNodeScope && context.BlankNodeIDUsages[next.Value] != context.GraphPatternID)
                            {
                                throw ParserHelper.Error("Invalid use of Blank Node Label '" + next.Value + "', this Label has already been used in a different Graph Pattern", next);
                            }
                        }
                        else
                        {
                            context.BlankNodeIDUsages.Add(next.Value, context.GraphPatternID);
                        }

                        context.LocalTokens.Push(next);
                        context.Tokens.Dequeue();
                        break;

                    case Token.HATHAT:
                        // Get the next Token which should be a Datatype Token
                        context.Tokens.Dequeue();
                        next = context.Tokens.Peek();
                        if (next.TokenType == Token.DATATYPE)
                        {
                            // Get the previous Token off the Stack and ensure it's a Literal
                            lit = context.LocalTokens.Pop();
                            if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL)
                            {
                                // Create a DataTyped Literal
                                context.LocalTokens.Push(new LiteralWithDataTypeToken(lit, (DataTypeToken)next));
                            }
                            else
                            {
                                throw ParserHelper.Error("Unexpected Datatype Token, a Datatype may only be specified after a quoted Literal/Long Literal", lit);
                            }
                        }
                        else
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Datatype Token to follow a ^^ Token to specify the Datatype of a previous Literal Token", next);
                        }
                        context.Tokens.Dequeue();
                        break;

                    case Token.LEFTSQBRACKET:
                        // Start of Blank Node Collection
                        // Create a new Blank Node Token
                        BlankNodeWithIDToken bnode = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), 0, 0, 0);

                        // Push twice, once for Object of the current Triple
                        context.LocalTokens.Push(bnode);

                        context.Tokens.Dequeue();
                        next = context.Tokens.Peek();
                        if (next.TokenType == Token.RIGHTSQBRACKET)
                        {
                            // Single anonymous blank node
                            context.Tokens.Dequeue();
                            break;
                        }

                        // Blank Node Collection
                        // Push again for Subject of new Triple
                        context.LocalTokens.Push(bnode);

                        // Recursively call self to parse the new Triple list
                        TryParsePredicateObjectList(context, p, expectedCount + 2);
                        break;

                    case Token.RIGHTSQBRACKET:
                        // End of Blank Node Collection

                        // Allow for trailing semicolon
                        if (context.LocalTokens.Count == expectedCount - 2 && context.Tokens.LastTokenType == Token.SEMICOLON)
                        {
                            context.Tokens.Dequeue();
                            return;
                        }

                        // Check length of Stack
                        if (context.LocalTokens.Count < expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern", next);
                        }
                        else if (context.LocalTokens.Count > expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Right Square Bracket Token to terminate a Blank Node Collection within a Triple Pattern but there are too many Tokens to form a valid Triple Pattern - " + ExcessTokensString(context, expectedCount), next);
                        }
                        obj = TryCreatePatternItem(context, context.LocalTokens.Pop());

                        if (context.LocalTokens.Peek() is PathToken)
                        {
                            PathToken pathToken = context.LocalTokens.Pop() as PathToken;
                            p.AddTriplePattern(new PropertyPathPattern(subj, pathToken.Path, obj));
                        }
                        else
                        {
                            pred = TryCreatePatternItem(context, context.LocalTokens.Pop());
                            p.AddTriplePattern(new TriplePattern(subj, pred, obj));
                        }
                        context.Tokens.Dequeue();
                        return;

                    case Token.LEFTBRACKET:
                        // Property Path if it's the Predicate or Collection if it's the Object
                        if (context.LocalTokens.Count == expectedCount - 2)
                        {
                            // Property Path
                            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Property Paths are not permitted in SPARQL 1.0");
 
                            path = context.PathParser.Parse(context, context.Tokens.Dequeue());
                            PathToken pathToken = new PathToken(path);
                            context.LocalTokens.Push(pathToken);
                        }
                        else
                        {
                            // Collection
                            context.Tokens.Dequeue();
                            TryParseCollection(context, p, false);
                        }
                        break;

                    case Token.LANGSPEC:
                        // Get the previous Token off the Stack and ensure it's a Literal
                        lit = context.LocalTokens.Pop();
                        if (lit.TokenType == Token.LITERAL || lit.TokenType == Token.LONGLITERAL)
                        {
                            // Create a Language Specified Literal
                            context.LocalTokens.Push(new LiteralWithLanguageSpecifierToken(lit, (LanguageSpecifierToken)next));
                        }
                        else
                        {
                            throw ParserHelper.Error("Unexpected Language Specifier Token, a Language Specifier may only be specified after a quoted Literal/Long Literal", lit);
                        }
                        context.Tokens.Dequeue();
                        break;

                    case Token.COMMA:
                        // End of a Triple Pattern

                        // Check length of stack
                        if (context.LocalTokens.Count < expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Comma Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern", next);
                        }
                        else if (context.LocalTokens.Count > expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Comma Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern - " + ExcessTokensString(context, expectedCount), next);
                        }
                        obj = TryCreatePatternItem(context, context.LocalTokens.Pop());
                        temp = context.LocalTokens.Pop();
                        if (temp.TokenType == Token.PATH)
                        {
                            path = ((PathToken)temp).Path;
                            p.AddTriplePattern(new PropertyPathPattern(subj, path, obj));
                        }
                        else
                        {
                            pred = TryCreatePatternItem(context, temp);

                            // Add Pattern to the Graph Pattern
                            p.AddTriplePattern(new TriplePattern(subj, pred, obj));
                        }

                        // Push Predicate back on Stack
                        context.LocalTokens.Push(temp);

                        context.Tokens.Dequeue();
                        break;

                    case Token.SEMICOLON:
                        // End of a Triple Pattern

                        // Check length of stack
                        if (context.LocalTokens.Count < expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Semicolon Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern", next);
                        }
                        else if (context.LocalTokens.Count > expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Semicolon Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern - " + ExcessTokensString(context, expectedCount), next);
                        }
                        obj = TryCreatePatternItem(context, context.LocalTokens.Pop());
                        temp = context.LocalTokens.Pop();
                        if (temp.TokenType == Token.PATH)
                        {
                            path = ((PathToken)temp).Path;
                            p.AddTriplePattern(new PropertyPathPattern(subj, path, obj));
                        }
                        else
                        {
                            pred = TryCreatePatternItem(context, temp);

                            // Add Pattern to the Graph Pattern
                            p.AddTriplePattern(new TriplePattern(subj, pred, obj));
                        }

                        context.Tokens.Dequeue();
                        break;

                    case Token.DOT:
                        // End of the Triple Patterns

                        // Allow for trailing semicolon and Blank Node Collection lists
                        if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET && p.TriplePatterns.Count > 0)))
                        {
                            if (context.Tokens.LastTokenType == Token.RIGHTSQBRACKET)
                            {
                                context.Tokens.Dequeue();
                            }
                            return;
                        }

                        // Check length of Stack
                        if (context.LocalTokens.Count < expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a DOT Token to terminate a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern", next);
                        }
                        else if (context.LocalTokens.Count > expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a DOT Token to terminate a Triple Pattern but there are too many Tokens to form a valid Triple Pattern - " + ExcessTokensString(context, expectedCount), next);
                        }
                        obj = TryCreatePatternItem(context, context.LocalTokens.Pop());
                        temp = context.LocalTokens.Pop();
                        if (temp.TokenType == Token.PATH)
                        {
                            path = ((PathToken)temp).Path;
                            p.AddTriplePattern(new PropertyPathPattern(subj, path, obj));
                        }
                        else
                        {
                            pred = TryCreatePatternItem(context, temp);

                            // Add Pattern to the Graph Pattern
                            p.AddTriplePattern(new TriplePattern(subj, pred, obj));
                        }
                        context.Tokens.Dequeue();
                        return;

                    case Token.LEFTCURLYBRACKET:
                    case Token.RIGHTCURLYBRACKET:
                    case Token.OPTIONAL:
                    case Token.EXISTS:
                    case Token.NOTEXISTS:
                    case Token.UNSAID:
                    case Token.MINUS_P:
                    case Token.SERVICE:
                    case Token.GRAPH:
                    case Token.FILTER:
                    case Token.VALUES:
                        // End of the Triple Patterns

                        // Allow for trailing semicolon and Blank Node Collection lists
                        if (context.LocalTokens.Count == expectedCount - 2 && (context.Tokens.LastTokenType == Token.SEMICOLON || ((context.Tokens.LastTokenType == Token.RIGHTSQBRACKET || context.Tokens.LastTokenType == Token.RIGHTBRACKET) && p.TriplePatterns.Count > 0)))
                        {
                            return;
                        }

                        // Check length of Stack
                        if (context.LocalTokens.Count < expectedCount)
                        {
                            temp = context.LocalTokens.Peek();
                            if (next.TokenType == Token.LEFTCURLYBRACKET && context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0 && context.LocalTokens.Count == expectedCount - 1 && (temp.TokenType == Token.QNAME || temp.TokenType == Token.URI || temp.TokenType == Token.KEYWORDA))
                            {
                                // In this case this should be a Cardinality Modifier on a path (we hope)
                                path = context.PathParser.Parse(context, context.LocalTokens.Pop());
                                IToken pathToken = new PathToken(path);
                                context.LocalTokens.Push(pathToken);
                                continue;
                            }
                            else
                            {
                                throw ParserHelper.Error("Encountered a Token which terminates a Triple Pattern but there are not enough Tokens to form a valid Triple Pattern", next);
                            }
                        }
                        else if (context.LocalTokens.Count > expectedCount)
                        {
                            throw ParserHelper.Error("Encountered a Token which terminates a Triple Pattern but there are too many Tokens to form a valid Triple Pattern - " + ExcessTokensString(context, expectedCount), next);
                        }
                        obj = TryCreatePatternItem(context, context.LocalTokens.Pop());
                        temp = context.LocalTokens.Pop();
                        if (temp.TokenType == Token.PATH)
                        {
                            path = ((PathToken)temp).Path;
                            p.AddTriplePattern(new PropertyPathPattern(subj, path, obj));
                        }
                        else
                        {
                            pred = TryCreatePatternItem(context, temp);

                            // Add Pattern to the Graph Pattern
                            p.AddTriplePattern(new TriplePattern(subj, pred, obj));
                        }
                        return;
                    
                    default:
                        throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' while trying to Parse Triple Patterns", next);
                }
            } while (true);

        }

        private void TryParseCollection(SparqlQueryParserContext context, GraphPattern p, bool nested)
        {

            // Check the next Token
            IToken next = context.Tokens.Peek();
            if (next.TokenType == Token.RIGHTBRACKET)
            {
                // Empty Collection
                context.Tokens.Dequeue();

                if (!nested)
                {
                    // Push an rdf:nil Uri on the Stack
                    context.LocalTokens.Push(new UriToken("<" + NamespaceMapper.RDF + "nil>", next.StartLine, next.StartPosition, next.EndPosition));
                }
            }
            else
            {
                // Push a Blank Node Token onto the stack for the start of the collection
                BlankNodeWithIDToken blank; 
                if (!nested)
                {
                    blank = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);
                    context.LocalTokens.Push(blank);
                } 
                else 
                {
                    blank = new BlankNodeWithIDToken("_:sparql-autos" + context.BlankNodeID, next.StartLine, next.StartPosition, next.EndPosition);
                }

                bool first = true;

                IUriNode rdfFirst, rdfRest, rdfNil;
                rdfFirst = new UriNode(null, UriFactory.Create(NamespaceMapper.RDF + "first"));
                rdfRest = new UriNode(null, UriFactory.Create(NamespaceMapper.RDF + "rest"));
                rdfNil = new UriNode(null, UriFactory.Create(NamespaceMapper.RDF + "nil"));

                do
                {
                    next = context.Tokens.Peek();

                    switch (next.TokenType)
                    {
                        case Token.BLANKNODE:
                        case Token.BLANKNODEWITHID:
                        case Token.KEYWORDA:
                        case Token.LITERAL:
                        case Token.LONGLITERAL:
                        case Token.PLAINLITERAL:
                        case Token.QNAME:
                        case Token.URI:
                        case Token.VARIABLE:
                            // Create the Triple pattern

                            if (first)
                            {
                                // rdf:first Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, next)));
                                first = false;
                            }
                            else
                            {
                                // Get new Blank Node ID
                                BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine,next.StartPosition,next.EndPosition);

                                // rdf:rest Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfRest), TryCreatePatternItem(context, blank2)));

                                blank = blank2;

                                // rdf:first Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, next)));
                            }

                            break;

                        case Token.LEFTSQBRACKET:
                            // Is the next token a Right Square Bracket?
                            // ie. a [] for an anonymous blank node
                            context.Tokens.Dequeue();
                            next = context.Tokens.Peek();

                            if (next.TokenType == Token.RIGHTSQBRACKET)
                            {
                                BlankNodeWithIDToken anon = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                                if (first)
                                {
                                    // rdf:first Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, anon)));
                                    first = false;
                                }
                                else
                                {
                                    // Get new Blank Node ID
                                    BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                                    // rdf:rest Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfRest), TryCreatePatternItem(context, blank2)));

                                    blank = blank2;

                                    // rdf:first Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, anon)));
                                }
                            }
                            else
                            {
                                BlankNodeWithIDToken anon = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                                if (first)
                                {
                                    // rdf:first Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, anon)));
                                    first = false;
                                }
                                else
                                {
                                    // Get new Blank Node ID
                                    BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                                    // rdf:rest Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfRest), TryCreatePatternItem(context, blank2)));

                                    blank = blank2;

                                    // rdf:first Pattern
                                    p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, anon)));
                                }

                                // Parse the Blank Node Collection
                                context.LocalTokens.Push(anon);
                                TryParsePredicateObjectList(context, p, context.LocalTokens.Count + 1);
                                continue;
                            }
                            break;

                        case Token.LEFTBRACKET:

                            BlankNodeWithIDToken innerCollection = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                            if (first)
                            {
                                // rdf:first Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, innerCollection)));
                                first = false;
                            }
                            else
                            {
                                // Get new Blank Node ID
                                BlankNodeWithIDToken blank2 = new BlankNodeWithIDToken(context.GetNewBlankNodeID(), next.StartLine, next.StartPosition, next.EndPosition);

                                // rdf:rest Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfRest), TryCreatePatternItem(context, blank2)));

                                blank = blank2;

                                // rdf:first Pattern
                                p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfFirst), TryCreatePatternItem(context, innerCollection)));
                            }

                            context.Tokens.Dequeue();
                            TryParseCollection(context, p, true);
                            continue;

                        case Token.RIGHTBRACKET:
                            // End of Collection

                            // rdf:rest Pattern
                            p.AddTriplePattern(new TriplePattern(TryCreatePatternItem(context, blank), new NodeMatchPattern(rdfRest), new NodeMatchPattern(rdfNil)));
                            break;

                        default:
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Collection", next);
                    }

                    context.Tokens.Dequeue();
                } while (next.TokenType != Token.RIGHTBRACKET);
            }
        }

        private void TryParseFilterClause(SparqlQueryParserContext context, GraphPattern p)
        {
            // TODO: Refactor entire function to just rely on SparqlExpressionParser instead

            IToken next = context.Tokens.Dequeue();
            switch (next.TokenType)
            {
                case Token.LEFTBRACKET:
                    TryParseFilterExpression(context, p);
                    break;

                case Token.ABS:
                case Token.BNODE:
                case Token.BOUND:
                case Token.CALL:
                case Token.CEIL:
                case Token.COALESCE:
                case Token.CONCAT:
                case Token.DATATYPEFUNC:
                case Token.DAY:
                case Token.ENCODEFORURI:
                case Token.FLOOR:
                case Token.HOURS:
                case Token.IF:
                case Token.IRI:
                case Token.ISBLANK:
                case Token.ISIRI:
                case Token.ISLITERAL:
                case Token.ISNUMERIC:
                case Token.ISURI:
                case Token.LANG:
                case Token.LANGMATCHES:
                case Token.LCASE:
                case Token.MINUTES:
                case Token.MONTH:
                case Token.NOW:
                case Token.RAND:
                case Token.REPLACE:
                case Token.ROUND:
                case Token.SAMETERM:
                case Token.SECONDS:
                case Token.SHA1:
                case Token.SHA224:
                case Token.SHA256:
                case Token.SHA384:
                case Token.SHA512:
                case Token.STR:
                case Token.STRAFTER:
                case Token.STRBEFORE:
                case Token.CONTAINS:
                case Token.STRDT:
                case Token.STRENDS:
                case Token.STRLANG:
                case Token.STRLEN:
                case Token.STRSTARTS:
                case Token.STRUUID:
                case Token.SUBSTR:
                case Token.TIMEZONE:
                case Token.TZ:
                case Token.UCASE:
                case Token.URIFUNC:
                case Token.UUID:
                case Token.YEAR:
                    // Built-in functions
                    TryParseFilterBuiltInCall(context, next, p);
                    break;

                case Token.EXISTS:
                case Token.NOTEXISTS:
                    // EXISTS/NOT EXISTS
                    TryParseFilterExists(context, p, (next.TokenType == Token.EXISTS));
                    break;
                
                case Token.REGEX:
                    // Regular Expression
                    TryParseFilterRegex(context, next, p);
                    break;

                case Token.URI:
                case Token.QNAME:
                    // Extension function
                    TryParseFilterFunctionCall(context, next, p);
                    break;

                default:
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a FILTER Clause", next);
            }
        }

        private void TryParseFilterExpression(SparqlQueryParserContext context, GraphPattern p)
        {
            UnaryExpressionFilter filter = new UnaryExpressionFilter(TryParseExpression(context, false));
            p.IsFiltered = true;
            p.AddFilter(filter);
        }

        private void TryParseFilterBuiltInCall(SparqlQueryParserContext context, IToken t, GraphPattern p)
        {
            ISparqlFilter filter;
            IToken next = context.Tokens.Dequeue();

            // Should get a LeftBracket next
            if (next.TokenType != Token.LEFTBRACKET)
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Built-in Function call", next);
            }

            // Gather tokens for the FILTER expression
            Queue<IToken> subtokens = new Queue<IToken>();
            subtokens.Enqueue(t);
            subtokens.Enqueue(next);
            int openBrackets = 1;
            while (openBrackets > 0)
            {
                next = context.Tokens.Dequeue();
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }

                subtokens.Enqueue(next);
            }

            ISparqlExpression expr = context.ExpressionParser.Parse(subtokens);
            if (expr is BoundFunction)
            {
                filter = new BoundFilter((VariableTerm)expr.Arguments.First());
            }
            else
            {
                filter = new UnaryExpressionFilter(expr);
            }

            p.IsFiltered = true;
            p.AddFilter(filter);
        }

        private void TryParseFilterRegex(SparqlQueryParserContext context, IToken t, GraphPattern p)
        {
            // Gather all the Tokens that make up the Regex
            IToken next = context.Tokens.Peek();
            Queue<IToken> regexTokens = new Queue<IToken>();
            regexTokens.Enqueue(t);

            int openBrackets = 0;
            do
            {
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }

                regexTokens.Enqueue(next);
                context.Tokens.Dequeue();
                next = context.Tokens.Peek();

            } while (openBrackets > 0);

            UnaryExpressionFilter filter = new UnaryExpressionFilter(context.ExpressionParser.Parse(regexTokens));
            p.IsFiltered = true;
            p.AddFilter(filter);
        }

        private void TryParseFilterExists(SparqlQueryParserContext context, GraphPattern p, bool exists)
        {
            if (_syntax == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("EXISTS/NOT EXISTS is not supported in SPARQL 1.0");

            // EXISTS/NOT EXISTS generate a new Graph Pattern
            GraphPattern existsClause = TryParseGraphPattern(context);

            UnaryExpressionFilter filter = new UnaryExpressionFilter(new ExistsFunction(existsClause, exists));
            p.IsFiltered = true;
            p.AddFilter(filter);
        }

        private void TryParseFilterFunctionCall(SparqlQueryParserContext context, IToken t, GraphPattern p)
        {
            // Gather the Terms of the Function Call
            Queue<IToken> funcTokens = new Queue<IToken>();
            funcTokens.Enqueue(t);

            int openBrackets = 0;
            IToken next = context.Tokens.Peek();
            do
            {
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }

                funcTokens.Enqueue(next);
                context.Tokens.Dequeue();
                next = context.Tokens.Peek();

            } while (openBrackets > 0);

            UnaryExpressionFilter filter = new UnaryExpressionFilter(context.ExpressionParser.Parse(funcTokens));
            p.IsFiltered = true;
            p.AddFilter(filter);
        }

        private void TryParseOptionalClause(SparqlQueryParserContext context, GraphPattern p)
        {
            // Optional Clauses generate a child Graph Pattern
            GraphPattern child = TryParseGraphPattern(context);
            child.IsOptional = true;

            p.AddGraphPattern(child);
        }

        private void TryParseGraphClause(SparqlQueryParserContext context, GraphPattern p)
        {
            // Graph Clauses generate a child Graph Pattern

            // Get the Graph Specifier - must be a Variable/IRIRef
            IToken graphspec = context.Tokens.Dequeue();
            if (graphspec.TokenType != Token.URI && graphspec.TokenType != Token.QNAME && graphspec.TokenType != Token.VARIABLE)
            {
                throw ParserHelper.Error("Unexpected Token '" + graphspec.GetType().ToString() + "' encountered, expected a URI/QName/Variable Token to specify the active Graph for a GRAPH Clause", graphspec);
            }

            // Convert a QName or Relative Uri to a Absolute Uri
            if (graphspec.TokenType != Token.VARIABLE)
            {
                String u = Tools.ResolveUriOrQName(graphspec, context.Query.NamespaceMap, context.Query.BaseUri);
                if (!u.Equals(graphspec.Value))
                {
                    graphspec = new UriToken("<" + u + ">", graphspec.StartLine, graphspec.StartPosition, graphspec.EndPosition);
                }
            }
            else
            {
                context.Query.AddVariable(graphspec.Value);
            }

            GraphPattern child = TryParseGraphPattern(context);
            child.IsGraph = true;
            child.GraphSpecifier = graphspec;

            p.AddGraphPattern(child);

        }

        private void TryParseUnionClause(SparqlQueryParserContext context, GraphPattern p)
        {
            // Create a new Pattern which will hold the UNION
            GraphPattern union = new GraphPattern();
            union.IsUnion = true;

            // Add the Last Child Pattern of the Parent as that is the start of the UNION
            GraphPattern lastchild = p.LastChildPattern();
            if (lastchild.IsSimplifiable)
            {
                union.AddGraphPattern(lastchild.LastChildPattern());
            }
            else
            {
                union.AddGraphPattern(lastchild);
            }

            GraphPattern child = TryParseGraphPattern(context, true);
            union.AddGraphPattern(child);

            // Check for multiple
            IToken next = context.Tokens.Peek();
            while (next.TokenType == Token.UNION)
            {
                context.Tokens.Dequeue();
                union.AddGraphPattern(TryParseGraphPattern(context, true));
                next = context.Tokens.Peek();
            }

            p.AddGraphPattern(union);
        }

        private ISparqlExpression TryParseExpression(SparqlQueryParserContext context, bool commasTerminate)
        {
            return TryParseExpression(context, commasTerminate, false);
        }

        private ISparqlExpression TryParseExpression(SparqlQueryParserContext context, bool commasTerminate, bool asTerminates)
        {
            // Opening Bracket ( has already been discarded
            int openBrackets = 1;
            Queue<IToken> exprTerms = new Queue<IToken>();

            IToken next;
            while (openBrackets > 0)
            {
                // Get next Token
                next = context.Tokens.Peek();

                // Take account of nesting
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }
                else if (next.TokenType == Token.COMMA && openBrackets == 1 && commasTerminate)
                {
                    // Comma can terminate the Tokens that make an expression when only 1 bracket is open
                    openBrackets--;
                }
                else if (next.TokenType == Token.AS && openBrackets == 1 && asTerminates)
                {
                    // AS can terminate the Tokens that make an expression when only 1 bracket is open
                    openBrackets--;
                }
                else if (next.TokenType == Token.DISTINCT && openBrackets == 1 && commasTerminate)
                {
                    // DISTINCT can terminate the Tokens that make an expression if it occurs as the first thing and only 1 bracket is open
                    if (exprTerms.Count == 0)
                    {
                        context.Tokens.Dequeue();
                        return new DistinctModifier();
                    }
                    else
                    {
                        throw ParserHelper.Error("Unexpected DISTINCT Keyword Token encountered, DISTINCT modifier keyword may only occur as the first argument to an aggregate function", next);
                    }
                }

                if (openBrackets > 0)
                {
                    exprTerms.Enqueue(next);
                }
                context.Tokens.Dequeue();
            }

            // Use the internal Expression Parser
            return context.ExpressionParser.Parse(exprTerms);
        }

        private ISparqlExpression TryParseFunctionExpression(SparqlQueryParserContext context)
        {
            // Gather the Terms of the Function Call
            // We've already encountered a function keyword/QName/URI which is the start point
            Queue<IToken> funcTokens = new Queue<IToken>();
            funcTokens.Enqueue(context.Tokens.Dequeue());

            int openBrackets = 0;
            IToken next = context.Tokens.Peek();
            do
            {
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }

                funcTokens.Enqueue(next);
                context.Tokens.Dequeue();
                next = context.Tokens.Peek();

            } while (openBrackets > 0);

            return context.ExpressionParser.Parse(funcTokens);
        }

        private void TryParseOrderByClause(SparqlQueryParserContext context)
        {
            // ORDER BY has already been discarded
            IToken next = context.Tokens.Peek();

            // If SPARQL 1.1 then aggregates are permitted in ORDER BY
            if (context.SyntaxMode != SparqlQuerySyntax.Sparql_1_0) context.ExpressionParser.AllowAggregates = true;

            ISparqlOrderBy first, last;
            first = last = null;
            int termsSeen = 0;
            bool exit = false;

            while (true)
            {
                switch (next.TokenType)
                {
                    case Token.VARIABLE:
                        // Simple Variable Order By
                        if (first == null)
                        {
                            first = new OrderByVariable(next.Value);
                            last = first;
                        }
                        else
                        {
                            last.Child = new OrderByVariable(next.Value);
                            last = last.Child;
                        }
                        context.Tokens.Dequeue();
                        break;

                    case Token.ASC:
                    case Token.DESC:
                        // Ascending/Descending Expression Order By

                        // Discard the ASC/DESC token
                        context.Tokens.Dequeue();
                        bool desc = (next.TokenType == Token.DESC);

                        // Discard the ( token
                        next = context.Tokens.Peek();
                        if (next.TokenType != Token.LEFTBRACKET)
                        {
                            throw new RdfParseException("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Bracket Token to start a Bracketted Expression after an ASC/DESC Token");
                        }
                        context.Tokens.Dequeue();

                        if (first == null)
                        {
                            first = new OrderByExpression(TryParseExpression(context, false));
                            first.Descending = desc;
                            last = first;
                        }
                        else
                        {
                            last.Child = new OrderByExpression(TryParseExpression(context, false));
                            last.Child.Descending = desc;
                            last = last.Child;
                        }
                        break;

                    case Token.LEFTBRACKET:
                        // Ascending Expression Order By

                        // Discard the Left Bracket
                        context.Tokens.Dequeue();

                        if (first == null)
                        {
                            first = new OrderByExpression(TryParseExpression(context, false));
                            last = first;
                        }
                        else
                        {
                            last.Child = new OrderByExpression(TryParseExpression(context, false));
                            last = last.Child;
                        }
                        break;

                    case Token.ABS:
                    case Token.BNODE:
                    case Token.BOUND:
                    case Token.CALL:
                    case Token.CEIL:
                    case Token.COALESCE:
                    case Token.CONCAT:
                    case Token.DATATYPEFUNC:
                    case Token.DAY:
                    case Token.ENCODEFORURI:
                    case Token.EXISTS:
                    case Token.FLOOR:
                    case Token.HOURS:
                    case Token.IF:
                    case Token.IRI:
                    case Token.ISBLANK:
                    case Token.ISIRI:
                    case Token.ISLITERAL:
                    case Token.ISNUMERIC:
                    case Token.ISURI:
                    case Token.LANG:
                    case Token.LANGMATCHES:
                    case Token.LCASE:
                    case Token.MINUTES:
                    case Token.MONTH:
                    case Token.NOTEXISTS:
                    case Token.NOW:
                    case Token.RAND:
                    case Token.REGEX:
                    case Token.REPLACE:
                    case Token.ROUND:
                    case Token.SAMETERM:
                    case Token.SECONDS:
                    case Token.SHA1:
                    case Token.SHA224:
                    case Token.SHA256:
                    case Token.SHA384:
                    case Token.SHA512:
                    case Token.STR:
                    case Token.STRAFTER:
                    case Token.STRBEFORE:
                    case Token.CONTAINS:
                    case Token.STRDT:
                    case Token.STRENDS:
                    case Token.STRLANG:
                    case Token.STRLEN:
                    case Token.STRSTARTS:
                    case Token.STRUUID:
                    case Token.SUBSTR:
                    case Token.TIMEZONE:
                    case Token.TZ:
                    case Token.UCASE:
                    case Token.URIFUNC:
                    case Token.UUID:
                    case Token.YEAR:
                    case Token.QNAME:
                    case Token.URI:
                        // Built-in/Extension Function Call Order By
                        ISparqlExpression expr = TryParseFunctionExpression(context);

                        if (first == null)
                        {
                            first = new OrderByExpression(expr);
                            last = first;
                        }
                        else
                        {
                            last.Child = new OrderByExpression(expr);
                            last = last.Child;
                        }
                        break;

                    case Token.AVG:
                    case Token.COUNT:
                    case Token.GROUPCONCAT:
                    case Token.MAX:
                    case Token.MIN:
                    case Token.SUM:
                    case Token.SAMPLE:
                        if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToSafeString() + "' encountered, aggregates are not permitted in an ORDER BY in SPARQL 1.0", next);

                        // Built-in/Extension Function Call Order By
                        ISparqlExpression aggExpr = TryParseFunctionExpression(context);

                        if (first == null)
                        {
                            first = new OrderByExpression(aggExpr);
                            last = first;
                        }
                        else
                        {
                            last.Child = new OrderByExpression(aggExpr);
                            last = last.Child;
                        }
                        break;

                    default:
                        if (termsSeen == 0)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a valid ORDER BY clause term", next);
                        }
                        else
                        {
                            exit = true;
                        }
                        break;
                }
                if (exit) break;

                termsSeen++;
                next = context.Tokens.Peek();
            }

            context.ExpressionParser.AllowAggregates = false;

            // Set to Query
            context.Query.OrderBy = first;
        }

        private void TryParseGroupByClause(SparqlQueryParserContext context)
        {
            if (_syntax == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("GROUP BY clauses are not supported in SPARQL 1.0");

            // GROUP BY has already been discarded
            IToken next = context.Tokens.Peek();

            ISparqlGroupBy first, last, current;
            ISparqlExpression expr;
            first = last = current = null;
            int termsSeen = 0;
            bool exit = false;
            bool terminateExpression = false;

            while (true)
            {
                switch (next.TokenType)
                {
                    case Token.VARIABLE:
                        // Simple Variable Group By

                        String name = next.Value.Substring(1);
                        terminateExpression = (context.Tokens.Peek().TokenType == Token.AS);
                        if (!terminateExpression)
                        {
                            current = new GroupByVariable(name, name);
                        }
                        else
                        {
                            current = new GroupByVariable(name);
                        }
                        if (first == null)
                        {
                            first = current;
                            last = first;
                        }
                        else
                        {
                            last.Child = current;
                            last = last.Child;
                        }
                        context.Tokens.Dequeue();
                        break;

                    case Token.LEFTBRACKET:
                        // Bracketted Expression Group By
                        context.Tokens.Dequeue();
                        expr = TryParseExpression(context, false, true);
                        terminateExpression = (context.Tokens.LastTokenType == Token.AS);
                        if (!terminateExpression && expr is VariableTerm)
                        {
                            current = new GroupByVariable(expr.Variables.First());
                        }
                        else
                        {
                            current = new GroupByExpression(expr);
                        }
                        if (first == null)
                        {
                            first = current;
                            last = first;
                        }
                        else
                        {
                            last.Child = current;
                            last = last.Child;
                        }
                        break;

                    case Token.ABS:
                    case Token.BNODE:
                    case Token.BOUND:
                    case Token.CALL:
                    case Token.CEIL:
                    case Token.COALESCE:
                    case Token.CONCAT:
                    case Token.DATATYPEFUNC:
                    case Token.DAY:
                    case Token.ENCODEFORURI:
                    case Token.EXISTS:
                    case Token.FLOOR:
                    case Token.HOURS:
                    case Token.IF:
                    case Token.IRI:
                    case Token.ISBLANK:
                    case Token.ISIRI:
                    case Token.ISLITERAL:
                    case Token.ISNUMERIC:
                    case Token.ISURI:
                    case Token.LANG:
                    case Token.LANGMATCHES:
                    case Token.LCASE:
                    case Token.MINUTES:
                    case Token.MONTH:
                    case Token.NOTEXISTS:
                    case Token.NOW:
                    case Token.RAND:
                    case Token.REGEX:
                    case Token.REPLACE:
                    case Token.ROUND:
                    case Token.SAMETERM:
                    case Token.SECONDS:
                    case Token.SHA1:
                    case Token.SHA224:
                    case Token.SHA256:
                    case Token.SHA384:
                    case Token.SHA512:
                    case Token.STR:
                    case Token.STRAFTER:
                    case Token.STRBEFORE:
                    case Token.CONTAINS:
                    case Token.STRDT:
                    case Token.STRENDS:
                    case Token.STRLANG:
                    case Token.STRLEN:
                    case Token.STRSTARTS:
                    case Token.STRUUID:
                    case Token.SUBSTR:
                    case Token.TIMEZONE:
                    case Token.TZ:
                    case Token.UCASE:
                    case Token.URIFUNC:
                    case Token.YEAR:
                    case Token.URI:
                    case Token.UUID:
                    case Token.QNAME:
                        // Function Expression Group By
                        expr = TryParseFunctionExpression(context);
                        terminateExpression = (context.Tokens.Peek().TokenType == Token.AS);
                        current = new GroupByExpression(expr);
                        if (first == null)
                        {
                            first = current;
                            last = first;
                        }
                        else
                        {
                            last.Child = current;
                            last = last.Child;
                        }
                        break;

                    default:
                        if (termsSeen == 0)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a valid GROUP BY clause term", next);
                        }
                        else
                        {
                            exit = true;
                        }
                        break;
                }
                if (exit) break;

                termsSeen++;
                next = context.Tokens.Peek();

                // Allow an AS ?var after an expression
                if (next.TokenType == Token.AS || terminateExpression)
                {
                    if (!terminateExpression) context.Tokens.Dequeue();
                    next = context.Tokens.Peek();
                    if (next.TokenType == Token.VARIABLE)
                    {
                        context.Tokens.Dequeue();
                        if (current != null) current.AssignVariable = next.Value.Substring(1);
                        next = context.Tokens.Peek();

                        // Find the terminating right bracket if required
                        if (terminateExpression)
                        {
                            if (next.TokenType != Token.RIGHTBRACKET)
                            {
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a ) to terminate the AS clause in a bracketted expression", next);
                            }
                            context.Tokens.Dequeue();
                            next = context.Tokens.Peek();
                        }
                    }
                    else
                    {
                        throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable Token after an AS token in a GROUP BY clause to specify the value to assign the GROUPed value to", next);
                    }
                }

                terminateExpression = false;
            }

            // Set to Query
            context.Query.GroupBy = first;
        }

        private void TryParseHavingClause(SparqlQueryParserContext context)
        {
            if (_syntax == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("HAVING clauses are not supported in SPARQL 1.0");
            // HAVING Keyword has already been discarded
            IToken next = context.Tokens.Peek();
            ISparqlExpression havingExpr;

            switch (next.TokenType)
            {
                case Token.LEFTBRACKET:
                    // Find and parse the Expression
                    context.Tokens.Dequeue();
                    int openBrackets = 1;
                    Queue<IToken> exprTerms = new Queue<IToken>();
                    while (openBrackets > 0)
                    {
                        // Get next Token
                        next = context.Tokens.Peek();

                        // Take account of nesting
                        if (next.TokenType == Token.LEFTBRACKET)
                        {
                            openBrackets++;
                        }
                        else if (next.TokenType == Token.RIGHTBRACKET)
                        {
                            openBrackets--;
                        }

                        if (openBrackets > 0)
                        {
                            exprTerms.Enqueue(next);
                        }
                        context.Tokens.Dequeue();
                    }

                    // Permit aggregates in the Expression
                    context.ExpressionParser.AllowAggregates = true;
                    havingExpr = context.ExpressionParser.Parse(exprTerms);
                    context.ExpressionParser.AllowAggregates = false;
                    break;

                case Token.ABS:
                case Token.BNODE:
                case Token.BOUND:
                case Token.CALL:
                case Token.CEIL:
                case Token.COALESCE:
                case Token.CONCAT:
                case Token.DATATYPEFUNC:
                case Token.DAY:
                case Token.ENCODEFORURI:
                case Token.EXISTS:
                case Token.FLOOR:
                case Token.HOURS:
                case Token.IF:
                case Token.IRI:
                case Token.ISBLANK:
                case Token.ISIRI:
                case Token.ISLITERAL:
                case Token.ISNUMERIC:
                case Token.ISURI:
                case Token.LANG:
                case Token.LANGMATCHES:
                case Token.LCASE:
                case Token.MINUTES:
                case Token.MONTH:
                case Token.NOTEXISTS:
                case Token.NOW:
                case Token.RAND:
                case Token.REGEX:
                case Token.REPLACE:
                case Token.ROUND:
                case Token.SAMETERM:
                case Token.SECONDS:
                case Token.SHA1:
                case Token.SHA224:
                case Token.SHA256:
                case Token.SHA384:
                case Token.SHA512:
                case Token.STR:
                case Token.STRAFTER:
                case Token.STRBEFORE:
                case Token.CONTAINS:
                case Token.STRDT:
                case Token.STRENDS:
                case Token.STRLANG:
                case Token.STRLEN:
                case Token.STRSTARTS:
                case Token.STRUUID:
                case Token.SUBSTR:
                case Token.TIMEZONE:
                case Token.TZ:
                case Token.UCASE:
                case Token.URIFUNC:
                case Token.YEAR:
                case Token.URI:
                case Token.UUID:
                case Token.QNAME:
                    // Built-in function/expression
                    context.ExpressionParser.AllowAggregates = true;
                    havingExpr = TryParseFunctionExpression(context);
                    context.ExpressionParser.AllowAggregates = false;
                    break;

                default:
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Bracket to start a bracketted expression in a HAVING Clause", next);
            }

            // Set the Having Clause of the Group By
            // For Leviathan we can just wrap in a standard Unary Expression Filter
            context.Query.Having = new UnaryExpressionFilter(havingExpr);
       }

        private void TryParseLimitOffsetClause(SparqlQueryParserContext context)
        {
            IToken next = context.Tokens.Dequeue();

            int limit, offset;
            limit = offset = 0;

            if (next.TokenType == Token.LIMIT)
            {
                // Expect a Plain Literal which can be parsed to an Integer
                next = context.Tokens.Dequeue();
                if (next.TokenType == Token.PLAINLITERAL)
                {
                    if (Int32.TryParse(next.Value, out limit))
                    {
                        context.Query.Limit = limit;

                        // Is there a subsequent OFFSET?
                        next = context.Tokens.Peek();
                        if (next.TokenType == Token.OFFSET)
                        {
                            context.Tokens.Dequeue();
                            next = context.Tokens.Dequeue();
                            if (next.TokenType == Token.PLAINLITERAL)
                            {
                                if (Int32.TryParse(next.Value, out offset))
                                {
                                    context.Query.Offset = offset;
                                }
                                else
                                {
                                    throw ParserHelper.Error("Unable to convert string '" + next.Value + "' into an Integer to use as the results offset for a OFFSET Clause", next);
                                }
                            }
                            else
                            {
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Plain Literal containing an Integer value as part of the OFFSET Clause", next);
                            }
                        }
                    }
                    else
                    {
                        throw ParserHelper.Error("Unable to convert string '" + next.Value + "' into an Integer to use as the results limit for a LIMIT Clause", next);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Plain Literal containing an Integer value as part of the LIMIT Clause", next);
                }
            }
            else if (next.TokenType == Token.OFFSET)
            {
                // Expect a Plain Literal which can be parsed to an Integer
                next = context.Tokens.Dequeue();
                if (next.TokenType == Token.PLAINLITERAL)
                {
                    if (Int32.TryParse(next.Value, out offset))
                    {
                        context.Query.Offset = offset;

                        // Is there a subsequent LIMIT?
                        next = context.Tokens.Peek();
                        if (next.TokenType == Token.LIMIT)
                        {
                            context.Tokens.Dequeue();
                            next = context.Tokens.Dequeue();
                            if (next.TokenType == Token.PLAINLITERAL)
                            {
                                if (Int32.TryParse(next.Value, out limit))
                                {
                                    context.Query.Limit = limit;
                                }
                                else
                                {
                                    throw ParserHelper.Error("Unable to convert string '" + next.Value + "' into an Integer to use as the results limit for a LIMIT Clause", next);
                                }
                            }
                            else
                            {
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Plain Literal containing an Integer value as part of the LIMIT Clause", next);
                            }
                        }
                    }
                    else
                    {
                        throw ParserHelper.Error("Unable to convert string '" + next.Value + "' into an Integer to use as the results offset for a OFFSET Clause", next);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Plain Literal containing an Integer value as part of the OFFSET Clause", next);
                }
            }
            else
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Limit/Offset Token to start a Limit Offset Clause", next);
            }
        }

        private void TryParseExistsClause(SparqlQueryParserContext context, GraphPattern p, bool exists)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("EXISTS and NOT EXISTS clauses are not supported in SPARQL 1.0");
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_1) throw new RdfParseException("EXISTS and NOT EXISTS clauses can only be used inside FILTER clauses in SPARQL 1.1");

            // EXISTS and NOT EXISTS generate a new Child Graph Pattern
            GraphPattern child = TryParseGraphPattern(context);

            if (exists)
            {
                child.IsExists = true;
            }
            else
            {
                child.IsNotExists = true;
            }

            p.AddGraphPattern(child);
        }

        private void TryParseMinusClause(SparqlQueryParserContext context, GraphPattern p)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("MINUS clauses are not supported in SPARQL 1.0");

            // MINUS generates a new child graph pattern
            GraphPattern child = TryParseGraphPattern(context);
            child.IsMinus = true;
            p.AddGraphPattern(child);
        }

        private void TryParseLetAssignment(SparqlQueryParserContext context, GraphPattern p)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("LET assignment is not supported in SPARQL 1.0");
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_1) throw new RdfParseException("LET assignment is not supported in SPARQL 1.1 - use BIND assignment instead");

            IToken variable;
            ISparqlExpression expr;

            // Firstly we expect an opening bracket, a variable and then an assignment operator
            IToken next = context.Tokens.Dequeue();
            if (next.TokenType == Token.LEFTBRACKET)
            {
                next = context.Tokens.Dequeue();
                if (next.TokenType == Token.VARIABLE)
                {
                    variable = next;
                    context.Query.AddVariable(variable.Value, false);
                    next = context.Tokens.Dequeue();
                    if (next.TokenType == Token.ASSIGNMENT)
                    {
                        // See if there is a valid expression for the right hand side of the assignment
                        next = context.Tokens.Peek();
                        switch (next.TokenType)
                        {
                            case Token.ABS:
                            case Token.BNODE:
                            case Token.BOUND:
                            case Token.CALL:
                            case Token.CEIL:
                            case Token.COALESCE:
                            case Token.CONCAT:
                            case Token.DATATYPEFUNC:
                            case Token.DAY:
                            case Token.ENCODEFORURI:
                            case Token.EXISTS:
                            case Token.FLOOR:
                            case Token.HOURS:
                            case Token.IF:
                            case Token.IRI:
                            case Token.ISBLANK:
                            case Token.ISIRI:
                            case Token.ISLITERAL:
                            case Token.ISNUMERIC:
                            case Token.ISURI:
                            case Token.LANG:
                            case Token.LANGMATCHES:
                            case Token.LCASE:
                            case Token.MINUTES:
                            case Token.MONTH:
                            case Token.NOTEXISTS:
                            case Token.NOW:
                            case Token.RAND:
                            case Token.REGEX:
                            case Token.REPLACE:
                            case Token.ROUND:
                            case Token.SAMETERM:
                            case Token.SECONDS:
                            case Token.SHA1:
                            case Token.SHA224:
                            case Token.SHA256:
                            case Token.SHA384:
                            case Token.SHA512:
                            case Token.STR:
                            case Token.STRAFTER:
                            case Token.STRBEFORE:
                            case Token.CONTAINS:
                            case Token.STRDT:
                            case Token.STRENDS:
                            case Token.STRLANG:
                            case Token.STRLEN:
                            case Token.STRSTARTS:
                            case Token.STRUUID:
                            case Token.SUBSTR:
                            case Token.TIMEZONE:
                            case Token.TZ:
                            case Token.UCASE:
                            case Token.URIFUNC:
                            case Token.UUID:
                            case Token.YEAR:
                            case Token.URI:
                            case Token.QNAME:
                                expr = TryParseFunctionExpression(context);
                                break;
                            case Token.LEFTBRACKET:
                                context.Tokens.Dequeue();
                                expr = TryParseExpression(context, false);
                                break;
                            case Token.VARIABLE:
                                context.Tokens.Dequeue();
                                expr = new VariableTerm(next.Value);
                                break;
                            default:
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Token which was valid as the start of an expression for the right hand side of a LET assignment", next);
                        }

                        // Finally expect a Right Bracket to terminate the LET
                        next = context.Tokens.Dequeue();
                        if (next.TokenType != Token.RIGHTBRACKET)
                        {
                            throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Right Bracket to terminate the LET assignment", next);
                        }
                        
                        // Create a Let Pattern and add to the Query appropriately
                        LetPattern let = new LetPattern(variable.Value.Substring(1), expr);
                        if (Options.QueryOptimisation)
                        {
                            p.AddAssignment(let);
                        }
                        else
                        {
                            // When Optimisation is turned off we'll just stick the Let in the Triples Pattern where it occurs
                            // since we're not going to do any Triple Pattern ordering, Assignment or FILTER placement
                            p.AddTriplePattern(let);
                        }
                    }
                    else
                    {
                        throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected an Assignment operator as part of a LET assignment", next);
                    }
                }
                else
                {
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable as the first item in a LET assignment", next);
                }
            }
            else
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Bracket to start a LET assignment after a LET Keyword", next);
            }
        }

        private void TryParseBindAssignment(SparqlQueryParserContext context, GraphPattern p)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("BIND assignment is not supported in SPARQL 1.0");

            // First need to discard opening (
            IToken next = context.Tokens.Dequeue();
            if (next.TokenType != Token.LEFTBRACKET) throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a ( to start a BIND assignment after a BIND keyword", next);

            // Expect a bracketted expression terminated by an AS
            ISparqlExpression expr = TryParseExpression(context, false, true);
            if (context.Tokens.LastTokenType != Token.AS)
            {
                throw ParserHelper.Error("A BIND assignment did not end with an AS ?var as expected, BIND assignment must be of the general form BIND(expr AS ?var)", next);
            }

            // Ensure there is a Variable after the AS
            next = context.Tokens.Dequeue();
            if (next.TokenType == Token.VARIABLE)
            {
                BindPattern bind = new BindPattern(next.Value.Substring(1), expr);

                // Check that the Variable has not already been used
                if (context.Query.RootGraphPattern != null && context.Query.RootGraphPattern.Variables.Contains(bind.VariableName))
                {
                    throw ParserHelper.Error("A BIND assignment is attempting to bind to the variable ?" + bind.VariableName + " but this variable is already in use in the query", next);
                }
                else if (p.Variables.Contains(bind.VariableName))
                {
                    throw ParserHelper.Error("A BIND assignment is attempting to bind to the variable ?" + bind.VariableName + " but this variable is already in use earlier in the Graph pattern", next);
                }

                if (Options.QueryOptimisation)
                {
                    p.AddAssignment(bind);
                }
                else
                {
                    // When Optimisation is turned off we'll just stick the BIND in the Triples Pattern where it occurs
                    // since we're not going to do any Triple Pattern ordering, Assignment or FILTER placement
                    p.AddTriplePattern(bind);
                    // In this case the BIND must break the BGP since using AddTriplePattern will not do it automatically
                    p.BreakBGP();
                }

                // Ensure the BIND assignment is terminated with a )
                next = context.Tokens.Dequeue();
                if (next.TokenType != Token.RIGHTBRACKET) throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a ) to terminate a BIND assignment", next);
            }
            else
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Variable after the AS in a BIND assignment", next);
            }
        }

        private void TryParseSubquery(SparqlQueryParserContext context, GraphPattern p)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Sub-queries are not supported in SPARQL 1.0");

            // We're going to make a temporary Token Queue which we will populate and then
            // use to create a new SPARQL Query Parser Context
            NonTokenisedTokenQueue tokens = new NonTokenisedTokenQueue();

            // Assume we've already seen a SELECT
            tokens.Enqueue(new BOFToken());
            tokens.Enqueue(new SelectKeywordToken(1, 1));

            // Now collect Tokens until we hit the closing Right Bracket
            int openBrackets = 1;
            do
            {
                IToken next = context.Tokens.Peek();

                if (next.TokenType == Token.LEFTCURLYBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTCURLYBRACKET)
                {
                    openBrackets--;
                }
                else if (next.TokenType == Token.EOF)
                {
                    throw ParserHelper.Error("Unexpected End of File encountered while trying to gather Tokens to parse a Sub-Query from", next);
                }

                if (openBrackets > 0)
                {
                    tokens.Enqueue(context.Tokens.Dequeue());
                }
            } while (openBrackets > 0);

            tokens.Enqueue(new EOFToken(0, 0));

            // Create a Sub-query Parser Context
            SparqlQueryParserContext subcontext = new SparqlQueryParserContext(context, tokens);
            subcontext.Query.NamespaceMap.Import(context.Query.NamespaceMap);
            SparqlQuery subquery = ParseInternal(subcontext);
            foreach (SparqlVariable var in subquery.Variables)
            {
                if (var.IsResultVariable) context.Query.AddVariable("?" + var.Name, false);
            }
            SubQueryPattern subqueryPattern = new SubQueryPattern(subquery);
            GraphPattern p2 = new GraphPattern();
            p2.AddTriplePattern(subqueryPattern);
            p.AddGraphPattern(p2);
        }

        private void TryParseServiceClause(SparqlQueryParserContext context, GraphPattern p)
        {
            if (context.SyntaxMode == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("SERVICE clauses are not supported in SPARQL 1.0");

            // May allow an optional SILENT keyword
            bool silent = false;
            if (context.Tokens.Peek().TokenType == Token.SILENT)
            {
                context.Tokens.Dequeue();
                silent = true;
            }

            // SERVICE first has a URI/Variable service specifier
            IToken specifier = context.Tokens.Dequeue();
            if (specifier.TokenType != Token.URI && specifier.TokenType != Token.VARIABLE)
            {
                throw ParserHelper.Error("Unexpected Token '" + specifier.GetType().ToString() + "' encountered, expected a URI/Variable after a SERVICE keyword", specifier);
            }

            // Then a Graph Pattern
            GraphPattern child = TryParseGraphPattern(context);
            child.IsService = true;
            child.GraphSpecifier = specifier;
            child.IsSilent = silent;
            p.AddGraphPattern(child);
        }

        private BindingsPattern TryParseInlineData(SparqlQueryParserContext context)
        {
            // First expect either a single variable or a sequence of variables enclosed in ( )
            IToken next = context.Tokens.Peek();
            List<String> vars = new List<String>();
            bool simpleForm = false;
            if (next.TokenType == Token.LEFTBRACKET)
            {
                context.Tokens.Dequeue();
                next = context.Tokens.Peek();
                while (next.TokenType == Token.VARIABLE)
                {
                    vars.Add(next.Value.Substring(1));
                    context.Tokens.Dequeue();
                    next = context.Tokens.Peek();
                }
                if (next.TokenType != Token.RIGHTBRACKET) throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' ecountered, expected a ) to terminate the variables list for a VALUES clause", next);
                context.Tokens.Dequeue();
            }
            else if (next.TokenType == Token.VARIABLE)
            {
                // Using the simplified form of the syntax
                simpleForm = true;
                vars.Add(next.Value.Substring(1));
                context.Tokens.Dequeue();
            }
            else
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected variables list for a VALUES clause", next);
            }

            // Then expect a Left Curly Bracket
            next = context.Tokens.Peek();
            if (next.TokenType == Token.LEFTCURLYBRACKET)
            {
                context.Tokens.Dequeue();
                BindingsPattern bindings = new BindingsPattern(vars);

                // Each Binding tuple must start with a ( unless using simplified single variable syntax form
                next = context.Tokens.Peek();
                while ((simpleForm && next.TokenType != Token.RIGHTCURLYBRACKET) || next.TokenType == Token.LEFTBRACKET)
                {
                    if (!simpleForm)
                    {
                        // Discard the ( and peek the next token
                        context.Tokens.Dequeue();
                        next = context.Tokens.Peek();
                    }

                    // Expect a sequence of values in the tuple
                    List<PatternItem> values = new List<PatternItem>();
                    while (next.TokenType != Token.RIGHTBRACKET)
                    {
                        next = context.Tokens.Dequeue();

                        // Get the value
                        switch (next.TokenType)
                        {
                            case Token.URI:
                            case Token.QNAME:
                            case Token.LITERALWITHDT:
                            case Token.LITERALWITHLANG:
                            case Token.PLAINLITERAL:
                                values.Add(TryCreatePatternItem(context, next));
                                break;

                            case Token.LONGLITERAL:
                            case Token.LITERAL:
                                // Need to check for subsequent datatype or language declaration
                                IToken lit = next;
                                next = context.Tokens.Peek();
                                if (next.TokenType == Token.HATHAT)
                                {
                                    context.Tokens.Dequeue();
                                    next = context.Tokens.Dequeue();
                                    if (next.TokenType == Token.DATATYPE)
                                    {
                                        LiteralWithDataTypeToken dtlit = new LiteralWithDataTypeToken(lit, (DataTypeToken)next);
                                        values.Add(TryCreatePatternItem(context, dtlit));
                                    }
                                    else
                                    {
                                        throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Datatype Token to specify the datatype for a Literal", next);
                                    }
                                }
                                else if (next.TokenType == Token.LANGSPEC)
                                {
                                    context.Tokens.Dequeue();
                                    LiteralWithLanguageSpecifierToken langlit = new LiteralWithLanguageSpecifierToken(lit, (LanguageSpecifierToken)next);
                                    values.Add(TryCreatePatternItem(context, langlit));
                                }
                                else
                                {
                                    values.Add(TryCreatePatternItem(context, lit));
                                }
                                break;

                            case Token.UNDEF:
                                // UNDEF indicates an unbound variable which equates to a null
                                values.Add(null);
                                break;

                            default:
                                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Token for a URI/Literal or an UNDEF keyword as part of a tuple in a VALUES clause", next);
                        }

                        next = context.Tokens.Peek();

                        // For simplified syntax just break after each value
                        if (simpleForm) break;
                    }

                    if (vars.Count != values.Count)
                    {
                        throw new RdfParseException("Invalid tuple in the VALUES clause, each Binding should contain " + vars.Count + " values but got a tuple containing " + values.Count + " values");
                    }

                    // Generate a representation of this possible solution and add it to our Bindings object
                    bindings.AddTuple(new BindingTuple(vars, values));

                    // Discard the ) and peek the next token
                    if (!simpleForm) context.Tokens.Dequeue();
                    next = context.Tokens.Peek();
                }

                // Finally we need to see a Right Curly Bracket
                if (next.TokenType != Token.RIGHTCURLYBRACKET)
                {
                    throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Right Curly Bracket to terminate the VALUES clause", next);
                }
                context.Tokens.Dequeue();

                return bindings;
            }
            else
            {
                throw ParserHelper.Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Curly Bracket after the list of variables as part of a VALUES clause", next);
            }
        }

        private PatternItem TryCreatePatternItem(SparqlQueryParserContext context, IToken t)
        {
            String baseUri;
            Uri u;

            switch (t.TokenType)
            {
                case Token.VARIABLE:
                    // Variables accept any Node as a substitution
                    return new VariablePattern(t.Value);

                case Token.URI:
                    // Uri uses a Node Match
                    if (t.Value.StartsWith("_:"))
                    {
                        return new FixedBlankNodePattern(t.Value);
                    }
                    else
                    {
                        String uri = Tools.ResolveUri(t.Value, context.Query.BaseUri.ToSafeString());
                        u = UriFactory.Create(uri);
                        return new NodeMatchPattern(new UriNode(null, u));
                    }

                case Token.QNAME:
                    // QName uses a Node Match
                    return new NodeMatchPattern(new UriNode(null, ResolveQName(context, t.Value)));

                case Token.LITERAL:
                case Token.LONGLITERAL:
                    // Literals use Node Matches
                    return new NodeMatchPattern(new NonNormalizedLiteralNode(null, t.Value));

                case Token.PLAINLITERAL:
                    // Plain Literals either use an inferred Literal Node Match
                    // We know it must be one of the inferrable types or the Parser would have failed at the Tokenisation stage for the Literal
                    if (TurtleSpecsHelper.IsValidDouble(t.Value))
                    {
                        // Double - Check first since to be considered a double must contain an exponent so is unique compared to 
                        // the other two numeric types
                        return new NodeMatchPattern(new LiteralNode(null, t.Value, UriFactory.Create(XmlSpecsHelper.XmlSchemaDataTypeDouble)));
                    }
                    else if (TurtleSpecsHelper.IsValidInteger(t.Value))
                    {
                        // Integer - Check before decimal as any valid integer is a valid decimal
                        return new NodeMatchPattern(new LiteralNode(null, t.Value, UriFactory.Create(XmlSpecsHelper.XmlSchemaDataTypeInteger)));
                    }
                    else if (TurtleSpecsHelper.IsValidDecimal(t.Value))
                    {
                        // Decimal - Check last since any valid integer is also a valid decimal
                        return new NodeMatchPattern(new LiteralNode(null, t.Value, UriFactory.Create(XmlSpecsHelper.XmlSchemaDataTypeDecimal)));
                    }
                    else
                    {
                        // Boolean
                        return new NodeMatchPattern(new LiteralNode(null, t.Value, UriFactory.Create(XmlSpecsHelper.XmlSchemaDataTypeBoolean)));
                    }


                case Token.LITERALWITHDT:
                    // Literal with Datatype use Node Matches
                    LiteralWithDataTypeToken litdt = (LiteralWithDataTypeToken)t;
                    if (litdt.DataType.StartsWith("<"))
                    {
                        baseUri = (context.Query.BaseUri == null) ? String.Empty : context.Query.BaseUri.AbsoluteUri;
                        u = UriFactory.Create(Tools.ResolveUri(litdt.DataType.Substring(1, litdt.DataType.Length - 2), baseUri));
                        return new NodeMatchPattern(new NonNormalizedLiteralNode(null, litdt.Value, u));
                    }
                    else
                    {
                        // Resolve the QName                       
                        return new NodeMatchPattern(new NonNormalizedLiteralNode(null, litdt.Value, ResolveQName(context, litdt.DataType)));
                    }

                case Token.LITERALWITHLANG:
                    // Literal with Lang Spec use Node Matches
                    LiteralWithLanguageSpecifierToken litls = (LiteralWithLanguageSpecifierToken)t;
                    return new NodeMatchPattern(new NonNormalizedLiteralNode(null, litls.Value, litls.Language));

                case Token.BLANKNODEWITHID:
                    // Blanks accept any Blank
                    return new BlankNodePattern(t.Value.Substring(2));

                case Token.KEYWORDA:
                    return new NodeMatchPattern(new UriNode(null, UriFactory.Create(NamespaceMapper.RDF + "type")));

                default:
                    throw ParserHelper.Error("Unable to Convert a '" + t.GetType().ToString() + "' to a Pattern Item in a Triple Pattern", t);
            }
        }

        private Uri ResolveQName(SparqlQueryParserContext context, String qname)
        {
            return UriFactory.Create(Tools.ResolveQName(qname, context.Query.NamespaceMap, context.Query.BaseUri));
        }

        private bool IsProjectableExpression(SparqlQueryParserContext context, ISparqlExpression expr, List<String> projectedSoFar)
        {
            if (expr.Type == SparqlExpressionType.Aggregate) return true;
            if (expr.Type == SparqlExpressionType.Primary)
            {
                return expr.Variables.All(v => context.Query.GroupBy.ProjectableVariables.Contains(v) || projectedSoFar.Contains(v));
            }
            else
            {
                return expr.Arguments.All(arg => IsProjectableExpression(context, arg, projectedSoFar));
            }
        }

        /// <summary>
        /// Constructs an error message that informs the user about unexpected excess tokens in a SPARQL qery.
        /// </summary>
        /// <param name="context">Current parser context.</param>
        /// <param name="expectedCount">The expected number of tokens.</param>
        /// <returns></returns>
        public string ExcessTokensString(SparqlQueryParserContext context, int expectedCount)
        {
            var builder = new StringBuilder();
            builder.Append("The following excess tokens were ecountered from Line ");

            List<IToken> excessTokens = new List<IToken>();
            while (context.LocalTokens.Count > expectedCount)
            {
                excessTokens.Add(context.LocalTokens.Pop());
            }
            excessTokens.Reverse();

            IToken first = excessTokens[0];
            builder.AppendLine(first.StartLine + " Column " + first.StartPosition + " onwards:");
            for (int i = 0; i < excessTokens.Count; i++)
            {
                builder.Append(excessTokens[i].Value);
                builder.Append(' ');
            }
            builder.AppendLine();
            builder.Append("You may be missing some syntax to divide these tokens into multiple triple patterns");
            return builder.ToString();
        }
        
        #endregion
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF\Parsing\SPARQLQueryParser.cs(945,51): error CS0128: A local variable or function named 'aggregateTerm' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF\Parsing\SPARQLQueryParser.cs(947,99): error CS0165: Use of unassigned local variable 'aggregateTerm'
######################################################################


######################################################################
Nr: 5 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\AlgebraJoinClasses.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using VDS.RDF.Nodes;
using VDS.RDF.Query.Expressions;
using VDS.RDF.Query.Expressions.Primary;
using VDS.RDF.Query.Filters;
using VDS.RDF.Query.Optimisation;
using VDS.RDF.Query.Patterns;

namespace VDS.RDF.Query.Algebra
{
    /// <summary>
    /// Represents a LeftJoin predicated on the existence/non-existence of joinable sets on the RHS for each item on the LHS.
    /// </summary>
    public class ExistsJoin 
        : IExistsJoin
    {
        private readonly ISparqlAlgebra _lhs, _rhs;
        private readonly bool _mustExist;

        /// <summary>
        /// Creates a new Exists Join.
        /// </summary>
        /// <param name="lhs">LHS Pattern.</param>
        /// <param name="rhs">RHS Pattern.</param>
        /// <param name="mustExist">Whether a joinable set must exist on the RHS for the LHS set to be preserved.</param>
        public ExistsJoin(ISparqlAlgebra lhs, ISparqlAlgebra rhs, bool mustExist)
        {
            _lhs = lhs;
            _rhs = rhs;
            _mustExist = mustExist;
        }

        /// <summary>
        /// Evaluates an ExistsJoin.
        /// </summary>
        /// <param name="context">Evaluation Context.</param>
        /// <returns></returns>
        public BaseMultiset Evaluate(SparqlEvaluationContext context)
        {
            BaseMultiset initialInput = context.InputMultiset;
            BaseMultiset lhsResult = context.Evaluate(_lhs);//this._lhs.Evaluate(context);
            context.CheckTimeout();

            if (lhsResult is NullMultiset)
            {
                context.OutputMultiset = lhsResult;
            }
            else if (lhsResult.IsEmpty)
            {
                context.OutputMultiset = new NullMultiset();
            }
            else
            {
                // Only execute the RHS if the LHS had results
                context.InputMultiset = lhsResult;
                BaseMultiset rhsResult = context.Evaluate(_rhs);//this._rhs.Evaluate(context);
                context.CheckTimeout();

                context.OutputMultiset = lhsResult.ExistsJoin(rhsResult, _mustExist);
                context.CheckTimeout();
            }

            context.InputMultiset = context.OutputMultiset;
            return context.OutputMultiset;
        }

        /// <summary>
        /// Gets the Variables used in the Algebra.
        /// </summary>
        public IEnumerable<String> Variables
        {
            get
            {
                return (_lhs.Variables.Concat(_rhs.Variables)).Distinct();
            }
        }

        /// <summary>
        /// Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FloatingVariables
        {
            get { return _lhs.FloatingVariables; }
        }

        /// <summary>
        /// Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FixedVariables
        {
            get { return _lhs.FixedVariables; }
        }

        /// <summary>
        /// Gets the LHS of the Join.
        /// </summary>
        public ISparqlAlgebra Lhs
        {
            get
            {
                return _lhs;
            }
        }

        /// <summary>
        /// Gets the RHS of the Join.
        /// </summary>
        public ISparqlAlgebra Rhs
        {
            get
            {
                return _rhs;
            }
        }

        /// <summary>
        /// Gets whether this is an EXISTS join.
        /// </summary>
        public bool MustExist
        {
            get
            {
                return _mustExist;
            }
        }

        /// <summary>
        /// Gets the String representation of the Algebra.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "ExistsJoin(" + _lhs.ToString() + ", " + _rhs.ToString() + ", " + _mustExist + ")";
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public SparqlQuery ToQuery()
        {
            SparqlQuery q = new SparqlQuery();
            q.RootGraphPattern = ToGraphPattern();
            q.Optimise();
            return q;
        }

        /// <summary>
        /// Converts the Algebra back to a Graph Pattern.
        /// </summary>
        /// <returns></returns>
        public GraphPattern ToGraphPattern()
        {
            GraphPattern p = _lhs.ToGraphPattern();
            GraphPattern opt = _rhs.ToGraphPattern();
            if (_mustExist)
            {
                opt.IsExists = true;
            }
            else
            {
                opt.IsNotExists = true;
            }
            p.AddGraphPattern(opt);
            return p;
        }

        /// <summary>
        /// Transforms both sides of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra Transform(IAlgebraOptimiser optimiser)
        {
            return new ExistsJoin(optimiser.Optimise(_lhs), optimiser.Optimise(_rhs), _mustExist);
        }

        /// <summary>
        /// Transforms the LHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformLhs(IAlgebraOptimiser optimiser)
        {
            return new ExistsJoin(optimiser.Optimise(_lhs), _rhs, _mustExist);
        }

        /// <summary>
        /// Transforms the RHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformRhs(IAlgebraOptimiser optimiser)
        {
            return new ExistsJoin(_lhs, optimiser.Optimise(_rhs), _mustExist);
        }
    }

    /// <summary>
    /// Represents a LeftJoin predicated on an arbitrary filter expression.
    /// </summary>
    public class LeftJoin 
        : ILeftJoin
    {
        private readonly ISparqlAlgebra _lhs, _rhs;
        private readonly ISparqlFilter _filter = new UnaryExpressionFilter(new ConstantTerm(new BooleanNode(null, true)));

        /// <summary>
        /// Creates a new LeftJoin where there is no Filter over the join.
        /// </summary>
        /// <param name="lhs">LHS Pattern.</param>
        /// <param name="rhs">RHS Pattern.</param>
        public LeftJoin(ISparqlAlgebra lhs, ISparqlAlgebra rhs)
        {
            _lhs = lhs;
            _rhs = rhs;
        }

        /// <summary>
        /// Creates a new LeftJoin where there is a Filter over the join.
        /// </summary>
        /// <param name="lhs">LHS Pattern.</param>
        /// <param name="rhs">RHS Pattern.</param>
        /// <param name="filter">Filter to decide which RHS solutions are valid.</param>
        public LeftJoin(ISparqlAlgebra lhs, ISparqlAlgebra rhs, ISparqlFilter filter)
            : this(lhs, rhs)
        {
            _filter = filter;
        }

        /// <summary>
        /// Evaluates the LeftJoin.
        /// </summary>
        /// <param name="context">Evaluation Context.</param>
        /// <returns></returns>
        public BaseMultiset Evaluate(SparqlEvaluationContext context)
        {
            // Need to be careful about whether we linearize (CORE-406)
            if (!CanLinearizeLhs(context))
            {
                context.InputMultiset = new IdentityMultiset();
            }
            BaseMultiset lhsResult = context.Evaluate(_lhs);
            context.CheckTimeout();

            if (lhsResult is NullMultiset)
            {
                context.OutputMultiset = lhsResult;
            }
            else if (lhsResult.IsEmpty)
            {
                context.OutputMultiset = new NullMultiset();
            }
            else
            {
                // Only execute the RHS if the LHS had some results
                // Need to be careful about whether we linearize (CORE-406)
                context.InputMultiset = CanFlowResultsToRhs(context) && !IsCrossProduct ? lhsResult : new IdentityMultiset();
                BaseMultiset rhsResult = context.Evaluate(_rhs);
                context.CheckTimeout();

                context.OutputMultiset = lhsResult.LeftJoin(rhsResult, _filter.Expression);
                context.CheckTimeout();
            }

            context.InputMultiset = context.OutputMultiset;
            return context.OutputMultiset;
        }

        private bool CanLinearizeLhs(SparqlEvaluationContext context)
        {
            // Must be no floating variables already present in the results to be flowed
            return _lhs.FloatingVariables.All(v => !context.InputMultiset.ContainsVariable(v));
        }

        private bool CanFlowResultsToRhs(SparqlEvaluationContext context)
        {
            // Can't have any conflicting variables
            HashSet<String> lhsFixed = new HashSet<string>(_lhs.FixedVariables);
            HashSet<String> lhsFloating = new HashSet<string>(_lhs.FloatingVariables);
            HashSet<String> rhsFloating = new HashSet<string>(_rhs.FloatingVariables);
            HashSet<String> rhsFixed = new HashSet<string>(_rhs.FixedVariables);

            // RHS Floating can't be floating/fixed on LHS
            if (rhsFloating.Any(v => lhsFloating.Contains(v) || lhsFixed.Contains(v))) return false;
            // RHS Fixed can't be floating on LHS
            if (rhsFixed.Any(v => lhsFloating.Contains(v))) return false;

            // Otherwise OK
            return true;
        }

        private bool IsCrossProduct
        {
            get { return !_lhs.Variables.Any(v => _rhs.Variables.Contains(v)); }
        }

        /// <summary>
        /// Gets the Variables used in the Algebra.
        /// </summary>
        public IEnumerable<String> Variables
        {
            get
            {
                return (_lhs.Variables.Concat(_rhs.Variables)).Distinct();
            }
        }

        /// <summary>
        /// Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FloatingVariables
        {
            get
            {
                // Floating variables are those fixed on RHS or floating on either side and not fixed on LHS
                IEnumerable<String> floating = _lhs.FloatingVariables.Concat(_rhs.FloatingVariables).Concat(_rhs.FixedVariables).Distinct();
                HashSet<String> fixedVars = new HashSet<string>(FixedVariables);
                return floating.Where(v => !fixedVars.Contains(v));
            }
        }

        /// <summary>
        /// Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FixedVariables
        {
            get
            {
                // Fixed variables are those fixed on LHS
                return _lhs.FixedVariables;
            }
        }

        /// <summary>
        /// Gets the Filter that applies across the Join.
        /// </summary>
        public ISparqlFilter Filter
        {
            get
            {
                return _filter;
            }
        }

        /// <summary>
        /// Gets the LHS of the Join.
        /// </summary>
        public ISparqlAlgebra Lhs
        {
            get
            {
                return _lhs;
            }
        }

        /// <summary>
        /// Gets the RHS of the Join.
        /// </summary>
        public ISparqlAlgebra Rhs
        {
            get
            {
                return _rhs;
            }
        }

        /// <summary>
        /// Gets the String representation of the Algebra.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            String filter = _filter.ToString();
            filter = filter.Substring(7, filter.Length - 8);
            return "LeftJoin(" + _lhs.ToString() + ", " + _rhs.ToString() + ", " + filter + ")";
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public SparqlQuery ToQuery()
        {
            SparqlQuery q = new SparqlQuery();
            q.RootGraphPattern = ToGraphPattern();
            q.Optimise();
            return q;
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public GraphPattern ToGraphPattern()
        {
            GraphPattern p = _lhs.ToGraphPattern();
            GraphPattern opt = _rhs.ToGraphPattern();
            opt.IsOptional = true;
            if (_filter.Expression is ConstantTerm)
            {
                try
                {
                    if (!_filter.Expression.Evaluate(null, 0).AsSafeBoolean())
                    {
                        opt.Filter = _filter;
                    }
                }
                catch
                {
                    opt.Filter = _filter;
                }
            }
            else
            {
                opt.Filter = _filter;
            }
            p.AddGraphPattern(opt);
            return p;
        }

        /// <summary>
        /// Transforms both sides of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra Transform(IAlgebraOptimiser optimiser)
        {
            if (optimiser is IExpressionTransformer)
            {
                return new LeftJoin(optimiser.Optimise(_lhs), optimiser.Optimise(_rhs), new UnaryExpressionFilter(((IExpressionTransformer)optimiser).Transform(_filter.Expression)));
            }
            else
            {
                return new LeftJoin(optimiser.Optimise(_lhs), optimiser.Optimise(_rhs), _filter);
            }
        }

        /// <summary>
        /// Transforms the LHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformLhs(IAlgebraOptimiser optimiser)
        {
            if (optimiser is IExpressionTransformer)
            {
                return new LeftJoin(optimiser.Optimise(_lhs), _rhs, new UnaryExpressionFilter(((IExpressionTransformer)optimiser).Transform(_filter.Expression)));
            }
            else
            {
                return new LeftJoin(optimiser.Optimise(_lhs), _rhs, _filter);
            }
        }

        /// <summary>
        /// Transforms the RHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformRhs(IAlgebraOptimiser optimiser)
        {
            if (optimiser is IExpressionTransformer)
            {
                return new LeftJoin(_lhs, optimiser.Optimise(_rhs), new UnaryExpressionFilter(((IExpressionTransformer)optimiser).Transform(_filter.Expression)));
            }
            else
            {
                return new LeftJoin(_lhs, optimiser.Optimise(_rhs), _filter);
            }
        }
    }

    /// <summary>
    /// Represents a Join.
    /// </summary>
    public class Join 
        : IJoin
    {
        private readonly ISparqlAlgebra _lhs, _rhs;

        /// <summary>
        /// Creates a new Join.
        /// </summary>
        /// <param name="lhs">Left Hand Side.</param>
        /// <param name="rhs">Right Hand Side.</param>
        public Join(ISparqlAlgebra lhs, ISparqlAlgebra rhs)
        {
            _lhs = lhs;
            _rhs = rhs;
        }

        /// <summary>
        /// Creates either a Join or returns just one of the sides of the Join if one side is the empty BGP.
        /// </summary>
        /// <param name="lhs">Left Hand Side.</param>
        /// <param name="rhs">Right Hand Side.</param>
        /// <returns></returns>
        public static ISparqlAlgebra CreateJoin(ISparqlAlgebra lhs, ISparqlAlgebra rhs)
        {
            if (lhs is Bgp)
            {
                if (((Bgp)lhs).IsEmpty)
                {
                    return rhs;
                }
                else if (rhs is Bgp)
                {
                    if (((Bgp)rhs).IsEmpty)
                    {
                        return lhs;
                    }
                    else
                    {
                        return new Join(lhs, rhs);
                    }
                }
                else
                {
                    return new Join(lhs, rhs);
                }
            }
            else if (rhs is Bgp)
            {
                if (((Bgp)rhs).IsEmpty)
                {
                    return lhs;
                }
                else
                {
                    return new Join(lhs, rhs);
                }
            }
            else
            {
                return new Join(lhs, rhs);
            }
        }

        /// <summary>
        /// Evalutes a Join.
        /// </summary>
        /// <param name="context">Evaluation Context.</param>
        /// <returns></returns>
        public BaseMultiset Evaluate(SparqlEvaluationContext context)
        {
            BaseMultiset initialInput = context.InputMultiset;
            BaseMultiset lhsResult = context.Evaluate(_lhs);
            context.CheckTimeout();

            if (lhsResult is NullMultiset)
            {
                context.OutputMultiset = lhsResult;
            }
            else if (lhsResult.IsEmpty)
            {
                context.OutputMultiset = new NullMultiset();
            }
            else
            {
                // Only Execute the RHS if the LHS has some results
                context.InputMultiset = lhsResult;
                BaseMultiset rhsResult = context.Evaluate(_rhs);
                context.CheckTimeout();

                context.OutputMultiset = lhsResult.Join(rhsResult);
                context.CheckTimeout();
            }

            context.InputMultiset = context.OutputMultiset;
            return context.OutputMultiset;
        }

        /// <summary>
        /// Gets the Variables used in the Algebra.
        /// </summary>
        public IEnumerable<String> Variables
        {
            get
            {
                return (_lhs.Variables.Concat(_rhs.Variables)).Distinct();
            }
        }

        /// <summary>
        /// Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FloatingVariables
        {
            get
            {
                // Floating variables are those floating on either side which are not fixed
                IEnumerable<String> floating = _lhs.FloatingVariables.Concat(_rhs.FloatingVariables).Distinct();
                HashSet<String> fixedVars = new HashSet<string>(FixedVariables);
                return floating.Where(v => !fixedVars.Contains(v));
            }
        }

        /// <summary>
        /// Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FixedVariables
        {
            get
            {
                // Fixed variables are those fixed on either side
                return _lhs.FixedVariables.Concat(_rhs.FixedVariables).Distinct();
            }
        }

        /// <summary>
        /// Gets the LHS of the Join.
        /// </summary>
        public ISparqlAlgebra Lhs
        {
            get
            {
                return _lhs;
            }
        }

        /// <summary>
        /// Gets the RHS of the Join.
        /// </summary>
        public ISparqlAlgebra Rhs
        {
            get
            {
                return _rhs;
            }
        }

        /// <summary>
        /// Gets the String representation of the Join.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "Join(" + _lhs.ToString() + ", " + _rhs.ToString() + ")";
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public SparqlQuery ToQuery()
        {
            SparqlQuery q = new SparqlQuery();
            q.RootGraphPattern = ToGraphPattern();
            q.Optimise();
            return q;
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public GraphPattern ToGraphPattern()
        {
            GraphPattern p = _lhs.ToGraphPattern();
            p.AddGraphPattern(_rhs.ToGraphPattern());
            return p;
        }

        /// <summary>
        /// Transforms both sides of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra Transform(IAlgebraOptimiser optimiser)
        {
            return new Join(optimiser.Optimise(_lhs), optimiser.Optimise(_rhs));
        }

        /// <summary>
        /// Transforms the LHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformLhs(IAlgebraOptimiser optimiser)
        {
            return new Join(optimiser.Optimise(_lhs), _rhs);
        }

        /// <summary>
        /// Transforms the RHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformRhs(IAlgebraOptimiser optimiser)
        {
            return new Join(_lhs, optimiser.Optimise(_rhs));
        }
    }

    /// <summary>
    /// Represents a Union.
    /// </summary>
    public class Union 
        : IUnion
    {
        private readonly ISparqlAlgebra _lhs, _rhs;

        /// <summary>
        /// Creates a new Union.
        /// </summary>
        /// <param name="lhs">LHS Pattern.</param>
        /// <param name="rhs">RHS Pattern.</param>
        public Union(ISparqlAlgebra lhs, ISparqlAlgebra rhs)
        {
            _lhs = lhs;
            _rhs = rhs;
        }

        /// <summary>
        /// Evaluates the Union.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public BaseMultiset Evaluate(SparqlEvaluationContext context)
        {
            BaseMultiset initialInput = context.InputMultiset;
            if (_lhs is Extend || _rhs is Extend) initialInput = new IdentityMultiset();

            context.InputMultiset = initialInput;
            BaseMultiset lhsResult = context.Evaluate(_lhs);
            context.CheckTimeout();

            context.InputMultiset = initialInput;
            BaseMultiset rhsResult = context.Evaluate(_rhs);
            context.CheckTimeout();

            context.OutputMultiset = lhsResult.Union(rhsResult);
            context.CheckTimeout();

            context.InputMultiset = context.OutputMultiset;
            return context.OutputMultiset;
        }

        /// <summary>
        /// Gets the Variables used in the Algebra.
        /// </summary>
        public IEnumerable<String> Variables
        {
            get
            {
                return (_lhs.Variables.Concat(_rhs.Variables)).Distinct();
            }
        }

        /// <summary>
        /// Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FloatingVariables
        {
            get
            {
                // Floating variables are those not fixed
                HashSet<String> fixedVars = new HashSet<string>(FixedVariables);
                return Variables.Where(v => !fixedVars.Contains(v));
            }
        }

        /// <summary>
        /// Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FixedVariables
        {
            get
            {
                // Fixed variables are those fixed on both sides
                return _lhs.FixedVariables.Intersect(_rhs.FixedVariables);
            }
        }

        /// <summary>
        /// Gets the LHS of the Join.
        /// </summary>
        public ISparqlAlgebra Lhs
        {
            get
            {
                return _lhs;
            }
        }

        /// <summary>
        /// Gets the RHS of the Join.
        /// </summary>
        public ISparqlAlgebra Rhs
        {
            get
            {
                return _rhs;
            }
        }

        /// <summary>
        /// Gets the String representation of the Algebra.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "Union(" + _lhs.ToString() + ", " + _rhs.ToString() + ")";
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public SparqlQuery ToQuery()
        {
            SparqlQuery q = new SparqlQuery();
            q.RootGraphPattern = ToGraphPattern();
            q.Optimise();
            return q;
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public GraphPattern ToGraphPattern()
        {
            GraphPattern p = new GraphPattern();
            p.IsUnion = true;
            p.AddGraphPattern(_lhs.ToGraphPattern());
            p.AddGraphPattern(_rhs.ToGraphPattern());
            return p;
        }

        /// <summary>
        /// Transforms both sides of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra Transform(IAlgebraOptimiser optimiser)
        {
            return new Union(optimiser.Optimise(_lhs), optimiser.Optimise(_rhs));
        }

        /// <summary>
        /// Transforms the LHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformLhs(IAlgebraOptimiser optimiser)
        {
            return new Union(optimiser.Optimise(_lhs), _rhs);
        }

        /// <summary>
        /// Transforms the RHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformRhs(IAlgebraOptimiser optimiser)
        {
            return new Union(_lhs, optimiser.Optimise(_rhs));
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using VDS.RDF.Nodes;
using VDS.RDF.Query.Expressions;
using VDS.RDF.Query.Expressions.Primary;
using VDS.RDF.Query.Filters;
using VDS.RDF.Query.Optimisation;
using VDS.RDF.Query.Patterns;

namespace VDS.RDF.Query.Algebra
{
    /// <summary>
    /// Represents a LeftJoin predicated on the existence/non-existence of joinable sets on the RHS for each item on the LHS.
    /// </summary>
    public class ExistsJoin 
        : IExistsJoin
    {
        private readonly ISparqlAlgebra _lhs, _rhs;
        private readonly bool _mustExist;

        /// <summary>
        /// Creates a new Exists Join.
        /// </summary>
        /// <param name="lhs">LHS Pattern.</param>
        /// <param name="rhs">RHS Pattern.</param>
        /// <param name="mustExist">Whether a joinable set must exist on the RHS for the LHS set to be preserved.</param>
        public ExistsJoin(ISparqlAlgebra lhs, ISparqlAlgebra rhs, bool mustExist)
        {
            _lhs = lhs;
            _rhs = rhs;
            _mustExist = mustExist;
        }

        /// <summary>
        /// Evaluates an ExistsJoin.
        /// </summary>
        /// <param name="context">Evaluation Context.</param>
        /// <returns></returns>
        public BaseMultiset Evaluate(SparqlEvaluationContext context)
        {
            BaseMultiset initialInput = context.InputMultiset;
            BaseMultiset lhsResult = context.Evaluate(_lhs);//this._lhs.Evaluate(context);
            context.CheckTimeout();

            if (lhsResult is NullMultiset)
            {
                context.OutputMultiset = lhsResult;
            }
            else if (lhsResult.IsEmpty)
            {
                context.OutputMultiset = new NullMultiset();
            }
            else
            {
                // Only execute the RHS if the LHS had results
                context.InputMultiset = lhsResult;
                BaseMultiset rhsResult = context.Evaluate(_rhs);//this._rhs.Evaluate(context);
                context.CheckTimeout();

                context.OutputMultiset = lhsResult.ExistsJoin(rhsResult, _mustExist);
                context.CheckTimeout();
            }

            context.InputMultiset = context.OutputMultiset;
            return context.OutputMultiset;
        }

        /// <summary>
        /// Gets the Variables used in the Algebra.
        /// </summary>
        public IEnumerable<String> Variables
        {
            get
            {
                return (_lhs.Variables.Concat(_rhs.Variables)).Distinct();
            }
        }

        /// <summary>
        /// Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FloatingVariables
        {
            get { return _lhs.FloatingVariables; }
        }

        /// <summary>
        /// Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FixedVariables
        {
            get { return _lhs.FixedVariables; }
        }

        /// <summary>
        /// Gets the LHS of the Join.
        /// </summary>
        public ISparqlAlgebra Lhs
        {
            get
            {
                return _lhs;
            }
        }

        /// <summary>
        /// Gets the RHS of the Join.
        /// </summary>
        public ISparqlAlgebra Rhs
        {
            get
            {
                return _rhs;
            }
        }

        /// <summary>
        /// Gets whether this is an EXISTS join.
        /// </summary>
        public bool MustExist
        {
            get
            {
                return _mustExist;
            }
        }

        /// <summary>
        /// Gets the String representation of the Algebra.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "ExistsJoin(" + _lhs.ToString() + ", " + _rhs.ToString() + ", " + _mustExist + ")";
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public SparqlQuery ToQuery()
        {
            SparqlQuery q = new SparqlQuery();
            q.RootGraphPattern = ToGraphPattern();
            q.Optimise();
            return q;
        }

        /// <summary>
        /// Converts the Algebra back to a Graph Pattern.
        /// </summary>
        /// <returns></returns>
        public GraphPattern ToGraphPattern()
        {
            GraphPattern p = _lhs.ToGraphPattern();
            GraphPattern opt = _rhs.ToGraphPattern();
            if (_mustExist)
            {
                opt.IsExists = true;
            }
            else
            {
                opt.IsNotExists = true;
            }
            p.AddGraphPattern(opt);
            return p;
        }

        /// <summary>
        /// Transforms both sides of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra Transform(IAlgebraOptimiser optimiser)
        {
            return new ExistsJoin(optimiser.Optimise(_lhs), optimiser.Optimise(_rhs), _mustExist);
        }

        /// <summary>
        /// Transforms the LHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformLhs(IAlgebraOptimiser optimiser)
        {
            return new ExistsJoin(optimiser.Optimise(_lhs), _rhs, _mustExist);
        }

        /// <summary>
        /// Transforms the RHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformRhs(IAlgebraOptimiser optimiser)
        {
            return new ExistsJoin(_lhs, optimiser.Optimise(_rhs), _mustExist);
        }
    }

    /// <summary>
    /// Represents a LeftJoin predicated on an arbitrary filter expression.
    /// </summary>
    public class LeftJoin 
        : ILeftJoin
    {
        private readonly ISparqlAlgebra _lhs, _rhs;
        private readonly ISparqlFilter _filter = new UnaryExpressionFilter(new ConstantTerm(new BooleanNode(null, true)));

        /// <summary>
        /// Creates a new LeftJoin where there is no Filter over the join.
        /// </summary>
        /// <param name="lhs">LHS Pattern.</param>
        /// <param name="rhs">RHS Pattern.</param>
        public LeftJoin(ISparqlAlgebra lhs, ISparqlAlgebra rhs)
        {
            _lhs = lhs;
            _rhs = rhs;
        }

        /// <summary>
        /// Creates a new LeftJoin where there is a Filter over the join.
        /// </summary>
        /// <param name="lhs">LHS Pattern.</param>
        /// <param name="rhs">RHS Pattern.</param>
        /// <param name="filter">Filter to decide which RHS solutions are valid.</param>
        public LeftJoin(ISparqlAlgebra lhs, ISparqlAlgebra rhs, ISparqlFilter filter)
            : this(lhs, rhs)
        {
            _filter = filter;
        }

        /// <summary>
        /// Evaluates the LeftJoin.
        /// </summary>
        /// <param name="context">Evaluation Context.</param>
        /// <returns></returns>
        public BaseMultiset Evaluate(SparqlEvaluationContext context)
        {
            // Need to be careful about whether we linearize (CORE-406)
            if (!CanLinearizeLhs(context))
            {
                context.InputMultiset = new IdentityMultiset();
            }
            BaseMultiset lhsResult = context.Evaluate(_lhs);
            context.CheckTimeout();

            if (lhsResult is NullMultiset)
            {
                context.OutputMultiset = lhsResult;
            }
            else if (lhsResult.IsEmpty)
            {
                context.OutputMultiset = new NullMultiset();
            }
            else
            {
                // Only execute the RHS if the LHS had some results
                // Need to be careful about whether we linearize (CORE-406)
                context.InputMultiset = CanFlowResultsToRhs(context) && !IsCrossProduct ? lhsResult : new IdentityMultiset();
                BaseMultiset rhsResult = context.Evaluate(_rhs);
                context.CheckTimeout();

                context.OutputMultiset = lhsResult.LeftJoin(rhsResult, _filter.Expression);
                context.CheckTimeout();
            }

            context.InputMultiset = context.OutputMultiset;
            return context.OutputMultiset;
        }

        private bool CanLinearizeLhs(SparqlEvaluationContext context)
        {
            // Must be no floating variables already present in the results to be flowed
            return _lhs.FloatingVariables.All(v => !context.InputMultiset.ContainsVariable(v));
        }

        private bool CanFlowResultsToRhs(SparqlEvaluationContext context)
        {
            // Can't have any conflicting variables
            HashSet<String> lhsFixed = new HashSet<string>(_lhs.FixedVariables);
            HashSet<String> lhsFloating = new HashSet<string>(_lhs.FloatingVariables);
            HashSet<String> rhsFloating = new HashSet<string>(_rhs.FloatingVariables);
            HashSet<String> rhsFixed = new HashSet<string>(_rhs.FixedVariables);

            // RHS Floating can't be floating/fixed on LHS
            if (rhsFloating.Any(v => lhsFloating.Contains(v) || lhsFixed.Contains(v))) return false;
            // RHS Fixed can't be floating on LHS
            if (rhsFixed.Any(v => lhsFloating.Contains(v))) return false;

            // Otherwise OK
            return true;
        }

        private bool IsCrossProduct
        {
            get { return !_lhs.Variables.Any(v => _rhs.Variables.Contains(v)); }
        }

        /// <summary>
        /// Gets the Variables used in the Algebra.
        /// </summary>
        public IEnumerable<String> Variables
        {
            get
            {
                return (_lhs.Variables.Concat(_rhs.Variables)).Distinct();
            }
        }

        /// <summary>
        /// Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FloatingVariables
        {
            get
            {
                // Floating variables are those fixed on RHS or floating on either side and not fixed on LHS
                IEnumerable<String> floating = _lhs.FloatingVariables.Concat(_rhs.FloatingVariables).Concat(_rhs.FixedVariables).Distinct();
                HashSet<String> fixedVars = new HashSet<string>(FixedVariables);
                return floating.Where(v => !fixedVars.Contains(v));
            }
        }

        /// <summary>
        /// Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FixedVariables
        {
            get
            {
                // Fixed variables are those fixed on LHS
                return _lhs.FixedVariables;
            }
        }

        /// <summary>
        /// Gets the Filter that applies across the Join.
        /// </summary>
        public ISparqlFilter Filter
        {
            get
            {
                return _filter;
            }
        }

        /// <summary>
        /// Gets the LHS of the Join.
        /// </summary>
        public ISparqlAlgebra Lhs
        {
            get
            {
                return _lhs;
            }
        }

        /// <summary>
        /// Gets the RHS of the Join.
        /// </summary>
        public ISparqlAlgebra Rhs
        {
            get
            {
                return _rhs;
            }
        }

        /// <summary>
        /// Gets the String representation of the Algebra.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            String filter = _filter.ToString();
            filter = filter.Substring(7, filter.Length - 8);
            return "LeftJoin(" + _lhs.ToString() + ", " + _rhs.ToString() + ", " + filter + ")";
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public SparqlQuery ToQuery()
        {
            SparqlQuery q = new SparqlQuery();
            q.RootGraphPattern = ToGraphPattern();
            q.Optimise();
            return q;
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public GraphPattern ToGraphPattern()
        {
            GraphPattern p = _lhs.ToGraphPattern();
            GraphPattern opt = _rhs.ToGraphPattern();
            opt.IsOptional = true;
            if (_filter.Expression is ConstantTerm)
            {
                try
                {
                    if (!_filter.Expression.Evaluate(null, 0).AsSafeBoolean())
                    {
                        opt.Filter = _filter;
                    }
                }
                catch
                {
                    opt.Filter = _filter;
                }
            }
            else
            {
                opt.Filter = _filter;
            }
            p.AddGraphPattern(opt);
            return p;
        }

        /// <summary>
        /// Transforms both sides of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra Transform(IAlgebraOptimiser optimiser)
        {
            if (optimiser is IExpressionTransformer iExpressionTransformer)
            {
                return new LeftJoin(optimiser.Optimise(_lhs), optimiser.Optimise(_rhs), new UnaryExpressionFilter(iExpressionTransformer.Transform(_filter.Expression)));
            }
            else
            {
                return new LeftJoin(optimiser.Optimise(_lhs), optimiser.Optimise(_rhs), _filter);
            }
        }

        /// <summary>
        /// Transforms the LHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformLhs(IAlgebraOptimiser optimiser)
        {
            if (optimiser is IExpressionTransformer iExpressionTransformer)
            {
                return new LeftJoin(optimiser.Optimise(_lhs), _rhs, new UnaryExpressionFilter(iExpressionTransformer.Transform(_filter.Expression)));
            }
            else
            {
                return new LeftJoin(optimiser.Optimise(_lhs), _rhs, _filter);
            }
        }

        /// <summary>
        /// Transforms the RHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformRhs(IAlgebraOptimiser optimiser)
        {
            if (optimiser is IExpressionTransformer iExpressionTransformer)
            {
                return new LeftJoin(_lhs, optimiser.Optimise(_rhs), new UnaryExpressionFilter(iExpressionTransformer.Transform(_filter.Expression)));
            }
            else
            {
                return new LeftJoin(_lhs, optimiser.Optimise(_rhs), _filter);
            }
        }
    }

    /// <summary>
    /// Represents a Join.
    /// </summary>
    public class Join 
        : IJoin
    {
        private readonly ISparqlAlgebra _lhs, _rhs;

        /// <summary>
        /// Creates a new Join.
        /// </summary>
        /// <param name="lhs">Left Hand Side.</param>
        /// <param name="rhs">Right Hand Side.</param>
        public Join(ISparqlAlgebra lhs, ISparqlAlgebra rhs)
        {
            _lhs = lhs;
            _rhs = rhs;
        }

        /// <summary>
        /// Creates either a Join or returns just one of the sides of the Join if one side is the empty BGP.
        /// </summary>
        /// <param name="lhs">Left Hand Side.</param>
        /// <param name="rhs">Right Hand Side.</param>
        /// <returns></returns>
        public static ISparqlAlgebra CreateJoin(ISparqlAlgebra lhs, ISparqlAlgebra rhs)
        {
            if (lhs is Bgp bgp)
            {
                if (bgp.IsEmpty)
                {
                    return rhs;
                }
                else if (rhs is Bgp bgp)
                {
                    if (bgp.IsEmpty)
                    {
                        return lhs;
                    }
                    else
                    {
                        return new Join(lhs, rhs);
                    }
                }
                else
                {
                    return new Join(lhs, rhs);
                }
            }
            else if (rhs is Bgp bgp)
            {
                if (bgp.IsEmpty)
                {
                    return lhs;
                }
                else
                {
                    return new Join(lhs, rhs);
                }
            }
            else
            {
                return new Join(lhs, rhs);
            }
        }

        /// <summary>
        /// Evalutes a Join.
        /// </summary>
        /// <param name="context">Evaluation Context.</param>
        /// <returns></returns>
        public BaseMultiset Evaluate(SparqlEvaluationContext context)
        {
            BaseMultiset initialInput = context.InputMultiset;
            BaseMultiset lhsResult = context.Evaluate(_lhs);
            context.CheckTimeout();

            if (lhsResult is NullMultiset)
            {
                context.OutputMultiset = lhsResult;
            }
            else if (lhsResult.IsEmpty)
            {
                context.OutputMultiset = new NullMultiset();
            }
            else
            {
                // Only Execute the RHS if the LHS has some results
                context.InputMultiset = lhsResult;
                BaseMultiset rhsResult = context.Evaluate(_rhs);
                context.CheckTimeout();

                context.OutputMultiset = lhsResult.Join(rhsResult);
                context.CheckTimeout();
            }

            context.InputMultiset = context.OutputMultiset;
            return context.OutputMultiset;
        }

        /// <summary>
        /// Gets the Variables used in the Algebra.
        /// </summary>
        public IEnumerable<String> Variables
        {
            get
            {
                return (_lhs.Variables.Concat(_rhs.Variables)).Distinct();
            }
        }

        /// <summary>
        /// Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FloatingVariables
        {
            get
            {
                // Floating variables are those floating on either side which are not fixed
                IEnumerable<String> floating = _lhs.FloatingVariables.Concat(_rhs.FloatingVariables).Distinct();
                HashSet<String> fixedVars = new HashSet<string>(FixedVariables);
                return floating.Where(v => !fixedVars.Contains(v));
            }
        }

        /// <summary>
        /// Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FixedVariables
        {
            get
            {
                // Fixed variables are those fixed on either side
                return _lhs.FixedVariables.Concat(_rhs.FixedVariables).Distinct();
            }
        }

        /// <summary>
        /// Gets the LHS of the Join.
        /// </summary>
        public ISparqlAlgebra Lhs
        {
            get
            {
                return _lhs;
            }
        }

        /// <summary>
        /// Gets the RHS of the Join.
        /// </summary>
        public ISparqlAlgebra Rhs
        {
            get
            {
                return _rhs;
            }
        }

        /// <summary>
        /// Gets the String representation of the Join.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "Join(" + _lhs.ToString() + ", " + _rhs.ToString() + ")";
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public SparqlQuery ToQuery()
        {
            SparqlQuery q = new SparqlQuery();
            q.RootGraphPattern = ToGraphPattern();
            q.Optimise();
            return q;
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public GraphPattern ToGraphPattern()
        {
            GraphPattern p = _lhs.ToGraphPattern();
            p.AddGraphPattern(_rhs.ToGraphPattern());
            return p;
        }

        /// <summary>
        /// Transforms both sides of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra Transform(IAlgebraOptimiser optimiser)
        {
            return new Join(optimiser.Optimise(_lhs), optimiser.Optimise(_rhs));
        }

        /// <summary>
        /// Transforms the LHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformLhs(IAlgebraOptimiser optimiser)
        {
            return new Join(optimiser.Optimise(_lhs), _rhs);
        }

        /// <summary>
        /// Transforms the RHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformRhs(IAlgebraOptimiser optimiser)
        {
            return new Join(_lhs, optimiser.Optimise(_rhs));
        }
    }

    /// <summary>
    /// Represents a Union.
    /// </summary>
    public class Union 
        : IUnion
    {
        private readonly ISparqlAlgebra _lhs, _rhs;

        /// <summary>
        /// Creates a new Union.
        /// </summary>
        /// <param name="lhs">LHS Pattern.</param>
        /// <param name="rhs">RHS Pattern.</param>
        public Union(ISparqlAlgebra lhs, ISparqlAlgebra rhs)
        {
            _lhs = lhs;
            _rhs = rhs;
        }

        /// <summary>
        /// Evaluates the Union.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        public BaseMultiset Evaluate(SparqlEvaluationContext context)
        {
            BaseMultiset initialInput = context.InputMultiset;
            if (_lhs is Extend || _rhs is Extend) initialInput = new IdentityMultiset();

            context.InputMultiset = initialInput;
            BaseMultiset lhsResult = context.Evaluate(_lhs);
            context.CheckTimeout();

            context.InputMultiset = initialInput;
            BaseMultiset rhsResult = context.Evaluate(_rhs);
            context.CheckTimeout();

            context.OutputMultiset = lhsResult.Union(rhsResult);
            context.CheckTimeout();

            context.InputMultiset = context.OutputMultiset;
            return context.OutputMultiset;
        }

        /// <summary>
        /// Gets the Variables used in the Algebra.
        /// </summary>
        public IEnumerable<String> Variables
        {
            get
            {
                return (_lhs.Variables.Concat(_rhs.Variables)).Distinct();
            }
        }

        /// <summary>
        /// Gets the enumeration of floating variables in the algebra i.e. variables that are not guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FloatingVariables
        {
            get
            {
                // Floating variables are those not fixed
                HashSet<String> fixedVars = new HashSet<string>(FixedVariables);
                return Variables.Where(v => !fixedVars.Contains(v));
            }
        }

        /// <summary>
        /// Gets the enumeration of fixed variables in the algebra i.e. variables that are guaranteed to have a bound value.
        /// </summary>
        public IEnumerable<String> FixedVariables
        {
            get
            {
                // Fixed variables are those fixed on both sides
                return _lhs.FixedVariables.Intersect(_rhs.FixedVariables);
            }
        }

        /// <summary>
        /// Gets the LHS of the Join.
        /// </summary>
        public ISparqlAlgebra Lhs
        {
            get
            {
                return _lhs;
            }
        }

        /// <summary>
        /// Gets the RHS of the Join.
        /// </summary>
        public ISparqlAlgebra Rhs
        {
            get
            {
                return _rhs;
            }
        }

        /// <summary>
        /// Gets the String representation of the Algebra.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return "Union(" + _lhs.ToString() + ", " + _rhs.ToString() + ")";
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public SparqlQuery ToQuery()
        {
            SparqlQuery q = new SparqlQuery();
            q.RootGraphPattern = ToGraphPattern();
            q.Optimise();
            return q;
        }

        /// <summary>
        /// Converts the Algebra back to a SPARQL Query.
        /// </summary>
        /// <returns></returns>
        public GraphPattern ToGraphPattern()
        {
            GraphPattern p = new GraphPattern();
            p.IsUnion = true;
            p.AddGraphPattern(_lhs.ToGraphPattern());
            p.AddGraphPattern(_rhs.ToGraphPattern());
            return p;
        }

        /// <summary>
        /// Transforms both sides of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra Transform(IAlgebraOptimiser optimiser)
        {
            return new Union(optimiser.Optimise(_lhs), optimiser.Optimise(_rhs));
        }

        /// <summary>
        /// Transforms the LHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformLhs(IAlgebraOptimiser optimiser)
        {
            return new Union(optimiser.Optimise(_lhs), _rhs);
        }

        /// <summary>
        /// Transforms the RHS of the Join using the given Optimiser.
        /// </summary>
        /// <param name="optimiser">Optimser.</param>
        /// <returns></returns>
        public ISparqlAlgebra TransformRhs(IAlgebraOptimiser optimiser)
        {
            return new Union(_lhs, optimiser.Optimise(_rhs));
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\AlgebraJoinClasses.cs(535,37): error CS0136: A local or parameter named 'bgp' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Libraries\dotNetRDF\Query\Algebra\AlgebraJoinClasses.cs(551,33): error CS0136: A local or parameter named 'bgp' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 6 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\BgpOptimisers.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using VDS.RDF.Query.Algebra;
using VDS.RDF.Update;

namespace VDS.RDF.Query.Optimisation
{
    /// <summary>
    /// An Algebra Optimiser that optimises Algebra to use <see cref="LazyBgp">LazyBgp</see>'s wherever possible.
    /// </summary>
    public class LazyBgpOptimiser 
        : BaseAlgebraOptimiser
    {
        /// <summary>
        /// Optimises an Algebra to a form that uses <see cref="LazyBgp">LazyBgp</see> where possible.
        /// </summary>
        /// <param name="algebra">Algebra.</param>
        /// <param name="depth">Depth.</param>
        /// <returns></returns>
        /// <remarks>
        /// <para>
        /// By transforming a query to use <see cref="LazyBgp">LazyBgp</see> we can achieve much more efficient processing of some forms of queries.
        /// </para>
        /// </remarks>
        protected override ISparqlAlgebra OptimiseInternal(ISparqlAlgebra algebra, int depth)
        {
            try
            {
                ISparqlAlgebra temp;

                // Note this first test is specifically for the default BGP implementation since other optimisers
                // may run before us and replace with other BGP implementations which we don't want to replace hence
                // why we don't check for IBgp here
                if (algebra is Bgp)
                {
                    temp = new LazyBgp(((Bgp)algebra).TriplePatterns);
                }
                else if (algebra is IUnion)
                {
                    IUnion join = (IUnion)algebra;
                    temp = new LazyUnion(OptimiseInternal(join.Lhs, depth + 1), OptimiseInternal(join.Rhs, depth + 1));
                }
                else if (algebra is IJoin)
                {
                    IJoin join = (IJoin)algebra;
                    if (join.Lhs.Variables.IsDisjoint(join.Rhs.Variables))
                    {
                        // If the sides of the Join are disjoint then can fully transform the join since we only need to find the requisite number of
                        // solutions on either side to guarantee a product which meets/exceeds the required results
                        temp = join.Transform(this);
                    }
                    else
                    {
                        // If the sides are not disjoint then the LHS must be fully evaluated but the RHS need only produce enough
                        // solutions that match
                        temp = join.TransformRhs(this);
                    }
                }
                else if (algebra is Algebra.Graph || algebra is Select || algebra is Slice || algebra is OrderBy)
                {
                    IUnaryOperator op = (IUnaryOperator)algebra;
                    temp = op.Transform(this);
                }
                else
                {
                    temp = algebra;
                }
                return temp;
            }
            catch
            {
                // If the Optimise fails return the current algebra
                return algebra;
            }
        }

        /// <summary>
        /// Determines whether the query can be optimised for lazy evaluation.
        /// </summary>
        /// <param name="q">Query.</param>
        /// <returns></returns>
        public override bool IsApplicable(SparqlQuery q)
        {
            return q.Limit > 0
                   && !q.HasDistinctModifier
                   && (q.OrderBy == null || q.IsOptimisableOrderBy)
                   && q.GroupBy == null && q.Having == null
                   && !q.IsAggregate
                   && q.Bindings == null;
        }

        /// <summary>
        /// Returns that the optimiser does not apply to SPARQL Updates.
        /// </summary>
        /// <param name="cmds">Updates.</param>
        /// <returns></returns>
        public override bool IsApplicable(SparqlUpdateCommandSet cmds)
        {
            return false;
        }
    }

    /// <summary>
    /// An Algebra Optimiser that optimises Algebra to use <see cref="AskBgp">AskBgp</see>'s wherever possible.
    /// </summary>
    public class AskBgpOptimiser
        : BaseAlgebraOptimiser
    {
        /// <summary>
        /// Optimises an Algebra to a form that uses <see cref="AskBgp">AskBgp</see> where possible.
        /// </summary>
        /// <param name="algebra">Algebra.</param>
        /// <param name="depth">Depth.</param>
        /// <returns></returns>
        /// <remarks>
        /// <para>
        /// By transforming a query to use <see cref="AskBgp">AskBgp</see> we can achieve much more efficient processing of some forms of queries.
        /// </para>
        /// </remarks>
        protected override ISparqlAlgebra OptimiseInternal(ISparqlAlgebra algebra, int depth)
        {
            try
            {
                ISparqlAlgebra temp;
                if (algebra is Bgp)
                {
                    // Bgp is transformed into AskBgp
                    // This tries to find 1 possible solution
                    temp = new AskBgp(((Bgp)algebra).TriplePatterns);
                }
                else if (algebra is ILeftJoin)
                {
                    // LeftJoin is transformed to just be the LHS as the RHS is irrelevant for ASK queries
                    // UNLESS the LeftJoin occurs inside a Filter/Minus BUT we should never get called to transform a 
                    // LeftJoin() for those branches of the algebra as the Optimiseer does not transform 
                    // Filter()/Minus() operators
                    temp = OptimiseInternal(((ILeftJoin)algebra).Lhs, depth + 1);
                }
                else if (algebra is IUnion)
                {
                    IUnion join = (IUnion)algebra;
                    temp = new AskUnion(OptimiseInternal(join.Lhs, depth + 1), OptimiseInternal(join.Rhs, depth + 1));
                }
                else if (algebra is IJoin)
                {
                    IJoin join = (IJoin)algebra;
                    if (join.Lhs.Variables.IsDisjoint(join.Rhs.Variables))
                    {
                        // If the sides of the Join are disjoint then can fully transform the join since we only need to find at least
                        // one solution on either side in order for the query to match
                        // temp = new Join(this.OptimiseInternal(join.Lhs, depth + 1), this.OptimiseInternal(join.Rhs, depth + 1));
                        temp = join.Transform(this);
                    } 
                    else 
                    {
                        // If the sides are not disjoint then the LHS must be fully evaluated but the RHS need only produce at least
                        // one solution based on the full input from the LHS for the query to match
                        // temp = new Join(join.Lhs, this.OptimiseInternal(join.Rhs, depth + 1));
                        temp = join.TransformRhs(this);
                    }
                }
                else if (algebra is Algebra.Graph)
                {
                    // Algebra.Graph g = (Algebra.Graph)algebra;
                    // temp = new Algebra.Graph(this.OptimiseInternal(g.InnerAlgebra, depth + 1), g.GraphSpecifier);
                    IUnaryOperator op = (IUnaryOperator)algebra;
                    temp = op.Transform(this);
                }
                else
                {
                    temp = algebra;
                }
                return temp;
            }
            catch
            {
                // If the Optimise fails return the current algebra
                return algebra;
            }
        }

        /// <summary>
        /// Determines whether the query can be optimised for ASK evaluation.
        /// </summary>
        /// <param name="q">Query.</param>
        /// <returns></returns>
        public override bool IsApplicable(SparqlQuery q)
        {
            return q.QueryType == SparqlQueryType.Ask && !q.HasSolutionModifier;
        }

        /// <summary>
        /// Returns that the optimiser does not apply to SPARQL Updates.
        /// </summary>
        /// <param name="cmds">Updates.</param>
        /// <returns></returns>
        public override bool IsApplicable(SparqlUpdateCommandSet cmds)
        {
            return false;
        }
    }
}

---- Transformed Tree ----
using VDS.RDF.Query.Algebra;
using VDS.RDF.Update;

namespace VDS.RDF.Query.Optimisation
{
    /// <summary>
    /// An Algebra Optimiser that optimises Algebra to use <see cref="LazyBgp">LazyBgp</see>'s wherever possible.
    /// </summary>
    public class LazyBgpOptimiser 
        : BaseAlgebraOptimiser
    {
        /// <summary>
        /// Optimises an Algebra to a form that uses <see cref="LazyBgp">LazyBgp</see> where possible.
        /// </summary>
        /// <param name="algebra">Algebra.</param>
        /// <param name="depth">Depth.</param>
        /// <returns></returns>
        /// <remarks>
        /// <para>
        /// By transforming a query to use <see cref="LazyBgp">LazyBgp</see> we can achieve much more efficient processing of some forms of queries.
        /// </para>
        /// </remarks>
        protected override ISparqlAlgebra OptimiseInternal(ISparqlAlgebra algebra, int depth)
        {
            try
            {
                ISparqlAlgebra temp;

                // Note this first test is specifically for the default BGP implementation since other optimisers
                // may run before us and replace with other BGP implementations which we don't want to replace hence
                // why we don't check for IBgp here
                if (algebra is Bgp bgp)
                {
                    temp = new LazyBgp(bgp.TriplePatterns);
                }
                else if (algebra is IUnion join)
                {
                    temp = new LazyUnion(OptimiseInternal(join.Lhs, depth + 1), OptimiseInternal(join.Rhs, depth + 1));
                }
                else if (algebra is IJoin join)
                {
                    if (join.Lhs.Variables.IsDisjoint(join.Rhs.Variables))
                    {
                        // If the sides of the Join are disjoint then can fully transform the join since we only need to find the requisite number of
                        // solutions on either side to guarantee a product which meets/exceeds the required results
                        temp = join.Transform(this);
                    }
                    else
                    {
                        // If the sides are not disjoint then the LHS must be fully evaluated but the RHS need only produce enough
                        // solutions that match
                        temp = join.TransformRhs(this);
                    }
                }
                else if (algebra is Algebra.Graph || algebra is Select || algebra is Slice || algebra is OrderBy)
                {
                    IUnaryOperator op = (IUnaryOperator)algebra;
                    temp = op.Transform(this);
                }
                else
                {
                    temp = algebra;
                }
                return temp;
            }
            catch
            {
                // If the Optimise fails return the current algebra
                return algebra;
            }
        }

        /// <summary>
        /// Determines whether the query can be optimised for lazy evaluation.
        /// </summary>
        /// <param name="q">Query.</param>
        /// <returns></returns>
        public override bool IsApplicable(SparqlQuery q)
        {
            return q.Limit > 0
                   && !q.HasDistinctModifier
                   && (q.OrderBy == null || q.IsOptimisableOrderBy)
                   && q.GroupBy == null && q.Having == null
                   && !q.IsAggregate
                   && q.Bindings == null;
        }

        /// <summary>
        /// Returns that the optimiser does not apply to SPARQL Updates.
        /// </summary>
        /// <param name="cmds">Updates.</param>
        /// <returns></returns>
        public override bool IsApplicable(SparqlUpdateCommandSet cmds)
        {
            return false;
        }
    }

    /// <summary>
    /// An Algebra Optimiser that optimises Algebra to use <see cref="AskBgp">AskBgp</see>'s wherever possible.
    /// </summary>
    public class AskBgpOptimiser
        : BaseAlgebraOptimiser
    {
        /// <summary>
        /// Optimises an Algebra to a form that uses <see cref="AskBgp">AskBgp</see> where possible.
        /// </summary>
        /// <param name="algebra">Algebra.</param>
        /// <param name="depth">Depth.</param>
        /// <returns></returns>
        /// <remarks>
        /// <para>
        /// By transforming a query to use <see cref="AskBgp">AskBgp</see> we can achieve much more efficient processing of some forms of queries.
        /// </para>
        /// </remarks>
        protected override ISparqlAlgebra OptimiseInternal(ISparqlAlgebra algebra, int depth)
        {
            try
            {
                ISparqlAlgebra temp;
                if (algebra is Bgp bgp)
                {
                    // Bgp is transformed into AskBgp
                    // This tries to find 1 possible solution
                    temp = new AskBgp(bgp.TriplePatterns);
                }
                else if (algebra is ILeftJoin iLeftJoin)
                {
                    // LeftJoin is transformed to just be the LHS as the RHS is irrelevant for ASK queries
                    // UNLESS the LeftJoin occurs inside a Filter/Minus BUT we should never get called to transform a 
                    // LeftJoin() for those branches of the algebra as the Optimiseer does not transform 
                    // Filter()/Minus() operators
                    temp = OptimiseInternal(iLeftJoin.Lhs, depth + 1);
                }
                else if (algebra is IUnion join)
                {
                    temp = new AskUnion(OptimiseInternal(join.Lhs, depth + 1), OptimiseInternal(join.Rhs, depth + 1));
                }
                else if (algebra is IJoin join)
                {
                    if (join.Lhs.Variables.IsDisjoint(join.Rhs.Variables))
                    {
                        // If the sides of the Join are disjoint then can fully transform the join since we only need to find at least
                        // one solution on either side in order for the query to match
                        // temp = new Join(this.OptimiseInternal(join.Lhs, depth + 1), this.OptimiseInternal(join.Rhs, depth + 1));
                        temp = join.Transform(this);
                    } 
                    else 
                    {
                        // If the sides are not disjoint then the LHS must be fully evaluated but the RHS need only produce at least
                        // one solution based on the full input from the LHS for the query to match
                        // temp = new Join(join.Lhs, this.OptimiseInternal(join.Rhs, depth + 1));
                        temp = join.TransformRhs(this);
                    }
                }
                else if (algebra is Algebra.Graph)
                {
                    // Algebra.Graph g = (Algebra.Graph)algebra;
                    // temp = new Algebra.Graph(this.OptimiseInternal(g.InnerAlgebra, depth + 1), g.GraphSpecifier);
                    IUnaryOperator op = (IUnaryOperator)algebra;
                    temp = op.Transform(this);
                }
                else
                {
                    temp = algebra;
                }
                return temp;
            }
            catch
            {
                // If the Optimise fails return the current algebra
                return algebra;
            }
        }

        /// <summary>
        /// Determines whether the query can be optimised for ASK evaluation.
        /// </summary>
        /// <param name="q">Query.</param>
        /// <returns></returns>
        public override bool IsApplicable(SparqlQuery q)
        {
            return q.QueryType == SparqlQueryType.Ask && !q.HasSolutionModifier;
        }

        /// <summary>
        /// Returns that the optimiser does not apply to SPARQL Updates.
        /// </summary>
        /// <param name="cmds">Updates.</param>
        /// <returns></returns>
        public override bool IsApplicable(SparqlUpdateCommandSet cmds)
        {
            return false;
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\BgpOptimisers.cs(165,43): error CS0136: A local or parameter named 'join' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Libraries\dotNetRDF\Query\Optimisation\BgpOptimisers.cs(66,43): error CS0136: A local or parameter named 'join' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 7 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLExpressionParser.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using VDS.RDF.Nodes;
using VDS.RDF.Parsing;
using VDS.RDF.Parsing.Contexts;
using VDS.RDF.Parsing.Tokens;
using VDS.RDF.Query.Aggregates.Leviathan;
using VDS.RDF.Query.Aggregates.Sparql;
using VDS.RDF.Query.Expressions;
using VDS.RDF.Query.Expressions.Arithmetic;
using VDS.RDF.Query.Expressions.Comparison;
using VDS.RDF.Query.Expressions.Conditional;
using VDS.RDF.Query.Expressions.Functions.Sparql;
using VDS.RDF.Query.Expressions.Functions.Sparql.Boolean;
using VDS.RDF.Query.Expressions.Functions.Sparql.Constructor;
using VDS.RDF.Query.Expressions.Functions.Sparql.DateTime;
using VDS.RDF.Query.Expressions.Functions.Sparql.Hash;
using VDS.RDF.Query.Expressions.Functions.Sparql.Numeric;
using VDS.RDF.Query.Expressions.Functions.Sparql.Set;
using VDS.RDF.Query.Expressions.Functions.Sparql.String;
using VDS.RDF.Query.Expressions.Primary;

namespace VDS.RDF.Query
{
    /// <summary>
    /// Internal Class which parses SPARQL Expressions into Expression Trees.
    /// </summary>
    class SparqlExpressionParser
    {
        private NamespaceMapper _nsmapper;
        private Uri _baseUri;
        private bool _allowAggregates = false;
        private SparqlQuerySyntax _syntax = Options.QueryDefaultSyntax;
        private SparqlQueryParser _parser;
        private IEnumerable<ISparqlCustomExpressionFactory> _factories = Enumerable.Empty<ISparqlCustomExpressionFactory>();

        /// <summary>
        /// Creates a new SPARQL Expression Parser.
        /// </summary>
        public SparqlExpressionParser() { }

        /// <summary>
        /// Creates a new SPARQL Expression Parser which has a reference back to a Query Parser.
        /// </summary>
        /// <param name="parser">Query Parser.</param>
        public SparqlExpressionParser(SparqlQueryParser parser)
            : this(parser, false) { }

        /// <summary>
        /// Creates a new SPARQL Expression Parser.
        /// </summary>
        /// <param name="allowAggregates">Whether Aggregates are allowed in Expressions.</param>
        public SparqlExpressionParser(bool allowAggregates)
            : this(null, allowAggregates) { }

        /// <summary>
        /// Creates a new SPARQL Expression Parser which has a reference back to a Query Parser.
        /// </summary>
        /// <param name="parser">Query Parser.</param>
        /// <param name="allowAggregates">Whether Aggregates are allowed in Expressions.</param>
        public SparqlExpressionParser(SparqlQueryParser parser, bool allowAggregates)
        {
            _parser = parser;
            _allowAggregates = allowAggregates;
        }

        /// <summary>
        /// Sets the Base Uri used to resolve URIs and QNames.
        /// </summary>
        public Uri BaseUri
        {
            set
            {
                _baseUri = value;
            }
        }

        /// <summary>
        /// Sets the Namespace Map used to resolve QNames.
        /// </summary>
        public NamespaceMapper NamespaceMap
        {
            set
            {
                _nsmapper = value;
            }
        }

        /// <summary>
        /// Gets/Sets whether Aggregates are permitted in Expressions.
        /// </summary>
        public bool AllowAggregates
        {
            get
            {
                return _allowAggregates;
            }
            set
            {
                _allowAggregates = value;
            }
        }

        /// <summary>
        /// Gets/Sets the Syntax that should be supported.
        /// </summary>
        public SparqlQuerySyntax SyntaxMode
        {
            get
            {
                return _syntax;
            }
            set
            {
                _syntax = value;
            }
        }

        /// <summary>
        /// Sets the Query Parser that the Expression Parser can call back into when needed.
        /// </summary>
        public SparqlQueryParser QueryParser
        {
            set
            {
                _parser = value;
            }
        }

        /// <summary>
        /// Gets/Sets the locally scoped custom expression factories.
        /// </summary>
        public IEnumerable<ISparqlCustomExpressionFactory> ExpressionFactories
        {
            get
            {
                return _factories;
            }
            set
            {
                if (value != null)
                {
                    _factories = value;
                }
            }
        }

        /// <summary>
        /// Parses a SPARQL Expression.
        /// </summary>
        /// <param name="tokens">Tokens that the Expression should be parsed from.</param>
        /// <returns></returns>
        public ISparqlExpression Parse(Queue<IToken> tokens)
        {
            try
            {
                return TryParseConditionalOrExpression(tokens);
            }
            catch (InvalidOperationException ex)
            {
                // The Queue was empty
                throw new RdfParseException("Unexpected end of Token Queue while trying to parse an Expression", ex);
            }
        }

        private ISparqlExpression TryParseConditionalOrExpression(Queue<IToken> tokens)
        {
            // Get the first Term in the Expression
            ISparqlExpression firstTerm = TryParseConditionalAndExpression(tokens);

            if (tokens.Count > 0) 
            {
                // Expect an || Token
                IToken next = tokens.Dequeue();
                if (next.TokenType == Token.OR) 
                {
                    return new OrExpression(firstTerm, TryParseConditionalOrExpression(tokens));
                } 
                else 
                {
                    throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Conditional Or expression", next);
                }
            } 
            else 
            {
                return firstTerm;
            }
        }

        private ISparqlExpression TryParseConditionalAndExpression(Queue<IToken> tokens)
        {
            // Get the first Term in the Expression
            ISparqlExpression firstTerm = TryParseValueLogical(tokens);

            if (tokens.Count > 0)
            {
                // Expect an && Token
                IToken next = tokens.Peek();
                if (next.TokenType == Token.AND)
                {
                    tokens.Dequeue();
                    return new AndExpression(firstTerm, TryParseConditionalAndExpression(tokens));
                }
                else
                {
                    return firstTerm;
                    // throw new RdfParseException("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Conditional And expression");
                }
            }
            else
            {
                return firstTerm;
            }
        }

        private ISparqlExpression TryParseValueLogical(Queue<IToken> tokens)
        {
            return TryParseRelationalExpression(tokens);
        }

        private ISparqlExpression TryParseRelationalExpression(Queue<IToken> tokens)
        {
            // Get the First Term of this Expression
            ISparqlExpression firstTerm = TryParseNumericExpression(tokens);

            if (tokens.Count > 0)
            {
                IToken next = tokens.Peek();
                switch (next.TokenType)
                {
                    case Token.EQUALS:
                        tokens.Dequeue();
                        return new EqualsExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.NOTEQUALS:
                        tokens.Dequeue();
                        return new NotEqualsExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.LESSTHAN:
                        tokens.Dequeue();
                        return new LessThanExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.GREATERTHAN:
                        tokens.Dequeue();
                        return new GreaterThanExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.LESSTHANOREQUALTO:
                        tokens.Dequeue();
                        return new LessThanOrEqualToExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.GREATERTHANOREQUALTO:
                        tokens.Dequeue();
                        return new GreaterThanOrEqualToExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.IN:
                    case Token.NOTIN:
                        return TryParseSetExpression(firstTerm, tokens);
                    default:
                        return firstTerm;
                }
            }
            else
            {
                return firstTerm;
            }
        }

        private ISparqlExpression TryParseNumericExpression(Queue<IToken> tokens)
        {
            return TryParseAdditiveExpression(tokens);
        }

        private ISparqlExpression TryParseAdditiveExpression(Queue<IToken> tokens)
        {
            // Get the First Term of this Expression
            ISparqlExpression firstTerm = TryParseMultiplicativeExpression(tokens);

            if (tokens.Count > 0)
            {
                IToken next = tokens.Peek();
                switch (next.TokenType)
                {
                    case Token.PLUS:
                        tokens.Dequeue();
                        return new AdditionExpression(firstTerm, TryParseMultiplicativeExpression(tokens));
                    case Token.MINUS:
                        tokens.Dequeue();
                        return new SubtractionExpression(firstTerm, TryParseMultiplicativeExpression(tokens));
                    case Token.PLAINLITERAL:
                        return new AdditionExpression(firstTerm, TryParseMultiplicativeExpression(tokens));
                    default:
                        return firstTerm;
                }
            }
            else
            {
                return firstTerm;
            }
        }

        private ISparqlExpression TryParseMultiplicativeExpression(Queue<IToken> tokens)
        {
            // Get the First Term of this Expression
            ISparqlExpression firstTerm = TryParseUnaryExpression(tokens);

            if (tokens.Count > 0)
            {
                IToken next = tokens.Peek();
                switch (next.TokenType)
                {
                    case Token.MULTIPLY:
                    {
                        tokens.Dequeue();
                        var rhs = TryParseMultiplicativeExpression(tokens);
                        if (rhs is DivisionExpression)
                        {
                            var args = rhs.Arguments.ToList();
                            return new DivisionExpression(new MultiplicationExpression(firstTerm, args[0]), args[1]);
                        }
                        if (rhs is MultiplicationExpression)
                        {
                            var args = rhs.Arguments.ToList();
                            return new MultiplicationExpression(new MultiplicationExpression(firstTerm, args[0]),
                                args[1]);
                        }
                        return new MultiplicationExpression(firstTerm, rhs);
                    }
                    case Token.DIVIDE:
                    {
                        tokens.Dequeue();
                        var rhs = TryParseMultiplicativeExpression(tokens);
                        if (rhs is DivisionExpression)
                        {
                            var args = rhs.Arguments.ToList();
                            return new DivisionExpression(new DivisionExpression(firstTerm, args[0]), args[1]);
                        }
                        if (rhs is MultiplicationExpression)
                        {
                            var args = rhs.Arguments.ToList();
                            return new MultiplicationExpression(new DivisionExpression(firstTerm, args[0]), args[1]);
                        }
                        return new DivisionExpression(firstTerm, rhs);
                    }
                    default:
                        return firstTerm;
                }
            }
            else
            {
                return firstTerm;
            }
        }

        private ISparqlExpression TryParseUnaryExpression(Queue<IToken> tokens)
        {
            IToken next = tokens.Peek();

            switch (next.TokenType)
            {
                case Token.NEGATION:
                    tokens.Dequeue();
                    return new NotExpression(TryParsePrimaryExpression(tokens));
                case Token.PLUS:
                    // Semantically Unary Plus does nothing so no special expression class for it
                    tokens.Dequeue();
                    return TryParsePrimaryExpression(tokens);
                case Token.MINUS:
                    tokens.Dequeue();
                    return new MinusExpression(TryParsePrimaryExpression(tokens));
                default:
                    return TryParsePrimaryExpression(tokens);
            }
        }

        private ISparqlExpression TryParsePrimaryExpression(Queue<IToken> tokens)
        {
            IToken next = tokens.Peek();

            switch (next.TokenType)
            {
                case Token.LEFTBRACKET:
                    return TryParseBrackettedExpression(tokens);

                case Token.ABS:
                case Token.BNODE:
                case Token.BOUND:
                case Token.CALL:
                case Token.CEIL:
                case Token.COALESCE:
                case Token.CONCAT:
                case Token.DATATYPEFUNC:
                case Token.DAY:
                case Token.ENCODEFORURI:
                case Token.EXISTS:
                case Token.FLOOR:
                case Token.HOURS:
                case Token.IF:
                case Token.IRI:
                case Token.ISBLANK:
                case Token.ISIRI:
                case Token.ISLITERAL:
                case Token.ISNUMERIC:
                case Token.ISURI:
                case Token.LANG:
                case Token.LANGMATCHES:
                case Token.LCASE:
                case Token.MD5:
                case Token.MINUTES:
                case Token.MONTH:
                case Token.NOTEXISTS:
                case Token.NOW:
                case Token.RAND:
                case Token.REGEX:
                case Token.REPLACE:
                case Token.ROUND:
                case Token.SAMETERM:
                case Token.SECONDS:
                case Token.SHA1:
                case Token.SHA224:
                case Token.SHA256:
                case Token.SHA384:
                case Token.SHA512:
                case Token.STR:
                case Token.STRAFTER:
                case Token.STRBEFORE:
                case Token.CONTAINS:
                case Token.STRDT:
                case Token.STRENDS:
                case Token.STRLANG:
                case Token.STRLEN:
                case Token.STRSTARTS:
                case Token.STRUUID:
                case Token.SUBSTR:
                case Token.TIMEZONE:
                case Token.TZ:
                case Token.UCASE:
                case Token.URIFUNC:
                case Token.UUID:
                case Token.YEAR:
                    if (_syntax == SparqlQuerySyntax.Sparql_1_0 && SparqlSpecsHelper.IsFunctionKeyword11(next.Value)) throw Error("The function " + next.Value + " is not supported in SPARQL 1.0", next);
                    return TryParseBuiltInCall(tokens);

                case Token.AVG:
                case Token.COUNT:
                case Token.GROUPCONCAT:
                case Token.MAX:
                case Token.MEDIAN:
                case Token.MIN:
                case Token.MODE:
                case Token.NMAX:
                case Token.NMIN:
                case Token.SAMPLE:
                case Token.SUM:
                    if (_allowAggregates)
                    {
                        return TryParseAggregateExpression(tokens);
                    }
                    else
                    {
                        throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, Aggregates are not permitted in this Expression or you have attempted to nest aggregates", next);
                    }

                case Token.URI:
                case Token.QNAME:
                    return TryParseIriRefOrFunction(tokens);

                case Token.LITERAL:
                case Token.LONGLITERAL:
                    return TryParseRdfLiteral(tokens);
                    
                case Token.PLAINLITERAL:
                    return TryParseBooleanOrNumericLiteral(tokens);

                case Token.VARIABLE:
                    tokens.Dequeue();
                    return new VariableTerm(next.Value);

                default:
                    throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Primary Expression",next);
            }
        }

        private ISparqlExpression TryParseBrackettedExpression(Queue<IToken> tokens)
        {
            return TryParseBrackettedExpression(tokens, true);
        }

        private ISparqlExpression TryParseBrackettedExpression(Queue<IToken> tokens, bool requireOpeningLeftBracket)
        {
            bool temp = false;
            return TryParseBrackettedExpression(tokens, requireOpeningLeftBracket, out temp);
        }

        private ISparqlExpression TryParseBrackettedExpression(Queue<IToken> tokens, bool requireOpeningLeftBracket, out bool commaTerminated)
        {
            bool temp = false;
            return TryParseBrackettedExpression(tokens, requireOpeningLeftBracket, out commaTerminated, out temp);
        }

        private ISparqlExpression TryParseBrackettedExpression(Queue<IToken> tokens, bool requireOpeningLeftBracket, out bool commaTerminated, out bool semicolonTerminated)
        {
            IToken next;

            commaTerminated = false;
            semicolonTerminated = false;

            // Discard the Opening Bracket
            if (requireOpeningLeftBracket)
            {
                next = tokens.Dequeue();
                if (next.TokenType != Token.LEFTBRACKET)
                {
                    throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Bracket to start a Bracketted Expression",next);
                }
            }

            int openBrackets = 1;
            Queue<IToken> exprTerms = new Queue<IToken>();

            while (openBrackets > 0)
            {
                // Get next Token
                next = tokens.Peek();

                // Take account of nesting
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }
                else if (next.TokenType == Token.COMMA && openBrackets == 1)
                {
                    openBrackets--;
                    commaTerminated = true;
                }
                else if (next.TokenType == Token.SEMICOLON && openBrackets == 1)
                {
                    openBrackets--;
                    semicolonTerminated = true;
                }
                else if (next.TokenType == Token.DISTINCT && openBrackets == 1)
                {
                    // DISTINCT can terminate the Tokens that make an expression if it occurs as the first thing and only 1 bracket is open
                    if (tokens.Count == 0)
                    {
                        tokens.Dequeue();
                        commaTerminated = true;
                        return new DistinctModifier();
                    }
                    else
                    {
                        throw Error("Unexpected DISTINCT Keyword Token encountered, DISTINCT modifier keyword may only occur as the first argument to an aggregate function", next);
                    }
                }

                if (openBrackets > 0)
                {
                    exprTerms.Enqueue(next);
                }
                tokens.Dequeue();
            }

            if (exprTerms.Count > 0)
            {
                // Recurse to invoke self
                return Parse(exprTerms);
            }
            else
            {
                return null;
            }
        }

        private ISparqlExpression TryParseBuiltInCall(Queue<IToken> tokens)
        {
            IToken next = tokens.Dequeue();
            bool comma = false, first = true;
            List<ISparqlExpression> args;
            ISparqlExpression strExpr;

            switch (next.TokenType)
            {
                case Token.ABS:
                    return new AbsFunction(TryParseBrackettedExpression(tokens));
                case Token.BNODE:
                    return new BNodeFunction(TryParseBrackettedExpression(tokens));                

                case Token.BOUND:
                    // Expect a Left Bracket, Variable and then a Right Bracket
                    next = tokens.Dequeue();
                    if (next.TokenType == Token.LEFTBRACKET)
                    {
                        next = tokens.Dequeue();
                        if (next.TokenType == Token.VARIABLE)
                        {
                            VariableTerm varExpr = new VariableTerm(next.Value);
                            next = tokens.Dequeue();
                            if (next.TokenType == Token.RIGHTBRACKET)
                            {
                                return new BoundFunction(varExpr);
                            }
                            else
                            {
                                throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, a Right Bracket to end a BOUND function call was expected",next);
                            }
                        }
                        else
                        {
                            throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, a Variable Token for a BOUND function call was expected", next);
                        }
                    }
                    else
                    {
                        throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, a Left Bracket to start a BOUND function call was expected", next);
                    }

                case Token.CALL:
                    if (_syntax != SparqlQuerySyntax.Extended) throw Error("The CALL keyword is only valid when using SPARQL 1.1 Extended syntax", next);
                    args = new List<ISparqlExpression>();
                    do
                    {
                        args.Add(TryParseBrackettedExpression(tokens, first, out comma));
                        first = false;
                    } while (comma);

                    return new CallFunction(args);

                case Token.CEIL:
                    return new CeilFunction(TryParseBrackettedExpression(tokens));

                case Token.COALESCE:
                    // Get as many argument expressions as we can
                    args = new List<ISparqlExpression>();
                    do
                    {
                        args.Add(TryParseBrackettedExpression(tokens, first, out comma));
                        first = false;
                    } while (comma);

                    return new CoalesceFunction(args);

                case Token.CONCAT:
                    // Get as many argument expressions as we can
                    args = new List<ISparqlExpression>();
                    do
                    {
                        args.Add(TryParseBrackettedExpression(tokens, first, out comma));
                        first = false;
                    } while (comma);

                    return new ConcatFunction(args);

                case Token.CONTAINS:
                    return new ContainsFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.DATATYPEFUNC:
                    if (_syntax == SparqlQuerySyntax.Sparql_1_0)
                    {
                        return new DataTypeFunction(TryParseBrackettedExpression(tokens));
                    }
                    else
                    {
                        return new DataType11Function(TryParseBrackettedExpression(tokens));
                    }
                case Token.DAY:
                    return new DayFunction(TryParseBrackettedExpression(tokens));
                case Token.ENCODEFORURI:
                    return new EncodeForUriFunction(TryParseBrackettedExpression(tokens));
                case Token.FLOOR:
                    return new FloorFunction(TryParseBrackettedExpression(tokens));
                case Token.HOURS:
                    return new HoursFunction(TryParseBrackettedExpression(tokens));
                case Token.IF:
                    return new IfElseFunction(TryParseBrackettedExpression(tokens, true, out comma), TryParseBrackettedExpression(tokens, false, out comma), TryParseBrackettedExpression(tokens, false, out comma));
                case Token.IRI:
                case Token.URIFUNC:
                    return new IriFunction(TryParseBrackettedExpression(tokens));
                case Token.ISBLANK:
                    return new IsBlankFunction(TryParseBrackettedExpression(tokens));
                case Token.ISIRI:
                    return new IsIriFunction(TryParseBrackettedExpression(tokens));
                case Token.ISLITERAL:
                    return new IsLiteralFunction(TryParseBrackettedExpression(tokens));
                case Token.ISNUMERIC:
                    return new IsNumericFunction(TryParseBrackettedExpression(tokens));
                case Token.ISURI:
                    return new IsUriFunction(TryParseBrackettedExpression(tokens));
                case Token.LANG:
                    return new LangFunction(TryParseBrackettedExpression(tokens));
                case Token.LANGMATCHES:
                    return new LangMatchesFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.LCASE:
                    return new LCaseFunction(TryParseBrackettedExpression(tokens));
                case Token.MD5:
                    return new MD5HashFunction(TryParseBrackettedExpression(tokens));
                case Token.MINUTES:
                    return new MinutesFunction(TryParseBrackettedExpression(tokens));
                case Token.MONTH:
                    return new MonthFunction(TryParseBrackettedExpression(tokens));

                case Token.NOW:
                    // Expect a () after the Keyword Token
                    TryParseNoArgs(tokens, "NOW");
                    return new NowFunction();

                case Token.RAND:
                    // Expect a () after the Keyword Token
                    TryParseNoArgs(tokens, "RAND");
                    return new RandFunction();

                case Token.REGEX:
                    return TryParseRegexExpression(tokens);
                case Token.REPLACE:
                    // REPLACE may have 3/4 arguments
                    strExpr = TryParseBrackettedExpression(tokens);
                    ISparqlExpression patternExpr = TryParseBrackettedExpression(tokens, false);
                    ISparqlExpression replaceExpr = TryParseBrackettedExpression(tokens, false, out comma);
                    if (comma)
                    {
                        ISparqlExpression opsExpr = TryParseBrackettedExpression(tokens, false);
                        return new ReplaceFunction(strExpr, patternExpr, replaceExpr, opsExpr);
                    }
                    else
                    {
                        return new ReplaceFunction(strExpr, patternExpr, replaceExpr);
                    }
                case Token.ROUND:
                    return new RoundFunction(TryParseBrackettedExpression(tokens));
                case Token.SAMETERM:
                    return new SameTermFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.SECONDS:
                    return new SecondsFunction(TryParseBrackettedExpression(tokens));
                case Token.SHA1:
                    return new Sha1HashFunction(TryParseBrackettedExpression(tokens));
                case Token.SHA256:
                    return new Sha256HashFunction(TryParseBrackettedExpression(tokens));
                case Token.SHA384:
                    return new Sha384HashFunction(TryParseBrackettedExpression(tokens));
                case Token.SHA512:
                    return new Sha512HashFunction(TryParseBrackettedExpression(tokens));
                case Token.STR:
                    return new StrFunction(TryParseBrackettedExpression(tokens));
                case Token.STRAFTER:
                    return new StrAfterFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRBEFORE:
                    return new StrBeforeFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRDT:
                    return new StrDtFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRENDS:
                    return new StrEndsFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRLANG:
                    return new StrLangFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRLEN:
                    return new StrLenFunction(TryParseBrackettedExpression(tokens));
                case Token.STRSTARTS:
                    return new StrStartsFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRUUID:
                    TryParseNoArgs(tokens, "STRUUID");
                    return new StrUUIDFunction();

                case Token.SUBSTR:
                    // SUBSTR may have 2/3 arguments
                    strExpr = TryParseBrackettedExpression(tokens);
                    ISparqlExpression startExpr = TryParseBrackettedExpression(tokens, false, out comma);
                    if (comma)
                    {
                        ISparqlExpression lengthExpr = TryParseBrackettedExpression(tokens, false);
                        return new SubStrFunction(strExpr, startExpr, lengthExpr);
                    }
                    else
                    {
                        return new SubStrFunction(strExpr, startExpr);
                    }

                case Token.TIMEZONE:
                    return new TimezoneFunction(TryParseBrackettedExpression(tokens));
                case Token.TZ:
                    return new TZFunction(TryParseBrackettedExpression(tokens));
                case Token.UCASE:
                    return new UCaseFunction(TryParseBrackettedExpression(tokens));
                case Token.UUID:
                    TryParseNoArgs(tokens, "UUID");
                    return new UUIDFunction();
                case Token.YEAR:
                    return new YearFunction(TryParseBrackettedExpression(tokens));

                case Token.EXISTS:
                case Token.NOTEXISTS:
                    if (_syntax == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("EXISTS/NOT EXISTS clauses are not supported in SPARQL 1.0");
                    if (_parser == null) throw new RdfParseException("Unable to parse an EXISTS/NOT EXISTS as there is no Query Parser to call into");

                    // Gather Tokens for the Pattern
                    NonTokenisedTokenQueue temptokens = new NonTokenisedTokenQueue();
                    int openbrackets = 0;
                    bool mustExist = (next.TokenType == Token.EXISTS);
                    do
                    {
                        if (tokens.Count == 0) throw new RdfParseException("Unexpected end of Tokens while trying to parse an EXISTS/NOT EXISTS function");

                        next = tokens.Dequeue();
                        if (next.TokenType == Token.LEFTCURLYBRACKET)
                        {
                            openbrackets++;
                        }
                        else if (next.TokenType == Token.RIGHTCURLYBRACKET)
                        {
                            openbrackets--;
                        }
                        temptokens.Enqueue(next);
                    } while (openbrackets > 0);

                    // Call back into the Query Parser to try and Parse the Graph Pattern for the Function
                    SparqlQueryParserContext tempcontext = new SparqlQueryParserContext(temptokens);
                    tempcontext.Query.NamespaceMap.Import(_nsmapper);
                    tempcontext.Query.BaseUri = _baseUri;
                    return new ExistsFunction(_parser.TryParseGraphPattern(tempcontext, true), mustExist);

                default:
                    throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Built-in Function call", next);
            }
        }

        private void TryParseNoArgs(Queue<IToken> tokens, String function)
        {
            IToken next = tokens.Dequeue();
            if (next.TokenType != Token.LEFTBRACKET) throw Error("Expected a Left Bracket after a " + function + " keyword to call the " + function + "() function", next);
            next = tokens.Dequeue();
            if (next.TokenType != Token.RIGHTBRACKET) throw Error("Expected a Right Bracket after " + function + "( since the " + function + "() function does not take any arguments", next);
        }

        private ISparqlExpression TryParseRegexExpression(Queue<IToken> tokens)
        {
            bool hasOptions = false;

            // Get Text and Pattern Expressions
            ISparqlExpression textExpr = TryParseBrackettedExpression(tokens);
            ISparqlExpression patternExpr = TryParseBrackettedExpression(tokens, false, out hasOptions);

            // Check whether we need to get an Options Expression
            if (hasOptions)
            {
                ISparqlExpression optionExpr = TryParseBrackettedExpression(tokens, false);
                return new RegexFunction(textExpr, patternExpr, optionExpr);
            }
            else
            {
                return new RegexFunction(textExpr, patternExpr);
            }
        }

        private ISparqlExpression TryParseIriRefOrFunction(Queue<IToken> tokens)
        {
            // Get the Uri/QName Token
            IToken first = tokens.Dequeue();

            // Resolve the Uri
            Uri u;
            if (first.TokenType == Token.QNAME)
            {
                // Resolve QName
                u = UriFactory.Create(Tools.ResolveQName(first.Value, _nsmapper, _baseUri));
            }
            else
            {
                u = UriFactory.Create(Tools.ResolveUri(first.Value, _baseUri.ToSafeString()));
            }
            
            // Get the Argument List (if any)
            if (tokens.Count > 0)
            {
                IToken next = tokens.Peek();
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    bool comma = false, semicolon = false;
                    List<ISparqlExpression> args = new List<ISparqlExpression>();
                    args.Add(TryParseBrackettedExpression(tokens, true, out comma, out semicolon));

                    while (comma && !semicolon)
                    {
                        args.Add(TryParseBrackettedExpression(tokens, false, out comma, out semicolon));
                    }

                    // If there are no arguments (one null argument) then discard
                    if (args.Count == 1 && args.First() == null) args.Clear();

                    // Check whether we need to parse Scalar Arguments
                    Dictionary<String, ISparqlExpression> scalarArgs = null;
                    if (semicolon)
                    {
                        if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("Arguments List terminated by a Semicolon - Arbitrary Scalar Arguments for Extension Functions/Aggregates are not permitted in SPARQL 1.1");
                        scalarArgs = TryParseScalarArguments(first, tokens);
                    }

                    // Return an Extension Function expression
                    ISparqlExpression expr = SparqlExpressionFactory.CreateExpression(u, args, _factories);
                    if (expr is AggregateTerm)
                    {
                        if (!_allowAggregates) throw new RdfParseException("Aggregate Expression '" + expr.ToString() + "' encountered but aggregates are not permitted in this Expression");
                    }
                    return expr;
                }
                else
                {
                    // Just an IRIRef
                    return new ConstantTerm(new UriNode(null, u));
                }
            }
            else
            {
                // Just an IRIRef
                return new ConstantTerm(new UriNode(null, u));
            }
        }

        private ISparqlExpression TryParseRdfLiteral(Queue<IToken> tokens)
        {
            // First Token will be the String value of this RDF Literal
            IToken str = tokens.Dequeue();

            // Might have a Language Specifier/DataType afterwards
            if (tokens.Count > 0)
            {
                IToken next = tokens.Peek();
                if (next.TokenType == Token.LANGSPEC)
                {
                    tokens.Dequeue();
                    return new ConstantTerm(new LiteralNode(null, str.Value, next.Value));
                }
                else if (next.TokenType == Token.HATHAT)
                {
                    tokens.Dequeue();

                    // Should be a DataTypeToken afterwards
                    next = tokens.Dequeue();
                    LiteralWithDataTypeToken dtlit = new LiteralWithDataTypeToken(str, (DataTypeToken)next); ;
                    Uri u;

                    if (next.Value.StartsWith("<"))
                    {
                        u = UriFactory.Create(next.Value.Substring(1, next.Value.Length - 2));
                    }
                    else
                    {
                        // Resolve the QName
                        u = UriFactory.Create(Tools.ResolveQName(next.Value, _nsmapper, _baseUri));
                    }

                    if (SparqlSpecsHelper.GetNumericTypeFromDataTypeUri(u) != SparqlNumericType.NaN)
                    {
                        // Should be a Number
                        return TryParseNumericLiteral(dtlit, tokens, false);
                    }
                    else if (XmlSpecsHelper.XmlSchemaDataTypeBoolean.Equals(u.AbsoluteUri))
                    {
                        // Appears to be a Boolean
                        bool b;
                        if (Boolean.TryParse(dtlit.Value, out b))
                        {
                            return new ConstantTerm(new BooleanNode(null, b));
                        }
                        else
                        {
                            return new ConstantTerm(new StringNode(null, dtlit.Value, dtlit.DataType));
                        }
                    }
                    else
                    {
                        // Just a datatyped Literal Node
                        return new ConstantTerm(new LiteralNode(null, str.Value, u));
                    }
                }
                else
                {
                    return new ConstantTerm(new LiteralNode(null, str.Value));
                }
            }
            else
            {
                return new ConstantTerm(new LiteralNode(null, str.Value));
            }

        }

        private ISparqlExpression TryParseBooleanOrNumericLiteral(Queue<IToken> tokens)
        {
            // First Token must be a Plain Literal
            IToken lit = tokens.Dequeue();

            if (lit.Value.Equals("true"))
            {
                return new ConstantTerm(new BooleanNode(null, true));
            }
            else if (lit.Value.Equals("false"))
            {
                return new ConstantTerm(new BooleanNode(null, false));
            }
            else
            {
                return TryParseNumericLiteral(lit, tokens, true);
            }
        }

        private ISparqlExpression TryParseNumericLiteral(IToken literal, Queue<IToken> tokens, bool requireValidLexicalForm)
        {
            switch (literal.TokenType)
            {
                case Token.PLAINLITERAL:
                    // Use Regular Expressions to see what type it is
                    if (SparqlSpecsHelper.IsInteger(literal.Value))
                    {
                        return new ConstantTerm(new LongNode(null, Int64.Parse(literal.Value)));
                    }
                    else if (SparqlSpecsHelper.IsDecimal(literal.Value))
                    {
                        return new ConstantTerm(new DecimalNode(null, Decimal.Parse(literal.Value, NumberStyles.Any, CultureInfo.InvariantCulture)));
                    }
                    else if (SparqlSpecsHelper.IsDouble(literal.Value))
                    {
                        return new ConstantTerm(new DoubleNode(null, Double.Parse(literal.Value, NumberStyles.Any, CultureInfo.InvariantCulture)));
                    }
                    else
                    {
                        throw Error("The Plain Literal '" + literal.Value + "' is not a valid Integer, Decimal or Double", literal);
                    }
                    
                case Token.LITERALWITHDT:
                    // Get the Data Type Uri
                    String dt = ((LiteralWithDataTypeToken)literal).DataType;
                    String dtUri;
                    if (dt.StartsWith("<"))
                    {
                        String baseUri = (_baseUri == null) ? String.Empty : _baseUri.AbsoluteUri;
                        dtUri = Tools.ResolveUri(dt.Substring(1, dt.Length - 2), baseUri);
                    }
                    else
                    {
                        dtUri = Tools.ResolveQName(dt, _nsmapper, _baseUri);
                    }

                    // Try to return a numeric expression, enforce the need for a valid numeric value where relevant
                    LiteralNode lit = new LiteralNode(null, literal.Value, UriFactory.Create(dtUri));
                    IValuedNode value = lit.AsValuedNode();
                    if (requireValidLexicalForm && value.NumericType == SparqlNumericType.NaN)
                    {
                        throw Error("The Literal '" + literal.Value + "' with Datatype URI '" + dtUri + "' is not a valid Integer, Decimal or Double", literal);
                    }
                    else
                    {
                        return new ConstantTerm(value);
                    }
                    
                case Token.LITERAL:
                    // Check if there's a Datatype following the Literal
                    if (tokens.Count > 0)
                    {
                        IToken next = tokens.Peek();
                        if (next.TokenType == Token.HATHAT)
                        {
                            tokens.Dequeue();
                            // Should now see a DataTypeToken
                            DataTypeToken datatype = (DataTypeToken)tokens.Dequeue();
                            LiteralWithDataTypeToken dtlit = new LiteralWithDataTypeToken(literal, datatype);

                            // Self-recurse to save replicating code
                            return TryParseNumericLiteral(dtlit, tokens, true);
                        }
                    }
                    // Use Regex to see if it's a Integer/Decimal/Double
                    if (SparqlSpecsHelper.IsInteger(literal.Value))
                    {
                        return new ConstantTerm(new LongNode(null, Int64.Parse(literal.Value)));
                    }
                    else if (SparqlSpecsHelper.IsDecimal(literal.Value))
                    {
                        return new ConstantTerm(new DecimalNode(null, Decimal.Parse(literal.Value)));
                    }
                    else if (SparqlSpecsHelper.IsDouble(literal.Value))
                    {
                        return new ConstantTerm(new DoubleNode(null, Double.Parse(literal.Value)));
                    }
                    else
                    {
                        // Otherwise treat as a Node Expression
                        throw Error("The Literal '" + literal.Value + "' is not a valid Integer, Decimal or Double", literal);
                    }

                default:
                    throw Error("Unexpected Token '" + literal.GetType().ToString() + "' encountered while trying to parse a Numeric Literal", literal);
            }
        }

        private ISparqlExpression TryParseAggregateExpression(Queue<IToken> tokens)
        {
            if (_syntax == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Aggregates are not permitted in SPARQL 1.0");

            IToken agg = tokens.Dequeue();
            ISparqlExpression aggExpr = null;
            bool distinct = false, all = false;
            bool scalarArgs = false;

            // Turn off aggregate allowance since aggregates may not be nested
            bool aggsAllowed = _allowAggregates;
            _allowAggregates = false;

            // Expect a Left Bracket next
            IToken next = tokens.Dequeue();
            if (next.TokenType != Token.LEFTBRACKET)
            {
                throw Error("Unexpected Token '" + next.GetType().ToString() + "', expected a Left Bracket after an Aggregate Keyword", next);
            }

            // Then a possible DISTINCT/ALL
            next = tokens.Peek();
            if (next.TokenType == Token.DISTINCT)
            {
                distinct = true;
                tokens.Dequeue();
            }
            next = tokens.Peek();
            if (next.TokenType == Token.ALL || next.TokenType == Token.MULTIPLY)
            {
                all = true;
                tokens.Dequeue();
            }
            next = tokens.Peek();

            // If we've seen an ALL then we need the closing bracket
            if (all && next.TokenType != Token.RIGHTBRACKET)
            {
                throw Error("Unexpected Token '" + next.GetType().ToString() + "', expected a Right Bracket after the * specifier in an aggregate to terminate the aggregate", next);
            }
            else if (all && agg.TokenType != Token.COUNT)
            {
                throw new RdfQueryException("Cannot use the * specifier in aggregates other than COUNT");
            }
            else if (!all)
            {
                // If it's not an all then we expect some expression(s)
                // Gather the Tokens and parse the Expression
                Queue<IToken> subtokens = new Queue<IToken>();

                int openBrackets = 1;
                List<ISparqlExpression> expressions = new List<ISparqlExpression>();

                while (openBrackets > 0)
                {
                    subtokens = new Queue<IToken>();
                    next = tokens.Dequeue();
                    do
                    {
                        if (next.TokenType == Token.LEFTBRACKET)
                        {
                            openBrackets++;
                        }
                        else if (next.TokenType == Token.RIGHTBRACKET)
                        {
                            openBrackets--;
                        }
                        else if (next.TokenType == Token.COMMA)
                        {
                            // If we see a comma when we only have 1 bracket open then it is separating argument expressions
                            if (openBrackets == 1)
                            {
                                break;
                            }
                        }
                        else if (next.TokenType == Token.SEMICOLON)
                        {
                            // If we see a semicolon when we only have 1 bracket open then this indicates we have scalar arguments in-use
                            if (openBrackets == 1)
                            {
                                scalarArgs = true;
                                break;
                            }
                        }

                        if (openBrackets > 0)
                        {
                            subtokens.Enqueue(next);
                            next = tokens.Dequeue();
                        }
                    } while (openBrackets > 0);

                    // Parse this expression and add to the list of expressions we're concatenating
                    expressions.Add(Parse(subtokens));

                    // Once we've hit the ; for the scalar arguments then we can stop looking for expressions
                    if (scalarArgs) break;

                    // If we've hit a , then openBrackets will still be one and we'll go around again looking for another expression
                    // Otherwise we've reached the end of the aggregate and there was no ; for scalar arguments
                }

                if (expressions.Count == 0) throw new RdfParseException("Aggregate must have at least one argument expression unless they are a COUNT(*)");
                if (expressions.Count > 1) throw new RdfParseException("The " + agg.Value + " aggregate does not support more than one argument expression");
                aggExpr = expressions.First();
            }
            else
            {
                tokens.Dequeue();
            }

            // If the aggregate uses scalar arguments then we'll parse them here
            Dictionary<String, ISparqlExpression> scalarArguments = new Dictionary<string, ISparqlExpression>();
            if (scalarArgs)
            {
                scalarArguments = TryParseScalarArguments(agg, tokens);
            }

            // Reset Aggregate Allowance
            _allowAggregates = aggsAllowed;

            // Now we need to generate the actual expression
            switch (agg.TokenType)
            {
                case Token.AVG:
                    // AVG Aggregate
                    if (aggExpr is VariableTerm)
                    {
                        return new AggregateTerm(new AverageAggregate((VariableTerm)aggExpr, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new AverageAggregate(aggExpr, distinct));
                    }

                case Token.COUNT:
                    // COUNT Aggregate
                    if (all)
                    {
                        if (distinct)
                        {
                            return new AggregateTerm(new CountAllDistinctAggregate());
                        }
                        else
                        {
                            return new AggregateTerm(new CountAllAggregate());
                        }
                    }
                    else if (aggExpr is VariableTerm)
                    {
                        if (distinct)
                        {
                            return new AggregateTerm(new CountDistinctAggregate((VariableTerm)aggExpr));
                        }
                        else
                        {
                            return new AggregateTerm(new CountAggregate((VariableTerm)aggExpr));
                        }
                    }
                    else
                    {
                        if (distinct)
                        {
                            return new AggregateTerm(new CountDistinctAggregate(aggExpr));
                        }
                        else
                        {
                            return new AggregateTerm(new CountAggregate(aggExpr));
                        }
                    }
                case Token.GROUPCONCAT:
                    if (scalarArgs)
                    {
                        if (!scalarArguments.ContainsKey(SparqlSpecsHelper.SparqlKeywordSeparator)) throw new RdfParseException("The GROUP_CONCAT aggregate has Scalar Arguments but does not have the expected SEPARATOR argument");
                        return new AggregateTerm(new GroupConcatAggregate(aggExpr, scalarArguments[SparqlSpecsHelper.SparqlKeywordSeparator], distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new GroupConcatAggregate(aggExpr, distinct));
                    }

                case Token.MAX:
                    // MAX Aggregate
                    if (aggExpr is VariableTerm)
                    {
                        return new AggregateTerm(new MaxAggregate((VariableTerm)aggExpr, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new MaxAggregate(aggExpr, distinct));
                    }

                case Token.MEDIAN:
                    // MEDIAN Aggregate
                    if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("The MEDIAN aggregate is only supported when the Syntax is set to Extended.");
                    if (aggExpr is VariableTerm)
                    {
                        return new AggregateTerm(new MedianAggregate((VariableTerm)aggExpr, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new MedianAggregate(aggExpr, distinct));
                    }

                case Token.MIN:
                    // MIN Aggregate
                    if (aggExpr is VariableTerm)
                    {
                        return new AggregateTerm(new MinAggregate((VariableTerm)aggExpr, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new MinAggregate(aggExpr, distinct));
                    }

                case Token.MODE:
                    // MODE Aggregate
                    if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("The MODE aggregate is only supported when the Syntax is set to Extended.");
                    if (aggExpr is VariableTerm)
                    {
                        return new AggregateTerm(new ModeAggregate((VariableTerm)aggExpr, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new ModeAggregate(aggExpr, distinct));
                    }

                case Token.NMAX:
                    // NMAX Aggregate
                    if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("The NMAX (Numeric Maximum) aggregate is only supported when the Syntax is set to Extended.  To achieve an equivalent result in SPARQL 1.0/1.1 apply a FILTER to your query so the aggregated variable is only literals of the desired numeric type");
                    if (aggExpr is VariableTerm)
                    {
                        return new AggregateTerm(new NumericMaxAggregate((VariableTerm)aggExpr, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new NumericMaxAggregate(aggExpr, distinct));
                    }

                case Token.NMIN:
                    // NMIN Aggregate
                    if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("The NMIN (Numeric Minimum) aggregate is only supported when the Syntax is set to Extended.  To achieve an equivalent result in SPARQL 1.0/1.1 apply a FILTER to your query so the aggregated variable is only literals of the desired numeric type");
                    if (aggExpr is VariableTerm)
                    {
                        return new AggregateTerm(new NumericMinAggregate((VariableTerm)aggExpr, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new NumericMinAggregate(aggExpr, distinct));
                    }

                case Token.SAMPLE:
                    // SAMPLE Aggregate
                    if (distinct) throw new RdfParseException("DISTINCT modifier is not valid for the SAMPLE aggregate");
                    return new AggregateTerm(new SampleAggregate(aggExpr));

                case Token.SUM:
                    // SUM Aggregate
                    if (aggExpr is VariableTerm)
                    {
                        return new AggregateTerm(new SumAggregate((VariableTerm)aggExpr, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new SumAggregate(aggExpr, distinct));
                    }

                default:
                    // Should have already handled this but have to have it to keep the compiler happy
                    throw Error("Cannot parse an Aggregate since '" + agg.GetType().ToString() + "' is not an Aggregate Keyword Token", agg);
            }
        }

        private Dictionary<String, ISparqlExpression> TryParseScalarArguments(IToken funcToken, Queue<IToken> tokens)
        {
            // Parse the Scalar Arguments
            Dictionary<String, ISparqlExpression> scalarArguments = new Dictionary<string, ISparqlExpression>();
            IToken next;
            Queue<IToken> subtokens = new Queue<IToken>();
            int openBrackets = 1;

            while (openBrackets > 0)
            {
                // First expect a Keyword/QName/URI for the Scalar Argument Name
                String argName;
                next = tokens.Peek();
                switch (next.TokenType)
                {
                    case Token.SEPARATOR:
                        if (funcToken.TokenType == Token.GROUPCONCAT)
                        {
                            // OK
                            argName = SparqlSpecsHelper.SparqlKeywordSeparator;
                        }
                        else
                        {
                            throw Error("The SEPARATOR scalar argument is only valid with the GROUP_CONCAT aggregate", next);
                        }
                        break;

                    case Token.QNAME:
                    case Token.URI:
                        if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("Arbitrary Scalar Arguments for Aggregates are not permitted in SPARQL 1.1");

                        // Resolve QName/URI
                        if (next.TokenType == Token.QNAME)
                        {
                            argName = Tools.ResolveQName(next.Value, _nsmapper, _baseUri);
                        }
                        else
                        {
                            argName = Tools.ResolveUri(next.Value, _baseUri.ToSafeString());
                        }
                        break;

                    default:
                        throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Keyword/QName/URI for the Scalar Argument Name", next);
                }
                tokens.Dequeue();

                // After the Argument Name need an =
                next = tokens.Peek();
                if (next.TokenType != Token.EQUALS)
                {
                    throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a = after a Scalar Argument name in an aggregate", next);
                }
                tokens.Dequeue();

                // Get the subtokens for the Argument Expression
                next = tokens.Dequeue();
                do
                {
                    if (next.TokenType == Token.LEFTBRACKET)
                    {
                        openBrackets++;
                    }
                    else if (next.TokenType == Token.RIGHTBRACKET)
                    {
                        openBrackets--;
                    }
                    else if (next.TokenType == Token.COMMA)
                    {
                        // If we see a COMMA and there is only 1 bracket open then expect another argument
                        if (openBrackets == 1)
                        {
                            break;
                        }
                    }

                    // If not the end bracket then add it to the subtokens
                    if (openBrackets > 0)
                    {
                        subtokens.Enqueue(next);
                        next = tokens.Dequeue();
                    }
                } while (openBrackets > 0);

                // Parse the Subtokens into the Argument Expression
                if (scalarArguments.ContainsKey(argName))
                {
                    scalarArguments[argName] = Parse(subtokens);
                }
                else
                {
                    scalarArguments.Add(argName, Parse(subtokens));
                }
            }

            return scalarArguments;
        }

        private ISparqlExpression TryParseSetExpression(ISparqlExpression expr, Queue<IToken> tokens)
        {
            IToken next = tokens.Dequeue();
            bool inSet = (next.TokenType == Token.IN);
            List<ISparqlExpression> expressions = new List<ISparqlExpression>();

            // Expecting a ( afterwards
            next = tokens.Dequeue();
            if (next.TokenType == Token.LEFTBRACKET)
            {
                next = tokens.Peek();

                if (next.TokenType == Token.RIGHTBRACKET)
                {
                    tokens.Dequeue();
                } 
                else
                {
                    bool comma = false;
                    expressions.Add(TryParseBrackettedExpression(tokens, false, out comma));
                    while (comma)
                    {
                        expressions.Add(TryParseBrackettedExpression(tokens, false, out comma));
                    }
                }
            }
            else
            {
                throw Error("Expected a left bracket to start the set of values for an IN/NOT IN expression", next);
            }

            if (inSet)
            {
                return new InFunction(expr, expressions);
            }
            else
            {
                return new NotInFunction(expr, expressions);
            }
        }

        /// <summary>
        /// Helper method for raising informative standardised Parser Errors.
        /// </summary>
        /// <param name="msg">The Error Message.</param>
        /// <param name="t">The Token that is the cause of the Error.</param>
        /// <returns></returns>
        private RdfParseException Error(String msg, IToken t)
        {
            StringBuilder output = new StringBuilder();
            output.Append("[");
            output.Append(t.GetType().ToString());
            output.Append(" at Line ");
            output.Append(t.StartLine);
            output.Append(" Column ");
            output.Append(t.StartPosition);
            output.Append(" to Line ");
            output.Append(t.EndLine);
            output.Append(" Column ");
            output.Append(t.EndPosition);
            output.Append("]\n");
            output.Append(msg);

            return new RdfParseException(output.ToString(), t);
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using VDS.RDF.Nodes;
using VDS.RDF.Parsing;
using VDS.RDF.Parsing.Contexts;
using VDS.RDF.Parsing.Tokens;
using VDS.RDF.Query.Aggregates.Leviathan;
using VDS.RDF.Query.Aggregates.Sparql;
using VDS.RDF.Query.Expressions;
using VDS.RDF.Query.Expressions.Arithmetic;
using VDS.RDF.Query.Expressions.Comparison;
using VDS.RDF.Query.Expressions.Conditional;
using VDS.RDF.Query.Expressions.Functions.Sparql;
using VDS.RDF.Query.Expressions.Functions.Sparql.Boolean;
using VDS.RDF.Query.Expressions.Functions.Sparql.Constructor;
using VDS.RDF.Query.Expressions.Functions.Sparql.DateTime;
using VDS.RDF.Query.Expressions.Functions.Sparql.Hash;
using VDS.RDF.Query.Expressions.Functions.Sparql.Numeric;
using VDS.RDF.Query.Expressions.Functions.Sparql.Set;
using VDS.RDF.Query.Expressions.Functions.Sparql.String;
using VDS.RDF.Query.Expressions.Primary;

namespace VDS.RDF.Query
{
    /// <summary>
    /// Internal Class which parses SPARQL Expressions into Expression Trees.
    /// </summary>
    class SparqlExpressionParser
    {
        private NamespaceMapper _nsmapper;
        private Uri _baseUri;
        private bool _allowAggregates = false;
        private SparqlQuerySyntax _syntax = Options.QueryDefaultSyntax;
        private SparqlQueryParser _parser;
        private IEnumerable<ISparqlCustomExpressionFactory> _factories = Enumerable.Empty<ISparqlCustomExpressionFactory>();

        /// <summary>
        /// Creates a new SPARQL Expression Parser.
        /// </summary>
        public SparqlExpressionParser() { }

        /// <summary>
        /// Creates a new SPARQL Expression Parser which has a reference back to a Query Parser.
        /// </summary>
        /// <param name="parser">Query Parser.</param>
        public SparqlExpressionParser(SparqlQueryParser parser)
            : this(parser, false) { }

        /// <summary>
        /// Creates a new SPARQL Expression Parser.
        /// </summary>
        /// <param name="allowAggregates">Whether Aggregates are allowed in Expressions.</param>
        public SparqlExpressionParser(bool allowAggregates)
            : this(null, allowAggregates) { }

        /// <summary>
        /// Creates a new SPARQL Expression Parser which has a reference back to a Query Parser.
        /// </summary>
        /// <param name="parser">Query Parser.</param>
        /// <param name="allowAggregates">Whether Aggregates are allowed in Expressions.</param>
        public SparqlExpressionParser(SparqlQueryParser parser, bool allowAggregates)
        {
            _parser = parser;
            _allowAggregates = allowAggregates;
        }

        /// <summary>
        /// Sets the Base Uri used to resolve URIs and QNames.
        /// </summary>
        public Uri BaseUri
        {
            set
            {
                _baseUri = value;
            }
        }

        /// <summary>
        /// Sets the Namespace Map used to resolve QNames.
        /// </summary>
        public NamespaceMapper NamespaceMap
        {
            set
            {
                _nsmapper = value;
            }
        }

        /// <summary>
        /// Gets/Sets whether Aggregates are permitted in Expressions.
        /// </summary>
        public bool AllowAggregates
        {
            get
            {
                return _allowAggregates;
            }
            set
            {
                _allowAggregates = value;
            }
        }

        /// <summary>
        /// Gets/Sets the Syntax that should be supported.
        /// </summary>
        public SparqlQuerySyntax SyntaxMode
        {
            get
            {
                return _syntax;
            }
            set
            {
                _syntax = value;
            }
        }

        /// <summary>
        /// Sets the Query Parser that the Expression Parser can call back into when needed.
        /// </summary>
        public SparqlQueryParser QueryParser
        {
            set
            {
                _parser = value;
            }
        }

        /// <summary>
        /// Gets/Sets the locally scoped custom expression factories.
        /// </summary>
        public IEnumerable<ISparqlCustomExpressionFactory> ExpressionFactories
        {
            get
            {
                return _factories;
            }
            set
            {
                if (value != null)
                {
                    _factories = value;
                }
            }
        }

        /// <summary>
        /// Parses a SPARQL Expression.
        /// </summary>
        /// <param name="tokens">Tokens that the Expression should be parsed from.</param>
        /// <returns></returns>
        public ISparqlExpression Parse(Queue<IToken> tokens)
        {
            try
            {
                return TryParseConditionalOrExpression(tokens);
            }
            catch (InvalidOperationException ex)
            {
                // The Queue was empty
                throw new RdfParseException("Unexpected end of Token Queue while trying to parse an Expression", ex);
            }
        }

        private ISparqlExpression TryParseConditionalOrExpression(Queue<IToken> tokens)
        {
            // Get the first Term in the Expression
            ISparqlExpression firstTerm = TryParseConditionalAndExpression(tokens);

            if (tokens.Count > 0) 
            {
                // Expect an || Token
                IToken next = tokens.Dequeue();
                if (next.TokenType == Token.OR) 
                {
                    return new OrExpression(firstTerm, TryParseConditionalOrExpression(tokens));
                } 
                else 
                {
                    throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Conditional Or expression", next);
                }
            } 
            else 
            {
                return firstTerm;
            }
        }

        private ISparqlExpression TryParseConditionalAndExpression(Queue<IToken> tokens)
        {
            // Get the first Term in the Expression
            ISparqlExpression firstTerm = TryParseValueLogical(tokens);

            if (tokens.Count > 0)
            {
                // Expect an && Token
                IToken next = tokens.Peek();
                if (next.TokenType == Token.AND)
                {
                    tokens.Dequeue();
                    return new AndExpression(firstTerm, TryParseConditionalAndExpression(tokens));
                }
                else
                {
                    return firstTerm;
                    // throw new RdfParseException("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Conditional And expression");
                }
            }
            else
            {
                return firstTerm;
            }
        }

        private ISparqlExpression TryParseValueLogical(Queue<IToken> tokens)
        {
            return TryParseRelationalExpression(tokens);
        }

        private ISparqlExpression TryParseRelationalExpression(Queue<IToken> tokens)
        {
            // Get the First Term of this Expression
            ISparqlExpression firstTerm = TryParseNumericExpression(tokens);

            if (tokens.Count > 0)
            {
                IToken next = tokens.Peek();
                switch (next.TokenType)
                {
                    case Token.EQUALS:
                        tokens.Dequeue();
                        return new EqualsExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.NOTEQUALS:
                        tokens.Dequeue();
                        return new NotEqualsExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.LESSTHAN:
                        tokens.Dequeue();
                        return new LessThanExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.GREATERTHAN:
                        tokens.Dequeue();
                        return new GreaterThanExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.LESSTHANOREQUALTO:
                        tokens.Dequeue();
                        return new LessThanOrEqualToExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.GREATERTHANOREQUALTO:
                        tokens.Dequeue();
                        return new GreaterThanOrEqualToExpression(firstTerm, TryParseNumericExpression(tokens));
                    case Token.IN:
                    case Token.NOTIN:
                        return TryParseSetExpression(firstTerm, tokens);
                    default:
                        return firstTerm;
                }
            }
            else
            {
                return firstTerm;
            }
        }

        private ISparqlExpression TryParseNumericExpression(Queue<IToken> tokens)
        {
            return TryParseAdditiveExpression(tokens);
        }

        private ISparqlExpression TryParseAdditiveExpression(Queue<IToken> tokens)
        {
            // Get the First Term of this Expression
            ISparqlExpression firstTerm = TryParseMultiplicativeExpression(tokens);

            if (tokens.Count > 0)
            {
                IToken next = tokens.Peek();
                switch (next.TokenType)
                {
                    case Token.PLUS:
                        tokens.Dequeue();
                        return new AdditionExpression(firstTerm, TryParseMultiplicativeExpression(tokens));
                    case Token.MINUS:
                        tokens.Dequeue();
                        return new SubtractionExpression(firstTerm, TryParseMultiplicativeExpression(tokens));
                    case Token.PLAINLITERAL:
                        return new AdditionExpression(firstTerm, TryParseMultiplicativeExpression(tokens));
                    default:
                        return firstTerm;
                }
            }
            else
            {
                return firstTerm;
            }
        }

        private ISparqlExpression TryParseMultiplicativeExpression(Queue<IToken> tokens)
        {
            // Get the First Term of this Expression
            ISparqlExpression firstTerm = TryParseUnaryExpression(tokens);

            if (tokens.Count > 0)
            {
                IToken next = tokens.Peek();
                switch (next.TokenType)
                {
                    case Token.MULTIPLY:
                    {
                        tokens.Dequeue();
                        var rhs = TryParseMultiplicativeExpression(tokens);
                        if (rhs is DivisionExpression)
                        {
                            var args = rhs.Arguments.ToList();
                            return new DivisionExpression(new MultiplicationExpression(firstTerm, args[0]), args[1]);
                        }
                        if (rhs is MultiplicationExpression)
                        {
                            var args = rhs.Arguments.ToList();
                            return new MultiplicationExpression(new MultiplicationExpression(firstTerm, args[0]),
                                args[1]);
                        }
                        return new MultiplicationExpression(firstTerm, rhs);
                    }
                    case Token.DIVIDE:
                    {
                        tokens.Dequeue();
                        var rhs = TryParseMultiplicativeExpression(tokens);
                        if (rhs is DivisionExpression)
                        {
                            var args = rhs.Arguments.ToList();
                            return new DivisionExpression(new DivisionExpression(firstTerm, args[0]), args[1]);
                        }
                        if (rhs is MultiplicationExpression)
                        {
                            var args = rhs.Arguments.ToList();
                            return new MultiplicationExpression(new DivisionExpression(firstTerm, args[0]), args[1]);
                        }
                        return new DivisionExpression(firstTerm, rhs);
                    }
                    default:
                        return firstTerm;
                }
            }
            else
            {
                return firstTerm;
            }
        }

        private ISparqlExpression TryParseUnaryExpression(Queue<IToken> tokens)
        {
            IToken next = tokens.Peek();

            switch (next.TokenType)
            {
                case Token.NEGATION:
                    tokens.Dequeue();
                    return new NotExpression(TryParsePrimaryExpression(tokens));
                case Token.PLUS:
                    // Semantically Unary Plus does nothing so no special expression class for it
                    tokens.Dequeue();
                    return TryParsePrimaryExpression(tokens);
                case Token.MINUS:
                    tokens.Dequeue();
                    return new MinusExpression(TryParsePrimaryExpression(tokens));
                default:
                    return TryParsePrimaryExpression(tokens);
            }
        }

        private ISparqlExpression TryParsePrimaryExpression(Queue<IToken> tokens)
        {
            IToken next = tokens.Peek();

            switch (next.TokenType)
            {
                case Token.LEFTBRACKET:
                    return TryParseBrackettedExpression(tokens);

                case Token.ABS:
                case Token.BNODE:
                case Token.BOUND:
                case Token.CALL:
                case Token.CEIL:
                case Token.COALESCE:
                case Token.CONCAT:
                case Token.DATATYPEFUNC:
                case Token.DAY:
                case Token.ENCODEFORURI:
                case Token.EXISTS:
                case Token.FLOOR:
                case Token.HOURS:
                case Token.IF:
                case Token.IRI:
                case Token.ISBLANK:
                case Token.ISIRI:
                case Token.ISLITERAL:
                case Token.ISNUMERIC:
                case Token.ISURI:
                case Token.LANG:
                case Token.LANGMATCHES:
                case Token.LCASE:
                case Token.MD5:
                case Token.MINUTES:
                case Token.MONTH:
                case Token.NOTEXISTS:
                case Token.NOW:
                case Token.RAND:
                case Token.REGEX:
                case Token.REPLACE:
                case Token.ROUND:
                case Token.SAMETERM:
                case Token.SECONDS:
                case Token.SHA1:
                case Token.SHA224:
                case Token.SHA256:
                case Token.SHA384:
                case Token.SHA512:
                case Token.STR:
                case Token.STRAFTER:
                case Token.STRBEFORE:
                case Token.CONTAINS:
                case Token.STRDT:
                case Token.STRENDS:
                case Token.STRLANG:
                case Token.STRLEN:
                case Token.STRSTARTS:
                case Token.STRUUID:
                case Token.SUBSTR:
                case Token.TIMEZONE:
                case Token.TZ:
                case Token.UCASE:
                case Token.URIFUNC:
                case Token.UUID:
                case Token.YEAR:
                    if (_syntax == SparqlQuerySyntax.Sparql_1_0 && SparqlSpecsHelper.IsFunctionKeyword11(next.Value)) throw Error("The function " + next.Value + " is not supported in SPARQL 1.0", next);
                    return TryParseBuiltInCall(tokens);

                case Token.AVG:
                case Token.COUNT:
                case Token.GROUPCONCAT:
                case Token.MAX:
                case Token.MEDIAN:
                case Token.MIN:
                case Token.MODE:
                case Token.NMAX:
                case Token.NMIN:
                case Token.SAMPLE:
                case Token.SUM:
                    if (_allowAggregates)
                    {
                        return TryParseAggregateExpression(tokens);
                    }
                    else
                    {
                        throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, Aggregates are not permitted in this Expression or you have attempted to nest aggregates", next);
                    }

                case Token.URI:
                case Token.QNAME:
                    return TryParseIriRefOrFunction(tokens);

                case Token.LITERAL:
                case Token.LONGLITERAL:
                    return TryParseRdfLiteral(tokens);
                    
                case Token.PLAINLITERAL:
                    return TryParseBooleanOrNumericLiteral(tokens);

                case Token.VARIABLE:
                    tokens.Dequeue();
                    return new VariableTerm(next.Value);

                default:
                    throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Primary Expression",next);
            }
        }

        private ISparqlExpression TryParseBrackettedExpression(Queue<IToken> tokens)
        {
            return TryParseBrackettedExpression(tokens, true);
        }

        private ISparqlExpression TryParseBrackettedExpression(Queue<IToken> tokens, bool requireOpeningLeftBracket)
        {
            bool temp = false;
            return TryParseBrackettedExpression(tokens, requireOpeningLeftBracket, out temp);
        }

        private ISparqlExpression TryParseBrackettedExpression(Queue<IToken> tokens, bool requireOpeningLeftBracket, out bool commaTerminated)
        {
            bool temp = false;
            return TryParseBrackettedExpression(tokens, requireOpeningLeftBracket, out commaTerminated, out temp);
        }

        private ISparqlExpression TryParseBrackettedExpression(Queue<IToken> tokens, bool requireOpeningLeftBracket, out bool commaTerminated, out bool semicolonTerminated)
        {
            IToken next;

            commaTerminated = false;
            semicolonTerminated = false;

            // Discard the Opening Bracket
            if (requireOpeningLeftBracket)
            {
                next = tokens.Dequeue();
                if (next.TokenType != Token.LEFTBRACKET)
                {
                    throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Left Bracket to start a Bracketted Expression",next);
                }
            }

            int openBrackets = 1;
            Queue<IToken> exprTerms = new Queue<IToken>();

            while (openBrackets > 0)
            {
                // Get next Token
                next = tokens.Peek();

                // Take account of nesting
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    openBrackets++;
                }
                else if (next.TokenType == Token.RIGHTBRACKET)
                {
                    openBrackets--;
                }
                else if (next.TokenType == Token.COMMA && openBrackets == 1)
                {
                    openBrackets--;
                    commaTerminated = true;
                }
                else if (next.TokenType == Token.SEMICOLON && openBrackets == 1)
                {
                    openBrackets--;
                    semicolonTerminated = true;
                }
                else if (next.TokenType == Token.DISTINCT && openBrackets == 1)
                {
                    // DISTINCT can terminate the Tokens that make an expression if it occurs as the first thing and only 1 bracket is open
                    if (tokens.Count == 0)
                    {
                        tokens.Dequeue();
                        commaTerminated = true;
                        return new DistinctModifier();
                    }
                    else
                    {
                        throw Error("Unexpected DISTINCT Keyword Token encountered, DISTINCT modifier keyword may only occur as the first argument to an aggregate function", next);
                    }
                }

                if (openBrackets > 0)
                {
                    exprTerms.Enqueue(next);
                }
                tokens.Dequeue();
            }

            if (exprTerms.Count > 0)
            {
                // Recurse to invoke self
                return Parse(exprTerms);
            }
            else
            {
                return null;
            }
        }

        private ISparqlExpression TryParseBuiltInCall(Queue<IToken> tokens)
        {
            IToken next = tokens.Dequeue();
            bool comma = false, first = true;
            List<ISparqlExpression> args;
            ISparqlExpression strExpr;

            switch (next.TokenType)
            {
                case Token.ABS:
                    return new AbsFunction(TryParseBrackettedExpression(tokens));
                case Token.BNODE:
                    return new BNodeFunction(TryParseBrackettedExpression(tokens));                

                case Token.BOUND:
                    // Expect a Left Bracket, Variable and then a Right Bracket
                    next = tokens.Dequeue();
                    if (next.TokenType == Token.LEFTBRACKET)
                    {
                        next = tokens.Dequeue();
                        if (next.TokenType == Token.VARIABLE)
                        {
                            VariableTerm varExpr = new VariableTerm(next.Value);
                            next = tokens.Dequeue();
                            if (next.TokenType == Token.RIGHTBRACKET)
                            {
                                return new BoundFunction(varExpr);
                            }
                            else
                            {
                                throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, a Right Bracket to end a BOUND function call was expected",next);
                            }
                        }
                        else
                        {
                            throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, a Variable Token for a BOUND function call was expected", next);
                        }
                    }
                    else
                    {
                        throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, a Left Bracket to start a BOUND function call was expected", next);
                    }

                case Token.CALL:
                    if (_syntax != SparqlQuerySyntax.Extended) throw Error("The CALL keyword is only valid when using SPARQL 1.1 Extended syntax", next);
                    args = new List<ISparqlExpression>();
                    do
                    {
                        args.Add(TryParseBrackettedExpression(tokens, first, out comma));
                        first = false;
                    } while (comma);

                    return new CallFunction(args);

                case Token.CEIL:
                    return new CeilFunction(TryParseBrackettedExpression(tokens));

                case Token.COALESCE:
                    // Get as many argument expressions as we can
                    args = new List<ISparqlExpression>();
                    do
                    {
                        args.Add(TryParseBrackettedExpression(tokens, first, out comma));
                        first = false;
                    } while (comma);

                    return new CoalesceFunction(args);

                case Token.CONCAT:
                    // Get as many argument expressions as we can
                    args = new List<ISparqlExpression>();
                    do
                    {
                        args.Add(TryParseBrackettedExpression(tokens, first, out comma));
                        first = false;
                    } while (comma);

                    return new ConcatFunction(args);

                case Token.CONTAINS:
                    return new ContainsFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.DATATYPEFUNC:
                    if (_syntax == SparqlQuerySyntax.Sparql_1_0)
                    {
                        return new DataTypeFunction(TryParseBrackettedExpression(tokens));
                    }
                    else
                    {
                        return new DataType11Function(TryParseBrackettedExpression(tokens));
                    }
                case Token.DAY:
                    return new DayFunction(TryParseBrackettedExpression(tokens));
                case Token.ENCODEFORURI:
                    return new EncodeForUriFunction(TryParseBrackettedExpression(tokens));
                case Token.FLOOR:
                    return new FloorFunction(TryParseBrackettedExpression(tokens));
                case Token.HOURS:
                    return new HoursFunction(TryParseBrackettedExpression(tokens));
                case Token.IF:
                    return new IfElseFunction(TryParseBrackettedExpression(tokens, true, out comma), TryParseBrackettedExpression(tokens, false, out comma), TryParseBrackettedExpression(tokens, false, out comma));
                case Token.IRI:
                case Token.URIFUNC:
                    return new IriFunction(TryParseBrackettedExpression(tokens));
                case Token.ISBLANK:
                    return new IsBlankFunction(TryParseBrackettedExpression(tokens));
                case Token.ISIRI:
                    return new IsIriFunction(TryParseBrackettedExpression(tokens));
                case Token.ISLITERAL:
                    return new IsLiteralFunction(TryParseBrackettedExpression(tokens));
                case Token.ISNUMERIC:
                    return new IsNumericFunction(TryParseBrackettedExpression(tokens));
                case Token.ISURI:
                    return new IsUriFunction(TryParseBrackettedExpression(tokens));
                case Token.LANG:
                    return new LangFunction(TryParseBrackettedExpression(tokens));
                case Token.LANGMATCHES:
                    return new LangMatchesFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.LCASE:
                    return new LCaseFunction(TryParseBrackettedExpression(tokens));
                case Token.MD5:
                    return new MD5HashFunction(TryParseBrackettedExpression(tokens));
                case Token.MINUTES:
                    return new MinutesFunction(TryParseBrackettedExpression(tokens));
                case Token.MONTH:
                    return new MonthFunction(TryParseBrackettedExpression(tokens));

                case Token.NOW:
                    // Expect a () after the Keyword Token
                    TryParseNoArgs(tokens, "NOW");
                    return new NowFunction();

                case Token.RAND:
                    // Expect a () after the Keyword Token
                    TryParseNoArgs(tokens, "RAND");
                    return new RandFunction();

                case Token.REGEX:
                    return TryParseRegexExpression(tokens);
                case Token.REPLACE:
                    // REPLACE may have 3/4 arguments
                    strExpr = TryParseBrackettedExpression(tokens);
                    ISparqlExpression patternExpr = TryParseBrackettedExpression(tokens, false);
                    ISparqlExpression replaceExpr = TryParseBrackettedExpression(tokens, false, out comma);
                    if (comma)
                    {
                        ISparqlExpression opsExpr = TryParseBrackettedExpression(tokens, false);
                        return new ReplaceFunction(strExpr, patternExpr, replaceExpr, opsExpr);
                    }
                    else
                    {
                        return new ReplaceFunction(strExpr, patternExpr, replaceExpr);
                    }
                case Token.ROUND:
                    return new RoundFunction(TryParseBrackettedExpression(tokens));
                case Token.SAMETERM:
                    return new SameTermFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.SECONDS:
                    return new SecondsFunction(TryParseBrackettedExpression(tokens));
                case Token.SHA1:
                    return new Sha1HashFunction(TryParseBrackettedExpression(tokens));
                case Token.SHA256:
                    return new Sha256HashFunction(TryParseBrackettedExpression(tokens));
                case Token.SHA384:
                    return new Sha384HashFunction(TryParseBrackettedExpression(tokens));
                case Token.SHA512:
                    return new Sha512HashFunction(TryParseBrackettedExpression(tokens));
                case Token.STR:
                    return new StrFunction(TryParseBrackettedExpression(tokens));
                case Token.STRAFTER:
                    return new StrAfterFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRBEFORE:
                    return new StrBeforeFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRDT:
                    return new StrDtFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRENDS:
                    return new StrEndsFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRLANG:
                    return new StrLangFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRLEN:
                    return new StrLenFunction(TryParseBrackettedExpression(tokens));
                case Token.STRSTARTS:
                    return new StrStartsFunction(TryParseBrackettedExpression(tokens), TryParseBrackettedExpression(tokens, false));
                case Token.STRUUID:
                    TryParseNoArgs(tokens, "STRUUID");
                    return new StrUUIDFunction();

                case Token.SUBSTR:
                    // SUBSTR may have 2/3 arguments
                    strExpr = TryParseBrackettedExpression(tokens);
                    ISparqlExpression startExpr = TryParseBrackettedExpression(tokens, false, out comma);
                    if (comma)
                    {
                        ISparqlExpression lengthExpr = TryParseBrackettedExpression(tokens, false);
                        return new SubStrFunction(strExpr, startExpr, lengthExpr);
                    }
                    else
                    {
                        return new SubStrFunction(strExpr, startExpr);
                    }

                case Token.TIMEZONE:
                    return new TimezoneFunction(TryParseBrackettedExpression(tokens));
                case Token.TZ:
                    return new TZFunction(TryParseBrackettedExpression(tokens));
                case Token.UCASE:
                    return new UCaseFunction(TryParseBrackettedExpression(tokens));
                case Token.UUID:
                    TryParseNoArgs(tokens, "UUID");
                    return new UUIDFunction();
                case Token.YEAR:
                    return new YearFunction(TryParseBrackettedExpression(tokens));

                case Token.EXISTS:
                case Token.NOTEXISTS:
                    if (_syntax == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("EXISTS/NOT EXISTS clauses are not supported in SPARQL 1.0");
                    if (_parser == null) throw new RdfParseException("Unable to parse an EXISTS/NOT EXISTS as there is no Query Parser to call into");

                    // Gather Tokens for the Pattern
                    NonTokenisedTokenQueue temptokens = new NonTokenisedTokenQueue();
                    int openbrackets = 0;
                    bool mustExist = (next.TokenType == Token.EXISTS);
                    do
                    {
                        if (tokens.Count == 0) throw new RdfParseException("Unexpected end of Tokens while trying to parse an EXISTS/NOT EXISTS function");

                        next = tokens.Dequeue();
                        if (next.TokenType == Token.LEFTCURLYBRACKET)
                        {
                            openbrackets++;
                        }
                        else if (next.TokenType == Token.RIGHTCURLYBRACKET)
                        {
                            openbrackets--;
                        }
                        temptokens.Enqueue(next);
                    } while (openbrackets > 0);

                    // Call back into the Query Parser to try and Parse the Graph Pattern for the Function
                    SparqlQueryParserContext tempcontext = new SparqlQueryParserContext(temptokens);
                    tempcontext.Query.NamespaceMap.Import(_nsmapper);
                    tempcontext.Query.BaseUri = _baseUri;
                    return new ExistsFunction(_parser.TryParseGraphPattern(tempcontext, true), mustExist);

                default:
                    throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered while trying to parse a Built-in Function call", next);
            }
        }

        private void TryParseNoArgs(Queue<IToken> tokens, String function)
        {
            IToken next = tokens.Dequeue();
            if (next.TokenType != Token.LEFTBRACKET) throw Error("Expected a Left Bracket after a " + function + " keyword to call the " + function + "() function", next);
            next = tokens.Dequeue();
            if (next.TokenType != Token.RIGHTBRACKET) throw Error("Expected a Right Bracket after " + function + "( since the " + function + "() function does not take any arguments", next);
        }

        private ISparqlExpression TryParseRegexExpression(Queue<IToken> tokens)
        {
            bool hasOptions = false;

            // Get Text and Pattern Expressions
            ISparqlExpression textExpr = TryParseBrackettedExpression(tokens);
            ISparqlExpression patternExpr = TryParseBrackettedExpression(tokens, false, out hasOptions);

            // Check whether we need to get an Options Expression
            if (hasOptions)
            {
                ISparqlExpression optionExpr = TryParseBrackettedExpression(tokens, false);
                return new RegexFunction(textExpr, patternExpr, optionExpr);
            }
            else
            {
                return new RegexFunction(textExpr, patternExpr);
            }
        }

        private ISparqlExpression TryParseIriRefOrFunction(Queue<IToken> tokens)
        {
            // Get the Uri/QName Token
            IToken first = tokens.Dequeue();

            // Resolve the Uri
            Uri u;
            if (first.TokenType == Token.QNAME)
            {
                // Resolve QName
                u = UriFactory.Create(Tools.ResolveQName(first.Value, _nsmapper, _baseUri));
            }
            else
            {
                u = UriFactory.Create(Tools.ResolveUri(first.Value, _baseUri.ToSafeString()));
            }
            
            // Get the Argument List (if any)
            if (tokens.Count > 0)
            {
                IToken next = tokens.Peek();
                if (next.TokenType == Token.LEFTBRACKET)
                {
                    bool comma = false, semicolon = false;
                    List<ISparqlExpression> args = new List<ISparqlExpression>();
                    args.Add(TryParseBrackettedExpression(tokens, true, out comma, out semicolon));

                    while (comma && !semicolon)
                    {
                        args.Add(TryParseBrackettedExpression(tokens, false, out comma, out semicolon));
                    }

                    // If there are no arguments (one null argument) then discard
                    if (args.Count == 1 && args.First() == null) args.Clear();

                    // Check whether we need to parse Scalar Arguments
                    Dictionary<String, ISparqlExpression> scalarArgs = null;
                    if (semicolon)
                    {
                        if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("Arguments List terminated by a Semicolon - Arbitrary Scalar Arguments for Extension Functions/Aggregates are not permitted in SPARQL 1.1");
                        scalarArgs = TryParseScalarArguments(first, tokens);
                    }

                    // Return an Extension Function expression
                    ISparqlExpression expr = SparqlExpressionFactory.CreateExpression(u, args, _factories);
                    if (expr is AggregateTerm)
                    {
                        if (!_allowAggregates) throw new RdfParseException("Aggregate Expression '" + expr.ToString() + "' encountered but aggregates are not permitted in this Expression");
                    }
                    return expr;
                }
                else
                {
                    // Just an IRIRef
                    return new ConstantTerm(new UriNode(null, u));
                }
            }
            else
            {
                // Just an IRIRef
                return new ConstantTerm(new UriNode(null, u));
            }
        }

        private ISparqlExpression TryParseRdfLiteral(Queue<IToken> tokens)
        {
            // First Token will be the String value of this RDF Literal
            IToken str = tokens.Dequeue();

            // Might have a Language Specifier/DataType afterwards
            if (tokens.Count > 0)
            {
                IToken next = tokens.Peek();
                if (next.TokenType == Token.LANGSPEC)
                {
                    tokens.Dequeue();
                    return new ConstantTerm(new LiteralNode(null, str.Value, next.Value));
                }
                else if (next.TokenType == Token.HATHAT)
                {
                    tokens.Dequeue();

                    // Should be a DataTypeToken afterwards
                    next = tokens.Dequeue();
                    LiteralWithDataTypeToken dtlit = new LiteralWithDataTypeToken(str, (DataTypeToken)next); ;
                    Uri u;

                    if (next.Value.StartsWith("<"))
                    {
                        u = UriFactory.Create(next.Value.Substring(1, next.Value.Length - 2));
                    }
                    else
                    {
                        // Resolve the QName
                        u = UriFactory.Create(Tools.ResolveQName(next.Value, _nsmapper, _baseUri));
                    }

                    if (SparqlSpecsHelper.GetNumericTypeFromDataTypeUri(u) != SparqlNumericType.NaN)
                    {
                        // Should be a Number
                        return TryParseNumericLiteral(dtlit, tokens, false);
                    }
                    else if (XmlSpecsHelper.XmlSchemaDataTypeBoolean.Equals(u.AbsoluteUri))
                    {
                        // Appears to be a Boolean
                        bool b;
                        if (Boolean.TryParse(dtlit.Value, out b))
                        {
                            return new ConstantTerm(new BooleanNode(null, b));
                        }
                        else
                        {
                            return new ConstantTerm(new StringNode(null, dtlit.Value, dtlit.DataType));
                        }
                    }
                    else
                    {
                        // Just a datatyped Literal Node
                        return new ConstantTerm(new LiteralNode(null, str.Value, u));
                    }
                }
                else
                {
                    return new ConstantTerm(new LiteralNode(null, str.Value));
                }
            }
            else
            {
                return new ConstantTerm(new LiteralNode(null, str.Value));
            }

        }

        private ISparqlExpression TryParseBooleanOrNumericLiteral(Queue<IToken> tokens)
        {
            // First Token must be a Plain Literal
            IToken lit = tokens.Dequeue();

            if (lit.Value.Equals("true"))
            {
                return new ConstantTerm(new BooleanNode(null, true));
            }
            else if (lit.Value.Equals("false"))
            {
                return new ConstantTerm(new BooleanNode(null, false));
            }
            else
            {
                return TryParseNumericLiteral(lit, tokens, true);
            }
        }

        private ISparqlExpression TryParseNumericLiteral(IToken literal, Queue<IToken> tokens, bool requireValidLexicalForm)
        {
            switch (literal.TokenType)
            {
                case Token.PLAINLITERAL:
                    // Use Regular Expressions to see what type it is
                    if (SparqlSpecsHelper.IsInteger(literal.Value))
                    {
                        return new ConstantTerm(new LongNode(null, Int64.Parse(literal.Value)));
                    }
                    else if (SparqlSpecsHelper.IsDecimal(literal.Value))
                    {
                        return new ConstantTerm(new DecimalNode(null, Decimal.Parse(literal.Value, NumberStyles.Any, CultureInfo.InvariantCulture)));
                    }
                    else if (SparqlSpecsHelper.IsDouble(literal.Value))
                    {
                        return new ConstantTerm(new DoubleNode(null, Double.Parse(literal.Value, NumberStyles.Any, CultureInfo.InvariantCulture)));
                    }
                    else
                    {
                        throw Error("The Plain Literal '" + literal.Value + "' is not a valid Integer, Decimal or Double", literal);
                    }
                    
                case Token.LITERALWITHDT:
                    // Get the Data Type Uri
                    String dt = ((LiteralWithDataTypeToken)literal).DataType;
                    String dtUri;
                    if (dt.StartsWith("<"))
                    {
                        String baseUri = (_baseUri == null) ? String.Empty : _baseUri.AbsoluteUri;
                        dtUri = Tools.ResolveUri(dt.Substring(1, dt.Length - 2), baseUri);
                    }
                    else
                    {
                        dtUri = Tools.ResolveQName(dt, _nsmapper, _baseUri);
                    }

                    // Try to return a numeric expression, enforce the need for a valid numeric value where relevant
                    LiteralNode lit = new LiteralNode(null, literal.Value, UriFactory.Create(dtUri));
                    IValuedNode value = lit.AsValuedNode();
                    if (requireValidLexicalForm && value.NumericType == SparqlNumericType.NaN)
                    {
                        throw Error("The Literal '" + literal.Value + "' with Datatype URI '" + dtUri + "' is not a valid Integer, Decimal or Double", literal);
                    }
                    else
                    {
                        return new ConstantTerm(value);
                    }
                    
                case Token.LITERAL:
                    // Check if there's a Datatype following the Literal
                    if (tokens.Count > 0)
                    {
                        IToken next = tokens.Peek();
                        if (next.TokenType == Token.HATHAT)
                        {
                            tokens.Dequeue();
                            // Should now see a DataTypeToken
                            DataTypeToken datatype = (DataTypeToken)tokens.Dequeue();
                            LiteralWithDataTypeToken dtlit = new LiteralWithDataTypeToken(literal, datatype);

                            // Self-recurse to save replicating code
                            return TryParseNumericLiteral(dtlit, tokens, true);
                        }
                    }
                    // Use Regex to see if it's a Integer/Decimal/Double
                    if (SparqlSpecsHelper.IsInteger(literal.Value))
                    {
                        return new ConstantTerm(new LongNode(null, Int64.Parse(literal.Value)));
                    }
                    else if (SparqlSpecsHelper.IsDecimal(literal.Value))
                    {
                        return new ConstantTerm(new DecimalNode(null, Decimal.Parse(literal.Value)));
                    }
                    else if (SparqlSpecsHelper.IsDouble(literal.Value))
                    {
                        return new ConstantTerm(new DoubleNode(null, Double.Parse(literal.Value)));
                    }
                    else
                    {
                        // Otherwise treat as a Node Expression
                        throw Error("The Literal '" + literal.Value + "' is not a valid Integer, Decimal or Double", literal);
                    }

                default:
                    throw Error("Unexpected Token '" + literal.GetType().ToString() + "' encountered while trying to parse a Numeric Literal", literal);
            }
        }

        private ISparqlExpression TryParseAggregateExpression(Queue<IToken> tokens)
        {
            if (_syntax == SparqlQuerySyntax.Sparql_1_0) throw new RdfParseException("Aggregates are not permitted in SPARQL 1.0");

            IToken agg = tokens.Dequeue();
            ISparqlExpression aggExpr = null;
            bool distinct = false, all = false;
            bool scalarArgs = false;

            // Turn off aggregate allowance since aggregates may not be nested
            bool aggsAllowed = _allowAggregates;
            _allowAggregates = false;

            // Expect a Left Bracket next
            IToken next = tokens.Dequeue();
            if (next.TokenType != Token.LEFTBRACKET)
            {
                throw Error("Unexpected Token '" + next.GetType().ToString() + "', expected a Left Bracket after an Aggregate Keyword", next);
            }

            // Then a possible DISTINCT/ALL
            next = tokens.Peek();
            if (next.TokenType == Token.DISTINCT)
            {
                distinct = true;
                tokens.Dequeue();
            }
            next = tokens.Peek();
            if (next.TokenType == Token.ALL || next.TokenType == Token.MULTIPLY)
            {
                all = true;
                tokens.Dequeue();
            }
            next = tokens.Peek();

            // If we've seen an ALL then we need the closing bracket
            if (all && next.TokenType != Token.RIGHTBRACKET)
            {
                throw Error("Unexpected Token '" + next.GetType().ToString() + "', expected a Right Bracket after the * specifier in an aggregate to terminate the aggregate", next);
            }
            else if (all && agg.TokenType != Token.COUNT)
            {
                throw new RdfQueryException("Cannot use the * specifier in aggregates other than COUNT");
            }
            else if (!all)
            {
                // If it's not an all then we expect some expression(s)
                // Gather the Tokens and parse the Expression
                Queue<IToken> subtokens = new Queue<IToken>();

                int openBrackets = 1;
                List<ISparqlExpression> expressions = new List<ISparqlExpression>();

                while (openBrackets > 0)
                {
                    subtokens = new Queue<IToken>();
                    next = tokens.Dequeue();
                    do
                    {
                        if (next.TokenType == Token.LEFTBRACKET)
                        {
                            openBrackets++;
                        }
                        else if (next.TokenType == Token.RIGHTBRACKET)
                        {
                            openBrackets--;
                        }
                        else if (next.TokenType == Token.COMMA)
                        {
                            // If we see a comma when we only have 1 bracket open then it is separating argument expressions
                            if (openBrackets == 1)
                            {
                                break;
                            }
                        }
                        else if (next.TokenType == Token.SEMICOLON)
                        {
                            // If we see a semicolon when we only have 1 bracket open then this indicates we have scalar arguments in-use
                            if (openBrackets == 1)
                            {
                                scalarArgs = true;
                                break;
                            }
                        }

                        if (openBrackets > 0)
                        {
                            subtokens.Enqueue(next);
                            next = tokens.Dequeue();
                        }
                    } while (openBrackets > 0);

                    // Parse this expression and add to the list of expressions we're concatenating
                    expressions.Add(Parse(subtokens));

                    // Once we've hit the ; for the scalar arguments then we can stop looking for expressions
                    if (scalarArgs) break;

                    // If we've hit a , then openBrackets will still be one and we'll go around again looking for another expression
                    // Otherwise we've reached the end of the aggregate and there was no ; for scalar arguments
                }

                if (expressions.Count == 0) throw new RdfParseException("Aggregate must have at least one argument expression unless they are a COUNT(*)");
                if (expressions.Count > 1) throw new RdfParseException("The " + agg.Value + " aggregate does not support more than one argument expression");
                aggExpr = expressions.First();
            }
            else
            {
                tokens.Dequeue();
            }

            // If the aggregate uses scalar arguments then we'll parse them here
            Dictionary<String, ISparqlExpression> scalarArguments = new Dictionary<string, ISparqlExpression>();
            if (scalarArgs)
            {
                scalarArguments = TryParseScalarArguments(agg, tokens);
            }

            // Reset Aggregate Allowance
            _allowAggregates = aggsAllowed;

            // Now we need to generate the actual expression
            switch (agg.TokenType)
            {
                case Token.AVG:
                    // AVG Aggregate
                    if (aggExpr is VariableTerm variableTerm)
                    {
                        return new AggregateTerm(new AverageAggregate(variableTerm, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new AverageAggregate(aggExpr, distinct));
                    }

                case Token.COUNT:
                    // COUNT Aggregate
                    if (all)
                    {
                        if (distinct)
                        {
                            return new AggregateTerm(new CountAllDistinctAggregate());
                        }
                        else
                        {
                            return new AggregateTerm(new CountAllAggregate());
                        }
                    }
                    else if (aggExpr is VariableTerm variableTerm)
                    {
                        if (distinct)
                        {
                            return new AggregateTerm(new CountDistinctAggregate(variableTerm));
                        }
                        else
                        {
                            return new AggregateTerm(new CountAggregate((VariableTerm)aggExpr));
                        }
                    }
                    else
                    {
                        if (distinct)
                        {
                            return new AggregateTerm(new CountDistinctAggregate(aggExpr));
                        }
                        else
                        {
                            return new AggregateTerm(new CountAggregate(aggExpr));
                        }
                    }
                case Token.GROUPCONCAT:
                    if (scalarArgs)
                    {
                        if (!scalarArguments.ContainsKey(SparqlSpecsHelper.SparqlKeywordSeparator)) throw new RdfParseException("The GROUP_CONCAT aggregate has Scalar Arguments but does not have the expected SEPARATOR argument");
                        return new AggregateTerm(new GroupConcatAggregate(aggExpr, scalarArguments[SparqlSpecsHelper.SparqlKeywordSeparator], distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new GroupConcatAggregate(aggExpr, distinct));
                    }

                case Token.MAX:
                    // MAX Aggregate
                    if (aggExpr is VariableTerm variableTerm)
                    {
                        return new AggregateTerm(new MaxAggregate(variableTerm, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new MaxAggregate(aggExpr, distinct));
                    }

                case Token.MEDIAN:
                    // MEDIAN Aggregate
                    if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("The MEDIAN aggregate is only supported when the Syntax is set to Extended.");
                    if (aggExpr is VariableTerm variableTerm)
                    {
                        return new AggregateTerm(new MedianAggregate(variableTerm, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new MedianAggregate(aggExpr, distinct));
                    }

                case Token.MIN:
                    // MIN Aggregate
                    if (aggExpr is VariableTerm variableTerm)
                    {
                        return new AggregateTerm(new MinAggregate(variableTerm, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new MinAggregate(aggExpr, distinct));
                    }

                case Token.MODE:
                    // MODE Aggregate
                    if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("The MODE aggregate is only supported when the Syntax is set to Extended.");
                    if (aggExpr is VariableTerm variableTerm)
                    {
                        return new AggregateTerm(new ModeAggregate(variableTerm, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new ModeAggregate(aggExpr, distinct));
                    }

                case Token.NMAX:
                    // NMAX Aggregate
                    if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("The NMAX (Numeric Maximum) aggregate is only supported when the Syntax is set to Extended.  To achieve an equivalent result in SPARQL 1.0/1.1 apply a FILTER to your query so the aggregated variable is only literals of the desired numeric type");
                    if (aggExpr is VariableTerm variableTerm)
                    {
                        return new AggregateTerm(new NumericMaxAggregate(variableTerm, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new NumericMaxAggregate(aggExpr, distinct));
                    }

                case Token.NMIN:
                    // NMIN Aggregate
                    if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("The NMIN (Numeric Minimum) aggregate is only supported when the Syntax is set to Extended.  To achieve an equivalent result in SPARQL 1.0/1.1 apply a FILTER to your query so the aggregated variable is only literals of the desired numeric type");
                    if (aggExpr is VariableTerm variableTerm)
                    {
                        return new AggregateTerm(new NumericMinAggregate(variableTerm, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new NumericMinAggregate(aggExpr, distinct));
                    }

                case Token.SAMPLE:
                    // SAMPLE Aggregate
                    if (distinct) throw new RdfParseException("DISTINCT modifier is not valid for the SAMPLE aggregate");
                    return new AggregateTerm(new SampleAggregate(aggExpr));

                case Token.SUM:
                    // SUM Aggregate
                    if (aggExpr is VariableTerm variableTerm)
                    {
                        return new AggregateTerm(new SumAggregate(variableTerm, distinct));
                    }
                    else
                    {
                        return new AggregateTerm(new SumAggregate(aggExpr, distinct));
                    }

                default:
                    // Should have already handled this but have to have it to keep the compiler happy
                    throw Error("Cannot parse an Aggregate since '" + agg.GetType().ToString() + "' is not an Aggregate Keyword Token", agg);
            }
        }

        private Dictionary<String, ISparqlExpression> TryParseScalarArguments(IToken funcToken, Queue<IToken> tokens)
        {
            // Parse the Scalar Arguments
            Dictionary<String, ISparqlExpression> scalarArguments = new Dictionary<string, ISparqlExpression>();
            IToken next;
            Queue<IToken> subtokens = new Queue<IToken>();
            int openBrackets = 1;

            while (openBrackets > 0)
            {
                // First expect a Keyword/QName/URI for the Scalar Argument Name
                String argName;
                next = tokens.Peek();
                switch (next.TokenType)
                {
                    case Token.SEPARATOR:
                        if (funcToken.TokenType == Token.GROUPCONCAT)
                        {
                            // OK
                            argName = SparqlSpecsHelper.SparqlKeywordSeparator;
                        }
                        else
                        {
                            throw Error("The SEPARATOR scalar argument is only valid with the GROUP_CONCAT aggregate", next);
                        }
                        break;

                    case Token.QNAME:
                    case Token.URI:
                        if (_syntax != SparqlQuerySyntax.Extended) throw new RdfParseException("Arbitrary Scalar Arguments for Aggregates are not permitted in SPARQL 1.1");

                        // Resolve QName/URI
                        if (next.TokenType == Token.QNAME)
                        {
                            argName = Tools.ResolveQName(next.Value, _nsmapper, _baseUri);
                        }
                        else
                        {
                            argName = Tools.ResolveUri(next.Value, _baseUri.ToSafeString());
                        }
                        break;

                    default:
                        throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a Keyword/QName/URI for the Scalar Argument Name", next);
                }
                tokens.Dequeue();

                // After the Argument Name need an =
                next = tokens.Peek();
                if (next.TokenType != Token.EQUALS)
                {
                    throw Error("Unexpected Token '" + next.GetType().ToString() + "' encountered, expected a = after a Scalar Argument name in an aggregate", next);
                }
                tokens.Dequeue();

                // Get the subtokens for the Argument Expression
                next = tokens.Dequeue();
                do
                {
                    if (next.TokenType == Token.LEFTBRACKET)
                    {
                        openBrackets++;
                    }
                    else if (next.TokenType == Token.RIGHTBRACKET)
                    {
                        openBrackets--;
                    }
                    else if (next.TokenType == Token.COMMA)
                    {
                        // If we see a COMMA and there is only 1 bracket open then expect another argument
                        if (openBrackets == 1)
                        {
                            break;
                        }
                    }

                    // If not the end bracket then add it to the subtokens
                    if (openBrackets > 0)
                    {
                        subtokens.Enqueue(next);
                        next = tokens.Dequeue();
                    }
                } while (openBrackets > 0);

                // Parse the Subtokens into the Argument Expression
                if (scalarArguments.ContainsKey(argName))
                {
                    scalarArguments[argName] = Parse(subtokens);
                }
                else
                {
                    scalarArguments.Add(argName, Parse(subtokens));
                }
            }

            return scalarArguments;
        }

        private ISparqlExpression TryParseSetExpression(ISparqlExpression expr, Queue<IToken> tokens)
        {
            IToken next = tokens.Dequeue();
            bool inSet = (next.TokenType == Token.IN);
            List<ISparqlExpression> expressions = new List<ISparqlExpression>();

            // Expecting a ( afterwards
            next = tokens.Dequeue();
            if (next.TokenType == Token.LEFTBRACKET)
            {
                next = tokens.Peek();

                if (next.TokenType == Token.RIGHTBRACKET)
                {
                    tokens.Dequeue();
                } 
                else
                {
                    bool comma = false;
                    expressions.Add(TryParseBrackettedExpression(tokens, false, out comma));
                    while (comma)
                    {
                        expressions.Add(TryParseBrackettedExpression(tokens, false, out comma));
                    }
                }
            }
            else
            {
                throw Error("Expected a left bracket to start the set of values for an IN/NOT IN expression", next);
            }

            if (inSet)
            {
                return new InFunction(expr, expressions);
            }
            else
            {
                return new NotInFunction(expr, expressions);
            }
        }

        /// <summary>
        /// Helper method for raising informative standardised Parser Errors.
        /// </summary>
        /// <param name="msg">The Error Message.</param>
        /// <param name="t">The Token that is the cause of the Error.</param>
        /// <returns></returns>
        private RdfParseException Error(String msg, IToken t)
        {
            StringBuilder output = new StringBuilder();
            output.Append("[");
            output.Append(t.GetType().ToString());
            output.Append(" at Line ");
            output.Append(t.StartLine);
            output.Append(" Column ");
            output.Append(t.StartPosition);
            output.Append(" to Line ");
            output.Append(t.EndLine);
            output.Append(" Column ");
            output.Append(t.EndPosition);
            output.Append("]\n");
            output.Append(msg);

            return new RdfParseException(output.ToString(), t);
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLExpressionParser.cs(1265,54): error CS0136: A local or parameter named 'variableTerm' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLExpressionParser.cs(1300,49): error CS0128: A local variable or function named 'variableTerm' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLExpressionParser.cs(1312,49): error CS0128: A local variable or function named 'variableTerm' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLExpressionParser.cs(1323,49): error CS0128: A local variable or function named 'variableTerm' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLExpressionParser.cs(1335,49): error CS0128: A local variable or function named 'variableTerm' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLExpressionParser.cs(1347,49): error CS0128: A local variable or function named 'variableTerm' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLExpressionParser.cs(1359,49): error CS0128: A local variable or function named 'variableTerm' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLExpressionParser.cs(1375,49): error CS0128: A local variable or function named 'variableTerm' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF\Query\SPARQLExpressionParser.cs(1302,67): error CS0165: Use of unassigned local variable 'variableTerm'
######################################################################


######################################################################
Nr: 8 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\dotNetRDF\Shacl\Constraints\Select.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
namespace VDS.RDF.Shacl.Constraints
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using VDS.RDF.Nodes;
    using VDS.RDF.Query;
    using VDS.RDF.Query.Paths;
    using VDS.RDF.Query.Patterns;
    using VDS.RDF.Shacl.Paths;
    using VDS.RDF.Shacl.Validation;

    internal class Select : Sparql
    {
        [DebuggerStepThrough]
        internal Select(Shape shape, INode value)
            : base(shape, value)
        {
        }

        [DebuggerStepThrough]
        internal Select(Shape shape, INode value, IEnumerable<KeyValuePair<string, INode>> parameters)
            : base(shape, value, parameters)
        {
        }

        protected override string DefaultMessage => "SPARQL SELECT query must not return any result bindings.";

        protected override string Query
        {
            get
            {
                return Vocabulary.Select.ObjectsOf(this).Single().AsValuedNode().AsString();
            }
        }

        protected override bool ValidateInternal(INode focusNode, IEnumerable<INode> valueNodes, Report report, SparqlQuery query)
        {
            var propertyShape = Shape as Shapes.Property;

            if (propertyShape != null)
            {
                BindPath(query.RootGraphPattern, propertyShape.Path.SparqlPath);
            }

            var solutions = (SparqlResultSet)focusNode.Graph.ExecuteQuery(query);

            if (solutions.IsEmpty)
            {
                return true;
            }

            if (report is null)
            {
                return false;
            }

            foreach (var solution in solutions)
            {
                var result = Result.Create(report.Graph);
                result.FocusNode = solution["this"];

                if (solution.TryGetBoundValue("path", out var pathValue) && pathValue.NodeType == NodeType.Uri)
                {
                    result.ResultPath = new Predicate(pathValue);
                }
                else
                {
                    if (propertyShape != null)
                    {
                        result.ResultPath = propertyShape.Path;
                    }
                }

                if (solution.HasValue("value"))
                {
                    result.ResultValue = solution["value"];
                }
                else
                {
                    result.ResultValue = focusNode;
                }

                if (solution.HasValue("message"))
                {
                    result.Message = (ILiteralNode)solution["message"];
                }
                else
                {
                    result.Message = Message;
                }

                result.SourceConstraintComponent = ConstraintComponent;
                result.SourceShape = Shape;
                result.Severity = Shape.Severity;
                result.SourceConstraint = this;

                report.Results.Add(result);
            }

            return false;
        }

        private static void BindPath(GraphPattern pattern, ISparqlPath path)
        {
            for (var i = 0; i < pattern.TriplePatterns.Count(); i++)
            {
                if (pattern.TriplePatterns[i] is TriplePattern triplePattern && triplePattern.Predicate.VariableName == "PATH")
                {
                    pattern.TriplePatterns.RemoveAt(i);
                    pattern.TriplePatterns.Insert(i, new PropertyPathPattern(triplePattern.Subject, path, triplePattern.Object));
                }
            }

            foreach (var subPattern in pattern.ChildGraphPatterns)
            {
                BindPath(subPattern, path);
            }

            foreach (var subQueryPattern in pattern.TriplePatterns.OfType<SubQueryPattern>())
            {
                BindPath(subQueryPattern.SubQuery.RootGraphPattern, path);
            }
        }
    }
}
---- Transformed Tree ----
namespace VDS.RDF.Shacl.Constraints
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using VDS.RDF.Nodes;
    using VDS.RDF.Query;
    using VDS.RDF.Query.Paths;
    using VDS.RDF.Query.Patterns;
    using VDS.RDF.Shacl.Paths;
    using VDS.RDF.Shacl.Validation;

    internal class Select : Sparql
    {
        [DebuggerStepThrough]
        internal Select(Shape shape, INode value)
            : base(shape, value)
        {
        }

        [DebuggerStepThrough]
        internal Select(Shape shape, INode value, IEnumerable<KeyValuePair<string, INode>> parameters)
            : base(shape, value, parameters)
        {
        }

        protected override string DefaultMessage => "SPARQL SELECT query must not return any result bindings.";

        protected override string Query
        {
            get
            {
                return Vocabulary.Select.ObjectsOf(this).Single().AsValuedNode().AsString();
            }
        }

        protected override bool ValidateInternal(INode focusNode, IEnumerable<INode> valueNodes, Report report, SparqlQuery query)
        {
            if (Shape is Shapes.Property propertyShape)
            {
                BindPath(query.RootGraphPattern, propertyShape.Path.SparqlPath);
            }

            var solutions = (SparqlResultSet)focusNode.Graph.ExecuteQuery(query);

            if (solutions.IsEmpty)
            {
                return true;
            }

            if (report is null)
            {
                return false;
            }

            foreach (var solution in solutions)
            {
                var result = Result.Create(report.Graph);
                result.FocusNode = solution["this"];

                if (solution.TryGetBoundValue("path", out var pathValue) && pathValue.NodeType == NodeType.Uri)
                {
                    result.ResultPath = new Predicate(pathValue);
                }
                else
                {
                    if (Shape is Shapes.Property propertyShape)
                    {
                        result.ResultPath = propertyShape.Path;
                    }
                }

                if (solution.HasValue("value"))
                {
                    result.ResultValue = solution["value"];
                }
                else
                {
                    result.ResultValue = focusNode;
                }

                if (solution.HasValue("message"))
                {
                    result.Message = (ILiteralNode)solution["message"];
                }
                else
                {
                    result.Message = Message;
                }

                result.SourceConstraintComponent = ConstraintComponent;
                result.SourceShape = Shape;
                result.Severity = Shape.Severity;
                result.SourceConstraint = this;

                report.Results.Add(result);
            }

            return false;
        }

        private static void BindPath(GraphPattern pattern, ISparqlPath path)
        {
            for (var i = 0; i < pattern.TriplePatterns.Count(); i++)
            {
                if (pattern.TriplePatterns[i] is TriplePattern triplePattern && triplePattern.Predicate.VariableName == "PATH")
                {
                    pattern.TriplePatterns.RemoveAt(i);
                    pattern.TriplePatterns.Insert(i, new PropertyPathPattern(triplePattern.Subject, path, triplePattern.Object));
                }
            }

            foreach (var subPattern in pattern.ChildGraphPatterns)
            {
                BindPath(subPattern, path);
            }

            foreach (var subQueryPattern in pattern.TriplePatterns.OfType<SubQueryPattern>())
            {
                BindPath(subQueryPattern.SubQuery.RootGraphPattern, path);
            }
        }
    }
}
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF\Shacl\Constraints\Select.cs(93,50): error CS0136: A local or parameter named 'propertyShape' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 9 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\dotNetRDF\Writing\JsonLdWriter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json.Linq;
using VDS.RDF.JsonLd;
using VDS.RDF.JsonLd.Processors;
using VDS.RDF.JsonLd.Syntax;
using VDS.RDF.Parsing;

namespace VDS.RDF.Writing
{
    /// <summary>
    /// Class for serializing a Triple Store in JSON-LD syntax.
    /// </summary>
    public class JsonLdWriter : IStoreWriter
    {
        private readonly JsonLdWriterOptions _options;

        /// <summary>
        /// Create a new serializer with default serialization options.
        /// </summary>
        public JsonLdWriter()
        {
            _options = new JsonLdWriterOptions();
        }


        /// <summary>
        /// Create a new serializer with the specified serialization options.
        /// </summary>
        /// <param name="options"></param>
        public JsonLdWriter(JsonLdWriterOptions options)
        {
            _options = options;
        }

        /// <inheritdoc/>
        public void Save(ITripleStore store, string filename)
        {
            var jsonArray = SerializeStore(store);
            using (var writer = new StreamWriter(File.Open(filename, FileMode.Create, FileAccess.Write),
                Encoding.UTF8))
            {
                writer.Write(jsonArray);
            }
        }

        /// <inheritdoc/>
        public void Save(ITripleStore store, TextWriter output)
        {
            Save(store, output, false);
        }

        /// <inheritdoc/>
        public void Save(ITripleStore store, TextWriter output, bool leaveOpen)
        {
            var jsonArray = SerializeStore(store);
            output.Write(jsonArray.ToString(_options.JsonFormatting));
            output.Flush();
            if (!leaveOpen)
            {
                output.Close();
            }
        }

        /// <summary>
        /// Serialize a Triple Store to an expanded JSON-LD document.
        /// </summary>
        /// <param name="store"></param>
        /// <returns></returns>
        public JArray SerializeStore(ITripleStore store)
        {
            // 1 - Initialize default graph to an empty dictionary.
            var defaultGraph = new JObject();
            // 2 - Initialize graph map to a dictionary consisting of a single member @default whose value references default graph.
            var graphMap = new JObject(new JProperty("@default", defaultGraph));
            // 3 - Initialize referenced once to an empty map.
            var referencedOnce =new Dictionary<string, Usage>();
            // 4 - Initialize compound literal subjects to an empty map.
            var compoundLiteralSubjects = new JObject();
            // 5 - For each graph in RDF dataset:
            foreach (var graph in store.Graphs)
            {
                // 5.1 - If graph is the default graph, set name to @default, otherwise to the graph name associated with graph.
                string name = graph.BaseUri == null ? "@default" : graph.BaseUri.ToString();

                // 5.2 - If graph map has no name entry, create one and set its value to an empty map.
                if (!graphMap.ContainsKey(name))
                {
                    graphMap.Add(name, new JObject());
                }

                // 5.3 - If compound literal subjects has no name entry, create one and set its value to an empty map.
                if (!compoundLiteralSubjects.ContainsKey(name))
                {
                    compoundLiteralSubjects[name] = new JObject();
                }

                // 5.4 - If graph is not the default graph and default graph does not have a name entry,
                // create such an entry and initialize its value to a new map with a single entry @id whose value is name.
                if (name != "@default")
                {
                    if (!defaultGraph.ContainsKey(name))
                    {
                        defaultGraph.Add(name, new JObjectWithUsages(new JProperty("@id", name)));
                    }
                }

                // 5.5 - Reference the value of the name entry in graph map using the variable node map.
                var nodeMap = graphMap[name] as JObject;

                // 5.6 - Reference the value of the name entry in compound literal subjects using the variable compound map.
                var compoundMap = compoundLiteralSubjects[name];

                // 5.7 - For each triple in graph consisting of subject, predicate, and object:
                foreach (var triple in graph.Triples)
                {
                    var subject = MakeNodeString(triple.Subject);
                    var predicate = MakeNodeString(triple.Predicate);
                    var @object = triple.Object is IUriNode || triple.Object is IBlankNode ? MakeNodeString(triple.Object) : null;

                    // 5.7.1 - If node map does not have a subject entry, create one and initialize its value to a new map consisting of a single entry @id whose value is set to subject.
                    if (!nodeMap.ContainsKey(subject))
                    {
                        nodeMap.Add(subject, new JObjectWithUsages(new JProperty("@id", subject)));
                    }

                    // 5.7.2 - Reference the value of the subject entry in node map using the variable node.
                    var node = nodeMap[subject] as JObjectWithUsages;

                    // 5.7.3 - If the rdfDirection option is compound-literal and predicate is rdf:direction, add an entry in compound map for subject with the value true.
                    if (_options.RdfDirection.HasValue && _options.RdfDirection == JsonLdRdfDirectionMode.CompoundLiteral && RdfSpecsHelper.RdfDirection.Equals(predicate))
                    {
                        compoundMap[subject] = true;
                    }

                    // 5.7.4 - If object is an IRI or blank node identifier, and node map does not have an object entry,
                    // create one and initialize its value to a new map consisting of a single entry @id whose value is set
                    // to object.
                    if (triple.Object is IUriNode || triple.Object is IBlankNode)
                    {
                        if (!nodeMap.ContainsKey(@object))
                        {
                            nodeMap.Add(@object, new JObjectWithUsages(new JProperty("@id", @object)));
                        }
                    }

                    // 5.7.5 - If predicate equals rdf:type, the useRdfType flag is not true, and object is an IRI or blank node identifier
                    if (predicate.Equals(RdfSpecsHelper.RdfType) && !_options.UseRdfType &&
                        (triple.Object is IUriNode || triple.Object is IBlankNode))
                    {
                        // Append object to the value of the @type entry of node; unless such an item already exists. 
                        if (node.ContainsKey("@type"))
                        {
                            AppendUniqueElement(@object, node["@type"] as JArray);
                        }
                        else
                        {
                            // If no such entry exists, create one and initialize it to an array whose only item is object.
                            node.Add("@type", new JArray(@object));
                        }

                        // Finally, continue to the next triple.
                        continue;
                    }

                    // 5.7.6 - Initialize value to the result of using the RDF to Object Conversion algorithm, passing object, rdfDirection, and useNativeTypes.
                    var value = RdfToObject(triple.Object);

                    // 5.7.7 -If node does not have a predicate entry, create one and initialize its value to an empty array.
                    if (!node.ContainsKey(predicate))
                    {
                        node[predicate] = new JArray();
                    }

                    // 5.7.8 - If there is no item equivalent to value in the array associated with the predicate entry of node, append a reference to value to the array. Two maps are considered equal if they have equivalent map entries.
                    AppendUniqueElement(value, node[predicate] as JArray);

                    // 5.7.9 - If object is rdf:nil, it represents the termination of an RDF collection:
                    if (triple.Object is IUriNode u && u.Uri.ToString().Equals(RdfSpecsHelper.RdfListNil))
                    {
                        // 5.7.9.1 - Reference the usages entry of the object entry of node map using the variable usages.
                        // 5.7.9.2 - Append a new map consisting of three entries, node, property, and value to the usages array. The node entry is set to a reference to node, property to predicate, and value to a reference to value.
                        var objectMap = nodeMap[@object] as JObjectWithUsages;
                        objectMap.Usages.Add(new Usage(node, predicate, value));
                    }
                    else if (@object != null && referencedOnce.ContainsKey(@object))
                    {
                        // 5.7.10 - Otherwise, if referenced once has an entry for object, set the object entry of referenced once to false.
                        referencedOnce[@object] = null;
                    }
                    else if (triple.Object is IBlankNode)
                    {
                        // 5.7.11 - Otherwise, if object is a blank node identifier, it might represent a list node:
                        // 5.7.11.1 - Set the object entry of referenced once to a new map consisting of three entries, node, property, and value to the usages array.
                        // The node entry is set to a reference to node, property to predicate, and value to a reference to value.
                        referencedOnce[@object] = new Usage(node, predicate, value);
                    }
                }
            }

            // 6 - For each name and graph object in graph map:
            foreach (var gp in graphMap)
            {
                var name = gp.Key;
                var graphObject = gp.Value as JObject;

                // 6.1 - If compound literal subjects has an entry for name, then for each cl which is a key in that entry:
                if (compoundLiteralSubjects.ContainsKey(name))
                {
                    if (compoundLiteralSubjects[name] is JObject compoundMap)
                    {
                        foreach (var clProp in compoundMap.Properties())
                        {
                            var cl = clProp.Name;
                            // 6.1.1 - Initialize cl entry to the value of cl in referenced once, continuing to the next cl if cl entry is not a map.
                            var clEntry = referencedOnce[cl];
                            if (clEntry == null) continue;
                            // 6.1.2 - Initialize node to the value of node in cl entry.
                            // 6.1.3 - Initialize property to value of property in cl entry.
                            // 6.1.4 - Initialize value to value of value in cl entry.
                            var node = clEntry.Node;
                            var property = clEntry.Property;
                            var value = clEntry.Value;
                            // 6.1.5 - Initialize cl node to the value of cl in graph object, and remove that entry from graph object, continuing to the next cl if cl node is not a map.
                            var clNode = graphObject[cl] as JObject;
                            graphObject.Remove(cl);
                            if (clNode == null) continue;
                            // 6.1.6 - For each cl reference in the value of property in node where the value of @id in cl reference is cl:
                            foreach (var clReference in node[property].OfType<JObject>()
                                .Where(n => cl.Equals(n["@id"].Value<string>())))
                            {
                                // 6.1.6.1 - Delete the @id entry in cl reference.
                                clReference.Remove("@id");
                                // 6.1.6.2 - Add an entry to cl reference for @value with the value taken from the rdf:value entry in cl node.
                                clReference["@value"] = clNode[RdfSpecsHelper.RdfValue][0]["@value"];
                                // 6.1.6.3 - Add an entry to cl reference for @language with the value taken from the rdf:language entry in cl node, if any.
                                // If that value is not well-formed according to section 2.2.9 of [BCP47], an invalid language-tagged string error has been detected and processing is aborted.
                                if (clNode.ContainsKey(RdfSpecsHelper.RdfLanguage))
                                {
                                    var language = clNode[RdfSpecsHelper.RdfLanguage][0]["@value"].Value<string>();
                                    if (!LanguageTag.IsWellFormed(language))
                                    {
                                        throw new JsonLdProcessorException(JsonLdErrorCode.InvalidLanguageTaggedString,
                                            $"Invalid Language-tagged string. Encountered a language tag ({language}) that is not well-formed according to BCP-47.");
                                    }

                                    clReference["@language"] = language;
                                }

                                // 6.1.6.4 - Add an entry to cl reference for @direction with the value taken from the rdf:direction entry in cl node, if any.
                                // If that value is not "ltr" or "rtl", an invalid base direction error has been detected and processing is aborted.
                                if (clNode.ContainsKey(RdfSpecsHelper.RdfDirection))
                                {
                                    var direction = clNode[RdfSpecsHelper.RdfDirection][0]["@value"].Value<string>();
                                    if (!("ltr".Equals(direction) || "rtl".Equals(direction)))
                                    {
                                        throw new JsonLdProcessorException(JsonLdErrorCode.InvalidBaseDirection,
                                            $"Invalid base direction. Encountered a value for rdf:direction ({direction}) that is not allowed. Allowed values are 'rtl' or 'ltr'.");
                                    }

                                    clReference["@direction"] = direction;
                                }
                            }
                        }
                    }
                }

                // 6.2 - If graph object has no rdf:nil entry, continue with the next name-graph object pair as the graph does not contain any lists that need to be converted.
                if (!graphObject.ContainsKey(RdfSpecsHelper.RdfListNil))
                {
                    continue;
                }

                // 6.3 - Initialize nil to the value of the rdf:nil member of graph object.
                var nil = graphObject[RdfSpecsHelper.RdfListNil] as JObjectWithUsages;

                // 6.4 - For each item usage in the usages member of nil, perform the following steps:

                foreach (var usage in nil.Usages)
                {
                    // 6.4.1 - Initialize node to the value of the value of the node entry of usage,
                    // property to the value of the property entry of usage,
                    // and head to the value of the value entry of usage.
                    var node = usage.Node;
                    var property = usage.Property;
                    var head = usage.Value as JObject;
                    // 6.4.2 - Initialize two empty arrays list and list nodes.
                    var list = new JArray();
                    var listNodes = new JArray();
                    // 6.4.3 - While property equals rdf:rest, the value of the @id entry of node is a blank node identifier,
                    // the value of the entry of referenced once associated with the @id entry of node is a map,
                    // node has rdf:first and rdf:rest entries, both of which have as value an array consisting of a single element,
                    // and node has no other entries apart from an optional @type entry whose value is an array with a single item equal to rdf:List,
                    // node represents a well-formed list node.
                    // Perform the following steps to traverse the list backwards towards its head:
                    while (IsWellFormedListNode(node, property, referencedOnce))
                    {
                        // 6.4.3.1 - Append the only item of rdf:first member of node to the list array.
                        list.Add((node[RdfSpecsHelper.RdfListFirst] as JArray)[0]);
                        // 6.4.3.2 - Append the value of the @id member of node to the list nodes array.
                        listNodes.Add(node["@id"]);
                        // 6.4.3.3 - Initialize node usage to the value of the entry of referenced once associated with the @id entry of node.
                        var nodeUsage = referencedOnce[node["@id"].Value<string>()];

                        // 6.4.3.4 - Set node to the value of the node entry of node usage,
                        // property to the value of the property entry of node usage,
                        // and head to the value of the value entry of node usage.
                        node = nodeUsage.Node;
                        property = nodeUsage.Property;
                        head = nodeUsage.Value as JObject;
                        // 6.4.3.5 - If the @id entry of node is an IRI instead of a blank node identifier, exit the while loop.
                        if (!JsonLdUtils.IsBlankNodeIdentifier(node["@id"].Value<string>())) break;
                    }

                    // 6.4.4 - Remove the @id entry from head.
                    head.Remove("@id");
                    // 6.4.5 - Reverse the order of the list array.
                    list = new JArray(list.Reverse());
                    // 6.4.6 - Add an @list entry to head and initialize its value to the list array.
                    head["@list"] = list;
                    // 6.5.7 - For each item node id in list nodes, remove the node id entry from graph object.
                    foreach (var nodeId in listNodes.Select(item => item.Value<string>()))
                    {
                        graphObject.Remove(nodeId);
                    }
                }

            }

            // 7 - Initialize an empty array result.
            var result = new JArray();
            // 8 - For each subject and node in default graph ordered lexicographically by subject if ordered is true:
            var defaultGraphProperties = defaultGraph.Properties();
            if (_options.Ordered) defaultGraphProperties = defaultGraphProperties.OrderBy(x => x.Name, StringComparer.Ordinal);
            foreach (var defaultGraphProperty in defaultGraphProperties)
            {
                var subject = defaultGraphProperty.Name;
                var node = defaultGraphProperty.Value as JObject;
                // 8.1 - If graph map has a subject member:
                if (graphMap.ContainsKey(subject))
                {
                    // 8.1.1 - Add an @graph member to node and initialize its value to an empty array.
                    var graphArray = new JArray();
                    node["@graph"] = graphArray;
                    // 8.1.2 - For each key-value pair s-n in the subject entry of graph map ordered lexicographically by s if ordered is true,
                    // append n to the @graph entry of node after removing its usages entry, unless the only remaining entry of n is @id.
                    var subjectMapProperties = (graphMap[subject] as JObject).Properties();
                    if (_options.Ordered)
                    {
                        subjectMapProperties = subjectMapProperties.OrderBy(x => x.Name, StringComparer.Ordinal);
                    }
                    foreach (var subjectMapProperty in subjectMapProperties)
                    {
                        var s = subjectMapProperty.Name;
                        var n = subjectMapProperty.Value as JObject;
                        n.Remove("usages");
                        if (n.Properties().Any(np => !np.Name.Equals("@id")))
                        {
                            graphArray.Add(n);
                        }
                    }
                }
                // 8.2 - Append node to result after removing its usages member, unless the only remaining member of node is @id.
                node.Remove("usages");
                if (node.Properties().Any(p => !p.Name.Equals("@id")))
                {
                    result.Add(node);
                }
            }
            // 9 - Return result.
            return result;
        }

        private static bool IsWellFormedListNode(JObject node, string property, Dictionary<string, Usage> nodeUsagesMap)
        {
            // If property equals rdf:rest, the value of the @id entry of node is a blank node identifier,
            // the value of the entry of referenced once associated with the @id entry of node is a map,
            // node has rdf: first and rdf: rest entries, both of which have as value an array consisting of a single element,
            // and node has no other entries apart from an optional @type entry whose value is an array with a single item equal to rdf: List,
            // node represents a well-formed list node. 
            if (!RdfSpecsHelper.RdfListRest.Equals(property)) return false;
            var nodeId = node["@id"].Value<string>();
            if (nodeId == null || !JsonLdUtils.IsBlankNodeIdentifier(nodeId)) return false;

            var mapEntry = nodeUsagesMap[nodeId];
            if (mapEntry == null) return false;

            var first = node[RdfSpecsHelper.RdfListFirst] as JArray;
            var rest = node[RdfSpecsHelper.RdfListRest] as JArray;
            if (first == null || rest == null) return false;
            if (first.Count != 1 || rest.Count != 1) return false;

            var type = node["@type"] as JArray;
            if (type != null && (type.Count != 1 ||
                                 type.Count == 1 && !type[0].Value<string>().Equals(RdfSpecsHelper.RdfList)))
                return false;
            var propCount = node.Properties().Count();
            if (type == null && propCount != 3 || type != null && propCount != 4) return false;
            return true;
        }

        private JToken RdfToObject(INode value)
        {
            switch (value)
            {
                // 1 - If value is an IRI or a blank node identifier, return a new dictionary consisting of a single member @id whose value is set to value.
                case IUriNode uriNode:
                    return new JObject(new JProperty("@id", uriNode.Uri.OriginalString));
                case IBlankNode bNode:
                    return new JObject(new JProperty("@id", "_:" + bNode.InternalID));
                case ILiteralNode literal:
                    // 2 - Otherwise value is an RDF literal:
                    // 2.1 - Initialize a new empty dictionary result.
                    var result = new JObject();
                    // 2.2 - Initialize converted value to value.
                    JToken convertedValue = new JValue(literal.Value);
                    // 2.3 - Initialize type to null
                    string type = null;
                    // 2.4 - If use native types is true
                    if (_options.UseNativeTypes && literal.DataType != null)
                    {
                        // 2.4.1 - If the datatype IRI of value equals xsd:string, set converted value to the lexical form of value.
                        if (literal.DataType.ToString().Equals(XmlSpecsHelper.XmlSchemaDataTypeString))
                        {
                            convertedValue = new JValue(literal.Value);
                        }
                        // 2.4.2 - Otherwise, if the datatype IRI of value equals xsd:boolean, set converted value to true if the lexical form of value matches true, or false if it matches false. If it matches neither, set type to xsd:boolean.
                        else if (literal.DataType.ToString()
                                     .Equals(XmlSpecsHelper.XmlSchemaDataTypeBoolean))
                        {
                            if (literal.Value.Equals("true"))
                            {
                                convertedValue = new JValue(true);
                            }
                            else if (literal.Value.Equals("false"))
                            {
                                convertedValue = new JValue(false);
                            }
                            else
                            {
                                type = XmlSpecsHelper.XmlSchemaDataTypeBoolean;
                            }
                        }
                        // 2.4.3 - Otherwise, if the datatype IRI of value equals xsd:integer or xsd:double and its lexical form is a valid xsd:integer or xsd:double according [XMLSCHEMA11-2], set converted value to the result of converting the lexical form to a JSON number.
                        else if (literal.DataType.ToString().Equals(XmlSpecsHelper.XmlSchemaDataTypeInteger))
                        {
                            if (IsWellFormedInteger(literal.Value))
                            {
                                convertedValue = new JValue(long.Parse(literal.Value));
                            }
                        }
                        else if (literal.DataType.ToString().Equals(XmlSpecsHelper.XmlSchemaDataTypeDouble))
                        {
                            if (IsWellFormedDouble(literal.Value))
                            {
                                convertedValue = new JValue(double.Parse(literal.Value));
                            }
                        }
                        // KA: Step missing from spec - otherwise set type to the datatype IRI
                        else
                        {
                            type = literal.DataType.ToString();
                        }
                    }
                    // 2.5 - Otherwise, if processing mode is not json-ld-1.0, and value is a JSON literal, set converted value to the result of turning the lexical value of value into the JSON-LD internal representation, and set type to @json. If the lexical value of value is not valid JSON according to the JSON Grammar [RFC8259], an invalid JSON literal error has been detected and processing is aborted.
                    else if (_options.ProcessingMode != JsonLdProcessingMode.JsonLd10 &&
                             RdfSpecsHelper.RdfJson.Equals(literal.DataType?.ToString()))
                    {
                        try
                        {
                            convertedValue = JToken.Parse(literal.Value);
                        }
                        catch (Exception ex)
                        {
                            throw new JsonLdProcessorException(JsonLdErrorCode.InvalidJsonLiteral,
                                "Invalid JSON literal. " + ex.Message);
                        }

                        type = "@json";
                    }
                    // 2.6 - Otherwise, if the datatype IRI of value starts with https://www.w3.org/ns/i18n#, and rdfDirection is i18n-datatype:
                    else if (_options.RdfDirection == JsonLdRdfDirectionMode.I18NDatatype && literal.DataType != null &&
                             literal.DataType.ToString().StartsWith("https://www.w3.org/ns/i18n#"))
                    {
                        var fragment = literal.DataType.Fragment.TrimStart('#');
                        if (!string.IsNullOrEmpty(literal.DataType.Fragment) && fragment.Contains("_"))
                        {
                            convertedValue = literal.Value;
                            var sepIx = fragment.IndexOf("_", StringComparison.Ordinal);
                            if (sepIx > 0)
                            {
                                result["@language"] = fragment.Substring(0, sepIx);
                            }
                            result["@direction"] = fragment.Substring(sepIx + 1);
                        }
                    }
                    // 2.7 - Otherwise, if value is a language-tagged string add a member @language to result and set its value to the language tag of value.
                    else if (!string.IsNullOrEmpty(literal.Language))
                    {
                        result["@language"] = literal.Language;
                    }
                    // 2.8 - Otherwise, set type to the datatype IRI of value, unless it equals xsd:string which is ignored.
                    else
                    {
                        if (literal.DataType != null && !literal.DataType.ToString()
                                .Equals(XmlSpecsHelper.XmlSchemaDataTypeString))
                        {
                            type = literal.DataType.ToString();
                        }
                    }
                    // 2.9 - Add a member @value to result whose value is set to converted value.
                    result["@value"] = convertedValue;
                    // 2.10 - If type is not null, add a member @type to result whose value is set to type.
                    if (type != null) result["@type"] = type;
                    // 2.11 - Return result.
                    return result;
            }

            return null;
        }

        private static readonly Regex IntegerLexicalRepresentation = new Regex(@"^(\+|\-)?\d+$");
        private static bool IsWellFormedInteger(string literal)
        {
            return IntegerLexicalRepresentation.IsMatch(literal);
        }

        private static readonly Regex DoubleLexicalRepresentation = new Regex(@"^((\+|-)?([0-9]+(\.[0-9]*)?|\.[0-9]+)([Ee](\+|-)?[0-9]+)?|(\+|-)?INF|NaN)$");

        private static bool IsWellFormedDouble(string literal)
        {
            return DoubleLexicalRepresentation.IsMatch(literal);
        }

        private static void AppendUniqueElement(JToken element, JArray toArray)
        {
            if (!toArray.Any(x => JToken.DeepEquals(x, element)))
            {
                toArray.Add(element);
            }
        }

        private static string MakeNodeString(INode node)
        {
            var uriNode = node as IUriNode;
            if (uriNode != null)
            {
                return uriNode.Uri.OriginalString;
            }
            var blankNode = node as IBlankNode;
            if (blankNode != null)
            {
                return "_:" + blankNode.InternalID;
            }
            throw new ArgumentException("Node must be a blank node or URI node", nameof(node));
        }

        /// <inheritdoc/>
        public event StoreWriterWarning Warning;

        private class JObjectWithUsages : JObject
        {
            public readonly List<Usage> Usages = new List<Usage>();
            public JObjectWithUsages(params object[] content) : base(content) { }
        }

        private class Usage
        {
            public Usage(JObjectWithUsages node, string property, JToken value)
            {
                Node = node;
                Property = property;
                Value = value;
            }
            public JObjectWithUsages Node { get; }
            public string Property { get; }
            public JToken Value { get; }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json.Linq;
using VDS.RDF.JsonLd;
using VDS.RDF.JsonLd.Processors;
using VDS.RDF.JsonLd.Syntax;
using VDS.RDF.Parsing;

namespace VDS.RDF.Writing
{
    /// <summary>
    /// Class for serializing a Triple Store in JSON-LD syntax.
    /// </summary>
    public class JsonLdWriter : IStoreWriter
    {
        private readonly JsonLdWriterOptions _options;

        /// <summary>
        /// Create a new serializer with default serialization options.
        /// </summary>
        public JsonLdWriter()
        {
            _options = new JsonLdWriterOptions();
        }


        /// <summary>
        /// Create a new serializer with the specified serialization options.
        /// </summary>
        /// <param name="options"></param>
        public JsonLdWriter(JsonLdWriterOptions options)
        {
            _options = options;
        }

        /// <inheritdoc/>
        public void Save(ITripleStore store, string filename)
        {
            var jsonArray = SerializeStore(store);
            using (var writer = new StreamWriter(File.Open(filename, FileMode.Create, FileAccess.Write),
                Encoding.UTF8))
            {
                writer.Write(jsonArray);
            }
        }

        /// <inheritdoc/>
        public void Save(ITripleStore store, TextWriter output)
        {
            Save(store, output, false);
        }

        /// <inheritdoc/>
        public void Save(ITripleStore store, TextWriter output, bool leaveOpen)
        {
            var jsonArray = SerializeStore(store);
            output.Write(jsonArray.ToString(_options.JsonFormatting));
            output.Flush();
            if (!leaveOpen)
            {
                output.Close();
            }
        }

        /// <summary>
        /// Serialize a Triple Store to an expanded JSON-LD document.
        /// </summary>
        /// <param name="store"></param>
        /// <returns></returns>
        public JArray SerializeStore(ITripleStore store)
        {
            // 1 - Initialize default graph to an empty dictionary.
            var defaultGraph = new JObject();
            // 2 - Initialize graph map to a dictionary consisting of a single member @default whose value references default graph.
            var graphMap = new JObject(new JProperty("@default", defaultGraph));
            // 3 - Initialize referenced once to an empty map.
            var referencedOnce =new Dictionary<string, Usage>();
            // 4 - Initialize compound literal subjects to an empty map.
            var compoundLiteralSubjects = new JObject();
            // 5 - For each graph in RDF dataset:
            foreach (var graph in store.Graphs)
            {
                // 5.1 - If graph is the default graph, set name to @default, otherwise to the graph name associated with graph.
                string name = graph.BaseUri == null ? "@default" : graph.BaseUri.ToString();

                // 5.2 - If graph map has no name entry, create one and set its value to an empty map.
                if (!graphMap.ContainsKey(name))
                {
                    graphMap.Add(name, new JObject());
                }

                // 5.3 - If compound literal subjects has no name entry, create one and set its value to an empty map.
                if (!compoundLiteralSubjects.ContainsKey(name))
                {
                    compoundLiteralSubjects[name] = new JObject();
                }

                // 5.4 - If graph is not the default graph and default graph does not have a name entry,
                // create such an entry and initialize its value to a new map with a single entry @id whose value is name.
                if (name != "@default")
                {
                    if (!defaultGraph.ContainsKey(name))
                    {
                        defaultGraph.Add(name, new JObjectWithUsages(new JProperty("@id", name)));
                    }
                }

                // 5.5 - Reference the value of the name entry in graph map using the variable node map.
                var nodeMap = graphMap[name] as JObject;

                // 5.6 - Reference the value of the name entry in compound literal subjects using the variable compound map.
                var compoundMap = compoundLiteralSubjects[name];

                // 5.7 - For each triple in graph consisting of subject, predicate, and object:
                foreach (var triple in graph.Triples)
                {
                    var subject = MakeNodeString(triple.Subject);
                    var predicate = MakeNodeString(triple.Predicate);
                    var @object = triple.Object is IUriNode || triple.Object is IBlankNode ? MakeNodeString(triple.Object) : null;

                    // 5.7.1 - If node map does not have a subject entry, create one and initialize its value to a new map consisting of a single entry @id whose value is set to subject.
                    if (!nodeMap.ContainsKey(subject))
                    {
                        nodeMap.Add(subject, new JObjectWithUsages(new JProperty("@id", subject)));
                    }

                    // 5.7.2 - Reference the value of the subject entry in node map using the variable node.
                    var node = nodeMap[subject] as JObjectWithUsages;

                    // 5.7.3 - If the rdfDirection option is compound-literal and predicate is rdf:direction, add an entry in compound map for subject with the value true.
                    if (_options.RdfDirection.HasValue && _options.RdfDirection == JsonLdRdfDirectionMode.CompoundLiteral && RdfSpecsHelper.RdfDirection.Equals(predicate))
                    {
                        compoundMap[subject] = true;
                    }

                    // 5.7.4 - If object is an IRI or blank node identifier, and node map does not have an object entry,
                    // create one and initialize its value to a new map consisting of a single entry @id whose value is set
                    // to object.
                    if (triple.Object is IUriNode || triple.Object is IBlankNode)
                    {
                        if (!nodeMap.ContainsKey(@object))
                        {
                            nodeMap.Add(@object, new JObjectWithUsages(new JProperty("@id", @object)));
                        }
                    }

                    // 5.7.5 - If predicate equals rdf:type, the useRdfType flag is not true, and object is an IRI or blank node identifier
                    if (predicate.Equals(RdfSpecsHelper.RdfType) && !_options.UseRdfType &&
                        (triple.Object is IUriNode || triple.Object is IBlankNode))
                    {
                        // Append object to the value of the @type entry of node; unless such an item already exists. 
                        if (node.ContainsKey("@type"))
                        {
                            AppendUniqueElement(@object, node["@type"] as JArray);
                        }
                        else
                        {
                            // If no such entry exists, create one and initialize it to an array whose only item is object.
                            node.Add("@type", new JArray(@object));
                        }

                        // Finally, continue to the next triple.
                        continue;
                    }

                    // 5.7.6 - Initialize value to the result of using the RDF to Object Conversion algorithm, passing object, rdfDirection, and useNativeTypes.
                    var value = RdfToObject(triple.Object);

                    // 5.7.7 -If node does not have a predicate entry, create one and initialize its value to an empty array.
                    if (!node.ContainsKey(predicate))
                    {
                        node[predicate] = new JArray();
                    }

                    // 5.7.8 - If there is no item equivalent to value in the array associated with the predicate entry of node, append a reference to value to the array. Two maps are considered equal if they have equivalent map entries.
                    AppendUniqueElement(value, node[predicate] as JArray);

                    // 5.7.9 - If object is rdf:nil, it represents the termination of an RDF collection:
                    if (triple.Object is IUriNode u && u.Uri.ToString().Equals(RdfSpecsHelper.RdfListNil))
                    {
                        // 5.7.9.1 - Reference the usages entry of the object entry of node map using the variable usages.
                        // 5.7.9.2 - Append a new map consisting of three entries, node, property, and value to the usages array. The node entry is set to a reference to node, property to predicate, and value to a reference to value.
                        var objectMap = nodeMap[@object] as JObjectWithUsages;
                        objectMap.Usages.Add(new Usage(node, predicate, value));
                    }
                    else if (@object != null && referencedOnce.ContainsKey(@object))
                    {
                        // 5.7.10 - Otherwise, if referenced once has an entry for object, set the object entry of referenced once to false.
                        referencedOnce[@object] = null;
                    }
                    else if (triple.Object is IBlankNode)
                    {
                        // 5.7.11 - Otherwise, if object is a blank node identifier, it might represent a list node:
                        // 5.7.11.1 - Set the object entry of referenced once to a new map consisting of three entries, node, property, and value to the usages array.
                        // The node entry is set to a reference to node, property to predicate, and value to a reference to value.
                        referencedOnce[@object] = new Usage(node, predicate, value);
                    }
                }
            }

            // 6 - For each name and graph object in graph map:
            foreach (var gp in graphMap)
            {
                var name = gp.Key;
                var graphObject = gp.Value as JObject;

                // 6.1 - If compound literal subjects has an entry for name, then for each cl which is a key in that entry:
                if (compoundLiteralSubjects.ContainsKey(name))
                {
                    if (compoundLiteralSubjects[name] is JObject compoundMap)
                    {
                        foreach (var clProp in compoundMap.Properties())
                        {
                            var cl = clProp.Name;
                            // 6.1.1 - Initialize cl entry to the value of cl in referenced once, continuing to the next cl if cl entry is not a map.
                            var clEntry = referencedOnce[cl];
                            if (clEntry == null) continue;
                            // 6.1.2 - Initialize node to the value of node in cl entry.
                            // 6.1.3 - Initialize property to value of property in cl entry.
                            // 6.1.4 - Initialize value to value of value in cl entry.
                            var node = clEntry.Node;
                            var property = clEntry.Property;
                            var value = clEntry.Value;
                            // 6.1.5 - Initialize cl node to the value of cl in graph object, and remove that entry from graph object, continuing to the next cl if cl node is not a map.
                            var clNode = graphObject[cl] as JObject;
                            graphObject.Remove(cl);
                            if (clNode == null) continue;
                            // 6.1.6 - For each cl reference in the value of property in node where the value of @id in cl reference is cl:
                            foreach (var clReference in node[property].OfType<JObject>()
                                .Where(n => cl.Equals(n["@id"].Value<string>())))
                            {
                                // 6.1.6.1 - Delete the @id entry in cl reference.
                                clReference.Remove("@id");
                                // 6.1.6.2 - Add an entry to cl reference for @value with the value taken from the rdf:value entry in cl node.
                                clReference["@value"] = clNode[RdfSpecsHelper.RdfValue][0]["@value"];
                                // 6.1.6.3 - Add an entry to cl reference for @language with the value taken from the rdf:language entry in cl node, if any.
                                // If that value is not well-formed according to section 2.2.9 of [BCP47], an invalid language-tagged string error has been detected and processing is aborted.
                                if (clNode.ContainsKey(RdfSpecsHelper.RdfLanguage))
                                {
                                    var language = clNode[RdfSpecsHelper.RdfLanguage][0]["@value"].Value<string>();
                                    if (!LanguageTag.IsWellFormed(language))
                                    {
                                        throw new JsonLdProcessorException(JsonLdErrorCode.InvalidLanguageTaggedString,
                                            $"Invalid Language-tagged string. Encountered a language tag ({language}) that is not well-formed according to BCP-47.");
                                    }

                                    clReference["@language"] = language;
                                }

                                // 6.1.6.4 - Add an entry to cl reference for @direction with the value taken from the rdf:direction entry in cl node, if any.
                                // If that value is not "ltr" or "rtl", an invalid base direction error has been detected and processing is aborted.
                                if (clNode.ContainsKey(RdfSpecsHelper.RdfDirection))
                                {
                                    var direction = clNode[RdfSpecsHelper.RdfDirection][0]["@value"].Value<string>();
                                    if (!("ltr".Equals(direction) || "rtl".Equals(direction)))
                                    {
                                        throw new JsonLdProcessorException(JsonLdErrorCode.InvalidBaseDirection,
                                            $"Invalid base direction. Encountered a value for rdf:direction ({direction}) that is not allowed. Allowed values are 'rtl' or 'ltr'.");
                                    }

                                    clReference["@direction"] = direction;
                                }
                            }
                        }
                    }
                }

                // 6.2 - If graph object has no rdf:nil entry, continue with the next name-graph object pair as the graph does not contain any lists that need to be converted.
                if (!graphObject.ContainsKey(RdfSpecsHelper.RdfListNil))
                {
                    continue;
                }

                // 6.3 - Initialize nil to the value of the rdf:nil member of graph object.
                var nil = graphObject[RdfSpecsHelper.RdfListNil] as JObjectWithUsages;

                // 6.4 - For each item usage in the usages member of nil, perform the following steps:

                foreach (var usage in nil.Usages)
                {
                    // 6.4.1 - Initialize node to the value of the value of the node entry of usage,
                    // property to the value of the property entry of usage,
                    // and head to the value of the value entry of usage.
                    var node = usage.Node;
                    var property = usage.Property;
                    var head = usage.Value as JObject;
                    // 6.4.2 - Initialize two empty arrays list and list nodes.
                    var list = new JArray();
                    var listNodes = new JArray();
                    // 6.4.3 - While property equals rdf:rest, the value of the @id entry of node is a blank node identifier,
                    // the value of the entry of referenced once associated with the @id entry of node is a map,
                    // node has rdf:first and rdf:rest entries, both of which have as value an array consisting of a single element,
                    // and node has no other entries apart from an optional @type entry whose value is an array with a single item equal to rdf:List,
                    // node represents a well-formed list node.
                    // Perform the following steps to traverse the list backwards towards its head:
                    while (IsWellFormedListNode(node, property, referencedOnce))
                    {
                        // 6.4.3.1 - Append the only item of rdf:first member of node to the list array.
                        list.Add((node[RdfSpecsHelper.RdfListFirst] as JArray)[0]);
                        // 6.4.3.2 - Append the value of the @id member of node to the list nodes array.
                        listNodes.Add(node["@id"]);
                        // 6.4.3.3 - Initialize node usage to the value of the entry of referenced once associated with the @id entry of node.
                        var nodeUsage = referencedOnce[node["@id"].Value<string>()];

                        // 6.4.3.4 - Set node to the value of the node entry of node usage,
                        // property to the value of the property entry of node usage,
                        // and head to the value of the value entry of node usage.
                        node = nodeUsage.Node;
                        property = nodeUsage.Property;
                        head = nodeUsage.Value as JObject;
                        // 6.4.3.5 - If the @id entry of node is an IRI instead of a blank node identifier, exit the while loop.
                        if (!JsonLdUtils.IsBlankNodeIdentifier(node["@id"].Value<string>())) break;
                    }

                    // 6.4.4 - Remove the @id entry from head.
                    head.Remove("@id");
                    // 6.4.5 - Reverse the order of the list array.
                    list = new JArray(list.Reverse());
                    // 6.4.6 - Add an @list entry to head and initialize its value to the list array.
                    head["@list"] = list;
                    // 6.5.7 - For each item node id in list nodes, remove the node id entry from graph object.
                    foreach (var nodeId in listNodes.Select(item => item.Value<string>()))
                    {
                        graphObject.Remove(nodeId);
                    }
                }

            }

            // 7 - Initialize an empty array result.
            var result = new JArray();
            // 8 - For each subject and node in default graph ordered lexicographically by subject if ordered is true:
            var defaultGraphProperties = defaultGraph.Properties();
            if (_options.Ordered) defaultGraphProperties = defaultGraphProperties.OrderBy(x => x.Name, StringComparer.Ordinal);
            foreach (var defaultGraphProperty in defaultGraphProperties)
            {
                var subject = defaultGraphProperty.Name;
                var node = defaultGraphProperty.Value as JObject;
                // 8.1 - If graph map has a subject member:
                if (graphMap.ContainsKey(subject))
                {
                    // 8.1.1 - Add an @graph member to node and initialize its value to an empty array.
                    var graphArray = new JArray();
                    node["@graph"] = graphArray;
                    // 8.1.2 - For each key-value pair s-n in the subject entry of graph map ordered lexicographically by s if ordered is true,
                    // append n to the @graph entry of node after removing its usages entry, unless the only remaining entry of n is @id.
                    var subjectMapProperties = (graphMap[subject] as JObject).Properties();
                    if (_options.Ordered)
                    {
                        subjectMapProperties = subjectMapProperties.OrderBy(x => x.Name, StringComparer.Ordinal);
                    }
                    foreach (var subjectMapProperty in subjectMapProperties)
                    {
                        var s = subjectMapProperty.Name;
                        var n = subjectMapProperty.Value as JObject;
                        n.Remove("usages");
                        if (n.Properties().Any(np => !np.Name.Equals("@id")))
                        {
                            graphArray.Add(n);
                        }
                    }
                }
                // 8.2 - Append node to result after removing its usages member, unless the only remaining member of node is @id.
                node.Remove("usages");
                if (node.Properties().Any(p => !p.Name.Equals("@id")))
                {
                    result.Add(node);
                }
            }
            // 9 - Return result.
            return result;
        }

        private static bool IsWellFormedListNode(JObject node, string property, Dictionary<string, Usage> nodeUsagesMap)
        {
            // If property equals rdf:rest, the value of the @id entry of node is a blank node identifier,
            // the value of the entry of referenced once associated with the @id entry of node is a map,
            // node has rdf: first and rdf: rest entries, both of which have as value an array consisting of a single element,
            // and node has no other entries apart from an optional @type entry whose value is an array with a single item equal to rdf: List,
            // node represents a well-formed list node. 
            if (!RdfSpecsHelper.RdfListRest.Equals(property)) return false;
            var nodeId = node["@id"].Value<string>();
            if (nodeId == null || !JsonLdUtils.IsBlankNodeIdentifier(nodeId)) return false;

            var mapEntry = nodeUsagesMap[nodeId];
            if (mapEntry == null) return false;

            var first = node[RdfSpecsHelper.RdfListFirst] as JArray;
            var rest = node[RdfSpecsHelper.RdfListRest] as JArray;
            if (first == null || rest == null) return false;
            if (first.Count != 1 || rest.Count != 1) return false;

            if (node["@type"] is JArray type && (type.Count != 1 ||
                                 type.Count == 1 && !type[0].Value<string>().Equals(RdfSpecsHelper.RdfList)))
                return false;
            var propCount = node.Properties().Count();
            if (type == null && propCount != 3 || node["@type"] is JArray type && propCount != 4) return false;
            return true;
        }

        private JToken RdfToObject(INode value)
        {
            switch (value)
            {
                // 1 - If value is an IRI or a blank node identifier, return a new dictionary consisting of a single member @id whose value is set to value.
                case IUriNode uriNode:
                    return new JObject(new JProperty("@id", uriNode.Uri.OriginalString));
                case IBlankNode bNode:
                    return new JObject(new JProperty("@id", "_:" + bNode.InternalID));
                case ILiteralNode literal:
                    // 2 - Otherwise value is an RDF literal:
                    // 2.1 - Initialize a new empty dictionary result.
                    var result = new JObject();
                    // 2.2 - Initialize converted value to value.
                    JToken convertedValue = new JValue(literal.Value);
                    // 2.3 - Initialize type to null
                    string type = null;
                    // 2.4 - If use native types is true
                    if (_options.UseNativeTypes && literal.DataType != null)
                    {
                        // 2.4.1 - If the datatype IRI of value equals xsd:string, set converted value to the lexical form of value.
                        if (literal.DataType.ToString().Equals(XmlSpecsHelper.XmlSchemaDataTypeString))
                        {
                            convertedValue = new JValue(literal.Value);
                        }
                        // 2.4.2 - Otherwise, if the datatype IRI of value equals xsd:boolean, set converted value to true if the lexical form of value matches true, or false if it matches false. If it matches neither, set type to xsd:boolean.
                        else if (literal.DataType.ToString()
                                     .Equals(XmlSpecsHelper.XmlSchemaDataTypeBoolean))
                        {
                            if (literal.Value.Equals("true"))
                            {
                                convertedValue = new JValue(true);
                            }
                            else if (literal.Value.Equals("false"))
                            {
                                convertedValue = new JValue(false);
                            }
                            else
                            {
                                type = XmlSpecsHelper.XmlSchemaDataTypeBoolean;
                            }
                        }
                        // 2.4.3 - Otherwise, if the datatype IRI of value equals xsd:integer or xsd:double and its lexical form is a valid xsd:integer or xsd:double according [XMLSCHEMA11-2], set converted value to the result of converting the lexical form to a JSON number.
                        else if (literal.DataType.ToString().Equals(XmlSpecsHelper.XmlSchemaDataTypeInteger))
                        {
                            if (IsWellFormedInteger(literal.Value))
                            {
                                convertedValue = new JValue(long.Parse(literal.Value));
                            }
                        }
                        else if (literal.DataType.ToString().Equals(XmlSpecsHelper.XmlSchemaDataTypeDouble))
                        {
                            if (IsWellFormedDouble(literal.Value))
                            {
                                convertedValue = new JValue(double.Parse(literal.Value));
                            }
                        }
                        // KA: Step missing from spec - otherwise set type to the datatype IRI
                        else
                        {
                            type = literal.DataType.ToString();
                        }
                    }
                    // 2.5 - Otherwise, if processing mode is not json-ld-1.0, and value is a JSON literal, set converted value to the result of turning the lexical value of value into the JSON-LD internal representation, and set type to @json. If the lexical value of value is not valid JSON according to the JSON Grammar [RFC8259], an invalid JSON literal error has been detected and processing is aborted.
                    else if (_options.ProcessingMode != JsonLdProcessingMode.JsonLd10 &&
                             RdfSpecsHelper.RdfJson.Equals(literal.DataType?.ToString()))
                    {
                        try
                        {
                            convertedValue = JToken.Parse(literal.Value);
                        }
                        catch (Exception ex)
                        {
                            throw new JsonLdProcessorException(JsonLdErrorCode.InvalidJsonLiteral,
                                "Invalid JSON literal. " + ex.Message);
                        }

                        type = "@json";
                    }
                    // 2.6 - Otherwise, if the datatype IRI of value starts with https://www.w3.org/ns/i18n#, and rdfDirection is i18n-datatype:
                    else if (_options.RdfDirection == JsonLdRdfDirectionMode.I18NDatatype && literal.DataType != null &&
                             literal.DataType.ToString().StartsWith("https://www.w3.org/ns/i18n#"))
                    {
                        var fragment = literal.DataType.Fragment.TrimStart('#');
                        if (!string.IsNullOrEmpty(literal.DataType.Fragment) && fragment.Contains("_"))
                        {
                            convertedValue = literal.Value;
                            var sepIx = fragment.IndexOf("_", StringComparison.Ordinal);
                            if (sepIx > 0)
                            {
                                result["@language"] = fragment.Substring(0, sepIx);
                            }
                            result["@direction"] = fragment.Substring(sepIx + 1);
                        }
                    }
                    // 2.7 - Otherwise, if value is a language-tagged string add a member @language to result and set its value to the language tag of value.
                    else if (!string.IsNullOrEmpty(literal.Language))
                    {
                        result["@language"] = literal.Language;
                    }
                    // 2.8 - Otherwise, set type to the datatype IRI of value, unless it equals xsd:string which is ignored.
                    else
                    {
                        if (literal.DataType != null && !literal.DataType.ToString()
                                .Equals(XmlSpecsHelper.XmlSchemaDataTypeString))
                        {
                            type = literal.DataType.ToString();
                        }
                    }
                    // 2.9 - Add a member @value to result whose value is set to converted value.
                    result["@value"] = convertedValue;
                    // 2.10 - If type is not null, add a member @type to result whose value is set to type.
                    if (type != null) result["@type"] = type;
                    // 2.11 - Return result.
                    return result;
            }

            return null;
        }

        private static readonly Regex IntegerLexicalRepresentation = new Regex(@"^(\+|\-)?\d+$");
        private static bool IsWellFormedInteger(string literal)
        {
            return IntegerLexicalRepresentation.IsMatch(literal);
        }

        private static readonly Regex DoubleLexicalRepresentation = new Regex(@"^((\+|-)?([0-9]+(\.[0-9]*)?|\.[0-9]+)([Ee](\+|-)?[0-9]+)?|(\+|-)?INF|NaN)$");

        private static bool IsWellFormedDouble(string literal)
        {
            return DoubleLexicalRepresentation.IsMatch(literal);
        }

        private static void AppendUniqueElement(JToken element, JArray toArray)
        {
            if (!toArray.Any(x => JToken.DeepEquals(x, element)))
            {
                toArray.Add(element);
            }
        }

        private static string MakeNodeString(INode node)
        {
            if (node is IUriNode uriNode)
            {
                return uriNode.Uri.OriginalString;
            }

            if (node is IBlankNode blankNode)
            {
                return "_:" + blankNode.InternalID;
            }
            throw new ArgumentException("Node must be a blank node or URI node", nameof(node));
        }

        /// <inheritdoc/>
        public event StoreWriterWarning Warning;

        private class JObjectWithUsages : JObject
        {
            public readonly List<Usage> Usages = new List<Usage>();
            public JObjectWithUsages(params object[] content) : base(content) { }
        }

        private class Usage
        {
            public Usage(JObjectWithUsages node, string property, JToken value)
            {
                Node = node;
                Property = property;
                Value = value;
            }
            public JObjectWithUsages Node { get; }
            public string Property { get; }
            public JToken Value { get; }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF\Writing\JsonLdWriter.cs(427,75): error CS0128: A local variable or function named 'type' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF\Writing\JsonLdWriter.cs(427,17): error CS0165: Use of unassigned local variable 'type'
######################################################################


######################################################################
Nr: 10 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Libraries\dotNetRDF.Data.Virtuoso\VirtuosoManager.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using OpenLink.Data.Virtuoso;
using VDS.RDF.Configuration;
using VDS.RDF.Parsing;
using VDS.RDF.Parsing.Handlers;
using VDS.RDF.Query;
using VDS.RDF.Query.Algebra;
using VDS.RDF.Update;
using VDS.RDF.Writing;
using VDS.RDF.Writing.Formatting;

namespace VDS.RDF.Storage
{
    /// <summary>
    /// A Manager for accessing the Native Virtuoso Quad Store.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This class implements <see cref="IStorageProvider">IStorageProvider</see> allowing it to be used with any of the general classes that support this interface as well as the Virtuoso specific classes.
    /// </para>
    /// <para>
    /// Although this class takes a Database Name to ensure compatability with any Virtuoso installation (i.e. this allows for the Native Quad Store to be in a non-standard database) generally you should always specify <strong>DB</strong> as the Database Name parameter.
    /// </para>
    /// <para>
    /// Virtuoso automatically assigns IDs to Blank Nodes input into it, these IDs are <strong>not</strong> based on the actual Blank Node ID so inputting a Blank Node with the same ID multiple times will result in multiple Nodes being created in Virtuoso.  This means that data containing Blank Nodes which is stored to Virtuoso and then retrieved will have different Blank Node IDs to those input.  In addition there is no guarentee that when you save a Graph containing Blank Nodes into Virtuoso that retrieving it will give the same Blank Node IDs even if the Graph being saved was originally retrieved from Virtuoso.  Finally please see the remarks on the <see cref="VirtuosoManager.UpdateGraph(Uri,IEnumerable{Triple},IEnumerable{Triple})">UpdateGraph()</see> method which deal with how insertion and deletion of triples containing blank nodes into existing graphs operates.
    /// </para>
    /// <para>
    /// You can use a null Uri or an empty String as a Uri to indicate that operations should affect the Default Graph.  Where the argument is only a Graph a null <see cref="IGraph.BaseUri">BaseUri</see> property indicates that the Graph affects the Default Graph.
    /// </para>
    /// </remarks>
    public class VirtuosoManager
        : BaseAsyncSafeConnector, IUpdateableStorage, IConfigurationSerializable
    {
        /// <summary>
        /// Default Port for Virtuoso Servers.
        /// </summary>
        public const int DefaultPort = 1111;

        /// <summary>
        /// Default Database for Virtuoso Server Quad Store.
        /// </summary>
        public const String DefaultDB = "DB";

        private const String SubjectColumn = "S", PredicateColumn = "P", ObjectColumn = "O";
        private const String VirtuosoRelativeBaseString = "virtuoso-relative:";
        private readonly Uri VirtuosoRelativeBase = new Uri(VirtuosoRelativeBaseString);

        #region Variables & Constructors

        private readonly VirtuosoConnection _db;
        private VirtuosoTransaction _dbtrans;
        private readonly ITripleFormatter _formatter = new VirtuosoFormatter();

        private readonly String _dbserver, _dbname, _dbuser, _dbpwd;
        private readonly int _dbport, _timeout = 0;

        /// <summary>
        /// Indicates whether the Database Connection is currently being kept open.
        /// </summary>
        private bool _keepOpen = false;

        private readonly bool _customConnString = false;

        /// <summary>
        /// Creates a Manager for a Virtuoso Native Quad Store.
        /// </summary>
        /// <param name="server">Server.</param>
        /// <param name="port">Port.</param>
        /// <param name="db">Database Name.</param>
        /// <param name="user">Username.</param>
        /// <param name="password">Password.</param>
        /// <param name="timeout">Connection Timeout in Seconds.</param>
        /// <remarks>
        /// Timeouts less than equal to zero are ignored and treated as using the default timeout which is dictated by the underlying Virtuoso ADO.Net provider.
        /// </remarks>
        public VirtuosoManager(String server, int port, String db, String user, String password, int timeout)
        {
            //Set the Connection Properties
            this._dbserver = server;
            this._dbname = db;
            this._dbuser = user;
            this._dbpwd = password;
            this._dbport = port;
            this._timeout = timeout;

            StringBuilder connString = new StringBuilder();
            connString.Append("Server=");
            connString.Append(this._dbserver);
            connString.Append(":");
            connString.Append(this._dbport);
            connString.Append(";Database=");
            connString.Append(this._dbname);
            connString.Append(";uid=");
            connString.Append(this._dbuser);
            connString.Append(";pwd=");
            connString.Append(this._dbpwd);
            connString.Append(";Charset=utf-8");
            if (this._timeout > 0)
            {
                connString.Append(";Connection Timeout=" + this._timeout);
            }

            //Create the Connection Object
            this._db = new VirtuosoConnection(connString.ToString());
        }

        /// <summary>
        /// Creates a Manager for a Virtuoso Native Quad Store.
        /// </summary>
        /// <param name="server">Server.</param>
        /// <param name="port">Port.</param>
        /// <param name="db">Database Name.</param>
        /// <param name="user">Username.</param>
        /// <param name="password">Password.</param>
        public VirtuosoManager(String server, int port, String db, String user, String password)
            : this(server, port, db, user, password, 0)
        {
        }

        /// <summary>
        /// Creates a Manager for a Virtuoso Native Quad Store.
        /// </summary>
        /// <param name="db">Database Name.</param>
        /// <param name="user">Username.</param>
        /// <param name="password">Password.</param>
        /// <param name="timeout">Connection Timeout in Seconds.</param>
        /// <remarks>
        /// Assumes the Server is on the localhost and the port is the default installation port of 1111.
        /// </remarks>
        public VirtuosoManager(String db, String user, String password, int timeout)
            : this("localhost", VirtuosoManager.DefaultPort, db, user, password, timeout)
        {
        }

        /// <summary>
        /// Creates a Manager for a Virtuoso Native Quad Store.
        /// </summary>
        /// <param name="db">Database Name.</param>
        /// <param name="user">Username.</param>
        /// <param name="password">Password.</param>
        /// <remarks>
        /// Assumes the Server is on the localhost and the port is the default installation port of 1111.
        /// </remarks>
        public VirtuosoManager(String db, String user, String password)
            : this("localhost", VirtuosoManager.DefaultPort, db, user, password, 0)
        {
        }

        /// <summary>
        /// Creates a Manager for a Virtuoso Native Quad Store.
        /// </summary>
        /// <param name="connectionString">Connection String.</param>
        /// <remarks>
        /// Allows the end user to specify a customised connection string.
        /// </remarks>
        public VirtuosoManager(String connectionString)
        {
            this._db = new VirtuosoConnection(connectionString);
            this._customConnString = true;
        }

        #endregion

        #region Triple Loading & Saving

        /// <summary>
        /// Loads a Graph from the Quad Store.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="graphUri">URI of the Graph to Load.</param>
        public override void LoadGraph(IGraph g, Uri graphUri)
        {
            if (g.IsEmpty && graphUri != null)
            {
                g.BaseUri = graphUri;
            }
            this.LoadGraph(new GraphHandler(g), graphUri);
        }

        /// <summary>
        /// Loads a Graph from the Quad Store.
        /// </summary>
        /// <param name="handler">RDF Handler.</param>
        /// <param name="graphUri">URI of the Graph to Load.</param>
        public override void LoadGraph(IRdfHandler handler, Uri graphUri)
        {
            if (graphUri == null) throw new RdfStorageException("Cannot load an unnamed Graph from Virtuoso as this would require loading the entirety of the Virtuoso Quad Store into memory!");

            try
            {
                handler.StartRdf();

                //Need to keep Database Open as Literals require extra trips to the Database to get additional
                //information about Language and Type
                this.Open(false);

                DataTable data = this.LoadTriples(graphUri);

                foreach (DataRow row in data.Rows)
                {
                    Object s, p, o;
                    INode subj, pred, obj;

                    //Get Data
                    s = row["S"];
                    p = row["P"];
                    o = row["O"];

                    //Create Nodes
                    subj = this.LoadNode(handler, s);
                    pred = this.LoadNode(handler, p);
                    obj = this.LoadNode(handler, o);

                    //Assert Triple
                    if (!handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();
                }
                handler.EndRdf(true);
                this.Close(false);
            }
            catch (RdfParsingTerminatedException)
            {
                handler.EndRdf(true);
                this.Close(false);
            }
            catch
            {
                handler.EndRdf(false);
                this.Close(true);
                throw;
            }
        }

        /// <summary>
        /// Loads a Graph from the Quad Store.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="graphUri">URI of the Graph to Load.</param>
        public override void LoadGraph(IGraph g, String graphUri)
        {
            if (graphUri == null || graphUri.Equals(String.Empty))
            {
                this.LoadGraph(g, (Uri) null);
            }
            else
            {
                this.LoadGraph(g, UriFactory.Create(graphUri));
            }
        }

        /// <summary>
        /// Loads a Graph from the Quad Store.
        /// </summary>
        /// <param name="handler">RDF Handler.</param>
        /// <param name="graphUri">URI of the Graph to Load.</param>
        public override void LoadGraph(IRdfHandler handler, String graphUri)
        {
            if (graphUri == null || graphUri.Equals(String.Empty))
            {
                this.LoadGraph(handler, (Uri) null);
            }
            else
            {
                this.LoadGraph(handler, UriFactory.Create(graphUri));
            }
        }

        /// <summary>
        /// Gets a Table of Triples that are in the given Graph.
        /// </summary>
        /// <param name="graphUri">Graph Uri.</param>
        /// <returns></returns>
        /// <remarks>
        /// Assumes that the caller has opened the Database connection.
        /// </remarks>
        private DataTable LoadTriples(Uri graphUri)
        {
            DataTable dt = new DataTable();
            String getTriples;
            if (graphUri != null)
            {
                getTriples = "SPARQL define output:format '_JAVA_' SELECT * FROM <" + this.UnmarshalUri(graphUri) + "> WHERE {?s ?p ?o}";
            }
            else
            {
                getTriples = "SPARQL define output:format '_JAVA_' SELECT * WHERE {?s ?p ?o}";
            }

            VirtuosoCommand cmd = this._db.CreateCommand();
            cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
            cmd.CommandText = getTriples;

            VirtuosoDataAdapter adapter = new VirtuosoDataAdapter(cmd);

            dt.Columns.Add("S", typeof (System.Object));
            dt.Columns.Add("P", typeof (System.Object));
            dt.Columns.Add("O", typeof (System.Object));
            adapter.Fill(dt);

            return dt;
        }

        /// <summary>
        /// Decodes an Object into an appropriate Node.
        /// </summary>
        /// <param name="factory">Node Factory to use to create Node.</param>
        /// <param name="n">Object to convert.</param>
        /// <returns></returns>
        private INode LoadNode(INodeFactory factory, Object n)
        {
            INode temp;
            if (n is SqlExtendedString)
            {
                SqlExtendedString iri = (SqlExtendedString) n;
                if (iri.IriType == SqlExtendedStringType.BNODE)
                {
                    //Blank Node
                    temp = factory.CreateBlankNode(n.ToString().Substring(9));
                }
                else if (iri.IriType != iri.StrType)
                {
                    //Literal
                    temp = factory.CreateLiteralNode(n.ToString());
                }
                else if (iri.IriType == SqlExtendedStringType.IRI)
                {
                    //Uri
                    Uri u = this.MarshalUri(n.ToString());
                    temp = factory.CreateUriNode(u);
                }
                else
                {
                    //Assume a Literal
                    temp = factory.CreateLiteralNode(n.ToString());
                }
            }
            else if (n is SqlRdfBox)
            {
                SqlRdfBox lit = (SqlRdfBox) n;
                if (lit.StrLang != null)
                {
                    //Language Specified Literal
                    temp = factory.CreateLiteralNode(n.ToString(), lit.StrLang);
                }
                else if (lit.StrType != null)
                {
                    //Data Typed Literal
                    temp = factory.CreateLiteralNode(n.ToString(), this.MarshalUri(lit.StrType));
                }
                else
                {
                    //Literal
                    temp = factory.CreateLiteralNode(n.ToString());
                }
            }
            else if (n is String)
            {
                String s = n.ToString();
                if (s.StartsWith("nodeID://"))
                {
                    //Blank Node
                    temp = factory.CreateBlankNode(s.Substring(9));
                }
                else
                {
                    //Literal
                    temp = factory.CreateLiteralNode(s);
                }
            }
            else if (n is Int32)
            {
                temp = ((Int32) n).ToLiteral(factory);
            }
            else if (n is Int16)
            {
                temp = ((Int16) n).ToLiteral(factory);
            }
            else if (n is Single)
            {
                temp = ((Single) n).ToLiteral(factory);
            }
            else if (n is Double)
            {
                temp = ((Double) n).ToLiteral(factory);
            }
            else if (n is Decimal)
            {
                temp = ((Decimal) n).ToLiteral(factory);
            }
            else if (n is DateTime)
            {
                temp = ((DateTime) n).ToLiteral(factory);
            }
            else if (n is TimeSpan)
            {
                temp = ((TimeSpan) n).ToLiteral(factory);
            }
            else if (n is Boolean)
            {
                temp = ((Boolean) n).ToLiteral(factory);
            }
            else if (n is DBNull)
            {
                //Fix by Alexander Sidarov for Virtuoso's results for unbound variables in OPTIONALs
                temp = null;
            }
            else if (n is VirtuosoDateTime)
            {
                //New type in Virtuoso 7
                VirtuosoDateTime vDateTime = (VirtuosoDateTime)n;
                DateTime dateTime = new DateTime(vDateTime.Year, vDateTime.Month, vDateTime.Day, vDateTime.Hour, vDateTime.Minute, vDateTime.Second, vDateTime.Millisecond, vDateTime.Kind);
                return dateTime.ToLiteral(factory);
            }
            else if (n is VirtuosoDateTimeOffset)
            {
                //New type in Virtuoso 7
                VirtuosoDateTimeOffset vDateTimeOffset = (VirtuosoDateTimeOffset)n;
                DateTimeOffset dateTimeOffset = new DateTimeOffset(vDateTimeOffset.Year, vDateTimeOffset.Month, vDateTimeOffset.Day, vDateTimeOffset.Hour, vDateTimeOffset.Minute, vDateTimeOffset.Second, vDateTimeOffset.Millisecond, vDateTimeOffset.Offset);
                return dateTimeOffset.ToLiteral(factory);
            }
            else
            {
                throw new RdfStorageException("Unexpected Object Type '" + n.GetType().ToString() + "' returned from SPASQL SELECT query to the Virtuoso Quad Store");
            }
            return temp;
        }

        private Uri MarshalUri(String uriData)
        {
            Uri u = new Uri(uriData, UriKind.RelativeOrAbsolute);
            if (!u.IsAbsoluteUri)
            {
                // As of VIRT-375 we marshal this to a form we can round trip later rather than erroring as we did previously
                u = new Uri(VirtuosoRelativeBase, u);
            }
            return u;
        }

        private String UnmarshalUri(Uri u)
        {
            if (u.IsAbsoluteUri)
            {
                if (u.AbsoluteUri.StartsWith(VirtuosoRelativeBaseString))
                {
                    u = new Uri(u.AbsoluteUri.Substring(VirtuosoRelativeBase.AbsoluteUri.Length), UriKind.Relative);
                    return u.OriginalString;
                }
                else
                {
                    return u.AbsoluteUri;
                }
            }
            else
            {
                return u.OriginalString;
            }
        }

        /// <summary>
        /// Saves a Graph into the Quad Store (Warning: Completely replaces any existing Graph with the same URI).
        /// </summary>
        /// <param name="g">Graph to save.</param>
        /// <remarks>
        /// Completely replaces any previously saved Graph with the same Graph URI.
        /// </remarks>
        public override void SaveGraph(IGraph g)
        {
            if (g.BaseUri == null) throw new RdfStorageException("Cannot save a Graph without a Base URI to Virtuoso");

            try
            {
                this.Open(false);

                //Delete the existing Graph (if it exists)
                this.ExecuteNonQuery("DELETE FROM DB.DBA.RDF_QUAD WHERE G = DB.DBA.RDF_MAKE_IID_OF_QNAME('" + this.UnmarshalUri(g.BaseUri) + "')");

                //Make a call to the TTLP() Virtuoso function
                VirtuosoCommand cmd = new VirtuosoCommand();
                cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                cmd.CommandText = "DB.DBA.TTLP(@data, @base, @graph, 1)";
                cmd.Parameters.Add("data", VirtDbType.VarChar);
                cmd.Parameters["data"].Value = VDS.RDF.Writing.StringWriter.Write(g, new NTriplesWriter());
                String baseUri = this.UnmarshalUri(g.BaseUri);
                cmd.Parameters.Add("base", VirtDbType.VarChar);
                cmd.Parameters.Add("graph", VirtDbType.VarChar);
                cmd.Parameters["base"].Value = baseUri;
                cmd.Parameters["graph"].Value = baseUri;
                cmd.Connection = this._db;
                int result = cmd.ExecuteNonQuery();

                this.Close(false);
            }
            catch
            {
                this.Close(true);
                throw;
            }
        }

        /// <summary>
        /// Gets the IO Behaviour of the store.
        /// </summary>
        public override IOBehaviour IOBehaviour
        {
            get { return IOBehaviour.IsQuadStore | IOBehaviour.HasNamedGraphs | IOBehaviour.OverwriteNamed | IOBehaviour.CanUpdateTriples; }
        }

        /// <summary>
        /// Updates a Graph in the Quad Store.
        /// </summary>
        /// <param name="graphUri">Graph Uri of the Graph to update.</param>
        /// <param name="additions">Triples to be added.</param>
        /// <param name="removals">Triples to be removed.</param>
        /// <remarks>
        /// <para>
        /// In the case of inserts where blank nodes are present the data will be inserted but new blank nodes will be created.  You cannot insert data that refers to existing blank nodes via this method, consider using a INSERT WHERE style SPARQL Update instead.
        /// </para>
        /// <para>
        /// Note that Blank Nodes cannot always be deleted successfully, if you have retrieved the triples you are now trying to delete from Virtuoso and they contain blank nodes then this will likely work as expected.  Otherwise deletetions of Blank Nodes cannot be guaranteed.
        /// </para>
        /// <para>
        /// If the Graph being modified is relatively small it may be safer to load the graph into memory, makes the modifications there and then persist the graph back to the store (which overwrites the previous version of the graph).
        /// </para>
        /// </remarks>
        public override void UpdateGraph(Uri graphUri, IEnumerable<Triple> additions, IEnumerable<Triple> removals)
        {
            try
            {
                this.Open(true);
                int r;

                //Build the Delete Data Command
                if (removals != null)
                {
                    if (removals.Any())
                    {
                        //HACK: This is super hacky but works in most cases provided the blank node containing triples
                        //we're attempting to delete originated from Virtuoso
                        //We use the VirtuosoFormatter as our formatter which formats Blank Nodes as calls to the
                        //bif:rdf_make_iid_of_qname('nodeID://bnode') function which works if the blank node originates from Virtuoso

                        VirtuosoCommand deleteCmd = new VirtuosoCommand();
                        deleteCmd.CommandTimeout = (this._timeout > 0 ? this._timeout : deleteCmd.CommandTimeout);
                        StringBuilder delete = new StringBuilder();
                        if (removals.All(t => t.IsGroundTriple))
                        {
                            delete.AppendLine("SPARQL define output:format '_JAVA_' DELETE DATA");
                        }
                        else
                        {
                            //If there are Blank Nodes present we must use a DELETE rather than a DELETE DATA since
                            //DELETE DATA does not allow the backquoted expressions required to do this hack
                            delete.AppendLine("SPARQL define output:format '_JAVA_' DELETE");
                        }
                        if (graphUri != null)
                        {
                            delete.AppendLine(" FROM <" + this.UnmarshalUri(graphUri) + ">");
                        }
                        else
                        {
                            throw new RdfStorageException("Cannot update an unnamed Graph in a Virtuoso Store using this method - you must specify the URI of a Graph to Update");
                        }
                        delete.AppendLine("{");
                        foreach (Triple t in removals)
                        {
                            delete.AppendLine(t.ToString(this._formatter));
                        }
                        delete.AppendLine("}");

                        //If there are Blank Nodes present we will be using a DELETE rather than a DELETE DATA
                        //so we need to add a WHERE clause
                        if (removals.Any(t => !t.IsGroundTriple))
                        {
                            delete.AppendLine("WHERE { }");
                        }

                        //Run the Delete
                        deleteCmd.CommandText = delete.ToString();
                        deleteCmd.Connection = this._db;
                        deleteCmd.Transaction = this._dbtrans;

                        r = deleteCmd.ExecuteNonQuery();
                        if (r < 0) throw new RdfStorageException("Virtuoso encountered an error when deleting Triples");
                    }
                }

                //Build the Insert Data Command
                if (additions != null)
                {
                    if (additions.Any())
                    {
                        if (additions.All(t => t.IsGroundTriple))
                        {
                            VirtuosoCommand insertCmd = new VirtuosoCommand();
                            insertCmd.CommandTimeout = (this._timeout > 0 ? this._timeout : insertCmd.CommandTimeout);
                            StringBuilder insert = new StringBuilder();
                            insert.AppendLine("SPARQL define output:format '_JAVA_' INSERT DATA");
                            if (graphUri != null)
                            {
                                insert.AppendLine(" INTO <" + this.UnmarshalUri(graphUri) + ">");
                            }
                            else
                            {
                                throw new RdfStorageException("Cannot update an unnamed Graph in Virtuoso using this method - you must specify the URI of a Graph to Update");
                            }
                            insert.AppendLine("{");
                            foreach (Triple t in additions)
                            {
                                insert.AppendLine(t.ToString(this._formatter));
                            }
                            insert.AppendLine("}");
                            insertCmd.CommandText = insert.ToString();
                            insertCmd.Connection = this._db;
                            insertCmd.Transaction = this._dbtrans;

                            r = insertCmd.ExecuteNonQuery();
                            if (r < 0) throw new RdfStorageException("Virtuoso encountered an error when inserting Triples");
                        }
                        else
                        {
                            //When data to be inserted contains Blank Nodes we must make a call to the TTLP() Virtuoso function
                            //instead of using INSERT DATA
                            Graph g = new Graph();
                            g.Assert(additions);
                            VirtuosoCommand cmd = new VirtuosoCommand();
                            cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                            cmd.CommandText = "DB.DBA.TTLP(@data, @base, @graph, 1)";
                            cmd.Parameters.Add("data", VirtDbType.VarChar);
                            cmd.Parameters["data"].Value = VDS.RDF.Writing.StringWriter.Write(g, new NTriplesWriter());
                            String baseUri = this.UnmarshalUri(graphUri);
                            if (String.IsNullOrEmpty(baseUri)) throw new RdfStorageException("Cannot updated an unnamed Graph in Virtuoso using this method - you must specify the URI of a Graph to Update");
                            cmd.Parameters.Add("base", VirtDbType.VarChar);
                            cmd.Parameters.Add("graph", VirtDbType.VarChar);
                            cmd.Parameters["base"].Value = baseUri;
                            cmd.Parameters["graph"].Value = baseUri;
                            cmd.Connection = this._db;
                            int result = cmd.ExecuteNonQuery();
                        }
                    }
                }

                this.Close(false);
            }
            catch
            {
                this.Close(true, true);
                throw;
            }
        }

        /// <summary>
        /// Updates a Graph in the Quad Store.
        /// </summary>
        /// <param name="graphUri">Graph Uri of the Graph to update.</param>
        /// <param name="additions">Triples to be added.</param>
        /// <param name="removals">Triples to be removed.</param>
        public override void UpdateGraph(String graphUri, IEnumerable<Triple> additions, IEnumerable<Triple> removals)
        {
            Uri u = (graphUri.Equals(String.Empty)) ? null : UriFactory.Create(graphUri);
            this.UpdateGraph(u, additions, removals);
        }

        /// <summary>
        /// Indicates that Updates are supported by the Virtuoso Native Quad Store.
        /// </summary>
        public override bool UpdateSupported
        {
            get { return true; }
        }

        /// <summary>
        /// Returns that the Manager is ready.
        /// </summary>
        public override bool IsReady
        {
            get { return true; }
        }

        /// <summary>
        /// Returns that the Manager is not read-only.
        /// </summary>
        public override bool IsReadOnly
        {
            get { return false; }
        }

        #endregion

        #region Native Query & Update

        /// <summary>
        /// Executes a SPARQL Query on the native Quad Store.
        /// </summary>
        /// <param name="sparqlQuery">SPARQL Query to execute.</param>
        /// <returns></returns>
        /// <remarks>
        /// <para>
        /// This method will first attempt to parse the query into a <see cref="SparqlQuery">SparqlQuery</see> object.  If this succeeds then the Query Type can be used to determine how to handle the response.
        /// </para>
        /// <para>
        /// If the parsing fails then the query will be executed anyway using Virtuoso's SPASQL (SPARQL + SQL) syntax.  Parsing can fail because Virtuoso supports various SPARQL extensions which the library does not support.  These include things like aggregate functions but also SPARUL updates (the non-standard precusor to SPARQL 1.1 Update).
        /// </para>
        /// <para>
        /// If you use an aggregate query which has an Integer, Decimal or Double type result then you will receive a <see cref="SparqlResultSet">SparqlResultSet</see> containing a single <see cref="SparqlResult">SparqlResult</see> which has contains a binding for a variable named <strong>Result</strong> which contains a <see cref="LiteralNode">LiteralNode</see> typed to the appropriate datatype.
        /// </para>
        /// </remarks>
        /// <exception cref="RdfQueryException">Thrown if an error occurs in making the query.</exception>
        public Object Query(String sparqlQuery)
        {
            Graph g = new Graph();
            SparqlResultSet results = new SparqlResultSet();
            this.Query(new GraphHandler(g), new ResultSetHandler(results), sparqlQuery);

            if (results.ResultsType != SparqlResultsType.Unknown)
            {
                return results;
            }
            return g;
        }

        /// <summary>
        /// Executes a SPARQL Query on the native Quad Store processing the results with an appropriate handler from those provided.
        /// </summary>
        /// <param name="rdfHandler">RDF Handler.</param>
        /// <param name="resultsHandler">Results Handler.</param>
        /// <param name="sparqlQuery">SPARQL Query to execute.</param>
        /// <remarks>
        /// <para>
        /// This method will first attempt to parse the query into a <see cref="SparqlQuery">SparqlQuery</see> object.  If this succeeds then the Query Type can be used to determine how to handle the response.
        /// </para>
        /// <para>
        /// If the parsing fails then the query will be executed anyway using Virtuoso's SPASQL (SPARQL + SQL) syntax.  Parsing can fail because Virtuoso supports various SPARQL non-standardised extensions which the library does not support.  These include things like aggregate functions but also SPARUL updates (the non-standard precusor to SPARQL 1.1 Update).
        /// </para>
        /// <para>
        /// If you use an aggregate query which has an Integer, Decimal or Double type result then you will receive a <see cref="SparqlResultSet">SparqlResultSet</see> containing a single <see cref="SparqlResult">SparqlResult</see> which has contains a binding for a variable named <strong>Result</strong> which contains a <see cref="LiteralNode">LiteralNode</see> typed to the appropriate datatype.
        /// </para>
        /// </remarks>
        /// <exception cref="RdfQueryException">Thrown if an error occurs in making the query.</exception>
        public void Query(IRdfHandler rdfHandler, ISparqlResultsHandler resultsHandler, String sparqlQuery)
        {
            try
            {
                if (resultsHandler != null) resultsHandler.StartResults();

                DataTable results = new DataTable();
                results.Columns.CollectionChanged += Columns_CollectionChanged;

                //See if the query can be parsed into a SparqlQuery object
                //It might not since the user might use Virtuoso's extensions to Sparql in their query
                try
                {
                    //We'll set the Parser to SPARQL 1.1 mode even though Virtuoso's SPARQL implementation has
                    //various perculiarties in their SPARQL 1.1 implementation and we'll try and 
                    //handle the potential results in the catch branch if a valid SPARQL 1.0 query
                    //cannot be parsed
                    //Change made in response to a bug report by Aleksandr A. Zaripov [zaripov@tpu.ru]
                    SparqlQueryParser parser = new SparqlQueryParser();
                    parser.SyntaxMode = SparqlQuerySyntax.Sparql_1_1;
                    SparqlQuery query;
                    try
                    {
                        query = parser.ParseFromString(sparqlQuery);
                    }
                    catch (RdfException rdfEx)
                    {
                        //Need to re-wrap errors during parsing so we fall into correct catch branch, can't generally re-wrap as we might
                        //get RdfException's from other places which would indicate unrecoverable errors
                        throw new RdfParseException("RDF exception generated in query parsing", rdfEx);
                    }

                    switch (query.QueryType)
                    {
                        case SparqlQueryType.Select:
                        case SparqlQueryType.SelectAll:
                        case SparqlQueryType.SelectAllDistinct:
                        case SparqlQueryType.SelectAllReduced:
                        case SparqlQueryType.SelectDistinct:
                        case SparqlQueryType.SelectReduced:
                            //Type the Tables columns as System.Object
                            foreach (SparqlVariable var in query.Variables)
                            {
                                if (var.IsResultVariable)
                                {
                                    results.Columns.Add(var.Name, typeof (System.Object));
                                }
                            }
                            break;
                    }

                    try
                    {
                        #region Valid SPARQL Query Handling

                        this.Open(false);

                        //Make the Query against Virtuoso
                        VirtuosoCommand cmd = this._db.CreateCommand();
                        cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                        cmd.CommandText = "SPARQL " + sparqlQuery;
                        VirtuosoDataAdapter adapter = new VirtuosoDataAdapter(cmd);
                        adapter.Fill(results);

                        //Decide how to process the results based on the return type
                        switch (query.QueryType)
                        {
                            case SparqlQueryType.Ask:
                                //Expect a DataTable containing a single row and column which contains a boolean

                                //Ensure Results Handler is not null
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle a Boolean Result with a null SPARQL Results Handler");

                                if (results.Rows.Count == 1 && results.Columns.Count == 1)
                                {
                                    //Try and parse the result
                                    bool result;
                                    int r;
                                    if (Boolean.TryParse(results.Rows[0][0].ToString(), out result))
                                    {
                                        resultsHandler.HandleBooleanResult(result);
                                    }
                                    else if (Int32.TryParse(results.Rows[0][0].ToString(), out r))
                                    {
                                        resultsHandler.HandleBooleanResult(r == 1);
                                    }
                                    else
                                    {
                                        throw new RdfQueryException("Expected a Boolean as the result of an ASK query but the non-boolean value '" + results.Rows[0][0].ToString() + "' was received");
                                    }
                                }
                                else
                                {
                                    //If we get anything else then we'll return that the result was False
                                    resultsHandler.HandleBooleanResult(false);
                                }
                                break;

                            case SparqlQueryType.Construct:
                            case SparqlQueryType.Describe:
                            case SparqlQueryType.DescribeAll:
                                //Expect a DataTable containing a single row and column which contains a String
                                //That string will be a Turtle serialization of the Graph

                                //Ensure that RDF Handler is not null
                                if (rdfHandler == null) throw new ArgumentNullException("rdfHandler", "Cannot handle a Graph result with a null RDF Handler");

                                if (results.Rows.Count == 1 && results.Columns.Count == 1)
                                {
                                    try
                                    {
                                        //Use StringParser to parse
                                        String data = results.Rows[0][0].ToString();
                                        TurtleParser ttlparser = new TurtleParser();
                                        ttlparser.Load(rdfHandler, new StringReader(data));
                                    }
                                    catch (RdfParseException parseEx)
                                    {
                                        throw new RdfQueryException("Expected a valid Turtle serialization of the Graph resulting from a CONSTRUCT/DESCRIBE query but the result failed to parse", parseEx);
                                    }
                                }
                                else if (results.Columns.Count == 3)
                                {
                                    rdfHandler.StartRdf();
                                    try
                                    {
                                        foreach (DataRow row in results.Rows)
                                        {
                                            INode s = this.LoadNode(rdfHandler, row[0]);
                                            INode p = this.LoadNode(rdfHandler, row[1]);
                                            INode o = this.LoadNode(rdfHandler, row[2]);
                                            if (!rdfHandler.HandleTriple(new Triple(s, p, o))) break;
                                        }
                                        rdfHandler.EndRdf(true);
                                    }
                                    catch
                                    {
                                        rdfHandler.EndRdf(false);
                                        throw;
                                    }
                                }
                                else
                                {
                                    throw new RdfQueryException("Unexpected results data received for a CONSTRUCT/DESCRIBE query (Got " + results.Rows.Count + " row(s) with " + results.Columns.Count + " column(s)");
                                }
                                break;

                            case SparqlQueryType.Select:
                            case SparqlQueryType.SelectAll:
                            case SparqlQueryType.SelectAllDistinct:
                            case SparqlQueryType.SelectAllReduced:
                            case SparqlQueryType.SelectDistinct:
                            case SparqlQueryType.SelectReduced:
                                //Ensure Results Handler is not null
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL Results with a null Results Handler");

                                //Get Result Variables
                                List<SparqlVariable> resultVars = query.Variables.Where(v => v.IsResultVariable).ToList();
                                foreach (SparqlVariable var in resultVars)
                                {
                                    if (!resultsHandler.HandleVariable(var.Name)) ParserHelper.Stop();
                                }
                                Graph temp = new Graph();

                                //Convert each solution into a SPARQLResult
                                foreach (DataRow r in results.Rows)
                                {
                                    Set s = new Set();
                                    foreach (SparqlVariable var in resultVars)
                                    {
                                        if (r[var.Name] != null)
                                        {
                                            s.Add(var.Name, this.LoadNode(temp, r[var.Name]));
                                        }
                                    }
                                    if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                                }
                                break;

                            default:
                                throw new RdfQueryException("Unable to process the Results of an Unknown query type");
                        }

                        this.Close(false);

                        #endregion
                    }
                    catch
                    {
                        throw;
                    }
                }
                catch (RdfParseException)
                {
                    //Unable to parse a SPARQL 1.0 query
                    //Have to attempt to detect the return type based on the DataTable that
                    //the SPASQL (Sparql+SQL) query gives back

                    try
                    {
                        #region Potentially Invalid SPARQL Query Handling

                        this.Open(false);

                        //Make the Query against Virtuoso
                        VirtuosoCommand cmd = this._db.CreateCommand();
                        cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                        cmd.CommandText = "SPARQL " /*define output:format '_JAVA_' "*/+ sparqlQuery;
                        VirtuosoDataAdapter adapter = new VirtuosoDataAdapter(cmd);
                        adapter.Fill(results);

                        //Try to detect the return type based on the DataTable configuration
                        if (results.Columns.Count == 3
                                && results.Columns[0].ColumnName.Equals(SubjectColumn)
                                && results.Columns[1].ColumnName.Equals(PredicateColumn)
                                && results.Columns[2].ColumnName.Equals(ObjectColumn)
                                && !Regex.IsMatch(sparqlQuery, "SELECT", RegexOptions.IgnoreCase))
                        {
                            //Ensure that RDF Handler is not null
                            if (rdfHandler == null) throw new ArgumentNullException("rdfHandler", "Cannot handle a Graph result with a null RDF Handler");

                            rdfHandler.StartRdf();
                            try
                            {
                                foreach (DataRow row in results.Rows)
                                {
                                    INode s = this.LoadNode(rdfHandler, row[0]);
                                    INode p = this.LoadNode(rdfHandler, row[1]);
                                    INode o = this.LoadNode(rdfHandler, row[2]);
                                    if (!rdfHandler.HandleTriple(new Triple(s, p, o))) break;
                                }
                                rdfHandler.EndRdf(true);
                            }
                            catch
                            {
                                rdfHandler.EndRdf(false);
                                throw;
                            }
                        }
                        else if (results.Rows.Count == 0 && results.Columns.Count > 0)
                        {
                            if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL Results with a null Results Handler");

                            //No Rows but some columns implies empty SELECT results
                            foreach (DataColumn col in results.Columns)
                            {
                                if (!resultsHandler.HandleVariable(col.ColumnName)) ParserHelper.Stop();
                            }
                        }
                        else if (results.Rows.Count == 1 && results.Columns.Count == 1 && !Regex.IsMatch(sparqlQuery, "SELECT", RegexOptions.IgnoreCase))
                        {
                            //Added a fix here suggested by Alexander Sidorov - not entirely happy with this fix as what happens if SELECT just happens to occur in a URI/Variable Name?

                            //Single Row and Column implies ASK/DESCRIBE/CONSTRUCT results
                            bool result;
                            int r;
                            decimal rdec;
                            double rdbl;
                            float rflt;

                            if (results.Rows[0][0].ToString().Equals(String.Empty))
                            {
                                //Empty Results - no need to do anything
                            }
                            else if (Boolean.TryParse(results.Rows[0][0].ToString(), out result))
                            {
                                //Parseable Boolean so ASK Results
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle a Boolean result with a null Results Handler");
                                resultsHandler.HandleBooleanResult(result);
                            }
                            else if (Int32.TryParse(results.Rows[0][0].ToString(), out r))
                            {
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                                //Parseable Integer so Aggregate SELECT Query Results
                                if (!resultsHandler.HandleVariable("Result")) ParserHelper.Stop();
                                Set s = new Set();
                                s.Add("Result", r.ToLiteral(resultsHandler));
                                if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                            }
                            else if (Single.TryParse(results.Rows[0][0].ToString(), out rflt))
                            {
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                                //Parseable Single so Aggregate SELECT Query Results
                                if (!resultsHandler.HandleVariable("Result")) ParserHelper.Stop();
                                Set s = new Set();
                                s.Add("Result", rflt.ToLiteral(resultsHandler));
                                if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                            }
                            else if (Double.TryParse(results.Rows[0][0].ToString(), out rdbl))
                            {
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                                //Parseable Double so Aggregate SELECT Query Results
                                if (!resultsHandler.HandleVariable("Result")) ParserHelper.Stop();
                                Set s = new Set();
                                s.Add("Result", rdbl.ToLiteral(resultsHandler));
                                if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                            }
                            else if (Decimal.TryParse(results.Rows[0][0].ToString(), out rdec))
                            {
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                                //Parseable Decimal so Aggregate SELECT Query Results
                                if (!resultsHandler.HandleVariable("Result")) ParserHelper.Stop();
                                Set s = new Set();
                                s.Add("Result", rdec.ToLiteral(resultsHandler));
                                if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                            }
                            else
                            {
                                //String so try and parse as Turtle
                                try
                                {
                                    //Use StringParser to parse
                                    String data = results.Rows[0][0].ToString();
                                    TurtleParser ttlparser = new TurtleParser();
                                    ttlparser.Load(rdfHandler, new StringReader(data));
                                }
                                catch (RdfParseException)
                                {
                                    if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                                    //If it failed to parse then it might be the result of one of the aggregate
                                    //functions that Virtuoso extends Sparql with
                                    if (!resultsHandler.HandleVariable(results.Columns[0].ColumnName)) ParserHelper.Stop();
                                    Set s = new Set();
                                    s.Add(results.Columns[0].ColumnName, this.LoadNode(resultsHandler, results.Rows[0][0]));
                                    //Nothing was returned here previously - fix submitted by Aleksandr A. Zaripov [zaripov@tpu.ru]
                                    if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                                }
                            }
                        }
                        else
                        {
                            //Any other number of rows/columns we have to assume that it's normal SELECT results
                            //Changed in response to bug report by Aleksandr A. Zaripov [zaripov@tpu.ru]

                            if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                            //Get Result Variables
                            List<String> vars = new List<string>();
                            foreach (DataColumn col in results.Columns)
                            {
                                vars.Add(col.ColumnName);
                                if (!resultsHandler.HandleVariable(col.ColumnName)) ParserHelper.Stop();
                            }

                            //Convert each solution into a SPARQLResult
                            foreach (DataRow r in results.Rows)
                            {
                                Set s = new Set();
                                foreach (String var in vars)
                                {
                                    if (r[var] != null)
                                    {
                                        s.Add(var, this.LoadNode(resultsHandler, r[var]));
                                    }
                                }
                                if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                            }
                        }
                        this.Close(false);

                        #endregion
                    }
                    catch
                    {
                        this.Close(true, true);
                        throw;
                    }
                }

                if (resultsHandler != null) resultsHandler.EndResults(true);
                this.Close(false);
            }
            catch (RdfParsingTerminatedException)
            {
                if (resultsHandler != null) resultsHandler.EndResults(true);
                this.Close(false);
            }
            catch
            {
                this.Close(true);
                if (resultsHandler != null) resultsHandler.EndResults(false);
                this.Close(false);
                throw;
            }
        }

        private static void Columns_CollectionChanged(object sender, System.ComponentModel.CollectionChangeEventArgs e)
        {
            Type reqType = typeof (Object);
            if (e.Action != System.ComponentModel.CollectionChangeAction.Add) return;
            DataColumn column = (DataColumn) e.Element;
            if (!column.DataType.Equals(reqType))
            {
                column.DataType = reqType;
            }
        }

        /// <summary>
        /// Executes a SPARQL Update on the native Quad Store.
        /// </summary>
        /// <param name="sparqlUpdate">SPARQL Update to execute.</param>
        /// <remarks>
        /// <para>
        /// This method will first attempt to parse the update into a <see cref="SparqlUpdateCommandSet">SparqlUpdateCommandSet</see> object.  If this succeeds then each command in the command set will be issued to Virtuoso.
        /// </para>
        /// <para>
        /// If the parsing fails then the update will be executed anyway using Virtuoso's SPASQL (SPARQL + SQL) syntax.  Parsing can fail because Virtuoso supports various SPARQL extensions which the library does not support and primarily supports SPARUL updates (the precusor to SPARQL 1.1 Update).
        /// </para>
        /// </remarks>
        /// <exception cref="SparqlUpdateException">Thrown if an error occurs in making the update.</exception>
        public void Update(String sparqlUpdate)
        {
            try
            {
                this.Open(true);

                //Try and parse the SPARQL Update String
                SparqlUpdateParser parser = new SparqlUpdateParser();
                SparqlUpdateCommandSet commands = parser.ParseFromString(sparqlUpdate);

                //Process each Command individually
                foreach (SparqlUpdateCommand command in commands.Commands)
                {
                    //Make the Update against Virtuoso
                    VirtuosoCommand cmd = this._db.CreateCommand();
                    cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                    cmd.CommandText = "SPARQL " + command.ToString();
                    cmd.ExecuteNonQuery();
                }

                this.Close(true);
            }
            catch (RdfParseException)
            {
                try
                {
                    //Ignore failed parsing and attempt to execute anyway
                    VirtuosoCommand cmd = this._db.CreateCommand();
                    cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                    cmd.CommandText = "SPARQL " + sparqlUpdate;

                    cmd.ExecuteNonQuery();
                    this.Close(true);
                }
                catch (Exception ex)
                {
                    this.Close(true, true);
                    throw new SparqlUpdateException("An error occurred while trying to perform the SPARQL Update with Virtuoso.  Note that Virtuoso historically has primarily supported SPARUL (the precursor to SPARQL Update) and many valid SPARQL Update Commands may not be supported by Virtuoso", ex);
                }
            }
            catch (SparqlUpdateException)
            {
                this.Close(true, true);
                throw;
            }
            catch (Exception ex)
            {
                //Wrap in a SPARQL Update Exception
                this.Close(true, true);
                throw new SparqlUpdateException("An error occurred while trying to perform the SPARQL Update with Virtuoso.  Note that Virtuoso historically has primarily supported SPARUL (the precursor to SPARQL Update) and many valid SPARQL Update Commands may not be supported by Virtuoso if you are not using a recent version.", ex);
            }
        }

        #endregion

        /// <summary>
        /// Deletes a Graph from the Virtuoso store.
        /// </summary>
        /// <param name="graphUri">URI of the Graph to delete.</param>
        public override void DeleteGraph(Uri graphUri)
        {
            this.DeleteGraph(this.UnmarshalUri(graphUri));
        }

        /// <summary>
        /// Deletes a Graph from the store.
        /// </summary>
        /// <param name="graphUri">URI of the Graph to delete.</param>
        public override void DeleteGraph(String graphUri)
        {
            if (graphUri == null) return;
            if (graphUri.Equals(String.Empty)) return;

            try
            {
                this.Open(false);
                this.ExecuteNonQuery("DELETE FROM DB.DBA.RDF_QUAD WHERE G = DB.DBA.RDF_MAKE_IID_OF_QNAME('" + graphUri + "')");
                this.Close(false);
            }
            catch
            {
                this.Close(true, true);
                throw;
            }
        }

        /// <summary>
        /// Returns that deleting Graphs is supported.
        /// </summary>
        public override bool DeleteSupported
        {
            get { return true; }
        }

        /// <summary>
        /// Lists the Graphs in the store.
        /// </summary>
        /// <returns></returns>
        public override IEnumerable<Uri> ListGraphs()
        {
            try
            {
                Object results = this.Query("SELECT DISTINCT ?g WHERE { GRAPH ?g { ?s ?p ?o } }");
                if (results is SparqlResultSet)
                {
                    List<Uri> graphs = new List<Uri>();
                    foreach (SparqlResult r in ((SparqlResultSet) results))
                    {
                        if (r.HasValue("g"))
                        {
                            INode temp = r["g"];
                            try
                            {
                                if (temp.NodeType == NodeType.Uri)
                                {
                                    graphs.Add(((IUriNode) temp).Uri);
                                }
                                else if (temp.NodeType == NodeType.Literal)
                                {
                                    //HACK: Virtuoso wrongly returns Literals instead of URIs in the results for the above query prior to Virtuoso 6.1.3
                                    graphs.Add(UriFactory.Create(((ILiteralNode) temp).Value));
                                }
                            }
                            catch
                            {
                                //HACK: Virtuoso has some special Graphs which have non-URI names so ignore these
                                continue;
                            }
                        }
                    }
                    return graphs;
                }
                else
                {
                    return Enumerable.Empty<Uri>();
                }
            }
            catch (Exception ex)
            {
                throw new RdfStorageException("Underlying Store returned an error while trying to List Graphs", ex);
            }
        }

        /// <summary>
        /// Returns that listing graphs is supported.
        /// </summary>
        public override bool ListGraphsSupported
        {
            get { return true; }
        }

        #region Database IO

        /// <summary>
        /// Opens a Connection to the Database.
        /// </summary>
        /// <param name="keepOpen">Indicates that the Connection should be kept open and a Transaction started.</param>
        private void Open(bool keepOpen)
        {
            this.Open(keepOpen, IsolationLevel.ReadCommitted);
        }

        /// <summary>
        /// Opens a Connection to the Database.
        /// </summary>
        /// <param name="keepOpen">Indicates that the Connection should be kept open and a Transaction started.</param>
        /// <param name="level">Isolation Level to use.</param>
        private void Open(bool keepOpen, IsolationLevel level)
        {
            switch (this._db.State)
            {
                case ConnectionState.Broken:
                case ConnectionState.Closed:
                    this._db.Open();

                    //Start a Transaction
                    if (this._dbtrans == null)
                    {
                        this._dbtrans = this._db.BeginTransaction(level);
                    }
                    break;
            }
            if (keepOpen) this._keepOpen = true;
        }

        /// <summary>
        /// Closes the Connection to the Database.
        /// </summary>
        /// <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened.</param>
        private void Close(bool forceClose)
        {
            this.Close(forceClose, false);
        }

        /// <summary>
        /// Closes the Connection to the Database.
        /// </summary>
        /// <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened.</param>
        /// <param name="rollbackTrans">Indicates that the Transaction should be rolled back because something has gone wrong.</param>
        private void Close(bool forceClose, bool rollbackTrans)
        {
            //Don't close if we're keeping open and not forcing Close or rolling back a Transaction
            if (this._keepOpen && !forceClose && !rollbackTrans)
            {
                return;
            }

            switch (this._db.State)
            {
                case ConnectionState.Open:
                    //Finish the Transaction if exists
                    if (this._dbtrans != null)
                    {
                        if (!rollbackTrans)
                        {
                            //Commit normally
                            this._dbtrans.Commit();
                        }
                        else
                        {
                            //Want to Rollback
                            this._dbtrans.Rollback();
                        }
                        this._dbtrans = null;

                        this._db.Close();
                    }

                    this._keepOpen = false;
                    break;
            }
        }

        /// <summary>
        /// Executes a Non-Query SQL Command against the database.
        /// </summary>
        /// <param name="sqlCmd">SQL Command.</param>
        private void ExecuteNonQuery(string sqlCmd)
        {
            //Create the SQL Command
            VirtuosoCommand cmd = new VirtuosoCommand(sqlCmd, this._db);
            cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
            if (this._dbtrans != null)
            {
                //Add to the Transaction if required
                cmd.Transaction = this._dbtrans;
            }

            //Execute
            cmd.ExecuteNonQuery();
        }

        /// <summary>
        /// Executes a Query SQL Command against the database and returns a DataTable.
        /// </summary>
        /// <param name="sqlCmd">SQL Command.</param>
        /// <returns>DataTable of results.</returns>
        private DataTable ExecuteQuery(string sqlCmd)
        {
            //Create the SQL Command
            VirtuosoCommand cmd = new VirtuosoCommand(sqlCmd, this._db);
            cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
            if (this._dbtrans != null)
            {
                //Add to the Transaction if required
                cmd.Transaction = this._dbtrans;
            }

            //Execute the Query
            VirtuosoDataAdapter adapter = new VirtuosoDataAdapter(cmd);
            DataTable results = new DataTable();
            adapter.Fill(results);

            return results;
        }

        /// <summary>
        /// Executes a Query SQL Command against the database and returns the scalar result (first column of first row of the result).
        /// </summary>
        /// <param name="sqlCmd">SQL Command.</param>
        /// <returns>First Column of First Row of the Results.</returns>
        private object ExecuteScalar(string sqlCmd)
        {
            //Create the SQL Command
            VirtuosoCommand cmd = new VirtuosoCommand(sqlCmd, this._db);
            cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
            if (this._dbtrans != null)
            {
                //Add to the Transaction if required
                cmd.Transaction = this._dbtrans;
            }

            //Execute the Scalar
            return cmd.ExecuteScalar();
        }

        /// <summary>
        /// Gets whether there is an active connection to the Virtuoso database.
        /// </summary>
        public bool HasOpenConnection
        {
            get { return this._db.State != ConnectionState.Broken && this._db.State != ConnectionState.Closed; }
        }

        /// <summary>
        /// Gets whether there is any active transaction on the Virtuoso database.
        /// </summary>
        public bool HasActiveTransaction
        {
            get { return !ReferenceEquals(this._dbtrans, null); }
        }

        #endregion

        #region IDisposable Members

        /// <summary>
        /// Disposes of the Manager.
        /// </summary>
        public override void Dispose()
        {
            this.Close(true, false);
        }

        #endregion

        /// <summary>
        /// Gets a String which gives details of the Connection.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (this._customConnString)
            {
                return "[Virtuoso] Custom Connection String";
            }
            return "[Virtuoso] " + this._dbserver + ":" + this._dbport;
        }

        /// <summary>
        /// Serializes the connection's configuration.
        /// </summary>
        /// <param name="context">Configuration Serialization Context.</param>
        public void SerializeConfiguration(ConfigurationSerializationContext context)
        {
            if (this._customConnString)
            {
                throw new DotNetRdfConfigurationException("Cannot serialize the configuration of a VirtuosoManager which was created with a custom connection string");
            }

            //Firstly need to ensure our object factory has been referenced
            context.EnsureObjectFactory(typeof (VirtuosoObjectFactory));

            //Then serialize the actual configuration
            INode dnrType = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyType));
            INode rdfType = context.Graph.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType));
            INode manager = context.NextSubject;
            INode rdfsLabel = context.Graph.CreateUriNode(UriFactory.Create(NamespaceMapper.RDFS + "label"));
            INode genericManager = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.ClassStorageProvider));
            INode server = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyServer));

            context.Graph.Assert(new Triple(manager, rdfType, genericManager));
            context.Graph.Assert(new Triple(manager, rdfsLabel, context.Graph.CreateLiteralNode(this.ToString())));
            context.Graph.Assert(new Triple(manager, dnrType, context.Graph.CreateLiteralNode(this.GetType().FullName + ", dotNetRDF.Data.Virtuoso")));
            context.Graph.Assert(new Triple(manager, server, context.Graph.CreateLiteralNode(this._dbserver)));

            if (this._dbport != DefaultPort)
            {
                INode port = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyPort));
                context.Graph.Assert(new Triple(manager, port, this._dbport.ToLiteral(context.Graph)));
            }
            if (!this._dbname.Equals(DefaultDB))
            {
                INode db = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyDatabase));
                context.Graph.Assert(new Triple(manager, db, context.Graph.CreateLiteralNode(this._dbname)));
            }
            if (this._timeout > 0)
            {
                INode timeout = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyTimeout));
                context.Graph.Assert(new Triple(manager, timeout, this._timeout.ToLiteral(context.Graph)));
            }
            if (this._dbuser != null && this._dbpwd != null)
            {
                INode username = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyUser));
                INode pwd = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyPassword));
                context.Graph.Assert(new Triple(manager, username, context.Graph.CreateLiteralNode(this._dbuser)));
                context.Graph.Assert(new Triple(manager, pwd, context.Graph.CreateLiteralNode(this._dbpwd)));
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using OpenLink.Data.Virtuoso;
using VDS.RDF.Configuration;
using VDS.RDF.Parsing;
using VDS.RDF.Parsing.Handlers;
using VDS.RDF.Query;
using VDS.RDF.Query.Algebra;
using VDS.RDF.Update;
using VDS.RDF.Writing;
using VDS.RDF.Writing.Formatting;

namespace VDS.RDF.Storage
{
    /// <summary>
    /// A Manager for accessing the Native Virtuoso Quad Store.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This class implements <see cref="IStorageProvider">IStorageProvider</see> allowing it to be used with any of the general classes that support this interface as well as the Virtuoso specific classes.
    /// </para>
    /// <para>
    /// Although this class takes a Database Name to ensure compatability with any Virtuoso installation (i.e. this allows for the Native Quad Store to be in a non-standard database) generally you should always specify <strong>DB</strong> as the Database Name parameter.
    /// </para>
    /// <para>
    /// Virtuoso automatically assigns IDs to Blank Nodes input into it, these IDs are <strong>not</strong> based on the actual Blank Node ID so inputting a Blank Node with the same ID multiple times will result in multiple Nodes being created in Virtuoso.  This means that data containing Blank Nodes which is stored to Virtuoso and then retrieved will have different Blank Node IDs to those input.  In addition there is no guarentee that when you save a Graph containing Blank Nodes into Virtuoso that retrieving it will give the same Blank Node IDs even if the Graph being saved was originally retrieved from Virtuoso.  Finally please see the remarks on the <see cref="VirtuosoManager.UpdateGraph(Uri,IEnumerable{Triple},IEnumerable{Triple})">UpdateGraph()</see> method which deal with how insertion and deletion of triples containing blank nodes into existing graphs operates.
    /// </para>
    /// <para>
    /// You can use a null Uri or an empty String as a Uri to indicate that operations should affect the Default Graph.  Where the argument is only a Graph a null <see cref="IGraph.BaseUri">BaseUri</see> property indicates that the Graph affects the Default Graph.
    /// </para>
    /// </remarks>
    public class VirtuosoManager
        : BaseAsyncSafeConnector, IUpdateableStorage, IConfigurationSerializable
    {
        /// <summary>
        /// Default Port for Virtuoso Servers.
        /// </summary>
        public const int DefaultPort = 1111;

        /// <summary>
        /// Default Database for Virtuoso Server Quad Store.
        /// </summary>
        public const String DefaultDB = "DB";

        private const String SubjectColumn = "S", PredicateColumn = "P", ObjectColumn = "O";
        private const String VirtuosoRelativeBaseString = "virtuoso-relative:";
        private readonly Uri VirtuosoRelativeBase = new Uri(VirtuosoRelativeBaseString);

        #region Variables & Constructors

        private readonly VirtuosoConnection _db;
        private VirtuosoTransaction _dbtrans;
        private readonly ITripleFormatter _formatter = new VirtuosoFormatter();

        private readonly String _dbserver, _dbname, _dbuser, _dbpwd;
        private readonly int _dbport, _timeout = 0;

        /// <summary>
        /// Indicates whether the Database Connection is currently being kept open.
        /// </summary>
        private bool _keepOpen = false;

        private readonly bool _customConnString = false;

        /// <summary>
        /// Creates a Manager for a Virtuoso Native Quad Store.
        /// </summary>
        /// <param name="server">Server.</param>
        /// <param name="port">Port.</param>
        /// <param name="db">Database Name.</param>
        /// <param name="user">Username.</param>
        /// <param name="password">Password.</param>
        /// <param name="timeout">Connection Timeout in Seconds.</param>
        /// <remarks>
        /// Timeouts less than equal to zero are ignored and treated as using the default timeout which is dictated by the underlying Virtuoso ADO.Net provider.
        /// </remarks>
        public VirtuosoManager(String server, int port, String db, String user, String password, int timeout)
        {
            //Set the Connection Properties
            this._dbserver = server;
            this._dbname = db;
            this._dbuser = user;
            this._dbpwd = password;
            this._dbport = port;
            this._timeout = timeout;

            StringBuilder connString = new StringBuilder();
            connString.Append("Server=");
            connString.Append(this._dbserver);
            connString.Append(":");
            connString.Append(this._dbport);
            connString.Append(";Database=");
            connString.Append(this._dbname);
            connString.Append(";uid=");
            connString.Append(this._dbuser);
            connString.Append(";pwd=");
            connString.Append(this._dbpwd);
            connString.Append(";Charset=utf-8");
            if (this._timeout > 0)
            {
                connString.Append(";Connection Timeout=" + this._timeout);
            }

            //Create the Connection Object
            this._db = new VirtuosoConnection(connString.ToString());
        }

        /// <summary>
        /// Creates a Manager for a Virtuoso Native Quad Store.
        /// </summary>
        /// <param name="server">Server.</param>
        /// <param name="port">Port.</param>
        /// <param name="db">Database Name.</param>
        /// <param name="user">Username.</param>
        /// <param name="password">Password.</param>
        public VirtuosoManager(String server, int port, String db, String user, String password)
            : this(server, port, db, user, password, 0)
        {
        }

        /// <summary>
        /// Creates a Manager for a Virtuoso Native Quad Store.
        /// </summary>
        /// <param name="db">Database Name.</param>
        /// <param name="user">Username.</param>
        /// <param name="password">Password.</param>
        /// <param name="timeout">Connection Timeout in Seconds.</param>
        /// <remarks>
        /// Assumes the Server is on the localhost and the port is the default installation port of 1111.
        /// </remarks>
        public VirtuosoManager(String db, String user, String password, int timeout)
            : this("localhost", VirtuosoManager.DefaultPort, db, user, password, timeout)
        {
        }

        /// <summary>
        /// Creates a Manager for a Virtuoso Native Quad Store.
        /// </summary>
        /// <param name="db">Database Name.</param>
        /// <param name="user">Username.</param>
        /// <param name="password">Password.</param>
        /// <remarks>
        /// Assumes the Server is on the localhost and the port is the default installation port of 1111.
        /// </remarks>
        public VirtuosoManager(String db, String user, String password)
            : this("localhost", VirtuosoManager.DefaultPort, db, user, password, 0)
        {
        }

        /// <summary>
        /// Creates a Manager for a Virtuoso Native Quad Store.
        /// </summary>
        /// <param name="connectionString">Connection String.</param>
        /// <remarks>
        /// Allows the end user to specify a customised connection string.
        /// </remarks>
        public VirtuosoManager(String connectionString)
        {
            this._db = new VirtuosoConnection(connectionString);
            this._customConnString = true;
        }

        #endregion

        #region Triple Loading & Saving

        /// <summary>
        /// Loads a Graph from the Quad Store.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="graphUri">URI of the Graph to Load.</param>
        public override void LoadGraph(IGraph g, Uri graphUri)
        {
            if (g.IsEmpty && graphUri != null)
            {
                g.BaseUri = graphUri;
            }
            this.LoadGraph(new GraphHandler(g), graphUri);
        }

        /// <summary>
        /// Loads a Graph from the Quad Store.
        /// </summary>
        /// <param name="handler">RDF Handler.</param>
        /// <param name="graphUri">URI of the Graph to Load.</param>
        public override void LoadGraph(IRdfHandler handler, Uri graphUri)
        {
            if (graphUri == null) throw new RdfStorageException("Cannot load an unnamed Graph from Virtuoso as this would require loading the entirety of the Virtuoso Quad Store into memory!");

            try
            {
                handler.StartRdf();

                //Need to keep Database Open as Literals require extra trips to the Database to get additional
                //information about Language and Type
                this.Open(false);

                DataTable data = this.LoadTriples(graphUri);

                foreach (DataRow row in data.Rows)
                {
                    Object s, p, o;
                    INode subj, pred, obj;

                    //Get Data
                    s = row["S"];
                    p = row["P"];
                    o = row["O"];

                    //Create Nodes
                    subj = this.LoadNode(handler, s);
                    pred = this.LoadNode(handler, p);
                    obj = this.LoadNode(handler, o);

                    //Assert Triple
                    if (!handler.HandleTriple(new Triple(subj, pred, obj))) ParserHelper.Stop();
                }
                handler.EndRdf(true);
                this.Close(false);
            }
            catch (RdfParsingTerminatedException)
            {
                handler.EndRdf(true);
                this.Close(false);
            }
            catch
            {
                handler.EndRdf(false);
                this.Close(true);
                throw;
            }
        }

        /// <summary>
        /// Loads a Graph from the Quad Store.
        /// </summary>
        /// <param name="g">Graph to load into.</param>
        /// <param name="graphUri">URI of the Graph to Load.</param>
        public override void LoadGraph(IGraph g, String graphUri)
        {
            if (graphUri == null || graphUri.Equals(String.Empty))
            {
                this.LoadGraph(g, (Uri) null);
            }
            else
            {
                this.LoadGraph(g, UriFactory.Create(graphUri));
            }
        }

        /// <summary>
        /// Loads a Graph from the Quad Store.
        /// </summary>
        /// <param name="handler">RDF Handler.</param>
        /// <param name="graphUri">URI of the Graph to Load.</param>
        public override void LoadGraph(IRdfHandler handler, String graphUri)
        {
            if (graphUri == null || graphUri.Equals(String.Empty))
            {
                this.LoadGraph(handler, (Uri) null);
            }
            else
            {
                this.LoadGraph(handler, UriFactory.Create(graphUri));
            }
        }

        /// <summary>
        /// Gets a Table of Triples that are in the given Graph.
        /// </summary>
        /// <param name="graphUri">Graph Uri.</param>
        /// <returns></returns>
        /// <remarks>
        /// Assumes that the caller has opened the Database connection.
        /// </remarks>
        private DataTable LoadTriples(Uri graphUri)
        {
            DataTable dt = new DataTable();
            String getTriples;
            if (graphUri != null)
            {
                getTriples = "SPARQL define output:format '_JAVA_' SELECT * FROM <" + this.UnmarshalUri(graphUri) + "> WHERE {?s ?p ?o}";
            }
            else
            {
                getTriples = "SPARQL define output:format '_JAVA_' SELECT * WHERE {?s ?p ?o}";
            }

            VirtuosoCommand cmd = this._db.CreateCommand();
            cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
            cmd.CommandText = getTriples;

            VirtuosoDataAdapter adapter = new VirtuosoDataAdapter(cmd);

            dt.Columns.Add("S", typeof (System.Object));
            dt.Columns.Add("P", typeof (System.Object));
            dt.Columns.Add("O", typeof (System.Object));
            adapter.Fill(dt);

            return dt;
        }

        /// <summary>
        /// Decodes an Object into an appropriate Node.
        /// </summary>
        /// <param name="factory">Node Factory to use to create Node.</param>
        /// <param name="n">Object to convert.</param>
        /// <returns></returns>
        private INode LoadNode(INodeFactory factory, Object n)
        {
            INode temp;
            if (n is SqlExtendedString iri)
            {
                if (iri.IriType == SqlExtendedStringType.BNODE)
                {
                    //Blank Node
                    temp = factory.CreateBlankNode(n.ToString().Substring(9));
                }
                else if (iri.IriType != iri.StrType)
                {
                    //Literal
                    temp = factory.CreateLiteralNode(n.ToString());
                }
                else if (iri.IriType == SqlExtendedStringType.IRI)
                {
                    //Uri
                    Uri u = this.MarshalUri(n.ToString());
                    temp = factory.CreateUriNode(u);
                }
                else
                {
                    //Assume a Literal
                    temp = factory.CreateLiteralNode(n.ToString());
                }
            }
            else if (n is SqlRdfBox lit)
            {
                if (lit.StrLang != null)
                {
                    //Language Specified Literal
                    temp = factory.CreateLiteralNode(n.ToString(), lit.StrLang);
                }
                else if (lit.StrType != null)
                {
                    //Data Typed Literal
                    temp = factory.CreateLiteralNode(n.ToString(), this.MarshalUri(lit.StrType));
                }
                else
                {
                    //Literal
                    temp = factory.CreateLiteralNode(n.ToString());
                }
            }
            else if (n is String)
            {
                String s = n.ToString();
                if (s.StartsWith("nodeID://"))
                {
                    //Blank Node
                    temp = factory.CreateBlankNode(s.Substring(9));
                }
                else
                {
                    //Literal
                    temp = factory.CreateLiteralNode(s);
                }
            }
            else if (n is Int32 i)
            {
                temp = i.ToLiteral(factory);
            }
            else if (n is Int16 i)
            {
                temp = i.ToLiteral(factory);
            }
            else if (n is Single single)
            {
                temp = single.ToLiteral(factory);
            }
            else if (n is Double d)
            {
                temp = d.ToLiteral(factory);
            }
            else if (n is Decimal d)
            {
                temp = d.ToLiteral(factory);
            }
            else if (n is DateTime dateTime)
            {
                temp = dateTime.ToLiteral(factory);
            }
            else if (n is TimeSpan timeSpan)
            {
                temp = timeSpan.ToLiteral(factory);
            }
            else if (n is Boolean boolean)
            {
                temp = boolean.ToLiteral(factory);
            }
            else if (n is DBNull)
            {
                //Fix by Alexander Sidarov for Virtuoso's results for unbound variables in OPTIONALs
                temp = null;
            }
            else if (n is VirtuosoDateTime vDateTime)
            {
                //New type in Virtuoso 7
                DateTime dateTime = new DateTime(vDateTime.Year, vDateTime.Month, vDateTime.Day, vDateTime.Hour, vDateTime.Minute, vDateTime.Second, vDateTime.Millisecond, vDateTime.Kind);
                return dateTime.ToLiteral(factory);
            }
            else if (n is VirtuosoDateTimeOffset vDateTimeOffset)
            {
                //New type in Virtuoso 7
                DateTimeOffset dateTimeOffset = new DateTimeOffset(vDateTimeOffset.Year, vDateTimeOffset.Month, vDateTimeOffset.Day, vDateTimeOffset.Hour, vDateTimeOffset.Minute, vDateTimeOffset.Second, vDateTimeOffset.Millisecond, vDateTimeOffset.Offset);
                return dateTimeOffset.ToLiteral(factory);
            }
            else
            {
                throw new RdfStorageException("Unexpected Object Type '" + n.GetType().ToString() + "' returned from SPASQL SELECT query to the Virtuoso Quad Store");
            }
            return temp;
        }

        private Uri MarshalUri(String uriData)
        {
            Uri u = new Uri(uriData, UriKind.RelativeOrAbsolute);
            if (!u.IsAbsoluteUri)
            {
                // As of VIRT-375 we marshal this to a form we can round trip later rather than erroring as we did previously
                u = new Uri(VirtuosoRelativeBase, u);
            }
            return u;
        }

        private String UnmarshalUri(Uri u)
        {
            if (u.IsAbsoluteUri)
            {
                if (u.AbsoluteUri.StartsWith(VirtuosoRelativeBaseString))
                {
                    u = new Uri(u.AbsoluteUri.Substring(VirtuosoRelativeBase.AbsoluteUri.Length), UriKind.Relative);
                    return u.OriginalString;
                }
                else
                {
                    return u.AbsoluteUri;
                }
            }
            else
            {
                return u.OriginalString;
            }
        }

        /// <summary>
        /// Saves a Graph into the Quad Store (Warning: Completely replaces any existing Graph with the same URI).
        /// </summary>
        /// <param name="g">Graph to save.</param>
        /// <remarks>
        /// Completely replaces any previously saved Graph with the same Graph URI.
        /// </remarks>
        public override void SaveGraph(IGraph g)
        {
            if (g.BaseUri == null) throw new RdfStorageException("Cannot save a Graph without a Base URI to Virtuoso");

            try
            {
                this.Open(false);

                //Delete the existing Graph (if it exists)
                this.ExecuteNonQuery("DELETE FROM DB.DBA.RDF_QUAD WHERE G = DB.DBA.RDF_MAKE_IID_OF_QNAME('" + this.UnmarshalUri(g.BaseUri) + "')");

                //Make a call to the TTLP() Virtuoso function
                VirtuosoCommand cmd = new VirtuosoCommand();
                cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                cmd.CommandText = "DB.DBA.TTLP(@data, @base, @graph, 1)";
                cmd.Parameters.Add("data", VirtDbType.VarChar);
                cmd.Parameters["data"].Value = VDS.RDF.Writing.StringWriter.Write(g, new NTriplesWriter());
                String baseUri = this.UnmarshalUri(g.BaseUri);
                cmd.Parameters.Add("base", VirtDbType.VarChar);
                cmd.Parameters.Add("graph", VirtDbType.VarChar);
                cmd.Parameters["base"].Value = baseUri;
                cmd.Parameters["graph"].Value = baseUri;
                cmd.Connection = this._db;
                int result = cmd.ExecuteNonQuery();

                this.Close(false);
            }
            catch
            {
                this.Close(true);
                throw;
            }
        }

        /// <summary>
        /// Gets the IO Behaviour of the store.
        /// </summary>
        public override IOBehaviour IOBehaviour
        {
            get { return IOBehaviour.IsQuadStore | IOBehaviour.HasNamedGraphs | IOBehaviour.OverwriteNamed | IOBehaviour.CanUpdateTriples; }
        }

        /// <summary>
        /// Updates a Graph in the Quad Store.
        /// </summary>
        /// <param name="graphUri">Graph Uri of the Graph to update.</param>
        /// <param name="additions">Triples to be added.</param>
        /// <param name="removals">Triples to be removed.</param>
        /// <remarks>
        /// <para>
        /// In the case of inserts where blank nodes are present the data will be inserted but new blank nodes will be created.  You cannot insert data that refers to existing blank nodes via this method, consider using a INSERT WHERE style SPARQL Update instead.
        /// </para>
        /// <para>
        /// Note that Blank Nodes cannot always be deleted successfully, if you have retrieved the triples you are now trying to delete from Virtuoso and they contain blank nodes then this will likely work as expected.  Otherwise deletetions of Blank Nodes cannot be guaranteed.
        /// </para>
        /// <para>
        /// If the Graph being modified is relatively small it may be safer to load the graph into memory, makes the modifications there and then persist the graph back to the store (which overwrites the previous version of the graph).
        /// </para>
        /// </remarks>
        public override void UpdateGraph(Uri graphUri, IEnumerable<Triple> additions, IEnumerable<Triple> removals)
        {
            try
            {
                this.Open(true);
                int r;

                //Build the Delete Data Command
                if (removals != null)
                {
                    if (removals.Any())
                    {
                        //HACK: This is super hacky but works in most cases provided the blank node containing triples
                        //we're attempting to delete originated from Virtuoso
                        //We use the VirtuosoFormatter as our formatter which formats Blank Nodes as calls to the
                        //bif:rdf_make_iid_of_qname('nodeID://bnode') function which works if the blank node originates from Virtuoso

                        VirtuosoCommand deleteCmd = new VirtuosoCommand();
                        deleteCmd.CommandTimeout = (this._timeout > 0 ? this._timeout : deleteCmd.CommandTimeout);
                        StringBuilder delete = new StringBuilder();
                        if (removals.All(t => t.IsGroundTriple))
                        {
                            delete.AppendLine("SPARQL define output:format '_JAVA_' DELETE DATA");
                        }
                        else
                        {
                            //If there are Blank Nodes present we must use a DELETE rather than a DELETE DATA since
                            //DELETE DATA does not allow the backquoted expressions required to do this hack
                            delete.AppendLine("SPARQL define output:format '_JAVA_' DELETE");
                        }
                        if (graphUri != null)
                        {
                            delete.AppendLine(" FROM <" + this.UnmarshalUri(graphUri) + ">");
                        }
                        else
                        {
                            throw new RdfStorageException("Cannot update an unnamed Graph in a Virtuoso Store using this method - you must specify the URI of a Graph to Update");
                        }
                        delete.AppendLine("{");
                        foreach (Triple t in removals)
                        {
                            delete.AppendLine(t.ToString(this._formatter));
                        }
                        delete.AppendLine("}");

                        //If there are Blank Nodes present we will be using a DELETE rather than a DELETE DATA
                        //so we need to add a WHERE clause
                        if (removals.Any(t => !t.IsGroundTriple))
                        {
                            delete.AppendLine("WHERE { }");
                        }

                        //Run the Delete
                        deleteCmd.CommandText = delete.ToString();
                        deleteCmd.Connection = this._db;
                        deleteCmd.Transaction = this._dbtrans;

                        r = deleteCmd.ExecuteNonQuery();
                        if (r < 0) throw new RdfStorageException("Virtuoso encountered an error when deleting Triples");
                    }
                }

                //Build the Insert Data Command
                if (additions != null)
                {
                    if (additions.Any())
                    {
                        if (additions.All(t => t.IsGroundTriple))
                        {
                            VirtuosoCommand insertCmd = new VirtuosoCommand();
                            insertCmd.CommandTimeout = (this._timeout > 0 ? this._timeout : insertCmd.CommandTimeout);
                            StringBuilder insert = new StringBuilder();
                            insert.AppendLine("SPARQL define output:format '_JAVA_' INSERT DATA");
                            if (graphUri != null)
                            {
                                insert.AppendLine(" INTO <" + this.UnmarshalUri(graphUri) + ">");
                            }
                            else
                            {
                                throw new RdfStorageException("Cannot update an unnamed Graph in Virtuoso using this method - you must specify the URI of a Graph to Update");
                            }
                            insert.AppendLine("{");
                            foreach (Triple t in additions)
                            {
                                insert.AppendLine(t.ToString(this._formatter));
                            }
                            insert.AppendLine("}");
                            insertCmd.CommandText = insert.ToString();
                            insertCmd.Connection = this._db;
                            insertCmd.Transaction = this._dbtrans;

                            r = insertCmd.ExecuteNonQuery();
                            if (r < 0) throw new RdfStorageException("Virtuoso encountered an error when inserting Triples");
                        }
                        else
                        {
                            //When data to be inserted contains Blank Nodes we must make a call to the TTLP() Virtuoso function
                            //instead of using INSERT DATA
                            Graph g = new Graph();
                            g.Assert(additions);
                            VirtuosoCommand cmd = new VirtuosoCommand();
                            cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                            cmd.CommandText = "DB.DBA.TTLP(@data, @base, @graph, 1)";
                            cmd.Parameters.Add("data", VirtDbType.VarChar);
                            cmd.Parameters["data"].Value = VDS.RDF.Writing.StringWriter.Write(g, new NTriplesWriter());
                            String baseUri = this.UnmarshalUri(graphUri);
                            if (String.IsNullOrEmpty(baseUri)) throw new RdfStorageException("Cannot updated an unnamed Graph in Virtuoso using this method - you must specify the URI of a Graph to Update");
                            cmd.Parameters.Add("base", VirtDbType.VarChar);
                            cmd.Parameters.Add("graph", VirtDbType.VarChar);
                            cmd.Parameters["base"].Value = baseUri;
                            cmd.Parameters["graph"].Value = baseUri;
                            cmd.Connection = this._db;
                            int result = cmd.ExecuteNonQuery();
                        }
                    }
                }

                this.Close(false);
            }
            catch
            {
                this.Close(true, true);
                throw;
            }
        }

        /// <summary>
        /// Updates a Graph in the Quad Store.
        /// </summary>
        /// <param name="graphUri">Graph Uri of the Graph to update.</param>
        /// <param name="additions">Triples to be added.</param>
        /// <param name="removals">Triples to be removed.</param>
        public override void UpdateGraph(String graphUri, IEnumerable<Triple> additions, IEnumerable<Triple> removals)
        {
            Uri u = (graphUri.Equals(String.Empty)) ? null : UriFactory.Create(graphUri);
            this.UpdateGraph(u, additions, removals);
        }

        /// <summary>
        /// Indicates that Updates are supported by the Virtuoso Native Quad Store.
        /// </summary>
        public override bool UpdateSupported
        {
            get { return true; }
        }

        /// <summary>
        /// Returns that the Manager is ready.
        /// </summary>
        public override bool IsReady
        {
            get { return true; }
        }

        /// <summary>
        /// Returns that the Manager is not read-only.
        /// </summary>
        public override bool IsReadOnly
        {
            get { return false; }
        }

        #endregion

        #region Native Query & Update

        /// <summary>
        /// Executes a SPARQL Query on the native Quad Store.
        /// </summary>
        /// <param name="sparqlQuery">SPARQL Query to execute.</param>
        /// <returns></returns>
        /// <remarks>
        /// <para>
        /// This method will first attempt to parse the query into a <see cref="SparqlQuery">SparqlQuery</see> object.  If this succeeds then the Query Type can be used to determine how to handle the response.
        /// </para>
        /// <para>
        /// If the parsing fails then the query will be executed anyway using Virtuoso's SPASQL (SPARQL + SQL) syntax.  Parsing can fail because Virtuoso supports various SPARQL extensions which the library does not support.  These include things like aggregate functions but also SPARUL updates (the non-standard precusor to SPARQL 1.1 Update).
        /// </para>
        /// <para>
        /// If you use an aggregate query which has an Integer, Decimal or Double type result then you will receive a <see cref="SparqlResultSet">SparqlResultSet</see> containing a single <see cref="SparqlResult">SparqlResult</see> which has contains a binding for a variable named <strong>Result</strong> which contains a <see cref="LiteralNode">LiteralNode</see> typed to the appropriate datatype.
        /// </para>
        /// </remarks>
        /// <exception cref="RdfQueryException">Thrown if an error occurs in making the query.</exception>
        public Object Query(String sparqlQuery)
        {
            Graph g = new Graph();
            SparqlResultSet results = new SparqlResultSet();
            this.Query(new GraphHandler(g), new ResultSetHandler(results), sparqlQuery);

            if (results.ResultsType != SparqlResultsType.Unknown)
            {
                return results;
            }
            return g;
        }

        /// <summary>
        /// Executes a SPARQL Query on the native Quad Store processing the results with an appropriate handler from those provided.
        /// </summary>
        /// <param name="rdfHandler">RDF Handler.</param>
        /// <param name="resultsHandler">Results Handler.</param>
        /// <param name="sparqlQuery">SPARQL Query to execute.</param>
        /// <remarks>
        /// <para>
        /// This method will first attempt to parse the query into a <see cref="SparqlQuery">SparqlQuery</see> object.  If this succeeds then the Query Type can be used to determine how to handle the response.
        /// </para>
        /// <para>
        /// If the parsing fails then the query will be executed anyway using Virtuoso's SPASQL (SPARQL + SQL) syntax.  Parsing can fail because Virtuoso supports various SPARQL non-standardised extensions which the library does not support.  These include things like aggregate functions but also SPARUL updates (the non-standard precusor to SPARQL 1.1 Update).
        /// </para>
        /// <para>
        /// If you use an aggregate query which has an Integer, Decimal or Double type result then you will receive a <see cref="SparqlResultSet">SparqlResultSet</see> containing a single <see cref="SparqlResult">SparqlResult</see> which has contains a binding for a variable named <strong>Result</strong> which contains a <see cref="LiteralNode">LiteralNode</see> typed to the appropriate datatype.
        /// </para>
        /// </remarks>
        /// <exception cref="RdfQueryException">Thrown if an error occurs in making the query.</exception>
        public void Query(IRdfHandler rdfHandler, ISparqlResultsHandler resultsHandler, String sparqlQuery)
        {
            try
            {
                if (resultsHandler != null) resultsHandler.StartResults();

                DataTable results = new DataTable();
                results.Columns.CollectionChanged += Columns_CollectionChanged;

                //See if the query can be parsed into a SparqlQuery object
                //It might not since the user might use Virtuoso's extensions to Sparql in their query
                try
                {
                    //We'll set the Parser to SPARQL 1.1 mode even though Virtuoso's SPARQL implementation has
                    //various perculiarties in their SPARQL 1.1 implementation and we'll try and 
                    //handle the potential results in the catch branch if a valid SPARQL 1.0 query
                    //cannot be parsed
                    //Change made in response to a bug report by Aleksandr A. Zaripov [zaripov@tpu.ru]
                    SparqlQueryParser parser = new SparqlQueryParser();
                    parser.SyntaxMode = SparqlQuerySyntax.Sparql_1_1;
                    SparqlQuery query;
                    try
                    {
                        query = parser.ParseFromString(sparqlQuery);
                    }
                    catch (RdfException rdfEx)
                    {
                        //Need to re-wrap errors during parsing so we fall into correct catch branch, can't generally re-wrap as we might
                        //get RdfException's from other places which would indicate unrecoverable errors
                        throw new RdfParseException("RDF exception generated in query parsing", rdfEx);
                    }

                    switch (query.QueryType)
                    {
                        case SparqlQueryType.Select:
                        case SparqlQueryType.SelectAll:
                        case SparqlQueryType.SelectAllDistinct:
                        case SparqlQueryType.SelectAllReduced:
                        case SparqlQueryType.SelectDistinct:
                        case SparqlQueryType.SelectReduced:
                            //Type the Tables columns as System.Object
                            foreach (SparqlVariable var in query.Variables)
                            {
                                if (var.IsResultVariable)
                                {
                                    results.Columns.Add(var.Name, typeof (System.Object));
                                }
                            }
                            break;
                    }

                    try
                    {
                        #region Valid SPARQL Query Handling

                        this.Open(false);

                        //Make the Query against Virtuoso
                        VirtuosoCommand cmd = this._db.CreateCommand();
                        cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                        cmd.CommandText = "SPARQL " + sparqlQuery;
                        VirtuosoDataAdapter adapter = new VirtuosoDataAdapter(cmd);
                        adapter.Fill(results);

                        //Decide how to process the results based on the return type
                        switch (query.QueryType)
                        {
                            case SparqlQueryType.Ask:
                                //Expect a DataTable containing a single row and column which contains a boolean

                                //Ensure Results Handler is not null
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle a Boolean Result with a null SPARQL Results Handler");

                                if (results.Rows.Count == 1 && results.Columns.Count == 1)
                                {
                                    //Try and parse the result
                                    bool result;
                                    int r;
                                    if (Boolean.TryParse(results.Rows[0][0].ToString(), out result))
                                    {
                                        resultsHandler.HandleBooleanResult(result);
                                    }
                                    else if (Int32.TryParse(results.Rows[0][0].ToString(), out r))
                                    {
                                        resultsHandler.HandleBooleanResult(r == 1);
                                    }
                                    else
                                    {
                                        throw new RdfQueryException("Expected a Boolean as the result of an ASK query but the non-boolean value '" + results.Rows[0][0].ToString() + "' was received");
                                    }
                                }
                                else
                                {
                                    //If we get anything else then we'll return that the result was False
                                    resultsHandler.HandleBooleanResult(false);
                                }
                                break;

                            case SparqlQueryType.Construct:
                            case SparqlQueryType.Describe:
                            case SparqlQueryType.DescribeAll:
                                //Expect a DataTable containing a single row and column which contains a String
                                //That string will be a Turtle serialization of the Graph

                                //Ensure that RDF Handler is not null
                                if (rdfHandler == null) throw new ArgumentNullException("rdfHandler", "Cannot handle a Graph result with a null RDF Handler");

                                if (results.Rows.Count == 1 && results.Columns.Count == 1)
                                {
                                    try
                                    {
                                        //Use StringParser to parse
                                        String data = results.Rows[0][0].ToString();
                                        TurtleParser ttlparser = new TurtleParser();
                                        ttlparser.Load(rdfHandler, new StringReader(data));
                                    }
                                    catch (RdfParseException parseEx)
                                    {
                                        throw new RdfQueryException("Expected a valid Turtle serialization of the Graph resulting from a CONSTRUCT/DESCRIBE query but the result failed to parse", parseEx);
                                    }
                                }
                                else if (results.Columns.Count == 3)
                                {
                                    rdfHandler.StartRdf();
                                    try
                                    {
                                        foreach (DataRow row in results.Rows)
                                        {
                                            INode s = this.LoadNode(rdfHandler, row[0]);
                                            INode p = this.LoadNode(rdfHandler, row[1]);
                                            INode o = this.LoadNode(rdfHandler, row[2]);
                                            if (!rdfHandler.HandleTriple(new Triple(s, p, o))) break;
                                        }
                                        rdfHandler.EndRdf(true);
                                    }
                                    catch
                                    {
                                        rdfHandler.EndRdf(false);
                                        throw;
                                    }
                                }
                                else
                                {
                                    throw new RdfQueryException("Unexpected results data received for a CONSTRUCT/DESCRIBE query (Got " + results.Rows.Count + " row(s) with " + results.Columns.Count + " column(s)");
                                }
                                break;

                            case SparqlQueryType.Select:
                            case SparqlQueryType.SelectAll:
                            case SparqlQueryType.SelectAllDistinct:
                            case SparqlQueryType.SelectAllReduced:
                            case SparqlQueryType.SelectDistinct:
                            case SparqlQueryType.SelectReduced:
                                //Ensure Results Handler is not null
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL Results with a null Results Handler");

                                //Get Result Variables
                                List<SparqlVariable> resultVars = query.Variables.Where(v => v.IsResultVariable).ToList();
                                foreach (SparqlVariable var in resultVars)
                                {
                                    if (!resultsHandler.HandleVariable(var.Name)) ParserHelper.Stop();
                                }
                                Graph temp = new Graph();

                                //Convert each solution into a SPARQLResult
                                foreach (DataRow r in results.Rows)
                                {
                                    Set s = new Set();
                                    foreach (SparqlVariable var in resultVars)
                                    {
                                        if (r[var.Name] != null)
                                        {
                                            s.Add(var.Name, this.LoadNode(temp, r[var.Name]));
                                        }
                                    }
                                    if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                                }
                                break;

                            default:
                                throw new RdfQueryException("Unable to process the Results of an Unknown query type");
                        }

                        this.Close(false);

                        #endregion
                    }
                    catch
                    {
                        throw;
                    }
                }
                catch (RdfParseException)
                {
                    //Unable to parse a SPARQL 1.0 query
                    //Have to attempt to detect the return type based on the DataTable that
                    //the SPASQL (Sparql+SQL) query gives back

                    try
                    {
                        #region Potentially Invalid SPARQL Query Handling

                        this.Open(false);

                        //Make the Query against Virtuoso
                        VirtuosoCommand cmd = this._db.CreateCommand();
                        cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                        cmd.CommandText = "SPARQL " /*define output:format '_JAVA_' "*/+ sparqlQuery;
                        VirtuosoDataAdapter adapter = new VirtuosoDataAdapter(cmd);
                        adapter.Fill(results);

                        //Try to detect the return type based on the DataTable configuration
                        if (results.Columns.Count == 3
                                && results.Columns[0].ColumnName.Equals(SubjectColumn)
                                && results.Columns[1].ColumnName.Equals(PredicateColumn)
                                && results.Columns[2].ColumnName.Equals(ObjectColumn)
                                && !Regex.IsMatch(sparqlQuery, "SELECT", RegexOptions.IgnoreCase))
                        {
                            //Ensure that RDF Handler is not null
                            if (rdfHandler == null) throw new ArgumentNullException("rdfHandler", "Cannot handle a Graph result with a null RDF Handler");

                            rdfHandler.StartRdf();
                            try
                            {
                                foreach (DataRow row in results.Rows)
                                {
                                    INode s = this.LoadNode(rdfHandler, row[0]);
                                    INode p = this.LoadNode(rdfHandler, row[1]);
                                    INode o = this.LoadNode(rdfHandler, row[2]);
                                    if (!rdfHandler.HandleTriple(new Triple(s, p, o))) break;
                                }
                                rdfHandler.EndRdf(true);
                            }
                            catch
                            {
                                rdfHandler.EndRdf(false);
                                throw;
                            }
                        }
                        else if (results.Rows.Count == 0 && results.Columns.Count > 0)
                        {
                            if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL Results with a null Results Handler");

                            //No Rows but some columns implies empty SELECT results
                            foreach (DataColumn col in results.Columns)
                            {
                                if (!resultsHandler.HandleVariable(col.ColumnName)) ParserHelper.Stop();
                            }
                        }
                        else if (results.Rows.Count == 1 && results.Columns.Count == 1 && !Regex.IsMatch(sparqlQuery, "SELECT", RegexOptions.IgnoreCase))
                        {
                            //Added a fix here suggested by Alexander Sidorov - not entirely happy with this fix as what happens if SELECT just happens to occur in a URI/Variable Name?

                            //Single Row and Column implies ASK/DESCRIBE/CONSTRUCT results
                            bool result;
                            int r;
                            decimal rdec;
                            double rdbl;
                            float rflt;

                            if (results.Rows[0][0].ToString().Equals(String.Empty))
                            {
                                //Empty Results - no need to do anything
                            }
                            else if (Boolean.TryParse(results.Rows[0][0].ToString(), out result))
                            {
                                //Parseable Boolean so ASK Results
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle a Boolean result with a null Results Handler");
                                resultsHandler.HandleBooleanResult(result);
                            }
                            else if (Int32.TryParse(results.Rows[0][0].ToString(), out r))
                            {
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                                //Parseable Integer so Aggregate SELECT Query Results
                                if (!resultsHandler.HandleVariable("Result")) ParserHelper.Stop();
                                Set s = new Set();
                                s.Add("Result", r.ToLiteral(resultsHandler));
                                if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                            }
                            else if (Single.TryParse(results.Rows[0][0].ToString(), out rflt))
                            {
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                                //Parseable Single so Aggregate SELECT Query Results
                                if (!resultsHandler.HandleVariable("Result")) ParserHelper.Stop();
                                Set s = new Set();
                                s.Add("Result", rflt.ToLiteral(resultsHandler));
                                if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                            }
                            else if (Double.TryParse(results.Rows[0][0].ToString(), out rdbl))
                            {
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                                //Parseable Double so Aggregate SELECT Query Results
                                if (!resultsHandler.HandleVariable("Result")) ParserHelper.Stop();
                                Set s = new Set();
                                s.Add("Result", rdbl.ToLiteral(resultsHandler));
                                if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                            }
                            else if (Decimal.TryParse(results.Rows[0][0].ToString(), out rdec))
                            {
                                if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                                //Parseable Decimal so Aggregate SELECT Query Results
                                if (!resultsHandler.HandleVariable("Result")) ParserHelper.Stop();
                                Set s = new Set();
                                s.Add("Result", rdec.ToLiteral(resultsHandler));
                                if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                            }
                            else
                            {
                                //String so try and parse as Turtle
                                try
                                {
                                    //Use StringParser to parse
                                    String data = results.Rows[0][0].ToString();
                                    TurtleParser ttlparser = new TurtleParser();
                                    ttlparser.Load(rdfHandler, new StringReader(data));
                                }
                                catch (RdfParseException)
                                {
                                    if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                                    //If it failed to parse then it might be the result of one of the aggregate
                                    //functions that Virtuoso extends Sparql with
                                    if (!resultsHandler.HandleVariable(results.Columns[0].ColumnName)) ParserHelper.Stop();
                                    Set s = new Set();
                                    s.Add(results.Columns[0].ColumnName, this.LoadNode(resultsHandler, results.Rows[0][0]));
                                    //Nothing was returned here previously - fix submitted by Aleksandr A. Zaripov [zaripov@tpu.ru]
                                    if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                                }
                            }
                        }
                        else
                        {
                            //Any other number of rows/columns we have to assume that it's normal SELECT results
                            //Changed in response to bug report by Aleksandr A. Zaripov [zaripov@tpu.ru]

                            if (resultsHandler == null) throw new ArgumentNullException("resultsHandler", "Cannot handle SPARQL results with a null Results Handler");

                            //Get Result Variables
                            List<String> vars = new List<string>();
                            foreach (DataColumn col in results.Columns)
                            {
                                vars.Add(col.ColumnName);
                                if (!resultsHandler.HandleVariable(col.ColumnName)) ParserHelper.Stop();
                            }

                            //Convert each solution into a SPARQLResult
                            foreach (DataRow r in results.Rows)
                            {
                                Set s = new Set();
                                foreach (String var in vars)
                                {
                                    if (r[var] != null)
                                    {
                                        s.Add(var, this.LoadNode(resultsHandler, r[var]));
                                    }
                                }
                                if (!resultsHandler.HandleResult(new SparqlResult(s))) ParserHelper.Stop();
                            }
                        }
                        this.Close(false);

                        #endregion
                    }
                    catch
                    {
                        this.Close(true, true);
                        throw;
                    }
                }

                if (resultsHandler != null) resultsHandler.EndResults(true);
                this.Close(false);
            }
            catch (RdfParsingTerminatedException)
            {
                if (resultsHandler != null) resultsHandler.EndResults(true);
                this.Close(false);
            }
            catch
            {
                this.Close(true);
                if (resultsHandler != null) resultsHandler.EndResults(false);
                this.Close(false);
                throw;
            }
        }

        private static void Columns_CollectionChanged(object sender, System.ComponentModel.CollectionChangeEventArgs e)
        {
            Type reqType = typeof (Object);
            if (e.Action != System.ComponentModel.CollectionChangeAction.Add) return;
            DataColumn column = (DataColumn) e.Element;
            if (!column.DataType.Equals(reqType))
            {
                column.DataType = reqType;
            }
        }

        /// <summary>
        /// Executes a SPARQL Update on the native Quad Store.
        /// </summary>
        /// <param name="sparqlUpdate">SPARQL Update to execute.</param>
        /// <remarks>
        /// <para>
        /// This method will first attempt to parse the update into a <see cref="SparqlUpdateCommandSet">SparqlUpdateCommandSet</see> object.  If this succeeds then each command in the command set will be issued to Virtuoso.
        /// </para>
        /// <para>
        /// If the parsing fails then the update will be executed anyway using Virtuoso's SPASQL (SPARQL + SQL) syntax.  Parsing can fail because Virtuoso supports various SPARQL extensions which the library does not support and primarily supports SPARUL updates (the precusor to SPARQL 1.1 Update).
        /// </para>
        /// </remarks>
        /// <exception cref="SparqlUpdateException">Thrown if an error occurs in making the update.</exception>
        public void Update(String sparqlUpdate)
        {
            try
            {
                this.Open(true);

                //Try and parse the SPARQL Update String
                SparqlUpdateParser parser = new SparqlUpdateParser();
                SparqlUpdateCommandSet commands = parser.ParseFromString(sparqlUpdate);

                //Process each Command individually
                foreach (SparqlUpdateCommand command in commands.Commands)
                {
                    //Make the Update against Virtuoso
                    VirtuosoCommand cmd = this._db.CreateCommand();
                    cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                    cmd.CommandText = "SPARQL " + command.ToString();
                    cmd.ExecuteNonQuery();
                }

                this.Close(true);
            }
            catch (RdfParseException)
            {
                try
                {
                    //Ignore failed parsing and attempt to execute anyway
                    VirtuosoCommand cmd = this._db.CreateCommand();
                    cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
                    cmd.CommandText = "SPARQL " + sparqlUpdate;

                    cmd.ExecuteNonQuery();
                    this.Close(true);
                }
                catch (Exception ex)
                {
                    this.Close(true, true);
                    throw new SparqlUpdateException("An error occurred while trying to perform the SPARQL Update with Virtuoso.  Note that Virtuoso historically has primarily supported SPARUL (the precursor to SPARQL Update) and many valid SPARQL Update Commands may not be supported by Virtuoso", ex);
                }
            }
            catch (SparqlUpdateException)
            {
                this.Close(true, true);
                throw;
            }
            catch (Exception ex)
            {
                //Wrap in a SPARQL Update Exception
                this.Close(true, true);
                throw new SparqlUpdateException("An error occurred while trying to perform the SPARQL Update with Virtuoso.  Note that Virtuoso historically has primarily supported SPARUL (the precursor to SPARQL Update) and many valid SPARQL Update Commands may not be supported by Virtuoso if you are not using a recent version.", ex);
            }
        }

        #endregion

        /// <summary>
        /// Deletes a Graph from the Virtuoso store.
        /// </summary>
        /// <param name="graphUri">URI of the Graph to delete.</param>
        public override void DeleteGraph(Uri graphUri)
        {
            this.DeleteGraph(this.UnmarshalUri(graphUri));
        }

        /// <summary>
        /// Deletes a Graph from the store.
        /// </summary>
        /// <param name="graphUri">URI of the Graph to delete.</param>
        public override void DeleteGraph(String graphUri)
        {
            if (graphUri == null) return;
            if (graphUri.Equals(String.Empty)) return;

            try
            {
                this.Open(false);
                this.ExecuteNonQuery("DELETE FROM DB.DBA.RDF_QUAD WHERE G = DB.DBA.RDF_MAKE_IID_OF_QNAME('" + graphUri + "')");
                this.Close(false);
            }
            catch
            {
                this.Close(true, true);
                throw;
            }
        }

        /// <summary>
        /// Returns that deleting Graphs is supported.
        /// </summary>
        public override bool DeleteSupported
        {
            get { return true; }
        }

        /// <summary>
        /// Lists the Graphs in the store.
        /// </summary>
        /// <returns></returns>
        public override IEnumerable<Uri> ListGraphs()
        {
            try
            {
                Object results = this.Query("SELECT DISTINCT ?g WHERE { GRAPH ?g { ?s ?p ?o } }");
                if (results is SparqlResultSet)
                {
                    List<Uri> graphs = new List<Uri>();
                    foreach (SparqlResult r in ((SparqlResultSet) results))
                    {
                        if (r.HasValue("g"))
                        {
                            INode temp = r["g"];
                            try
                            {
                                if (temp.NodeType == NodeType.Uri)
                                {
                                    graphs.Add(((IUriNode) temp).Uri);
                                }
                                else if (temp.NodeType == NodeType.Literal)
                                {
                                    //HACK: Virtuoso wrongly returns Literals instead of URIs in the results for the above query prior to Virtuoso 6.1.3
                                    graphs.Add(UriFactory.Create(((ILiteralNode) temp).Value));
                                }
                            }
                            catch
                            {
                                //HACK: Virtuoso has some special Graphs which have non-URI names so ignore these
                                continue;
                            }
                        }
                    }
                    return graphs;
                }
                else
                {
                    return Enumerable.Empty<Uri>();
                }
            }
            catch (Exception ex)
            {
                throw new RdfStorageException("Underlying Store returned an error while trying to List Graphs", ex);
            }
        }

        /// <summary>
        /// Returns that listing graphs is supported.
        /// </summary>
        public override bool ListGraphsSupported
        {
            get { return true; }
        }

        #region Database IO

        /// <summary>
        /// Opens a Connection to the Database.
        /// </summary>
        /// <param name="keepOpen">Indicates that the Connection should be kept open and a Transaction started.</param>
        private void Open(bool keepOpen)
        {
            this.Open(keepOpen, IsolationLevel.ReadCommitted);
        }

        /// <summary>
        /// Opens a Connection to the Database.
        /// </summary>
        /// <param name="keepOpen">Indicates that the Connection should be kept open and a Transaction started.</param>
        /// <param name="level">Isolation Level to use.</param>
        private void Open(bool keepOpen, IsolationLevel level)
        {
            switch (this._db.State)
            {
                case ConnectionState.Broken:
                case ConnectionState.Closed:
                    this._db.Open();

                    //Start a Transaction
                    if (this._dbtrans == null)
                    {
                        this._dbtrans = this._db.BeginTransaction(level);
                    }
                    break;
            }
            if (keepOpen) this._keepOpen = true;
        }

        /// <summary>
        /// Closes the Connection to the Database.
        /// </summary>
        /// <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened.</param>
        private void Close(bool forceClose)
        {
            this.Close(forceClose, false);
        }

        /// <summary>
        /// Closes the Connection to the Database.
        /// </summary>
        /// <param name="forceClose">Indicates that the connection should be closed even if keepOpen was specified when the Connection was opened.</param>
        /// <param name="rollbackTrans">Indicates that the Transaction should be rolled back because something has gone wrong.</param>
        private void Close(bool forceClose, bool rollbackTrans)
        {
            //Don't close if we're keeping open and not forcing Close or rolling back a Transaction
            if (this._keepOpen && !forceClose && !rollbackTrans)
            {
                return;
            }

            switch (this._db.State)
            {
                case ConnectionState.Open:
                    //Finish the Transaction if exists
                    if (this._dbtrans != null)
                    {
                        if (!rollbackTrans)
                        {
                            //Commit normally
                            this._dbtrans.Commit();
                        }
                        else
                        {
                            //Want to Rollback
                            this._dbtrans.Rollback();
                        }
                        this._dbtrans = null;

                        this._db.Close();
                    }

                    this._keepOpen = false;
                    break;
            }
        }

        /// <summary>
        /// Executes a Non-Query SQL Command against the database.
        /// </summary>
        /// <param name="sqlCmd">SQL Command.</param>
        private void ExecuteNonQuery(string sqlCmd)
        {
            //Create the SQL Command
            VirtuosoCommand cmd = new VirtuosoCommand(sqlCmd, this._db);
            cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
            if (this._dbtrans != null)
            {
                //Add to the Transaction if required
                cmd.Transaction = this._dbtrans;
            }

            //Execute
            cmd.ExecuteNonQuery();
        }

        /// <summary>
        /// Executes a Query SQL Command against the database and returns a DataTable.
        /// </summary>
        /// <param name="sqlCmd">SQL Command.</param>
        /// <returns>DataTable of results.</returns>
        private DataTable ExecuteQuery(string sqlCmd)
        {
            //Create the SQL Command
            VirtuosoCommand cmd = new VirtuosoCommand(sqlCmd, this._db);
            cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
            if (this._dbtrans != null)
            {
                //Add to the Transaction if required
                cmd.Transaction = this._dbtrans;
            }

            //Execute the Query
            VirtuosoDataAdapter adapter = new VirtuosoDataAdapter(cmd);
            DataTable results = new DataTable();
            adapter.Fill(results);

            return results;
        }

        /// <summary>
        /// Executes a Query SQL Command against the database and returns the scalar result (first column of first row of the result).
        /// </summary>
        /// <param name="sqlCmd">SQL Command.</param>
        /// <returns>First Column of First Row of the Results.</returns>
        private object ExecuteScalar(string sqlCmd)
        {
            //Create the SQL Command
            VirtuosoCommand cmd = new VirtuosoCommand(sqlCmd, this._db);
            cmd.CommandTimeout = (this._timeout > 0 ? this._timeout : cmd.CommandTimeout);
            if (this._dbtrans != null)
            {
                //Add to the Transaction if required
                cmd.Transaction = this._dbtrans;
            }

            //Execute the Scalar
            return cmd.ExecuteScalar();
        }

        /// <summary>
        /// Gets whether there is an active connection to the Virtuoso database.
        /// </summary>
        public bool HasOpenConnection
        {
            get { return this._db.State != ConnectionState.Broken && this._db.State != ConnectionState.Closed; }
        }

        /// <summary>
        /// Gets whether there is any active transaction on the Virtuoso database.
        /// </summary>
        public bool HasActiveTransaction
        {
            get { return !ReferenceEquals(this._dbtrans, null); }
        }

        #endregion

        #region IDisposable Members

        /// <summary>
        /// Disposes of the Manager.
        /// </summary>
        public override void Dispose()
        {
            this.Close(true, false);
        }

        #endregion

        /// <summary>
        /// Gets a String which gives details of the Connection.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (this._customConnString)
            {
                return "[Virtuoso] Custom Connection String";
            }
            return "[Virtuoso] " + this._dbserver + ":" + this._dbport;
        }

        /// <summary>
        /// Serializes the connection's configuration.
        /// </summary>
        /// <param name="context">Configuration Serialization Context.</param>
        public void SerializeConfiguration(ConfigurationSerializationContext context)
        {
            if (this._customConnString)
            {
                throw new DotNetRdfConfigurationException("Cannot serialize the configuration of a VirtuosoManager which was created with a custom connection string");
            }

            //Firstly need to ensure our object factory has been referenced
            context.EnsureObjectFactory(typeof (VirtuosoObjectFactory));

            //Then serialize the actual configuration
            INode dnrType = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyType));
            INode rdfType = context.Graph.CreateUriNode(UriFactory.Create(RdfSpecsHelper.RdfType));
            INode manager = context.NextSubject;
            INode rdfsLabel = context.Graph.CreateUriNode(UriFactory.Create(NamespaceMapper.RDFS + "label"));
            INode genericManager = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.ClassStorageProvider));
            INode server = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyServer));

            context.Graph.Assert(new Triple(manager, rdfType, genericManager));
            context.Graph.Assert(new Triple(manager, rdfsLabel, context.Graph.CreateLiteralNode(this.ToString())));
            context.Graph.Assert(new Triple(manager, dnrType, context.Graph.CreateLiteralNode(this.GetType().FullName + ", dotNetRDF.Data.Virtuoso")));
            context.Graph.Assert(new Triple(manager, server, context.Graph.CreateLiteralNode(this._dbserver)));

            if (this._dbport != DefaultPort)
            {
                INode port = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyPort));
                context.Graph.Assert(new Triple(manager, port, this._dbport.ToLiteral(context.Graph)));
            }
            if (!this._dbname.Equals(DefaultDB))
            {
                INode db = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyDatabase));
                context.Graph.Assert(new Triple(manager, db, context.Graph.CreateLiteralNode(this._dbname)));
            }
            if (this._timeout > 0)
            {
                INode timeout = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyTimeout));
                context.Graph.Assert(new Triple(manager, timeout, this._timeout.ToLiteral(context.Graph)));
            }
            if (this._dbuser != null && this._dbpwd != null)
            {
                INode username = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyUser));
                INode pwd = context.Graph.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyPassword));
                context.Graph.Assert(new Triple(manager, username, context.Graph.CreateLiteralNode(this._dbuser)));
                context.Graph.Assert(new Triple(manager, pwd, context.Graph.CreateLiteralNode(this._dbpwd)));
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF.Data.Virtuoso\VirtuosoManager.cs(403,33): error CS0136: A local or parameter named 'i' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Libraries\dotNetRDF.Data.Virtuoso\VirtuosoManager.cs(415,35): error CS0136: A local or parameter named 'd' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Libraries\dotNetRDF.Data.Virtuoso\VirtuosoManager.cs(439,26): error CS0136: A local or parameter named 'dateTime' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 11 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Libraries\dotNetRDF.Query.FullText\FullTextObjectFactory.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using DirInfo = System.IO.DirectoryInfo;
using System.Linq;
using System.Reflection;
using Lucene.Net.Analysis;
using Lucene.Net.Analysis.Standard;
using Lucene.Net.Index;
using Lucene.Net.Store;
using VDS.RDF.Query;
using VDS.RDF.Query.Datasets;
using VDS.RDF.Query.FullText.Indexing;
using VDS.RDF.Query.FullText.Indexing.Lucene;
using VDS.RDF.Query.FullText.Schema;
using VDS.RDF.Query.FullText.Search;
using VDS.RDF.Query.FullText.Search.Lucene;
using VDS.RDF.Query.Optimisation;
using LucVersion = Lucene.Net.Util.Version;

namespace VDS.RDF.Configuration
{   
    /// <summary>
    /// An Object Factory that can load types from the Full Text Query library (<strong>dotNetRDF.Query.FullText.dll</strong>).
    /// </summary>
    public class FullTextObjectFactory
        : IObjectFactory
    {
        /// <summary>
        /// Constants for loadable Types.
        /// </summary>
        private const String LuceneSubjectsIndexer = "VDS.RDF.Query.FullText.Indexing.Lucene.LuceneSubjectsIndexer",
                             LuceneObjectsIndexer = "VDS.RDF.Query.FullText.Indexing.Lucene.LuceneObjectsIndexer",
                             LucenePredicatesIndexer = "VDS.RDF.Query.FullText.Indexing.Lucene.LucenePredicatesIndexer",
                             DefaultIndexSchema = "VDS.RDF.Query.FullText.Schema.DefaultIndexSchema",
                             LuceneSearchProvider = "VDS.RDF.Query.FullText.Search.Lucene.LuceneSearchProvider",
                             FullTextOptimiser = "VDS.RDF.Query.Optimisation.FullTextOptimiser",
                             FullTextIndexedDataset = "VDS.RDF.Query.Datasets.FullTextIndexedDataset";

        private readonly Type _luceneAnalyzerType = typeof(Analyzer);
        private readonly Type _luceneDirectoryType = typeof(Directory);

        private const int DefaultVersion = 3000;


        /// <summary>
        /// Tries to load an object based on information from the Configuration Graph.
        /// </summary>
        /// <param name="g">Configuration Graph.</param>
        /// <param name="objNode">Object Node.</param>
        /// <param name="targetType">Target Type.</param>
        /// <param name="obj">Output Object.</param>
        /// <returns></returns>
        public bool TryLoadObject(IGraph g, INode objNode, Type targetType, out object obj)
        {
            obj = null;

            INode index = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "index"));
            INode indexerProperty = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "indexer"));
            INode searcher = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "searcher"));
            INode analyzer = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "analyzer"));
            INode schema = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "schema"));
            INode version = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "version"));

            Object tempIndex, tempAnalyzer, tempSchema;
            int ver = DefaultVersion;
            //Always check for the version
            ver = ConfigurationLoader.GetConfigurationInt32(g, objNode, version, DefaultVersion);

            switch (targetType.FullName)
            {
                case DefaultIndexSchema:
                    obj = new DefaultIndexSchema();
                    break;

                case FullTextIndexedDataset:
                    //Need to get the inner dataset
                    INode datasetNode = ConfigurationLoader.GetConfigurationNode(g, objNode, g.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyUsingDataset)));
                    if (datasetNode == null) throw new DotNetRdfConfigurationException("Unable to load the Full Text Indexed Dataset specified by the Node '" + objNode.ToString() + "' as there was no value specified for the required dnr:usingDataset property");
                    Object tempDataset = ConfigurationLoader.LoadObject(g, datasetNode);
                    if (tempDataset is ISparqlDataset)
                    {
                        //Then load the indexer associated with the dataset
                        INode indexerNode = ConfigurationLoader.GetConfigurationNode(g, objNode, indexerProperty);
                        if (indexerNode == null) throw new DotNetRdfConfigurationException("Unable to load the Full Text Indexed Dataset specified by the Node '" + objNode.ToString() + " as there was no value specified for the required dnr-ft:indexer property");
                        Object tempIndexer = ConfigurationLoader.LoadObject(g, indexerNode);
                        if (tempIndexer is IFullTextIndexer)
                        {
                            bool indexNow = ConfigurationLoader.GetConfigurationBoolean(g, objNode, g.CreateUriNode(UriFactory.Create(FullTextHelper.PropertyIndexNow)), false);
                            obj = new FullTextIndexedDataset((ISparqlDataset)tempDataset, (IFullTextIndexer)tempIndexer, indexNow);
                        }
                        else
                        {
                            throw new DotNetRdfConfigurationException("Unable to load the Full Text Indexed Dataset specified by the Node '" + objNode.ToString() + "' as the value specified for the dnr-ft:indexer property pointed to an object which could not be loaded as a type that implements the required IFullTextIndexer interface");
                        }
                    }
                    else
                    {
                        throw new DotNetRdfConfigurationException("Unable to load the Full Text Indexed Dataset specified by the Node '" + objNode.ToString() + "' as the value specified for the dnr:usingDataset property pointed to an object which could not be loaded as a type that implements the required ISparqlDataset interface");
                    }
                    break;

                case FullTextOptimiser:
                    //Need to get the Search Provider
                    INode providerNode = ConfigurationLoader.GetConfigurationNode(g, objNode, searcher);
                    if (providerNode == null) throw new DotNetRdfConfigurationException("Unable to load the Full Text Optimiser specified by the Node '" + objNode.ToString() + "' as there was no value specified for the required dnr-ft:searcher property");
                    Object tempSearcher = ConfigurationLoader.LoadObject(g, providerNode);
                    if (tempSearcher is IFullTextSearchProvider)
                    {
                        obj = new FullTextOptimiser((IFullTextSearchProvider)tempSearcher);
                    }
                    else
                    {
                        throw new DotNetRdfConfigurationException("Unable to load the Full Text Optimiser specified by the Node '" + objNode.ToString() + "' as the value specified for the dnr-ft:searcher property pointed to an object which could not be loaded as a type that implements the required IFullTextSearchProvider interface");
                    }
                    break;

                case LuceneObjectsIndexer:
                case LucenePredicatesIndexer:
                case LuceneSubjectsIndexer:
                case LuceneSearchProvider:
                    //For any Lucene Indexer/Search Provider need to know the Index, Analyzer and Schema to be used

                    //Then get the Index
                    tempIndex = ConfigurationLoader.GetConfigurationNode(g, objNode, index);
                    if (tempIndex == null) throw new DotNetRdfConfigurationException("Unable to load the Lucene Indexer specified by the Node '" + objNode.ToString() + "' as there was no value specified for the required dnr-ft:index property");
                    tempIndex = ConfigurationLoader.LoadObject(g, (INode)tempIndex);
                    if (tempIndex is Directory)
                    {
                        //Next get the Analyzer (assume Standard if none specified)
                        tempAnalyzer = ConfigurationLoader.GetConfigurationNode(g, objNode, analyzer);
                        if (tempAnalyzer == null)
                        {
                            tempAnalyzer = new StandardAnalyzer(this.GetLuceneVersion(ver));
                        } 
                        else 
                        {
                            tempAnalyzer = ConfigurationLoader.LoadObject(g, (INode)tempAnalyzer);
                        }

                        if (tempAnalyzer is Analyzer)
                        {
                            //Finally get the Schema (assume Default if none specified)
                            tempSchema = ConfigurationLoader.GetConfigurationNode(g, objNode, schema);
                            if (tempSchema == null)
                            {
                                tempSchema = new DefaultIndexSchema();
                            }
                            else
                            {
                                tempSchema = ConfigurationLoader.LoadObject(g, (INode)tempSchema);
                            }

                            if (tempSchema is IFullTextIndexSchema)
                            {
                                //Now we can create the Object
                                switch (targetType.FullName)
                                {
                                    case LuceneObjectsIndexer:
                                        obj = new LuceneObjectsIndexer((Directory)tempIndex, (Analyzer)tempAnalyzer, (IFullTextIndexSchema)tempSchema);
                                        break;
                                    case LucenePredicatesIndexer:
                                        obj = new LucenePredicatesIndexer((Directory)tempIndex, (Analyzer)tempAnalyzer, (IFullTextIndexSchema)tempSchema);
                                        break;
                                    case LuceneSubjectsIndexer:
                                        obj = new LuceneSubjectsIndexer((Directory)tempIndex, (Analyzer)tempAnalyzer, (IFullTextIndexSchema)tempSchema);
                                        break;
                                    case LuceneSearchProvider:
                                        //Before the Search Provider has been loaded determine whether we need to carry out auto-indexing
                                        List<INode> sources = ConfigurationLoader.GetConfigurationData(g, objNode, g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "buildIndexFor"))).ToList();
                                        if (sources.Count > 0)
                                        {
                                            //If there are sources to index ensure we have an indexer to index with
                                            INode indexerNode = ConfigurationLoader.GetConfigurationNode(g, objNode, g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "buildIndexWith")));
                                            if (indexerNode == null) throw new DotNetRdfConfigurationException("Unable to load the Lucene Search Provider specified by the Node '" + objNode.ToString() + "' as there were values specified for the dnr-ft:buildIndexFor property but no dnr-ft:buildIndexWith property was found");
                                            IFullTextIndexer indexer = ConfigurationLoader.LoadObject(g, indexerNode) as IFullTextIndexer;
                                            if (indexer == null) throw new DotNetRdfConfigurationException("Unable to load the Lucene Search Provider specified by the Node '" + objNode.ToString() + "' as the value given for the dnr-ft:buildIndexWith property pointed to an Object which could not be loaded as a type that implements the required IFullTextIndexer interface");

                                            try 
                                            {
                                                //For Each Source load it and Index it
                                                foreach (INode sourceNode in sources)
                                                {
                                                    Object source = ConfigurationLoader.LoadObject(g, sourceNode);
                                                    if (source is ISparqlDataset)
                                                    {
                                                        indexer.Index((ISparqlDataset)source);
                                                    }
                                                    else if (source is ITripleStore)
                                                    {
                                                        foreach (IGraph graph in ((ITripleStore)source).Graphs)
                                                        {
                                                            indexer.Index(graph);
                                                        }
                                                    }
                                                    else if (source is IGraph)
                                                    {
                                                        indexer.Index((IGraph)source);
                                                    }
                                                    else
                                                    {
                                                        throw new DotNetRdfConfigurationException("Unable to load the Lucene Search Provider specified by the Node '" + objNode.ToString() + "' as a value given for the dnr-ft:buildIndexFor property ('" + sourceNode.ToString() + "') pointed to an Object which could not be loaded as a type that implements one of the required interfaces: IGraph, ITripleStore or ISparqlDataset");
                                                    }
                                                }
                                            } 
                                            finally 
                                            {
                                                indexer.Dispose();
                                            }
                                        }

                                        //Then we actually load the Search Provider
                                        bool autoSync = ConfigurationLoader.GetConfigurationBoolean(g, objNode, g.CreateUriNode(UriFactory.Create(FullTextHelper.PropertyIndexSync)), true);
                                        obj = new LuceneSearchProvider(this.GetLuceneVersion(ver), (Directory)tempIndex, (Analyzer)tempAnalyzer, (IFullTextIndexSchema)tempSchema, autoSync);
                                        break;
                                }
                            }
                            else
                            {
                                throw new DotNetRdfConfigurationException("Unable to load the Lucene Indexer specified by the Node '" + objNode.ToString() + "' as the value given for the dnr-ft:schema property pointed to an Object which could not be loaded as a type that implements the required IFullTextIndexSchema interface");
                            }
                        }
                        else
                        {
                            throw new DotNetRdfConfigurationException("Unable to load the Lucene Indexer specified by the Node '" + objNode.ToString() + "' as the value given for the dnr-ft:analyzer property pointed to an Object which could not be loaded as a type that derives from the required Lucene.Net.Analysis.Analyzer type");
                        }
                    }
                    else
                    {
                        throw new DotNetRdfConfigurationException("Unable to load the Lucene Indexer specified by the Node '" + objNode.ToString() + "' as the value given for the dnr-ft:index property pointed to an Object which could not be loaded as a type that derives from the required Lucene.Net.Store.Directory type");
                    }
                    break;

                default:
                    try
                    {
                        if (this._luceneAnalyzerType.IsAssignableFrom(targetType))
                        {
                            //Create an Analyzer
                            //Try to create passing Lucene Version wherever possible
                            if (targetType.GetConstructor(new Type[] { typeof(LucVersion) }) != null)
                            {
                                obj = Activator.CreateInstance(targetType, new Object[] { this.GetLuceneVersion(ver) });
                            }
                            else
                            {
                                obj = Activator.CreateInstance(targetType);
                            }
                        }
                        else if (this._luceneDirectoryType.IsAssignableFrom(targetType))
                        {
                            //Create a Directory aka a Lucene Index
                            String dir = ConfigurationLoader.GetConfigurationString(g, objNode, g.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyFromFile)));
                            if (dir != null)
                            {
                                try
                                {
                                    obj = Activator.CreateInstance(targetType, new Object[] { dir });
                                }
                                catch
                                {
                                    MethodInfo method = targetType.GetMethod("Open", new Type[] { typeof(DirInfo) });
                                    if (method != null)
                                    {
                                        obj = method.Invoke(null, new Object[] { new DirInfo(ConfigurationLoader.ResolvePath(dir)) });
                                    }
                                }
                            }
                            else
                            {
                                obj = Activator.CreateInstance(targetType);
                            }
                            //Ensure the Index if necessary
                            if (obj != null)
                            {
                                if (ConfigurationLoader.GetConfigurationBoolean(g, objNode, g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "ensureIndex")), false))
                                {
                                    IndexWriter writer = new IndexWriter((Directory)obj, new StandardAnalyzer(this.GetLuceneVersion(ver)), IndexWriter.MaxFieldLength.UNLIMITED);
                                    writer.Dispose();
                                }
                            }
                        }
                    }
                    catch
                    {
                        //Since we know we don't allow loading of all analyzers and directories we allow for users to inject other object factories
                        //which may know how to load those specific instances
                        obj = null;
                    }
                    break;
            }

            return (obj != null);
        }

        /// <summary>
        /// Gets whether this Factory can load objects of the given Type.
        /// </summary>
        /// <param name="t">Type.</param>
        /// <returns></returns>
        public bool CanLoadObject(Type t)
        {
            switch (t.FullName)
            {
                case DefaultIndexSchema:
                case FullTextIndexedDataset:
                case FullTextOptimiser:
                case LuceneObjectsIndexer:
                case LucenePredicatesIndexer:
                case LuceneSearchProvider:
                case LuceneSubjectsIndexer:
                    return true;

                default:
                    if (this._luceneAnalyzerType.IsAssignableFrom(t)) return true;
                    if (this._luceneDirectoryType.IsAssignableFrom(t)) return true;
                    return false;
            }
        }

        /// <summary>
        /// Converts from an integer to a Lucene.Net Version.
        /// </summary>
        /// <param name="ver">Version.</param>
        /// <returns></returns>
        private LucVersion GetLuceneVersion(int ver)
        {
            switch (ver)
            {
                case 2000:
                    return LucVersion.LUCENE_20;
                case 2100:
                    return LucVersion.LUCENE_21;
                case 2200:
                    return LucVersion.LUCENE_22;
                case 2300:
                    return LucVersion.LUCENE_23;
                case 2400:
                    return LucVersion.LUCENE_24;
                case 2900:
                    return LucVersion.LUCENE_29;
                default:
                    return LucVersion.LUCENE_29;
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using DirInfo = System.IO.DirectoryInfo;
using System.Linq;
using System.Reflection;
using Lucene.Net.Analysis;
using Lucene.Net.Analysis.Standard;
using Lucene.Net.Index;
using Lucene.Net.Store;
using VDS.RDF.Query;
using VDS.RDF.Query.Datasets;
using VDS.RDF.Query.FullText.Indexing;
using VDS.RDF.Query.FullText.Indexing.Lucene;
using VDS.RDF.Query.FullText.Schema;
using VDS.RDF.Query.FullText.Search;
using VDS.RDF.Query.FullText.Search.Lucene;
using VDS.RDF.Query.Optimisation;
using LucVersion = Lucene.Net.Util.Version;

namespace VDS.RDF.Configuration
{   
    /// <summary>
    /// An Object Factory that can load types from the Full Text Query library (<strong>dotNetRDF.Query.FullText.dll</strong>).
    /// </summary>
    public class FullTextObjectFactory
        : IObjectFactory
    {
        /// <summary>
        /// Constants for loadable Types.
        /// </summary>
        private const String LuceneSubjectsIndexer = "VDS.RDF.Query.FullText.Indexing.Lucene.LuceneSubjectsIndexer",
                             LuceneObjectsIndexer = "VDS.RDF.Query.FullText.Indexing.Lucene.LuceneObjectsIndexer",
                             LucenePredicatesIndexer = "VDS.RDF.Query.FullText.Indexing.Lucene.LucenePredicatesIndexer",
                             DefaultIndexSchema = "VDS.RDF.Query.FullText.Schema.DefaultIndexSchema",
                             LuceneSearchProvider = "VDS.RDF.Query.FullText.Search.Lucene.LuceneSearchProvider",
                             FullTextOptimiser = "VDS.RDF.Query.Optimisation.FullTextOptimiser",
                             FullTextIndexedDataset = "VDS.RDF.Query.Datasets.FullTextIndexedDataset";

        private readonly Type _luceneAnalyzerType = typeof(Analyzer);
        private readonly Type _luceneDirectoryType = typeof(Directory);

        private const int DefaultVersion = 3000;


        /// <summary>
        /// Tries to load an object based on information from the Configuration Graph.
        /// </summary>
        /// <param name="g">Configuration Graph.</param>
        /// <param name="objNode">Object Node.</param>
        /// <param name="targetType">Target Type.</param>
        /// <param name="obj">Output Object.</param>
        /// <returns></returns>
        public bool TryLoadObject(IGraph g, INode objNode, Type targetType, out object obj)
        {
            obj = null;

            INode index = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "index"));
            INode indexerProperty = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "indexer"));
            INode searcher = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "searcher"));
            INode analyzer = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "analyzer"));
            INode schema = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "schema"));
            INode version = g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "version"));

            Object tempIndex, tempAnalyzer, tempSchema;
            int ver = DefaultVersion;
            //Always check for the version
            ver = ConfigurationLoader.GetConfigurationInt32(g, objNode, version, DefaultVersion);

            switch (targetType.FullName)
            {
                case DefaultIndexSchema:
                    obj = new DefaultIndexSchema();
                    break;

                case FullTextIndexedDataset:
                    //Need to get the inner dataset
                    INode datasetNode = ConfigurationLoader.GetConfigurationNode(g, objNode, g.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyUsingDataset)));
                    if (datasetNode == null) throw new DotNetRdfConfigurationException("Unable to load the Full Text Indexed Dataset specified by the Node '" + objNode.ToString() + "' as there was no value specified for the required dnr:usingDataset property");
                    Object tempDataset = ConfigurationLoader.LoadObject(g, datasetNode);
                    if (tempDataset is ISparqlDataset iSparqlDataset)
                    {
                        //Then load the indexer associated with the dataset
                        INode indexerNode = ConfigurationLoader.GetConfigurationNode(g, objNode, indexerProperty);
                        if (indexerNode == null) throw new DotNetRdfConfigurationException("Unable to load the Full Text Indexed Dataset specified by the Node '" + objNode.ToString() + " as there was no value specified for the required dnr-ft:indexer property");
                        Object tempIndexer = ConfigurationLoader.LoadObject(g, indexerNode);
                        if (tempIndexer is IFullTextIndexer iFullTextIndexer)
                        {
                            bool indexNow = ConfigurationLoader.GetConfigurationBoolean(g, objNode, g.CreateUriNode(UriFactory.Create(FullTextHelper.PropertyIndexNow)), false);
                            obj = new FullTextIndexedDataset(iSparqlDataset, iFullTextIndexer, indexNow);
                        }
                        else
                        {
                            throw new DotNetRdfConfigurationException("Unable to load the Full Text Indexed Dataset specified by the Node '" + objNode.ToString() + "' as the value specified for the dnr-ft:indexer property pointed to an object which could not be loaded as a type that implements the required IFullTextIndexer interface");
                        }
                    }
                    else
                    {
                        throw new DotNetRdfConfigurationException("Unable to load the Full Text Indexed Dataset specified by the Node '" + objNode.ToString() + "' as the value specified for the dnr:usingDataset property pointed to an object which could not be loaded as a type that implements the required ISparqlDataset interface");
                    }
                    break;

                case FullTextOptimiser:
                    //Need to get the Search Provider
                    INode providerNode = ConfigurationLoader.GetConfigurationNode(g, objNode, searcher);
                    if (providerNode == null) throw new DotNetRdfConfigurationException("Unable to load the Full Text Optimiser specified by the Node '" + objNode.ToString() + "' as there was no value specified for the required dnr-ft:searcher property");
                    Object tempSearcher = ConfigurationLoader.LoadObject(g, providerNode);
                    if (tempSearcher is IFullTextSearchProvider iFullTextSearchProvider)
                    {
                        obj = new FullTextOptimiser(iFullTextSearchProvider);
                    }
                    else
                    {
                        throw new DotNetRdfConfigurationException("Unable to load the Full Text Optimiser specified by the Node '" + objNode.ToString() + "' as the value specified for the dnr-ft:searcher property pointed to an object which could not be loaded as a type that implements the required IFullTextSearchProvider interface");
                    }
                    break;

                case LuceneObjectsIndexer:
                case LucenePredicatesIndexer:
                case LuceneSubjectsIndexer:
                case LuceneSearchProvider:
                    //For any Lucene Indexer/Search Provider need to know the Index, Analyzer and Schema to be used

                    //Then get the Index
                    tempIndex = ConfigurationLoader.GetConfigurationNode(g, objNode, index);
                    if (tempIndex == null) throw new DotNetRdfConfigurationException("Unable to load the Lucene Indexer specified by the Node '" + objNode.ToString() + "' as there was no value specified for the required dnr-ft:index property");
                    tempIndex = ConfigurationLoader.LoadObject(g, (INode)tempIndex);
                    if (tempIndex is Directory directory)
                    {
                        //Next get the Analyzer (assume Standard if none specified)
                        tempAnalyzer = ConfigurationLoader.GetConfigurationNode(g, objNode, analyzer);
                        if (tempAnalyzer == null)
                        {
                            tempAnalyzer = new StandardAnalyzer(this.GetLuceneVersion(ver));
                        } 
                        else 
                        {
                            tempAnalyzer = ConfigurationLoader.LoadObject(g, (INode)tempAnalyzer);
                        }

                        if (tempAnalyzer is Analyzer analyzer)
                        {
                            //Finally get the Schema (assume Default if none specified)
                            tempSchema = ConfigurationLoader.GetConfigurationNode(g, objNode, schema);
                            if (tempSchema == null)
                            {
                                tempSchema = new DefaultIndexSchema();
                            }
                            else
                            {
                                tempSchema = ConfigurationLoader.LoadObject(g, (INode)tempSchema);
                            }

                            if (tempSchema is IFullTextIndexSchema iFullTextIndexSchema)
                            {
                                //Now we can create the Object
                                switch (targetType.FullName)
                                {
                                    case LuceneObjectsIndexer:
                                        obj = new LuceneObjectsIndexer(directory, analyzer, iFullTextIndexSchema);
                                        break;
                                    case LucenePredicatesIndexer:
                                        obj = new LucenePredicatesIndexer((Directory)tempIndex, (Analyzer)tempAnalyzer, (IFullTextIndexSchema)tempSchema);
                                        break;
                                    case LuceneSubjectsIndexer:
                                        obj = new LuceneSubjectsIndexer((Directory)tempIndex, (Analyzer)tempAnalyzer, (IFullTextIndexSchema)tempSchema);
                                        break;
                                    case LuceneSearchProvider:
                                        //Before the Search Provider has been loaded determine whether we need to carry out auto-indexing
                                        List<INode> sources = ConfigurationLoader.GetConfigurationData(g, objNode, g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "buildIndexFor"))).ToList();
                                        if (sources.Count > 0)
                                        {
                                            //If there are sources to index ensure we have an indexer to index with
                                            INode indexerNode = ConfigurationLoader.GetConfigurationNode(g, objNode, g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "buildIndexWith")));
                                            if (indexerNode == null) throw new DotNetRdfConfigurationException("Unable to load the Lucene Search Provider specified by the Node '" + objNode.ToString() + "' as there were values specified for the dnr-ft:buildIndexFor property but no dnr-ft:buildIndexWith property was found");
                                            IFullTextIndexer indexer = ConfigurationLoader.LoadObject(g, indexerNode) as IFullTextIndexer;
                                            if (indexer == null) throw new DotNetRdfConfigurationException("Unable to load the Lucene Search Provider specified by the Node '" + objNode.ToString() + "' as the value given for the dnr-ft:buildIndexWith property pointed to an Object which could not be loaded as a type that implements the required IFullTextIndexer interface");

                                            try 
                                            {
                                                //For Each Source load it and Index it
                                                foreach (INode sourceNode in sources)
                                                {
                                                    Object source = ConfigurationLoader.LoadObject(g, sourceNode);
                                                    if (source is ISparqlDataset iSparqlDataset)
                                                    {
                                                        indexer.Index(iSparqlDataset);
                                                    }
                                                    else if (source is ITripleStore iTripleStore)
                                                    {
                                                        foreach (IGraph graph in iTripleStore.Graphs)
                                                        {
                                                            indexer.Index(graph);
                                                        }
                                                    }
                                                    else if (source is IGraph iGraph)
                                                    {
                                                        indexer.Index(iGraph);
                                                    }
                                                    else
                                                    {
                                                        throw new DotNetRdfConfigurationException("Unable to load the Lucene Search Provider specified by the Node '" + objNode.ToString() + "' as a value given for the dnr-ft:buildIndexFor property ('" + sourceNode.ToString() + "') pointed to an Object which could not be loaded as a type that implements one of the required interfaces: IGraph, ITripleStore or ISparqlDataset");
                                                    }
                                                }
                                            } 
                                            finally 
                                            {
                                                indexer.Dispose();
                                            }
                                        }

                                        //Then we actually load the Search Provider
                                        bool autoSync = ConfigurationLoader.GetConfigurationBoolean(g, objNode, g.CreateUriNode(UriFactory.Create(FullTextHelper.PropertyIndexSync)), true);
                                        obj = new LuceneSearchProvider(this.GetLuceneVersion(ver), (Directory)tempIndex, (Analyzer)tempAnalyzer, (IFullTextIndexSchema)tempSchema, autoSync);
                                        break;
                                }
                            }
                            else
                            {
                                throw new DotNetRdfConfigurationException("Unable to load the Lucene Indexer specified by the Node '" + objNode.ToString() + "' as the value given for the dnr-ft:schema property pointed to an Object which could not be loaded as a type that implements the required IFullTextIndexSchema interface");
                            }
                        }
                        else
                        {
                            throw new DotNetRdfConfigurationException("Unable to load the Lucene Indexer specified by the Node '" + objNode.ToString() + "' as the value given for the dnr-ft:analyzer property pointed to an Object which could not be loaded as a type that derives from the required Lucene.Net.Analysis.Analyzer type");
                        }
                    }
                    else
                    {
                        throw new DotNetRdfConfigurationException("Unable to load the Lucene Indexer specified by the Node '" + objNode.ToString() + "' as the value given for the dnr-ft:index property pointed to an Object which could not be loaded as a type that derives from the required Lucene.Net.Store.Directory type");
                    }
                    break;

                default:
                    try
                    {
                        if (this._luceneAnalyzerType.IsAssignableFrom(targetType))
                        {
                            //Create an Analyzer
                            //Try to create passing Lucene Version wherever possible
                            if (targetType.GetConstructor(new Type[] { typeof(LucVersion) }) != null)
                            {
                                obj = Activator.CreateInstance(targetType, new Object[] { this.GetLuceneVersion(ver) });
                            }
                            else
                            {
                                obj = Activator.CreateInstance(targetType);
                            }
                        }
                        else if (this._luceneDirectoryType.IsAssignableFrom(targetType))
                        {
                            //Create a Directory aka a Lucene Index
                            String dir = ConfigurationLoader.GetConfigurationString(g, objNode, g.CreateUriNode(UriFactory.Create(ConfigurationLoader.PropertyFromFile)));
                            if (dir != null)
                            {
                                try
                                {
                                    obj = Activator.CreateInstance(targetType, new Object[] { dir });
                                }
                                catch
                                {
                                    MethodInfo method = targetType.GetMethod("Open", new Type[] { typeof(DirInfo) });
                                    if (method != null)
                                    {
                                        obj = method.Invoke(null, new Object[] { new DirInfo(ConfigurationLoader.ResolvePath(dir)) });
                                    }
                                }
                            }
                            else
                            {
                                obj = Activator.CreateInstance(targetType);
                            }
                            //Ensure the Index if necessary
                            if (obj != null)
                            {
                                if (ConfigurationLoader.GetConfigurationBoolean(g, objNode, g.CreateUriNode(UriFactory.Create(FullTextHelper.FullTextConfigurationNamespace + "ensureIndex")), false))
                                {
                                    IndexWriter writer = new IndexWriter((Directory)obj, new StandardAnalyzer(this.GetLuceneVersion(ver)), IndexWriter.MaxFieldLength.UNLIMITED);
                                    writer.Dispose();
                                }
                            }
                        }
                    }
                    catch
                    {
                        //Since we know we don't allow loading of all analyzers and directories we allow for users to inject other object factories
                        //which may know how to load those specific instances
                        obj = null;
                    }
                    break;
            }

            return (obj != null);
        }

        /// <summary>
        /// Gets whether this Factory can load objects of the given Type.
        /// </summary>
        /// <param name="t">Type.</param>
        /// <returns></returns>
        public bool CanLoadObject(Type t)
        {
            switch (t.FullName)
            {
                case DefaultIndexSchema:
                case FullTextIndexedDataset:
                case FullTextOptimiser:
                case LuceneObjectsIndexer:
                case LucenePredicatesIndexer:
                case LuceneSearchProvider:
                case LuceneSubjectsIndexer:
                    return true;

                default:
                    if (this._luceneAnalyzerType.IsAssignableFrom(t)) return true;
                    if (this._luceneDirectoryType.IsAssignableFrom(t)) return true;
                    return false;
            }
        }

        /// <summary>
        /// Converts from an integer to a Lucene.Net Version.
        /// </summary>
        /// <param name="ver">Version.</param>
        /// <returns></returns>
        private LucVersion GetLuceneVersion(int ver)
        {
            switch (ver)
            {
                case 2000:
                    return LucVersion.LUCENE_20;
                case 2100:
                    return LucVersion.LUCENE_21;
                case 2200:
                    return LucVersion.LUCENE_22;
                case 2300:
                    return LucVersion.LUCENE_23;
                case 2400:
                    return LucVersion.LUCENE_24;
                case 2900:
                    return LucVersion.LUCENE_29;
                default:
                    return LucVersion.LUCENE_29;
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF.Query.FullText\FullTextObjectFactory.cs(156,93): error CS0841: Cannot use local variable 'analyzer' before it is declared,D:\a\1\s\Libraries\dotNetRDF.Query.FullText\FullTextObjectFactory.cs(166,54): error CS0136: A local or parameter named 'analyzer' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Libraries\dotNetRDF.Query.FullText\FullTextObjectFactory.cs(210,82): error CS0136: A local or parameter named 'iSparqlDataset' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 12 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\RDFUtil.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using VDS.RDF.Nodes;
using VDS.RDF.Query.Spin.LibraryOntology;
using VDS.RDF.Query.Spin.Model;

namespace VDS.RDF.Query.Spin.Util
{
    internal static class RDFUtil
    {

        public readonly static UriComparer uriComparer = new UriComparer();

        public readonly static IEqualityComparer<Triple> tripleEqualityComparer = new TripleEqualityComparer();

        public readonly static NodeFactory nodeFactory = new NodeFactory();

        #region UriComparison shortcuts
        internal static bool sameTerm(Uri uri1, Uri uri2)
        {
            return uriComparer.Equals(uri1, uri2);
        }

        internal static bool sameTerm(Uri uri1, INode uri2)
        {
            if (uri2 is IResource) uri2 = ((IResource)uri2).getSource();
            if (!(uri2 is IUriNode)) return false;
            return uriComparer.Equals(uri1, ((IUriNode)uri2).Uri);
        }

        internal static bool sameTerm(INode uri1, Uri uri2)
        {
            if (uri1 is IResource) uri1 = ((IResource)uri1).getSource();
            if (!(uri1 is IUriNode)) return false;
            return uriComparer.Equals(((IUriNode)uri1).Uri, uri2);
        }

        internal static bool sameTerm(INode uri1, INode uri2)
        {
            if (uri1 is IResource) uri1 = ((IResource)uri1).getSource();
            if (uri2 is IResource) uri2 = ((IResource)uri2).getSource();
            if (!(uri1 is IUriNode) || !(uri2 is IUriNode)) return false;
            return uriComparer.Equals(((IUriNode)uri1).Uri, ((IUriNode)uri2).Uri);
        }

        #endregion

        #region NodeFactory shortcuts

        internal static IUriNode CreateUriNode(Uri uri)
        {
            return nodeFactory.CreateUriNode(uri);
        }

        internal static ILiteralNode CreateLiteralNode(String literal)
        {
            return nodeFactory.CreateLiteralNode(literal);
        }

        internal static ILiteralNode CreateLiteralNode(String literal, String langspec)
        {
            return nodeFactory.CreateLiteralNode(literal, langspec);
        }

        internal static ILiteralNode CreateLiteralNode(String literal, Uri datatype)
        {
            return nodeFactory.CreateLiteralNode(literal, datatype);
        }

        internal static ILiteralNode FALSE = CreateLiteralNode("false", UriFactory.Create(NamespaceMapper.XMLSCHEMA + "boolean"));
        internal static ILiteralNode TRUE = CreateLiteralNode("true", UriFactory.Create(NamespaceMapper.XMLSCHEMA + "boolean"));

        internal static HashSet<Uri> numericDatatypeURIs = new HashSet<Uri>(uriComparer);

        internal static HashSet<Uri> otherDatatypeURIs = new HashSet<Uri>(uriComparer);

        private static bool isFullyInitialized = false;
        private static void Initialize() {
            if (isFullyInitialized) return;
            numericDatatypeURIs.Add(XSD.DatatypeDecimal.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeDuration.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeGDay.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeGMonth.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeGMonthDay.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeGYear.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeGYearMonth.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeInteger.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeNegativeInteger.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeNonNegativeInteger.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeNonPositiveInteger.Uri);
            numericDatatypeURIs.Add(XSD.DatatypePositiveInteger.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeUnsignedByte.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeUnsignedInt.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeUnsignedLong.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeUnsignedShort.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeByte.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeDouble.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeFloat.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeInt.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeLong.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeShort.Uri);

            otherDatatypeURIs.Add(XSD.DatatypeAnySimpleType.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeAnyURI.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeBase64Binary.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeDate.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeDateTime.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeENTITY.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeHexBinary.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeID.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeIDREF.Uri);
            otherDatatypeURIs.Add(XSD.PropertyLanguage.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeName.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeNCName.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeNMTOKEN.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeNormalizedString.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeNOTATION.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeQName.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeTime.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeToken.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeBoolean.Uri);
            otherDatatypeURIs.Add(XSD.string_.Uri);
            otherDatatypeURIs.Add(RDF.ClassXMLLiteral.Uri);

            isFullyInitialized = true;
        }

        internal static ILiteralNode createInteger(int value)
        {
            return CreateLiteralNode("" + value, XSD.DatatypeInteger.Uri);
        }


        /**
         * Gets a List of all datatype URIs.
         * @return a List the datatype URIs
         */
        internal static List<Uri> getDatatypeURIs()
        {
            Initialize();
            List<Uri> list = new List<Uri>();
            list.AddRange(otherDatatypeURIs);
            list.AddRange(numericDatatypeURIs);
            list.Add(RDF.ClassPlainLiteral.Uri);
            return list;
        }


        /**
         * Checks if a given URI is a numeric datatype URI.
         * @param datatypeURI  the URI of the datatype to test
         * @return true if so
         */
        internal static bool isNumeric(Uri datatypeURI)
        {
            Initialize();
            return numericDatatypeURIs.Contains(datatypeURI);
        }


        /**
         * Checks if a given INode represents a system XSD datatype such as xsd:int.
         * Note: this will not return true on user-defined datatypes or rdfs:Literal.
         * @param node  the node to test
         * @return true if node is a datatype
         */
        internal static bool isSystemDatatype(INode node)
        {
            Initialize();
            if (node is IUriNode)
            {
                return isNumeric(((IUriNode)node).Uri) || otherDatatypeURIs.Contains(((IUriNode)node).Uri);
            }
            else
            {
                return false;
            }
        }

        #endregion

    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using VDS.RDF.Nodes;
using VDS.RDF.Query.Spin.LibraryOntology;
using VDS.RDF.Query.Spin.Model;

namespace VDS.RDF.Query.Spin.Util
{
    internal static class RDFUtil
    {

        public readonly static UriComparer uriComparer = new UriComparer();

        public readonly static IEqualityComparer<Triple> tripleEqualityComparer = new TripleEqualityComparer();

        public readonly static NodeFactory nodeFactory = new NodeFactory();

        #region UriComparison shortcuts
        internal static bool sameTerm(Uri uri1, Uri uri2)
        {
            return uriComparer.Equals(uri1, uri2);
        }

        internal static bool sameTerm(Uri uri1, INode uri2)
        {
            if (uri2 is IResource iResource) uri2 = iResource.getSource();
            if (!(uri2 is IUriNode)) return false;
            return uriComparer.Equals(uri1, ((IUriNode)uri2).Uri);
        }

        internal static bool sameTerm(INode uri1, Uri uri2)
        {
            if (uri1 is IResource iResource) uri1 = iResource.getSource();
            if (!(uri1 is IUriNode)) return false;
            return uriComparer.Equals(((IUriNode)uri1).Uri, uri2);
        }

        internal static bool sameTerm(INode uri1, INode uri2)
        {
            if (uri1 is IResource iResource) uri1 = iResource.getSource();
            if (uri2 is IResource iResource) uri2 = iResource.getSource();
            if (!(uri1 is IUriNode) || !(uri2 is IUriNode)) return false;
            return uriComparer.Equals(((IUriNode)uri1).Uri, ((IUriNode)uri2).Uri);
        }

        #endregion

        #region NodeFactory shortcuts

        internal static IUriNode CreateUriNode(Uri uri)
        {
            return nodeFactory.CreateUriNode(uri);
        }

        internal static ILiteralNode CreateLiteralNode(String literal)
        {
            return nodeFactory.CreateLiteralNode(literal);
        }

        internal static ILiteralNode CreateLiteralNode(String literal, String langspec)
        {
            return nodeFactory.CreateLiteralNode(literal, langspec);
        }

        internal static ILiteralNode CreateLiteralNode(String literal, Uri datatype)
        {
            return nodeFactory.CreateLiteralNode(literal, datatype);
        }

        internal static ILiteralNode FALSE = CreateLiteralNode("false", UriFactory.Create(NamespaceMapper.XMLSCHEMA + "boolean"));
        internal static ILiteralNode TRUE = CreateLiteralNode("true", UriFactory.Create(NamespaceMapper.XMLSCHEMA + "boolean"));

        internal static HashSet<Uri> numericDatatypeURIs = new HashSet<Uri>(uriComparer);

        internal static HashSet<Uri> otherDatatypeURIs = new HashSet<Uri>(uriComparer);

        private static bool isFullyInitialized = false;
        private static void Initialize() {
            if (isFullyInitialized) return;
            numericDatatypeURIs.Add(XSD.DatatypeDecimal.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeDuration.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeGDay.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeGMonth.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeGMonthDay.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeGYear.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeGYearMonth.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeInteger.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeNegativeInteger.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeNonNegativeInteger.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeNonPositiveInteger.Uri);
            numericDatatypeURIs.Add(XSD.DatatypePositiveInteger.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeUnsignedByte.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeUnsignedInt.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeUnsignedLong.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeUnsignedShort.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeByte.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeDouble.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeFloat.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeInt.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeLong.Uri);
            numericDatatypeURIs.Add(XSD.DatatypeShort.Uri);

            otherDatatypeURIs.Add(XSD.DatatypeAnySimpleType.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeAnyURI.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeBase64Binary.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeDate.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeDateTime.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeENTITY.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeHexBinary.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeID.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeIDREF.Uri);
            otherDatatypeURIs.Add(XSD.PropertyLanguage.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeName.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeNCName.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeNMTOKEN.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeNormalizedString.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeNOTATION.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeQName.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeTime.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeToken.Uri);
            otherDatatypeURIs.Add(XSD.DatatypeBoolean.Uri);
            otherDatatypeURIs.Add(XSD.string_.Uri);
            otherDatatypeURIs.Add(RDF.ClassXMLLiteral.Uri);

            isFullyInitialized = true;
        }

        internal static ILiteralNode createInteger(int value)
        {
            return CreateLiteralNode("" + value, XSD.DatatypeInteger.Uri);
        }


        /**
         * Gets a List of all datatype URIs.
         * @return a List the datatype URIs
         */
        internal static List<Uri> getDatatypeURIs()
        {
            Initialize();
            List<Uri> list = new List<Uri>();
            list.AddRange(otherDatatypeURIs);
            list.AddRange(numericDatatypeURIs);
            list.Add(RDF.ClassPlainLiteral.Uri);
            return list;
        }


        /**
         * Checks if a given URI is a numeric datatype URI.
         * @param datatypeURI  the URI of the datatype to test
         * @return true if so
         */
        internal static bool isNumeric(Uri datatypeURI)
        {
            Initialize();
            return numericDatatypeURIs.Contains(datatypeURI);
        }


        /**
         * Checks if a given INode represents a system XSD datatype such as xsd:int.
         * Note: this will not return true on user-defined datatypes or rdfs:Literal.
         * @param node  the node to test
         * @return true if node is a datatype
         */
        internal static bool isSystemDatatype(INode node)
        {
            Initialize();
            if (node is IUriNode iUriNode)
            {
                return isNumeric(iUriNode.Uri) || otherDatatypeURIs.Contains(((IUriNode)node).Uri);
            }
            else
            {
                return false;
            }
        }

        #endregion

    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\RDFUtil.cs(29,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\RDFUtil.cs(30,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\RDFUtil.cs(31,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\RDFUtil.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\RDFUtil.cs(69,35): error CS0128: A local variable or function named 'iResource' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\RDFUtil.cs(69,53): error CS0165: Use of unassigned local variable 'iResource',D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\RDFUtil.cs(30,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\RDFUtil.cs(31,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\RDFUtil.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\RDFUtil.cs(29,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 13 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using VDS.RDF;
using VDS.RDF.Nodes;
using VDS.RDF.Query.Spin;
using VDS.RDF.Query.Spin.Model;
using System.Reflection;
using VDS.RDF.Query.Datasets;

namespace VDS.RDF.Query.Spin.Util
{
    /// <summary>
    /// A utility class that wraps dotNetRDF Nodes with the same interface as the Jena Resource classes
    /// </summary>
    internal class Resource : IResource, IComparable<IResource>, IEquatable<IResource>
    {

        #region "Basic resource wrapper implementation "

        private INode _source;
        private SpinProcessor _model;

        //TODO DO NOT USE THIS ONE !!!
        //internal static Resource Get(INode node)
        //{
        //    if (node is Resource)
        //    {
        //        return (Resource)node;
        //    }
        //    return new Resource(node, SpinWrapperDataset.currentModel);
        //}

        internal static Resource Get(INode node, SpinProcessor spinModel)
        {
            if (node == null) return null;
            if (node is Resource && ((IResource)node).getModel() == spinModel)
            {
                return (Resource)node;
            }
            return new Resource(node, spinModel);
        }

        protected Resource(INode node, SpinProcessor spinModel)
        {
            _source = node;
            _model = spinModel;
            if (node is Resource)
            {
                _source = ((Resource)node).getSource();
            }
        }

        public bool isBlank()
        {
            return _source is IBlankNode;
        }

        public bool isUri()
        {
            return _source is IUriNode;
        }

        public bool isLiteral()
        {
            return _source is ILiteralNode;
        }

        public Uri Uri
        {
            get
            {
                if (isUri())
                {
                    return ((IUriNode)_source).Uri;
                }
                return null;
            }
        }

        public INode getSource()
        {
            return _source;
        }

        public SpinProcessor getModel()
        {
            return _model;
        }

        public bool canAs(INode cls)
        {
            return _model.ContainsTriple(_source, RDF.PropertyType, cls);
        }

        // A constructor cache to optimize half of the reflection work
        private static Dictionary<Type, ConstructorInfo> constructors = new Dictionary<Type, ConstructorInfo>();
        public IResource As(Type cls)
        {
            ConstructorInfo constructor;
            if (constructors.ContainsKey(cls))
            {
                constructor = constructors[cls];
            }
            else
            {
                constructor = cls.GetConstructor(new Type[] { typeof(INode), typeof(SpinProcessor) });
                constructors[cls] = constructor;
            }
            return (IResource)constructor.Invoke(new object[] { _source, _model });
        }

        public IEnumerable<IResource> getObjects(INode property)
        {
            return _model.GetTriplesWithSubjectPredicate(this, property).Select(t => Resource.Get(t.Object, _model));
        }

        public List<IResource> AsList()
        {
            List<IResource> result = new List<IResource>();
            INode listRoot = this;
            Triple step = _model.GetTriplesWithSubjectPredicate(listRoot, RDF.PropertyFirst).FirstOrDefault();
            if (step != null)
            {
                while (step != null)
                {
                    if (!RDFUtil.sameTerm(RDF.Nil, step.Object))
                    {
                        result.Add(Resource.Get(step.Object, _model));
                    }
                    step = _model.GetTriplesWithSubjectPredicate(listRoot, RDF.PropertyRest).FirstOrDefault();
                    if (step != null)
                    {
                        if (RDFUtil.sameTerm(RDF.Nil, step.Object))
                        {
                            break;
                        }
                        listRoot = step.Object;
                        step = _model.GetTriplesWithSubjectPredicate(listRoot, RDF.PropertyFirst).FirstOrDefault();
                    }
                }
            }
            else
            {
                result.Add(this);
            }
            return result;
        }

        public void AddProperty(INode predicate, INode value)
        {
            if (predicate == null || value == null)
            {
                return;
            }
            if (predicate is IResource)
            {
                predicate = ((IResource)predicate).getSource();
            }
            if (value is IResource)
            {
                value = ((IResource)value).getSource();
            }
            _source.Graph.Assert(_source, predicate, value);
        }

        // TODO check whether we need to reference Model or _model
        public IEnumerable<Triple> listProperties()
        {
            return _model.GetTriplesWithSubject(_source);
        }

        public IEnumerable<Triple> listProperties(INode property)
        {
            return _model.GetTriplesWithSubjectPredicate(_source, property);
        }

        public bool hasProperty(INode property)
        {
            return _model.GetTriplesWithSubjectPredicate(_source, property).Any();
        }

        public bool hasProperty(INode property, INode value)
        {
            return _model.ContainsTriple(_source, property, value);
        }

        /* To simplify subsequent code and calls, we consider chaining cases where property is null */
        public Triple getProperty(INode property)
        {
            if (property != null)
            {
                return _model.GetTriplesWithSubjectPredicate(_source, property).FirstOrDefault();
            }
            return null;
        }

        public IResource getObject(INode property)
        {
            Triple t = getProperty(property);
            if (t != null)
            {
                return Resource.Get(t.Object, _model);
            }
            else
            {
                return null;
            }
        }

        public IResource getResource(INode property)
        {
            IResource obj = getObject(property);
            if (obj != null && !obj.isLiteral())
            {
                return obj;
            }
            return null;
        }

        public ILiteralNode getLiteral(INode property)
        {
            IResource obj = getObject(property);
            if (obj != null && obj.isLiteral())
            {
                return (ILiteralNode)obj.getSource();
            }
            return null;
        }

        public bool? getBoolean(INode property)
        {
            ILiteralNode obj = getLiteral(property);
            if (obj is IValuedNode)
            {
                return ((IValuedNode)obj).AsBoolean();
            }
            return null;
        }

        public int? getInteger(INode property)
        {
            ILiteralNode obj = getLiteral(property);
            if (obj is IValuedNode)
            {
                return (int)((IValuedNode)obj).AsInteger();
            }
            return null;
        }
        public long? getLong(INode property)
        {
            ILiteralNode obj = getLiteral(property);
            if (obj is IValuedNode)
            {
                return ((IValuedNode)obj).AsInteger();
            }
            return null;
        }

        public String getString(INode property)
        {
            ILiteralNode obj = getLiteral(property);
            if (obj != null)
            {
                return obj.Value;
            }
            return null;
        }


        public IResource inferRDFNode(INode property)
        {
            IResource existing = getObject(property);
            if (existing != null)
            {
                return existing;
            }
            else
            {
                return null;
            }
        }

        #endregion

        #region "INode implementation "

        public NodeType NodeType
        {
            get
            {
                return _source.NodeType;
            }
        }

        public IGraph Graph
        {
            get
            {
                return _source.Graph;
            }
        }

        public Uri GraphUri
        {
            get
            {
                return _source.GraphUri;
            }
            set
            {
                _source.GraphUri = value;
            }
        }

        public string ToString(Writing.Formatting.INodeFormatter formatter)
        {
            return _source.ToString(formatter);
        }

        public string ToString(Writing.Formatting.INodeFormatter formatter, Writing.TripleSegment segment)
        {
            return _source.ToString(formatter, segment);
        }

        public int CompareTo(INode other)
        {
            if (other is IResource) return CompareTo((IResource)other);
            return _source.CompareTo(other);
        }

        public int CompareTo(IResource other)
        {
            if (other == null) return 1;
            return _source.CompareTo(other.getSource());
        }

        public int CompareTo(IBlankNode other)
        {
            return _source.CompareTo(other);
        }

        public int CompareTo(IGraphLiteralNode other)
        {
            return _source.CompareTo(other);
        }

        public int CompareTo(ILiteralNode other)
        {
            return _source.CompareTo(other);
        }

        public int CompareTo(IUriNode other)
        {
            return _source.CompareTo(other);
        }

        public int CompareTo(IVariableNode other)
        {
            return _source.CompareTo(other);
        }

        public bool Equals(INode other)
        {
            if (other is IResource) return Equals((IResource)other);
            return _source.Equals(other);
        }

        public bool Equals(IResource other)
        {
            if (other == null) return false;
            return _source.Equals(other.getSource());
        }

        public bool Equals(IBlankNode other)
        {
            return _source.Equals(other);
        }

        public bool Equals(IGraphLiteralNode other)
        {
            return _source.Equals(other);
        }

        public bool Equals(ILiteralNode other)
        {
            return _source.Equals(other);
        }

        public bool Equals(IUriNode other)
        {
            return _source.Equals(other);
        }

        public bool Equals(IVariableNode other)
        {
            return _source.Equals(other);
        }

        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
        {
            _source.GetObjectData(info, context);
        }

        public System.Xml.Schema.XmlSchema GetSchema()
        {
            return _source.GetSchema();
        }

        public void ReadXml(System.Xml.XmlReader reader)
        {
            _source.ReadXml(reader);
        }

        public void WriteXml(System.Xml.XmlWriter writer)
        {
            _source.WriteXml(writer);
        }

        #endregion
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using VDS.RDF;
using VDS.RDF.Nodes;
using VDS.RDF.Query.Spin;
using VDS.RDF.Query.Spin.Model;
using System.Reflection;
using VDS.RDF.Query.Datasets;

namespace VDS.RDF.Query.Spin.Util
{
    /// <summary>
    /// A utility class that wraps dotNetRDF Nodes with the same interface as the Jena Resource classes
    /// </summary>
    internal class Resource : IResource, IComparable<IResource>, IEquatable<IResource>
    {

        #region "Basic resource wrapper implementation "

        private INode _source;
        private SpinProcessor _model;

        //TODO DO NOT USE THIS ONE !!!
        //internal static Resource Get(INode node)
        //{
        //    if (node is Resource)
        //    {
        //        return (Resource)node;
        //    }
        //    return new Resource(node, SpinWrapperDataset.currentModel);
        //}

        internal static Resource Get(INode node, SpinProcessor spinModel)
        {
            if (node == null) return null;
            if (node is Resource && ((IResource)node).getModel() == spinModel)
            {
                return (Resource)node;
            }
            return new Resource(node, spinModel);
        }

        protected Resource(INode node, SpinProcessor spinModel)
        {
            _source = node;
            _model = spinModel;
            if (node is Resource resource)
            {
                _source = resource.getSource();
            }
        }

        public bool isBlank()
        {
            return _source is IBlankNode;
        }

        public bool isUri()
        {
            return _source is IUriNode;
        }

        public bool isLiteral()
        {
            return _source is ILiteralNode;
        }

        public Uri Uri
        {
            get
            {
                if (isUri())
                {
                    return ((IUriNode)_source).Uri;
                }
                return null;
            }
        }

        public INode getSource()
        {
            return _source;
        }

        public SpinProcessor getModel()
        {
            return _model;
        }

        public bool canAs(INode cls)
        {
            return _model.ContainsTriple(_source, RDF.PropertyType, cls);
        }

        // A constructor cache to optimize half of the reflection work
        private static Dictionary<Type, ConstructorInfo> constructors = new Dictionary<Type, ConstructorInfo>();
        public IResource As(Type cls)
        {
            ConstructorInfo constructor;
            if (constructors.ContainsKey(cls))
            {
                constructor = constructors[cls];
            }
            else
            {
                constructor = cls.GetConstructor(new Type[] { typeof(INode), typeof(SpinProcessor) });
                constructors[cls] = constructor;
            }
            return (IResource)constructor.Invoke(new object[] { _source, _model });
        }

        public IEnumerable<IResource> getObjects(INode property)
        {
            return _model.GetTriplesWithSubjectPredicate(this, property).Select(t => Resource.Get(t.Object, _model));
        }

        public List<IResource> AsList()
        {
            List<IResource> result = new List<IResource>();
            INode listRoot = this;
            Triple step = _model.GetTriplesWithSubjectPredicate(listRoot, RDF.PropertyFirst).FirstOrDefault();
            if (step != null)
            {
                while (step != null)
                {
                    if (!RDFUtil.sameTerm(RDF.Nil, step.Object))
                    {
                        result.Add(Resource.Get(step.Object, _model));
                    }
                    step = _model.GetTriplesWithSubjectPredicate(listRoot, RDF.PropertyRest).FirstOrDefault();
                    if (step != null)
                    {
                        if (RDFUtil.sameTerm(RDF.Nil, step.Object))
                        {
                            break;
                        }
                        listRoot = step.Object;
                        step = _model.GetTriplesWithSubjectPredicate(listRoot, RDF.PropertyFirst).FirstOrDefault();
                    }
                }
            }
            else
            {
                result.Add(this);
            }
            return result;
        }

        public void AddProperty(INode predicate, INode value)
        {
            if (predicate == null || value == null)
            {
                return;
            }
            if (predicate is IResource iResource)
            {
                predicate = iResource.getSource();
            }
            if (value is IResource iResource)
            {
                value = iResource.getSource();
            }
            _source.Graph.Assert(_source, predicate, value);
        }

        // TODO check whether we need to reference Model or _model
        public IEnumerable<Triple> listProperties()
        {
            return _model.GetTriplesWithSubject(_source);
        }

        public IEnumerable<Triple> listProperties(INode property)
        {
            return _model.GetTriplesWithSubjectPredicate(_source, property);
        }

        public bool hasProperty(INode property)
        {
            return _model.GetTriplesWithSubjectPredicate(_source, property).Any();
        }

        public bool hasProperty(INode property, INode value)
        {
            return _model.ContainsTriple(_source, property, value);
        }

        /* To simplify subsequent code and calls, we consider chaining cases where property is null */
        public Triple getProperty(INode property)
        {
            if (property != null)
            {
                return _model.GetTriplesWithSubjectPredicate(_source, property).FirstOrDefault();
            }
            return null;
        }

        public IResource getObject(INode property)
        {
            Triple t = getProperty(property);
            if (t != null)
            {
                return Resource.Get(t.Object, _model);
            }
            else
            {
                return null;
            }
        }

        public IResource getResource(INode property)
        {
            IResource obj = getObject(property);
            if (obj != null && !obj.isLiteral())
            {
                return obj;
            }
            return null;
        }

        public ILiteralNode getLiteral(INode property)
        {
            IResource obj = getObject(property);
            if (obj != null && obj.isLiteral())
            {
                return (ILiteralNode)obj.getSource();
            }
            return null;
        }

        public bool? getBoolean(INode property)
        {
            ILiteralNode obj = getLiteral(property);
            if (obj is IValuedNode iValuedNode)
            {
                return iValuedNode.AsBoolean();
            }
            return null;
        }

        public int? getInteger(INode property)
        {
            ILiteralNode obj = getLiteral(property);
            if (obj is IValuedNode iValuedNode)
            {
                return (int)iValuedNode.AsInteger();
            }
            return null;
        }
        public long? getLong(INode property)
        {
            ILiteralNode obj = getLiteral(property);
            if (obj is IValuedNode iValuedNode)
            {
                return iValuedNode.AsInteger();
            }
            return null;
        }

        public String getString(INode property)
        {
            ILiteralNode obj = getLiteral(property);
            if (obj != null)
            {
                return obj.Value;
            }
            return null;
        }


        public IResource inferRDFNode(INode property)
        {
            IResource existing = getObject(property);
            if (existing != null)
            {
                return existing;
            }
            else
            {
                return null;
            }
        }

        #endregion

        #region "INode implementation "

        public NodeType NodeType
        {
            get
            {
                return _source.NodeType;
            }
        }

        public IGraph Graph
        {
            get
            {
                return _source.Graph;
            }
        }

        public Uri GraphUri
        {
            get
            {
                return _source.GraphUri;
            }
            set
            {
                _source.GraphUri = value;
            }
        }

        public string ToString(Writing.Formatting.INodeFormatter formatter)
        {
            return _source.ToString(formatter);
        }

        public string ToString(Writing.Formatting.INodeFormatter formatter, Writing.TripleSegment segment)
        {
            return _source.ToString(formatter, segment);
        }

        public int CompareTo(INode other)
        {
            if (other is IResource iResource) return CompareTo(iResource);
            return _source.CompareTo(other);
        }

        public int CompareTo(IResource other)
        {
            if (other == null) return 1;
            return _source.CompareTo(other.getSource());
        }

        public int CompareTo(IBlankNode other)
        {
            return _source.CompareTo(other);
        }

        public int CompareTo(IGraphLiteralNode other)
        {
            return _source.CompareTo(other);
        }

        public int CompareTo(ILiteralNode other)
        {
            return _source.CompareTo(other);
        }

        public int CompareTo(IUriNode other)
        {
            return _source.CompareTo(other);
        }

        public int CompareTo(IVariableNode other)
        {
            return _source.CompareTo(other);
        }

        public bool Equals(INode other)
        {
            if (other is IResource iResource) return Equals(iResource);
            return _source.Equals(other);
        }

        public bool Equals(IResource other)
        {
            if (other == null) return false;
            return _source.Equals(other.getSource());
        }

        public bool Equals(IBlankNode other)
        {
            return _source.Equals(other);
        }

        public bool Equals(IGraphLiteralNode other)
        {
            return _source.Equals(other);
        }

        public bool Equals(ILiteralNode other)
        {
            return _source.Equals(other);
        }

        public bool Equals(IUriNode other)
        {
            return _source.Equals(other);
        }

        public bool Equals(IVariableNode other)
        {
            return _source.Equals(other);
        }

        public void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context)
        {
            _source.GetObjectData(info, context);
        }

        public System.Xml.Schema.XmlSchema GetSchema()
        {
            return _source.GetSchema();
        }

        public void ReadXml(System.Xml.XmlReader reader)
        {
            _source.ReadXml(reader);
        }

        public void WriteXml(System.Xml.XmlWriter writer)
        {
            _source.WriteXml(writer);
        }

        #endregion
    }
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs(30,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs(35,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs(186,36): error CS0128: A local variable or function named 'iResource' is already defined in this scope,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs(188,25): error CS0165: Use of unassigned local variable 'iResource',D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs(30,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\dotNetRDF.Query.Spin\Util\Resource.cs(35,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 14 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using Xunit;
using VDS.RDF;
using VDS.RDF.Parsing;
using VDS.RDF.Query;
using VDS.RDF.Query.Algebra;
using VDS.RDF.Query.Datasets;
using VDS.RDF.Query.Expressions;
using VDS.RDF.Query.Expressions.Functions;
using VDS.RDF.Query.Optimisation;
using VDS.RDF.Writing.Formatting;


namespace VDS.RDF.Query
{
    public class SparqlTests2
    {
        private ISparqlDataset AsDataset(IInMemoryQueryableStore store)
        {
            if (store.Graphs.Count == 1)
            {
                return new InMemoryDataset(store, store.Graphs.First().BaseUri);
            }
            else
            {
                return new InMemoryDataset(store);
            }
        }

        private IEnumerable<IAlgebraOptimiser> _algebraOptimisers;

        private void UseSpecificOptimiserOnly(IAlgebraOptimiser optimiser)
        {
            this._algebraOptimisers = SparqlOptimiser.AlgebraOptimisers.ToList();
            foreach (IAlgebraOptimiser opt in this._algebraOptimisers)
            {
                SparqlOptimiser.RemoveOptimiser(opt);
            }
            SparqlOptimiser.AddOptimiser(optimiser);
        }

        private void ResetOptimiser()
        {
            foreach (IAlgebraOptimiser opt in SparqlOptimiser.AlgebraOptimisers.ToList())
            {
                SparqlOptimiser.RemoveOptimiser(opt);
            }
            foreach (IAlgebraOptimiser opt in this._algebraOptimisers)
            {
                SparqlOptimiser.AddOptimiser(opt);
            }
        }

        [Fact]
        public void SparqlBind()
        {
            String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o . BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) }";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count > 0, "Expected 1 or more results");
            }
        }

        [Fact]
        public void SparqlBindLazy()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o . BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) } LIMIT 1";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet)
                {
                    SparqlResultSet rset = (SparqlResultSet)results;
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 1, "Expected exactly 1 results");
                    Assert.True(rset.All(r => r.HasValue("triple")), "All Results should have had a value for ?triple");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlBindLazy2()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT * WHERE { ?s ?p ?o . BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) } LIMIT 10";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet)
                {
                    SparqlResultSet rset = (SparqlResultSet)results;
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 10, "Expected exactly 10 results");
                    Assert.True(rset.All(r => r.HasValue("s") && r.HasValue("p") && r.HasValue("o") && r.HasValue("triple")), "Expected ?s, ?p, ?o and ?triple values for every result");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlBindLazy3()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());
                String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT * WHERE { ?s ?p ?o . BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) } LIMIT 10 OFFSET 10";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet)
                {
                    SparqlResultSet rset = (SparqlResultSet)results;
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 10, "Expected exactly 10 results");
                    Assert.True(rset.All(r => r.HasValue("s") && r.HasValue("p") && r.HasValue("o") && r.HasValue("triple")), "Expected ?s, ?p, ?o and ?triple values for every result");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        //[Fact]
        //public void SparqlBindNested()
        //{
        //    String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o .{ BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) } FILTER(BOUND(?triple))}";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count == 0, "Expected no results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        [Fact]
        public void SparqlBindIn10Standard()
        {
            String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o . BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) }";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser(SparqlQuerySyntax.Sparql_1_0);
            Assert.Throws<RdfParseException>(() =>
            {
                SparqlQuery q = parser.ParseFromString(query);
            });
        }

        [Fact]
        public void SparqlBindToExistingVariable()
        {
            String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT * WHERE { ?s ?p ?o . BIND(?s AS ?p) }";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            Assert.Throws<RdfParseException>(() => { SparqlQuery q = parser.ParseFromString(query); });
        }

        [Fact]
        public void SparqlBindToExistingVariableLazy()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT * WHERE { ?s ?p ?o . BIND(?s AS ?p) } LIMIT 1";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                Assert.Throws<RdfParseException>(() => { SparqlQuery q = parser.ParseFromString(query); });
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlBindScope1()
        {
            String query = @"PREFIX : <http://www.example.org>
 SELECT *
 WHERE {
    {
    :s :p ?o .
    :s :q ?o1 .
    }
    BIND((1+?o) AS ?o1)
 }";

            SparqlQueryParser parser = new SparqlQueryParser();

            Assert.Throws<RdfParseException>(() => parser.ParseFromString(query));
        }

        [Fact]
        public void SparqlBindScope2()
        {
            String query = @"PREFIX : <http://www.example.org>
 SELECT *
 WHERE {
    :s :p ?o .
    { BIND((1 + ?o) AS ?o1) } UNION { BIND((2 + ?o) AS ?o1) }
 }";

            SparqlQueryParser parser = new SparqlQueryParser();
            parser.ParseFromString(query);
        }

        [Fact]
        public void SparqlBindScope3()
        {
            String query = @" PREFIX : <http://www.example.org>
 SELECT *
 WHERE {
    :s :p ?o .
    :s :q ?o1
    { BIND((1+?o) AS ?o1) }
 }";

            SparqlQueryParser parser = new SparqlQueryParser();
            parser.ParseFromString(query);
        }

        [Fact]
        public void SparqlBindScope4()
        {
            String query = @" PREFIX : <http://www.example.org>
 SELECT *
 WHERE {
    { 
    :s :p ?o .
    :s :q ?o1
    }
    { BIND((1+?o) AS ?o1) }
 }";

            SparqlQueryParser parser = new SparqlQueryParser();
            parser.ParseFromString(query);
        }

        [Fact]
        public void SparqlBindScope5()
        {
            String query = @"PREFIX : <http://example.org>
SELECT *
WHERE
{
  GRAPH ?g { :s :p ?o }
  BIND (?g AS ?in)
}";

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToString());

            ISparqlAlgebra algebra = q.ToAlgebra();
            Console.WriteLine(algebra.ToString());
            Assert.IsAssignableFrom<Select>(algebra);

            algebra = ((IUnaryOperator)algebra).InnerAlgebra;
            Assert.IsAssignableFrom<Extend>(algebra);
        }

        [Fact]
        public void SparqlBindScope6()
        {
            String query = @"PREFIX : <http://example.org>
SELECT *
WHERE
{
  {
    GRAPH ?g { :s :p ?o }
    BIND (?g AS ?in)
  }
  UNION
  {
    :s :p ?o .
    BIND('default' AS ?in)
  }
}";

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToString());

            ISparqlAlgebra algebra = q.ToAlgebra();
            Console.WriteLine(algebra.ToString());
            Assert.IsAssignableFrom<Select>(algebra);

            algebra = ((IUnaryOperator)algebra).InnerAlgebra;
            Assert.IsAssignableFrom<Union>(algebra);

            IUnion union = (Union)algebra;
            ISparqlAlgebra lhs = union.Lhs;
            Assert.IsAssignableFrom<Extend>(lhs);

            ISparqlAlgebra rhs = union.Rhs;
            Assert.IsAssignableFrom<Join>(rhs);
        }

        [Fact]
        public void SparqlLet()
        {
            String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o . LET (?triple := fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o))) }";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser(SparqlQuerySyntax.Extended);
            SparqlQuery q = parser.ParseFromString(query);

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count > 0, "Expected 1 or more results");
            }
        }

        [Fact]
        public void SparqlLetIn11Standard()
        {
            String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o . LET (?triple := fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o))) }";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser(SparqlQuerySyntax.Sparql_1_1);
            Assert.Throws<RdfParseException>(() =>
            {
                SparqlQuery q = parser.ParseFromString(query);
            });
        }

        //[Fact]
        //public void SparqlSubQueryLazy()
        //{
        //    String query = "SELECT * WHERE { {SELECT * WHERE { ?s ?p ?o}}} LIMIT 1";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Console.WriteLine(q.ToAlgebra().ToString());
        //    Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
        //    Console.WriteLine();

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count == 1, "Expected exactly 1 results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        //[Fact]
        //public void SparqlSubQueryLazy2()
        //{
        //    String query = "SELECT * WHERE { {SELECT * WHERE { ?s ?p ?o}}} LIMIT 10";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Console.WriteLine(q.ToAlgebra().ToString());
        //    Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
        //    Console.WriteLine();

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count == 10, "Expected exactly 10 results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        //[Fact]
        //public void SparqlSubQueryLazy3()
        //{
        //    String query = "SELECT * WHERE { {SELECT * WHERE { ?s ?p ?o}}} LIMIT 10 OFFSET 10";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Console.WriteLine(q.ToAlgebra().ToString());
        //    Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
        //    Console.WriteLine();

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count == 10, "Expected exactly 10 results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        //[Fact]
        //public void SparqlSubQueryLazyComplex()
        //{
        //    String query = "SELECT * WHERE { ?s a <http://example.org/vehicles/Car> . {SELECT * WHERE { ?s <http://example.org/vehicles/Speed> ?speed}}} LIMIT 1";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Console.WriteLine(q.ToAlgebra().ToString());
        //    Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
        //    Console.WriteLine();

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count == 1, "Expected exactly 1 results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        //[Fact]
        //public void SparqlSubQueryLazyComplex2()
        //{
        //    String query = "SELECT * WHERE { ?s a <http://example.org/vehicles/Car> . {SELECT * WHERE { ?s <http://example.org/vehicles/Speed> ?speed}}} LIMIT 5";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Console.WriteLine(q.ToAlgebra().ToString());
        //    Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
        //    Console.WriteLine();

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count <= 5, "Expected at most 5 results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        [Fact]
        public void SparqlOrderBySubjectLazyAscending()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ?s LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderBySubjectLazyAscendingExplicit()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ASC(?s) LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderBySubjectLazyDescending()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY DESC(?s) LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderByPredicateLazyAscending()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ?p LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderByPredicateLazyAscendingExplicit()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ASC(?p) LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderByPredicateLazyDescending()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY DESC(?p) LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderByComplexLazy()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ?s DESC(?p) LIMIT 5";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 5, "Expected exactly 5 results");
            }
        }

        [Fact]
        [Trait("Coverage", "Skip")]
        public void SparqlOrderByComplexLazyPerformance()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ?s DESC(?p) LIMIT 5";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\dataset_50.ttl.gz");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();

            //First do with Optimisation
            Stopwatch timer = new Stopwatch();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            timer.Start();
            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            timer.Stop();
            Console.WriteLine("Took " + timer.Elapsed + " to execute when Optimised");
            timer.Reset();
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 5, "Expected exactly 5 results");
            }

            //Then do without optimisation
            Options.AlgebraOptimisation = false;
            timer.Start();
            results = processor.ProcessQuery(q);
            timer.Stop();
            Console.WriteLine("Took " + timer.Elapsed + " to execute when Unoptimised");
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 5, "Expected exactly 5 results");
            }
            Options.AlgebraOptimisation = true;
        }

        [Fact]
        public void SparqlOrderByComplexLazy2()
        {
            String query = "SELECT * WHERE { ?s a ?vehicle . ?s <http://example.org/vehicles/Speed> ?speed } ORDER BY DESC(?speed) LIMIT 3";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                SparqlResultSet rset = (SparqlResultSet)results;
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.Equal(3, rset.Count);
            }
        }

        [Fact]
        public void SparqlFilterLazy()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                String query = "SELECT * WHERE { ?s a ?vehicle . FILTER (SAMETERM(?vehicle, <http://example.org/vehicles/Car>)) } LIMIT 3";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet)
                {
                    SparqlResultSet rset = (SparqlResultSet)results;
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 3, "Expected exactly 3 results");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlFilterLazy2()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());
                String query = "SELECT * WHERE { ?s a ?vehicle . FILTER (SAMETERM(?vehicle, <http://example.org/Vehicles/Car>)) } LIMIT 3";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine("NOTE: The URI for Car is purposefully wrong in this case so no results should be returned");
                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet)
                {
                    SparqlResultSet rset = (SparqlResultSet)results;
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 0, "Expected no results");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlFilterLazy3()
        {
            long currTimeout = Options.QueryExecutionTimeout;
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());
                Options.QueryExecutionTimeout = 0;

                String query = "SELECT * WHERE { ?s a ?vehicle . FILTER (SAMETERM(?vehicle, <http://example.org/vehicles/Car>)) . ?s <http://example.org/vehicles/Speed> ?speed } LIMIT 3";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);
                q.Timeout = 0;

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet)
                {
                    SparqlResultSet rset = (SparqlResultSet)results;
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 3, "Expected exactly 3 results");
                }
            }
            finally
            {
                this.ResetOptimiser();
                Options.QueryExecutionTimeout = currTimeout;
            }
        }

        [Fact]
        public void SparqlFilterLazy4()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());
                String query = "SELECT * WHERE { ?s a <http://example.org/vehicles/Car> ; <http://example.org/vehicles/Speed> ?speed } LIMIT 3";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet)
                {
                    SparqlResultSet rset = (SparqlResultSet)results;
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 3, "Expected exactly 3 results");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [SkippableFact]
        public void SparqlFilterLazyDBPedia()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseRemoteParsing),
                "Test Config marks Remote Parsing as unavailable, test cannot be run");

            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                SparqlParameterizedString query = new SparqlParameterizedString();
                query.Namespaces.AddNamespace("rdfs", new Uri(NamespaceMapper.RDFS));
                query.CommandText = "SELECT * WHERE {?s ?p ?label . FILTER(ISLITERAL(?label) && LANGMATCHES(LANG(?label), \"en\")) } LIMIT 5";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                UriLoader.Load(g, new Uri("http://dbpedia.org/resource/Southampton"));
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet)
                {
                    SparqlResultSet rset = (SparqlResultSet)results;
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 5, "Expected exactly 5 results");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlLazyWithAndWithoutOffset()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                String query = "SELECT * WHERE { ?s a ?vehicle . FILTER (SAMETERM(?vehicle, <http://example.org/vehicles/Car>)) } LIMIT 3";
                String query2 = "SELECT * WHERE { ?s a ?vehicle . FILTER (SAMETERM(?vehicle, <http://example.org/vehicles/Car>)) } LIMIT 3 OFFSET 3";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);
                SparqlQuery q2 = parser.ParseFromString(query2);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                Console.WriteLine(q2.ToAlgebra().ToString());
                Assert.True(q2.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet)
                {
                    SparqlResultSet rset = (SparqlResultSet)results;
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 3, "Expected exactly 3 results");

                    Object results2 = processor.ProcessQuery(q2);
                    Assert.IsAssignableFrom<SparqlResultSet>(results2);
                    if (results2 is SparqlResultSet)
                    {
                        SparqlResultSet rset2 = (SparqlResultSet)results2;
                        foreach (SparqlResult r in rset2)
                        {
                            Console.WriteLine(r.ToString());
                        }
                        Assert.True(rset2.Count == 1, "Expected exactly 1 results");
                    }
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlLazyLimitSimple1()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                const string query = @"PREFIX eg:
<http://example.org/vehicles/> PREFIX rdf:
<http://www.w3.org/1999/02/22-rdf-syntax-ns#> SELECT ?car ?speed WHERE
{ ?car rdf:type eg:Car . ?car eg:Speed ?speed } LIMIT 1";

                var g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");

                var parser = new SparqlQueryParser();
                var q = parser.ParseFromString(query);
                var results = g.ExecuteQuery(q);
                Assert.True(results is SparqlResultSet, "Expected a SPARQL results set");
                var rset = results as SparqlResultSet;
                foreach (var r in rset)
                {
                    Console.WriteLine(r);
                    Assert.Equal(2, r.Count);
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlLazyLimitSimple2()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                const string query = @"PREFIX eg:
<http://example.org/vehicles/> PREFIX rdf:
<http://www.w3.org/1999/02/22-rdf-syntax-ns#> SELECT ?car ?speed WHERE
{ ?car rdf:type eg:Car . ?car eg:Speed ?speed } LIMIT 20";

                var g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");

                var parser = new SparqlQueryParser();
                var q = parser.ParseFromString(query);
                var results = g.ExecuteQuery(q);
                Assert.True(results is SparqlResultSet, "Expected a SPARQL results set");
                var rset = results as SparqlResultSet;
                foreach (var r in rset)
                {
                    Console.WriteLine(r);
                    Assert.Equal(2, r.Count);
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlNestedOptionalCore406()
        {
            IGraph g = new Graph();
            g.LoadFromFile(@"resources\core-406.ttl");

            SparqlQuery query = new SparqlQueryParser().ParseFromFile(@"resources\core-406.rq");

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(new InMemoryDataset(g));
            SparqlResultSet results = processor.ProcessQuery(query) as SparqlResultSet;
            Assert.NotNull(results);

            TestTools.ShowResults(results);

            foreach (SparqlResult result in results)
            {
                Assert.True(result.HasBoundValue("first"), "Row " + result + " failed to contain ?first binding");
            }
        }

        [Fact]
        [Trait("Coverage", "Skip")]
        public void SparqlSubQueryGraphInteractionCore416_Serial()
        {
            try
            {
                Options.UsePLinqEvaluation = false;

                TripleStore store = new TripleStore();
                store.LoadFromFile(@"resources\core-416.trig");

                SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-416.rq");
                //SparqlFormatter formatter = new SparqlFormatter();
                //Console.WriteLine(formatter.Format(q));

                ISparqlDataset dataset = AsDataset(store);

                //ExplainQueryProcessor processor = new ExplainQueryProcessor(dataset, ExplanationLevel.OutputToConsoleStdOut | ExplanationLevel.ShowAll | ExplanationLevel.AnalyseNamedGraphs);
                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
                TimeSpan total = new TimeSpan();
                const int totalRuns = 1000;
                for (int i = 0; i < totalRuns; i++)
                {
                    Console.WriteLine("Starting query run " + i + " of " + totalRuns);
                    SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
                    Assert.NotNull(results);

                    if (q.QueryExecutionTime != null)
                    {
                        Console.WriteLine("Execution Time: " + q.QueryExecutionTime.Value);
                        total = total + q.QueryExecutionTime.Value;
                    }
                    if (results.Count != 4) TestTools.ShowResults(results);
                    Assert.Equal(4, results.Count);
                }

                Console.WriteLine("Total Execution Time: " + total);
                Assert.True(total < new TimeSpan(0, 0, 1 * (totalRuns / 10)));
            }
            finally
            {
                Options.UsePLinqEvaluation = true;
            }
        }

        [Fact]
        [Trait("Coverage", "Skip")]
        public void SparqlSubQueryGraphInteractionCore416_Parallel()
        {
            try
            {
                Options.UsePLinqEvaluation = true;

                TripleStore store = new TripleStore();
                store.LoadFromFile(@"resources\core-416.trig");

                SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-416.rq");
                Console.WriteLine(q.ToAlgebra().ToString());
                //SparqlFormatter formatter = new SparqlFormatter();
                //Console.WriteLine(formatter.Format(q));

                ISparqlDataset dataset = AsDataset(store);

                //ExplainQueryProcessor processor = new ExplainQueryProcessor(dataset, ExplanationLevel.OutputToConsoleStdOut | ExplanationLevel.ShowAll | ExplanationLevel.AnalyseNamedGraphs);
                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
                TimeSpan total = new TimeSpan();
                const int totalRuns = 1000;
                for (int i = 0; i < totalRuns; i++)
                {
                    Console.WriteLine("Starting query run " + i + " of " + totalRuns);
                    SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
                    Assert.NotNull(results);

                    if (q.QueryExecutionTime != null)
                    {
                        Console.WriteLine("Execution Time: " + q.QueryExecutionTime.Value);
                        total = total + q.QueryExecutionTime.Value;
                    }
                    if (results.Count != 4) TestTools.ShowResults(results);
                    Assert.Equal(4, results.Count);
                }

                Console.WriteLine("Total Execution Time: " + total);
                Assert.True(total < new TimeSpan(0, 0, 1 * (totalRuns / 10)));
            }
            finally
            {
                Options.UsePLinqEvaluation = true;
            }
        }

        [Fact]
        public void SparqlInfiniteLoopCore439_01()
        {
            TripleStore store = new TripleStore();
            store.LoadFromFile(@"resources\core-439\data.trig");

            SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-439\bad-query.rq");
            //q.Timeout = 10000;
            Console.WriteLine(q.ToAlgebra().ToString());

            ISparqlDataset dataset = AsDataset(store);

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
            SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;

            Assert.NotNull(results);

            Assert.Equal(10, results.Count);
        }

        [Fact]
        public void SparqlInfiniteLoopCore439_02()
        {
            TripleStore store = new TripleStore();
            store.LoadFromFile(@"resources\core-439\data.trig");

            SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-439\good-query.rq");
            //q.Timeout = 3000;
            Console.WriteLine(q.ToAlgebra().ToString());

            ISparqlDataset dataset = AsDataset(store);

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
            SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
            Assert.NotNull(results);

            Assert.Equal(10, results.Count);
        }

        [Fact]
        public void SparqlInfiniteLoopCore439_03()
        {
            TripleStore store = new TripleStore();
            store.LoadFromFile(@"resources\core-439\data.trig");

            SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-439\from-query.rq");
            //q.Timeout = 3000;
            Console.WriteLine(q.ToAlgebra().ToString());

            ISparqlDataset dataset = AsDataset(store);

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
            SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
            Assert.NotNull(results);

            Assert.Equal(10, results.Count);
        }

        [Fact]
        public void SparqlSubQueryOrderByLimitInteractionCore437()
        {
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            InMemoryDataset dataset = new InMemoryDataset(g);

            SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-437.rq");
            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
            SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
            Assert.NotNull(results);

            TestTools.ShowResults(results);
        }

        private void RunCore457(String query)
        {
            TripleStore store = new TripleStore();
            store.LoadFromFile(@"resources\core-457\data.nq");
            InMemoryDataset dataset = new InMemoryDataset(store);

            SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-457\" + query);
            q.Timeout = 15000;
            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
            SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
            Assert.NotNull(results);
            Assert.True(q.QueryExecutionTime.HasValue);
            Console.WriteLine(q.QueryExecutionTime.Value);

            //TestTools.ShowResults(results);
        }

        [Fact(Skip = "the query requires generating ~4.7 million solutions so is fundamentally unsolvable")]
        public void SparqlGraphOptionalInteractionCore457_1()
        {
            RunCore457("optional.rq");
        }


        [Fact(Skip = "the query requires generating ~4.7 million solutions so is fundamentally unsolvable")]
        public void SparqlGraphOptionalInteractionCore457_2()
        {
            try
            {
                Options.UsePLinqEvaluation = false;
                RunCore457("optional.rq");
            }
            finally
            {
                Options.UsePLinqEvaluation = true;
            }
        }

        [Fact]
        public void SparqlGraphOptionalInteractionCore457_3()
        {
            RunCore457("optional2.rq");
        }

        [Fact(Skip = "the query requires generating ~4.7 million solutions so is fundamentally unsolvable")]
        public void SparqlGraphExistsInteractionCore457_1()
        {
            RunCore457("exists.rq");
        }

        [Fact(Skip = "the query requires generating ~4.7 million solutions so is fundamentally unsolvable")]
        public void SparqlGraphExistsInteractionCore457_2()
        {
            try
            {
                Options.UsePLinqEvaluation = false;
                RunCore457("exists.rq");
            }
            finally
            {
                Options.UsePLinqEvaluation = true;
            }
        }

        [Fact]
        public void SparqlGraphExistsInteractionCore457_3()
        {
            RunCore457("exists2.rq");
        }

        [Fact]
        public void SparqlGraphExistsInteractionCore457_4()
        {
            RunCore457("exists3.rq");
        }

        [Fact(Skip = "the query requires generating ~4.7 million solutions so is fundamentally unsolvable")]
        public void SparqlGraphExistsInteractionCore457_5()
        {
            RunCore457("exists-limit.rq");
        }
    }
}
---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using Xunit;
using VDS.RDF;
using VDS.RDF.Parsing;
using VDS.RDF.Query;
using VDS.RDF.Query.Algebra;
using VDS.RDF.Query.Datasets;
using VDS.RDF.Query.Expressions;
using VDS.RDF.Query.Expressions.Functions;
using VDS.RDF.Query.Optimisation;
using VDS.RDF.Writing.Formatting;


namespace VDS.RDF.Query
{
    public class SparqlTests2
    {
        private ISparqlDataset AsDataset(IInMemoryQueryableStore store)
        {
            if (store.Graphs.Count == 1)
            {
                return new InMemoryDataset(store, store.Graphs.First().BaseUri);
            }
            else
            {
                return new InMemoryDataset(store);
            }
        }

        private IEnumerable<IAlgebraOptimiser> _algebraOptimisers;

        private void UseSpecificOptimiserOnly(IAlgebraOptimiser optimiser)
        {
            this._algebraOptimisers = SparqlOptimiser.AlgebraOptimisers.ToList();
            foreach (IAlgebraOptimiser opt in this._algebraOptimisers)
            {
                SparqlOptimiser.RemoveOptimiser(opt);
            }
            SparqlOptimiser.AddOptimiser(optimiser);
        }

        private void ResetOptimiser()
        {
            foreach (IAlgebraOptimiser opt in SparqlOptimiser.AlgebraOptimisers.ToList())
            {
                SparqlOptimiser.RemoveOptimiser(opt);
            }
            foreach (IAlgebraOptimiser opt in this._algebraOptimisers)
            {
                SparqlOptimiser.AddOptimiser(opt);
            }
        }

        [Fact]
        public void SparqlBind()
        {
            String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o . BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) }";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count > 0, "Expected 1 or more results");
            }
        }

        [Fact]
        public void SparqlBindLazy()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o . BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) } LIMIT 1";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet rset)
                {
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 1, "Expected exactly 1 results");
                    Assert.True(rset.All(r => r.HasValue("triple")), "All Results should have had a value for ?triple");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlBindLazy2()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT * WHERE { ?s ?p ?o . BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) } LIMIT 10";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet rset)
                {
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 10, "Expected exactly 10 results");
                    Assert.True(rset.All(r => r.HasValue("s") && r.HasValue("p") && r.HasValue("o") && r.HasValue("triple")), "Expected ?s, ?p, ?o and ?triple values for every result");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlBindLazy3()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());
                String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT * WHERE { ?s ?p ?o . BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) } LIMIT 10 OFFSET 10";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet rset)
                {
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 10, "Expected exactly 10 results");
                    Assert.True(rset.All(r => r.HasValue("s") && r.HasValue("p") && r.HasValue("o") && r.HasValue("triple")), "Expected ?s, ?p, ?o and ?triple values for every result");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        //[Fact]
        //public void SparqlBindNested()
        //{
        //    String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o .{ BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) } FILTER(BOUND(?triple))}";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count == 0, "Expected no results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        [Fact]
        public void SparqlBindIn10Standard()
        {
            String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o . BIND(fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o)) AS ?triple) }";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser(SparqlQuerySyntax.Sparql_1_0);
            Assert.Throws<RdfParseException>(() =>
            {
                SparqlQuery q = parser.ParseFromString(query);
            });
        }

        [Fact]
        public void SparqlBindToExistingVariable()
        {
            String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT * WHERE { ?s ?p ?o . BIND(?s AS ?p) }";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            Assert.Throws<RdfParseException>(() => { SparqlQuery q = parser.ParseFromString(query); });
        }

        [Fact]
        public void SparqlBindToExistingVariableLazy()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT * WHERE { ?s ?p ?o . BIND(?s AS ?p) } LIMIT 1";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                Assert.Throws<RdfParseException>(() => { SparqlQuery q = parser.ParseFromString(query); });
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlBindScope1()
        {
            String query = @"PREFIX : <http://www.example.org>
 SELECT *
 WHERE {
    {
    :s :p ?o .
    :s :q ?o1 .
    }
    BIND((1+?o) AS ?o1)
 }";

            SparqlQueryParser parser = new SparqlQueryParser();

            Assert.Throws<RdfParseException>(() => parser.ParseFromString(query));
        }

        [Fact]
        public void SparqlBindScope2()
        {
            String query = @"PREFIX : <http://www.example.org>
 SELECT *
 WHERE {
    :s :p ?o .
    { BIND((1 + ?o) AS ?o1) } UNION { BIND((2 + ?o) AS ?o1) }
 }";

            SparqlQueryParser parser = new SparqlQueryParser();
            parser.ParseFromString(query);
        }

        [Fact]
        public void SparqlBindScope3()
        {
            String query = @" PREFIX : <http://www.example.org>
 SELECT *
 WHERE {
    :s :p ?o .
    :s :q ?o1
    { BIND((1+?o) AS ?o1) }
 }";

            SparqlQueryParser parser = new SparqlQueryParser();
            parser.ParseFromString(query);
        }

        [Fact]
        public void SparqlBindScope4()
        {
            String query = @" PREFIX : <http://www.example.org>
 SELECT *
 WHERE {
    { 
    :s :p ?o .
    :s :q ?o1
    }
    { BIND((1+?o) AS ?o1) }
 }";

            SparqlQueryParser parser = new SparqlQueryParser();
            parser.ParseFromString(query);
        }

        [Fact]
        public void SparqlBindScope5()
        {
            String query = @"PREFIX : <http://example.org>
SELECT *
WHERE
{
  GRAPH ?g { :s :p ?o }
  BIND (?g AS ?in)
}";

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToString());

            ISparqlAlgebra algebra = q.ToAlgebra();
            Console.WriteLine(algebra.ToString());
            Assert.IsAssignableFrom<Select>(algebra);

            algebra = ((IUnaryOperator)algebra).InnerAlgebra;
            Assert.IsAssignableFrom<Extend>(algebra);
        }

        [Fact]
        public void SparqlBindScope6()
        {
            String query = @"PREFIX : <http://example.org>
SELECT *
WHERE
{
  {
    GRAPH ?g { :s :p ?o }
    BIND (?g AS ?in)
  }
  UNION
  {
    :s :p ?o .
    BIND('default' AS ?in)
  }
}";

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToString());

            ISparqlAlgebra algebra = q.ToAlgebra();
            Console.WriteLine(algebra.ToString());
            Assert.IsAssignableFrom<Select>(algebra);

            algebra = ((IUnaryOperator)algebra).InnerAlgebra;
            Assert.IsAssignableFrom<Union>(algebra);

            IUnion union = (Union)algebra;
            ISparqlAlgebra lhs = union.Lhs;
            Assert.IsAssignableFrom<Extend>(lhs);

            ISparqlAlgebra rhs = union.Rhs;
            Assert.IsAssignableFrom<Join>(rhs);
        }

        [Fact]
        public void SparqlLet()
        {
            String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o . LET (?triple := fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o))) }";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser(SparqlQuerySyntax.Extended);
            SparqlQuery q = parser.ParseFromString(query);

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count > 0, "Expected 1 or more results");
            }
        }

        [Fact]
        public void SparqlLetIn11Standard()
        {
            String query = "PREFIX fn: <" + XPathFunctionFactory.XPathFunctionsNamespace + "> SELECT ?triple WHERE { ?s ?p ?o . LET (?triple := fn:concat(STR(?s), ' ', STR(?p), ' ', STR(?o))) }";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser(SparqlQuerySyntax.Sparql_1_1);
            Assert.Throws<RdfParseException>(() =>
            {
                SparqlQuery q = parser.ParseFromString(query);
            });
        }

        //[Fact]
        //public void SparqlSubQueryLazy()
        //{
        //    String query = "SELECT * WHERE { {SELECT * WHERE { ?s ?p ?o}}} LIMIT 1";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Console.WriteLine(q.ToAlgebra().ToString());
        //    Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
        //    Console.WriteLine();

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count == 1, "Expected exactly 1 results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        //[Fact]
        //public void SparqlSubQueryLazy2()
        //{
        //    String query = "SELECT * WHERE { {SELECT * WHERE { ?s ?p ?o}}} LIMIT 10";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Console.WriteLine(q.ToAlgebra().ToString());
        //    Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
        //    Console.WriteLine();

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count == 10, "Expected exactly 10 results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        //[Fact]
        //public void SparqlSubQueryLazy3()
        //{
        //    String query = "SELECT * WHERE { {SELECT * WHERE { ?s ?p ?o}}} LIMIT 10 OFFSET 10";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Console.WriteLine(q.ToAlgebra().ToString());
        //    Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
        //    Console.WriteLine();

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count == 10, "Expected exactly 10 results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        //[Fact]
        //public void SparqlSubQueryLazyComplex()
        //{
        //    String query = "SELECT * WHERE { ?s a <http://example.org/vehicles/Car> . {SELECT * WHERE { ?s <http://example.org/vehicles/Speed> ?speed}}} LIMIT 1";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Console.WriteLine(q.ToAlgebra().ToString());
        //    Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
        //    Console.WriteLine();

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count == 1, "Expected exactly 1 results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        //[Fact]
        //public void SparqlSubQueryLazyComplex2()
        //{
        //    String query = "SELECT * WHERE { ?s a <http://example.org/vehicles/Car> . {SELECT * WHERE { ?s <http://example.org/vehicles/Speed> ?speed}}} LIMIT 5";

        //    TripleStore store = new TripleStore();
        //    Graph g = new Graph();
        //    FileLoader.Load(g, "resources\\InferenceTest.ttl");
        //    store.Add(g);

        //    SparqlQueryParser parser = new SparqlQueryParser();
        //    SparqlQuery q = parser.ParseFromString(query);

        //    Console.WriteLine(q.ToAlgebra().ToString());
        //    Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
        //    Console.WriteLine();

        //    Object results = q.Evaluate(store);
        //    if (results is SparqlResultSet)
        //    {
        //        SparqlResultSet rset = (SparqlResultSet)results;
        //        foreach (SparqlResult r in rset)
        //        {
        //            Console.WriteLine(r.ToString());
        //        }
        //        Assert.True(rset.Count <= 5, "Expected at most 5 results");
        //    }
        //    else
        //    {
        //        Assert.True(false, "Expected a SPARQL Result Set");
        //    }
        //}

        [Fact]
        public void SparqlOrderBySubjectLazyAscending()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ?s LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderBySubjectLazyAscendingExplicit()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ASC(?s) LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderBySubjectLazyDescending()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY DESC(?s) LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderByPredicateLazyAscending()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ?p LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderByPredicateLazyAscendingExplicit()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ASC(?p) LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderByPredicateLazyDescending()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY DESC(?p) LIMIT 1";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 1, "Expected exactly 1 results");
            }
        }

        [Fact]
        public void SparqlOrderByComplexLazy()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ?s DESC(?p) LIMIT 5";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 5, "Expected exactly 5 results");
            }
        }

        [Fact]
        [Trait("Coverage", "Skip")]
        public void SparqlOrderByComplexLazyPerformance()
        {
            String query = "SELECT * WHERE { ?s ?p ?o . } ORDER BY ?s DESC(?p) LIMIT 5";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\dataset_50.ttl.gz");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();

            //First do with Optimisation
            Stopwatch timer = new Stopwatch();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            timer.Start();
            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            timer.Stop();
            Console.WriteLine("Took " + timer.Elapsed + " to execute when Optimised");
            timer.Reset();
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 5, "Expected exactly 5 results");
            }

            //Then do without optimisation
            Options.AlgebraOptimisation = false;
            timer.Start();
            results = processor.ProcessQuery(q);
            timer.Stop();
            Console.WriteLine("Took " + timer.Elapsed + " to execute when Unoptimised");
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.True(rset.Count == 5, "Expected exactly 5 results");
            }
            Options.AlgebraOptimisation = true;
        }

        [Fact]
        public void SparqlOrderByComplexLazy2()
        {
            String query = "SELECT * WHERE { ?s a ?vehicle . ?s <http://example.org/vehicles/Speed> ?speed } ORDER BY DESC(?speed) LIMIT 3";

            TripleStore store = new TripleStore();
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            store.Add(g);

            SparqlQueryParser parser = new SparqlQueryParser();
            SparqlQuery q = parser.ParseFromString(query);

            Console.WriteLine(q.ToAlgebra().ToString());
            Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
            Console.WriteLine();

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
            Object results = processor.ProcessQuery(q);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet rset)
            {
                foreach (SparqlResult r in rset)
                {
                    Console.WriteLine(r.ToString());
                }
                Assert.Equal(3, rset.Count);
            }
        }

        [Fact]
        public void SparqlFilterLazy()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                String query = "SELECT * WHERE { ?s a ?vehicle . FILTER (SAMETERM(?vehicle, <http://example.org/vehicles/Car>)) } LIMIT 3";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet rset)
                {
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 3, "Expected exactly 3 results");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlFilterLazy2()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());
                String query = "SELECT * WHERE { ?s a ?vehicle . FILTER (SAMETERM(?vehicle, <http://example.org/Vehicles/Car>)) } LIMIT 3";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine("NOTE: The URI for Car is purposefully wrong in this case so no results should be returned");
                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet rset)
                {
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 0, "Expected no results");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlFilterLazy3()
        {
            long currTimeout = Options.QueryExecutionTimeout;
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());
                Options.QueryExecutionTimeout = 0;

                String query = "SELECT * WHERE { ?s a ?vehicle . FILTER (SAMETERM(?vehicle, <http://example.org/vehicles/Car>)) . ?s <http://example.org/vehicles/Speed> ?speed } LIMIT 3";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);
                q.Timeout = 0;

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet rset)
                {
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 3, "Expected exactly 3 results");
                }
            }
            finally
            {
                this.ResetOptimiser();
                Options.QueryExecutionTimeout = currTimeout;
            }
        }

        [Fact]
        public void SparqlFilterLazy4()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());
                String query = "SELECT * WHERE { ?s a <http://example.org/vehicles/Car> ; <http://example.org/vehicles/Speed> ?speed } LIMIT 3";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet rset)
                {
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 3, "Expected exactly 3 results");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [SkippableFact]
        public void SparqlFilterLazyDBPedia()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseRemoteParsing),
                "Test Config marks Remote Parsing as unavailable, test cannot be run");

            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                SparqlParameterizedString query = new SparqlParameterizedString();
                query.Namespaces.AddNamespace("rdfs", new Uri(NamespaceMapper.RDFS));
                query.CommandText = "SELECT * WHERE {?s ?p ?label . FILTER(ISLITERAL(?label) && LANGMATCHES(LANG(?label), \"en\")) } LIMIT 5";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                UriLoader.Load(g, new Uri("http://dbpedia.org/resource/Southampton"));
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet rset)
                {
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 5, "Expected exactly 5 results");
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlLazyWithAndWithoutOffset()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                String query = "SELECT * WHERE { ?s a ?vehicle . FILTER (SAMETERM(?vehicle, <http://example.org/vehicles/Car>)) } LIMIT 3";
                String query2 = "SELECT * WHERE { ?s a ?vehicle . FILTER (SAMETERM(?vehicle, <http://example.org/vehicles/Car>)) } LIMIT 3 OFFSET 3";

                TripleStore store = new TripleStore();
                Graph g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");
                store.Add(g);

                SparqlQueryParser parser = new SparqlQueryParser();
                SparqlQuery q = parser.ParseFromString(query);
                SparqlQuery q2 = parser.ParseFromString(query2);

                Console.WriteLine(q.ToAlgebra().ToString());
                Assert.True(q.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                Console.WriteLine(q2.ToAlgebra().ToString());
                Assert.True(q2.ToAlgebra().ToString().Contains("LazyBgp"), "Should have been optimised to use a Lazy BGP");
                Console.WriteLine();

                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(AsDataset(store));
                Object results = processor.ProcessQuery(q);
                Assert.IsAssignableFrom<SparqlResultSet>(results);
                if (results is SparqlResultSet rset)
                {
                    foreach (SparqlResult r in rset)
                    {
                        Console.WriteLine(r.ToString());
                    }
                    Assert.True(rset.Count == 3, "Expected exactly 3 results");

                    Object results2 = processor.ProcessQuery(q2);
                    Assert.IsAssignableFrom<SparqlResultSet>(results2);
                    if (results2 is SparqlResultSet rset2)
                    {
                        foreach (SparqlResult r in rset2)
                        {
                            Console.WriteLine(r.ToString());
                        }
                        Assert.True(rset2.Count == 1, "Expected exactly 1 results");
                    }
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlLazyLimitSimple1()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                const string query = @"PREFIX eg:
<http://example.org/vehicles/> PREFIX rdf:
<http://www.w3.org/1999/02/22-rdf-syntax-ns#> SELECT ?car ?speed WHERE
{ ?car rdf:type eg:Car . ?car eg:Speed ?speed } LIMIT 1";

                var g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");

                var parser = new SparqlQueryParser();
                var q = parser.ParseFromString(query);
                var results = g.ExecuteQuery(q);
                Assert.True(results is SparqlResultSet, "Expected a SPARQL results set");
                var rset = results as SparqlResultSet;
                foreach (var r in rset)
                {
                    Console.WriteLine(r);
                    Assert.Equal(2, r.Count);
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlLazyLimitSimple2()
        {
            try
            {
                this.UseSpecificOptimiserOnly(new LazyBgpOptimiser());

                const string query = @"PREFIX eg:
<http://example.org/vehicles/> PREFIX rdf:
<http://www.w3.org/1999/02/22-rdf-syntax-ns#> SELECT ?car ?speed WHERE
{ ?car rdf:type eg:Car . ?car eg:Speed ?speed } LIMIT 20";

                var g = new Graph();
                FileLoader.Load(g, "resources\\InferenceTest.ttl");

                var parser = new SparqlQueryParser();
                var q = parser.ParseFromString(query);
                var results = g.ExecuteQuery(q);
                Assert.True(results is SparqlResultSet, "Expected a SPARQL results set");
                var rset = results as SparqlResultSet;
                foreach (var r in rset)
                {
                    Console.WriteLine(r);
                    Assert.Equal(2, r.Count);
                }
            }
            finally
            {
                this.ResetOptimiser();
            }
        }

        [Fact]
        public void SparqlNestedOptionalCore406()
        {
            IGraph g = new Graph();
            g.LoadFromFile(@"resources\core-406.ttl");

            SparqlQuery query = new SparqlQueryParser().ParseFromFile(@"resources\core-406.rq");

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(new InMemoryDataset(g));
            SparqlResultSet results = processor.ProcessQuery(query) as SparqlResultSet;
            Assert.NotNull(results);

            TestTools.ShowResults(results);

            foreach (SparqlResult result in results)
            {
                Assert.True(result.HasBoundValue("first"), "Row " + result + " failed to contain ?first binding");
            }
        }

        [Fact]
        [Trait("Coverage", "Skip")]
        public void SparqlSubQueryGraphInteractionCore416_Serial()
        {
            try
            {
                Options.UsePLinqEvaluation = false;

                TripleStore store = new TripleStore();
                store.LoadFromFile(@"resources\core-416.trig");

                SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-416.rq");
                //SparqlFormatter formatter = new SparqlFormatter();
                //Console.WriteLine(formatter.Format(q));

                ISparqlDataset dataset = AsDataset(store);

                //ExplainQueryProcessor processor = new ExplainQueryProcessor(dataset, ExplanationLevel.OutputToConsoleStdOut | ExplanationLevel.ShowAll | ExplanationLevel.AnalyseNamedGraphs);
                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
                TimeSpan total = new TimeSpan();
                const int totalRuns = 1000;
                for (int i = 0; i < totalRuns; i++)
                {
                    Console.WriteLine("Starting query run " + i + " of " + totalRuns);
                    SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
                    Assert.NotNull(results);

                    if (q.QueryExecutionTime != null)
                    {
                        Console.WriteLine("Execution Time: " + q.QueryExecutionTime.Value);
                        total = total + q.QueryExecutionTime.Value;
                    }
                    if (results.Count != 4) TestTools.ShowResults(results);
                    Assert.Equal(4, results.Count);
                }

                Console.WriteLine("Total Execution Time: " + total);
                Assert.True(total < new TimeSpan(0, 0, 1 * (totalRuns / 10)));
            }
            finally
            {
                Options.UsePLinqEvaluation = true;
            }
        }

        [Fact]
        [Trait("Coverage", "Skip")]
        public void SparqlSubQueryGraphInteractionCore416_Parallel()
        {
            try
            {
                Options.UsePLinqEvaluation = true;

                TripleStore store = new TripleStore();
                store.LoadFromFile(@"resources\core-416.trig");

                SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-416.rq");
                Console.WriteLine(q.ToAlgebra().ToString());
                //SparqlFormatter formatter = new SparqlFormatter();
                //Console.WriteLine(formatter.Format(q));

                ISparqlDataset dataset = AsDataset(store);

                //ExplainQueryProcessor processor = new ExplainQueryProcessor(dataset, ExplanationLevel.OutputToConsoleStdOut | ExplanationLevel.ShowAll | ExplanationLevel.AnalyseNamedGraphs);
                LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
                TimeSpan total = new TimeSpan();
                const int totalRuns = 1000;
                for (int i = 0; i < totalRuns; i++)
                {
                    Console.WriteLine("Starting query run " + i + " of " + totalRuns);
                    SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
                    Assert.NotNull(results);

                    if (q.QueryExecutionTime != null)
                    {
                        Console.WriteLine("Execution Time: " + q.QueryExecutionTime.Value);
                        total = total + q.QueryExecutionTime.Value;
                    }
                    if (results.Count != 4) TestTools.ShowResults(results);
                    Assert.Equal(4, results.Count);
                }

                Console.WriteLine("Total Execution Time: " + total);
                Assert.True(total < new TimeSpan(0, 0, 1 * (totalRuns / 10)));
            }
            finally
            {
                Options.UsePLinqEvaluation = true;
            }
        }

        [Fact]
        public void SparqlInfiniteLoopCore439_01()
        {
            TripleStore store = new TripleStore();
            store.LoadFromFile(@"resources\core-439\data.trig");

            SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-439\bad-query.rq");
            //q.Timeout = 10000;
            Console.WriteLine(q.ToAlgebra().ToString());

            ISparqlDataset dataset = AsDataset(store);

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
            SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;

            Assert.NotNull(results);

            Assert.Equal(10, results.Count);
        }

        [Fact]
        public void SparqlInfiniteLoopCore439_02()
        {
            TripleStore store = new TripleStore();
            store.LoadFromFile(@"resources\core-439\data.trig");

            SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-439\good-query.rq");
            //q.Timeout = 3000;
            Console.WriteLine(q.ToAlgebra().ToString());

            ISparqlDataset dataset = AsDataset(store);

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
            SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
            Assert.NotNull(results);

            Assert.Equal(10, results.Count);
        }

        [Fact]
        public void SparqlInfiniteLoopCore439_03()
        {
            TripleStore store = new TripleStore();
            store.LoadFromFile(@"resources\core-439\data.trig");

            SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-439\from-query.rq");
            //q.Timeout = 3000;
            Console.WriteLine(q.ToAlgebra().ToString());

            ISparqlDataset dataset = AsDataset(store);

            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
            SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
            Assert.NotNull(results);

            Assert.Equal(10, results.Count);
        }

        [Fact]
        public void SparqlSubQueryOrderByLimitInteractionCore437()
        {
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            InMemoryDataset dataset = new InMemoryDataset(g);

            SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-437.rq");
            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
            SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
            Assert.NotNull(results);

            TestTools.ShowResults(results);
        }

        private void RunCore457(String query)
        {
            TripleStore store = new TripleStore();
            store.LoadFromFile(@"resources\core-457\data.nq");
            InMemoryDataset dataset = new InMemoryDataset(store);

            SparqlQuery q = new SparqlQueryParser().ParseFromFile(@"resources\core-457\" + query);
            q.Timeout = 15000;
            LeviathanQueryProcessor processor = new LeviathanQueryProcessor(dataset);
            SparqlResultSet results = processor.ProcessQuery(q) as SparqlResultSet;
            Assert.NotNull(results);
            Assert.True(q.QueryExecutionTime.HasValue);
            Console.WriteLine(q.QueryExecutionTime.Value);

            //TestTools.ShowResults(results);
        }

        [Fact(Skip = "the query requires generating ~4.7 million solutions so is fundamentally unsolvable")]
        public void SparqlGraphOptionalInteractionCore457_1()
        {
            RunCore457("optional.rq");
        }


        [Fact(Skip = "the query requires generating ~4.7 million solutions so is fundamentally unsolvable")]
        public void SparqlGraphOptionalInteractionCore457_2()
        {
            try
            {
                Options.UsePLinqEvaluation = false;
                RunCore457("optional.rq");
            }
            finally
            {
                Options.UsePLinqEvaluation = true;
            }
        }

        [Fact]
        public void SparqlGraphOptionalInteractionCore457_3()
        {
            RunCore457("optional2.rq");
        }

        [Fact(Skip = "the query requires generating ~4.7 million solutions so is fundamentally unsolvable")]
        public void SparqlGraphExistsInteractionCore457_1()
        {
            RunCore457("exists.rq");
        }

        [Fact(Skip = "the query requires generating ~4.7 million solutions so is fundamentally unsolvable")]
        public void SparqlGraphExistsInteractionCore457_2()
        {
            try
            {
                Options.UsePLinqEvaluation = false;
                RunCore457("exists.rq");
            }
            finally
            {
                Options.UsePLinqEvaluation = true;
            }
        }

        [Fact]
        public void SparqlGraphExistsInteractionCore457_3()
        {
            RunCore457("exists2.rq");
        }

        [Fact]
        public void SparqlGraphExistsInteractionCore457_4()
        {
            RunCore457("exists3.rq");
        }

        [Fact(Skip = "the query requires generating ~4.7 million solutions so is fundamentally unsolvable")]
        public void SparqlGraphExistsInteractionCore457_5()
        {
            RunCore457("exists-limit.rq");
        }
    }
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(31,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(39,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(33,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(30,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(35,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(41,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(900,44): error CS0128: A local variable or function named 'rset' is already defined in this scope,D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(902,44): error CS0165: Use of unassigned local variable 'rset',D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(31,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(39,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(33,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(30,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(35,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Query\SparqlTests2.cs(41,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 15 - TypeCheckAndCastRewriterR5
Filepath: D:\a\1\s\Testing\unittest\Storage\SesameTests.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.IO;
using System.Linq;
using System.Text;
using Xunit;
using VDS.RDF.Parsing;
using VDS.RDF.Query;

namespace VDS.RDF.Storage
{

    public class SesameTests : IDisposable
    {
        public static SesameHttpProtocolConnector GetConnection()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseSesame), "Test Config marks Sesame as unavailable, cannot run test");
            return new SesameHttpProtocolConnector(TestConfigManager.GetSetting(TestConfigManager.SesameServer), TestConfigManager.GetSetting(TestConfigManager.SesameRepository));
        }

        public SesameTests()
        {
            Options.HttpDebugging = true;
            Options.UriLoaderCaching = false;
        }

        public void Dispose()
        {
            Options.HttpDebugging = false;
            Options.UriLoaderCaching = true;
        }

        [SkippableFact]
        public void StorageSesameSaveLoad()
        {
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            g.BaseUri = new Uri("http://example.org/SesameTest");

            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            sesame.SaveGraph(g);

            //Options.HttpDebugging = true;
            //Options.HttpFullDebugging = true;

            Graph h = new Graph();
            sesame.LoadGraph(h, "http://example.org/SesameTest");
            Assert.False(h.IsEmpty, "Graph should not be empty after loading");

            Assert.Equal(g, h);
        }

        [SkippableFact]
        public void StorageSesameSaveEmptyGraph1()
        {
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/Sesame/empty");

            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            sesame.SaveGraph(g);

            Graph h = new Graph();
            sesame.LoadGraph(h, "http://example.org/Sesame/empty");
            Assert.True(h.IsEmpty, "Graph should be empty after loading");

            Assert.Equal(g, h);
        }

        [SkippableFact]
        public void StorageSesameSaveEmptyGraph2()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Uri graphUri = new Uri("http://example.org/Sesame/empty2");
            Console.WriteLine("Deleting any existing graph");
            sesame.DeleteGraph(graphUri);
            Console.WriteLine("Existing graph deleted");

            // First create a non-empty graph
            Graph g = new Graph();
            g.BaseUri = graphUri;
            g.Assert(g.CreateBlankNode(), g.CreateUriNode("rdf:type"), g.CreateUriNode(new Uri("http://example.org/BNode")));
            Console.WriteLine("Saving non-empty graph");
            sesame.SaveGraph(g);
            Console.WriteLine("Non-empty graph saved");

            Graph h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.False(h.IsEmpty, "Graph should not be empty after loading");

            Assert.Equal(g, h);

            // Now attempt to save an empty graph as well
            g = new Graph();
            g.BaseUri = graphUri;
            Console.WriteLine("Attempting to save empty graph with same name");
            sesame.SaveGraph(g);
            Console.WriteLine("Empty graph saved");

            h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.True(h.IsEmpty, "Graph should be empty after loading");

            Assert.Equal(g, h);
        }

        [SkippableFact]
        public void StorageSesameSaveEmptyGraph3()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Uri graphUri = null;
            Console.WriteLine("Deleting any existing graph");
            sesame.DeleteGraph(graphUri);
            Console.WriteLine("Existing graph deleted");

            // First create a non-empty graph
            Graph g = new Graph();
            g.BaseUri = graphUri;
            g.Assert(g.CreateBlankNode(), g.CreateUriNode("rdf:type"), g.CreateUriNode(new Uri("http://example.org/BNode")));
            Console.WriteLine("Saving non-empty graph");
            sesame.SaveGraph(g);
            Console.WriteLine("Non-empty graph saved");

            Graph h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.False(h.IsEmpty, "Graph should not be empty after loading");

            Assert.Equal(g, h);

            // Now attempt to overwrite with an empty graph
            g = new Graph();
            g.BaseUri = graphUri;
            Console.WriteLine("Attempting to save empty graph with same name");
            sesame.SaveGraph(g);
            Console.WriteLine("Empty graph saved");

            h = new Graph();
            sesame.LoadGraph(h, graphUri);

            // Since saving to default graph does not overwrite the graph we've just retrieved must contain the empty graph as a sub-graph
            Assert.True(h.HasSubGraph(g));
        }

        [SkippableFact]
        public void StorageSesameDeleteTriples1()
        {
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            g.BaseUri = new Uri("http://example.org/SesameTest");

            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            sesame.SaveGraph(g);

            Console.WriteLine("Graph before deletion");
            TestTools.ShowGraph(g);

            //Delete all Triples about the Ford Fiesta
            sesame.UpdateGraph(g.BaseUri, null, g.GetTriplesWithSubject(new Uri("http://example.org/vehicles/FordFiesta")));

            Object results = sesame.Query("ASK WHERE { GRAPH <http://example.org/SesameTest> { <http://example.org/vehicles/FordFiesta> ?p ?o } }");
            if (results is SparqlResultSet)
            {
                Assert.False(((SparqlResultSet) results).Result, "There should no longer be any triples about the Ford Fiesta present");
            }

            Graph h = new Graph();
            sesame.LoadGraph(h, g.BaseUri);

            Console.WriteLine("Graph after deletion");
            TestTools.ShowGraph(h);

            Assert.False(h.IsEmpty, "Graph should not be completely empty");
            Assert.True(g.HasSubGraph(h), "Graph retrieved with missing Triples should be a sub-graph of the original Graph");
            Assert.False(g.Equals(h), "Graph retrieved should not be equal to original Graph");
        }

        [SkippableFact]
        public void StorageSesameDeleteTriples2()
        {
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/SesameTest/Delete2");
            g.NamespaceMap.AddNamespace("ex", new Uri("http://example.org/ns#"));
            g.Assert(g.CreateUriNode("ex:subj"), g.CreateUriNode("ex:pred"), g.CreateUriNode("ex:obj"));

            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            sesame.SaveGraph(g);

            Console.WriteLine("Graph before deletion");
            TestTools.ShowGraph(g);

            //Delete the single triple
            sesame.UpdateGraph(g.BaseUri, null, g.Triples);

            Object results = sesame.Query("ASK WHERE { GRAPH <http://example.org/SesameTest/Delete2> { <http://example.org/ns#subj> ?p ?o } }");
            if (results is SparqlResultSet)
            {
                Assert.False(((SparqlResultSet) results).Result, "There should no longer be any triples present in the graph");
            }

            Graph h = new Graph();
            sesame.LoadGraph(h, g.BaseUri);

            Console.WriteLine("Graph after deletion");
            TestTools.ShowGraph(h);

            Assert.True(h.IsEmpty, "Graph should not be completely empty");
            Assert.False(g.Equals(h), "Graph retrieved should not be equal to original Graph");
        }

        [SkippableFact]
        public void StorageSesameDeleteTriples3()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/sesame/chinese");
            FileLoader.Load(g, @"..\\resources\chinese.ttl");
            sesame.SaveGraph(g);

            String ask = "ASK WHERE { GRAPH <http://example.org/sesame/chinese> { ?s ?p '例子' } }";

            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.True(((SparqlResultSet) results).Result);
            }

            // Now delete the triple in question
            sesame.UpdateGraph(g.BaseUri, null, g.Triples);

            // Re-issue ASK to check deletion
            results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.False(((SparqlResultSet) results).Result);
            }
        }

        [SkippableFact]
        public void StorageSesameDeleteGraph1()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Uri graphUri = new Uri("http://example.org/Sesame/delete");

            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            g.BaseUri = graphUri;

            sesame.SaveGraph(g);

            Graph h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.False(h.IsEmpty, "Graph should not be empty after loading");

            Assert.Equal(g, h);

            sesame.DeleteGraph(graphUri);
            h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.True(h.IsEmpty, "Graph should be equal after deletion");
            Assert.NotEqual(g, h);
        }

        [SkippableFact]
        public void StorageSesameDeleteGraph2()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Uri graphUri = null;
            sesame.DeleteGraph(graphUri);

            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            g.BaseUri = graphUri;

            sesame.SaveGraph(g);

            Graph h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.False(h.IsEmpty, "Graph should not be empty after loading");

            Assert.Equal(g, h);

            sesame.DeleteGraph(graphUri);
            h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.True(h.IsEmpty, "Graph should be equal after deletion");
            Assert.NotEqual(g, h);
        }

        [SkippableFact]
        public void StorageSesameCyrillic()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/sesame/cyrillic");
            FileLoader.Load(g, @"..\\resources\cyrillic.rdf");
            sesame.SaveGraph(g);

            String ask = "ASK WHERE { GRAPH <http://example.org/sesame/cyrillic> { ?s ?p 'литерал' } }";

            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.True(((SparqlResultSet) results).Result);
            }
        }

        [SkippableFact]
        public void StorageSesameChinese()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/sesame/chinese");
            FileLoader.Load(g, @"..\\resources\chinese.ttl");
            sesame.SaveGraph(g);

            String ask = "ASK WHERE { GRAPH <http://example.org/sesame/chinese> { ?s ?p '例子' } }";

            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.True(((SparqlResultSet) results).Result);
            }
        }

        [SkippableFact]
        public void StorageSesameAsk()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();

            String ask = "ASK WHERE { ?s ?p ?o }";

            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                TestTools.ShowResults(results);
            }
        }

        [SkippableFact]
        public void StorageSesameDescribe()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();

            String describe = "DESCRIBE <http://example.org/vehicles/FordFiesta>";

            Object results = sesame.Query(describe);
            Assert.IsAssignableFrom<IGraph>(results);
            if (results is IGraph)
            {
                TestTools.ShowGraph((IGraph) results);
            }
        }

        [SkippableFact]
        public void StorageSesameSparqlUpdate1()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseRemoteParsing), "Test Config marks Remote Parsing as unavailable, test cannot be run");

            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            sesame.Update(@"DROP GRAPH <http://example.org/sparqlUpdateLoad>;
LOAD <http://dbpedia.org/resource/Ilkeston> INTO GRAPH <http://example.org/sparqlUpdateLoad>;
DELETE WHERE 
{ 
  GRAPH <http://example.org/sparqlUpdateLoad> 
  { ?s <http://www.w3.org/2003/01/geo/wgs84_pos#long> ?long ; <http://www.w3.org/2003/01/geo/wgs84_pos#lat> ?lat }
}");

            Graph orig = new Graph();
            orig.LoadFromUri(new Uri("http://dbpedia.org/resource/Ilkeston"));
            orig.Retract(orig.GetTriplesWithPredicate(new Uri("http://www.w3.org/2003/01/geo/wgs84_pos#long")).ToList());
            orig.Retract(orig.GetTriplesWithPredicate(new Uri("http://www.w3.org/2003/01/geo/wgs84_pos#lat")).ToList());

            Graph actual = new Graph();
            sesame.LoadGraph(actual, "http://example.org/sparqlUpdateLoad");

            GraphDiffReport diff = orig.Difference(actual);
            if (!diff.AreEqual)
            {
                TestTools.ShowDifferences(diff);
            }

            Assert.Equal(orig, actual);
        }

        [SkippableFact]
        public void StorageSesameSparqlUpdate2()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            g.BaseUri = new Uri("http://example.org/sparqlUpdateDeleteWhere");
            sesame.SaveGraph(g);

            sesame.Update("WITH <http://example.org/sparqlUpdateDeleteWhere> DELETE { ?s a ?type } WHERE { ?s a ?type }");

            Graph h = new Graph();
            sesame.LoadGraph(h, "http://example.org/sparqlUpdateDeleteWhere");
            INode rdfType = h.CreateUriNode("rdf:type");
            Assert.False(h.GetTriplesWithPredicate(rdfType).Any(), "Should not be any rdf:type triples after SPARQL Update operation");
        }

        [SkippableFact]
        public void StorageSesameSparqlUpdate3()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();

            // Ensure required graph is present
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/sesame/chinese");
            FileLoader.Load(g, @"..\\resources\chinese.ttl");
            sesame.SaveGraph(g);

            String ask = "ASK WHERE { GRAPH <http://example.org/sesame/chinese> { ?s ?p '例子' } }";

            // Issue query to validate data was added
            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.True(((SparqlResultSet) results).Result);
            }

            // Issue a DELETE for the Chinese literal
            String update = "DELETE WHERE { GRAPH <http://example.org/sesame/chinese> { ?s ?p '例子' } }";
            sesame.Update(update);

            // Re-issue query to validate triple was deleted
            results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.False(((SparqlResultSet) results).Result);
            }
        }

        [SkippableFact]
        public void StorageSesameSparqlUpdate4()
        {
            // Test case adapted from CORE-374 sample update
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();

            // Insert the Data
            StringBuilder updates = new StringBuilder();
            using (StreamReader reader = File.OpenText(@"..\\resources\core-374.ru"))
            {
                updates.Append(reader.ReadToEnd());
                reader.Close();
            }
            sesame.Update(updates.ToString());

            String ask = "ASK WHERE { GRAPH <http://example.org/sesame/core-374> { ?s ?p 'République du Niger'@fr } }";

            // Issue query to validate data was added
            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.True(((SparqlResultSet) results).Result);
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.IO;
using System.Linq;
using System.Text;
using Xunit;
using VDS.RDF.Parsing;
using VDS.RDF.Query;

namespace VDS.RDF.Storage
{

    public class SesameTests : IDisposable
    {
        public static SesameHttpProtocolConnector GetConnection()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseSesame), "Test Config marks Sesame as unavailable, cannot run test");
            return new SesameHttpProtocolConnector(TestConfigManager.GetSetting(TestConfigManager.SesameServer), TestConfigManager.GetSetting(TestConfigManager.SesameRepository));
        }

        public SesameTests()
        {
            Options.HttpDebugging = true;
            Options.UriLoaderCaching = false;
        }

        public void Dispose()
        {
            Options.HttpDebugging = false;
            Options.UriLoaderCaching = true;
        }

        [SkippableFact]
        public void StorageSesameSaveLoad()
        {
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            g.BaseUri = new Uri("http://example.org/SesameTest");

            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            sesame.SaveGraph(g);

            //Options.HttpDebugging = true;
            //Options.HttpFullDebugging = true;

            Graph h = new Graph();
            sesame.LoadGraph(h, "http://example.org/SesameTest");
            Assert.False(h.IsEmpty, "Graph should not be empty after loading");

            Assert.Equal(g, h);
        }

        [SkippableFact]
        public void StorageSesameSaveEmptyGraph1()
        {
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/Sesame/empty");

            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            sesame.SaveGraph(g);

            Graph h = new Graph();
            sesame.LoadGraph(h, "http://example.org/Sesame/empty");
            Assert.True(h.IsEmpty, "Graph should be empty after loading");

            Assert.Equal(g, h);
        }

        [SkippableFact]
        public void StorageSesameSaveEmptyGraph2()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Uri graphUri = new Uri("http://example.org/Sesame/empty2");
            Console.WriteLine("Deleting any existing graph");
            sesame.DeleteGraph(graphUri);
            Console.WriteLine("Existing graph deleted");

            // First create a non-empty graph
            Graph g = new Graph();
            g.BaseUri = graphUri;
            g.Assert(g.CreateBlankNode(), g.CreateUriNode("rdf:type"), g.CreateUriNode(new Uri("http://example.org/BNode")));
            Console.WriteLine("Saving non-empty graph");
            sesame.SaveGraph(g);
            Console.WriteLine("Non-empty graph saved");

            Graph h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.False(h.IsEmpty, "Graph should not be empty after loading");

            Assert.Equal(g, h);

            // Now attempt to save an empty graph as well
            g = new Graph();
            g.BaseUri = graphUri;
            Console.WriteLine("Attempting to save empty graph with same name");
            sesame.SaveGraph(g);
            Console.WriteLine("Empty graph saved");

            h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.True(h.IsEmpty, "Graph should be empty after loading");

            Assert.Equal(g, h);
        }

        [SkippableFact]
        public void StorageSesameSaveEmptyGraph3()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Uri graphUri = null;
            Console.WriteLine("Deleting any existing graph");
            sesame.DeleteGraph(graphUri);
            Console.WriteLine("Existing graph deleted");

            // First create a non-empty graph
            Graph g = new Graph();
            g.BaseUri = graphUri;
            g.Assert(g.CreateBlankNode(), g.CreateUriNode("rdf:type"), g.CreateUriNode(new Uri("http://example.org/BNode")));
            Console.WriteLine("Saving non-empty graph");
            sesame.SaveGraph(g);
            Console.WriteLine("Non-empty graph saved");

            Graph h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.False(h.IsEmpty, "Graph should not be empty after loading");

            Assert.Equal(g, h);

            // Now attempt to overwrite with an empty graph
            g = new Graph();
            g.BaseUri = graphUri;
            Console.WriteLine("Attempting to save empty graph with same name");
            sesame.SaveGraph(g);
            Console.WriteLine("Empty graph saved");

            h = new Graph();
            sesame.LoadGraph(h, graphUri);

            // Since saving to default graph does not overwrite the graph we've just retrieved must contain the empty graph as a sub-graph
            Assert.True(h.HasSubGraph(g));
        }

        [SkippableFact]
        public void StorageSesameDeleteTriples1()
        {
            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            g.BaseUri = new Uri("http://example.org/SesameTest");

            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            sesame.SaveGraph(g);

            Console.WriteLine("Graph before deletion");
            TestTools.ShowGraph(g);

            //Delete all Triples about the Ford Fiesta
            sesame.UpdateGraph(g.BaseUri, null, g.GetTriplesWithSubject(new Uri("http://example.org/vehicles/FordFiesta")));

            Object results = sesame.Query("ASK WHERE { GRAPH <http://example.org/SesameTest> { <http://example.org/vehicles/FordFiesta> ?p ?o } }");
            if (results is SparqlResultSet sparqlResultSet)
            {
                Assert.False(sparqlResultSet.Result, "There should no longer be any triples about the Ford Fiesta present");
            }

            Graph h = new Graph();
            sesame.LoadGraph(h, g.BaseUri);

            Console.WriteLine("Graph after deletion");
            TestTools.ShowGraph(h);

            Assert.False(h.IsEmpty, "Graph should not be completely empty");
            Assert.True(g.HasSubGraph(h), "Graph retrieved with missing Triples should be a sub-graph of the original Graph");
            Assert.False(g.Equals(h), "Graph retrieved should not be equal to original Graph");
        }

        [SkippableFact]
        public void StorageSesameDeleteTriples2()
        {
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/SesameTest/Delete2");
            g.NamespaceMap.AddNamespace("ex", new Uri("http://example.org/ns#"));
            g.Assert(g.CreateUriNode("ex:subj"), g.CreateUriNode("ex:pred"), g.CreateUriNode("ex:obj"));

            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            sesame.SaveGraph(g);

            Console.WriteLine("Graph before deletion");
            TestTools.ShowGraph(g);

            //Delete the single triple
            sesame.UpdateGraph(g.BaseUri, null, g.Triples);

            Object results = sesame.Query("ASK WHERE { GRAPH <http://example.org/SesameTest/Delete2> { <http://example.org/ns#subj> ?p ?o } }");
            if (results is SparqlResultSet sparqlResultSet)
            {
                Assert.False(sparqlResultSet.Result, "There should no longer be any triples present in the graph");
            }

            Graph h = new Graph();
            sesame.LoadGraph(h, g.BaseUri);

            Console.WriteLine("Graph after deletion");
            TestTools.ShowGraph(h);

            Assert.True(h.IsEmpty, "Graph should not be completely empty");
            Assert.False(g.Equals(h), "Graph retrieved should not be equal to original Graph");
        }

        [SkippableFact]
        public void StorageSesameDeleteTriples3()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/sesame/chinese");
            FileLoader.Load(g, @"..\\resources\chinese.ttl");
            sesame.SaveGraph(g);

            String ask = "ASK WHERE { GRAPH <http://example.org/sesame/chinese> { ?s ?p '例子' } }";

            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet sparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.True(sparqlResultSet.Result);
            }

            // Now delete the triple in question
            sesame.UpdateGraph(g.BaseUri, null, g.Triples);

            // Re-issue ASK to check deletion
            results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet sparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.False(sparqlResultSet.Result);
            }
        }

        [SkippableFact]
        public void StorageSesameDeleteGraph1()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Uri graphUri = new Uri("http://example.org/Sesame/delete");

            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            g.BaseUri = graphUri;

            sesame.SaveGraph(g);

            Graph h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.False(h.IsEmpty, "Graph should not be empty after loading");

            Assert.Equal(g, h);

            sesame.DeleteGraph(graphUri);
            h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.True(h.IsEmpty, "Graph should be equal after deletion");
            Assert.NotEqual(g, h);
        }

        [SkippableFact]
        public void StorageSesameDeleteGraph2()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Uri graphUri = null;
            sesame.DeleteGraph(graphUri);

            Graph g = new Graph();
            FileLoader.Load(g, "resources\\InferenceTest.ttl");
            g.BaseUri = graphUri;

            sesame.SaveGraph(g);

            Graph h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.False(h.IsEmpty, "Graph should not be empty after loading");

            Assert.Equal(g, h);

            sesame.DeleteGraph(graphUri);
            h = new Graph();
            sesame.LoadGraph(h, graphUri);
            Assert.True(h.IsEmpty, "Graph should be equal after deletion");
            Assert.NotEqual(g, h);
        }

        [SkippableFact]
        public void StorageSesameCyrillic()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/sesame/cyrillic");
            FileLoader.Load(g, @"..\\resources\cyrillic.rdf");
            sesame.SaveGraph(g);

            String ask = "ASK WHERE { GRAPH <http://example.org/sesame/cyrillic> { ?s ?p 'литерал' } }";

            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet sparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.True(sparqlResultSet.Result);
            }
        }

        [SkippableFact]
        public void StorageSesameChinese()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/sesame/chinese");
            FileLoader.Load(g, @"..\\resources\chinese.ttl");
            sesame.SaveGraph(g);

            String ask = "ASK WHERE { GRAPH <http://example.org/sesame/chinese> { ?s ?p '例子' } }";

            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet sparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.True(sparqlResultSet.Result);
            }
        }

        [SkippableFact]
        public void StorageSesameAsk()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();

            String ask = "ASK WHERE { ?s ?p ?o }";

            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet)
            {
                TestTools.ShowResults(results);
            }
        }

        [SkippableFact]
        public void StorageSesameDescribe()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();

            String describe = "DESCRIBE <http://example.org/vehicles/FordFiesta>";

            Object results = sesame.Query(describe);
            Assert.IsAssignableFrom<IGraph>(results);
            if (results is IGraph iGraph)
            {
                TestTools.ShowGraph(iGraph);
            }
        }

        [SkippableFact]
        public void StorageSesameSparqlUpdate1()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseRemoteParsing), "Test Config marks Remote Parsing as unavailable, test cannot be run");

            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            sesame.Update(@"DROP GRAPH <http://example.org/sparqlUpdateLoad>;
LOAD <http://dbpedia.org/resource/Ilkeston> INTO GRAPH <http://example.org/sparqlUpdateLoad>;
DELETE WHERE 
{ 
  GRAPH <http://example.org/sparqlUpdateLoad> 
  { ?s <http://www.w3.org/2003/01/geo/wgs84_pos#long> ?long ; <http://www.w3.org/2003/01/geo/wgs84_pos#lat> ?lat }
}");

            Graph orig = new Graph();
            orig.LoadFromUri(new Uri("http://dbpedia.org/resource/Ilkeston"));
            orig.Retract(orig.GetTriplesWithPredicate(new Uri("http://www.w3.org/2003/01/geo/wgs84_pos#long")).ToList());
            orig.Retract(orig.GetTriplesWithPredicate(new Uri("http://www.w3.org/2003/01/geo/wgs84_pos#lat")).ToList());

            Graph actual = new Graph();
            sesame.LoadGraph(actual, "http://example.org/sparqlUpdateLoad");

            GraphDiffReport diff = orig.Difference(actual);
            if (!diff.AreEqual)
            {
                TestTools.ShowDifferences(diff);
            }

            Assert.Equal(orig, actual);
        }

        [SkippableFact]
        public void StorageSesameSparqlUpdate2()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            g.BaseUri = new Uri("http://example.org/sparqlUpdateDeleteWhere");
            sesame.SaveGraph(g);

            sesame.Update("WITH <http://example.org/sparqlUpdateDeleteWhere> DELETE { ?s a ?type } WHERE { ?s a ?type }");

            Graph h = new Graph();
            sesame.LoadGraph(h, "http://example.org/sparqlUpdateDeleteWhere");
            INode rdfType = h.CreateUriNode("rdf:type");
            Assert.False(h.GetTriplesWithPredicate(rdfType).Any(), "Should not be any rdf:type triples after SPARQL Update operation");
        }

        [SkippableFact]
        public void StorageSesameSparqlUpdate3()
        {
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();

            // Ensure required graph is present
            Graph g = new Graph();
            g.BaseUri = new Uri("http://example.org/sesame/chinese");
            FileLoader.Load(g, @"..\\resources\chinese.ttl");
            sesame.SaveGraph(g);

            String ask = "ASK WHERE { GRAPH <http://example.org/sesame/chinese> { ?s ?p '例子' } }";

            // Issue query to validate data was added
            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet sparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.True(sparqlResultSet.Result);
            }

            // Issue a DELETE for the Chinese literal
            String update = "DELETE WHERE { GRAPH <http://example.org/sesame/chinese> { ?s ?p '例子' } }";
            sesame.Update(update);

            // Re-issue query to validate triple was deleted
            results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet sparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.False(sparqlResultSet.Result);
            }
        }

        [SkippableFact]
        public void StorageSesameSparqlUpdate4()
        {
            // Test case adapted from CORE-374 sample update
            SesameHttpProtocolConnector sesame = SesameTests.GetConnection();

            // Insert the Data
            StringBuilder updates = new StringBuilder();
            using (StreamReader reader = File.OpenText(@"..\\resources\core-374.ru"))
            {
                updates.Append(reader.ReadToEnd());
                reader.Close();
            }
            sesame.Update(updates.ToString());

            String ask = "ASK WHERE { GRAPH <http://example.org/sesame/core-374> { ?s ?p 'République du Niger'@fr } }";

            // Issue query to validate data was added
            Object results = sesame.Query(ask);
            Assert.IsAssignableFrom<SparqlResultSet>(results);
            if (results is SparqlResultSet sparqlResultSet)
            {
                TestTools.ShowResults(results);
                Assert.True(sparqlResultSet.Result);
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Testing\unittest\Storage\SesameTests.cs(258,44): error CS0128: A local variable or function named 'sparqlResultSet' is already defined in this scope,D:\a\1\s\Testing\unittest\Storage\SesameTests.cs(261,30): error CS0165: Use of unassigned local variable 'sparqlResultSet',D:\a\1\s\Testing\unittest\Storage\SesameTests.cs(463,44): error CS0128: A local variable or function named 'sparqlResultSet' is already defined in this scope,D:\a\1\s\Testing\unittest\Storage\SesameTests.cs(466,30): error CS0165: Use of unassigned local variable 'sparqlResultSet'
######################################################################


######################################################################
Nr: 16 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Testing\unittest\Storage\StardogTests.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Xunit;
using VDS.RDF.Parsing;
using VDS.RDF.Query;
using VDS.RDF.Storage;
using VDS.RDF.Storage.Management;
using VDS.RDF.Storage.Management.Provisioning;
using VDS.RDF.Update;
using VDS.RDF.Writing.Formatting;

namespace VDS.RDF.Storage
{

    public class StardogTests
        : GenericUpdateProcessorTests, IDisposable
    {
        public static StardogConnector GetConnection()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseStardog), "Test Config marks Stardog as unavailable, test cannot be run");
            return new StardogConnector(TestConfigManager.GetSetting(TestConfigManager.StardogServer),
                TestConfigManager.GetSetting(TestConfigManager.StardogDatabase),
                TestConfigManager.GetSetting(TestConfigManager.StardogUser),
                TestConfigManager.GetSetting(TestConfigManager.StardogPassword));
        }

        public static StardogServer GetServer()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseStardog), "Test Config marks Stardog as unavailable, test cannot be run");
            return new StardogServer(TestConfigManager.GetSetting(TestConfigManager.StardogServer),
                TestConfigManager.GetSetting(TestConfigManager.StardogUser),
                TestConfigManager.GetSetting(TestConfigManager.StardogPassword));
        }

        public StardogTests()
        {
            Options.HttpDebugging = true;
        }

        protected override IStorageProvider GetManager()
        {
            return (IStorageProvider) StardogTests.GetConnection();
        }

        // Many of these tests require a synchronous API
        [SkippableFact]
        public void StorageStardogLoadDefaultGraph()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            g.BaseUri = null;
            stardog.SaveGraph(g);

            Graph h = new Graph();
            stardog.LoadGraph(h, (Uri) null);

            NTriplesFormatter formatter = new NTriplesFormatter();
            foreach (Triple t in h.Triples)
            {
                Console.WriteLine(t.ToString(formatter));
            }

            Assert.False(h.IsEmpty);
        }

        [SkippableFact]
        public void StorageStardogLoadNamedGraph()
        {
            StardogConnector stardog = StardogTests.GetConnection();

            // Ensure graph exists
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            g.BaseUri = new Uri("http://example.org/graph");
            stardog.SaveGraph(g);

            // Load it back from the store
            Graph h = new Graph();
            stardog.LoadGraph(h, new Uri("http://example.org/graph"));

            NTriplesFormatter formatter = new NTriplesFormatter();
            foreach (Triple t in h.Triples)
            {
                Console.WriteLine(t.ToString(formatter));
            }

            Assert.False(h.IsEmpty);
            Assert.Equal(g, h);
        }

        [SkippableFact]
        public void StorageStardogSaveToDefaultGraph()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            g.BaseUri = null;
            stardog.SaveGraph(g);

            Graph h = new Graph();
            stardog.LoadGraph(h, (Uri) null);
            Console.WriteLine("Retrieved " + h.Triples.Count + " Triple(s) from Stardog");

            if (g.Triples.Count == h.Triples.Count)
            {
                Assert.Equal(g, h);
            }
            else
            {
                Assert.True(h.HasSubGraph(g), "Retrieved Graph should have the Saved Graph as a subgraph");
            }
        }

        [SkippableFact]
        public void StorageStardogSaveToNamedGraph()
        {
            try
            {
                //Options.UseBomForUtf8 = false;

                StardogConnector stardog = StardogTests.GetConnection();
                
                Graph g = new Graph();
                g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
                g.BaseUri = new Uri("http://example.org/graph");
                stardog.SaveGraph(g);

                Graph h = new Graph();
                stardog.LoadGraph(h, new Uri("http://example.org/graph"));

                Assert.Equal(g, h);
            }
            finally
            {
                //Options.UseBomForUtf8 = true;
            }
        }

        [SkippableFact]
        public void StorageStardogSaveToNamedGraph2()
        {
            try
            {
                //Options.UseBomForUtf8 = false;

                StardogConnector stardog = StardogTests.GetConnection();
                
                Graph g = new Graph();
                g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
                Uri u = new Uri("http://example.org/graph/" + DateTime.Now.Ticks);
                g.BaseUri = u;
                stardog.SaveGraph(g);

                Graph h = new Graph();
                stardog.LoadGraph(h, u);

                Assert.Equal(g, h);
            }
            finally
            {
                //Options.UseBomForUtf8 = true;
            }
        }

        [SkippableFact]
        public void StorageStardogSaveToNamedGraphOverwrite()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            g.BaseUri = new Uri("http://example.org/namedGraph");
            stardog.SaveGraph(g);

            Graph h = new Graph();
            stardog.LoadGraph(h, new Uri("http://example.org/namedGraph"));

            Assert.Equal(g, h);

            Graph i = new Graph();
            i.LoadFromEmbeddedResource("VDS.RDF.Query.Expressions.LeviathanFunctionLibrary.ttl");
            i.BaseUri = new Uri("http://example.org/namedGraph");
            stardog.SaveGraph(i);

            Graph j = new Graph();
            stardog.LoadGraph(j, "http://example.org/namedGraph");

            Assert.NotEqual(g, j);
            Assert.Equal(i, j);
        }

        [SkippableFact]
        public void StorageStardogUpdateNamedGraphRemoveTriples()
        {
            try
            {
                //Options.UseBomForUtf8 = false;

                StardogConnector stardog = StardogTests.GetConnection();
                
                Graph g = new Graph();
                g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
                g.BaseUri = new Uri("http://example.org/graph");
                stardog.SaveGraph(g);

                INode rdfType = g.CreateUriNode(new Uri(VDS.RDF.Parsing.RdfSpecsHelper.RdfType));

                stardog.UpdateGraph(g.BaseUri, null, g.GetTriplesWithPredicate(rdfType));
                g.Retract(g.GetTriplesWithPredicate(rdfType).ToList());

                Graph h = new Graph();
                stardog.LoadGraph(h, new Uri("http://example.org/graph"));

                if (g.Triples.Count == h.Triples.Count)
                {
                    Assert.Equal(g, h);
                }
                else
                {
                    Assert.True(h.HasSubGraph(g), "Retrieved Graph should have the Saved Graph as a subgraph");
                }
                Assert.False(h.GetTriplesWithPredicate(rdfType).Any(),
                    "Retrieved Graph should not contain any rdf:type Triples");
            }
            finally
            {
                //Options.UseBomForUtf8 = true;
            }
        }

        [SkippableFact]
        public void StorageStardogUpdateNamedGraphAddTriples()
        {
            try
            {
                //Options.UseBomForUtf8 = false;

                StardogConnector stardog = StardogTests.GetConnection();
                
                Graph g = new Graph();
                g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
                g.BaseUri = new Uri("http://example.org/addGraph");

                INode rdfType = g.CreateUriNode(new Uri(VDS.RDF.Parsing.RdfSpecsHelper.RdfType));
                Graph types = new Graph();
                types.Assert(g.GetTriplesWithPredicate(rdfType));
                g.Retract(g.GetTriplesWithPredicate(rdfType).ToList());

                //Save the Graph without the rdf:type triples
                stardog.SaveGraph(g);
                //Then add back in the rdf:type triples
                stardog.UpdateGraph(g.BaseUri, types.Triples, null);

                Graph h = new Graph();
                stardog.LoadGraph(h, new Uri("http://example.org/addGraph"));

                if (g.Triples.Count == h.Triples.Count)
                {
                    Assert.Equal(g, h);
                }
                else
                {
                    Assert.True(h.HasSubGraph(g), "Retrieved Graph should have the Saved Graph as a subgraph");
                }
                Assert.True(h.GetTriplesWithPredicate(rdfType).Any(),
                    "Retrieved Graph should not contain any rdf:type Triples");
            }
            finally
            {
                //Options.UseBomForUtf8 = true;
            }
        }

        [SkippableFact]
        public void StorageStardogDeleteNamedGraph()
        {
            try
            {
                //Options.UseBomForUtf8 = false;

                StardogConnector stardog = StardogTests.GetConnection();
                
                Graph g = new Graph();
                g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
                g.BaseUri = new Uri("http://example.org/tempGraph");
                stardog.SaveGraph(g);

                Graph h = new Graph();
                stardog.LoadGraph(h, new Uri("http://example.org/tempGraph"));

                if (g.Triples.Count == h.Triples.Count)
                {
                    Assert.Equal(g, h);
                }
                else
                {
                    Assert.True(h.HasSubGraph(g), "Retrieved Graph should have the Saved Graph as a subgraph");
                }

                stardog.DeleteGraph("http://example.org/tempGraph");
                Graph i = new Graph();
                stardog.LoadGraph(i, new Uri("http://example.org/tempGraph"));

                Assert.True(i.IsEmpty, "Retrieved Graph should be empty since it has been deleted");
            }
            finally
            {
                //Options.UseBomForUtf8 = true;
            }
        }

        [SkippableFact]
        public void StorageStardogReasoningQL()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            Skip.If(stardog.Reasoning == StardogReasoningMode.DatabaseControlled, 
                    "Version of Stardog being tested does not support configuring reasoning mode at connection level");

            Graph g = new Graph();
            g.LoadFromFile("resources\\InferenceTest.ttl");
            g.BaseUri = new Uri("http://example.org/reasoning");
            stardog.SaveGraph(g);

            String query = "PREFIX rdfs: <" + NamespaceMapper.RDFS +
                           "> SELECT * WHERE { { ?class rdfs:subClassOf <http://example.org/vehicles/Vehicle> } UNION { GRAPH <http://example.org/reasoning> { ?class rdfs:subClassOf <http://example.org/vehicles/Vehicle> } } }";
            Console.WriteLine(query);
            Console.WriteLine();

            SparqlResultSet resultsNoReasoning = stardog.Query(query) as SparqlResultSet;
            Assert.NotNull(resultsNoReasoning);
            if (resultsNoReasoning != null)
            {
                Console.WriteLine("Results without Reasoning");
                TestTools.ShowResults(resultsNoReasoning);
            }

            stardog.Reasoning = StardogReasoningMode.QL;
            SparqlResultSet resultsWithReasoning = stardog.Query(query) as SparqlResultSet;
            if (resultsWithReasoning != null)
            {
                Console.WriteLine("Results with Reasoning");
                TestTools.ShowResults(resultsWithReasoning);
            }
            else
            {
                Assert.True(false, "Did not get a SPARQL Result Set as expected");
            }

            Assert.True(resultsWithReasoning.Count >= resultsNoReasoning.Count,
                "Reasoning should yield as many if not more results");
        }


        [SkippableFact]
        public void StorageStardogReasoningByQuery1()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            Skip.If(stardog.Reasoning == StardogReasoningMode.DatabaseControlled, 
                    "Version of Stardog being tested does not support configuring reasoning mode at connection level");

            Graph g = new Graph();
            g.LoadFromFile("resources\\stardog-reasoning-test.rdf");
            g.BaseUri = new Uri("http://www.reasoningtest.com/");
            stardog.SaveGraph(g);

            String query = "Select ?building where { ?building <http://www.reasoningtest.com#hasLocation> ?room.}";

            Console.WriteLine(query);
            Console.WriteLine();

            SparqlResultSet resultsWithReasoning = stardog.Query(query, true) as SparqlResultSet;
            Assert.NotNull(resultsWithReasoning);
            if (resultsWithReasoning != null)
            {
                Console.WriteLine("Results With Reasoning");
                TestTools.ShowResults(resultsWithReasoning);
                Assert.True(true , "Reasoning By Query OK !");
            }
            else
            {
                Assert.True(false, "Did not get a SPARQL Result Set as expected");
            }

        }


        [SkippableFact]
        public void StorageStardogReasoningByQuery2()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            Skip.If(stardog.Reasoning == StardogReasoningMode.DatabaseControlled, 
                    "Version of Stardog being tested does not support configuring reasoning mode at connection level");

            Graph g = new Graph();
            g.LoadFromFile("resources\\stardog-reasoning-test.rdf");
            g.BaseUri = new Uri("http://www.reasoningtest.com/");
            stardog.SaveGraph(g);

            String query = "Select ?building where { ?building <http://www.reasoningtest.com#hasLocation> ?room.}"; 
            Console.WriteLine(query);
            Console.WriteLine();

            SparqlResultSet resultsWithNoReasoning = stardog.Query(query, false) as SparqlResultSet;
            Assert.Null(resultsWithNoReasoning);
            if (resultsWithNoReasoning != null )
            {
                Console.WriteLine("Results With No Reasoning");
                Assert.True(false, "There should not be any reasoning results !");
            }
            else
            {
                Assert.True(true, "No SPARQL Results returned ! Success.");
            }

        }


        [SkippableFact]
        public void StorageStardogReasoningMode()
        {
            StardogConnector connector = StardogTests.GetConnection();

            if (connector.Reasoning != StardogReasoningMode.DatabaseControlled)
            {
                return;
            }
            else
            {
                Assert.Throws<RdfStorageException>(() =>
                    connector.Reasoning = StardogReasoningMode.DL
                    );
            }
        }

        [SkippableFact]
        public void StorageStardogTransactionTest()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            
            stardog.Begin();
            stardog.Commit();
            stardog.Dispose();
        }

        [SkippableFact]
        public void StorageStardogAmpersandsInDataTest()
        {
            StardogConnector stardog = StardogTests.GetConnection();

            //Save the Graph
            Graph g = new Graph();
            const string fragment = "@prefix : <http://example.org/> . [] :string \"This has & ampersands in it\" .";
            g.LoadFromString(fragment);
            g.BaseUri = new Uri("http://example.org/ampersandGraph");

            Console.WriteLine("Original Graph:");
            TestTools.ShowGraph(g);

            stardog.SaveGraph(g);

            //Retrieve and check it round trips
            Graph h = new Graph();
            stardog.LoadGraph(h, g.BaseUri);

            Console.WriteLine("Graph as retrieved from Stardog:");
            TestTools.ShowGraph(h);

            Assert.Equal(g, h);

            //Now try to delete the data from this Graph
            GenericUpdateProcessor processor = new GenericUpdateProcessor(stardog);
            SparqlUpdateParser parser = new SparqlUpdateParser();
            processor.ProcessCommandSet(
                parser.ParseFromString("DELETE WHERE { GRAPH <http://example.org/ampersandGraph> { ?s ?p ?o } }"));

            Graph i = new Graph();
            stardog.LoadGraph(i, g.BaseUri);

            Console.WriteLine("Graph as retrieved after the DELETE WHERE:");
            TestTools.ShowGraph(i);

            Assert.NotEqual(g, i);
            Assert.NotEqual(h, i);
        }

        [SkippableFact]
        public void StorageStardogCreateNewStore()
        {
            Guid guid;
            do
            {
                guid = Guid.NewGuid();
            } while (guid.Equals(Guid.Empty) || !Char.IsLetter(guid.ToString()[0]));

            StardogServer stardog = StardogTests.GetServer();
            IStoreTemplate template = stardog.GetDefaultTemplate(guid.ToString());
            Console.WriteLine("Template ID " + template.ID);

            stardog.CreateStore(template);

            stardog.Dispose();
        }

        [SkippableFact]
        public void StorageStardogSparqlUpdate1()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            IGraph g;

            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/1");
            if (!g.IsEmpty)
            {
                Console.WriteLine("Dropping graph");
                stardog.Update("DROP SILENT GRAPH <http://example.org/stardog/update/1>");
                Console.WriteLine("Dropped graph");
                Thread.Sleep(2500);
                g = new Graph();
                stardog.LoadGraph(g, "http://example.org/stardog/update/1");
                Assert.True(g.IsEmpty, "Graph should be empty after DROP command");
            }

            Console.WriteLine("Inserting data");
            stardog.Update(
                "INSERT DATA { GRAPH <http://example.org/stardog/update/1> { <http://x> <http://y> <http://z> } }");
            Console.WriteLine("Inserted data");
            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/1");
            Assert.False(g.IsEmpty, "Graph should not be empty");
            Assert.Equal(1, g.Triples.Count);
        }

        [SkippableFact]
        public void StorageStardogSparqlUpdate2()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            IGraph g;

            Console.WriteLine("Dropping graph");
            stardog.Update("DROP SILENT GRAPH <http://example.org/stardog/update/2>");
            Console.WriteLine("Dropped graph");
            Thread.Sleep(2500);
            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/2");
            Assert.True(g.IsEmpty, "Graph should be empty after DROP command");

            Console.WriteLine("Inserting data");
            stardog.Update(
                "INSERT DATA { GRAPH <http://example.org/stardog/update/2> { <http://x> <http://y> <http://z> } }");
            Console.WriteLine("Inserted data");
            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/2");
            Assert.False(g.IsEmpty, "Graph should not be empty");
            Assert.Equal(1, g.Triples.Count);
        }

        [SkippableFact]
        public void StorageStardogSparqlUpdate3()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            IGraph g;

            Console.WriteLine("Dropping graph");
            stardog.Update("DROP SILENT GRAPH <http://example.org/stardog/update/3>");
            Console.WriteLine("Dropped graph");
            Thread.Sleep(2500);
            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/3");
            Assert.True(g.IsEmpty, "Graph should be empty after DROP command");

            Console.WriteLine("Inserting data");
            IGraph newData = new Graph();
            newData.BaseUri = new Uri("http://example.org/stardog/update/3");
            newData.Assert(newData.CreateUriNode(new Uri("http://x")), newData.CreateUriNode(new Uri("http://y")),
                newData.CreateUriNode(new Uri("http://z")));
            stardog.SaveGraph(newData);
            Console.WriteLine("Inserted data");
            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/3");
            Assert.False(g.IsEmpty, "Graph should not be empty");
            Assert.Equal(1, g.Triples.Count);
        }

        [SkippableFact]
        public void StorageStardogSparqlUpdate4()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            IGraph g;

            // Begin a transaction
            stardog.Begin();

            // Try to make an update
            stardog.Update(
                "DROP SILENT GRAPH <http://example.org/stardog/update/4>; INSERT DATA { GRAPH <http://example.org/stardog/update/4> { <http://x> <http://y> <http://z> } }");

            // Commit the transaction
            stardog.Commit();

            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/4");
            Assert.False(g.IsEmpty, "Graph should not be empty after update");
            Assert.Equal(1, g.Triples.Count);

            stardog.Dispose();
        }

        [SkippableFact]
        public void StorageStardogSparqlUpdate5()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            IGraph g;

            // Begin a transaction
            stardog.Begin();

            // Try to make an update
            stardog.Update(
                "DROP SILENT GRAPH <http://example.org/stardog/update/5>; INSERT DATA { GRAPH <http://example.org/stardog/update/5> { <http://x> <http://y> <http://z> } }");

            // Rollback the transaction
            stardog.Rollback();

            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/5");
            Assert.False(g.IsEmpty, "Graph should not be empty after update");
            Assert.Equal(1, g.Triples.Count);

            stardog.Dispose();
        }

        [SkippableFact]
        public void StorageStardogIsReadyValidDb()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            Assert.True(stardog.IsReady);

            stardog.Dispose();
        }

        [SkippableFact]
        public void StorageStardogIsReadyInvalidDb()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseStardog), "Test Config marks Stardog as unavailable, test cannot be run");
            StardogConnector stardog =  new StardogConnector(TestConfigManager.GetSetting(TestConfigManager.StardogServer),
                "i_dont_exist",
                TestConfigManager.GetSetting(TestConfigManager.StardogUser),
                TestConfigManager.GetSetting(TestConfigManager.StardogPassword));
            Assert.False(stardog.IsReady);

            stardog.Dispose();
        }

        public void Dispose()
        {
            Options.HttpDebugging = false;
        }
    }
}
---- Transformed Tree ----
using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Xunit;
using VDS.RDF.Parsing;
using VDS.RDF.Query;
using VDS.RDF.Storage;
using VDS.RDF.Storage.Management;
using VDS.RDF.Storage.Management.Provisioning;
using VDS.RDF.Update;
using VDS.RDF.Writing.Formatting;

namespace VDS.RDF.Storage
{

    public class StardogTests
        : GenericUpdateProcessorTests, IDisposable
    {
        public static StardogConnector GetConnection()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseStardog), "Test Config marks Stardog as unavailable, test cannot be run");
            return new StardogConnector(TestConfigManager.GetSetting(TestConfigManager.StardogServer),
                TestConfigManager.GetSetting(TestConfigManager.StardogDatabase),
                TestConfigManager.GetSetting(TestConfigManager.StardogUser),
                TestConfigManager.GetSetting(TestConfigManager.StardogPassword));
        }

        public static StardogServer GetServer()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseStardog), "Test Config marks Stardog as unavailable, test cannot be run");
            return new StardogServer(TestConfigManager.GetSetting(TestConfigManager.StardogServer),
                TestConfigManager.GetSetting(TestConfigManager.StardogUser),
                TestConfigManager.GetSetting(TestConfigManager.StardogPassword));
        }

        public StardogTests()
        {
            Options.HttpDebugging = true;
        }

        protected override IStorageProvider GetManager()
        {
            return (IStorageProvider) StardogTests.GetConnection();
        }

        // Many of these tests require a synchronous API
        [SkippableFact]
        public void StorageStardogLoadDefaultGraph()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            g.BaseUri = null;
            stardog.SaveGraph(g);

            Graph h = new Graph();
            stardog.LoadGraph(h, (Uri) null);

            NTriplesFormatter formatter = new NTriplesFormatter();
            foreach (Triple t in h.Triples)
            {
                Console.WriteLine(t.ToString(formatter));
            }

            Assert.False(h.IsEmpty);
        }

        [SkippableFact]
        public void StorageStardogLoadNamedGraph()
        {
            StardogConnector stardog = StardogTests.GetConnection();

            // Ensure graph exists
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            g.BaseUri = new Uri("http://example.org/graph");
            stardog.SaveGraph(g);

            // Load it back from the store
            Graph h = new Graph();
            stardog.LoadGraph(h, new Uri("http://example.org/graph"));

            NTriplesFormatter formatter = new NTriplesFormatter();
            foreach (Triple t in h.Triples)
            {
                Console.WriteLine(t.ToString(formatter));
            }

            Assert.False(h.IsEmpty);
            Assert.Equal(g, h);
        }

        [SkippableFact]
        public void StorageStardogSaveToDefaultGraph()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            g.BaseUri = null;
            stardog.SaveGraph(g);

            Graph h = new Graph();
            stardog.LoadGraph(h, (Uri) null);
            Console.WriteLine("Retrieved " + h.Triples.Count + " Triple(s) from Stardog");

            if (g.Triples.Count == h.Triples.Count)
            {
                Assert.Equal(g, h);
            }
            else
            {
                Assert.True(h.HasSubGraph(g), "Retrieved Graph should have the Saved Graph as a subgraph");
            }
        }

        [SkippableFact]
        public void StorageStardogSaveToNamedGraph()
        {
            try
            {
                //Options.UseBomForUtf8 = false;

                StardogConnector stardog = StardogTests.GetConnection();
                
                Graph g = new Graph();
                g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
                g.BaseUri = new Uri("http://example.org/graph");
                stardog.SaveGraph(g);

                Graph h = new Graph();
                stardog.LoadGraph(h, new Uri("http://example.org/graph"));

                Assert.Equal(g, h);
            }
            finally
            {
                //Options.UseBomForUtf8 = true;
            }
        }

        [SkippableFact]
        public void StorageStardogSaveToNamedGraph2()
        {
            try
            {
                //Options.UseBomForUtf8 = false;

                StardogConnector stardog = StardogTests.GetConnection();
                
                Graph g = new Graph();
                g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
                Uri u = new Uri("http://example.org/graph/" + DateTime.Now.Ticks);
                g.BaseUri = u;
                stardog.SaveGraph(g);

                Graph h = new Graph();
                stardog.LoadGraph(h, u);

                Assert.Equal(g, h);
            }
            finally
            {
                //Options.UseBomForUtf8 = true;
            }
        }

        [SkippableFact]
        public void StorageStardogSaveToNamedGraphOverwrite()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            
            Graph g = new Graph();
            g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
            g.BaseUri = new Uri("http://example.org/namedGraph");
            stardog.SaveGraph(g);

            Graph h = new Graph();
            stardog.LoadGraph(h, new Uri("http://example.org/namedGraph"));

            Assert.Equal(g, h);

            Graph i = new Graph();
            i.LoadFromEmbeddedResource("VDS.RDF.Query.Expressions.LeviathanFunctionLibrary.ttl");
            i.BaseUri = new Uri("http://example.org/namedGraph");
            stardog.SaveGraph(i);

            Graph j = new Graph();
            stardog.LoadGraph(j, "http://example.org/namedGraph");

            Assert.NotEqual(g, j);
            Assert.Equal(i, j);
        }

        [SkippableFact]
        public void StorageStardogUpdateNamedGraphRemoveTriples()
        {
            try
            {
                //Options.UseBomForUtf8 = false;

                StardogConnector stardog = StardogTests.GetConnection();
                
                Graph g = new Graph();
                g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
                g.BaseUri = new Uri("http://example.org/graph");
                stardog.SaveGraph(g);

                INode rdfType = g.CreateUriNode(new Uri(VDS.RDF.Parsing.RdfSpecsHelper.RdfType));

                stardog.UpdateGraph(g.BaseUri, null, g.GetTriplesWithPredicate(rdfType));
                g.Retract(g.GetTriplesWithPredicate(rdfType).ToList());

                Graph h = new Graph();
                stardog.LoadGraph(h, new Uri("http://example.org/graph"));

                if (g.Triples.Count == h.Triples.Count)
                {
                    Assert.Equal(g, h);
                }
                else
                {
                    Assert.True(h.HasSubGraph(g), "Retrieved Graph should have the Saved Graph as a subgraph");
                }
                Assert.False(h.GetTriplesWithPredicate(rdfType).Any(),
                    "Retrieved Graph should not contain any rdf:type Triples");
            }
            finally
            {
                //Options.UseBomForUtf8 = true;
            }
        }

        [SkippableFact]
        public void StorageStardogUpdateNamedGraphAddTriples()
        {
            try
            {
                //Options.UseBomForUtf8 = false;

                StardogConnector stardog = StardogTests.GetConnection();
                
                Graph g = new Graph();
                g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
                g.BaseUri = new Uri("http://example.org/addGraph");

                INode rdfType = g.CreateUriNode(new Uri(VDS.RDF.Parsing.RdfSpecsHelper.RdfType));
                Graph types = new Graph();
                types.Assert(g.GetTriplesWithPredicate(rdfType));
                g.Retract(g.GetTriplesWithPredicate(rdfType).ToList());

                //Save the Graph without the rdf:type triples
                stardog.SaveGraph(g);
                //Then add back in the rdf:type triples
                stardog.UpdateGraph(g.BaseUri, types.Triples, null);

                Graph h = new Graph();
                stardog.LoadGraph(h, new Uri("http://example.org/addGraph"));

                if (g.Triples.Count == h.Triples.Count)
                {
                    Assert.Equal(g, h);
                }
                else
                {
                    Assert.True(h.HasSubGraph(g), "Retrieved Graph should have the Saved Graph as a subgraph");
                }
                Assert.True(h.GetTriplesWithPredicate(rdfType).Any(),
                    "Retrieved Graph should not contain any rdf:type Triples");
            }
            finally
            {
                //Options.UseBomForUtf8 = true;
            }
        }

        [SkippableFact]
        public void StorageStardogDeleteNamedGraph()
        {
            try
            {
                //Options.UseBomForUtf8 = false;

                StardogConnector stardog = StardogTests.GetConnection();
                
                Graph g = new Graph();
                g.LoadFromEmbeddedResource("VDS.RDF.Configuration.configuration.ttl");
                g.BaseUri = new Uri("http://example.org/tempGraph");
                stardog.SaveGraph(g);

                Graph h = new Graph();
                stardog.LoadGraph(h, new Uri("http://example.org/tempGraph"));

                if (g.Triples.Count == h.Triples.Count)
                {
                    Assert.Equal(g, h);
                }
                else
                {
                    Assert.True(h.HasSubGraph(g), "Retrieved Graph should have the Saved Graph as a subgraph");
                }

                stardog.DeleteGraph("http://example.org/tempGraph");
                Graph i = new Graph();
                stardog.LoadGraph(i, new Uri("http://example.org/tempGraph"));

                Assert.True(i.IsEmpty, "Retrieved Graph should be empty since it has been deleted");
            }
            finally
            {
                //Options.UseBomForUtf8 = true;
            }
        }

        [SkippableFact]
        public void StorageStardogReasoningQL()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            Skip.If(stardog.Reasoning == StardogReasoningMode.DatabaseControlled, 
                    "Version of Stardog being tested does not support configuring reasoning mode at connection level");

            Graph g = new Graph();
            g.LoadFromFile("resources\\InferenceTest.ttl");
            g.BaseUri = new Uri("http://example.org/reasoning");
            stardog.SaveGraph(g);

            String query = "PREFIX rdfs: <" + NamespaceMapper.RDFS +
                           "> SELECT * WHERE { { ?class rdfs:subClassOf <http://example.org/vehicles/Vehicle> } UNION { GRAPH <http://example.org/reasoning> { ?class rdfs:subClassOf <http://example.org/vehicles/Vehicle> } } }";
            Console.WriteLine(query);
            Console.WriteLine();

            SparqlResultSet resultsNoReasoning = stardog.Query(query) as SparqlResultSet;
            Assert.NotNull(resultsNoReasoning);
            if (resultsNoReasoning != null)
            {
                Console.WriteLine("Results without Reasoning");
                TestTools.ShowResults(resultsNoReasoning);
            }

            stardog.Reasoning = StardogReasoningMode.QL;

            if (stardog.Query(query) is SparqlResultSet resultsWithReasoning)
            {
                Console.WriteLine("Results with Reasoning");
                TestTools.ShowResults(resultsWithReasoning);
            }
            else
            {
                Assert.True(false, "Did not get a SPARQL Result Set as expected");
            }

            Assert.True(resultsWithReasoning.Count >= resultsNoReasoning.Count,
                "Reasoning should yield as many if not more results");
        }


        [SkippableFact]
        public void StorageStardogReasoningByQuery1()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            Skip.If(stardog.Reasoning == StardogReasoningMode.DatabaseControlled, 
                    "Version of Stardog being tested does not support configuring reasoning mode at connection level");

            Graph g = new Graph();
            g.LoadFromFile("resources\\stardog-reasoning-test.rdf");
            g.BaseUri = new Uri("http://www.reasoningtest.com/");
            stardog.SaveGraph(g);

            String query = "Select ?building where { ?building <http://www.reasoningtest.com#hasLocation> ?room.}";

            Console.WriteLine(query);
            Console.WriteLine();

            SparqlResultSet resultsWithReasoning = stardog.Query(query, true) as SparqlResultSet;
            Assert.NotNull(resultsWithReasoning);
            if (resultsWithReasoning != null)
            {
                Console.WriteLine("Results With Reasoning");
                TestTools.ShowResults(resultsWithReasoning);
                Assert.True(true , "Reasoning By Query OK !");
            }
            else
            {
                Assert.True(false, "Did not get a SPARQL Result Set as expected");
            }

        }


        [SkippableFact]
        public void StorageStardogReasoningByQuery2()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            Skip.If(stardog.Reasoning == StardogReasoningMode.DatabaseControlled, 
                    "Version of Stardog being tested does not support configuring reasoning mode at connection level");

            Graph g = new Graph();
            g.LoadFromFile("resources\\stardog-reasoning-test.rdf");
            g.BaseUri = new Uri("http://www.reasoningtest.com/");
            stardog.SaveGraph(g);

            String query = "Select ?building where { ?building <http://www.reasoningtest.com#hasLocation> ?room.}"; 
            Console.WriteLine(query);
            Console.WriteLine();

            SparqlResultSet resultsWithNoReasoning = stardog.Query(query, false) as SparqlResultSet;
            Assert.Null(resultsWithNoReasoning);
            if (resultsWithNoReasoning != null )
            {
                Console.WriteLine("Results With No Reasoning");
                Assert.True(false, "There should not be any reasoning results !");
            }
            else
            {
                Assert.True(true, "No SPARQL Results returned ! Success.");
            }

        }


        [SkippableFact]
        public void StorageStardogReasoningMode()
        {
            StardogConnector connector = StardogTests.GetConnection();

            if (connector.Reasoning != StardogReasoningMode.DatabaseControlled)
            {
                return;
            }
            else
            {
                Assert.Throws<RdfStorageException>(() =>
                    connector.Reasoning = StardogReasoningMode.DL
                    );
            }
        }

        [SkippableFact]
        public void StorageStardogTransactionTest()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            
            stardog.Begin();
            stardog.Commit();
            stardog.Dispose();
        }

        [SkippableFact]
        public void StorageStardogAmpersandsInDataTest()
        {
            StardogConnector stardog = StardogTests.GetConnection();

            //Save the Graph
            Graph g = new Graph();
            const string fragment = "@prefix : <http://example.org/> . [] :string \"This has & ampersands in it\" .";
            g.LoadFromString(fragment);
            g.BaseUri = new Uri("http://example.org/ampersandGraph");

            Console.WriteLine("Original Graph:");
            TestTools.ShowGraph(g);

            stardog.SaveGraph(g);

            //Retrieve and check it round trips
            Graph h = new Graph();
            stardog.LoadGraph(h, g.BaseUri);

            Console.WriteLine("Graph as retrieved from Stardog:");
            TestTools.ShowGraph(h);

            Assert.Equal(g, h);

            //Now try to delete the data from this Graph
            GenericUpdateProcessor processor = new GenericUpdateProcessor(stardog);
            SparqlUpdateParser parser = new SparqlUpdateParser();
            processor.ProcessCommandSet(
                parser.ParseFromString("DELETE WHERE { GRAPH <http://example.org/ampersandGraph> { ?s ?p ?o } }"));

            Graph i = new Graph();
            stardog.LoadGraph(i, g.BaseUri);

            Console.WriteLine("Graph as retrieved after the DELETE WHERE:");
            TestTools.ShowGraph(i);

            Assert.NotEqual(g, i);
            Assert.NotEqual(h, i);
        }

        [SkippableFact]
        public void StorageStardogCreateNewStore()
        {
            Guid guid;
            do
            {
                guid = Guid.NewGuid();
            } while (guid.Equals(Guid.Empty) || !Char.IsLetter(guid.ToString()[0]));

            StardogServer stardog = StardogTests.GetServer();
            IStoreTemplate template = stardog.GetDefaultTemplate(guid.ToString());
            Console.WriteLine("Template ID " + template.ID);

            stardog.CreateStore(template);

            stardog.Dispose();
        }

        [SkippableFact]
        public void StorageStardogSparqlUpdate1()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            IGraph g;

            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/1");
            if (!g.IsEmpty)
            {
                Console.WriteLine("Dropping graph");
                stardog.Update("DROP SILENT GRAPH <http://example.org/stardog/update/1>");
                Console.WriteLine("Dropped graph");
                Thread.Sleep(2500);
                g = new Graph();
                stardog.LoadGraph(g, "http://example.org/stardog/update/1");
                Assert.True(g.IsEmpty, "Graph should be empty after DROP command");
            }

            Console.WriteLine("Inserting data");
            stardog.Update(
                "INSERT DATA { GRAPH <http://example.org/stardog/update/1> { <http://x> <http://y> <http://z> } }");
            Console.WriteLine("Inserted data");
            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/1");
            Assert.False(g.IsEmpty, "Graph should not be empty");
            Assert.Equal(1, g.Triples.Count);
        }

        [SkippableFact]
        public void StorageStardogSparqlUpdate2()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            IGraph g;

            Console.WriteLine("Dropping graph");
            stardog.Update("DROP SILENT GRAPH <http://example.org/stardog/update/2>");
            Console.WriteLine("Dropped graph");
            Thread.Sleep(2500);
            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/2");
            Assert.True(g.IsEmpty, "Graph should be empty after DROP command");

            Console.WriteLine("Inserting data");
            stardog.Update(
                "INSERT DATA { GRAPH <http://example.org/stardog/update/2> { <http://x> <http://y> <http://z> } }");
            Console.WriteLine("Inserted data");
            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/2");
            Assert.False(g.IsEmpty, "Graph should not be empty");
            Assert.Equal(1, g.Triples.Count);
        }

        [SkippableFact]
        public void StorageStardogSparqlUpdate3()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            IGraph g;

            Console.WriteLine("Dropping graph");
            stardog.Update("DROP SILENT GRAPH <http://example.org/stardog/update/3>");
            Console.WriteLine("Dropped graph");
            Thread.Sleep(2500);
            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/3");
            Assert.True(g.IsEmpty, "Graph should be empty after DROP command");

            Console.WriteLine("Inserting data");
            IGraph newData = new Graph();
            newData.BaseUri = new Uri("http://example.org/stardog/update/3");
            newData.Assert(newData.CreateUriNode(new Uri("http://x")), newData.CreateUriNode(new Uri("http://y")),
                newData.CreateUriNode(new Uri("http://z")));
            stardog.SaveGraph(newData);
            Console.WriteLine("Inserted data");
            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/3");
            Assert.False(g.IsEmpty, "Graph should not be empty");
            Assert.Equal(1, g.Triples.Count);
        }

        [SkippableFact]
        public void StorageStardogSparqlUpdate4()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            IGraph g;

            // Begin a transaction
            stardog.Begin();

            // Try to make an update
            stardog.Update(
                "DROP SILENT GRAPH <http://example.org/stardog/update/4>; INSERT DATA { GRAPH <http://example.org/stardog/update/4> { <http://x> <http://y> <http://z> } }");

            // Commit the transaction
            stardog.Commit();

            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/4");
            Assert.False(g.IsEmpty, "Graph should not be empty after update");
            Assert.Equal(1, g.Triples.Count);

            stardog.Dispose();
        }

        [SkippableFact]
        public void StorageStardogSparqlUpdate5()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            IGraph g;

            // Begin a transaction
            stardog.Begin();

            // Try to make an update
            stardog.Update(
                "DROP SILENT GRAPH <http://example.org/stardog/update/5>; INSERT DATA { GRAPH <http://example.org/stardog/update/5> { <http://x> <http://y> <http://z> } }");

            // Rollback the transaction
            stardog.Rollback();

            g = new Graph();
            stardog.LoadGraph(g, "http://example.org/stardog/update/5");
            Assert.False(g.IsEmpty, "Graph should not be empty after update");
            Assert.Equal(1, g.Triples.Count);

            stardog.Dispose();
        }

        [SkippableFact]
        public void StorageStardogIsReadyValidDb()
        {
            StardogConnector stardog = StardogTests.GetConnection();
            Assert.True(stardog.IsReady);

            stardog.Dispose();
        }

        [SkippableFact]
        public void StorageStardogIsReadyInvalidDb()
        {
            Skip.IfNot(TestConfigManager.GetSettingAsBoolean(TestConfigManager.UseStardog), "Test Config marks Stardog as unavailable, test cannot be run");
            StardogConnector stardog =  new StardogConnector(TestConfigManager.GetSetting(TestConfigManager.StardogServer),
                "i_dont_exist",
                TestConfigManager.GetSetting(TestConfigManager.StardogUser),
                TestConfigManager.GetSetting(TestConfigManager.StardogPassword));
            Assert.False(stardog.IsReady);

            stardog.Dispose();
        }

        public void Dispose()
        {
            Options.HttpDebugging = false;
        }
    }
}
---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Testing\unittest\Storage\StardogTests.cs(34,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Storage\StardogTests.cs(28,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Storage\StardogTests.cs(27,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Testing\unittest\Storage\StardogTests.cs(379,25): error CS0165: Use of unassigned local variable 'resultsWithReasoning',D:\a\1\s\Testing\unittest\Storage\StardogTests.cs(27,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Storage\StardogTests.cs(34,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Testing\unittest\Storage\StardogTests.cs(28,1): hidden CS8019: Unnecessary using directive.
######################################################################


