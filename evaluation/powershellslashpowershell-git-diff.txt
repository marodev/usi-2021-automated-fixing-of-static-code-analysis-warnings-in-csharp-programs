diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimAsyncOperation.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimAsyncOperation.cs
index 49f39c8c0..69e161768 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimAsyncOperation.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimAsyncOperation.cs
@@ -383,8 +383,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
         /// <returns>The object.</returns>
         protected object GetReferenceOrReferenceArrayObject(object value, ref CimType referenceType)
         {
-            PSReference cimReference = value as PSReference;
-            if (cimReference != null)
+            if (value is PSReference cimReference)
             {
                 object baseObject = GetBaseObject(cimReference.Value);
                 if (!(baseObject is CimInstance cimInstance))
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimGetInstance.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimGetInstance.cs
index 254005144..2c5db056c 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimGetInstance.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimGetInstance.cs
@@ -284,8 +284,8 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
         internal static bool IsClassNameQuerySet(CimBaseCommand cmdlet)
         {
             DebugHelper.WriteLogEx();
-            GetCimInstanceCommand cmd = cmdlet as GetCimInstanceCommand;
-            if (cmd != null)
+
+            if (cmdlet is GetCimInstanceCommand cmd)
             {
                 if (cmd.QueryDialect != null || cmd.SelectProperties != null || cmd.Filter != null)
                 {
@@ -299,8 +299,8 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
         protected static string CreateQuery(CimBaseCommand cmdlet)
         {
             DebugHelper.WriteLogEx();
-            GetCimInstanceCommand cmd = cmdlet as GetCimInstanceCommand;
-            if (cmd != null)
+
+            if (cmdlet is GetCimInstanceCommand cmd)
             {
                 StringBuilder propertyList = new();
                 if (cmd.SelectProperties == null)
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimIndicationWatcher.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimIndicationWatcher.cs
index 0c847265c..a8a762fa7 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimIndicationWatcher.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimIndicationWatcher.cs
@@ -221,13 +221,11 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
             if (temp != null)
             {
                 // raise the event
-                CimSubscriptionResultEventArgs resultArgs = args as CimSubscriptionResultEventArgs;
-                if (resultArgs != null)
+                if (args is CimSubscriptionResultEventArgs resultArgs)
                     temp(this, new CimIndicationEventInstanceEventArgs(resultArgs.Result));
                 else
                 {
-                    CimSubscriptionExceptionEventArgs exceptionArgs = args as CimSubscriptionExceptionEventArgs;
-                    if (exceptionArgs != null)
+                    if (args is CimSubscriptionExceptionEventArgs exceptionArgs)
                         temp(this, new CimIndicationEventExceptionEventArgs(exceptionArgs.Exception));
                 }
             }
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimNewCimInstance.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimNewCimInstance.cs
index d7436fc0e..104ef62f7 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimNewCimInstance.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimNewCimInstance.cs
@@ -295,8 +295,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
 
                 DebugHelper.WriteLog("Create and add new property to ciminstance: name = {0}; value = {1}; flags = {2}", 5, propertyName, propertyValue, flag);
 
-                PSReference cimReference = propertyValue as PSReference;
-                if (cimReference != null)
+                if (propertyValue is PSReference cimReference)
                 {
                     CimProperty newProperty = CimProperty.Create(propertyName, GetBaseObject(cimReference.Value), CimType.Reference, flag);
                     cimInstance.CimInstanceProperties.Add(newProperty);
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimRegisterCimIndication.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimRegisterCimIndication.cs
index e0fbb1aa0..388608cac 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimRegisterCimIndication.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimRegisterCimIndication.cs
@@ -198,8 +198,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
             }
 
             // NOTES: should move after this.Disposed, but need to log the exception
-            CimWriteError cimWriteError = actionArgs.Action as CimWriteError;
-            if (cimWriteError != null)
+            if (actionArgs.Action is CimWriteError cimWriteError)
             {
                 this.Exception = cimWriteError.Exception;
                 if (!this.ackedEvent.IsSet)
@@ -221,11 +220,9 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
                 DebugHelper.WriteLog("Got an exception: {0}", 2, Exception);
             }
 
-            CimWriteResultObject cimWriteResultObject = actionArgs.Action as CimWriteResultObject;
-            if (cimWriteResultObject != null)
+            if (actionArgs.Action is CimWriteResultObject cimWriteResultObject)
             {
-                CimSubscriptionResult result = cimWriteResultObject.Result as CimSubscriptionResult;
-                if (result != null)
+                if (cimWriteResultObject.Result is CimSubscriptionResult result)
                 {
                     EventHandler<CimSubscriptionEventArgs> temp = this.OnNewSubscriptionResult;
                     if (temp != null)
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimResultObserver.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimResultObserver.cs
index c27c7493d..985510af0 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimResultObserver.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimResultObserver.cs
@@ -419,8 +419,8 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
 
             string resultObjectPSType = null;
             PSObject resultObject = null;
-            CimMethodResult methodResult = value as CimMethodResult;
-            if (methodResult != null)
+
+            if (value is CimMethodResult methodResult)
             {
                 resultObjectPSType = PSTypeCimMethodResult;
                 resultObject = new PSObject();
@@ -431,8 +431,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
             }
             else
             {
-                CimMethodStreamedResult methodStreamedResult = value as CimMethodStreamedResult;
-                if (methodStreamedResult != null)
+                if (value is CimMethodStreamedResult methodStreamedResult)
                 {
                     resultObjectPSType = PSTypeCimMethodStreamedResult;
                     resultObject = new PSObject();
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimWriteError.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimWriteError.cs
index d3ae3419f..f1ebe9116 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/CimWriteError.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/CimWriteError.cs
@@ -39,14 +39,12 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
         {
             Debug.Assert(inner != null, "Caller should verify inner != null");
 
-            CimException cimException = inner as CimException;
-            if (cimException != null)
+            if (inner is CimException cimException)
             {
                 return CreateFromCimException(context, cimException, cimResultContext);
             }
 
-            var containsErrorRecord = inner as IContainsErrorRecord;
-            if (containsErrorRecord != null)
+            if (inner is IContainsErrorRecord containsErrorRecord)
             {
                 return InitializeErrorRecord(context,
                     exception: inner,
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/CmdletOperation.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/CmdletOperation.cs
index 3c49b1dcb..a5fe46210 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/CmdletOperation.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/CmdletOperation.cs
@@ -230,8 +230,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
 
             if (sendToPipeline is CimInstance)
             {
-                CimSetCimInstanceContext setContext = context as CimSetCimInstanceContext;
-                if (setContext != null)
+                if (context is CimSetCimInstanceContext setContext)
                 {
                     if (string.Equals(setContext.ParameterSetName, CimBaseCommand.QueryComputerSet, StringComparison.OrdinalIgnoreCase) ||
                         string.Equals(setContext.ParameterSetName, CimBaseCommand.QuerySessionSet, StringComparison.OrdinalIgnoreCase))
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/GetCimClassCommand.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/GetCimClassCommand.cs
index d4ab679f0..36f4a8958 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/GetCimClassCommand.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/GetCimClassCommand.cs
@@ -196,10 +196,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
         protected override void EndProcessing()
         {
             CimGetCimClass cimGetCimClass = this.GetOperationAgent();
-            if (cimGetCimClass != null)
-            {
-                cimGetCimClass.ProcessRemainActions(this.CmdletOperation);
-            }
+            cimGetCimClass?.ProcessRemainActions(this.CmdletOperation);
         }
 
         #endregion
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/GetCimInstanceCommand.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/GetCimInstanceCommand.cs
index cc4de5e84..6830e5a43 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/GetCimInstanceCommand.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/GetCimInstanceCommand.cs
@@ -491,10 +491,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
         protected override void EndProcessing()
         {
             CimGetInstance cimGetInstance = this.GetOperationAgent();
-            if (cimGetInstance != null)
-            {
-                cimGetInstance.ProcessRemainActions(this.CmdletOperation);
-            }
+            cimGetInstance?.ProcessRemainActions(this.CmdletOperation);
         }
 
         #endregion
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/InvokeCimMethodCommand.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/InvokeCimMethodCommand.cs
index f920094ae..3f5dc861b 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/InvokeCimMethodCommand.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/InvokeCimMethodCommand.cs
@@ -408,10 +408,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
         protected override void EndProcessing()
         {
             CimInvokeCimMethod cimInvokeMethod = this.GetOperationAgent();
-            if (cimInvokeMethod != null)
-            {
-                cimInvokeMethod.ProcessRemainActions(this.CmdletOperation);
-            }
+            cimInvokeMethod?.ProcessRemainActions(this.CmdletOperation);
         }
 
         #endregion
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/NewCimInstanceCommand.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/NewCimInstanceCommand.cs
index b43b1e275..fad21588a 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/NewCimInstanceCommand.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/NewCimInstanceCommand.cs
@@ -377,10 +377,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
         protected override void EndProcessing()
         {
             CimNewCimInstance cimNewCimInstance = this.GetOperationAgent();
-            if (cimNewCimInstance != null)
-            {
-                cimNewCimInstance.ProcessRemainActions(this.CmdletOperation);
-            }
+            cimNewCimInstance?.ProcessRemainActions(this.CmdletOperation);
         }
 
         #endregion
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/NewCimSessionCommand.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/NewCimSessionCommand.cs
index 2d1a91f5c..fb2e0ec6e 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/NewCimSessionCommand.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/NewCimSessionCommand.cs
@@ -234,8 +234,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
             outputCredential = null;
             if (options != null)
             {
-                DComSessionOptions dcomOptions = options as DComSessionOptions;
-                if (dcomOptions != null)
+                if (options is DComSessionOptions dcomOptions)
                 {
                     bool conflict = false;
                     string parameterName = string.Empty;
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/RegisterCimIndicationCommand.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/RegisterCimIndicationCommand.cs
index 246a95f37..3b570c081 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/RegisterCimIndicationCommand.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/RegisterCimIndicationCommand.cs
@@ -227,10 +227,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
                     break;
             }
 
-            if (watcher != null)
-            {
-                watcher.SetCmdlet(this);
-            }
+            watcher?.SetCmdlet(this);
 
             return watcher;
         }
@@ -275,10 +272,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
             DebugHelper.WriteLogEx();
 
             CimIndicationWatcher watcher = sender as CimIndicationWatcher;
-            if (watcher != null)
-            {
-                watcher.Stop();
-            }
+            watcher?.Stop();
         }
 
         #region private members
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/RemoveCimInstanceCommand.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/RemoveCimInstanceCommand.cs
index c3f123002..5e4b909f1 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/RemoveCimInstanceCommand.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/RemoveCimInstanceCommand.cs
@@ -276,10 +276,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
         protected override void EndProcessing()
         {
             CimRemoveCimInstance cimRemoveInstance = this.GetOperationAgent();
-            if (cimRemoveInstance != null)
-            {
-                cimRemoveInstance.ProcessRemainActions(this.CmdletOperation);
-            }
+            cimRemoveInstance?.ProcessRemainActions(this.CmdletOperation);
         }
 
         #endregion
diff --git a/src/Microsoft.Management.Infrastructure.CimCmdlets/SetCimInstanceCommand.cs b/src/Microsoft.Management.Infrastructure.CimCmdlets/SetCimInstanceCommand.cs
index 25b3113e4..f04e60266 100644
--- a/src/Microsoft.Management.Infrastructure.CimCmdlets/SetCimInstanceCommand.cs
+++ b/src/Microsoft.Management.Infrastructure.CimCmdlets/SetCimInstanceCommand.cs
@@ -325,10 +325,7 @@ namespace Microsoft.Management.Infrastructure.CimCmdlets
         protected override void EndProcessing()
         {
             CimSetCimInstance cimSetCimInstance = this.GetOperationAgent();
-            if (cimSetCimInstance != null)
-            {
-                cimSetCimInstance.ProcessRemainActions(this.CmdletOperation);
-            }
+            cimSetCimInstance?.ProcessRemainActions(this.CmdletOperation);
         }
 
         #endregion
diff --git a/src/Microsoft.PowerShell.Commands.Diagnostics/GetEventCommand.cs b/src/Microsoft.PowerShell.Commands.Diagnostics/GetEventCommand.cs
index 1a74da73d..784ad1f6b 100644
--- a/src/Microsoft.PowerShell.Commands.Diagnostics/GetEventCommand.cs
+++ b/src/Microsoft.PowerShell.Commands.Diagnostics/GetEventCommand.cs
@@ -1181,11 +1181,8 @@ namespace Microsoft.PowerShell.Commands
                 //
                 xpathString = BuildXPathFromHashTable(hash);
 
-                //
-                // Build xpath for <Suppress>
-                //
-                Hashtable suppresshash = hash[hashkey_supress_lc] as Hashtable;
-                if (suppresshash != null)
+                //                // Build xpath for <Suppress>                //
+                if (hash[hashkey_supress_lc] is Hashtable suppresshash)
                 {
                     xpathStringSuppress = BuildXPathFromHashTable(suppresshash);
                 }
@@ -1252,8 +1249,8 @@ namespace Microsoft.PowerShell.Commands
         private static string HandleEventIdHashValue(object value)
         {
             StringBuilder ret = new();
-            Array idsArray = value as Array;
-            if (idsArray != null)
+
+            if (value is Array idsArray)
             {
                 ret.Append('(');
                 for (int i = 0; i < idsArray.Length; i++)
@@ -1282,8 +1279,8 @@ namespace Microsoft.PowerShell.Commands
         private static string HandleLevelHashValue(object value)
         {
             StringBuilder ret = new();
-            Array levelsArray = value as Array;
-            if (levelsArray != null)
+
+            if (value is Array levelsArray)
             {
                 ret.Append('(');
                 for (int i = 0; i < levelsArray.Length; i++)
@@ -1314,8 +1311,7 @@ namespace Microsoft.PowerShell.Commands
             Int64 keywordsMask = 0;
             Int64 keywordLong = 0;
 
-            Array keywordArray = value as Array;
-            if (keywordArray != null)
+            if (value is Array keywordArray)
             {
                 foreach (object keyword in keywordArray)
                 {
@@ -1470,8 +1466,8 @@ namespace Microsoft.PowerShell.Commands
         private static string HandleDataHashValue(object value)
         {
             StringBuilder ret = new();
-            Array dataArray = value as Array;
-            if (dataArray != null)
+
+            if (value is Array dataArray)
             {
                 ret.Append('(');
                 for (int i = 0; i < dataArray.Length; i++)
@@ -1501,8 +1497,8 @@ namespace Microsoft.PowerShell.Commands
         private static string HandleNamedDataHashValue(string key, object value)
         {
             StringBuilder ret = new();
-            Array dataArray = value as Array;
-            if (dataArray != null)
+
+            if (value is Array dataArray)
             {
                 ret.Append('(');
                 for (int i = 0; i < dataArray.Length; i++)
@@ -1749,8 +1745,7 @@ namespace Microsoft.PowerShell.Commands
                     }
                     else
                     {
-                        Array eltArray = value as Array;
-                        if (eltArray != null)
+                        if (value is Array eltArray)
                         {
                             foreach (object elt in eltArray)
                             {
diff --git a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/SessionBasedWrapper.cs b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/SessionBasedWrapper.cs
index fb6b638b9..e16eacb03 100644
--- a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/SessionBasedWrapper.cs
+++ b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/SessionBasedWrapper.cs
@@ -495,8 +495,7 @@ namespace Microsoft.PowerShell.Cmdletization
                 return this.Session;
             }
 
-            var sessionBoundQueryBuilder = queryBuilder as ISessionBoundQueryBuilder<TSession>;
-            if (sessionBoundQueryBuilder != null)
+            if (queryBuilder is ISessionBoundQueryBuilder<TSession> sessionBoundQueryBuilder)
             {
                 TSession sessionOfTheQueryBuilder = sessionBoundQueryBuilder.GetTargetSession();
                 if (sessionOfTheQueryBuilder != null)
@@ -688,10 +687,7 @@ namespace Microsoft.PowerShell.Cmdletization
         public override void StopProcessing()
         {
             Job jobToStop = _parentJob;
-            if (jobToStop != null)
-            {
-                jobToStop.StopJob();
-            }
+            jobToStop?.StopJob();
 
             base.StopProcessing();
         }
diff --git a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/CimJobException.cs b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/CimJobException.cs
index 808ca1a4d..e128692ef 100644
--- a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/CimJobException.cs
+++ b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/CimJobException.cs
@@ -104,16 +104,15 @@ namespace Microsoft.PowerShell.Cmdletization.Cim
             Dbg.Assert(jobContext != null, "Caller should verify jobContext != null");
             Dbg.Assert(inner != null, "Caller should verify inner != null");
 
-            CimException cimException = inner as CimException;
-            if (cimException != null)
+            if (inner is CimException cimException)
             {
                 return CreateFromCimException(jobDescription, jobContext, cimException);
             }
 
             string message = BuildErrorMessage(jobDescription, jobContext, inner.Message);
             CimJobException cimJobException = new(message, inner);
-            var containsErrorRecord = inner as IContainsErrorRecord;
-            if (containsErrorRecord != null)
+
+            if (inner is IContainsErrorRecord containsErrorRecord)
             {
                 cimJobException.InitializeErrorRecord(
                     jobContext,
diff --git a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/TerminatingErrorTracker.cs b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/TerminatingErrorTracker.cs
index 515e19f89..f973e1446 100644
--- a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/TerminatingErrorTracker.cs
+++ b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/TerminatingErrorTracker.cs
@@ -53,8 +53,7 @@ namespace Microsoft.PowerShell.Cmdletization.Cim
             int maxNumberOfSessionsIndicatedByCimInstanceArguments = 1;
             foreach (object cmdletArgument in invocationInfo.BoundParameters.Values)
             {
-                CimInstance[] array = cmdletArgument as CimInstance[];
-                if (array != null)
+                if (cmdletArgument is CimInstance[] array)
                 {
                     int numberOfSessionsAssociatedWithArgument = array
                         .Select(CimCmdletAdapter.GetSessionOfOriginFromCimInstance)
diff --git a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/cimChildJobBase.cs b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/cimChildJobBase.cs
index 6dc65424f..42c529b5b 100644
--- a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/cimChildJobBase.cs
+++ b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/cimChildJobBase.cs
@@ -315,10 +315,7 @@ namespace Microsoft.PowerShell.Cmdletization.Cim
                 this.ExceptionSafeWrapper(delegate
                 {
                     IObservable<T> observable = this.GetCimOperation();
-                    if (observable != null)
-                    {
-                        observable.Subscribe(this);
-                    }
+                    observable?.Subscribe(this);
                 });
             });
         }
@@ -522,10 +519,7 @@ namespace Microsoft.PowerShell.Cmdletization.Cim
             }
 
             CimCustomOptionsDictionary jobSpecificCustomOptions = this.GetJobSpecificCustomOptions();
-            if (jobSpecificCustomOptions != null)
-            {
-                jobSpecificCustomOptions.Apply(operationOptions, CimSensitiveValueConverter);
-            }
+            jobSpecificCustomOptions?.Apply(operationOptions, CimSensitiveValueConverter);
 
             return operationOptions;
         }
@@ -629,8 +623,7 @@ namespace Microsoft.PowerShell.Cmdletization.Cim
             }
             else
             {
-                CimJobException cje = exception as CimJobException;
-                if ((cje != null) && (cje.IsTerminatingError))
+                if ((exception is CimJobException cje) && (cje.IsTerminatingError))
                 {
                     terminatingErrorTracker.MarkSessionAsTerminated(this.JobContext.Session, out sessionWasAlreadyTerminated);
                     isThisTerminatingError = true;
@@ -1019,8 +1012,7 @@ namespace Microsoft.PowerShell.Cmdletization.Cim
 
         internal static void AddShowComputerNameMarker(PSObject pso)
         {
-            PSPropertyInfo psShowComputerNameProperty = pso.InstanceMembers[RemotingConstants.ShowComputerNameNoteProperty] as PSPropertyInfo;
-            if (psShowComputerNameProperty != null)
+            if (pso.InstanceMembers[RemotingConstants.ShowComputerNameNoteProperty] is PSPropertyInfo psShowComputerNameProperty)
             {
                 psShowComputerNameProperty.Value = true;
             }
diff --git a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/cimQuery.cs b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/cimQuery.cs
index a6f5b9616..04c4a2c16 100644
--- a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/cimQuery.cs
+++ b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/cimQuery.cs
@@ -122,9 +122,8 @@ namespace Microsoft.PowerShell.Cmdletization.Cim
             string condition;
 
             // comparison of 'char' is case-sensitive in WQL (comparison of 'string' is case-insensitive)
-            if (propertyValue is char)
+            if (propertyValue is char c)
             {
-                char c = (char)propertyValue;
                 char lowerCase = char.ToLowerInvariant(c);
                 char upperCase = char.ToUpperInvariant(c);
                 string lowerCaseLiteral = CimQuery.ObjectToWqlLiteral(lowerCase);
diff --git a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/clientSideQuery.cs b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/clientSideQuery.cs
index 39d1a5bc4..620816f86 100644
--- a/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/clientSideQuery.cs
+++ b/src/Microsoft.PowerShell.Commands.Management/cimSupport/cmdletization/cim/clientSideQuery.cs
@@ -466,8 +466,7 @@ namespace Microsoft.PowerShell.Cmdletization.Cim
                 }
                 else
                 {
-                    string expectedPropertyValueAsString = cimTypedExpectedPropertyValue as string;
-                    if (expectedPropertyValueAsString != null && WildcardPattern.ContainsWildcardCharacters(expectedPropertyValueAsString))
+                    if (cimTypedExpectedPropertyValue is string expectedPropertyValueAsString && WildcardPattern.ContainsWildcardCharacters(expectedPropertyValueAsString))
                     {
                         return BehaviorOnNoMatch.SilentlyContinue;
                     }
@@ -504,8 +503,7 @@ namespace Microsoft.PowerShell.Cmdletization.Cim
                     actualPropertyValue = actualPropertyValue.ToString();
                 }
 
-                var expectedPropertyValueAsString = expectedPropertyValue as string;
-                if (expectedPropertyValueAsString != null)
+                if (expectedPropertyValue is string expectedPropertyValueAsString)
                 {
                     var actualPropertyValueAsString = (string)actualPropertyValue;
                     return actualPropertyValueAsString.Equals(expectedPropertyValueAsString, StringComparison.OrdinalIgnoreCase);
diff --git a/src/Microsoft.PowerShell.Commands.Management/commands/management/Computer.cs b/src/Microsoft.PowerShell.Commands.Management/commands/management/Computer.cs
index 61b5fe448..ac644b19f 100644
--- a/src/Microsoft.PowerShell.Commands.Management/commands/management/Computer.cs
+++ b/src/Microsoft.PowerShell.Commands.Management/commands/management/Computer.cs
@@ -393,17 +393,11 @@ $result
         {
             if (disposing)
             {
-                if (_timer != null)
-                {
-                    _timer.Dispose();
-                }
+                _timer?.Dispose();
 
                 _waitHandler.Dispose();
                 _cancel.Dispose();
-                if (_powershell != null)
-                {
-                    _powershell.Dispose();
-                }
+                _powershell?.Dispose();
             }
         }
 
@@ -1098,10 +1092,7 @@ $result
             _cancel.Cancel();
             _waitHandler.Set();
 
-            if (_timer != null)
-            {
-                _timer.Change(System.Threading.Timeout.Infinite, System.Threading.Timeout.Infinite);
-            }
+            _timer?.Change(System.Threading.Timeout.Infinite, System.Threading.Timeout.Infinite);
 
             if (_powershell != null)
             {
diff --git a/src/Microsoft.PowerShell.Commands.Management/commands/management/GetComputerInfoCommand.cs b/src/Microsoft.PowerShell.Commands.Management/commands/management/GetComputerInfoCommand.cs
index 4c8a95ddd..6b4dbec52 100644
--- a/src/Microsoft.PowerShell.Commands.Management/commands/management/GetComputerInfoCommand.cs
+++ b/src/Microsoft.PowerShell.Commands.Management/commands/management/GetComputerInfoCommand.cs
@@ -248,7 +248,7 @@ namespace Microsoft.PowerShell.Commands
             try
             {
                 var halPath = CIMHelper.EscapePath(System.IO.Path.Combine(systemDirectory, "hal.dll"));
-                var query = string.Format("SELECT * FROM CIM_DataFile Where Name='{0}'", halPath);
+                var query = $"SELECT * FROM CIM_DataFile Where Name='{halPath}'";
                 var instance = session.QueryFirstInstance(query);
 
                 if (instance != null)
@@ -460,7 +460,7 @@ namespace Microsoft.PowerShell.Commands
                 {
                     var property = instance.CimInstanceProperties[propertyName];
 
-                    if (property != null && property.Value != null)
+                    if (property?.Value != null)
                         return (bool)property.Value;
                 }
                 catch (Exception)
diff --git a/src/Microsoft.PowerShell.Commands.Management/commands/management/Hotfix.cs b/src/Microsoft.PowerShell.Commands.Management/commands/management/Hotfix.cs
index d6768a131..1aa945094 100644
--- a/src/Microsoft.PowerShell.Commands.Management/commands/management/Hotfix.cs
+++ b/src/Microsoft.PowerShell.Commands.Management/commands/management/Hotfix.cs
@@ -169,10 +169,7 @@ namespace Microsoft.PowerShell.Commands
         /// </summary>
         protected override void StopProcessing()
         {
-            if (_searchProcess != null)
-            {
-                _searchProcess.Dispose();
-            }
+            _searchProcess?.Dispose();
         }
         #endregion Overrides
 
@@ -227,10 +224,7 @@ namespace Microsoft.PowerShell.Commands
         {
             if (disposing)
             {
-                if (_searchProcess != null)
-                {
-                    _searchProcess.Dispose();
-                }
+                _searchProcess?.Dispose();
             }
         }
 
diff --git a/src/Microsoft.PowerShell.Commands.Management/commands/management/Process.cs b/src/Microsoft.PowerShell.Commands.Management/commands/management/Process.cs
index 6656dcc54..083c6f75b 100644
--- a/src/Microsoft.PowerShell.Commands.Management/commands/management/Process.cs
+++ b/src/Microsoft.PowerShell.Commands.Management/commands/management/Process.cs
@@ -947,10 +947,7 @@ namespace Microsoft.PowerShell.Commands
         {
             if (System.Threading.Interlocked.Decrement(ref _numberOfProcessesToWaitFor) == 0)
             {
-                if (_waitHandle != null)
-                {
-                    _waitHandle.Set();
-                }
+                _waitHandle?.Set();
             }
         }
 
@@ -1051,10 +1048,7 @@ namespace Microsoft.PowerShell.Commands
         /// </summary>
         protected override void StopProcessing()
         {
-            if (_waitHandle != null)
-            {
-                _waitHandle.Set();
-            }
+            _waitHandle?.Set();
         }
         #endregion Overrides
 
@@ -2090,10 +2084,7 @@ namespace Microsoft.PowerShell.Commands
         /// </summary>
         protected override void StopProcessing()
         {
-            if (_waithandle != null)
-            {
-                _waithandle.Set();
-            }
+            _waithandle?.Set();
         }
 
         #endregion
@@ -2127,10 +2118,7 @@ namespace Microsoft.PowerShell.Commands
         /// </summary>
         private void myProcess_Exited(object sender, System.EventArgs e)
         {
-            if (_waithandle != null)
-            {
-                _waithandle.Set();
-            }
+            _waithandle?.Set();
         }
 
         private string ResolveFilePath(string path)
diff --git a/src/Microsoft.PowerShell.Commands.Management/commands/management/Service.cs b/src/Microsoft.PowerShell.Commands.Management/commands/management/Service.cs
index 1d793857c..cb5d45ec4 100644
--- a/src/Microsoft.PowerShell.Commands.Management/commands/management/Service.cs
+++ b/src/Microsoft.PowerShell.Commands.Management/commands/management/Service.cs
@@ -1126,8 +1126,7 @@ namespace Microsoft.PowerShell.Commands
             }
             catch (InvalidOperationException e)
             {
-                Win32Exception eInner = e.InnerException as Win32Exception;
-                if (eInner != null
+                if (e.InnerException is Win32Exception eInner
                     && eInner.NativeErrorCode == NativeMethods.ERROR_SERVICE_NOT_ACTIVE)
                 {
                     serviceNotRunning = true;
@@ -1207,8 +1206,7 @@ namespace Microsoft.PowerShell.Commands
             }
             catch (InvalidOperationException e)
             {
-                Win32Exception eInner = e.InnerException as Win32Exception;
-                if (eInner != null
+                if (e.InnerException is Win32Exception eInner
                     && eInner.NativeErrorCode == NativeMethods.ERROR_SERVICE_NOT_ACTIVE)
                 {
                     serviceNotRunning = true;
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/AddMember.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/AddMember.cs
index efb035b77..c41ea302a 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/AddMember.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/AddMember.cs
@@ -557,9 +557,9 @@ namespace Microsoft.PowerShell.Commands
         {
             protected override void Validate(object arguments, EngineIntrinsics engineIntrinsics)
             {
-                string notePropertyName = arguments as string;
                 PSMemberTypes memberType;
-                if (notePropertyName != null && LanguagePrimitives.TryConvertTo<PSMemberTypes>(notePropertyName, out memberType))
+
+                if (arguments is string notePropertyName && LanguagePrimitives.TryConvertTo<PSMemberTypes>(notePropertyName, out memberType))
                 {
                     switch (memberType)
                     {
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ConvertTo-Html.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ConvertTo-Html.cs
index e72fc825e..925c35b48 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ConvertTo-Html.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ConvertTo-Html.cs
@@ -504,9 +504,8 @@ namespace Microsoft.PowerShell.Commands
                                     MshCommandRuntime mshCommandRuntime = this.CommandRuntime as MshCommandRuntime;
                                     string Message = StringUtil.Format(ConvertHTMLStrings.MetaPropertyNotFound, s, _meta[s]);
                                     WarningRecord record = new(Message);
-                                    InvocationInfo invocationInfo = GetVariableValue(SpecialVariables.MyInvocation) as InvocationInfo;
 
-                                    if (invocationInfo != null)
+                                    if (GetVariableValue(SpecialVariables.MyInvocation) is InvocationInfo invocationInfo)
                                     {
                                         record.SetInvocationInfo(invocationInfo);
                                     }
@@ -555,16 +554,15 @@ namespace Microsoft.PowerShell.Commands
             foreach (MshParameter p in mshParams)
             {
                 COLTag.Append("<col");
-                string width = p.GetEntry(ConvertHTMLParameterDefinitionKeys.WidthEntryKey) as string;
-                if (width != null)
+
+                if (p.GetEntry(ConvertHTMLParameterDefinitionKeys.WidthEntryKey) is string width)
                 {
                     COLTag.Append(" width = \"");
                     COLTag.Append(width);
                     COLTag.Append('"');
                 }
 
-                string alignment = p.GetEntry(ConvertHTMLParameterDefinitionKeys.AlignmentEntryKey) as string;
-                if (alignment != null)
+                if (p.GetEntry(ConvertHTMLParameterDefinitionKeys.AlignmentEntryKey) is string alignment)
                 {
                     COLTag.Append(" align = \"");
                     COLTag.Append(alignment);
@@ -610,8 +608,7 @@ namespace Microsoft.PowerShell.Commands
         private static void WritePropertyName(StringBuilder Listtag, MshParameter p)
         {
             // for writing the property name
-            string label = p.GetEntry(ConvertHTMLParameterDefinitionKeys.LabelEntryKey) as string;
-            if (label != null)
+            if (p.GetEntry(ConvertHTMLParameterDefinitionKeys.LabelEntryKey) is string label)
             {
                 Listtag.Append(label);
             }
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/CsvCommands.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/CsvCommands.cs
index cbd9d4c36..3828c49f9 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/CsvCommands.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/CsvCommands.cs
@@ -428,10 +428,7 @@ namespace Microsoft.PowerShell.Commands
                     _readOnlyFileInfo.Attributes |= FileAttributes.ReadOnly;
             }
 
-            if (_helper != null)
-            {
-                _helper.Dispose();
-            }
+            _helper?.Dispose();
         }
 
         private void ReconcilePreexistingPropertyNames()
@@ -736,7 +733,7 @@ namespace Microsoft.PowerShell.Commands
 
                 // Write property information
                 string properties = _helper.ConvertPropertyNamesCSV(_propertyNames);
-                if (!properties.Equals(string.Empty))
+                if (!string.IsNullOrEmpty(properties))
                     WriteCsvLine(properties);
             }
 
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/CustomSerialization.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/CustomSerialization.cs
index 6ad8b02a5..8e159d22e 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/CustomSerialization.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/CustomSerialization.cs
@@ -170,10 +170,7 @@ namespace System.Management.Automation
         internal void Stop()
         {
             CustomInternalSerializer serializer = _serializer;
-            if (serializer != null)
-            {
-                serializer.Stop();
-            }
+            serializer?.Stop();
         }
 
         #endregion
@@ -341,8 +338,8 @@ namespace System.Management.Automation
             Dbg.Assert(source != null, "caller should validate the parameter");
 
             bool sourceHandled = false;
-            PSObject moSource = source as PSObject;
-            if (moSource != null && !moSource.ImmediateBaseObjectIsEmpty)
+
+            if (source is PSObject moSource && !moSource.ImmediateBaseObjectIsEmpty)
             {
                 // Check if baseObject is primitive known type
                 object baseObject = moSource.ImmediateBaseObject;
@@ -362,18 +359,17 @@ namespace System.Management.Automation
             Dbg.Assert(source != null, "caller should validate the parameter");
 
             ContainerType ct = ContainerType.None;
-            PSObject mshSource = source as PSObject;
             IEnumerable enumerable = null;
             IDictionary dictionary = null;
 
             // If passed in object is PSObject with no baseobject, return false.
-            if (mshSource != null && mshSource.ImmediateBaseObjectIsEmpty)
+            if (source is PSObject mshSource && mshSource.ImmediateBaseObjectIsEmpty)
             {
                 return false;
             }
 
             // Check if source (or baseobject in mshSource) is known container type
-            GetKnownContainerTypeInfo(mshSource != null ? mshSource.ImmediateBaseObject : source, out ct,
+            GetKnownContainerTypeInfo(source is PSObject mshSource ? mshSource.ImmediateBaseObject : source, out ct,
                                       out dictionary, out enumerable);
 
             if (ct == ContainerType.None)
@@ -411,7 +407,7 @@ namespace System.Management.Automation
             // We serialize properties of enumerable and on deserialization mark the object
             // as Deserialized. So if object is marked deserialized, we should write properties.
             // Note: we do not serialize the properties of IEnumerable if depth is zero.
-            if (depth != 0 && (ct == ContainerType.Enumerable || (mshSource != null && mshSource.IsDeserialized)))
+            if (depth != 0 && (ct == ContainerType.Enumerable || (source is PSObject mshSource && mshSource.IsDeserialized)))
             {
                 // Note:Depth is the depth for serialization of baseObject.
                 // Depth for serialization of each property is one less.
@@ -419,7 +415,7 @@ namespace System.Management.Automation
             }
 
             // If source is PSObject, serialize notes
-            if (mshSource != null)
+            if (source is PSObject mshSource)
             {
                 // Serialize instanceMembers
                 PSMemberInfoCollection<PSMemberInfo> instanceMembers = mshSource.InstanceMembers;
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/DebugRunspaceCommand.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/DebugRunspaceCommand.cs
index aa370c12b..3d447add6 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/DebugRunspaceCommand.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/DebugRunspaceCommand.cs
@@ -237,10 +237,7 @@ namespace Microsoft.PowerShell.Commands
 
             // Unblock the data collection.
             PSDataCollection<PSStreamObject> debugCollection = _debugBlockingCollection;
-            if (debugCollection != null)
-            {
-                debugCollection.Complete();
-            }
+            debugCollection?.Complete();
 
             // Unblock any new command wait.
             _newRunningScriptEvent.Set();
@@ -335,9 +332,9 @@ namespace Microsoft.PowerShell.Commands
         private void AddDataEventHandlers()
         {
             // Create new collection objects.
-            if (_debugBlockingCollection != null) { _debugBlockingCollection.Dispose(); }
+            _debugBlockingCollection?.Dispose();
 
-            if (_debugAccumulateCollection != null) { _debugAccumulateCollection.Dispose(); }
+            _debugAccumulateCollection?.Dispose();
 
             _debugBlockingCollection = new PSDataCollection<PSStreamObject>();
             _debugBlockingCollection.BlockingEnumerator = true;
@@ -409,8 +406,7 @@ namespace Microsoft.PowerShell.Commands
         private void HandleRunspaceAvailabilityChanged(object sender, RunspaceAvailabilityEventArgs e)
         {
             // Ignore nested commands.
-            LocalRunspace localRunspace = sender as LocalRunspace;
-            if (localRunspace != null)
+            if (sender is LocalRunspace localRunspace)
             {
                 var basePowerShell = localRunspace.GetCurrentBasePowerShell();
                 if ((basePowerShell != null) && (basePowerShell.IsNested))
@@ -440,8 +436,7 @@ namespace Microsoft.PowerShell.Commands
 
         private void HandlePipelineOutputDataReady(object sender, EventArgs e)
         {
-            PipelineReader<PSObject> reader = sender as PipelineReader<PSObject>;
-            if (reader != null && reader.IsOpen)
+            if (sender is PipelineReader<PSObject> reader && reader.IsOpen)
             {
                 WritePipelineCollection(reader.NonBlockingRead(), PSStreamObjectType.Output);
             }
@@ -449,8 +444,7 @@ namespace Microsoft.PowerShell.Commands
 
         private void HandlePipelineErrorDataReady(object sender, EventArgs e)
         {
-            PipelineReader<object> reader = sender as PipelineReader<object>;
-            if (reader != null && reader.IsOpen)
+            if (sender is PipelineReader<object> reader && reader.IsOpen)
             {
                 WritePipelineCollection(reader.NonBlockingRead(), PSStreamObjectType.Error);
             }
@@ -537,8 +531,7 @@ namespace Microsoft.PowerShell.Commands
             // Only enable and disable the host's runspace if we are in process attach mode.
             if (_debugger is ServerRemoteDebugger)
             {
-                LocalRunspace localRunspace = runspace as LocalRunspace;
-                if ((localRunspace != null) && (localRunspace.ExecutionContext != null) && (localRunspace.ExecutionContext.EngineHostInterface != null))
+                if ((runspace is LocalRunspace localRunspace) && (localRunspace.ExecutionContext != null) && (localRunspace.ExecutionContext.EngineHostInterface != null))
                 {
                     try
                     {
@@ -551,8 +544,7 @@ namespace Microsoft.PowerShell.Commands
 
         private static void SetLocalMode(System.Management.Automation.Debugger debugger, bool localMode)
         {
-            ServerRemoteDebugger remoteDebugger = debugger as ServerRemoteDebugger;
-            if (remoteDebugger != null)
+            if (debugger is ServerRemoteDebugger remoteDebugger)
             {
                 remoteDebugger.LocalDebugMode = localMode;
             }
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/EnableDisableRunspaceDebugCommand.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/EnableDisableRunspaceDebugCommand.cs
index c37d83ecf..a682c680b 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/EnableDisableRunspaceDebugCommand.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/EnableDisableRunspaceDebugCommand.cs
@@ -517,7 +517,7 @@ namespace Microsoft.PowerShell.Commands
         {
             Runspace currentRunspace = this.Context.CurrentRunspace;
 
-            if (currentRunspace != null && currentRunspace.Debugger != null)
+            if (currentRunspace?.Debugger != null)
             {
                 WriteVerbose(string.Format(CultureInfo.InvariantCulture, Debugger.DebugBreakMessage, MyInvocation.ScriptLineNumber, MyInvocation.ScriptName));
 
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/ColumnInfo.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/ColumnInfo.cs
index a42462737..5b66d56d5 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/ColumnInfo.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/ColumnInfo.cs
@@ -33,7 +33,7 @@ namespace Microsoft.PowerShell.Commands
         internal Type GetValueType(PSObject liveObject, out object columnValue)
         {
             columnValue = GetValue(liveObject);
-            if (columnValue != null && columnValue is IComparable)
+            if (columnValue is IComparable)
             {
                 return columnValue.GetType();
             }
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OriginalColumnInfo.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OriginalColumnInfo.cs
index 3db37f352..ee7540078 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OriginalColumnInfo.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OriginalColumnInfo.cs
@@ -33,15 +33,14 @@ namespace Microsoft.PowerShell.Commands
 
                 // The live object has the liveObjectPropertyName property.
                 object liveObjectValue = propertyInfo.Value;
-                ICollection collectionValue = liveObjectValue as ICollection;
-                if (collectionValue != null)
+
+                if (liveObjectValue is ICollection collectionValue)
                 {
                     liveObjectValue = _parentCmdlet.ConvertToString(PSObjectHelper.AsPSObject(propertyInfo.Value));
                 }
                 else
                 {
-                    PSObject psObjectValue = liveObjectValue as PSObject;
-                    if (psObjectValue != null)
+                    if (liveObjectValue is PSObject psObjectValue)
                     {
                         // Since PSObject implements IComparable there is a need to verify if its BaseObject actually implements IComparable.
                         if (psObjectValue.BaseObject is IComparable)
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OutGridViewCommand.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OutGridViewCommand.cs
index e606e58e9..4f3a0e9e0 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OutGridViewCommand.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OutGridViewCommand.cs
@@ -180,8 +180,7 @@ namespace Microsoft.PowerShell.Commands
                 return;
             }
 
-            IDictionary dictionary = InputObject.BaseObject as IDictionary;
-            if (dictionary != null)
+            if (InputObject.BaseObject is IDictionary dictionary)
             {
                 // Dictionaries should be enumerated through because the pipeline does not enumerate through them.
                 foreach (DictionaryEntry entry in dictionary)
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OutWindowProxy.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OutWindowProxy.cs
index 3f22caf1e..5e9aa218a 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OutWindowProxy.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/OutWindowProxy.cs
@@ -80,8 +80,7 @@ namespace Microsoft.PowerShell.Commands
             catch (TargetInvocationException ex)
             {
                 // Verify if this is an error loading the System.Core dll.
-                FileNotFoundException fileNotFoundEx = ex.InnerException as FileNotFoundException;
-                if (fileNotFoundEx != null && fileNotFoundEx.FileName.Contains("System.Core"))
+                if (ex.InnerException is FileNotFoundException fileNotFoundEx && fileNotFoundEx.FileName.Contains("System.Core"))
                 {
                     _parentCmdlet.ThrowTerminatingError(
                         new ErrorRecord(new InvalidOperationException(
@@ -232,10 +231,7 @@ namespace Microsoft.PowerShell.Commands
 
         internal void BlockUntillClosed()
         {
-            if (_closedEvent != null)
-            {
-                _closedEvent.WaitOne();
-            }
+            _closedEvent?.WaitOne();
         }
 
         /// <summary>
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/TableView.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/TableView.cs
index 216d9121d..03d14f428 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/TableView.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/OutGridView/TableView.cs
@@ -56,7 +56,7 @@ namespace Microsoft.PowerShell.Commands
                     if (col < tableBody.header.columnHeaderDefinitionList.Count)
                         colHeader = tableBody.header.columnHeaderDefinitionList[col];
 
-                    if (colHeader != null && colHeader.label != null)
+                    if (colHeader?.label != null)
                     {
                         displayName = _typeInfoDatabase.displayResourceManagerCache.GetTextTokenString(colHeader.label);
                     }
@@ -69,8 +69,7 @@ namespace Microsoft.PowerShell.Commands
 
                     if (token != null)
                     {
-                        FieldPropertyToken fpt = token as FieldPropertyToken;
-                        if (fpt != null)
+                        if (token is FieldPropertyToken fpt)
                         {
                             if (displayName == null)
                             {
@@ -101,8 +100,7 @@ namespace Microsoft.PowerShell.Commands
                         }
                         else
                         {
-                            TextToken tt = token as TextToken;
-                            if (tt != null)
+                            if (token is TextToken tt)
                             {
                                 displayName = _typeInfoDatabase.displayResourceManagerCache.GetTextTokenString(tt);
                                 columnInfo = new OriginalColumnInfo(tt.text, displayName, tt.text, parentCmdlet);
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/common/GetFormatDataCommand.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/common/GetFormatDataCommand.cs
index 70967aa89..932103376 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/common/GetFormatDataCommand.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/common/GetFormatDataCommand.cs
@@ -104,8 +104,8 @@ namespace Microsoft.PowerShell.Commands
             //      Note: Even though $PSVersionTable.PSVersion is of type [semver] in PowerShell 6+, it is of type [version] here,
             //            presumably because only the latter type deserializes type-faithfully.
             var clientVersion = PowerShellVersion;
-            PSSenderInfo remotingClientInfo = GetVariableValue("PSSenderInfo") as PSSenderInfo;
-            if (clientVersion == null && remotingClientInfo != null)
+
+            if (clientVersion == null && GetVariableValue("PSSenderInfo") is PSSenderInfo remotingClientInfo)
             {
                 clientVersion = PSObject.Base((PSObject.Base(remotingClientInfo.ApplicationArguments["PSVersionTable"]) as PSPrimitiveDictionary)?["PSVersion"]) as Version;
             }
@@ -113,7 +113,7 @@ namespace Microsoft.PowerShell.Commands
             // During remoting, remain compatible with v5.0- clients by default.
             // Passing a -PowerShellVersion argument allows overriding the client version.
             bool writeOldWay =
-                (remotingClientInfo != null && clientVersion == null)  // To be safe: Remoting client version could unexpectedly not be determined.
+                (GetVariableValue("PSSenderInfo") is PSSenderInfo remotingClientInfo && clientVersion == null)  // To be safe: Remoting client version could unexpectedly not be determined.
                 ||
                 (clientVersion != null
                     &&
@@ -140,22 +140,19 @@ namespace Microsoft.PowerShell.Commands
 
                 PSControl control;
 
-                var tableControlBody = definition.mainControl as TableControlBody;
-                if (tableControlBody != null)
+                if (definition.mainControl is TableControlBody tableControlBody)
                 {
                     control = new TableControl(tableControlBody, definition);
                 }
                 else
                 {
-                    var listControlBody = definition.mainControl as ListControlBody;
-                    if (listControlBody != null)
+                    if (definition.mainControl is ListControlBody listControlBody)
                     {
                         control = new ListControl(listControlBody, definition);
                     }
                     else
                     {
-                        var wideControlBody = definition.mainControl as WideControlBody;
-                        if (wideControlBody != null)
+                        if (definition.mainControl is WideControlBody wideControlBody)
                         {
                             control = new WideControl(wideControlBody, definition);
                             if (writeOldWay)
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/format-hex/Format-Hex.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/format-hex/Format-Hex.cs
index 091903f01..f9afe5ad8 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/format-hex/Format-Hex.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/FormatAndOutput/format-hex/Format-Hex.cs
@@ -296,7 +296,7 @@ namespace Microsoft.PowerShell.Commands
         private static readonly Random _idGenerator = new();
 
         private static string GetGroupLabel(Type inputType)
-            => string.Format("{0} ({1}) <{2:X8}>", inputType.Name, inputType.FullName, _idGenerator.Next());
+            => $"{inputType.Name} ({inputType.FullName}) <{_idGenerator.Next():X8}>";
 
         private void FlushInputBuffer()
         {
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/GetMember.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/GetMember.cs
index 2fd9a4990..aa4773482 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/GetMember.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/GetMember.cs
@@ -230,8 +230,7 @@ namespace Microsoft.PowerShell.Commands
                 {
                     if (!Force)
                     {
-                        PSMethod memberAsPSMethod = member as PSMethod;
-                        if ((memberAsPSMethod != null) && (memberAsPSMethod.IsSpecial))
+                        if ((member is PSMethod memberAsPSMethod) && (memberAsPSMethod.IsSpecial))
                         {
                             continue;
                         }
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/GetRandomCommand.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/GetRandomCommand.cs
index 7d02713d8..e8114ca4e 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/GetRandomCommand.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/GetRandomCommand.cs
@@ -247,11 +247,11 @@ namespace Microsoft.PowerShell.Commands
             PSObject pso = PSObject.AsPSObject(o);
             object baseObject = pso.BaseObject;
 
-            if (baseObject is string)
+            if (baseObject is string s)
             {
                 // The type argument passed in does not decide the number type we want to convert to. ScanNumber will return
                 // int/long/double based on the string form number passed in.
-                baseObject = System.Management.Automation.Language.Parser.ScanNumber((string)baseObject, typeof(int));
+                baseObject = System.Management.Automation.Language.Parser.ScanNumber(s, typeof(int));
             }
 
             return baseObject;
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ImplicitRemotingCommands.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ImplicitRemotingCommands.cs
index d77225822..5a963e748 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ImplicitRemotingCommands.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ImplicitRemotingCommands.cs
@@ -725,12 +725,8 @@ namespace Microsoft.PowerShell.Commands
             string errorId;
             ErrorDetails errorDetails;
             ErrorRecord errorRecord;
-
-            //
-            // handle recognized types of exceptions first
-            //
-            RemoteException remoteException = runtimeException as RemoteException;
-            if ((remoteException != null) && (remoteException.SerializedRemoteException != null))
+            //            // handle recognized types of exceptions first            //
+            if ((runtimeException is RemoteException remoteException) && (remoteException.SerializedRemoteException != null))
             {
                 if (Deserializer.IsInstanceOfType(remoteException.SerializedRemoteException, typeof(CommandNotFoundException)))
                 {
@@ -1582,10 +1578,8 @@ namespace Microsoft.PowerShell.Commands
 
             powerShell.AddCommand("Get-FormatData");
             powerShell.AddParameter("TypeName", this.FormatTypeName);
-
             // For remote PS version 5.1 and greater, we need to include the new -PowerShellVersion parameter
-            RemoteRunspace remoteRunspace = Session.Runspace as RemoteRunspace;
-            if ((remoteRunspace != null) && (remoteRunspace.ServerVersion != null) &&
+            if ((Session.Runspace is RemoteRunspace remoteRunspace) && (remoteRunspace.ServerVersion != null) &&
                 (remoteRunspace.ServerVersion >= new Version(5, 1)))
             {
                 powerShell.AddParameter("PowerShellVersion", PSVersionInfo.PSVersion);
@@ -1951,20 +1945,17 @@ namespace Microsoft.PowerShell.Commands
         /// <returns>Connection URI associated with the remote runspace.</returns>
         private string GetConnectionString()
         {
-            WSManConnectionInfo connectionInfo = _remoteRunspaceInfo.Runspace.ConnectionInfo as WSManConnectionInfo;
-            if (connectionInfo != null)
+            if (_remoteRunspaceInfo.Runspace.ConnectionInfo is WSManConnectionInfo connectionInfo)
             {
                 return connectionInfo.ConnectionUri.ToString();
             }
 
-            VMConnectionInfo vmConnectionInfo = _remoteRunspaceInfo.Runspace.ConnectionInfo as VMConnectionInfo;
-            if (vmConnectionInfo != null)
+            if (_remoteRunspaceInfo.Runspace.ConnectionInfo is VMConnectionInfo vmConnectionInfo)
             {
                 return vmConnectionInfo.ComputerName;
             }
 
-            ContainerConnectionInfo containerConnectionInfo = _remoteRunspaceInfo.Runspace.ConnectionInfo as ContainerConnectionInfo;
-            if (containerConnectionInfo != null)
+            if (_remoteRunspaceInfo.Runspace.ConnectionInfo is ContainerConnectionInfo containerConnectionInfo)
             {
                 return containerConnectionInfo.ComputerName;
             }
@@ -2253,8 +2244,7 @@ function Get-PSImplicitRemotingSessionOption
         {
             StringBuilder result = new("& $script:NewPSSessionOption ");
 
-            RunspaceConnectionInfo runspaceConnectionInfo = _remoteRunspaceInfo.Runspace.ConnectionInfo as RunspaceConnectionInfo;
-            if (runspaceConnectionInfo != null)
+            if (_remoteRunspaceInfo.Runspace.ConnectionInfo is RunspaceConnectionInfo runspaceConnectionInfo)
             {
                 result.AppendFormat(null, "-Culture '{0}' ", CodeGeneration.EscapeSingleQuotedStringContent(runspaceConnectionInfo.Culture.ToString()));
                 result.AppendFormat(null, "-UICulture '{0}' ", CodeGeneration.EscapeSingleQuotedStringContent(runspaceConnectionInfo.UICulture.ToString()));
@@ -2265,8 +2255,7 @@ function Get-PSImplicitRemotingSessionOption
                 result.AppendFormat(null, "-OperationTimeOut {0} ", runspaceConnectionInfo.OperationTimeout);
             }
 
-            WSManConnectionInfo wsmanConnectionInfo = _remoteRunspaceInfo.Runspace.ConnectionInfo as WSManConnectionInfo;
-            if (wsmanConnectionInfo != null)
+            if (_remoteRunspaceInfo.Runspace.ConnectionInfo is WSManConnectionInfo wsmanConnectionInfo)
             {
                 if (!wsmanConnectionInfo.UseCompression) { result.Append("-NoCompression "); }
 
@@ -2525,8 +2514,7 @@ function Get-PSImplicitRemotingSession
 
         private string GenerateNewRunspaceExpression()
         {
-            VMConnectionInfo vmConnectionInfo = _remoteRunspaceInfo.Runspace.ConnectionInfo as VMConnectionInfo;
-            if (vmConnectionInfo != null)
+            if (_remoteRunspaceInfo.Runspace.ConnectionInfo is VMConnectionInfo vmConnectionInfo)
             {
                 string vmConfigurationName = vmConnectionInfo.ConfigurationName;
                 return string.Format(
@@ -2538,8 +2526,7 @@ function Get-PSImplicitRemotingSession
             }
             else
             {
-                ContainerConnectionInfo containerConnectionInfo = _remoteRunspaceInfo.Runspace.ConnectionInfo as ContainerConnectionInfo;
-                if (containerConnectionInfo != null)
+                if (_remoteRunspaceInfo.Runspace.ConnectionInfo is ContainerConnectionInfo containerConnectionInfo)
                 {
                     string containerConfigurationName = containerConnectionInfo.ContainerProc.ConfigurationName;
                     return string.Format(
@@ -2584,16 +2571,14 @@ function Get-PSImplicitRemotingSession
             WSManConnectionInfo connectionInfo = _remoteRunspaceInfo.Runspace.ConnectionInfo as WSManConnectionInfo;
             if (connectionInfo == null)
             {
-                VMConnectionInfo vmConnectionInfo = _remoteRunspaceInfo.Runspace.ConnectionInfo as VMConnectionInfo;
-                if (vmConnectionInfo != null)
+                if (_remoteRunspaceInfo.Runspace.ConnectionInfo is VMConnectionInfo vmConnectionInfo)
                 {
                     return string.Format(CultureInfo.InvariantCulture,
                         VMIdParameterTemplate,
                         CodeGeneration.EscapeSingleQuotedStringContent(vmConnectionInfo.VMGuid.ToString()));
                 }
 
-                ContainerConnectionInfo containerConnectionInfo = _remoteRunspaceInfo.Runspace.ConnectionInfo as ContainerConnectionInfo;
-                if (containerConnectionInfo != null)
+                if (_remoteRunspaceInfo.Runspace.ConnectionInfo is ContainerConnectionInfo containerConnectionInfo)
                 {
                     return string.Format(CultureInfo.InvariantCulture,
                         ContainerIdParameterTemplate,
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ShowMarkdownCommand.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ShowMarkdownCommand.cs
index 63ee15f6f..3f40ec343 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ShowMarkdownCommand.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/ShowMarkdownCommand.cs
@@ -224,10 +224,7 @@ namespace Microsoft.PowerShell.Commands
         /// </summary>
         protected override void EndProcessing()
         {
-            if (_powerShell != null)
-            {
-                _powerShell.Dispose();
-            }
+            _powerShell?.Dispose();
         }
     }
 }
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/StartSleepCommand.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/StartSleepCommand.cs
index a57d635f3..e67ffeabe 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/StartSleepCommand.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/StartSleepCommand.cs
@@ -82,10 +82,7 @@ namespace Microsoft.PowerShell.Commands
                 }
             }
 
-            if (_waitHandle != null)
-            {
-                _waitHandle.WaitOne(milliSecondsToSleep, true);
-            }
+            _waitHandle?.WaitOne(milliSecondsToSleep, true);
         }
 
         /// <summary>
@@ -121,10 +118,7 @@ namespace Microsoft.PowerShell.Commands
             lock (_syncObject)
             {
                 _stopping = true;
-                if (_waitHandle != null)
-                {
-                    _waitHandle.Set();
-                }
+                _waitHandle?.Set();
             }
         }
 
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/Update-TypeData.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/Update-TypeData.cs
index d13752462..0ef850947 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/Update-TypeData.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/Update-TypeData.cs
@@ -596,9 +596,9 @@ namespace Microsoft.PowerShell.Commands
 
         private void EnsureValue1NotNullOrEmpty()
         {
-            if (_value1 is string)
+            if (_value1 is string s)
             {
-                if (string.IsNullOrEmpty((string)_value1))
+                if (string.IsNullOrEmpty(s))
                 {
                     ThrowTerminatingError(NewError("ValueShouldBeSpecified", UpdateDataStrings.ShouldNotBeNull, null, "Value", _memberType));
                 }
@@ -1371,23 +1371,23 @@ namespace Microsoft.PowerShell.Commands
         {
             string typeName;
             object target = PSObject.Base(inputData);
-            if (target is Type)
+            if (target is Type @type)
             {
-                typeName = ((Type)target).FullName;
+                typeName = @type.FullName;
             }
-            else if (target is string)
+            else if (target is string s)
             {
                 // Respect the type shortcut
                 Type type;
-                typeName = (string)target;
+                typeName = s;
                 if (LanguagePrimitives.TryConvertTo(typeName, out type))
                 {
                     typeName = type.FullName;
                 }
             }
-            else if (target is TypeData)
+            else if (target is TypeData typeData)
             {
-                typeName = ((TypeData)target).TypeName;
+                typeName = typeData.TypeName;
             }
             else
             {
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/ContentHelper.Common.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/ContentHelper.Common.cs
index f16ad99d2..0272cd9e9 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/ContentHelper.Common.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/ContentHelper.Common.cs
@@ -168,8 +168,7 @@ namespace Microsoft.PowerShell.Commands
                 {
                     if (contentTypeKey != null)
                     {
-                        string extension = contentTypeKey.GetValue("Extension") as string;
-                        if (extension != null)
+                        if (contentTypeKey.GetValue("Extension") is string extension)
                         {
                             using (RegistryKey extensionKey = Registry.ClassesRoot.OpenSubKey(extension))
                             {
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/WebRequestPSCmdlet.Common.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/WebRequestPSCmdlet.Common.cs
index 3423b912f..84941e8eb 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/WebRequestPSCmdlet.Common.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/WebRequestPSCmdlet.Common.cs
@@ -826,14 +826,14 @@ namespace Microsoft.PowerShell.Commands
         private string GetBasicAuthorizationHeader()
         {
             var password = new NetworkCredential(null, Credential.Password).Password;
-            string unencoded = string.Format("{0}:{1}", Credential.UserName, password);
+            string unencoded = $"{Credential.UserName}:{password}";
             byte[] bytes = Encoding.UTF8.GetBytes(unencoded);
-            return string.Format("Basic {0}", Convert.ToBase64String(bytes));
+            return $"Basic {Convert.ToBase64String(bytes)}";
         }
 
         private string GetBearerAuthorizationHeader()
         {
-            return string.Format("Bearer {0}", new NetworkCredential(string.Empty, Token).Password);
+            return $"Bearer {new NetworkCredential(string.Empty, Token).Password}";
         }
 
         private void ProcessAuthentication()
@@ -848,7 +848,7 @@ namespace Microsoft.PowerShell.Commands
             }
             else
             {
-                Diagnostics.Assert(false, string.Format("Unrecognized Authentication value: {0}", Authentication));
+                Diagnostics.Assert(false, $"Unrecognized Authentication value: {Authentication}");
             }
         }
 
@@ -1207,8 +1207,7 @@ namespace Microsoft.PowerShell.Commands
                 object content = Body;
 
                 // make sure we're using the base object of the body, not the PSObject wrapper
-                PSObject psBody = Body as PSObject;
-                if (psBody != null)
+                if (Body is PSObject psBody)
                 {
                     content = psBody.BaseObject;
                 }
@@ -1555,10 +1554,7 @@ namespace Microsoft.PowerShell.Commands
                                     }
                                     finally
                                     {
-                                        if (reader != null)
-                                        {
-                                            reader.Dispose();
-                                        }
+                                        reader?.Dispose();
                                     }
 
                                     if (!string.IsNullOrEmpty(detailMsg))
@@ -1636,10 +1632,7 @@ namespace Microsoft.PowerShell.Commands
         /// </summary>
         protected override void StopProcessing()
         {
-            if (_cancelToken != null)
-            {
-                _cancelToken.Cancel();
-            }
+            _cancelToken?.Cancel();
         }
 
         #endregion Overrides
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/WebResponseObject.Common.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/WebResponseObject.Common.cs
index 98e7c397e..449577630 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/WebResponseObject.Common.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/Common/WebResponseObject.Common.cs
@@ -187,8 +187,7 @@ namespace Microsoft.PowerShell.Commands
 
             BaseResponse = response;
 
-            MemoryStream ms = contentStream as MemoryStream;
-            if (ms != null)
+            if (contentStream is MemoryStream ms)
             {
                 _rawContentStream = ms;
             }
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/JsonObject.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/JsonObject.cs
index 9f1d2b1c8..773a15507 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/JsonObject.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WebCmdlet/JsonObject.cs
@@ -505,9 +505,7 @@ namespace Microsoft.PowerShell.Commands
                 return null;
             }
 
-            PSObject pso = obj as PSObject;
-
-            if (pso != null)
+            if (obj is PSObject pso)
             {
                 obj = pso.BaseObject;
             }
@@ -574,7 +572,7 @@ namespace Microsoft.PowerShell.Commands
                             context.Cmdlet.WriteWarning(maxDepthMessage);
                         }
 
-                        if (pso != null && pso.ImmediateBaseObjectIsEmpty)
+                        if (obj is PSObject pso && pso.ImmediateBaseObjectIsEmpty)
                         {
                             // The obj is a pure PSObject, we convert the original PSObject to a string,
                             // instead of its base object in this case
@@ -590,15 +588,13 @@ namespace Microsoft.PowerShell.Commands
                     }
                     else
                     {
-                        IDictionary dict = obj as IDictionary;
-                        if (dict != null)
+                        if (obj is IDictionary dict)
                         {
                             rv = ProcessDictionary(dict, currentDepth, in context);
                         }
                         else
                         {
-                            IEnumerable enumerable = obj as IEnumerable;
-                            if (enumerable != null)
+                            if (obj is IEnumerable enumerable)
                             {
                                 rv = ProcessEnumerable(enumerable, currentDepth, in context);
                             }
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/Write.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/Write.cs
index bf9072035..520c6fedc 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/Write.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/Write.cs
@@ -28,20 +28,13 @@ namespace Microsoft.PowerShell.Commands
         /// </summary>
         protected override void ProcessRecord()
         {
-            //
-            // The write-debug command must use the script's InvocationInfo rather than its own,
-            // so we create the DebugRecord here and fill it up with the appropriate InvocationInfo;
-            // then, we call the command runtime directly and pass this record to WriteDebug().
-            //
-            MshCommandRuntime mshCommandRuntime = this.CommandRuntime as MshCommandRuntime;
-
-            if (mshCommandRuntime != null)
+            //            // The write-debug command must use the script's InvocationInfo rather than its own,            // so we create the DebugRecord here and fill it up with the appropriate InvocationInfo;            // then, we call the command runtime directly and pass this record to WriteDebug().            //
+
+            if (this.CommandRuntime is MshCommandRuntime mshCommandRuntime)
             {
                 DebugRecord record = new(Message);
 
-                InvocationInfo invocationInfo = GetVariableValue(SpecialVariables.MyInvocation) as InvocationInfo;
-
-                if (invocationInfo != null)
+                if (GetVariableValue(SpecialVariables.MyInvocation) is InvocationInfo invocationInfo)
                 {
                     record.SetInvocationInfo(invocationInfo);
                 }
@@ -76,20 +69,13 @@ namespace Microsoft.PowerShell.Commands
         /// </summary>
         protected override void ProcessRecord()
         {
-            //
-            // The write-verbose command must use the script's InvocationInfo rather than its own,
-            // so we create the VerboseRecord here and fill it up with the appropriate InvocationInfo;
-            // then, we call the command runtime directly and pass this record to WriteVerbose().
-            //
-            MshCommandRuntime mshCommandRuntime = this.CommandRuntime as MshCommandRuntime;
-
-            if (mshCommandRuntime != null)
+            //            // The write-verbose command must use the script's InvocationInfo rather than its own,            // so we create the VerboseRecord here and fill it up with the appropriate InvocationInfo;            // then, we call the command runtime directly and pass this record to WriteVerbose().            //
+
+            if (this.CommandRuntime is MshCommandRuntime mshCommandRuntime)
             {
                 VerboseRecord record = new(Message);
 
-                InvocationInfo invocationInfo = GetVariableValue(SpecialVariables.MyInvocation) as InvocationInfo;
-
-                if (invocationInfo != null)
+                if (GetVariableValue(SpecialVariables.MyInvocation) is InvocationInfo invocationInfo)
                 {
                     record.SetInvocationInfo(invocationInfo);
                 }
@@ -124,20 +110,13 @@ namespace Microsoft.PowerShell.Commands
         /// </summary>
         protected override void ProcessRecord()
         {
-            //
-            // The write-warning command must use the script's InvocationInfo rather than its own,
-            // so we create the WarningRecord here and fill it up with the appropriate InvocationInfo;
-            // then, we call the command runtime directly and pass this record to WriteWarning().
-            //
-            MshCommandRuntime mshCommandRuntime = this.CommandRuntime as MshCommandRuntime;
-
-            if (mshCommandRuntime != null)
+            //            // The write-warning command must use the script's InvocationInfo rather than its own,            // so we create the WarningRecord here and fill it up with the appropriate InvocationInfo;            // then, we call the command runtime directly and pass this record to WriteWarning().            //
+
+            if (this.CommandRuntime is MshCommandRuntime mshCommandRuntime)
             {
                 WarningRecord record = new(Message);
 
-                InvocationInfo invocationInfo = GetVariableValue(SpecialVariables.MyInvocation) as InvocationInfo;
-
-                if (invocationInfo != null)
+                if (GetVariableValue(SpecialVariables.MyInvocation) is InvocationInfo invocationInfo)
                 {
                     record.SetInvocationInfo(invocationInfo);
                 }
@@ -363,12 +342,8 @@ namespace Microsoft.PowerShell.Commands
             }
             else
             {
-            */
-
-            // 2005/07/14-913791 "write-error output is confusing and misleading"
-            // set InvocationInfo to the script not the command
-            InvocationInfo myInvocation = GetVariableValue(SpecialVariables.MyInvocation) as InvocationInfo;
-            if (myInvocation != null)
+            */            // 2005/07/14-913791 "write-error output is confusing and misleading"            // set InvocationInfo to the script not the command
+            if (GetVariableValue(SpecialVariables.MyInvocation) is InvocationInfo myInvocation)
             {
                 errorRecord.SetInvocationInfo(myInvocation);
                 errorRecord.PreserveInvocationInfoOnce = true;
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WriteConsoleCmdlet.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WriteConsoleCmdlet.cs
index 2d2009e56..faa5e6c39 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WriteConsoleCmdlet.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/WriteConsoleCmdlet.cs
@@ -51,9 +51,9 @@ namespace Microsoft.PowerShell.Commands
         {
             if (o != null)
             {
-                string s = o as string;
                 IEnumerable enumerable = null;
-                if (s != null)
+
+                if (o is string s)
                 {
                     // strings are IEnumerable, so we special case them
                     if (s.Length > 0)
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/XmlCommands.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/XmlCommands.cs
index 8db56196a..62f98e840 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/XmlCommands.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/XmlCommands.cs
@@ -763,12 +763,10 @@ namespace Microsoft.PowerShell.Commands
                 while (!_deserializer.Done() && count < first)
                 {
                     object result = _deserializer.Deserialize();
-                    PSObject psObject = result as PSObject;
 
-                    if (psObject != null)
+                    if (result is PSObject psObject)
                     {
-                        ICollection c = psObject.BaseObject as ICollection;
-                        if (c != null)
+                        if (psObject.BaseObject is ICollection c)
                         {
                             foreach (object o in c)
                             {
@@ -803,10 +801,7 @@ namespace Microsoft.PowerShell.Commands
 
         internal void Stop()
         {
-            if (_deserializer != null)
-            {
-                _deserializer.Stop();
-            }
+            _deserializer?.Stop();
         }
     }
 
diff --git a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/trace/TraceExpressionCommand.cs b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/trace/TraceExpressionCommand.cs
index 412f4a2d1..96a5d79df 100644
--- a/src/Microsoft.PowerShell.Commands.Utility/commands/utility/trace/TraceExpressionCommand.cs
+++ b/src/Microsoft.PowerShell.Commands.Utility/commands/utility/trace/TraceExpressionCommand.cs
@@ -251,10 +251,7 @@ namespace Microsoft.PowerShell.Commands
         /// </summary>
         protected override void StopProcessing()
         {
-            if (_pipeline != null)
-            {
-                _pipeline.Stop();
-            }
+            _pipeline?.Stop();
         }
 
         #endregion Cmdlet code
@@ -525,8 +522,8 @@ namespace Microsoft.PowerShell.Commands
         private static ErrorRecord ConvertToErrorRecord(object obj)
         {
             ErrorRecord result = null;
-            PSObject mshobj = obj as PSObject;
-            if (mshobj != null)
+
+            if (obj is PSObject mshobj)
             {
                 object baseObject = mshobj.BaseObject;
                 if (baseObject is not PSCustomObject)
@@ -535,8 +532,7 @@ namespace Microsoft.PowerShell.Commands
                 }
             }
 
-            ErrorRecord errorRecordResult = obj as ErrorRecord;
-            if (errorRecordResult != null)
+            if (obj is ErrorRecord errorRecordResult)
             {
                 result = errorRecordResult;
             }
diff --git a/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHost.cs b/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHost.cs
index 9de877ba4..769390c49 100644
--- a/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHost.cs
+++ b/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHost.cs
@@ -250,13 +250,7 @@ namespace Microsoft.PowerShell
             }
             finally
             {
-                if (s_theConsoleHost != null)
-                {
-#if LEGACYTELEMETRY
-                    TelemetryAPI.ReportExitTelemetry(s_theConsoleHost);
-#endif
-                    s_theConsoleHost.Dispose();
-                }
+                s_theConsoleHost?.Dispose();
             }
 
             unchecked
@@ -464,10 +458,7 @@ namespace Microsoft.PowerShell
                     if (runspaceRef != null)
                     {
                         var runspace = runspaceRef.Runspace;
-                        if (runspace != null)
-                        {
-                            runspace.Close();
-                        }
+                        runspace?.Close();
                     }
                 }
             }
@@ -1222,15 +1213,9 @@ namespace Microsoft.PowerShell
                         StopTranscribing();
                     }
 
-                    if (_outputSerializer != null)
-                    {
-                        _outputSerializer.End();
-                    }
+                    _outputSerializer?.End();
 
-                    if (_errorSerializer != null)
-                    {
-                        _errorSerializer.End();
-                    }
+                    _errorSerializer?.End();
 
                     if (_runspaceRef != null)
                     {
@@ -2053,9 +2038,7 @@ namespace Microsoft.PowerShell
 
             // NTRAID#Windows OS Bugs-1143621-2005/04/08-sburns
 
-            IContainsErrorRecord icer = e as IContainsErrorRecord;
-
-            if (icer != null)
+            if (e is IContainsErrorRecord icer)
             {
                 error = icer.ErrorRecord;
             }
@@ -2112,8 +2095,8 @@ namespace Microsoft.PowerShell
 
             // See if the exception has an error record attached to it...
             ErrorRecord er = null;
-            IContainsErrorRecord icer = e as IContainsErrorRecord;
-            if (icer != null)
+
+            if (e is IContainsErrorRecord icer)
                 er = icer.ErrorRecord;
 
             if (e is PSRemotingTransportException)
@@ -2131,7 +2114,7 @@ namespace Microsoft.PowerShell
             }
 
             // Add the position message for the error if it's available.
-            if (er != null && er.InvocationInfo != null)
+            if (er?.InvocationInfo != null)
                 Console.Error.WriteLine(er.InvocationInfo.PositionMessage);
         }
 
@@ -2168,10 +2151,7 @@ namespace Microsoft.PowerShell
                     // For remote debugging block data coming from the main (not-nested)
                     // running command.
                     baseLoop = InputLoop.GetNonNestedLoop();
-                    if (baseLoop != null)
-                    {
-                        baseLoop.BlockCommandOutput();
-                    }
+                    baseLoop?.BlockCommandOutput();
                 }
 
                 //
@@ -2216,10 +2196,7 @@ namespace Microsoft.PowerShell
             finally
             {
                 _debuggerStopEventArgs = null;
-                if (baseLoop != null)
-                {
-                    baseLoop.ResumeCommandOutput();
-                }
+                baseLoop?.ResumeCommandOutput();
             }
         }
 
@@ -2551,8 +2528,7 @@ namespace Microsoft.PowerShell
                                 var ex = e as PSInvalidOperationException;
                                 if (e is PSRemotingTransportException ||
                                     e is RemoteException ||
-                                    (ex != null &&
-                                     ex.ErrorRecord != null &&
+                                    (ex?.ErrorRecord != null &&
                                      ex.ErrorRecord.FullyQualifiedErrorId.Equals("Debugger:CannotProcessCommandNotStopped", StringComparison.OrdinalIgnoreCase)))
                                 {
                                     // Debugger session is broken.  Exit nested loop.
@@ -2592,10 +2568,7 @@ namespace Microsoft.PowerShell
                                 bht = _parent._breakHandlerThread;
                             }
 
-                            if (bht != null)
-                            {
-                                bht.Join();
-                            }
+                            bht?.Join();
 
                             // Once the pipeline has been executed, we toss any outstanding progress data and
                             // take down the display.
@@ -2634,8 +2607,7 @@ namespace Microsoft.PowerShell
 
             internal void BlockCommandOutput()
             {
-                RemotePipeline rCmdPipeline = _parent.runningCmd as RemotePipeline;
-                if (rCmdPipeline != null)
+                if (_parent.runningCmd is RemotePipeline rCmdPipeline)
                 {
                     rCmdPipeline.DrainIncomingData();
                     rCmdPipeline.SuspendIncomingData();
@@ -2648,8 +2620,7 @@ namespace Microsoft.PowerShell
 
             internal void ResumeCommandOutput()
             {
-                RemotePipeline rCmdPipeline = _parent.runningCmd as RemotePipeline;
-                if (rCmdPipeline != null)
+                if (_parent.runningCmd is RemotePipeline rCmdPipeline)
                 {
                     rCmdPipeline.ResumeIncomingData();
                 }
@@ -2799,8 +2770,7 @@ namespace Microsoft.PowerShell
                 // Check for the pushed runspace scenario.
                 if (_isRunspacePushed)
                 {
-                    RemoteRunspace remoteRunspace = _parent.Runspace as RemoteRunspace;
-                    if (remoteRunspace != null)
+                    if (_parent.Runspace is RemoteRunspace remoteRunspace)
                     {
                         promptString = HostUtilities.GetRemotePrompt(remoteRunspace, promptString, _parent._inPushedConfiguredSession);
                     }
@@ -2836,8 +2806,7 @@ namespace Microsoft.PowerShell
                 string promptString = (prompt != null) ? (prompt.BaseObject as string) : null;
                 if (promptString != null)
                 {
-                    RemoteRunspace remoteRunspace = _parent.Runspace as RemoteRunspace;
-                    if (remoteRunspace != null)
+                    if (_parent.Runspace is RemoteRunspace remoteRunspace)
                     {
                         promptString = HostUtilities.GetRemotePrompt(remoteRunspace, promptString, _parent._inPushedConfiguredSession);
                     }
diff --git a/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHostUserInterfaceProgress.cs b/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHostUserInterfaceProgress.cs
index 50dedf410..13f5e7b0b 100644
--- a/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHostUserInterfaceProgress.cs
+++ b/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHostUserInterfaceProgress.cs
@@ -110,20 +110,14 @@ namespace Microsoft.PowerShell
         void
         PreWrite()
         {
-            if (_progPane != null)
-            {
-                _progPane.Hide();
-            }
+            _progPane?.Hide();
         }
 
         private
         void
         PostWrite()
         {
-            if (_progPane != null)
-            {
-                _progPane.Show();
-            }
+            _progPane?.Show();
         }
 
         private
@@ -149,20 +143,14 @@ namespace Microsoft.PowerShell
         void
         PreRead()
         {
-            if (_progPane != null)
-            {
-                _progPane.Hide();
-            }
+            _progPane?.Hide();
         }
 
         private
         void
         PostRead()
         {
-            if (_progPane != null)
-            {
-                _progPane.Show();
-            }
+            _progPane?.Show();
         }
 
         private
diff --git a/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHostUserInterfacePrompt.cs b/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHostUserInterfacePrompt.cs
index 6d7caefec..28a2ed1d5 100644
--- a/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHostUserInterfacePrompt.cs
+++ b/src/Microsoft.PowerShell.ConsoleHost/host/msh/ConsoleHostUserInterfacePrompt.cs
@@ -380,8 +380,7 @@ namespace Microsoft.PowerShell
                 else
                 {
                     object userInput = ReadLineSafe(false, null);
-                    string userInputString = userInput as string;
-                    System.Management.Automation.Diagnostics.Assert(userInputString != null, "ReadLineSafe did not return a string");
+                    System.Management.Automation.Diagnostics.Assert(userInput is string userInputString, "ReadLineSafe did not return a string");
                     rawInputString = userInputString;
                 }
 
diff --git a/src/Microsoft.PowerShell.ConsoleHost/host/msh/Executor.cs b/src/Microsoft.PowerShell.ConsoleHost/host/msh/Executor.cs
index 68df51be5..35bfe94b6 100644
--- a/src/Microsoft.PowerShell.ConsoleHost/host/msh/Executor.cs
+++ b/src/Microsoft.PowerShell.ConsoleHost/host/msh/Executor.cs
@@ -107,8 +107,8 @@ namespace Microsoft.PowerShell
         private void AsyncPipelineFailureHandler(Exception ex)
         {
             ErrorRecord er = null;
-            IContainsErrorRecord cer = ex as IContainsErrorRecord;
-            if (cer != null)
+
+            if (ex is IContainsErrorRecord cer)
             {
                 er = cer.ErrorRecord;
                 // Exception inside the error record is ParentContainsErrorRecordException which
@@ -499,11 +499,8 @@ namespace Microsoft.PowerShell
                 if (streamResults[0] == null)
                     return string.Empty;
 
-                // And convert the base object into a string. We can't use the proxied
-                // ToString() on the PSObject because there is no default runspace
-                // available.
-                PSObject msho = streamResults[0] as PSObject;
-                if (msho != null)
+                // And convert the base object into a string. We can't use the proxied                // ToString() on the PSObject because there is no default runspace                // available.
+                if (streamResults[0] is PSObject msho)
                     result = msho.BaseObject.ToString();
                 else
                     result = streamResults[0].ToString();
@@ -605,8 +602,7 @@ namespace Microsoft.PowerShell
 
         internal void BlockCommandOutput()
         {
-            RemotePipeline remotePipeline = _pipeline as RemotePipeline;
-            if (remotePipeline != null)
+            if (_pipeline is RemotePipeline remotePipeline)
             {
                 // Waits until queued data is handled.
                 remotePipeline.DrainIncomingData();
@@ -619,11 +615,7 @@ namespace Microsoft.PowerShell
         internal void ResumeCommandOutput()
         {
             RemotePipeline remotePipeline = _pipeline as RemotePipeline;
-            if (remotePipeline != null)
-            {
-                // Resumes data flow.
-                remotePipeline.ResumeIncomingData();
-            }
+            remotePipeline?.ResumeIncomingData();
         }
 
         /// <summary>
@@ -717,10 +709,7 @@ namespace Microsoft.PowerShell
                 temp = s_currentExecutor;
             }
 
-            if (temp != null)
-            {
-                temp.Cancel();
-            }
+            temp?.Cancel();
         }
 
         // These statics are threadsafe, as there can be only one instance of ConsoleHost in a process at a time, and access
diff --git a/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/EventProvider.cs b/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/EventProvider.cs
index d4e566890..ae843c1a9 100644
--- a/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/EventProvider.cs
+++ b/src/Microsoft.PowerShell.CoreCLR.Eventing/DotNetCode/Eventing/EventProvider.cs
@@ -291,8 +291,7 @@ namespace System.Diagnostics.Eventing
         {
             dataDescriptor->Reserved = 0;
 
-            string sRet = data as string;
-            if (sRet != null)
+            if (data is string sRet)
             {
                 dataDescriptor->Size = (uint)((sRet.Length + 1) * 2);
                 return sRet;
@@ -303,32 +302,32 @@ namespace System.Diagnostics.Eventing
                 dataDescriptor->Size = 0;
                 dataDescriptor->DataPointer = 0;
             }
-            else if (data is IntPtr)
+            else if (data is IntPtr intPtr)
             {
                 dataDescriptor->Size = (uint)sizeof(IntPtr);
                 IntPtr* intptrPtr = (IntPtr*)dataBuffer;
-                *intptrPtr = (IntPtr)data;
+                *intptrPtr = intPtr;
                 dataDescriptor->DataPointer = (ulong)intptrPtr;
             }
-            else if (data is int)
+            else if (data is int i)
             {
                 dataDescriptor->Size = (uint)sizeof(int);
                 int* intptrPtr = (int*)dataBuffer;
-                *intptrPtr = (int)data;
+                *intptrPtr = i;
                 dataDescriptor->DataPointer = (ulong)intptrPtr;
             }
-            else if (data is long)
+            else if (data is long l)
             {
                 dataDescriptor->Size = (uint)sizeof(long);
                 long* longptr = (long*)dataBuffer;
-                *longptr = (long)data;
+                *longptr = l;
                 dataDescriptor->DataPointer = (ulong)longptr;
             }
-            else if (data is uint)
+            else if (data is uint ui)
             {
                 dataDescriptor->Size = (uint)sizeof(uint);
                 uint* uintptr = (uint*)dataBuffer;
-                *uintptr = (uint)data;
+                *uintptr = ui;
                 dataDescriptor->DataPointer = (ulong)uintptr;
             }
             else if (data is UInt64)
@@ -338,74 +337,74 @@ namespace System.Diagnostics.Eventing
                 *ulongptr = (ulong)data;
                 dataDescriptor->DataPointer = (ulong)ulongptr;
             }
-            else if (data is char)
+            else if (data is char c)
             {
                 dataDescriptor->Size = (uint)sizeof(char);
                 char* charptr = (char*)dataBuffer;
-                *charptr = (char)data;
+                *charptr = c;
                 dataDescriptor->DataPointer = (ulong)charptr;
             }
-            else if (data is byte)
+            else if (data is byte b)
             {
                 dataDescriptor->Size = (uint)sizeof(byte);
                 byte* byteptr = (byte*)dataBuffer;
-                *byteptr = (byte)data;
+                *byteptr = b;
                 dataDescriptor->DataPointer = (ulong)byteptr;
             }
-            else if (data is short)
+            else if (data is short sh)
             {
                 dataDescriptor->Size = (uint)sizeof(short);
                 short* shortptr = (short*)dataBuffer;
-                *shortptr = (short)data;
+                *shortptr = sh;
                 dataDescriptor->DataPointer = (ulong)shortptr;
             }
-            else if (data is sbyte)
+            else if (data is sbyte sb)
             {
                 dataDescriptor->Size = (uint)sizeof(sbyte);
                 sbyte* sbyteptr = (sbyte*)dataBuffer;
-                *sbyteptr = (sbyte)data;
+                *sbyteptr = sb;
                 dataDescriptor->DataPointer = (ulong)sbyteptr;
             }
-            else if (data is ushort)
+            else if (data is ushort us)
             {
                 dataDescriptor->Size = (uint)sizeof(ushort);
                 ushort* ushortptr = (ushort*)dataBuffer;
-                *ushortptr = (ushort)data;
+                *ushortptr = us;
                 dataDescriptor->DataPointer = (ulong)ushortptr;
             }
-            else if (data is float)
+            else if (data is float f)
             {
                 dataDescriptor->Size = (uint)sizeof(float);
                 float* floatptr = (float*)dataBuffer;
-                *floatptr = (float)data;
+                *floatptr = f;
                 dataDescriptor->DataPointer = (ulong)floatptr;
             }
-            else if (data is double)
+            else if (data is double d)
             {
                 dataDescriptor->Size = (uint)sizeof(double);
                 double* doubleptr = (double*)dataBuffer;
-                *doubleptr = (double)data;
+                *doubleptr = d;
                 dataDescriptor->DataPointer = (ulong)doubleptr;
             }
-            else if (data is bool)
+            else if (data is bool b)
             {
                 dataDescriptor->Size = (uint)sizeof(bool);
                 bool* boolptr = (bool*)dataBuffer;
-                *boolptr = (bool)data;
+                *boolptr = b;
                 dataDescriptor->DataPointer = (ulong)boolptr;
             }
-            else if (data is Guid)
+            else if (data is Guid guid)
             {
                 dataDescriptor->Size = (uint)sizeof(Guid);
                 Guid* guidptr = (Guid*)dataBuffer;
-                *guidptr = (Guid)data;
+                *guidptr = guid;
                 dataDescriptor->DataPointer = (ulong)guidptr;
             }
-            else if (data is decimal)
+            else if (data is decimal d)
             {
                 dataDescriptor->Size = (uint)sizeof(decimal);
                 decimal* decimalptr = (decimal*)dataBuffer;
-                *decimalptr = (decimal)data;
+                *decimalptr = d;
                 dataDescriptor->DataPointer = (ulong)decimalptr;
             }
             else
diff --git a/src/Microsoft.PowerShell.Security/security/CertificateProvider.cs b/src/Microsoft.PowerShell.Security/security/CertificateProvider.cs
index d0c71e822..5c98f1fbb 100644
--- a/src/Microsoft.PowerShell.Security/security/CertificateProvider.cs
+++ b/src/Microsoft.PowerShell.Security/security/CertificateProvider.cs
@@ -725,9 +725,7 @@ namespace Microsoft.PowerShell.Commands
 
             if (DynamicParameters != null)
             {
-                ProviderRemoveItemDynamicParameters dp =
-                    DynamicParameters as ProviderRemoveItemDynamicParameters;
-                if (dp != null)
+                if (DynamicParameters is ProviderRemoveItemDynamicParameters dp)
                 {
                     if (dp.DeleteKey)
                     {
@@ -887,9 +885,8 @@ namespace Microsoft.PowerShell.Commands
                 object store = GetItemAtPath(destination, false, out isDestContainer);
 
                 X509Certificate2 certificate = cert as X509Certificate2;
-                X509NativeStore certstore = store as X509NativeStore;
 
-                if (certstore != null)
+                if (store is X509NativeStore certstore)
                 {
                     certstore.Open(true);
 
@@ -1067,15 +1064,13 @@ namespace Microsoft.PowerShell.Commands
 
             if ((item != null) && isContainer)
             {
-                X509StoreLocation storeLocation = item as X509StoreLocation;
-                if (storeLocation != null)
+                if (item is X509StoreLocation storeLocation)
                 {
                     result = storeLocation.StoreNames.Count > 0;
                 }
                 else
                 {
-                    X509NativeStore store = item as X509NativeStore;
-                    if (store != null)
+                    if (item is X509NativeStore store)
                     {
                         store.Open(IncludeArchivedCerts());
                         IntPtr certContext = store.GetFirstCert();
@@ -1239,10 +1234,8 @@ namespace Microsoft.PowerShell.Commands
                     }
                     else
                     {
-                        // The filter is non null. If the certificate
-                        // satisfies the filter, output it. Otherwise, don't.
-                        X509Certificate2 cert = item as X509Certificate2;
-                        Dbg.Diagnostics.Assert(cert != null, "item should be a certificate");
+                        // The filter is non null. If the certificate                        // satisfies the filter, output it. Otherwise, don't.
+                        Dbg.Diagnostics.Assert(item is X509Certificate2 cert, "item should be a certificate");
 
                         if (MatchesFilter(cert, filter))
                         {
@@ -1258,15 +1251,13 @@ namespace Microsoft.PowerShell.Commands
                         return;
                     }
 
-                    X509StoreLocation storeLocation = item as X509StoreLocation;
-                    if (storeLocation != null)  // store location
+                    if (item is X509StoreLocation storeLocation)  // store location
                     {
                         WriteItemObject(item, path, isContainer);
                     }
                     else // store
                     {
-                        X509NativeStore store = item as X509NativeStore;
-                        if (store != null)
+                        if (item is X509NativeStore store)
                         {
                             // create X509Store
                             X509Store outStore = new(store.StoreName, store.Location.Location);
@@ -2648,9 +2639,7 @@ namespace Microsoft.PowerShell.Commands
 
             if (DynamicParameters != null)
             {
-                CertificateProviderDynamicParameters dp =
-                    DynamicParameters as CertificateProviderDynamicParameters;
-                if (dp != null)
+                if (DynamicParameters is CertificateProviderDynamicParameters dp)
                 {
                     if (dp.CodeSigningCert)
                     {
diff --git a/src/Microsoft.WSMan.Management/ConfigProvider.cs b/src/Microsoft.WSMan.Management/ConfigProvider.cs
index 9e3d9bd05..0d37c19eb 100644
--- a/src/Microsoft.WSMan.Management/ConfigProvider.cs
+++ b/src/Microsoft.WSMan.Management/ConfigProvider.cs
@@ -1023,9 +1023,7 @@ namespace Microsoft.WSMan.Management
                         {
                             if (WSManStringLiterals.ConfigRunAsUserName.Equals(ChildName, StringComparison.OrdinalIgnoreCase))
                             {
-                                PSCredential runAsCredentials = value as PSCredential;
-
-                                if (runAsCredentials != null)
+                                if (value is PSCredential runAsCredentials)
                                 {
                                     // UserName
                                     value = runAsCredentials.UserName;
@@ -1301,8 +1299,7 @@ namespace Microsoft.WSMan.Management
                                     }
                                 }
 
-                                WSManProviderSetItemDynamicParameters dynParams = DynamicParameters as WSManProviderSetItemDynamicParameters;
-                                if (dynParams != null)
+                                if (DynamicParameters is WSManProviderSetItemDynamicParameters dynParams)
                                 {
                                     if (dynParams.Concatenate)
                                     {
@@ -1965,9 +1962,9 @@ namespace Microsoft.WSMan.Management
         private void NewItemCreateComputerConnection(string Name)
         {
             helper = new WSManHelper(this);
-            WSManProviderNewItemComputerParameters dynParams = DynamicParameters as WSManProviderNewItemComputerParameters;
             string parametersetName = "ComputerName";
-            if (dynParams != null)
+
+            if (DynamicParameters is WSManProviderNewItemComputerParameters dynParams)
             {
                 if (dynParams.ConnectionURI != null)
                 {
@@ -2064,8 +2061,7 @@ namespace Microsoft.WSMan.Management
             // to create a new plugin
             if (path.EndsWith(strPathChk, StringComparison.OrdinalIgnoreCase))
             {
-                WSManProviderNewItemPluginParameters niParams = DynamicParameters as WSManProviderNewItemPluginParameters;
-                if (niParams != null)
+                if (DynamicParameters is WSManProviderNewItemPluginParameters niParams)
                 {
                     if (string.IsNullOrEmpty(niParams.File))
                     {
@@ -2155,8 +2151,7 @@ namespace Microsoft.WSMan.Management
                     strPathChk += WSManStringLiterals.containerResources;
                     if (path.EndsWith(strPathChk, StringComparison.OrdinalIgnoreCase))
                     {
-                        WSManProviderNewItemResourceParameters niParams = DynamicParameters as WSManProviderNewItemResourceParameters;
-                        if (niParams != null)
+                        if (DynamicParameters is WSManProviderNewItemPluginParameters niParams)
                         {
                             mshObj.Properties.Add(new PSNoteProperty("Resource", niParams.ResourceUri));
                             mshObj.Properties.Add(new PSNoteProperty("Capability", niParams.Capability));
@@ -2211,8 +2206,6 @@ namespace Microsoft.WSMan.Management
                             AssertError(message, false);
                             return; // AssertError is going to throw - return silences some static analysis tools
                         }
-
-                        WSManProviderNewItemSecurityParameters niParams = DynamicParameters as WSManProviderNewItemSecurityParameters;
                         mshObj.Properties.Add(new PSNoteProperty("Uri", resourceDirProperties.Properties["ResourceUri"].Value));
                         mshObj.Properties.Add(new PSNoteProperty("Sddl", niParams.Sddl));
 
@@ -2239,7 +2232,6 @@ namespace Microsoft.WSMan.Management
 
                 if (path.EndsWith(strPathChk + WSManStringLiterals.containerInitParameters, StringComparison.OrdinalIgnoreCase))
                 {
-                    WSManProviderInitializeParameters niParams = DynamicParameters as WSManProviderInitializeParameters;
                     mshObj.Properties.Add(new PSNoteProperty(niParams.ParamName, niParams.ParamValue));
                     inputStr = ConstructInitParamsXml(mshObj, null);
                     XmlDocument xdoc = new XmlDocument();
@@ -5146,7 +5138,7 @@ namespace Microsoft.WSMan.Management
 
             if (configurationName.Equals(WSManStringLiterals.ConfigRunAsPasswordName, StringComparison.OrdinalIgnoreCase))
             {
-                if (basePsObject != null && basePsObject.BaseObject is SecureString)
+                if (basePsObject?.BaseObject is SecureString)
                 {
                     return basePsObject.BaseObject as SecureString;
                 }
@@ -5163,7 +5155,7 @@ namespace Microsoft.WSMan.Management
             }
             else if (configurationName.Equals(WSManStringLiterals.ConfigRunAsUserName, StringComparison.OrdinalIgnoreCase))
             {
-                if (basePsObject != null && basePsObject.BaseObject is PSCredential)
+                if (basePsObject?.BaseObject is PSCredential)
                 {
                     return basePsObject.BaseObject as PSCredential;
                 }
@@ -5193,10 +5185,9 @@ namespace Microsoft.WSMan.Management
         /// <param name="propertyValue">Value to append.</param>
         private static string GetStringFromSecureString(object propertyValue)
         {
-            SecureString value = propertyValue as SecureString;
             string passwordValueToAdd = string.Empty;
 
-            if (value != null)
+            if (propertyValue is SecureString value)
             {
                 IntPtr ptr = Marshal.SecureStringToBSTR(value);
                 passwordValueToAdd = Marshal.PtrToStringAuto(ptr);
diff --git a/src/Microsoft.WSMan.Management/Set-QuickConfig.cs b/src/Microsoft.WSMan.Management/Set-QuickConfig.cs
index c318ea764..dc1655038 100644
--- a/src/Microsoft.WSMan.Management/Set-QuickConfig.cs
+++ b/src/Microsoft.WSMan.Management/Set-QuickConfig.cs
@@ -201,7 +201,7 @@ namespace Microsoft.WSMan.Management
                 }
 
                 string inputXml = resultopxml.SelectSingleNode(xpathUpdate, nsmgr).OuterXml;
-                if (resultAction.Equals(string.Empty) || inputXml.Equals(string.Empty))
+                if (string.IsNullOrEmpty(resultAction)|| string.IsNullOrEmpty(inputXml))
                 {
                     ArgumentException e = new ArgumentException(WSManResourceLoader.GetResourceString("L_ERR_Message") + WSManResourceLoader.GetResourceString("L_QuickConfig_MissingUpdateXml_0_ErrorMessage"));
                     ErrorRecord er = new ErrorRecord(e, "InvalidOperation", ErrorCategory.InvalidOperation, null);
diff --git a/src/Microsoft.WSMan.Management/WsManHelper.cs b/src/Microsoft.WSMan.Management/WsManHelper.cs
index 000cb871a..ad386b9a5 100644
--- a/src/Microsoft.WSMan.Management/WsManHelper.cs
+++ b/src/Microsoft.WSMan.Management/WsManHelper.cs
@@ -370,17 +370,9 @@ namespace Microsoft.WSMan.Management
             }
             finally
             {
-                if (_sr != null)
-                {
-                    // _sr.Close();
-                    _sr.Dispose();
-                }
+                _sr?.Dispose();
 
-                if (_fs != null)
-                {
-                    // _fs.Close();
-                    _fs.Dispose();
-                }
+                _fs?.Dispose();
             }
 
             return strOut;
diff --git a/src/System.Management.Automation/DscSupport/CimDSCParser.cs b/src/System.Management.Automation/DscSupport/CimDSCParser.cs
index 290114881..86657cacf 100644
--- a/src/System.Management.Automation/DscSupport/CimDSCParser.cs
+++ b/src/System.Management.Automation/DscSupport/CimDSCParser.cs
@@ -91,8 +91,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
                         case CimType.Instance:
                             {
                                 var cimPropertyInstance = property.Value as CimInstance;
-                                if (cimPropertyInstance != null &&
-                                    cimPropertyInstance.CimClass != null &&
+                                if (cimPropertyInstance?.CimClass != null &&
                                     cimPropertyInstance.CimClass.CimSystemProperties != null &&
                                     string.Equals(
                                         cimPropertyInstance.CimClass.CimSystemProperties.ClassName,
@@ -158,14 +157,14 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
                         throw invalidOperationException;
                     }
 
-                    if (member is FieldInfo)
+                    if (member is FieldInfo fieldInfo)
                     {
-                        ((FieldInfo)member).SetValue(targetObject, targetValue);
+                        fieldInfo.SetValue(targetObject, targetValue);
                     }
 
-                    if (member is PropertyInfo)
+                    if (member is PropertyInfo propertyInfo)
                     {
-                        ((PropertyInfo)member).SetValue(targetObject, targetValue);
+                        propertyInfo.SetValue(targetObject, targetValue);
                     }
                 }
             }
@@ -985,10 +984,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
             {
                 // Ignore modules with invalid schemas.
                 s_tracer.WriteLine("DSC ClassCache: Error importing file '{0}', with error '{1}'.  Skipping file.", path, e);
-                if (errors != null)
-                {
-                    errors.Add(e);
-                }
+                errors?.Add(e);
             }
 
             if (classes != null)
@@ -1015,10 +1011,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
                                 ParserStrings.DuplicateCimClassDefinition, className, path, files);
 
                             e.SetErrorId("DuplicateCimClassDefinition");
-                            if (errors != null)
-                            {
-                                errors.Add(e);
-                            }
+                            errors?.Add(e);
                         }
                     }
 
@@ -1956,8 +1949,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
                 object evalResultObject;
                 if (IsConstantValueVisitor.IsConstant(pair.Item1, out evalResultObject, forAttribute: false, forRequires: false))
                 {
-                    var presentName = evalResultObject as string;
-                    if (presentName != null)
+                    if (evalResultObject is string presentName)
                     {
                         if (mandatoryPropertiesNames.Remove(presentName) && mandatoryPropertiesNames.Count == 0)
                         {
@@ -2320,8 +2312,8 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
         internal static string MapTypeNameToMofType(ITypeName typeName, string memberName, string className, out bool isArrayType, out string embeddedInstanceType, List<object> embeddedInstanceTypes, ref string[] enumNames)
         {
             TypeName propTypeName;
-            var arrayTypeName = typeName as ArrayTypeName;
-            if (arrayTypeName != null)
+
+            if (typeName is ArrayTypeName arrayTypeName)
             {
                 isArrayType = true;
                 propTypeName = arrayTypeName.ElementType as TypeName;
@@ -2384,15 +2376,14 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
             while (bases.Count > 0)
             {
                 var b = bases.Dequeue();
-                var tc = b as TypeConstraintAst;
 
-                if (tc != null)
+                if (b is TypeConstraintAst tc)
                 {
                     b = tc.TypeName.GetReflectionType();
                     if (b == null)
                     {
                         var td = tc.TypeName as TypeName;
-                        if (td != null && td._typeDefinitionAst != null)
+                        if (td?._typeDefinitionAst != null)
                         {
                             ProcessMembers(sb, embeddedInstanceTypes, td._typeDefinitionAst, className);
                             foreach (var b1 in td._typeDefinitionAst.BaseTypes)
@@ -2405,8 +2396,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
                     }
                 }
 
-                var type = b as Type;
-                if (type != null)
+                if (b is Type type)
                 {
                     ProcessMembers(type, sb, embeddedInstanceTypes, className);
                     var t = type.BaseType;
@@ -2434,8 +2424,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
             methodsLinePosition = new Dictionary<string, int>();
             foreach (var member in typeDefinitionAst.Members)
             {
-                var functionMemberAst = member as FunctionMemberAst;
-                if (functionMemberAst != null)
+                if (member is FunctionMemberAst functionMemberAst)
                 {
                     if (functionMemberAst.Name.Equals(getMethodName, StringComparison.OrdinalIgnoreCase))
                     {
@@ -2622,8 +2611,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
 
             resourceDefinitions = ast.FindAll(n =>
             {
-                var typeAst = n as TypeDefinitionAst;
-                if (typeAst != null)
+                if (n is TypeDefinitionAst typeAst)
                 {
                     for (int i = 0; i < typeAst.Attributes.Count; i++)
                     {
@@ -2694,8 +2682,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
                         {
                             if (na.ArgumentName.Equals("RunAsCredential", StringComparison.OrdinalIgnoreCase))
                             {
-                                var dscResourceAttribute = attr.GetAttribute() as DscResourceAttribute;
-                                if (dscResourceAttribute != null)
+                                if (attr.GetAttribute() is DscResourceAttribute dscResourceAttribute)
                                 {
                                     runAsBehavior = dscResourceAttribute.RunAsCredential;
                                 }
@@ -2932,8 +2919,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
             bool needComma = false;
             foreach (var attr in customAttributes)
             {
-                var dscProperty = attr as DscPropertyAttribute;
-                if (dscProperty != null)
+                if (attr is DscPropertyAttribute dscProperty)
                 {
                     if (dscProperty.Key)
                     {
@@ -2956,8 +2942,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
                     continue;
                 }
 
-                var validateSet = attr as ValidateSetAttribute;
-                if (validateSet != null)
+                if (attr is ValidateSetAttribute validateSet)
                 {
                     bool valueMapComma = false;
                     StringBuilder sbValues = new(", Values{");
@@ -3051,8 +3036,8 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal
                 for (int i = batchedTypes.Length - 1; i >= 0; i--)
                 {
                     visitedInstances.Add(batchedTypes[i]);
-                    var type = batchedTypes[i] as Type;
-                    if (type != null)
+
+                    if (batchedTypes[i] is Type type)
                     {
                         GenerateMofForType(type, nestedSb, embeddedInstanceTypes);
                     }
diff --git a/src/System.Management.Automation/DscSupport/JsonDscClassCache.cs b/src/System.Management.Automation/DscSupport/JsonDscClassCache.cs
index 2fe4f7c26..c3a7fe55a 100755
--- a/src/System.Management.Automation/DscSupport/JsonDscClassCache.cs
+++ b/src/System.Management.Automation/DscSupport/JsonDscClassCache.cs
@@ -263,10 +263,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal.CrossPlatform
             {
                 // Ignore modules with invalid schemas.
                 s_tracer.WriteLine("DSC ClassCache: Error importing file '{0}', with error '{1}'.  Skipping file.", path, e);
-                if (errors != null)
-                {
-                    errors.Add(e);
-                }
+                errors?.Add(e);
             }
 
             if (classes != null)
@@ -1620,8 +1617,7 @@ namespace Microsoft.PowerShell.DesiredStateConfiguration.Internal.CrossPlatform
                         {
                             if (na.ArgumentName.Equals("RunAsCredential", StringComparison.OrdinalIgnoreCase))
                             {
-                                var dscResourceAttribute = attr.GetAttribute() as DscResourceAttribute;
-                                if (dscResourceAttribute != null)
+                                if (attr.GetAttribute() is DscResourceAttribute dscResourceAttribute)
                                 {
                                     runAsBehavior = dscResourceAttribute.RunAsCredential;
                                 }
diff --git a/src/System.Management.Automation/FormatAndOutput/common/BaseFormattingCommandParameters.cs b/src/System.Management.Automation/FormatAndOutput/common/BaseFormattingCommandParameters.cs
index 95c583534..1dd0ac6ce 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/BaseFormattingCommandParameters.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/BaseFormattingCommandParameters.cs
@@ -174,17 +174,14 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                 throw PSTraceSource.NewArgumentNullException(nameof(val));
             }
 
-            // need to check the type:
-            // it can be a string or a script block
-            ScriptBlock sb = val as ScriptBlock;
-            if (sb != null)
+            // need to check the type:            // it can be a string or a script block
+            if (val is ScriptBlock sb)
             {
                 PSPropertyExpression ex = new PSPropertyExpression(sb);
                 return ex;
             }
 
-            string s = val as string;
-            if (s != null)
+            if (val is string s)
             {
                 if (string.IsNullOrEmpty(s))
                 {
diff --git a/src/System.Management.Automation/FormatAndOutput/common/BaseOutputtingCommand.cs b/src/System.Management.Automation/FormatAndOutput/common/BaseOutputtingCommand.cs
index 48ab13076..8820555bf 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/BaseOutputtingCommand.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/BaseOutputtingCommand.cs
@@ -135,9 +135,8 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             }
 
             // no need for formatting, just process the object
-            FormatStartData formatStart = o as FormatStartData;
 
-            if (formatStart != null)
+            if (o is FormatStartData formatStart)
             {
                 // get autosize flag from object
                 // turn on group caching
@@ -149,8 +148,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                 else
                 {
                     // If the format info doesn't define column widths, then auto-size based on the first ten elements
-                    TableHeaderInfo headerInfo = formatStart.shapeInfo as TableHeaderInfo;
-                    if ((headerInfo != null) &&
+                    if ((formatStart.shapeInfo is TableHeaderInfo headerInfo) &&
                         (headerInfo.tableColumnInfoList.Count > 0) &&
                         (headerInfo.tableColumnInfoList[0].width == 0))
                     {
@@ -262,8 +260,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
         /// <returns>Whether the object needs to be shunted to preprocessing.</returns>
         private bool NeedsPreprocessing(object o)
         {
-            FormatEntryData fed = o as FormatEntryData;
-            if (fed != null)
+            if (o is FormatEntryData fed)
             {
                 // we got an already pre-processed object
                 if (!fed.outOfBand)
@@ -326,8 +323,8 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                 // need to abort the command
 
                 string violatingCommand = "format-*";
-                StartData sdObj = obj as StartData;
-                if (sdObj != null)
+
+                if (obj is StartData sdObj)
                 {
                     if (sdObj.shapeInfo is WideViewHeaderInfo)
                     {
@@ -387,18 +384,16 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                                         FormatMessagesContextManager.OutputContext parentContext,
                                         FormatInfoData formatInfoData)
         {
-            FormatStartData formatStartData = formatInfoData as FormatStartData;
             // initialize the format context
-            if (formatStartData != null)
+            if (formatInfoData is FormatStartData formatStartData)
             {
                 FormatOutputContext foc = new FormatOutputContext(parentContext, formatStartData);
 
                 return foc;
             }
 
-            GroupStartData gsd = formatInfoData as GroupStartData;
             // we are starting a group, initialize the group context
-            if (gsd != null)
+            if (formatInfoData is GroupStartData gsd)
             {
                 GroupOutputContext goc = null;
 
@@ -541,8 +536,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
         private void ProcessOutOfBandPayload(FormatEntryData fed)
         {
             // try if it is raw text
-            RawTextFormatEntry rte = fed.formatEntryInfo as RawTextFormatEntry;
-            if (rte != null)
+            if (fed.formatEntryInfo is RawTextFormatEntry rte)
             {
                 if (fed.isHelpObject)
                 {
@@ -561,7 +555,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
 
             // try if it is a complex entry
             ComplexViewEntry cve = fed.formatEntryInfo as ComplexViewEntry;
-            if (cve != null && cve.formatValueList != null)
+            if (cve?.formatValueList != null)
             {
                 ComplexWriter complexWriter = new ComplexWriter();
 
@@ -572,7 +566,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             }
             // try if it is a list view
             ListViewEntry lve = fed.formatEntryInfo as ListViewEntry;
-            if (lve != null && lve.listViewFieldList != null)
+            if (lve?.listViewFieldList != null)
             {
                 ListWriter listWriter = new ListWriter();
 
@@ -651,17 +645,13 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
         {
             _formattingHint = null;
 
-            TableHeaderInfo thi = formatStartData.shapeInfo as TableHeaderInfo;
-
-            if (thi != null)
+            if (formatStartData.shapeInfo is TableHeaderInfo thi)
             {
                 ProcessCachedGroupOnTable(thi, objects);
                 return;
             }
 
-            WideViewHeaderInfo wvhi = formatStartData.shapeInfo as WideViewHeaderInfo;
-
-            if (wvhi != null)
+            if (formatStartData.shapeInfo is WideViewHeaderInfo wvhi)
             {
                 ProcessCachedGroupOnWide(wvhi, objects);
                 return;
@@ -978,11 +968,11 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             /// </summary>
             internal override void Initialize()
             {
-                TableFormattingHint tableHint = this.InnerCommand.RetrieveFormattingHint() as TableFormattingHint;
                 int[] columnWidthsHint = null;
+
                 // We expect that console width is less then 120.
 
-                if (tableHint != null)
+                if (this.InnerCommand.RetrieveFormattingHint() is TableFormattingHint tableHint)
                 {
                     columnWidthsHint = tableHint.columnWidths;
                 }
@@ -1201,14 +1191,12 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             {
                 // set the hard wider default, to be used if no other info is available
                 int itemsPerRow = 2;
-
                 // get the header info and the view hint
-                WideFormattingHint hint = this.InnerCommand.RetrieveFormattingHint() as WideFormattingHint;
 
                 int columnsOnTheScreen = GetConsoleWindowWidth(this.InnerCommand._lo.ColumnNumber);
 
                 // give a preference to the hint, if there
-                if (hint != null && hint.maxWidth > 0)
+                if (this.InnerCommand.RetrieveFormattingHint() is WideFormattingHint hint && hint.maxWidth > 0)
                 {
                     itemsPerRow = TableWriter.ComputeWideViewBestItemsPerRowFit(hint.maxWidth, columnsOnTheScreen);
                 }
diff --git a/src/System.Management.Automation/FormatAndOutput/common/ComplexWriter.cs b/src/System.Management.Automation/FormatAndOutput/common/ComplexWriter.cs
index e96115b78..126a42c87 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/ComplexWriter.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/ComplexWriter.cs
@@ -68,8 +68,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
         {
             foreach (object obj in fe.formatValueList)
             {
-                FormatEntry feChild = obj as FormatEntry;
-                if (feChild != null)
+                if (obj is FormatEntry feChild)
                 {
                     if (currentDepth < maxRecursionDepth)
                     {
@@ -98,15 +97,13 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                     continue;
                 }
 
-                FormatTextField ftf = obj as FormatTextField;
-                if (ftf != null)
+                if (obj is FormatTextField ftf)
                 {
                     this.AddToBuffer(ftf.text);
                     continue;
                 }
 
-                FormatPropertyField fpf = obj as FormatPropertyField;
-                if (fpf != null)
+                if (obj is FormatPropertyField fpf)
                 {
                     this.AddToBuffer(fpf.propertyValue);
                 }
@@ -237,10 +234,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
 
             public void Dispose()
             {
-                if (_mgr != null)
-                {
-                    _mgr.RemoveStackFrame();
-                }
+                _mgr?.RemoveStackFrame();
             }
 
             private readonly IndentationManager _mgr;
diff --git a/src/System.Management.Automation/FormatAndOutput/common/DisplayDatabase/XmlLoaderBase.cs b/src/System.Management.Automation/FormatAndOutput/common/DisplayDatabase/XmlLoaderBase.cs
index a7e7df0a5..74678d94f 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/DisplayDatabase/XmlLoaderBase.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/DisplayDatabase/XmlLoaderBase.cs
@@ -386,8 +386,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
 
             if (match && !allowAttributes)
             {
-                XmlElement e = n as XmlElement;
-                if (e != null && e.Attributes.Count > 0)
+                if (n is XmlElement e && e.Attributes.Count > 0)
                 {
                     // Error at XPath {0} in file {1}: The XML Element {2} does not allow attributes.
                     ReportError(StringUtil.Format(FormatAndOutXmlLoadingStrings.AttributesNotAllowed, ComputeCurrentXPath(), FilePath, n.Name));
diff --git a/src/System.Management.Automation/FormatAndOutput/common/DisplayDatabase/typeDataQuery.cs b/src/System.Management.Automation/FormatAndOutput/common/DisplayDatabase/typeDataQuery.cs
index 60953d22c..f0aafc687 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/DisplayDatabase/typeDataQuery.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/DisplayDatabase/typeDataQuery.cs
@@ -143,9 +143,8 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                 }
 
                 int currentMatch = BestMatchIndexUndefined;
-                TypeReference tr = r as TypeReference;
 
-                if (tr != null)
+                if (r is TypeReference tr)
                 {
                     // we have a type
                     currentMatch = MatchTypeIndex(tr.name, currentObject, ex);
@@ -486,9 +485,9 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                 foreach (TypeOrGroupReference togr in vd.appliesTo.referenceList)
                 {
                     StringBuilder sb = new StringBuilder();
-                    TypeReference tr = togr as TypeReference;
                     sb.Append(isMatched ? "MATCH FOUND" : "NOT MATCH");
-                    if (tr != null)
+
+                    if (togr is TypeReference tr)
                     {
                         sb.AppendFormat(CultureInfo.InvariantCulture, " {0} NAME: {1}  TYPE: {2}",
                             ControlBase.GetControlShapeName(vd.mainControl), vd.name, tr.name);
@@ -507,8 +506,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
 
         private static ViewDefinition GetBestMatch(TypeMatch match)
         {
-            ViewDefinition bestMatchedVD = match.BestMatch as ViewDefinition;
-            if (bestMatchedVD != null)
+            if (match.BestMatch is ViewDefinition bestMatchedVD)
             {
                 TraceHelper(bestMatchedVD, true);
             }
@@ -593,8 +591,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             foreach (TypeOrGroupReference r in appliesTo.referenceList)
             {
                 // if it is a type reference, just add the type name
-                TypeReference tr = r as TypeReference;
-                if (tr != null)
+                if (r is TypeReference tr)
                 {
                     if (!allTypes.Contains(tr.name))
                         allTypes.Add(tr.name);
diff --git a/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator.cs b/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator.cs
index f29033e3c..5ac212283 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator.cs
@@ -143,8 +143,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             // check if we have a view with autosize checked
             if (this.dataBaseInfo.view != null && this.dataBaseInfo.view.mainControl != null)
             {
-                ControlBody controlBody = this.dataBaseInfo.view.mainControl as ControlBody;
-                if (controlBody != null && controlBody.autosize.HasValue)
+                if (this.dataBaseInfo.view.mainControl is ControlBody controlBody && controlBody.autosize.HasValue)
                 {
                     _autosize = controlBody.autosize.Value;
                 }
@@ -217,7 +216,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
 
                 string currentGroupingValueDisplay = PSObjectHelper.SmartToString(so, this.expressionFactory, enumerationLimit, formatErrorObject);
 
-                if (formatErrorObject != null && formatErrorObject.exception != null)
+                if (formatErrorObject?.exception != null)
                 {
                     // if we did no thave any errors in the expression evaluation
                     // we might have errors in the formatting, if present
@@ -385,7 +384,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                         retVal = _errorManager.ErrorString;
                     }
                 }
-                else if (formatErrorObject != null && formatErrorObject.exception != null)
+                else if (formatErrorObject?.exception != null)
                 {
                     // if we did no thave any errors in the expression evaluation
                     // we might have errors in the formatting, if present
@@ -409,7 +408,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             PSPropertyExpressionResult expressionResult;
             bool retVal = DisplayCondition.Evaluate(so, ex, out expressionResult);
 
-            if (expressionResult != null && expressionResult.Exception != null)
+            if (expressionResult?.Exception != null)
             {
                 _errorManager.LogPSPropertyExpressionFailedResult(expressionResult, so);
             }
@@ -439,16 +438,15 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             if (formatTokenList.Count != 0)
             {
                 FormatToken token = formatTokenList[0];
-                FieldPropertyToken fpt = token as FieldPropertyToken;
-                if (fpt != null)
+
+                if (token is FieldPropertyToken fpt)
                 {
                     PSPropertyExpression ex = this.expressionFactory.CreateFromExpressionToken(fpt.expression, this.dataBaseInfo.view.loadingInfo);
                     fpf.propertyValue = this.GetExpressionDisplayValue(so, enumerationLimit, ex, fpt.fieldFormattingDirective, out result);
                 }
                 else
                 {
-                    TextToken tt = token as TextToken;
-                    if (tt != null)
+                    if (token is TextToken tt)
                         fpf.propertyValue = this.dataBaseInfo.db.displayResourceManagerCache.GetTextTokenString(tt);
                 }
             }
diff --git a/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_Complex.cs b/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_Complex.cs
index c1645b09a..6b79c2e48 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_Complex.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_Complex.cs
@@ -107,8 +107,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             ComplexControlBody complexBody = null;
 
             // we might have a reference
-            ControlReference controlReference = control as ControlReference;
-            if (controlReference != null && controlReference.controlType == typeof(ComplexControlBody))
+            if (control is ControlReference controlReference && controlReference.controlType == typeof(ComplexControlBody))
             {
                 // retrieve the reference
                 complexBody = DisplayDataQuery.ResolveControlReference(
@@ -205,8 +204,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             #region foreach loop
             foreach (FormatToken t in formatTokenList)
             {
-                TextToken tt = t as TextToken;
-                if (tt != null)
+                if (t is TextToken tt)
                 {
                     FormatTextField ftf = new FormatTextField();
                     ftf.text = _db.displayResourceManagerCache.GetTextTokenString(tt);
@@ -214,8 +212,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                     continue;
                 }
 
-                var newline = t as NewLineToken;
-                if (newline != null)
+                if (t is NewLineToken newline)
                 {
                     for (int i = 0; i < newline.count; i++)
                     {
@@ -225,8 +222,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                     continue;
                 }
 
-                FrameToken ft = t as FrameToken;
-                if (ft != null)
+                if (t is FrameToken ft)
                 {
                     // instantiate a new entry and attach a frame info object
                     FormatEntry feFrame = new FormatEntry();
@@ -244,9 +240,8 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                     fe.formatValueList.Add(feFrame);
                     continue;
                 }
-                #region CompoundPropertyToken
-                CompoundPropertyToken cpt = t as CompoundPropertyToken;
-                if (cpt != null)
+
+                if (t is CompoundPropertyToken cpt)
                 {
                     if (!EvaluateDisplayCondition(so, cpt.conditionToken))
                     {
@@ -325,7 +320,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                             fe.formatValueList.Add(fpf);
                         }
 
-                        if (formatErrorObject != null && formatErrorObject.exception != null)
+                        if (formatErrorObject?.exception != null)
                         {
                             _errorManager.LogStringFormatError(formatErrorObject);
                             fpf.propertyValue = _errorManager.FormatErrorString;
@@ -375,7 +370,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             PSPropertyExpressionResult expressionResult;
             bool retVal = DisplayCondition.Evaluate(so, ex, out expressionResult);
 
-            if (expressionResult != null && expressionResult.Exception != null)
+            if (expressionResult?.Exception != null)
             {
                 _errorManager.LogPSPropertyExpressionFailedResult(expressionResult, so);
             }
@@ -492,7 +487,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
 
             fpf.propertyValue = PSObjectHelper.SmartToString(so, _expressionFactory, _enumerationLimit, formatErrorObject);
 
-            if (formatErrorObject != null && formatErrorObject.exception != null)
+            if (formatErrorObject?.exception != null)
             {
                 // if we did no thave any errors in the expression evaluation
                 // we might have errors in the formatting, if present
diff --git a/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_List.cs b/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_List.cs
index 1cee30670..ff16752b4 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_List.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_List.cs
@@ -114,8 +114,8 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
 
                     // we try to fall back and see if we have an un-resolved PSPropertyExpression
                     FormatToken token = listItem.formatTokenList[0];
-                    FieldPropertyToken fpt = token as FieldPropertyToken;
-                    if (fpt != null)
+
+                    if (token is FieldPropertyToken fpt)
                     {
                         PSPropertyExpression ex = this.expressionFactory.CreateFromExpressionToken(fpt.expression, this.dataBaseInfo.view.loadingInfo);
 
@@ -124,8 +124,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                     }
                     else
                     {
-                        TextToken tt = token as TextToken;
-                        if (tt != null)
+                        if (token is TextToken tt)
                             // we had a text token, use it as a label (last resort...)
                             lvf.label = this.dataBaseInfo.db.displayResourceManagerCache.GetTextTokenString(tt);
                     }
diff --git a/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_Table.cs b/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_Table.cs
index bfd3291dd..6e2b3f69c 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_Table.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/FormatViewGenerator_Table.cs
@@ -187,15 +187,13 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                         token = rowItem.formatTokenList[0];
                     if (token != null)
                     {
-                        FieldPropertyToken fpt = token as FieldPropertyToken;
-                        if (fpt != null)
+                        if (token is FieldPropertyToken fpt)
                         {
                             ci.label = fpt.expression.expressionValue;
                         }
                         else
                         {
-                            TextToken tt = token as TextToken;
-                            if (tt != null)
+                            if (token is TextToken tt)
                             {
                                 ci.label = this.dataBaseInfo.db.displayResourceManagerCache.GetTextTokenString(tt);
                             }
diff --git a/src/System.Management.Automation/FormatAndOutput/common/FormatViewManager.cs b/src/System.Management.Automation/FormatAndOutput/common/FormatViewManager.cs
index 0737e4347..db031e43e 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/FormatViewManager.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/FormatViewManager.cs
@@ -237,7 +237,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             const string separator = ", ";
             StringBuilder validViewFormats = new StringBuilder();
 
-            if (so != null && so.BaseObject != null &&
+            if (so?.BaseObject != null &&
                 db != null && db.viewDefinitionsSection != null &&
                 db.viewDefinitionsSection.viewDefinitionList != null &&
                 db.viewDefinitionsSection.viewDefinitionList.Count > 0)
@@ -646,8 +646,8 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
         {
             ErrorRecord errorRecord = null;
             string msg = null;
-            PSPropertyExpressionError psPropertyExpressionError = error as PSPropertyExpressionError;
-            if (psPropertyExpressionError != null)
+
+            if (error is PSPropertyExpressionError psPropertyExpressionError)
             {
                 errorRecord = new ErrorRecord(
                                 psPropertyExpressionError.result.Exception,
@@ -660,8 +660,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                 errorRecord.ErrorDetails = new ErrorDetails(msg);
             }
 
-            StringFormatError formattingError = error as StringFormatError;
-            if (formattingError != null)
+            if (error is StringFormatError formattingError)
             {
                 errorRecord = new ErrorRecord(
                                 formattingError.exception,
diff --git a/src/System.Management.Automation/FormatAndOutput/common/FormattingObjectsDeserializer.cs b/src/System.Management.Automation/FormatAndOutput/common/FormattingObjectsDeserializer.cs
index 285e4d4c0..48a9ec1c9 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/FormattingObjectsDeserializer.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/FormattingObjectsDeserializer.cs
@@ -30,8 +30,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
 
         internal bool IsFormatInfoData(PSObject so)
         {
-            var fid = PSObject.Base(so) as FormatInfoData;
-            if (fid != null)
+            if (PSObject.Base(so) is FormatInfoData fid)
             {
                 if (fid is FormatStartData ||
                     fid is FormatEndData ||
@@ -86,8 +85,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
         /// <returns>Deserialized object or null.</returns>
         internal object Deserialize(PSObject so)
         {
-            var fid = PSObject.Base(so) as FormatInfoData;
-            if (fid != null)
+            if (PSObject.Base(so) is FormatInfoData fid)
             {
                 if (fid is FormatStartData ||
                     fid is FormatEndData ||
@@ -302,9 +300,9 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
             }
 
             WriteStreamType rtnWSType;
-            if (wsTypeValue is WriteStreamType)
+            if (wsTypeValue is WriteStreamType writeStreamType)
             {
-                rtnWSType = (WriteStreamType)wsTypeValue;
+                rtnWSType = writeStreamType;
             }
             else if (wsTypeValue is string)
             {
diff --git a/src/System.Management.Automation/FormatAndOutput/common/OutputManager.cs b/src/System.Management.Automation/FormatAndOutput/common/OutputManager.cs
index 41ea611f1..6e6fdb413 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/OutputManager.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/OutputManager.cs
@@ -100,10 +100,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
         {
             lock (_syncRoot)
             {
-                if (_lo != null)
-                {
-                    _lo.StopProcessing();
-                }
+                _lo?.StopProcessing();
 
                 _isStopped = true;
             }
diff --git a/src/System.Management.Automation/FormatAndOutput/common/OutputQueue.cs b/src/System.Management.Automation/FormatAndOutput/common/OutputQueue.cs
index 1909b0393..c61343f7f 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/OutputQueue.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/OutputQueue.cs
@@ -43,8 +43,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
         /// <returns>Objects the cache needs to return. It can be null.</returns>
         internal List<PacketInfoData> Add(PacketInfoData o)
         {
-            FormatStartData fsd = o as FormatStartData;
-            if (fsd != null)
+            if (o is FormatStartData fsd)
             {
                 // just cache the reference (used during the notification call)
                 _formatStartData = fsd;
@@ -139,8 +138,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
 
             foreach (PacketInfoData x in _queue)
             {
-                FormatEntryData fed = x as FormatEntryData;
-                if (fed != null && fed.outOfBand)
+                if (x is FormatEntryData fed && fed.outOfBand)
                     continue;
 
                 validObjects.Add(x);
diff --git a/src/System.Management.Automation/FormatAndOutput/common/Utilities/MshObjectUtil.cs b/src/System.Management.Automation/FormatAndOutput/common/Utilities/MshObjectUtil.cs
index 7760e86b1..1d25811c2 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/Utilities/MshObjectUtil.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/Utilities/MshObjectUtil.cs
@@ -120,8 +120,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
         /// <param name="obj">Object to extract the IEnumerable from.</param>
         internal static IEnumerable GetEnumerable(object obj)
         {
-            PSObject mshObj = obj as PSObject;
-            if (mshObj != null)
+            if (obj is PSObject mshObj)
             {
                 obj = mshObj.BaseObject;
             }
@@ -226,8 +225,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                     IEnumerator enumerator = e.GetEnumerator();
                     if (enumerator != null)
                     {
-                        IBlockingEnumerator<object> be = enumerator as IBlockingEnumerator<object>;
-                        if (be != null)
+                        if (enumerator is IBlockingEnumerator<object> be)
                         {
                             while (be.MoveNext(false))
                             {
@@ -396,8 +394,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
         {
             if (standardMembersSet != null)
             {
-                PSPropertySet defaultDisplayPropertySet = standardMembersSet.Members[TypeTable.DefaultDisplayPropertySet] as PSPropertySet;
-                if (defaultDisplayPropertySet != null)
+                if (standardMembersSet.Members[TypeTable.DefaultDisplayPropertySet] is PSPropertySet defaultDisplayPropertySet)
                 {
                     List<PSPropertyExpression> retVal = new List<PSPropertyExpression>();
                     foreach (string prop in defaultDisplayPropertySet.ReferencedPropertyNames)
@@ -435,8 +432,7 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
         {
             if (standardMembersSet != null)
             {
-                PSNoteProperty defaultDisplayProperty = standardMembersSet.Members[TypeTable.DefaultDisplayProperty] as PSNoteProperty;
-                if (defaultDisplayProperty != null)
+                if (standardMembersSet.Members[TypeTable.DefaultDisplayProperty] is PSNoteProperty defaultDisplayProperty)
                 {
                     string expressionString = defaultDisplayProperty.Value.ToString();
                     if (string.IsNullOrEmpty(expressionString))
diff --git a/src/System.Management.Automation/FormatAndOutput/common/Utilities/MshParameter.cs b/src/System.Management.Automation/FormatAndOutput/common/Utilities/MshParameter.cs
index e7d7b9e75..35f1f3f64 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/Utilities/MshParameter.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/Utilities/MshParameter.cs
@@ -265,10 +265,10 @@ namespace Microsoft.PowerShell.Commands.Internal.Format
                 // we always copy into a fresh hash table
                 currParam = _paramDef.CreateInstance();
                 var actualObject = PSObject.Base(p[k]);
-                if (actualObject is IDictionary)
+                if (actualObject is IDictionary iDictionary)
                 {
                     originalParameterWasHashTable = true;
-                    currParam.hash = VerifyHashTable((IDictionary)actualObject, invocationContext);
+                    currParam.hash = VerifyHashTable(iDictionary, invocationContext);
                 }
                 else if ((actualObject != null) && MatchesAllowedTypes(actualObject.GetType(), _paramDef.hashEntries[0].AllowedTypes))
                 {
diff --git a/src/System.Management.Automation/FormatAndOutput/common/Utilities/Mshexpression.cs b/src/System.Management.Automation/FormatAndOutput/common/Utilities/Mshexpression.cs
index 68921ddb0..2edc3734c 100644
--- a/src/System.Management.Automation/FormatAndOutput/common/Utilities/Mshexpression.cs
+++ b/src/System.Management.Automation/FormatAndOutput/common/Utilities/Mshexpression.cs
@@ -215,8 +215,7 @@ namespace Microsoft.PowerShell.Commands
             foreach (PSMemberInfo member in members)
             {
                 // it can be a property set
-                PSPropertySet propertySet = member as PSPropertySet;
-                if (propertySet != null)
+                if (member is PSPropertySet propertySet)
                 {
                     if (expand)
                     {
diff --git a/src/System.Management.Automation/FormatAndOutput/out-console/OutConsole.cs b/src/System.Management.Automation/FormatAndOutput/out-console/OutConsole.cs
index 2582a1e68..2486ff9e3 100644
--- a/src/System.Management.Automation/FormatAndOutput/out-console/OutConsole.cs
+++ b/src/System.Management.Automation/FormatAndOutput/out-console/OutConsole.cs
@@ -70,9 +70,7 @@ namespace Microsoft.PowerShell.Commands
 
             ((OutputManagerInner)this.implementation).LineOutput = lineOutput;
 
-            MshCommandRuntime mrt = this.CommandRuntime as MshCommandRuntime;
-
-            if (mrt != null)
+            if (this.CommandRuntime is MshCommandRuntime mrt)
             {
                 mrt.MergeUnclaimedPreviousErrorResults = true;
             }
@@ -109,8 +107,7 @@ namespace Microsoft.PowerShell.Commands
                 object inputObjectBase = PSObject.Base(InputObject);
 
                 // Ignore errors and formatting records, as those can't be captured
-                if (inputObjectBase != null &&
-                    inputObjectBase is not ErrorRecord &&
+                if (                    inputObjectBase is not ErrorRecord &&
                     !inputObjectBase.GetType().FullName.StartsWith(
                         "Microsoft.PowerShell.Commands.Internal.Format", StringComparison.OrdinalIgnoreCase))
                 {
diff --git a/src/System.Management.Automation/cimSupport/cmdletization/MethodInvocationInfo.cs b/src/System.Management.Automation/cimSupport/cmdletization/MethodInvocationInfo.cs
index 1640dec33..f1b44c0fe 100644
--- a/src/System.Management.Automation/cimSupport/cmdletization/MethodInvocationInfo.cs
+++ b/src/System.Management.Automation/cimSupport/cmdletization/MethodInvocationInfo.cs
@@ -62,20 +62,17 @@ namespace Microsoft.PowerShell.Cmdletization
                     continue;
                 }
 
-                var objectInstance = methodParameter.Value as T;
-                if (objectInstance != null)
+                if (methodParameter.Value is T objectInstance)
                 {
                     result.Add(objectInstance);
                     continue;
                 }
 
-                var objectInstanceArray = methodParameter.Value as IEnumerable;
-                if (objectInstanceArray != null)
+                if (methodParameter.Value is IEnumerable objectInstanceArray)
                 {
                     foreach (object element in objectInstanceArray)
                     {
-                        var objectInstance2 = element as T;
-                        if (objectInstance2 != null)
+                        if (element is T objectInstance2)
                         {
                             result.Add(objectInstance2);
                         }
diff --git a/src/System.Management.Automation/cimSupport/cmdletization/ObjectModelWrapper.cs b/src/System.Management.Automation/cimSupport/cmdletization/ObjectModelWrapper.cs
index a840ca527..86079ac17 100644
--- a/src/System.Management.Automation/cimSupport/cmdletization/ObjectModelWrapper.cs
+++ b/src/System.Management.Automation/cimSupport/cmdletization/ObjectModelWrapper.cs
@@ -42,18 +42,14 @@ namespace Microsoft.PowerShell.Cmdletization
             _classVersion = classVersion;
             _privateData = privateData;
 
-            var compiledScript = this.Cmdlet as PSScriptCmdlet;
-            if (compiledScript != null)
+            if (this.Cmdlet is PSScriptCmdlet compiledScript)
             {
                 compiledScript.StoppingEvent += delegate { this.StopProcessing(); };
                 compiledScript.DisposingEvent +=
                         delegate
                         {
                             var disposable = this as IDisposable;
-                            if (disposable != null)
-                            {
-                                disposable.Dispose();
-                            }
+                            disposable?.Dispose();
                         };
             }
         }
diff --git a/src/System.Management.Automation/cimSupport/cmdletization/ScriptWriter.cs b/src/System.Management.Automation/cimSupport/cmdletization/ScriptWriter.cs
index a66316064..c9a70856f 100644
--- a/src/System.Management.Automation/cimSupport/cmdletization/ScriptWriter.cs
+++ b/src/System.Management.Automation/cimSupport/cmdletization/ScriptWriter.cs
@@ -716,7 +716,7 @@ function __cmdletization_BindCommonParameters
 
             ParameterSetMetadata parameterSetMetadata = result.ParameterSets[ParameterAttribute.AllParameterSets];
             result.ParameterSets.Clear();
-            if (parameterCmdletization != null && parameterCmdletization.CmdletParameterSets != null && parameterCmdletization.CmdletParameterSets.Length > 0)
+            if (parameterCmdletization?.CmdletParameterSets != null && parameterCmdletization.CmdletParameterSets.Length > 0)
             {
                 queryParameterSets = parameterCmdletization.CmdletParameterSets;
             }
@@ -788,8 +788,8 @@ function __cmdletization_BindCommonParameters
         private CommandMetadata GetCommandMetadata(CommonCmdletMetadata cmdletMetadata)
         {
             string defaultParameterSetName = null;
-            StaticCmdletMetadataCmdletMetadata staticCmdletMetadata = cmdletMetadata as StaticCmdletMetadataCmdletMetadata;
-            if (staticCmdletMetadata != null)
+
+            if (cmdletMetadata is StaticCmdletMetadataCmdletMetadata staticCmdletMetadata)
             {
                 if (!string.IsNullOrEmpty(staticCmdletMetadata.DefaultCmdletParameterSet))
                 {
@@ -1477,9 +1477,7 @@ function __cmdletization_BindCommonParameters
                 property.PropertyName,
                 property.Type,
                 query.CmdletParameterMetadata);
-
-            WildcardablePropertyQuery wildcardablePropertyQuery = query as WildcardablePropertyQuery;
-            if ((wildcardablePropertyQuery != null) && (!cmdletParameterMetadata.SwitchParameter))
+            if ((query is WildcardablePropertyQuery wildcardablePropertyQuery) && (!cmdletParameterMetadata.SwitchParameter))
             {
                 if (cmdletParameterMetadata.ParameterType == null)
                 {
diff --git a/src/System.Management.Automation/cimSupport/other/ciminstancetypeadapter.cs b/src/System.Management.Automation/cimSupport/other/ciminstancetypeadapter.cs
index f9aa9f9b7..b7ef0edac 100644
--- a/src/System.Management.Automation/cimSupport/other/ciminstancetypeadapter.cs
+++ b/src/System.Management.Automation/cimSupport/other/ciminstancetypeadapter.cs
@@ -202,8 +202,7 @@ namespace Microsoft.PowerShell.Cim
                 throw new ArgumentNullException(nameof(adaptedProperty));
             }
 
-            CimProperty cimProperty = adaptedProperty.Tag as CimProperty;
-            if (cimProperty != null)
+            if (adaptedProperty.Tag is CimProperty cimProperty)
             {
                 return CimTypeToTypeNameDisplayString(cimProperty.CimType);
             }
@@ -227,8 +226,7 @@ namespace Microsoft.PowerShell.Cim
                 throw new ArgumentNullException(nameof(adaptedProperty));
             }
 
-            CimProperty cimProperty = adaptedProperty.Tag as CimProperty;
-            if (cimProperty != null)
+            if (adaptedProperty.Tag is CimProperty cimProperty)
             {
                 return cimProperty.Value;
             }
diff --git a/src/System.Management.Automation/engine/ArgumentTypeConverterAttribute.cs b/src/System.Management.Automation/engine/ArgumentTypeConverterAttribute.cs
index a2c2cd832..a60bb6520 100644
--- a/src/System.Management.Automation/engine/ArgumentTypeConverterAttribute.cs
+++ b/src/System.Management.Automation/engine/ArgumentTypeConverterAttribute.cs
@@ -59,8 +59,8 @@ namespace System.Management.Automation
                         if (_convertTypes[i].Equals(typeof(System.Management.Automation.PSReference)))
                         {
                             object temp;
-                            PSObject mshObject = result as PSObject;
-                            if (mshObject != null)
+
+                            if (result is PSObject mshObject)
                                 temp = mshObject.BaseObject;
                             else
                                 temp = result;
@@ -74,16 +74,15 @@ namespace System.Management.Automation
                         else
                         {
                             object temp;
-                            PSObject mshObject = result as PSObject;
-                            if (mshObject != null)
+
+                            if (result is PSObject mshObject)
                                 temp = mshObject.BaseObject;
                             else
                                 temp = result;
 
                             // If a non-ref type is expected but currently passed in is a ref, do an implicit dereference.
-                            PSReference reference = temp as PSReference;
 
-                            if (reference != null)
+                            if (temp is PSReference reference)
                             {
                                 result = reference.Value;
                             }
diff --git a/src/System.Management.Automation/engine/COM/ComTypeInfo.cs b/src/System.Management.Automation/engine/COM/ComTypeInfo.cs
index 851325e82..7a5d2aeb9 100644
--- a/src/System.Management.Automation/engine/COM/ComTypeInfo.cs
+++ b/src/System.Management.Automation/engine/COM/ComTypeInfo.cs
@@ -146,8 +146,8 @@ namespace System.Management.Automation
         internal static ComTypeInfo GetDispatchTypeInfo(object comObject)
         {
             ComTypeInfo result = null;
-            IDispatch disp = comObject as IDispatch;
-            if (disp != null)
+
+            if (comObject is IDispatch disp)
             {
                 COM.ITypeInfo typeinfo = null;
                 disp.GetTypeInfo(0, 0, out typeinfo);
@@ -183,10 +183,7 @@ namespace System.Management.Automation
                 _properties[strName] = prop;
             }
 
-            if (prop != null)
-            {
-                prop.UpdateFuncDesc(funcdesc, index);
-            }
+            prop?.UpdateFuncDesc(funcdesc, index);
         }
 
         private void AddMethod(string strName, int index)
@@ -198,10 +195,7 @@ namespace System.Management.Automation
                 _methods[strName] = method;
             }
 
-            if (method != null)
-            {
-                method.AddFuncDesc(index);
-            }
+            method?.AddFuncDesc(index);
         }
 
         /// <summary>
diff --git a/src/System.Management.Automation/engine/CmdletParameterBinderController.cs b/src/System.Management.Automation/engine/CmdletParameterBinderController.cs
index 440b9ead5..b3c124abc 100644
--- a/src/System.Management.Automation/engine/CmdletParameterBinderController.cs
+++ b/src/System.Management.Automation/engine/CmdletParameterBinderController.cs
@@ -202,10 +202,7 @@ namespace System.Management.Automation
         internal void BindCommandLineParametersNoValidation(Collection<CommandParameterInternal> arguments)
         {
             var psCompiledScriptCmdlet = this.Command as PSScriptCmdlet;
-            if (psCompiledScriptCmdlet != null)
-            {
-                psCompiledScriptCmdlet.PrepareForBinding(this.CommandLineParameters);
-            }
+            psCompiledScriptCmdlet?.PrepareForBinding(this.CommandLineParameters);
 
             InitUnboundArguments(arguments);
             CommandMetadata cmdletMetadata = _commandMetadata;
@@ -402,8 +399,7 @@ namespace System.Management.Automation
 
                 try
                 {
-                    ScriptBlock scriptBlockArg = argumentValue as ScriptBlock;
-                    if (scriptBlockArg != null)
+                    if (argumentValue is ScriptBlock scriptBlockArg)
                     {
                         // Get the current binding state, and pass it to the ScriptBlock as the argument
                         // The 'arg' includes HashSet properties 'BoundParameters', 'BoundPositionalParameters',
@@ -1045,10 +1041,7 @@ namespace System.Management.Automation
                         _commandMetadata.ImplementsDynamicParameters,
                         "The metadata for the dynamic parameters should only be available if the command supports IDynamicParameters");
 
-                    if (_dynamicParameterBinder != null)
-                    {
-                        _dynamicParameterBinder.BindParameter(argumentToBind.ParameterName, argumentToBind.ArgumentValue, parameter.Parameter);
-                    }
+                    _dynamicParameterBinder?.BindParameter(argumentToBind.ParameterName, argumentToBind.ArgumentValue, parameter.Parameter);
 
                     break;
             }
@@ -1611,9 +1604,7 @@ namespace System.Management.Automation
                 {
                     s_tracer.WriteLine("The Cmdlet supports the dynamic parameter interface");
 
-                    IDynamicParameters dynamicParameterCmdlet = this.Command as IDynamicParameters;
-
-                    if (dynamicParameterCmdlet != null)
+                    if (this.Command is IDynamicParameters dynamicParameterCmdlet)
                     {
                         if (_dynamicParameterBinder == null)
                         {
@@ -1658,8 +1649,7 @@ namespace System.Management.Automation
 
                                 InternalParameterMetadata dynamicParameterMetadata;
 
-                                RuntimeDefinedParameterDictionary runtimeParamDictionary = dynamicParamBindableObject as RuntimeDefinedParameterDictionary;
-                                if (runtimeParamDictionary != null)
+                                if (dynamicParamBindableObject is RuntimeDefinedParameterDictionary runtimeParamDictionary)
                                 {
                                     // Generate the type metadata for the runtime-defined parameters
                                     dynamicParameterMetadata =
diff --git a/src/System.Management.Automation/engine/ComInterop/ComBinder.cs b/src/System.Management.Automation/engine/ComInterop/ComBinder.cs
index 726f336ec..28e0eaf77 100644
--- a/src/System.Management.Automation/engine/ComInterop/ComBinder.cs
+++ b/src/System.Management.Automation/engine/ComInterop/ComBinder.cs
@@ -367,8 +367,7 @@ namespace System.Management.Automation.ComInterop
 
             public override bool Equals(object obj)
             {
-                ComInvokeMemberBinder other = obj as ComInvokeMemberBinder;
-                return other != null &&
+                return obj is ComInvokeMemberBinder other &&
                     IsPropertySet == other.IsPropertySet &&
                     _originalBinder.Equals(other._originalBinder);
             }
diff --git a/src/System.Management.Automation/engine/ComInterop/IDispatchMetaObject.cs b/src/System.Management.Automation/engine/ComInterop/IDispatchMetaObject.cs
index b340cf549..53a67d80f 100644
--- a/src/System.Management.Automation/engine/ComInterop/IDispatchMetaObject.cs
+++ b/src/System.Management.Automation/engine/ComInterop/IDispatchMetaObject.cs
@@ -26,10 +26,8 @@ namespace System.Management.Automation.ComInterop
             Requires.NotNull(binder, nameof(binder));
 
             ComMethodDesc method = null;
-
             // See if this is actually a property set
-            ComBinder.ComInvokeMemberBinder comInvokeBinder = binder as ComBinder.ComInvokeMemberBinder;
-            if ((comInvokeBinder != null) && (comInvokeBinder.IsPropertySet))
+            if ((binder is ComBinder.ComInvokeMemberBinder comInvokeBinder) && (comInvokeBinder.IsPropertySet))
             {
                 DynamicMetaObject value = args[args.Length - 1];
 
diff --git a/src/System.Management.Automation/engine/CommandCompletion/CompletionAnalysis.cs b/src/System.Management.Automation/engine/CommandCompletion/CompletionAnalysis.cs
index f8961956a..8e0620025 100644
--- a/src/System.Management.Automation/engine/CommandCompletion/CompletionAnalysis.cs
+++ b/src/System.Management.Automation/engine/CommandCompletion/CompletionAnalysis.cs
@@ -240,7 +240,7 @@ namespace System.Management.Automation
             Tuple<Token, Ast> fileConditionTuple;
 
             var errorStatement = lastAst as ErrorStatementAst;
-            if (errorStatement != null && errorStatement.Flags != null && errorStatement.Kind != null && tokenBeforeCursor != null &&
+            if (errorStatement?.Flags != null && errorStatement.Kind != null && tokenBeforeCursor != null &&
                 errorStatement.Kind.Kind.Equals(TokenKind.Switch) && errorStatement.Flags.TryGetValue("file", out fileConditionTuple))
             {
                 // Handle "switch -file <tab>"
@@ -289,7 +289,7 @@ namespace System.Management.Automation
 
             // Handle "switch -f<tab>"
             var errorStatement = lastAst as ErrorStatementAst;
-            if (errorStatement != null && errorStatement.Kind != null)
+            if (errorStatement?.Kind != null)
             {
                 switch (errorStatement.Kind.Kind)
                 {
@@ -318,7 +318,7 @@ namespace System.Management.Automation
                     last = last.Parent;
                 }
 
-                if (errorStatement != null && errorStatement.Kind != null)
+                if (errorStatement?.Kind != null)
                 {
                     switch (errorStatement.Kind.Kind)
                     {
@@ -493,9 +493,8 @@ namespace System.Management.Automation
                         break;
 
                     case TokenKind.RBracket:
-                        if (lastAst is TypeExpressionAst)
+                        if (lastAst is TypeExpressionAst targetExpr)
                         {
-                            var targetExpr = (TypeExpressionAst)lastAst;
                             var memberResult = new List<CompletionResult>();
 
                             CompletionCompleters.CompleteMemberHelper(
@@ -1877,7 +1876,7 @@ namespace System.Management.Automation
 
                 // Handle the StringExpandableToken;
                 var strToken = tokenAtCursor as StringExpandableToken;
-                if (strToken != null && strToken.NestedTokens != null && strConst != null)
+                if (strToken?.NestedTokens != null && strConst != null)
                 {
                     try
                     {
diff --git a/src/System.Management.Automation/engine/CommandCompletion/CompletionCompleters.cs b/src/System.Management.Automation/engine/CommandCompletion/CompletionCompleters.cs
index 853b79e78..7a380857c 100644
--- a/src/System.Management.Automation/engine/CommandCompletion/CompletionCompleters.cs
+++ b/src/System.Management.Automation/engine/CommandCompletion/CompletionCompleters.cs
@@ -1191,9 +1191,8 @@ namespace System.Management.Automation
                 }
             }
 
-            if (expressionAst is StringConstantExpressionAst)
+            if (expressionAst is StringConstantExpressionAst pathAst)
             {
-                var pathAst = (StringConstantExpressionAst)expressionAst;
                 // Handle static member completion: echo [int]::<tab>
                 var shareMatch = Regex.Match(pathAst.Value, @"^(\[[\w\d\.]+\]::[\w\d\*]*)$");
                 if (shareMatch.Success)
diff --git a/src/System.Management.Automation/engine/CommandCompletion/PseudoParameterBinder.cs b/src/System.Management.Automation/engine/CommandCompletion/PseudoParameterBinder.cs
index 0d1952802..41769ca97 100644
--- a/src/System.Management.Automation/engine/CommandCompletion/PseudoParameterBinder.cs
+++ b/src/System.Management.Automation/engine/CommandCompletion/PseudoParameterBinder.cs
@@ -191,7 +191,7 @@ namespace System.Management.Automation.Language
 
         internal AstPair(CommandParameterAst parameterAst, ExpressionAst argumentAst)
         {
-            if (parameterAst != null && parameterAst.Argument != null)
+            if (parameterAst?.Argument != null)
                 throw PSTraceSource.NewArgumentException(nameof(parameterAst));
 
             if (parameterAst == null && argumentAst == null)
@@ -211,7 +211,7 @@ namespace System.Management.Automation.Language
 
         internal AstPair(CommandParameterAst parameterAst, CommandElementAst argumentAst)
         {
-            if (parameterAst != null && parameterAst.Argument != null)
+            if (parameterAst?.Argument != null)
                 throw PSTraceSource.NewArgumentException(nameof(parameterAst));
 
             if (parameterAst == null || argumentAst == null)
@@ -486,22 +486,18 @@ namespace System.Management.Automation.Language
                     object constantValue = null;
 
                     // This is a single argument
-                    AstPair argumentAstPair = bindingInfo.BoundArguments[item.Key] as AstPair;
-                    if (argumentAstPair != null)
+                    if (bindingInfo.BoundArguments[item.Key] is AstPair argumentAstPair)
                     {
                         value = argumentAstPair.Argument;
                     }
 
-                    // This is a parameter that took an argument, as well as ValueFromRemainingArguments.
-                    // Merge the arguments into a single fake argument.
-                    AstArrayPair argumentAstArrayPair = bindingInfo.BoundArguments[item.Key] as AstArrayPair;
-                    if (argumentAstArrayPair != null)
+                    // This is a parameter that took an argument, as well as ValueFromRemainingArguments.                    // Merge the arguments into a single fake argument.
+                    if (bindingInfo.BoundArguments[item.Key] is AstArrayPair argumentAstArrayPair)
                     {
                         List<ExpressionAst> arguments = new List<ExpressionAst>();
                         foreach (ExpressionAst expression in argumentAstArrayPair.Argument)
                         {
-                            ArrayLiteralAst expressionArray = expression as ArrayLiteralAst;
-                            if (expressionArray != null)
+                            if (expression is ArrayLiteralAst expressionArray)
                             {
                                 foreach (ExpressionAst newExpression in expressionArray.Elements)
                                 {
@@ -614,8 +610,7 @@ namespace System.Management.Automation.Language
                     continue;
                 }
 
-                CommandParameterAst parameter = commandElement as CommandParameterAst;
-                if (parameter != null)
+                if (commandElement is CommandParameterAst parameter)
                 {
                     if (currentParameter != null)
                     {
@@ -1203,25 +1198,21 @@ namespace System.Management.Automation.Language
             }
 
             var commandProcessor = processor as CommandProcessor;
-            var scriptProcessor = processor as ScriptCommandProcessorBase;
             bool implementsDynamicParameters = commandProcessor != null &&
                                                commandProcessor.CommandInfo.ImplementsDynamicParameters;
 
             var argumentsToGetDynamicParameters = implementsDynamicParameters
                                                       ? new List<object>(_commandElements.Count)
                                                       : null;
-            if (commandProcessor != null || scriptProcessor != null)
+
+            if (commandProcessor != null || processor is ScriptCommandProcessorBase scriptProcessor)
             {
                 // Pre-processing the arguments -- command arguments
                 for (commandIndex++; commandIndex < _commandElements.Count; commandIndex++)
                 {
-                    var parameter = _commandElements[commandIndex] as CommandParameterAst;
-                    if (parameter != null)
+                    if (_commandElements[commandIndex] is CommandParameterAst parameter)
                     {
-                        if (argumentsToGetDynamicParameters != null)
-                        {
-                            argumentsToGetDynamicParameters.Add(parameter.Extent.Text);
-                        }
+                        argumentsToGetDynamicParameters?.Add(parameter.Extent.Text);
 
                         AstPair parameterArg = parameter.Argument != null
                             ? new AstPair(parameter)
@@ -1231,16 +1222,13 @@ namespace System.Management.Automation.Language
                     }
                     else
                     {
-                        var dash = _commandElements[commandIndex] as StringConstantExpressionAst;
-                        if (dash != null && dash.Value.Trim().Equals("-", StringComparison.OrdinalIgnoreCase))
+                        if (_commandElements[commandIndex] is StringConstantExpressionAst dash && dash.Value.Trim().Equals("-", StringComparison.OrdinalIgnoreCase))
                         {
                             // "-" is represented by StringConstantExpressionAst. Most likely the user type a tab here,
                             // and we don't want it be treated as an argument
                             continue;
                         }
-
-                        var expressionArgument = _commandElements[commandIndex] as ExpressionAst;
-                        if (expressionArgument != null)
+                        if (_commandElements[commandIndex] is ExpressionAst expressionArgument)
                         {
                             argumentsToGetDynamicParameters?.Add(expressionArgument.Extent.Text);
 
@@ -1307,7 +1295,7 @@ namespace System.Management.Automation.Language
                 _bindableParameters = commandProcessor.CmdletParameterBinderController.BindableParameters;
                 _defaultParameterSetFlag = commandProcessor.CommandInfo.CommandMetadata.DefaultParameterSetFlag;
             }
-            else if (scriptProcessor != null)
+            else if (processor is ScriptCommandProcessorBase scriptProcessor)
             {
                 _function = true;
                 _commandInfo = scriptProcessor.CommandInfo;
@@ -1542,8 +1530,7 @@ namespace System.Management.Automation.Language
                     else
                     {
                         // The next item is a pure argument.
-                        AstPair nextArgument = nextArg as AstPair;
-                        Diagnostics.Assert(nextArgument != null, "the next item should be a pure argument here");
+                        Diagnostics.Assert(nextArg is AstPair nextArgument, "the next item should be a pure argument here");
                         Diagnostics.Assert(nextArgument.ArgumentSpecified && !nextArgument.ArgumentIsCommandParameterAst, "the next item should be a pure argument here");
 
                         AstPair newArg = new AstPair(argument.Parameter, (ExpressionAst)nextArgument.Argument);
diff --git a/src/System.Management.Automation/engine/CommandInfo.cs b/src/System.Management.Automation/engine/CommandInfo.cs
index 7538d9fb1..a5d5d5899 100644
--- a/src/System.Management.Automation/engine/CommandInfo.cs
+++ b/src/System.Management.Automation/engine/CommandInfo.cs
@@ -372,7 +372,7 @@ namespace System.Management.Automation
                 else
                 {
                     CmdletInfo cmdlet = this as CmdletInfo;
-                    if (cmdlet != null && cmdlet.PSSnapIn != null)
+                    if (cmdlet?.PSSnapIn != null)
                     {
                         moduleName = cmdlet.PSSnapInName;
                     }
@@ -489,8 +489,7 @@ namespace System.Management.Automation
 
         private void OnGetMergedCommandParameterMetadataSafelyEventHandler(object sender, PSEventArgs args)
         {
-            var eventArgs = args.SourceEventArgs as GetMergedCommandParameterMetadataSafelyEventArgs;
-            if (eventArgs != null)
+            if (args.SourceEventArgs is GetMergedCommandParameterMetadataSafelyEventArgs eventArgs)
             {
                 try
                 {
@@ -525,8 +524,7 @@ namespace System.Management.Automation
             }
             else
             {
-                IScriptCommandInfo scriptCommand = this as IScriptCommandInfo;
-                processor = scriptCommand != null
+                processor = this is IScriptCommandInfo scriptCommand
                     ? new CommandProcessor(scriptCommand, _context, useLocalScope: true, fromScriptFile: false,
                         sessionState: scriptCommand.ScriptBlock.SessionStateInternal ?? Context.EngineSessionState)
                     : new CommandProcessor((CmdletInfo)this, _context) { UseLocalScope = true };
@@ -828,7 +826,7 @@ namespace System.Management.Automation
             else
             {
                 var t = typeName as TypeName;
-                if (t != null && t._typeDefinitionAst != null)
+                if (t?._typeDefinitionAst != null)
                 {
                     TypeDefinitionAst = t._typeDefinitionAst;
                     Name = TypeDefinitionAst.Name;
diff --git a/src/System.Management.Automation/engine/CommandMetadata.cs b/src/System.Management.Automation/engine/CommandMetadata.cs
index eb59f9140..3788bb459 100644
--- a/src/System.Management.Automation/engine/CommandMetadata.cs
+++ b/src/System.Management.Automation/engine/CommandMetadata.cs
@@ -699,15 +699,14 @@ namespace System.Management.Automation
 
             foreach (Attribute attribute in customAttributes)
             {
-                CmdletAttribute cmdletAttribute = attribute as CmdletAttribute;
-                if (cmdletAttribute != null)
+                if (attribute is CmdletAttribute cmdletAttribute)
                 {
                     ProcessCmdletAttribute(cmdletAttribute);
                     this.Name = cmdletAttribute.VerbName + "-" + cmdletAttribute.NounName;
                 }
-                else if (attribute is ObsoleteAttribute)
+                else if (attribute is ObsoleteAttribute obsoleteAttribute)
                 {
-                    Obsolete = (ObsoleteAttribute)attribute;
+                    Obsolete = obsoleteAttribute;
                 }
                 else
                 {
@@ -757,8 +756,7 @@ namespace System.Management.Automation
             _remotingCapability = attribute.RemotingCapability;
 
             // Check to see if the cmdlet uses positional binding
-            var cmdletBindingAttribute = attribute as CmdletBindingAttribute;
-            if (cmdletBindingAttribute != null)
+            if (attribute is CmdletBindingAttribute cmdletBindingAttribute)
             {
                 PositionalBinding = cmdletBindingAttribute.PositionalBinding;
             }
diff --git a/src/System.Management.Automation/engine/CommandProcessorBase.cs b/src/System.Management.Automation/engine/CommandProcessorBase.cs
index c6825cc69..72e065b4c 100644
--- a/src/System.Management.Automation/engine/CommandProcessorBase.cs
+++ b/src/System.Management.Automation/engine/CommandProcessorBase.cs
@@ -777,8 +777,7 @@ namespace System.Management.Automation
                 {
                     do // false loop
                     {
-                        ProviderInvocationException pie = e as ProviderInvocationException;
-                        if (pie != null)
+                        if (e is ProviderInvocationException pie)
                         {
                             // If a ProviderInvocationException occurred,
                             // discard the ProviderInvocationException and
@@ -805,8 +804,7 @@ namespace System.Management.Automation
                             break;
                         }
 
-                        RuntimeException rte = e as RuntimeException;
-                        if (rte != null && rte.WasThrownFromThrowStatement)
+                        if (e is RuntimeException rte && rte.WasThrownFromThrowStatement)
                         {
                             // do not rewrap a script based throw
                             break;
@@ -951,10 +949,7 @@ namespace System.Management.Automation
                 // whether IDisposable is implemented, in order to avoid
                 // this expensive reflection cast.
                 IDisposable id = Command as IDisposable;
-                if (id != null)
-                {
-                    id.Dispose();
-                }
+                id?.Dispose();
             }
 
             _disposed = true;
diff --git a/src/System.Management.Automation/engine/CommonCommandParameters.cs b/src/System.Management.Automation/engine/CommonCommandParameters.cs
index 376b9d0ad..72f699984 100644
--- a/src/System.Management.Automation/engine/CommonCommandParameters.cs
+++ b/src/System.Management.Automation/engine/CommonCommandParameters.cs
@@ -240,8 +240,7 @@ namespace System.Management.Automation.Internal
         {
             protected override void Validate(object arguments, EngineIntrinsics engineIntrinsics)
             {
-                string varName = arguments as string;
-                if (varName != null)
+                if (arguments is string varName)
                 {
                     if (varName.StartsWith('+'))
                     {
diff --git a/src/System.Management.Automation/engine/CompiledCommandParameter.cs b/src/System.Management.Automation/engine/CompiledCommandParameter.cs
index dc74210bd..9f26dcaa4 100644
--- a/src/System.Management.Automation/engine/CompiledCommandParameter.cs
+++ b/src/System.Management.Automation/engine/CompiledCommandParameter.cs
@@ -437,8 +437,7 @@ namespace System.Management.Automation
                 return;
             }
 
-            ValidateArgumentsAttribute validateAttr = attribute as ValidateArgumentsAttribute;
-            if (validateAttr != null)
+            if (attribute is ValidateArgumentsAttribute validateAttr)
             {
                 if (validationAttributes == null)
                     validationAttributes = new Collection<ValidateArgumentsAttribute>();
@@ -451,8 +450,7 @@ namespace System.Management.Automation
                 return;
             }
 
-            AliasAttribute aliasAttr = attribute as AliasAttribute;
-            if (aliasAttr != null)
+            if (attribute is AliasAttribute aliasAttr)
             {
                 if (aliases == null)
                 {
@@ -470,8 +468,7 @@ namespace System.Management.Automation
                 return;
             }
 
-            ArgumentTransformationAttribute argumentAttr = attribute as ArgumentTransformationAttribute;
-            if (argumentAttr != null)
+            if (attribute is ArgumentTransformationAttribute argumentAttr)
             {
                 if (argTransformationAttributes == null)
                     argTransformationAttributes = new Collection<ArgumentTransformationAttribute>();
@@ -479,36 +476,31 @@ namespace System.Management.Automation
                 return;
             }
 
-            AllowNullAttribute allowNullAttribute = attribute as AllowNullAttribute;
-            if (allowNullAttribute != null)
+            if (attribute is AllowNullAttribute allowNullAttribute)
             {
                 this.AllowsNullArgument = true;
                 return;
             }
 
-            AllowEmptyStringAttribute allowEmptyStringAttribute = attribute as AllowEmptyStringAttribute;
-            if (allowEmptyStringAttribute != null)
+            if (attribute is AllowEmptyStringAttribute allowEmptyStringAttribute)
             {
                 this.AllowsEmptyStringArgument = true;
                 return;
             }
 
-            AllowEmptyCollectionAttribute allowEmptyCollectionAttribute = attribute as AllowEmptyCollectionAttribute;
-            if (allowEmptyCollectionAttribute != null)
+            if (attribute is AllowEmptyCollectionAttribute allowEmptyCollectionAttribute)
             {
                 this.AllowsEmptyCollectionArgument = true;
                 return;
             }
 
-            ObsoleteAttribute obsoleteAttr = attribute as ObsoleteAttribute;
-            if (obsoleteAttr != null)
+            if (attribute is ObsoleteAttribute obsoleteAttr)
             {
                 ObsoleteAttribute = obsoleteAttr;
                 return;
             }
 
-            PSTypeNameAttribute psTypeNameAttribute = attribute as PSTypeNameAttribute;
-            if (psTypeNameAttribute != null)
+            if (attribute is PSTypeNameAttribute psTypeNameAttribute)
             {
                 this.PSTypeName = psTypeNameAttribute.PSTypeName;
             }
diff --git a/src/System.Management.Automation/engine/CoreAdapter.cs b/src/System.Management.Automation/engine/CoreAdapter.cs
index 48077bbaf..6549e48d9 100644
--- a/src/System.Management.Automation/engine/CoreAdapter.cs
+++ b/src/System.Management.Automation/engine/CoreAdapter.cs
@@ -349,8 +349,7 @@ namespace System.Management.Automation
                 newParameters[i + 1] = parameters[i];
             }
 
-            Exception ex = e as TargetInvocationException;
-            if (ex != null)
+            if (e is TargetInvocationException ex)
             {
                 Exception inner = ex.InnerException ?? ex;
                 newParameters[0] = inner.Message;
@@ -1166,8 +1165,7 @@ namespace System.Management.Automation
         {
             if (method.IsGenericMethod && !method.IsGenericMethodDefinition)
             {
-                MethodInfo methodInfo = method as MethodInfo;
-                if (methodInfo != null)
+                if (method is MethodInfo methodInfo)
                 {
                     return methodInfo.GetGenericMethodDefinition();
                 }
@@ -1355,8 +1353,7 @@ namespace System.Management.Automation
             // }
             //
             // If we have such information in invocationConstraints then we should call method on the baseClass.
-            if (invocationConstraints != null &&
-                invocationConstraints.MethodTargetType != null &&
+            if (invocationConstraints?.MethodTargetType != null &&
                 methodInfo.method != null &&
                 methodInfo.method.DeclaringType != null)
             {
@@ -1419,7 +1416,7 @@ namespace System.Management.Automation
                 {
                     Type[] argumentTypesForTypeInference = new Type[argumentTypes.Length];
                     Array.Copy(argumentTypes, argumentTypesForTypeInference, argumentTypes.Length);
-                    if (invocationConstraints != null && invocationConstraints.ParameterTypes != null)
+                    if (invocationConstraints?.ParameterTypes != null)
                     {
                         int parameterIndex = 0;
                         foreach (Type typeConstraintFromCallSite in invocationConstraints.ParameterTypes)
@@ -1617,8 +1614,7 @@ namespace System.Management.Automation
             if (arg != null)
             {
                 arg = PSObject.Base(arg);
-                object[] argAsArray = arg as object[];
-                if (argAsArray != null && argAsArray.Length > 0 && PSObject.Base(argAsArray[0]) != null)
+                if (arg is object[] argAsArray && argAsArray.Length > 0 && PSObject.Base(argAsArray[0]) != null)
                 {
                     Type firstType = PSObject.Base(argAsArray[0]).GetType();
                     bool allSameType = true;
@@ -1879,21 +1875,20 @@ namespace System.Management.Automation
         internal static object UnReference(object obj, out bool isArgumentByRef)
         {
             isArgumentByRef = false;
-            PSReference reference = obj as PSReference;
-            if (reference != null)
+
+            if (obj is PSReference reference)
             {
                 PSObject.MemberResolution.WriteLine("Parameter was a reference.");
                 isArgumentByRef = true;
                 return reference.Value;
             }
 
-            PSObject mshObj = obj as PSObject;
-            if (mshObj != null)
+            if (obj is PSObject mshObj)
             {
                 reference = mshObj.BaseObject as PSReference;
             }
 
-            if (reference != null)
+            if (obj is PSReference reference)
             {
                 PSObject.MemberResolution.WriteLine("Parameter was an PSObject containing a reference.");
                 isArgumentByRef = true;
@@ -1913,8 +1908,7 @@ namespace System.Management.Automation
                     throw PSTraceSource.NewArgumentNullException(nameof(resultType));
                 }
 
-                PSObject mshObj = valueToConvert as PSObject;
-                if (mshObj != null)
+                if (valueToConvert is PSObject mshObj)
                 {
                     if (resultType == typeof(object))
                     {
@@ -2820,8 +2814,7 @@ namespace System.Management.Automation
                 var parameter = Expression.Parameter(typeof(object));
                 Expression instance = null;
 
-                var field = member as FieldInfo;
-                if (field != null)
+                if (member is FieldInfo field)
                 {
                     var declaringType = field.DeclaringType;
                     if (!field.IsStatic)
@@ -2881,8 +2874,7 @@ namespace System.Management.Automation
                 var value = Expression.Parameter(typeof(object));
                 Expression instance = null;
 
-                var field = member as FieldInfo;
-                if (field != null)
+                if (member is FieldInfo field)
                 {
                     var declaringType = field.DeclaringType;
                     if (!field.IsStatic)
@@ -3587,8 +3579,7 @@ namespace System.Management.Automation
                 : GetInstancePropertyReflectionTable(type);
             for (int i = 0; i < propertyTable.memberCollection.Count; i++)
             {
-                var propertyCacheEntry = propertyTable.memberCollection[i] as PropertyCacheEntry;
-                if (propertyCacheEntry != null)
+                if (propertyTable.memberCollection[i] is PropertyCacheEntry propertyCacheEntry)
                     yield return propertyCacheEntry.member;
             }
 
@@ -3597,8 +3588,7 @@ namespace System.Management.Automation
                 : GetInstanceMethodReflectionTable(type);
             for (int i = 0; i < methodTable.memberCollection.Count; i++)
             {
-                var method = methodTable.memberCollection[i] as MethodCacheEntry;
-                if (method != null && !method[0].method.IsSpecialName)
+                if (methodTable.memberCollection[i] is MethodCacheEntry method && !method[0].method.IsSpecialName)
                 {
                     yield return method;
                 }
@@ -4030,8 +4020,7 @@ namespace System.Management.Automation
                     adapterData.propertyType);
             }
 
-            PropertyInfo propertyInfo = adapterData.member as PropertyInfo;
-            if (propertyInfo != null)
+            if (adapterData.member is PropertyInfo propertyInfo)
             {
                 if (adapterData.writeOnly)
                 {
@@ -4092,8 +4081,7 @@ namespace System.Management.Automation
                     adapterData.propertyType);
             }
 
-            PropertyInfo propertyInfo = adapterData.member as PropertyInfo;
-            if (propertyInfo != null)
+            if (adapterData.member is PropertyInfo propertyInfo)
             {
                 if (convertIfPossible)
                 {
@@ -4273,8 +4261,8 @@ namespace System.Management.Automation
 #pragma warning restore 56500
 
             SetReferences(arguments, methodInformation, originalArguments);
-            MethodInfo methodInfo = methodInformation.method as MethodInfo;
-            if (methodInfo != null && methodInfo.ReturnType != typeof(void))
+
+            if (methodInformation.method is MethodInfo methodInfo && methodInfo.ReturnType != typeof(void))
                 return result;
             return AutomationNull.Value;
         }
@@ -4410,16 +4398,14 @@ namespace System.Management.Automation
                 builder.Append("static ");
             }
 
-            MethodInfo method = methodEntry as MethodInfo;
-            if (method != null)
+            if (methodEntry is MethodInfo method)
             {
                 builder.Append(ToStringCodeMethods.Type(method.ReturnType));
                 builder.Append(' ');
             }
             else
             {
-                ConstructorInfo ctorInfo = methodEntry as ConstructorInfo;
-                if (ctorInfo != null)
+                if (methodEntry is ConstructorInfo ctorInfo)
                 {
                     builder.Append(ToStringCodeMethods.Type(ctorInfo.DeclaringType));
                     builder.Append(' ');
@@ -4955,8 +4941,7 @@ namespace System.Management.Automation
             PSObject mshObj = (PSObject)obj;
             foreach (PSMemberInfo member in mshObj.Members)
             {
-                T memberAsT = member as T;
-                if (memberAsT != null)
+                if (member is T memberAsT)
                 {
                     returnValue.Add(memberAsT);
                 }
@@ -5030,8 +5015,7 @@ namespace System.Management.Automation
             var returnValue = new PSMemberInfoInternalCollection<T>();
             foreach (PSMemberInfo member in ((PSMemberSet)obj).Members)
             {
-                T memberAsT = member as T;
-                if (memberAsT != null)
+                if (member is T memberAsT)
                 {
                     returnValue.Add(memberAsT);
                 }
@@ -5401,8 +5385,7 @@ namespace System.Management.Automation
 
         private static object GetNodeObject(XmlNode node)
         {
-            XmlText text = node as XmlText;
-            if (text != null)
+            if (node is XmlText text)
             {
                 return text.InnerText;
             }
@@ -5428,8 +5411,7 @@ namespace System.Management.Automation
                 return node.InnerText;
             }
 
-            XmlAttribute attribute = node as XmlAttribute;
-            if (attribute != null)
+            if (node is XmlAttribute attribute)
             {
                 return attribute.Value;
             }
@@ -5480,8 +5462,8 @@ namespace System.Management.Automation
             }
 
             XmlNode node = nodes[0];
-            XmlText text = node as XmlText;
-            if (text != null)
+
+            if (node is XmlText text)
             {
                 text.InnerText = valueString;
                 return;
@@ -5510,8 +5492,7 @@ namespace System.Management.Automation
                 return;
             }
 
-            XmlAttribute attribute = node as XmlAttribute;
-            if (attribute != null)
+            if (node is XmlAttribute attribute)
             {
                 attribute.Value = valueString;
                 return;
diff --git a/src/System.Management.Automation/engine/DscResourceSearcher.cs b/src/System.Management.Automation/engine/DscResourceSearcher.cs
index bfd406f56..2b587c3a9 100644
--- a/src/System.Management.Automation/engine/DscResourceSearcher.cs
+++ b/src/System.Management.Automation/engine/DscResourceSearcher.cs
@@ -151,9 +151,7 @@ namespace System.Management.Automation
 
                             resourceInfo.CompanyName = resource.CompanyName;
 
-                            PSModuleInfo psMod = resource.Module as PSModuleInfo;
-
-                            if (psMod != null)
+                            if (resource.Module is PSModuleInfo psMod)
                                 resourceInfo.Module = psMod;
 
                             if (resource.ImplementedAs != null)
@@ -163,9 +161,7 @@ namespace System.Management.Automation
                                     resourceInfo.ImplementedAs = impType;
                             }
 
-                            var properties = resource.Properties as IList;
-
-                            if (properties != null)
+                            if (resource.Properties is IList properties)
                             {
                                 List<DscResourcePropertyInfo> propertyList = new List<DscResourcePropertyInfo>();
 
diff --git a/src/System.Management.Automation/engine/ErrorPackage.cs b/src/System.Management.Automation/engine/ErrorPackage.cs
index 7d6a1f275..48ce14bd5 100644
--- a/src/System.Management.Automation/engine/ErrorPackage.cs
+++ b/src/System.Management.Automation/engine/ErrorPackage.cs
@@ -1302,8 +1302,7 @@ namespace System.Management.Automation
             string exceptionMessage = null;
             if (serializedException != null)
             {
-                PSPropertyInfo messageProperty = serializedException.Properties["Message"] as PSPropertyInfo;
-                if (messageProperty != null)
+                if (serializedException.Properties["Message"] is PSPropertyInfo messageProperty)
                 {
                     exceptionMessage = messageProperty.Value as string;
                 }
@@ -1569,7 +1568,7 @@ namespace System.Management.Automation
             //
             // Copy a snapshot of the PipelinePositionInfo from the InvocationInfo to this ErrorRecord
             //
-            if (invocationInfo != null && invocationInfo.PipelineIterationInfo != null)
+            if (invocationInfo?.PipelineIterationInfo != null)
             {
                 int[] snapshot = (int[])invocationInfo.PipelineIterationInfo.Clone();
 
@@ -1663,8 +1662,7 @@ namespace System.Management.Automation
                 return string.Empty;
             }
 
-            IScriptCommandInfo scriptInfo = commandInfo as IScriptCommandInfo;
-            if (scriptInfo != null)
+            if (commandInfo is IScriptCommandInfo scriptInfo)
             {
                 return commandInfo.Name;
             }
diff --git a/src/System.Management.Automation/engine/EventManager.cs b/src/System.Management.Automation/engine/EventManager.cs
index fd3029866..cd863846b 100644
--- a/src/System.Management.Automation/engine/EventManager.cs
+++ b/src/System.Management.Automation/engine/EventManager.cs
@@ -1532,10 +1532,7 @@ namespace System.Management.Automation
             {
                 lock (_eventSubscribers)
                 {
-                    if (_timer != null)
-                    {
-                        _timer.Dispose();
-                    }
+                    _timer?.Dispose();
 
                     foreach (PSEventSubscriber currentSubscriber in _eventSubscribers.Keys.ToArray())
                     {
diff --git a/src/System.Management.Automation/engine/ExecutionContext.cs b/src/System.Management.Automation/engine/ExecutionContext.cs
index 3857de9ba..24560c218 100644
--- a/src/System.Management.Automation/engine/ExecutionContext.cs
+++ b/src/System.Management.Automation/engine/ExecutionContext.cs
@@ -53,15 +53,9 @@ namespace System.Management.Automation
         /// </summary>
         internal void ResetManagers()
         {
-            if (_debugger != null)
-            {
-                _debugger.ResetDebugger();
-            }
+            _debugger?.ResetDebugger();
 
-            if (Events != null)
-            {
-                Events.Dispose();
-            }
+            Events?.Dispose();
 
             Events = new PSLocalEventManager(this);
             if (this.transactionManager != null)
@@ -575,15 +569,13 @@ namespace System.Management.Automation
         internal T GetEnumPreference<T>(VariablePath preferenceVariablePath, T defaultPref, out bool defaultUsed)
         {
             object val = EngineSessionState.GetVariableValue(preferenceVariablePath, out _, out _);
-            if (val is T)
+            if (val is T convertedResult)
             {
                 if (val is ActionPreference actionPreferenceValue)
                 {
                     CheckActionPreference(preferenceVariablePath, actionPreferenceValue, defaultPref);
                 }
 
-                T convertedResult = (T)val;
-
                 defaultUsed = false;
                 return convertedResult;
             }
@@ -698,7 +690,7 @@ namespace System.Management.Automation
             CommandProcessorBase commandProcessor =
                 CommandDiscovery.LookupCommandProcessor(command, commandOrigin, !dotSource);
             // Reset the command origin for script commands... // BUGBUG - dotting can get around command origin checks???
-            if (commandProcessor != null && commandProcessor is ScriptCommandProcessorBase)
+            if (commandProcessor is ScriptCommandProcessorBase)
             {
                 commandProcessor.Command.CommandOriginInternal = CommandOrigin.Internal;
             }
@@ -1209,15 +1201,9 @@ namespace System.Management.Automation
         {
             EngineSessionState.RunspaceClosingNotification();
 
-            if (_debugger != null)
-            {
-                _debugger.Dispose();
-            }
+            _debugger?.Dispose();
 
-            if (Events != null)
-            {
-                Events.Dispose();
-            }
+            Events?.Dispose();
 
             Events = null;
             if (this.transactionManager != null)
diff --git a/src/System.Management.Automation/engine/ExtraAdapter.cs b/src/System.Management.Automation/engine/ExtraAdapter.cs
index dd6ba0c07..40a4e55a4 100644
--- a/src/System.Management.Automation/engine/ExtraAdapter.cs
+++ b/src/System.Management.Automation/engine/ExtraAdapter.cs
@@ -191,9 +191,7 @@ namespace System.Management.Automation
         /// <param name="convertIfPossible">Instructs the adapter to convert before setting, if the adapter supports conversion.</param>
         protected override void PropertySet(PSProperty property, object setValue, bool convertIfPossible)
         {
-            PropertyValueCollection values = property.adapterData as PropertyValueCollection;
-
-            if (values != null)
+            if (property.adapterData is PropertyValueCollection values)
             {
                 // This means GetMember returned PropertyValueCollection
                 try
diff --git a/src/System.Management.Automation/engine/GetCommandCommand.cs b/src/System.Management.Automation/engine/GetCommandCommand.cs
index 9007bed24..d5e4b1890 100644
--- a/src/System.Management.Automation/engine/GetCommandCommand.cs
+++ b/src/System.Management.Automation/engine/GetCommandCommand.cs
@@ -611,12 +611,7 @@ namespace Microsoft.PowerShell.Commands
                 switch (command)
                 {
                     case ExternalScriptInfo externalScript:
-                        replacedSyntax = string.Format(
-                            "{0} (alias) -> {1}{2}{3}",
-                            aliasName,
-                            string.Format("{0}{1}", externalScript.Path, Environment.NewLine),
-                            Environment.NewLine,
-                            command.Syntax.Replace(command.Name, aliasName));
+                        replacedSyntax = $"{aliasName} (alias) -> {string.Format("{0}{1}", externalScript.Path, Environment.NewLine)}{Environment.NewLine}{command.Syntax.Replace(command.Name, aliasName)}";
                         break;
                     case ApplicationInfo app:
                         replacedSyntax = app.Path;
@@ -628,12 +623,7 @@ namespace Microsoft.PowerShell.Commands
                         }
                         else
                         {
-                            replacedSyntax = string.Format(
-                                "{0} (alias) -> {1}{2}{3}",
-                                aliasName,
-                                command.Name,
-                                Environment.NewLine,
-                                command.Syntax.Replace(command.Name, aliasName));
+                            replacedSyntax = $"{aliasName} (alias) -> {command.Name}{Environment.NewLine}{command.Syntax.Replace(command.Name, aliasName)}";
                         }
 
                         break;
@@ -729,8 +719,8 @@ namespace Microsoft.PowerShell.Commands
                 // Get the noun and verb to check...
                 string verb;
                 string noun;
-                CmdletInfo cmdlet = command as CmdletInfo;
-                if (cmdlet != null)
+
+                if (command is CmdletInfo cmdlet)
                 {
                     verb = cmdlet.Verb;
                     noun = cmdlet.Noun;
@@ -1108,29 +1098,25 @@ namespace Microsoft.PowerShell.Commands
 
             do // false loop
             {
-                ApplicationInfo appInfo = info as ApplicationInfo;
-                if (appInfo != null)
+                if (info is ApplicationInfo appInfo)
                 {
                     key = appInfo.Path;
                     break;
                 }
 
-                CmdletInfo cmdletInfo = info as CmdletInfo;
-                if (cmdletInfo != null)
+                if (info is CmdletInfo cmdletInfo)
                 {
                     key = cmdletInfo.FullName;
                     break;
                 }
 
-                ScriptInfo scriptInfo = info as ScriptInfo;
-                if (scriptInfo != null)
+                if (info is ScriptInfo scriptInfo)
                 {
                     key = scriptInfo.Definition;
                     break;
                 }
 
-                ExternalScriptInfo externalScriptInfo = info as ExternalScriptInfo;
-                if (externalScriptInfo != null)
+                if (info is ExternalScriptInfo externalScriptInfo)
                 {
                     key = externalScriptInfo.Path;
                     break;
diff --git a/src/System.Management.Automation/engine/InitialSessionState.cs b/src/System.Management.Automation/engine/InitialSessionState.cs
index 257cb79ce..d984507b1 100644
--- a/src/System.Management.Automation/engine/InitialSessionState.cs
+++ b/src/System.Management.Automation/engine/InitialSessionState.cs
@@ -1290,8 +1290,7 @@ namespace System.Management.Automation.Runspaces
                 string entryName = nameGetter(entry);
 
                 // Aliases to allowed commands are OK
-                SessionStateAliasEntry aliasEntry = entry as SessionStateAliasEntry;
-                if (aliasEntry != null)
+                if (entry is SessionStateAliasEntry aliasEntry)
                 {
                     if (allowedNames.Exists(allowedName => allowedName.Equals(aliasEntry.Definition, StringComparison.OrdinalIgnoreCase)))
                     {
@@ -2337,8 +2336,7 @@ namespace System.Management.Automation.Runspaces
                     RunspaceEventSource.Log.LoadCommandStart(cmd.Name);
                 }
 
-                SessionStateCmdletEntry ssce = cmd as SessionStateCmdletEntry;
-                if (ssce != null)
+                if (cmd is SessionStateCmdletEntry ssce)
                 {
                     if (noClobber && ModuleCmdletBase.CommandFound(ssce.Name, ss))
                     {
@@ -2354,22 +2352,19 @@ namespace System.Management.Automation.Runspaces
 
                 cmd.SetModule(module);
 
-                SessionStateFunctionEntry ssfe = cmd as SessionStateFunctionEntry;
-                if (ssfe != null)
+                if (cmd is SessionStateFunctionEntry ssfe)
                 {
                     ss.AddSessionStateEntry(ssfe);
                     continue;
                 }
 
-                SessionStateAliasEntry ssae = cmd as SessionStateAliasEntry;
-                if (ssae != null)
+                if (cmd is SessionStateAliasEntry ssae)
                 {
                     ss.AddSessionStateEntry(ssae, StringLiterals.Local);
                     continue;
                 }
 
-                SessionStateApplicationEntry ssappe = cmd as SessionStateApplicationEntry;
-                if (ssappe != null)
+                if (cmd is SessionStateApplicationEntry ssappe)
                 {
                     if (ssappe.Visibility == SessionStateEntryVisibility.Public)
                     {
@@ -2379,8 +2374,7 @@ namespace System.Management.Automation.Runspaces
                     continue;
                 }
 
-                SessionStateScriptEntry ssse = cmd as SessionStateScriptEntry;
-                if (ssse != null)
+                if (cmd is SessionStateScriptEntry ssse)
                 {
                     if (ssse.Visibility == SessionStateEntryVisibility.Public)
                     {
@@ -2660,8 +2654,7 @@ namespace System.Management.Automation.Runspaces
                 }
 
                 // If we are wrapping a function, rename it.
-                FunctionInfo commandAsFunction = existingCommand as FunctionInfo;
-                if (commandAsFunction != null)
+                if (existingCommand is FunctionInfo commandAsFunction)
                 {
                     string newCommandName = commandAsFunction.Name + "_" + Guid.NewGuid().ToString("N");
                     commandAsFunction.Rename(newCommandName);
@@ -2755,9 +2748,8 @@ namespace System.Management.Automation.Runspaces
                 if (variable.ContainsKey("Name"))
                 {
                     string name = variable["Name"].ToString();
-                    ScriptBlock sb = variable["Value"] as ScriptBlock;
 
-                    if (!string.IsNullOrEmpty(name) && (sb != null))
+                    if (!string.IsNullOrEmpty(name) && (variable["Value"] is ScriptBlock sb))
                     {
                         sb.SessionStateInternal = initializedRunspace.ExecutionContext.EngineSessionState;
 
@@ -2915,15 +2907,13 @@ namespace System.Management.Automation.Runspaces
                 ArrayList errorList = (ArrayList)initializedRunspace.GetExecutionContext.DollarErrorVariable;
                 if (errorList.Count > 0)
                 {
-                    ErrorRecord lastErrorRecord = errorList[0] as ErrorRecord;
-                    if (lastErrorRecord != null)
+                    if (errorList[0] is ErrorRecord lastErrorRecord)
                     {
                         return new Exception(lastErrorRecord.ToString());
                     }
                     else
                     {
-                        Exception lastException = errorList[0] as Exception;
-                        if (lastException != null)
+                        if (errorList[0] is Exception lastException)
                         {
                             return lastException;
                         }
@@ -2949,15 +2939,13 @@ namespace System.Management.Automation.Runspaces
 
             foreach (object module in moduleList)
             {
-                string moduleName = module as string;
-                if (moduleName != null)
+                if (module is string moduleName)
                 {
                     exceptionToReturn = ProcessOneModule(initializedRunspace, moduleName, null, path, publicCommands);
                 }
                 else
                 {
-                    ModuleSpecification moduleSpecification = module as ModuleSpecification;
-                    if (moduleSpecification != null)
+                    if (module is ModuleSpecification moduleSpecification)
                     {
                         if ((moduleSpecification.RequiredVersion == null) && (moduleSpecification.Version == null) && (moduleSpecification.MaximumVersion == null) && (moduleSpecification.Guid == null))
                         {
@@ -3406,8 +3394,7 @@ namespace System.Management.Automation.Runspaces
                 // Remove all of the commands from the top-level session state.
                 foreach (SessionStateCommandEntry cmd in Commands)
                 {
-                    SessionStateCmdletEntry ssce = cmd as SessionStateCmdletEntry;
-                    if (ssce != null)
+                    if (cmd is SessionStateCmdletEntry ssce)
                     {
                         List<CmdletInfo> matches;
                         if (context.TopLevelSessionState.GetCmdletTable().TryGetValue(ssce.Name, out matches))
@@ -3981,9 +3968,9 @@ namespace System.Management.Automation.Runspaces
                     Collection<SessionStateCommandEntry> funcList = Commands[f.Name];
                     foreach (var func in funcList)
                     {
-                        if (func is SessionStateFunctionEntry)
+                        if (func is SessionStateFunctionEntry sessionStateFunctionEntry)
                         {
-                            ((SessionStateFunctionEntry)func).SetHelpFile(helpFile);
+                            sessionStateFunctionEntry.SetHelpFile(helpFile);
                         }
                     }
                 }
diff --git a/src/System.Management.Automation/engine/InternalCommands.cs b/src/System.Management.Automation/engine/InternalCommands.cs
index b7b1d87cc..bfd4056c9 100644
--- a/src/System.Management.Automation/engine/InternalCommands.cs
+++ b/src/System.Management.Automation/engine/InternalCommands.cs
@@ -734,8 +734,7 @@ namespace Microsoft.PowerShell.Commands
                 if (member is PSMethodInfo)
                 {
                     // first we check if the member is a ParameterizedProperty
-                    PSParameterizedProperty targetParameterizedProperty = member as PSParameterizedProperty;
-                    if (targetParameterizedProperty != null)
+                    if (member is PSParameterizedProperty targetParameterizedProperty)
                     {
                         // should process
                         string propertyAction = string.Format(CultureInfo.InvariantCulture,
@@ -749,9 +748,7 @@ namespace Microsoft.PowerShell.Commands
 
                         return;
                     }
-
-                    PSMethodInfo targetMethod = member as PSMethodInfo;
-                    Dbg.Assert(targetMethod != null, "targetMethod should not be null here.");
+                    Dbg.Assert(member is PSMethodInfo targetMethod, "targetMethod should not be null here.");
                     try
                     {
                         // should process
@@ -775,7 +772,7 @@ namespace Microsoft.PowerShell.Commands
                     catch (Exception ex)
                     {
                         MethodException mex = ex as MethodException;
-                        if (mex != null && mex.ErrorRecord != null && mex.ErrorRecord.FullyQualifiedErrorId == "MethodCountCouldNotFindBest")
+                        if (mex?.ErrorRecord != null && mex.ErrorRecord.FullyQualifiedErrorId == "MethodCountCouldNotFindBest")
                         {
                             WriteObject(targetMethod.Value);
                         }
@@ -1055,8 +1052,7 @@ namespace Microsoft.PowerShell.Commands
             }
             else
             {
-                PSMethodInfo targetMethod = methods[0] as PSMethodInfo;
-                Dbg.Assert(targetMethod != null, "targetMethod should not be null here.");
+                Dbg.Assert(methods[0] is PSMethodInfo targetMethod, "targetMethod should not be null here.");
 
                 // should process
                 StringBuilder arglist = new StringBuilder(GetStringRepresentation(_arguments[0]));
@@ -1112,8 +1108,7 @@ namespace Microsoft.PowerShell.Commands
 
             if (string.IsNullOrEmpty(objInString))
             {
-                var psobj = obj as PSObject;
-                objInString = psobj != null ? psobj.BaseObject.GetType().FullName : obj.GetType().FullName;
+                objInString = obj is PSObject psobj ? psobj.BaseObject.GetType().FullName : obj.GetType().FullName;
             }
 
             return objInString;
@@ -1127,11 +1122,10 @@ namespace Microsoft.PowerShell.Commands
         private bool GetValueFromIDictionaryInput()
         {
             object target = PSObject.Base(_inputObject);
-            IDictionary hash = target as IDictionary;
 
             try
             {
-                if (hash != null && hash.Contains(_propertyOrMethodName))
+                if (target is IDictionary hash && hash.Contains(_propertyOrMethodName))
                 {
                     string keyAction = string.Format(
                         CultureInfo.InvariantCulture,
@@ -2201,9 +2195,9 @@ namespace Microsoft.PowerShell.Commands
 
                     case TokenKind.Is:
                     case TokenKind.IsNot:
+
                         // users might input [int], [string] as they do when using scripts
-                        var strValue = _convertedValue as string;
-                        if (strValue != null)
+                        if (_convertedValue is string strValue)
                         {
                             var typeLength = strValue.Length;
                             if (typeLength > 2 && strValue[0] == '[' && strValue[typeLength - 1] == ']')
@@ -2345,10 +2339,9 @@ namespace Microsoft.PowerShell.Commands
             // return that, otherwise fall through and see if there is an
             // underlying member corresponding to the key...
             object target = PSObject.Base(_inputObject);
-            IDictionary hash = target as IDictionary;
             try
             {
-                if (hash != null && hash.Contains(_property))
+                if (target is IDictionary hash && hash.Contains(_property))
                 {
                     return hash[_property];
                 }
@@ -2658,8 +2651,7 @@ namespace Microsoft.PowerShell.Commands
             {
                 object version = PSObject.Base(inputData);
 
-                string versionStr = version as string;
-                if (versionStr != null)
+                if (version is string versionStr)
                 {
                     if (versionStr.Equals("latest", StringComparison.OrdinalIgnoreCase))
                     {
diff --git a/src/System.Management.Automation/engine/InvocationInfo.cs b/src/System.Management.Automation/engine/InvocationInfo.cs
index 6020b6e53..1c849f0d4 100644
--- a/src/System.Management.Automation/engine/InvocationInfo.cs
+++ b/src/System.Management.Automation/engine/InvocationInfo.cs
@@ -77,7 +77,7 @@ namespace System.Management.Automation
             if (contextToUse != null)
             {
                 Runspaces.LocalRunspace localRunspace = contextToUse.CurrentRunspace as Runspaces.LocalRunspace;
-                if (localRunspace != null && localRunspace.History != null)
+                if (localRunspace?.History != null)
                 {
                     HistoryId = localRunspace.History.GetNextHistoryId();
                 }
@@ -436,8 +436,7 @@ namespace System.Management.Automation
             RemotingEncoder.AddNoteProperty<string>(psObject, "InvocationInfo_ScriptName", () => this.ScriptName);
             RemotingEncoder.AddNoteProperty<object>(psObject, "InvocationInfo_UnboundArguments", () => this.UnboundArguments);
 
-            ScriptExtent extent = DisplayScriptPosition as ScriptExtent;
-            if (extent != null)
+            if (DisplayScriptPosition is ScriptExtent extent)
             {
                 extent.ToPSObjectForRemoting(psObject);
                 RemotingEncoder.AddNoteProperty(psObject, "SerializeExtent", () => true);
diff --git a/src/System.Management.Automation/engine/LanguagePrimitives.cs b/src/System.Management.Automation/engine/LanguagePrimitives.cs
index 83361fe96..9381b2205 100644
--- a/src/System.Management.Automation/engine/LanguagePrimitives.cs
+++ b/src/System.Management.Automation/engine/LanguagePrimitives.cs
@@ -654,10 +654,9 @@ namespace System.Management.Automation
             {
                 return false; // first is not null
             }
-
-            string firstString = first as string;
             string secondString;
-            if (firstString != null)
+
+            if (first is string firstString)
             {
                 secondString = second as string ?? (string)LanguagePrimitives.ConvertTo(second, typeof(string), culture);
                 return (culture.CompareInfo.Compare(firstString, secondString,
@@ -1014,8 +1013,7 @@ namespace System.Management.Automation
             if (objType == typeof(SwitchParameter))
                 return ((SwitchParameter)obj).ToBool();
 
-            IList objectArray = obj as IList;
-            if (objectArray != null)
+            if (obj is IList objectArray)
             {
                 return IsTrue(objectArray);
             }
@@ -2582,8 +2580,7 @@ namespace System.Management.Automation
 
                 if ((valueConverter != null))
                 {
-                    TypeConverter valueTypeConverter = valueConverter as TypeConverter;
-                    if (valueTypeConverter != null)
+                    if (valueConverter is TypeConverter valueTypeConverter)
                     {
                         typeConversion.WriteLine("Original type's converter is TypeConverter.");
                         if (valueTypeConverter.CanConvertTo(resultType))
@@ -2608,8 +2605,7 @@ namespace System.Management.Automation
                         }
                     }
 
-                    PSTypeConverter valuePSTypeConverter = valueConverter as PSTypeConverter;
-                    if (valuePSTypeConverter != null)
+                    if (valueConverter is PSTypeConverter valuePSTypeConverter)
                     {
                         typeConversion.WriteLine("Original type's converter is PSTypeConverter.");
                         PSObject psValueToConvert = PSObject.AsPSObject(valueToConvert);
@@ -2642,8 +2638,7 @@ namespace System.Management.Automation
                 valueConverter = GetConverter(resultType, backupTypeTable);
                 if (valueConverter != null)
                 {
-                    TypeConverter valueTypeConverter = valueConverter as TypeConverter;
-                    if (valueTypeConverter != null)
+                    if (valueConverter is TypeConverter valueTypeConverter)
                     {
                         typeConversion.WriteLine("Destination type's converter is TypeConverter that can convert from originalType.");
                         if (valueTypeConverter.CanConvertFrom(originalType))
@@ -2668,8 +2663,7 @@ namespace System.Management.Automation
                         }
                     }
 
-                    PSTypeConverter valuePSTypeConverter = valueConverter as PSTypeConverter;
-                    if (valuePSTypeConverter != null)
+                    if (valueConverter is PSTypeConverter valuePSTypeConverter)
                     {
                         typeConversion.WriteLine("Destination type's converter is PSTypeConverter.");
                         PSObject psValueToConvert = PSObject.AsPSObject(valueToConvert);
@@ -3322,7 +3316,7 @@ namespace System.Management.Automation
                                                      IFormatProvider formatProvider,
                                                      TypeTable backupTable)
         {
-            if (originalValueToConvert != null && originalValueToConvert.TokenText != null)
+            if (originalValueToConvert?.TokenText != null)
             {
                 return originalValueToConvert.TokenText;
             }
@@ -3524,7 +3518,7 @@ namespace System.Management.Automation
         {
             typeConversion.WriteLine("Value to convert is scalar.");
 
-            if (originalValueToConvert != null && originalValueToConvert.TokenText != null)
+            if (originalValueToConvert?.TokenText != null)
             {
                 valueToConvert = originalValueToConvert;
             }
@@ -3987,8 +3981,8 @@ namespace System.Management.Automation
                     if (ecFromTLS == null || (ecFromTLS.LanguageMode == PSLanguageMode.FullLanguage && !ecFromTLS.LanguageModeTransitionInParameterBinding))
                     {
                         result = _constructor();
-                        var psobject = valueToConvert as PSObject;
-                        if (psobject != null)
+
+                        if (valueToConvert is PSObject psobject)
                         {
                             // Use PSObject properties to perform conversion.
                             SetObjectProperties(result, psobject, resultType, CreateMemberNotFoundError, CreateMemberSetValueError, formatProvider, recursion, ignoreUnknownMembers);
@@ -4114,7 +4108,7 @@ namespace System.Management.Automation
         {
             // If the original object was a number, then try and do a conversion on the string
             // equivalent of that number...
-            if (originalValueToConvert != null && originalValueToConvert.TokenText != null)
+            if (originalValueToConvert?.TokenText != null)
             {
                 return LanguagePrimitives.ConvertTo(originalValueToConvert.TokenText,
                     resultType, recursion, formatProvider, backupTable);
@@ -4606,8 +4600,8 @@ namespace System.Management.Automation
             else
             {
                 object baseObj = PSObject.Base(psObject);
-                var dictionary = baseObj as IDictionary;
-                if (dictionary != null)
+
+                if (baseObj is IDictionary dictionary)
                 {
                     // Win8:649519
                     return SetObjectProperties(o, dictionary, resultType, memberNotFoundErrorAction, memberSetValueErrorAction, enableMethodCall: false);
@@ -4615,8 +4609,7 @@ namespace System.Management.Automation
                 else
                 {
                     // Support PSObject to Strong type conversion.
-                    PSObject psBaseObject = baseObj as PSObject;
-                    if (psBaseObject != null)
+                    if (baseObj is PSObject psBaseObject)
                     {
                         Dictionary<string, object> properties = new Dictionary<string, object>();
                         foreach (var item in psBaseObject.Properties)
@@ -4677,8 +4670,7 @@ namespace System.Management.Automation
 
                                         try
                                         {
-                                            PSObject propertyValue = prop.Value as PSObject;
-                                            if (propertyValue != null)
+                                            if (prop.Value is PSObject propertyValue)
                                             {
                                                 propValue = LanguagePrimitives.ConvertPSObjectToType(propertyValue, propType, recursion, formatProvider, ignoreUnknownMembers);
                                             }
@@ -4704,9 +4696,7 @@ namespace System.Management.Automation
                             {
                                 if (pso.BaseObject is PSCustomObject)
                                 {
-                                    var key = prop.Key as string;
-                                    var value = prop.Value as string;
-                                    if (key != null && value != null && key.Equals("PSTypeName", StringComparison.OrdinalIgnoreCase))
+                                    if (prop.Key is string key && prop.Value is string value && key.Equals("PSTypeName", StringComparison.OrdinalIgnoreCase))
                                     {
                                         pso.TypeNames.Insert(0, value);
                                     }
@@ -4740,7 +4730,7 @@ namespace System.Management.Automation
             StringBuilder availableProperties = new StringBuilder();
             bool first = true;
 
-            if (pso != null && pso.Properties != null)
+            if (pso?.Properties != null)
             {
                 foreach (PSPropertyInfo p in pso.Properties)
                 {
diff --git a/src/System.Management.Automation/engine/ManagementObjectAdapter.cs b/src/System.Management.Automation/engine/ManagementObjectAdapter.cs
index c591a6963..1e0f1f7ae 100644
--- a/src/System.Management.Automation/engine/ManagementObjectAdapter.cs
+++ b/src/System.Management.Automation/engine/ManagementObjectAdapter.cs
@@ -105,8 +105,7 @@ namespace System.Management.Automation
                 Dbg.Assert(derivationData.IsArray, "__Derivation must be a string array as per MSDN documentation");
 
                 // give the typenames based on NameSpace + __Derivation
-                string[] typeHierarchy = PropertySetAndMethodArgumentConvertTo(derivationData.Value, typeof(string[]), CultureInfo.InvariantCulture) as string[];
-                if (typeHierarchy != null)
+                if (PropertySetAndMethodArgumentConvertTo(derivationData.Value, typeof(string[]), CultureInfo.InvariantCulture) is string[] typeHierarchy)
                 {
                     foreach (string t in typeHierarchy)
                     {
@@ -542,8 +541,7 @@ namespace System.Management.Automation
                 mgmtClass = new ManagementClass(mgmtBaseObject.ClassPath);
 
                 // inherit ManagementObject properties
-                ManagementObject mgmtObject = mgmtBaseObject as ManagementObject;
-                if (mgmtObject != null)
+                if (mgmtBaseObject is ManagementObject mgmtObject)
                 {
                     mgmtClass.Scope = mgmtObject.Scope;
                     mgmtClass.Options = mgmtObject.Options;
diff --git a/src/System.Management.Automation/engine/Modules/AnalysisCache.cs b/src/System.Management.Automation/engine/Modules/AnalysisCache.cs
index 084c8c467..a51e8b33c 100644
--- a/src/System.Management.Automation/engine/Modules/AnalysisCache.cs
+++ b/src/System.Management.Automation/engine/Modules/AnalysisCache.cs
@@ -250,8 +250,7 @@ namespace System.Management.Automation
             var nestedModules = moduleManifestProperties["NestedModules"];
             if (nestedModules != null)
             {
-                var nestedModule = nestedModules as string;
-                if (nestedModule != null)
+                if (nestedModules is string nestedModule)
                 {
                     return ModuleAnalysisViaGetModuleRequired(nestedModule, hadCmdlets, hadFunctions, hadAliases);
                 }
@@ -298,14 +297,12 @@ namespace System.Management.Automation
 
         private static bool AddPsd1EntryToResult(ConcurrentDictionary<string, CommandTypes> result, object value, CommandTypes commandTypeToAdd, ref bool sawWildcard)
         {
-            string command = value as string;
-            if (command != null)
+            if (value is string command)
             {
                 return AddPsd1EntryToResult(result, command, commandTypeToAdd, ref sawWildcard);
             }
 
-            object[] commands = value as object[];
-            if (commands != null)
+            if (value is object[] commands)
             {
                 foreach (var o in commands)
                 {
diff --git a/src/System.Management.Automation/engine/Modules/ModuleCmdletBase.cs b/src/System.Management.Automation/engine/Modules/ModuleCmdletBase.cs
index 7e7549c65..5ac15d66f 100644
--- a/src/System.Management.Automation/engine/Modules/ModuleCmdletBase.cs
+++ b/src/System.Management.Automation/engine/Modules/ModuleCmdletBase.cs
@@ -2621,8 +2621,7 @@ namespace Microsoft.PowerShell.Commands
                 {
                     using (TextReader reader = File.OpenText(psgetItemInfoXml))
                     {
-                        PSObject xml = PSSerializer.Deserialize(reader.ReadToEnd()) as PSObject;
-                        if (xml != null && xml.Properties["RepositorySourceLocation"] != null)
+                        if (PSSerializer.Deserialize(reader.ReadToEnd()) is PSObject xml && xml.Properties["RepositorySourceLocation"] != null)
                         {
                             var repositorySourceLocation = xml.Properties["RepositorySourceLocation"].Value.ToString();
                             Uri repositorySourceLocationUri;
@@ -3821,7 +3820,7 @@ namespace Microsoft.PowerShell.Commands
                         {
                             Dbg.Assert(error != null, "Error message should be populated if there is cyclic dependency");
                             MissingMemberException mm = null;
-                            if (error != null && error.Exception != null)
+                            if (error?.Exception != null)
                             {
                                 mm = new MissingMemberException(error.Exception.Message);
                             }
@@ -3923,9 +3922,9 @@ namespace Microsoft.PowerShell.Commands
             else
             {
                 // Either module/snapin is already loaded
-                if (loadedModule is PSModuleInfo)
+                if (loadedModule is PSModuleInfo pSModuleInfo)
                 {
-                    result = (PSModuleInfo)loadedModule;
+                    result = pSModuleInfo;
                 }
                 else if (!loaded)
                 {
@@ -4749,7 +4748,7 @@ namespace Microsoft.PowerShell.Commands
 
             Collection<string> filePaths;
 
-            if (context != null && context.EngineSessionState != null && context.EngineSessionState.IsProviderLoaded(context.ProviderNames.FileSystem))
+            if (context?.EngineSessionState != null && context.EngineSessionState.IsProviderLoaded(context.ProviderNames.FileSystem))
             {
                 try
                 {
@@ -4786,7 +4785,7 @@ namespace Microsoft.PowerShell.Commands
 
             Collection<string> filePaths;
 
-            if (context != null && context.EngineSessionState != null && context.EngineSessionState.IsProviderLoaded(context.ProviderNames.FileSystem))
+            if (context?.EngineSessionState != null && context.EngineSessionState.IsProviderLoaded(context.ProviderNames.FileSystem))
             {
                 try
                 {
@@ -4887,7 +4886,7 @@ namespace Microsoft.PowerShell.Commands
                 using var ps = System.Management.Automation.PowerShell.Create(RunspaceMode.CurrentRunspace);
                 ps.AddCommand(new CmdletInfo("Invoke-Command", typeof(InvokeCommandCommand)));
                 ps.AddParameter("Session", compatSession);
-                ps.AddParameter("ScriptBlock", ScriptBlock.Create(string.Format("Set-Location -Path '{0}'", args.NewPath.Path)));
+                ps.AddParameter("ScriptBlock", ScriptBlock.Create($"Set-Location -Path '{args.NewPath.Path}'"));
                 ps.Invoke();
             }
         }
@@ -5193,8 +5192,7 @@ namespace Microsoft.PowerShell.Commands
                         Context.Modules.IsImplicitRemotingModuleLoaded = false;
                         foreach (var modInfo in Context.Modules.ModuleTable.Values)
                         {
-                            var privateData = modInfo.PrivateData as Hashtable;
-                            if ((privateData != null) && privateData.ContainsKey("ImplicitRemoting"))
+                            if ((modInfo.PrivateData is Hashtable privateData) && privateData.ContainsKey("ImplicitRemoting"))
                             {
                                 Context.Modules.IsImplicitRemotingModuleLoaded = true;
                                 break;
@@ -6846,21 +6844,17 @@ namespace Microsoft.PowerShell.Commands
                 foreach (SessionStateCommandEntry commandEntry in iss.Commands)
                 {
                     commandEntry.SetModule(module);
-
-                    // A binary module can only directly export cmdlets, so cmdletEntry should never be null.
-                    // With nested modules in a manifest, there may be a session state attached to
-                    // this module in which case we add the exported cmdlets to the existing list.
-                    SessionStateCmdletEntry cmdletEntry = commandEntry as SessionStateCmdletEntry;
+                    // A binary module can only directly export cmdlets, so cmdletEntry should never be null.                    // With nested modules in a manifest, there may be a session state attached to                    // this module in which case we add the exported cmdlets to the existing list.
                     SessionStateAliasEntry aliasEntry = null;
                     if (cmdletEntry == null)
                     {
                         aliasEntry = commandEntry as SessionStateAliasEntry;
                     }
 
-                    Dbg.Assert((cmdletEntry != null || aliasEntry != null), "When importing a binary module, the commands entry should only have cmdlets/aliases in it");
+                    Dbg.Assert((commandEntry is SessionStateCmdletEntry cmdletEntry || aliasEntry != null), "When importing a binary module, the commands entry should only have cmdlets/aliases in it");
                     if (ss != null)
                     {
-                        if (cmdletEntry != null)
+                        if (commandEntry is SessionStateCmdletEntry cmdletEntry)
                         {
                             ss.Internal.ExportedCmdlets.Add(CommandDiscovery.NewCmdletInfo(cmdletEntry, this.Context));
                         }
@@ -6873,7 +6867,7 @@ namespace Microsoft.PowerShell.Commands
                     {
                         // If there is no session state, we need to attach the entry to the module instead
                         // of the session state.
-                        if (cmdletEntry != null)
+                        if (commandEntry is SessionStateCmdletEntry cmdletEntry)
                         {
                             module.AddExportedCmdlet(CommandDiscovery.NewCmdletInfo(cmdletEntry, this.Context));
                         }
@@ -7154,10 +7148,8 @@ namespace Microsoft.PowerShell.Commands
             {
                 targetSessionState.Module.AddNestedModule(module);
             }
-
-            var privateDataHashTable = module.PrivateData as Hashtable;
             if (!context.Modules.IsImplicitRemotingModuleLoaded &&
-                privateDataHashTable != null && privateDataHashTable.ContainsKey("ImplicitRemoting"))
+                module.PrivateData is Hashtable privateDataHashTable && privateDataHashTable.ContainsKey("ImplicitRemoting"))
             {
                 context.Modules.IsImplicitRemotingModuleLoaded = true;
             }
diff --git a/src/System.Management.Automation/engine/Modules/ModuleIntrinsics.cs b/src/System.Management.Automation/engine/Modules/ModuleIntrinsics.cs
index 9d5af6097..19012f63f 100644
--- a/src/System.Management.Automation/engine/Modules/ModuleIntrinsics.cs
+++ b/src/System.Management.Automation/engine/Modules/ModuleIntrinsics.cs
@@ -168,10 +168,8 @@ namespace System.Management.Automation
             {
                 _context.EngineSessionState = ss.Internal;
 
-                // Build the scriptblock at this point so the references to the module
-                // context are correct...
-                ExternalScriptInfo scriptInfo = moduleCode as ExternalScriptInfo;
-                if (scriptInfo != null)
+                // Build the scriptblock at this point so the references to the module                // context are correct...
+                if (moduleCode is ExternalScriptInfo scriptInfo)
                 {
                     sb = scriptInfo.ScriptBlock;
 
@@ -190,8 +188,7 @@ namespace System.Management.Automation
                     }
                     else
                     {
-                        var sbText = moduleCode as string;
-                        if (sbText != null)
+                        if (moduleCode is string sbText)
                             sb = ScriptBlock.Create(_context, sbText);
                     }
                 }
diff --git a/src/System.Management.Automation/engine/Modules/RemoteDiscoveryHelper.cs b/src/System.Management.Automation/engine/Modules/RemoteDiscoveryHelper.cs
index c52a752c6..c95ea0ea4 100644
--- a/src/System.Management.Automation/engine/Modules/RemoteDiscoveryHelper.cs
+++ b/src/System.Management.Automation/engine/Modules/RemoteDiscoveryHelper.cs
@@ -324,8 +324,7 @@ namespace System.Management.Automation
 
         private static ErrorRecord GetErrorRecordForRemoteDiscoveryProvider(Exception innerException)
         {
-            CimException cimException = innerException as CimException;
-            if ((cimException != null) &&
+            if ((innerException is CimException cimException) &&
                 ((cimException.NativeErrorCode == NativeErrorCode.InvalidNamespace) ||
                  (cimException.NativeErrorCode == NativeErrorCode.InvalidClass) ||
                  (cimException.NativeErrorCode == NativeErrorCode.MethodNotFound) ||
@@ -516,9 +515,8 @@ namespace System.Management.Automation
                 return (T)propertyValue;
             }
 
-            if (propertyValue is string)
+            if (propertyValue is string stringValue)
             {
-                string stringValue = (string)propertyValue;
                 try
                 {
                     if (typeof(T) == typeof(bool))
@@ -1083,15 +1081,13 @@ namespace System.Management.Automation
                 return;
             }
 
-            Tuple<CimSession, Uri, string> cimSessionInfo = weaklyTypeSession as Tuple<CimSession, Uri, string>;
-            if (cimSessionInfo != null)
+            if (weaklyTypeSession is Tuple<CimSession, Uri, string> cimSessionInfo)
             {
                 cimSessionAction(cimSessionInfo.Item1, cimSessionInfo.Item2, cimSessionInfo.Item3);
                 return;
             }
 
-            PSSession psSession = weaklyTypeSession as PSSession;
-            if (psSession != null)
+            if (weaklyTypeSession is PSSession psSession)
             {
                 psSessionAction(psSession);
                 return;
diff --git a/src/System.Management.Automation/engine/MshCmdlet.cs b/src/System.Management.Automation/engine/MshCmdlet.cs
index a2a7023b2..b9533090f 100644
--- a/src/System.Management.Automation/engine/MshCmdlet.cs
+++ b/src/System.Management.Automation/engine/MshCmdlet.cs
@@ -139,9 +139,9 @@ namespace System.Management.Automation
             {
                 return _isPresent == (bool)obj;
             }
-            else if (obj is SwitchParameter)
+            else if (obj is SwitchParameter switchParameter)
             {
-                return _isPresent == ((SwitchParameter)obj).IsPresent;
+                return _isPresent == switchParameter.IsPresent;
             }
             else
             {
@@ -661,8 +661,7 @@ namespace System.Management.Automation
                     continue;
                 }
 
-                CommandInfo commandInfo = ((IEnumerator)searcher).Current as CommandInfo;
-                if (commandInfo != null)
+                if (((IEnumerator)searcher).Current is CommandInfo commandInfo)
                 {
                     yield return commandInfo;
                 }
@@ -853,8 +852,7 @@ namespace System.Management.Automation
             }
 
             // If the result is already a collection of PSObjects, just return it...
-            Collection<PSObject> result = rawResult as Collection<PSObject>;
-            if (result != null)
+            if (rawResult is Collection<PSObject> result)
                 return result;
 
             result = new Collection<PSObject>();
diff --git a/src/System.Management.Automation/engine/MshCommandRuntime.cs b/src/System.Management.Automation/engine/MshCommandRuntime.cs
index e43e49631..35646b4c4 100644
--- a/src/System.Management.Automation/engine/MshCommandRuntime.cs
+++ b/src/System.Management.Automation/engine/MshCommandRuntime.cs
@@ -781,8 +781,7 @@ namespace System.Management.Automation
                     if ((record.Tags.Contains("PSHOST") && (!record.Tags.Contains("FORWARDED")))
                         || (preference == ActionPreference.Continue))
                     {
-                        HostInformationMessage hostOutput = record.MessageData as HostInformationMessage;
-                        if (hostOutput != null)
+                        if (record.MessageData is HostInformationMessage hostOutput)
                         {
                             string message = hostOutput.Message;
                             ConsoleColor? foregroundColor = null;
@@ -890,9 +889,7 @@ namespace System.Management.Automation
 
         private bool InitShouldLogPipelineExecutionDetail()
         {
-            CmdletInfo cmdletInfo = _commandInfo as CmdletInfo;
-
-            if (cmdletInfo != null)
+            if (_commandInfo is CmdletInfo cmdletInfo)
             {
                 if (string.Equals("Add-Type", cmdletInfo.Name, StringComparison.OrdinalIgnoreCase))
                 {
@@ -914,7 +911,7 @@ namespace System.Management.Automation
 
             // Logging should be enabled for functions from modules also
             FunctionInfo functionInfo = _commandInfo as FunctionInfo;
-            if (functionInfo != null && functionInfo.Module != null)
+            if (functionInfo?.Module != null)
             {
                 return functionInfo.Module.LogPipelineExecutionDetails;
             }
@@ -2376,10 +2373,7 @@ namespace System.Management.Automation
             if (e == null)
                 throw PSTraceSource.NewArgumentNullException(nameof(e));
 
-            if (PipelineProcessor != null)
-            {
-                PipelineProcessor.RecordFailure(e, _thisCommand);
-            }
+            PipelineProcessor?.RecordFailure(e, _thisCommand);
 
             // 1021203-2005/05/09-JonN
             // HaltCommandException will cause the command
diff --git a/src/System.Management.Automation/engine/MshObject.cs b/src/System.Management.Automation/engine/MshObject.cs
index 7ea7ef1bd..0dc66dbd9 100644
--- a/src/System.Management.Automation/engine/MshObject.cs
+++ b/src/System.Management.Automation/engine/MshObject.cs
@@ -1364,8 +1364,7 @@ namespace System.Management.Automation
                 {
                     if (objFormattable == null)
                     {
-                        Type type = obj as Type;
-                        if (type != null)
+                        if (obj is Type type)
                         {
                             return Microsoft.PowerShell.ToStringCodeMethods.Type(type);
                         }
diff --git a/src/System.Management.Automation/engine/MshObjectTypeDescriptor.cs b/src/System.Management.Automation/engine/MshObjectTypeDescriptor.cs
index 6e941b4c5..8127ded9c 100644
--- a/src/System.Management.Automation/engine/MshObjectTypeDescriptor.cs
+++ b/src/System.Management.Automation/engine/MshObjectTypeDescriptor.cs
@@ -380,8 +380,7 @@ namespace System.Management.Automation
                 Type propertyType = typeof(object);
                 if (attributes != null && attributes.Length != 0)
                 {
-                    PSProperty property = propertyInfo as PSProperty;
-                    if (property != null)
+                    if (propertyInfo is PSProperty property)
                     {
                         DotNetAdapter.PropertyCacheEntry propertyEntry = property.adapterData as DotNetAdapter.PropertyCacheEntry;
                         if (propertyEntry == null)
@@ -509,8 +508,7 @@ namespace System.Management.Automation
             PSMemberSet standardMembers = this.Instance.PSStandardMembers;
             if (standardMembers != null)
             {
-                PSNoteProperty note = standardMembers.Properties[TypeTable.DefaultDisplayProperty] as PSNoteProperty;
-                if (note != null)
+                if (standardMembers.Properties[TypeTable.DefaultDisplayProperty] is PSNoteProperty note)
                 {
                     defaultProperty = note.Value as string;
                 }
@@ -521,8 +519,7 @@ namespace System.Management.Automation
                 object[] defaultPropertyAttributes = this.Instance.BaseObject.GetType().GetCustomAttributes(typeof(DefaultPropertyAttribute), true);
                 if (defaultPropertyAttributes.Length == 1)
                 {
-                    DefaultPropertyAttribute defaultPropertyAttribute = defaultPropertyAttributes[0] as DefaultPropertyAttribute;
-                    if (defaultPropertyAttribute != null)
+                    if (defaultPropertyAttributes[0] is DefaultPropertyAttribute defaultPropertyAttribute)
                     {
                         defaultProperty = defaultPropertyAttribute.Name;
                     }
diff --git a/src/System.Management.Automation/engine/NativeCommandProcessor.cs b/src/System.Management.Automation/engine/NativeCommandProcessor.cs
index 96ad84a6c..ac2ff25aa 100644
--- a/src/System.Management.Automation/engine/NativeCommandProcessor.cs
+++ b/src/System.Management.Automation/engine/NativeCommandProcessor.cs
@@ -1019,10 +1019,7 @@ namespace System.Management.Automation
             try
             {
                 // Dispose the process if it's already created
-                if (_nativeProcess != null)
-                {
-                    _nativeProcess.Dispose();
-                }
+                _nativeProcess?.Dispose();
             }
             catch (Exception)
             {
@@ -1035,8 +1032,7 @@ namespace System.Management.Automation
 
             if (outputValue.Stream == MinishellStream.Error)
             {
-                ErrorRecord record = outputValue.Data as ErrorRecord;
-                Dbg.Assert(record != null, "ProcessReader should ensure that data is ErrorRecord");
+                Dbg.Assert(outputValue.Data is ErrorRecord record, "ProcessReader should ensure that data is ErrorRecord");
                 record.SetInvocationInfo(this.Command.MyInvocation);
                 this.commandRuntime._WriteErrorSkipAllowCheck(record, isNativeError: true);
             }
@@ -1046,26 +1042,22 @@ namespace System.Management.Automation
             }
             else if (outputValue.Stream == MinishellStream.Debug)
             {
-                string temp = outputValue.Data as string;
-                Dbg.Assert(temp != null, "ProcessReader should ensure that data is string");
+                Dbg.Assert(outputValue.Data is string temp, "ProcessReader should ensure that data is string");
                 this.Command.PSHostInternal.UI.WriteDebugLine(temp);
             }
             else if (outputValue.Stream == MinishellStream.Verbose)
             {
-                string temp = outputValue.Data as string;
-                Dbg.Assert(temp != null, "ProcessReader should ensure that data is string");
+                Dbg.Assert(outputValue.Data is string temp, "ProcessReader should ensure that data is string");
                 this.Command.PSHostInternal.UI.WriteVerboseLine(temp);
             }
             else if (outputValue.Stream == MinishellStream.Warning)
             {
-                string temp = outputValue.Data as string;
-                Dbg.Assert(temp != null, "ProcessReader should ensure that data is string");
+                Dbg.Assert(outputValue.Data is string temp, "ProcessReader should ensure that data is string");
                 this.Command.PSHostInternal.UI.WriteWarningLine(temp);
             }
             else if (outputValue.Stream == MinishellStream.Progress)
             {
-                PSObject temp = outputValue.Data as PSObject;
-                if (temp != null)
+                if (outputValue.Data is string temp)
                 {
                     long sourceId = 0;
                     PSMemberInfo info = temp.Properties["SourceId"];
@@ -1089,8 +1081,7 @@ namespace System.Management.Automation
             }
             else if (outputValue.Stream == MinishellStream.Information)
             {
-                InformationRecord record = outputValue.Data as InformationRecord;
-                Dbg.Assert(record != null, "ProcessReader should ensure that data is InformationRecord");
+                Dbg.Assert(outputValue.Data is ErrorRecord record, "ProcessReader should ensure that data is InformationRecord");
                 this.commandRuntime.WriteInformation(record);
             }
         }
@@ -1892,10 +1883,7 @@ namespace System.Management.Automation
         {
             if (_inputFormat == NativeCommandIOFormat.Xml)
             {
-                if (_xmlSerializer != null)
-                {
-                    _xmlSerializer.Done();
-                }
+                _xmlSerializer?.Done();
             }
             else // Text
             {
diff --git a/src/System.Management.Automation/engine/ParameterBinderBase.cs b/src/System.Management.Automation/engine/ParameterBinderBase.cs
index ee7028c38..2b7d18f15 100644
--- a/src/System.Management.Automation/engine/ParameterBinderBase.cs
+++ b/src/System.Management.Automation/engine/ParameterBinderBase.cs
@@ -359,9 +359,9 @@ namespace System.Management.Automation
                 do // false loop
                 {
                     // Now call any argument transformation attributes that might be present on the parameter
-                    ScriptParameterBinder spb = this as ScriptParameterBinder;
                     bool usesCmdletBinding = false;
-                    if (spb != null)
+
+                    if (this is ScriptParameterBinder spb)
                     {
                         usesCmdletBinding = spb.Script.UsesCmdletBinding;
                     }
@@ -390,9 +390,7 @@ namespace System.Management.Automation
                         {
                             try
                             {
-                                ArgumentTypeConverterAttribute argumentTypeConverter = dma as ArgumentTypeConverterAttribute;
-
-                                if (argumentTypeConverter != null)
+                                if (dma is ArgumentTypeConverterAttribute argumentTypeConverter)
                                 {
                                     if (coerceTypeIfNeeded)
                                     {
@@ -550,7 +548,7 @@ namespace System.Management.Automation
 
                     if (parameterMetadata.ObsoleteAttribute != null &&
                         (!isDefaultValue) &&
-                        spb != null && !usesCmdletBinding)
+                        this is ScriptParameterBinder spb && !usesCmdletBinding)
                     {
                         string obsoleteWarning = string.Format(
                             CultureInfo.InvariantCulture,
@@ -559,15 +557,7 @@ namespace System.Management.Automation
                             parameterMetadata.ObsoleteAttribute.Message);
 
                         var mshCommandRuntime = this.Command.commandRuntime as MshCommandRuntime;
-                        if (mshCommandRuntime != null)
-                        {
-                            // Write out warning only if we are in the context of MshCommandRuntime.
-                            // This is because
-                            //  1. The overload method WriteWarning(WarningRecord) is only available in MshCommandRuntime;
-                            //  2. We write out warnings for obsolete commands and obsolete cmdlet parameters only when in
-                            //     the context of MshCommandRuntime. So we do it here to keep consistency.
-                            mshCommandRuntime.WriteWarning(new WarningRecord(FQIDParameterObsolete, obsoleteWarning));
-                        }
+                        mshCommandRuntime?.WriteWarning(new WarningRecord(FQIDParameterObsolete, obsoleteWarning));
                     }
 
                     // Finally bind the argument to the parameter
@@ -618,9 +608,7 @@ namespace System.Management.Automation
                     {
                         this.CommandLineParameters.Add(parameter.ParameterName, parameterValue);
                     }
-
-                    MshCommandRuntime cmdRuntime = this.Command.commandRuntime as MshCommandRuntime;
-                    if ((cmdRuntime != null) &&
+                    if ((this.Command.commandRuntime is MshCommandRuntime cmdRuntime) &&
                         (cmdRuntime.LogPipelineExecutionDetail || _isTranscribing) &&
                         (cmdRuntime.PipelineProcessor != null))
                     {
@@ -718,11 +706,9 @@ namespace System.Management.Automation
 
             if (argumentType == typeof(string))
             {
-                // Since the parameter is of type string, verify that either the argument
-                // is not null and not empty or that the parameter can accept null or empty.
-                string stringParamValue = parameterValue as string;
+                // Since the parameter is of type string, verify that either the argument                // is not null and not empty or that the parameter can accept null or empty.
                 Diagnostics.Assert(
-                    stringParamValue != null,
+                    parameterValue is string stringParamValue,
                     "Type coercion should have already converted the argument value to a string");
 
                 if (stringParamValue.Length == 0 && !parameterMetadata.AllowsEmptyStringArgument)
@@ -851,8 +837,7 @@ namespace System.Management.Automation
                 return true;
             }
 
-            var psobj = parameterValue as PSObject;
-            if (psobj != null && !psobj.ImmediateBaseObjectIsEmpty)
+            if (parameterValue is PSObject psobj && !psobj.ImmediateBaseObjectIsEmpty)
             {
                 // See if the base object is of the same type or
                 // as subclass of the parameter
@@ -1094,9 +1079,9 @@ namespace System.Management.Automation
                                 PSObject currentValueAsPSObject = (PSObject)currentValue;
                                 currentValue = currentValueAsPSObject.BaseObject;
 
-                                if (currentValue is SwitchParameter)
+                                if (currentValue is SwitchParameter switchParameter)
                                 {
-                                    currentValue = ((SwitchParameter)currentValue).IsPresent;
+                                    currentValue = switchParameter.IsPresent;
                                 }
 
                                 boType = currentValue.GetType();
@@ -1902,8 +1887,8 @@ namespace System.Management.Automation
         internal static IList GetIList(object value)
         {
             var baseObj = PSObject.Base(value);
-            var result = baseObj as IList;
-            if (result != null)
+
+            if (baseObj is IList result)
             {
                 // Reference comparison to determine if 'value' is a PSObject
                 s_tracer.WriteLine(baseObj == value
@@ -2025,8 +2010,7 @@ namespace System.Management.Automation
             if (_dictionary.ImplicitUsingParameters == null)
             {
                 // Handle downlevel V4 case where using parameters are passed as an array list.
-                IList implicitArrayUsingParameters = PSObject.Base(obj) as IList;
-                if ((implicitArrayUsingParameters != null) && (implicitArrayUsingParameters.Count > 0))
+                if ((PSObject.Base(obj) is IList implicitArrayUsingParameters) && (implicitArrayUsingParameters.Count > 0))
                 {
                     // Convert array to hash table.
                     _dictionary.ImplicitUsingParameters = new Hashtable();
diff --git a/src/System.Management.Automation/engine/ParameterBinderController.cs b/src/System.Management.Automation/engine/ParameterBinderController.cs
index e6a7153a8..385bf570d 100644
--- a/src/System.Management.Automation/engine/ParameterBinderController.cs
+++ b/src/System.Management.Automation/engine/ParameterBinderController.cs
@@ -343,8 +343,7 @@ namespace System.Management.Automation
         {
             if ((arguments != null) && (arguments.Length > 0))
             {
-                PSBoundParametersDictionary boundParameters = arguments[0] as PSBoundParametersDictionary;
-                if ((boundParameters != null) && (arguments.Length == 1))
+                if ((arguments[0] is PSBoundParametersDictionary boundParameters) && (arguments.Length == 1))
                 {
                     // If they are supplying a dictionary of parameters, use those directly
                     foreach (KeyValuePair<string, object> boundParameter in boundParameters)
diff --git a/src/System.Management.Automation/engine/Pipe.cs b/src/System.Management.Automation/engine/Pipe.cs
index 8ee000a4f..8632b9ab0 100644
--- a/src/System.Management.Automation/engine/Pipe.cs
+++ b/src/System.Management.Automation/engine/Pipe.cs
@@ -516,10 +516,8 @@ namespace System.Management.Automation.Internal
             }
             finally
             {
-                // If our object came from GetEnumerator (and hence is not IEnumerator), then we need to dispose
-                // Otherwise, we don't own the object, so don't dispose.
-                var disposable = ie as IDisposable;
-                if (disposable != null && objects is not IEnumerator)
+                // If our object came from GetEnumerator (and hence is not IEnumerator), then we need to dispose                // Otherwise, we don't own the object, so don't dispose.
+                if (ie is IDisposable disposable && objects is not IEnumerator)
                 {
                     disposable.Dispose();
                 }
diff --git a/src/System.Management.Automation/engine/ProxyCommand.cs b/src/System.Management.Automation/engine/ProxyCommand.cs
index 5703adec6..f38eed588 100644
--- a/src/System.Management.Automation/engine/ProxyCommand.cs
+++ b/src/System.Management.Automation/engine/ProxyCommand.cs
@@ -262,8 +262,7 @@ namespace System.Management.Automation
         {
             string text = null;
 
-            PSObject psobj = obj as PSObject;
-            if (psobj != null)
+            if (obj is PSObject psobj)
             {
                 text = GetProperty<string>(psobj, "Text");
             }
diff --git a/src/System.Management.Automation/engine/ScopedItemSearcher.cs b/src/System.Management.Automation/engine/ScopedItemSearcher.cs
index fc67ee263..107e3735f 100644
--- a/src/System.Management.Automation/engine/ScopedItemSearcher.cs
+++ b/src/System.Management.Automation/engine/ScopedItemSearcher.cs
@@ -397,8 +397,8 @@ namespace System.Management.Automation
             if (script != null)
             {
                 bool isPrivate;
-                FilterInfo filterInfo = script as FilterInfo;
-                if (filterInfo != null)
+
+                if (script is FilterInfo filterInfo)
                 {
                     isPrivate = (filterInfo.Options & ScopedItemOptions.Private) != 0;
                 }
diff --git a/src/System.Management.Automation/engine/ScriptCommandProcessor.cs b/src/System.Management.Automation/engine/ScriptCommandProcessor.cs
index 99b685e07..a4dffad94 100644
--- a/src/System.Management.Automation/engine/ScriptCommandProcessor.cs
+++ b/src/System.Management.Automation/engine/ScriptCommandProcessor.cs
@@ -535,8 +535,7 @@ namespace System.Management.Automation
                         }
                         else
                         {
-                            IList list = inputToProcess as IList;
-                            inputToProcess = (list != null)
+                            inputToProcess = (inputToProcess is IList list)
                                                  ? list.GetEnumerator()
                                                  : LanguagePrimitives.GetEnumerator(inputToProcess);
                         }
diff --git a/src/System.Management.Automation/engine/SessionState.cs b/src/System.Management.Automation/engine/SessionState.cs
index e0bdbd23e..fbfbf4361 100644
--- a/src/System.Management.Automation/engine/SessionState.cs
+++ b/src/System.Management.Automation/engine/SessionState.cs
@@ -516,12 +516,8 @@ namespace System.Management.Automation
             Exception e,
             bool useInnerExceptionErrorMessage)
         {
-            //  If the innerException was itself thrown by
-            //  ProviderBase.ThrowTerminatingError, it is already a
-            //  ProviderInvocationException, and we don't want to
-            //  re-wrap it.
-            ProviderInvocationException pie = e as ProviderInvocationException;
-            if (pie != null)
+            //  If the innerException was itself thrown by            //  ProviderBase.ThrowTerminatingError, it is already a            //  ProviderInvocationException, and we don't want to            //  re-wrap it.
+            if (e is ProviderInvocationException pie)
             {
                 pie._providerInfo = provider;
                 return pie;
diff --git a/src/System.Management.Automation/engine/SessionStateContainer.cs b/src/System.Management.Automation/engine/SessionStateContainer.cs
index ca7f03a42..4c6409a15 100644
--- a/src/System.Management.Automation/engine/SessionStateContainer.cs
+++ b/src/System.Management.Automation/engine/SessionStateContainer.cs
@@ -1818,8 +1818,7 @@ namespace System.Management.Automation
 
                         foreach (PSObject filteredChildName in filteredChildNameObjects)
                         {
-                            string filteredName = filteredChildName.BaseObject as string;
-                            if (filteredName != null)
+                            if (filteredChildName.BaseObject is string filteredName)
                             {
                                 filteredChildNameDictionary[filteredName] = true;
                             }
@@ -4164,13 +4163,12 @@ namespace System.Management.Automation
 
             PSDriveInfo unusedDrive = null;
             ProviderInfo destinationProvider = null;
-            Microsoft.PowerShell.Commands.CopyItemDynamicParameters dynamicParams = context.DynamicParameters as Microsoft.PowerShell.Commands.CopyItemDynamicParameters;
             bool destinationIsRemote = false;
             bool sourceIsRemote = false;
             string providerDestinationPath;
             Runspaces.PSSession session = null;
 
-            if (dynamicParams != null)
+            if (context.DynamicParameters is Microsoft.PowerShell.Commands.CopyItemDynamicParameters dynamicParams)
             {
                 if (dynamicParams.FromSession != null)
                 {
diff --git a/src/System.Management.Automation/engine/SessionStateDriveAPIs.cs b/src/System.Management.Automation/engine/SessionStateDriveAPIs.cs
index b8a89b9b3..5524c9808 100644
--- a/src/System.Management.Automation/engine/SessionStateDriveAPIs.cs
+++ b/src/System.Management.Automation/engine/SessionStateDriveAPIs.cs
@@ -1377,7 +1377,7 @@ namespace System.Management.Automation
                 // If the scope was specified then don't loop
                 // through the other scopes
 
-                if (scope != null && scope.Length > 0)
+                if (!string.IsNullOrEmpty(scope))
                 {
                     break;
                 }
diff --git a/src/System.Management.Automation/engine/SessionStateFunctionAPIs.cs b/src/System.Management.Automation/engine/SessionStateFunctionAPIs.cs
index f444f46d2..ed8322306 100644
--- a/src/System.Management.Automation/engine/SessionStateFunctionAPIs.cs
+++ b/src/System.Management.Automation/engine/SessionStateFunctionAPIs.cs
@@ -777,7 +777,7 @@ namespace System.Management.Automation
             Dbg.Assert(module != null, "Caller should verify that module parameter is not null");
 
             FunctionInfo func = GetFunction(name) as FunctionInfo;
-            if (func != null && func.ScriptBlock != null
+            if (func?.ScriptBlock != null
                 && func.ScriptBlock.File != null
                 && func.ScriptBlock.File.Equals(module.Path, StringComparison.OrdinalIgnoreCase))
             {
diff --git a/src/System.Management.Automation/engine/SessionStateNavigation.cs b/src/System.Management.Automation/engine/SessionStateNavigation.cs
index f6d1a28eb..7366eb0a2 100644
--- a/src/System.Management.Automation/engine/SessionStateNavigation.cs
+++ b/src/System.Management.Automation/engine/SessionStateNavigation.cs
@@ -696,8 +696,7 @@ namespace System.Management.Automation
 
             Provider.CmdletProvider providerInstance = GetProviderInstance(provider);
 
-            NavigationCmdletProvider navigationCmdletProvider = providerInstance as NavigationCmdletProvider;
-            if (navigationCmdletProvider != null)
+            if (providerInstance is NavigationCmdletProvider navigationCmdletProvider)
             {
                 try
                 {
@@ -971,9 +970,7 @@ namespace System.Management.Automation
 
             string result = null;
 
-            NavigationCmdletProvider navigationCmdletProvider = providerInstance as NavigationCmdletProvider;
-
-            if (navigationCmdletProvider != null)
+            if (providerInstance is NavigationCmdletProvider navigationCmdletProvider)
             {
                 try
                 {
diff --git a/src/System.Management.Automation/engine/SessionStatePublic.cs b/src/System.Management.Automation/engine/SessionStatePublic.cs
index ce14d4948..87b6bfcf3 100644
--- a/src/System.Management.Automation/engine/SessionStatePublic.cs
+++ b/src/System.Management.Automation/engine/SessionStatePublic.cs
@@ -187,8 +187,7 @@ namespace System.Management.Automation
             SessionStateException exception;
             if (!IsVisible(origin, valueToCheck))
             {
-                PSVariable sv = valueToCheck as PSVariable;
-                if (sv != null)
+                if (valueToCheck is PSVariable sv)
                 {
                     exception =
                        new SessionStateException(
@@ -201,8 +200,7 @@ namespace System.Management.Automation
                     throw exception;
                 }
 
-                CommandInfo cinfo = valueToCheck as CommandInfo;
-                if (cinfo != null)
+                if (valueToCheck is CommandInfo cinfo)
                 {
                     string commandName = cinfo.Name;
                     if (commandName != null)
@@ -253,8 +251,8 @@ namespace System.Management.Automation
         {
             if (origin == CommandOrigin.Internal)
                 return true;
-            IHasSessionStateEntryVisibility obj = valueToCheck as IHasSessionStateEntryVisibility;
-            if (obj != null)
+
+            if (valueToCheck is IHasSessionStateEntryVisibility obj)
             {
                 return (obj.Visibility == SessionStateEntryVisibility.Public);
             }
diff --git a/src/System.Management.Automation/engine/SessionStateScope.cs b/src/System.Management.Automation/engine/SessionStateScope.cs
index fc5dff007..caf911865 100644
--- a/src/System.Management.Automation/engine/SessionStateScope.cs
+++ b/src/System.Management.Automation/engine/SessionStateScope.cs
@@ -1666,13 +1666,13 @@ namespace System.Management.Automation
             }
 
             // First use the copy constructors
-            if (originalFunction is FilterInfo)
+            if (originalFunction is FilterInfo filterInfo)
             {
-                newValue = new FilterInfo(name, (FilterInfo)originalFunction);
+                newValue = new FilterInfo(name, filterInfo);
             }
-            else if (originalFunction is ConfigurationInfo)
+            else if (originalFunction is ConfigurationInfo configurationInfo)
             {
-                newValue = new ConfigurationInfo(name, (ConfigurationInfo)originalFunction);
+                newValue = new ConfigurationInfo(name, configurationInfo);
             }
             else if (originalFunction != null)
             {
diff --git a/src/System.Management.Automation/engine/SessionStateVariableAPIs.cs b/src/System.Management.Automation/engine/SessionStateVariableAPIs.cs
index 8cc9e4baf..3976745a5 100644
--- a/src/System.Management.Automation/engine/SessionStateVariableAPIs.cs
+++ b/src/System.Management.Automation/engine/SessionStateVariableAPIs.cs
@@ -881,9 +881,7 @@ namespace System.Management.Automation
 
             if (resultItem != null)
             {
-                PSVariable variable = resultItem as PSVariable;
-
-                if (variable != null)
+                if (resultItem is PSVariable variable)
                 {
                     resultItem = variable.Value;
                 }
diff --git a/src/System.Management.Automation/engine/ShellVariable.cs b/src/System.Management.Automation/engine/ShellVariable.cs
index 424be2953..00d3959fa 100644
--- a/src/System.Management.Automation/engine/ShellVariable.cs
+++ b/src/System.Management.Automation/engine/ShellVariable.cs
@@ -442,8 +442,7 @@ namespace System.Management.Automation
         {
             bool result = true;
 
-            ValidateArgumentsAttribute validationAttribute = attribute as ValidateArgumentsAttribute;
-            if (validationAttribute != null)
+            if (attribute is ValidateArgumentsAttribute validationAttribute)
             {
                 try
                 {
@@ -502,9 +501,7 @@ namespace System.Management.Automation
 
             foreach (Attribute attribute in attributes)
             {
-                ArgumentTransformationAttribute transformationAttribute =
-                    attribute as ArgumentTransformationAttribute;
-                if (transformationAttribute != null)
+                if (attribute is ArgumentTransformationAttribute transformationAttribute)
                 {
                     result = transformationAttribute.TransformInternal(engine, result);
                 }
diff --git a/src/System.Management.Automation/engine/TypeMetadata.cs b/src/System.Management.Automation/engine/TypeMetadata.cs
index 31a6adeab..7ae6ff570 100644
--- a/src/System.Management.Automation/engine/TypeMetadata.cs
+++ b/src/System.Management.Automation/engine/TypeMetadata.cs
@@ -899,8 +899,7 @@ namespace System.Management.Automation
         {
             string result;
 
-            ValidateLengthAttribute validLengthAttrib = attrib as ValidateLengthAttribute;
-            if (validLengthAttrib != null)
+            if (attrib is ValidateLengthAttribute validLengthAttrib)
             {
                 result = string.Format(
                     CultureInfo.InvariantCulture,
@@ -910,8 +909,7 @@ namespace System.Management.Automation
                 return result;
             }
 
-            ValidateRangeAttribute validRangeAttrib = attrib as ValidateRangeAttribute;
-            if (validRangeAttrib != null)
+            if (attrib is ValidateRangeAttribute validRangeAttrib)
             {
                 if (validRangeAttrib.RangeKind.HasValue)
                 {
@@ -946,32 +944,28 @@ namespace System.Management.Automation
                 }
             }
 
-            AllowNullAttribute allowNullAttrib = attrib as AllowNullAttribute;
-            if (allowNullAttrib != null)
+            if (attrib is AllowNullAttribute allowNullAttrib)
             {
                 result = string.Format(CultureInfo.InvariantCulture,
                     AllowNullFormat, prefix);
                 return result;
             }
 
-            AllowEmptyStringAttribute allowEmptyStringAttrib = attrib as AllowEmptyStringAttribute;
-            if (allowEmptyStringAttrib != null)
+            if (attrib is AllowEmptyStringAttribute allowEmptyStringAttrib)
             {
                 result = string.Format(CultureInfo.InvariantCulture,
                     AllowEmptyStringFormat, prefix);
                 return result;
             }
 
-            AllowEmptyCollectionAttribute allowEmptyColAttrib = attrib as AllowEmptyCollectionAttribute;
-            if (allowEmptyColAttrib != null)
+            if (attrib is AllowEmptyCollectionAttribute allowEmptyColAttrib)
             {
                 result = string.Format(CultureInfo.InvariantCulture,
                     AllowEmptyCollectionFormat, prefix);
                 return result;
             }
 
-            ValidatePatternAttribute patternAttrib = attrib as ValidatePatternAttribute;
-            if (patternAttrib != null)
+            if (attrib is ValidatePatternAttribute patternAttrib)
             {
                 /* TODO: Validate Pattern dont support Options in ScriptCmdletText.
                 StringBuilder regexOps = new System.Text.StringBuilder();
@@ -1001,32 +995,28 @@ namespace System.Management.Automation
                 return result;
             }
 
-            ValidateCountAttribute countAttrib = attrib as ValidateCountAttribute;
-            if (countAttrib != null)
+            if (attrib is ValidateCountAttribute countAttrib)
             {
                 result = string.Format(CultureInfo.InvariantCulture,
                     ValidateCountFormat, prefix, countAttrib.MinLength, countAttrib.MaxLength);
                 return result;
             }
 
-            ValidateNotNullAttribute notNullAttrib = attrib as ValidateNotNullAttribute;
-            if (notNullAttrib != null)
+            if (attrib is ValidateNotNullAttribute notNullAttrib)
             {
                 result = string.Format(CultureInfo.InvariantCulture,
                     ValidateNotNullFormat, prefix);
                 return result;
             }
 
-            ValidateNotNullOrEmptyAttribute notNullEmptyAttrib = attrib as ValidateNotNullOrEmptyAttribute;
-            if (notNullEmptyAttrib != null)
+            if (attrib is ValidateNotNullOrEmptyAttribute notNullEmptyAttrib)
             {
                 result = string.Format(CultureInfo.InvariantCulture,
                     ValidateNotNullOrEmptyFormat, prefix);
                 return result;
             }
 
-            ValidateSetAttribute setAttrib = attrib as ValidateSetAttribute;
-            if (setAttrib != null)
+            if (attrib is ValidateSetAttribute setAttrib)
             {
                 Text.StringBuilder values = new System.Text.StringBuilder();
                 string comma = string.Empty;
@@ -1045,8 +1035,7 @@ namespace System.Management.Automation
                 return result;
             }
 
-            ValidateScriptAttribute scriptAttrib = attrib as ValidateScriptAttribute;
-            if (scriptAttrib != null)
+            if (attrib is ValidateScriptAttribute scriptAttrib)
             {
                 // Talked with others and I think it is okay to use *unescaped* value from sb.ToString()
                 // 1. implicit remoting is not bringing validation scripts across
@@ -1057,8 +1046,7 @@ namespace System.Management.Automation
                 return result;
             }
 
-            PSTypeNameAttribute psTypeNameAttrib = attrib as PSTypeNameAttribute;
-            if (psTypeNameAttrib != null)
+            if (attrib is PSTypeNameAttribute psTypeNameAttrib)
             {
                 result = string.Format(
                     CultureInfo.InvariantCulture,
@@ -1068,8 +1056,7 @@ namespace System.Management.Automation
                 return result;
             }
 
-            ObsoleteAttribute obsoleteAttrib = attrib as ObsoleteAttribute;
-            if (obsoleteAttrib != null)
+            if (attrib is ObsoleteAttribute obsoleteAttrib)
             {
                 string parameters = string.Empty;
                 if (obsoleteAttrib.IsError)
diff --git a/src/System.Management.Automation/engine/TypeTable.cs b/src/System.Management.Automation/engine/TypeTable.cs
index 0e407d57a..398a76c1f 100644
--- a/src/System.Management.Automation/engine/TypeTable.cs
+++ b/src/System.Management.Automation/engine/TypeTable.cs
@@ -256,8 +256,7 @@ namespace System.Management.Automation.Runspaces
 
         private void CheckStandardNote<T>(TypeMemberData member, TypeData typeData, Action<TypeData, T> setter, Func<object, string, T> converter)
         {
-            var note = member as NotePropertyData;
-            if (note != null)
+            if (member is NotePropertyData note)
             {
                 T value;
                 if (note.Value.GetType() != typeof(T))
@@ -279,8 +278,7 @@ namespace System.Management.Automation.Runspaces
 
         private static bool CheckStandardPropertySet(TypeMemberData member, TypeData typeData, Action<TypeData, PropertySetData> setter)
         {
-            var propertySet = member as PropertySetData;
-            if (propertySet != null)
+            if (member is PropertySetData propertySet)
             {
                 setter(typeData, propertySet);
                 return true;
@@ -485,8 +483,7 @@ namespace System.Management.Automation.Runspaces
                     }
                     else if (m.Name.Equals(TypeTable.StringSerializationSource, StringComparison.OrdinalIgnoreCase))
                     {
-                        var aliasData = m as AliasPropertyData;
-                        if (aliasData != null)
+                        if (m is AliasPropertyData aliasData)
                         {
                             typeData.StringSerializationSource = aliasData.ReferencedMemberName;
                         }
@@ -2968,8 +2965,7 @@ namespace System.Management.Automation.Runspaces
             object sourceValue = note.Value;
             if (noteType.GetTypeCode().Equals(TypeCode.Boolean))
             {
-                string sourceValueAsString = sourceValue as string;
-                if (sourceValueAsString != null)
+                if (sourceValue is string sourceValueAsString)
                 {
                     if (sourceValueAsString.Length == 0)
                     {
@@ -4153,48 +4149,41 @@ namespace System.Management.Automation.Runspaces
 
         private TypeMemberData GetTypeMemberDataFromPSMemberInfo(PSMemberInfo member)
         {
-            var note = member as PSNoteProperty;
-            if (note != null)
+            if (member is PSNoteProperty note)
             {
                 return new NotePropertyData(note.Name, note.Value);
             }
 
-            var alias = member as PSAliasProperty;
-            if (alias != null)
+            if (member is PSAliasProperty alias)
             {
                 return new AliasPropertyData(alias.Name, alias.ReferencedMemberName);
             }
 
-            var scriptProperty = member as PSScriptProperty;
-            if (scriptProperty != null)
+            if (member is PSScriptProperty scriptProperty)
             {
                 ScriptBlock getter = scriptProperty.IsGettable ? scriptProperty.GetterScript : null;
                 ScriptBlock setter = scriptProperty.IsSettable ? scriptProperty.SetterScript : null;
                 return new ScriptPropertyData(scriptProperty.Name, getter, setter);
             }
 
-            var codeProperty = member as PSCodeProperty;
-            if (codeProperty != null)
+            if (member is PSCodeProperty codeProperty)
             {
                 MethodInfo getter = codeProperty.IsGettable ? codeProperty.GetterCodeReference : null;
                 MethodInfo setter = codeProperty.IsSettable ? codeProperty.SetterCodeReference : null;
                 return new CodePropertyData(codeProperty.Name, getter, setter);
             }
 
-            var scriptMethod = member as PSScriptMethod;
-            if (scriptMethod != null)
+            if (member is PSScriptMethod scriptMethod)
             {
                 return new ScriptMethodData(scriptMethod.Name, scriptMethod.Script);
             }
 
-            var codeMethod = member as PSCodeMethod;
-            if (codeMethod != null)
+            if (member is PSCodeMethod codeMethod)
             {
                 return new CodeMethodData(codeMethod.Name, codeMethod.CodeReference);
             }
 
-            var memberSet = member as PSMemberSet;
-            if (memberSet != null)
+            if (member is PSMemberSet memberSet)
             {
                 if (memberSet.Name.Equals(PSStandardMembers, StringComparison.OrdinalIgnoreCase))
                 {
@@ -4230,8 +4219,7 @@ namespace System.Management.Automation.Runspaces
                 return;
             }
 
-            var memberSet = member as PSMemberSet;
-            if (memberSet != null)
+            if (member is PSMemberSet memberSet)
             {
                 if (memberSet.Name.Equals(PSStandardMembers, StringComparison.OrdinalIgnoreCase))
                 {
@@ -4286,8 +4274,7 @@ namespace System.Management.Automation.Runspaces
                 }
                 else if (memberName.Equals(StringSerializationSource, StringComparison.OrdinalIgnoreCase))
                 {
-                    var aliasProperty = standardMember as PSAliasProperty;
-                    if (aliasProperty != null)
+                    if (standardMember is PSAliasProperty aliasProperty)
                     {
                         typeData.StringSerializationSource = aliasProperty.ReferencedMemberName;
                     }
@@ -4380,7 +4367,7 @@ namespace System.Management.Automation.Runspaces
 
         private bool RetrieveMembersToTypeData(TypeData typeData)
         {
-            Dbg.Assert(typeData != null && typeData.TypeName != null, "The caller needs to make sure typeData != null");
+            Dbg.Assert(typeData?.TypeName != null, "The caller needs to make sure typeData != null");
             string typeName = typeData.TypeName;
 
             PSMemberInfoInternalCollection<PSMemberInfo> typeMembers;
@@ -4401,7 +4388,7 @@ namespace System.Management.Automation.Runspaces
 
         private bool RetrieveConverterToTypeData(TypeData typeData)
         {
-            Dbg.Assert(typeData != null && typeData.TypeName != null, "The caller needs to make sure typeData != null");
+            Dbg.Assert(typeData?.TypeName != null, "The caller needs to make sure typeData != null");
             string typeName = typeData.TypeName;
 
             object converterResult;
@@ -4417,7 +4404,7 @@ namespace System.Management.Automation.Runspaces
 
         private bool RetrieveAdapterToTypeData(TypeData typeData)
         {
-            Dbg.Assert(typeData != null && typeData.TypeName != null, "The caller needs to make sure typeData != null");
+            Dbg.Assert(typeData?.TypeName != null, "The caller needs to make sure typeData != null");
             string typeName = typeData.TypeName;
 
             PSObject.AdapterSet adapterResult;
diff --git a/src/System.Management.Automation/engine/Utils.cs b/src/System.Management.Automation/engine/Utils.cs
index fa1ef1357..4026df9a2 100644
--- a/src/System.Management.Automation/engine/Utils.cs
+++ b/src/System.Management.Automation/engine/Utils.cs
@@ -576,10 +576,7 @@ namespace System.Management.Automation
             catch (ObjectDisposedException) { }
             finally
             {
-                if (winPEKey != null)
-                {
-                    winPEKey.Dispose();
-                }
+                winPEKey?.Dispose();
             }
 #endif
             return false;
@@ -1069,10 +1066,7 @@ namespace System.Management.Automation
                     finally
                     {
                         context.AutoLoadingModuleInProgress.Remove(module);
-                        if (ps != null)
-                        {
-                            ps.Dispose();
-                        }
+                        ps?.Dispose();
                     }
                 }
             }
@@ -1129,10 +1123,7 @@ namespace System.Management.Automation
             }
             finally
             {
-                if (ps != null)
-                {
-                    ps.Dispose();
-                }
+                ps?.Dispose();
             }
 
             return result;
@@ -1190,10 +1181,7 @@ namespace System.Management.Automation
             }
             finally
             {
-                if (ps != null)
-                {
-                    ps.Dispose();
-                }
+                ps?.Dispose();
             }
 
             return result;
@@ -1422,11 +1410,10 @@ namespace System.Management.Automation
         private static void WorkItemCallback(object callBackArgs)
         {
             object[] args = callBackArgs as object[];
-            WindowsIdentity identityToImpersonate = args[0] as WindowsIdentity;
             WaitCallback callback = args[1] as WaitCallback;
             object state = args[2];
 
-            if (identityToImpersonate != null)
+            if (args[0] is WindowsIdentity identityToImpersonate)
             {
                 WindowsIdentity.RunImpersonated(
                     identityToImpersonate.AccessToken,
@@ -2103,10 +2090,7 @@ namespace System.Management.Automation.Internal
         public static void SetTestHook(string property, object value)
         {
             var fieldInfo = typeof(InternalTestHooks).GetField(property, BindingFlags.Static | BindingFlags.NonPublic);
-            if (fieldInfo != null)
-            {
-                fieldInfo.SetValue(null, value);
-            }
+            fieldInfo?.SetValue(null, value);
         }
 
         /// <summary>
diff --git a/src/System.Management.Automation/engine/VariableAttributeCollection.cs b/src/System.Management.Automation/engine/VariableAttributeCollection.cs
index a1a81dbb0..838b6ddab 100644
--- a/src/System.Management.Automation/engine/VariableAttributeCollection.cs
+++ b/src/System.Management.Automation/engine/VariableAttributeCollection.cs
@@ -119,8 +119,7 @@ namespace System.Management.Automation
             object variableValue = _variable.Value;
 
             // Perform transformation before validating
-            ArgumentTransformationAttribute argumentTransformation = item as ArgumentTransformationAttribute;
-            if (argumentTransformation != null)
+            if (item is ArgumentTransformationAttribute argumentTransformation)
             {
                 // Get an EngineIntrinsics instance using the context of the thread.
 
diff --git a/src/System.Management.Automation/engine/VariableInterfaces.cs b/src/System.Management.Automation/engine/VariableInterfaces.cs
index 4ced936df..2ff468d76 100644
--- a/src/System.Management.Automation/engine/VariableInterfaces.cs
+++ b/src/System.Management.Automation/engine/VariableInterfaces.cs
@@ -72,7 +72,7 @@ namespace System.Management.Automation
             // 2. If the requested variable is not null and does not exist in the session scope, then a null value is returned to the pipeline.
             // 3. If the requested variable is null then an NewArgumentNullException is thrown.
             // PowerShell V3 has the similar experience.
-            if (name != null && name.Equals(string.Empty))
+            if (string.IsNullOrEmpty(name))
             {
                 return null;
             }
diff --git a/src/System.Management.Automation/engine/cmdlet.cs b/src/System.Management.Automation/engine/cmdlet.cs
index b049193fd..28ebb341c 100644
--- a/src/System.Management.Automation/engine/cmdlet.cs
+++ b/src/System.Management.Automation/engine/cmdlet.cs
@@ -135,9 +135,7 @@ namespace System.Management.Automation
         /// </exception>
         internal override void DoBeginProcessing()
         {
-            MshCommandRuntime mshRuntime = this.CommandRuntime as MshCommandRuntime;
-
-            if (mshRuntime != null)
+            if (this.CommandRuntime is MshCommandRuntime mshRuntime)
             {
                 if (mshRuntime.UseTransaction &&
                    (!this.Context.TransactionManager.HasTransaction))
@@ -678,8 +676,7 @@ namespace System.Management.Automation
         {
             using (PSTransactionManager.GetEngineProtectionScope())
             {
-                ICommandRuntime2 commandRuntime2 = commandRuntime as ICommandRuntime2;
-                if (commandRuntime2 != null)
+                if (commandRuntime is ICommandRuntime2 commandRuntime2)
                 {
                     string source = this.MyInvocation.PSCommandPath;
                     if (string.IsNullOrEmpty(source))
@@ -736,8 +733,7 @@ namespace System.Management.Automation
         {
             using (PSTransactionManager.GetEngineProtectionScope())
             {
-                ICommandRuntime2 commandRuntime2 = commandRuntime as ICommandRuntime2;
-                if (commandRuntime2 != null)
+                if (commandRuntime is ICommandRuntime2 commandRuntime2)
                 {
                     commandRuntime2.WriteInformation(informationRecord);
                 }
@@ -1565,8 +1561,7 @@ namespace System.Management.Automation
             {
                 if (commandRuntime != null)
                 {
-                    ICommandRuntime2 runtime2 = commandRuntime as ICommandRuntime2;
-                    if (runtime2 != null)
+                    if (commandRuntime is ICommandRuntime2 runtime2)
                     {
                         return runtime2.ShouldContinue(query, caption, hasSecurityImpact, ref yesToAll, ref noToAll);
                     }
diff --git a/src/System.Management.Automation/engine/debugger/debugger.cs b/src/System.Management.Automation/engine/debugger/debugger.cs
index 30e83c38f..7934bd8fc 100644
--- a/src/System.Management.Automation/engine/debugger/debugger.cs
+++ b/src/System.Management.Automation/engine/debugger/debugger.cs
@@ -1147,8 +1147,7 @@ namespace System.Management.Automation
 
             if (_context._debuggingMode > 0)
             {
-                var scriptCommandInfo = invocationInfo.MyCommand as ExternalScriptInfo;
-                if (scriptCommandInfo != null)
+                if (invocationInfo.MyCommand is ExternalScriptInfo scriptCommandInfo)
                 {
                     RegisterScriptFile(scriptCommandInfo);
                 }
@@ -1263,22 +1262,19 @@ namespace System.Management.Automation
 
         private void AddNewBreakpoint(Breakpoint breakpoint)
         {
-            LineBreakpoint lineBreakpoint = breakpoint as LineBreakpoint;
-            if (lineBreakpoint != null)
+            if (breakpoint is LineBreakpoint lineBreakpoint)
             {
                 AddLineBreakpoint(lineBreakpoint);
                 return;
             }
 
-            CommandBreakpoint cmdBreakpoint = breakpoint as CommandBreakpoint;
-            if (cmdBreakpoint != null)
+            if (breakpoint is CommandBreakpoint cmdBreakpoint)
             {
                 AddCommandBreakpoint(cmdBreakpoint);
                 return;
             }
 
-            VariableBreakpoint varBreakpoint = breakpoint as VariableBreakpoint;
-            if (varBreakpoint != null)
+            if (breakpoint is VariableBreakpoint varBreakpoint)
             {
                 AddVariableBreakpoint(varBreakpoint);
             }
@@ -2355,8 +2351,7 @@ namespace System.Management.Automation
                             {
                                 if (item == null) { continue; }
 
-                                DebuggerCommand dbgCmd = item.BaseObject as DebuggerCommand;
-                                if (dbgCmd != null)
+                                if (item.BaseObject is DebuggerCommand dbgCmd)
                                 {
                                     bool executedByDebugger = (dbgCmd.ResumeAction != null || dbgCmd.ExecutedByDebugger);
                                     results = new DebuggerCommandResults(dbgCmd.ResumeAction, executedByDebugger);
@@ -2394,10 +2389,7 @@ namespace System.Management.Automation
             }
 
             PowerShell ps = _psDebuggerCommand;
-            if (ps != null)
-            {
-                ps.BeginStop(null, null);
-            }
+            ps?.BeginStop(null, null);
         }
 
         /// <summary>
@@ -2933,8 +2925,7 @@ namespace System.Management.Automation
 
         private bool TryAddDebugJob(Job job, bool breakAll)
         {
-            IJobDebugger debuggableJob = job as IJobDebugger;
-            if ((debuggableJob != null) && (debuggableJob.Debugger != null) &&
+            if ((job is IJobDebugger debuggableJob) && (debuggableJob.Debugger != null) &&
                 ((job.JobStateInfo.State == JobState.Running) || (job.JobStateInfo.State == JobState.AtBreakpoint)))
             {
                 // Check to see if job is already stopped in debugger.
@@ -2949,8 +2940,7 @@ namespace System.Management.Automation
                 // Raise debug stop event if job is already in stopped state.
                 if (jobDebugAlreadyStopped)
                 {
-                    RemotingJobDebugger remoteJobDebugger = debuggableJob.Debugger as RemotingJobDebugger;
-                    if (remoteJobDebugger != null)
+                    if (debuggableJob.Debugger is RemotingJobDebugger remoteJobDebugger)
                     {
                         remoteJobDebugger.CheckStateAndRaiseStopEvent();
                     }
@@ -3110,8 +3100,7 @@ namespace System.Management.Automation
 
         private void ReleaseInternalRunspaceDebugProcessing(object sender, bool emptyQueue = false)
         {
-            Runspace runspace = sender as Runspace;
-            if (runspace != null)
+            if (sender is Runspace runspace)
             {
                 runspace.StateChanged -= RunspaceStateChangedHandler;
                 runspace.AvailabilityChanged -= RunspaceAvailabilityChangedHandler;
@@ -3249,10 +3238,7 @@ namespace System.Management.Automation
                 {
                     Debugger nestedDebugger = item.NestedDebugger;
 
-                    if (nestedDebugger != null)
-                    {
-                        nestedDebugger.SetDebuggerStepMode(enableStepping);
-                    }
+                    nestedDebugger?.SetDebuggerStepMode(enableStepping);
                 }
                 catch (PSNotImplementedException) { }
             }
@@ -3567,8 +3553,7 @@ namespace System.Management.Automation
 
                     // Check to see if this is a resume command that we handle here.
                     DebuggerCommand dbgCommand = _commandProcessor.ProcessBasicCommand(commandText);
-                    if (dbgCommand != null &&
-                        dbgCommand.ResumeAction != null)
+                    if (dbgCommand?.ResumeAction != null)
                     {
                         _lastActiveDebuggerAction = dbgCommand.ResumeAction.Value;
                         return new DebuggerCommandResults(dbgCommand.ResumeAction, true);
@@ -4528,8 +4513,7 @@ namespace System.Management.Automation
         /// </summary>
         internal void CheckStateAndRaiseStopEvent()
         {
-            RemoteDebugger remoteDebugger = _wrappedDebugger as RemoteDebugger;
-            if (remoteDebugger != null)
+            if (_wrappedDebugger is RemoteDebugger remoteDebugger)
             {
                 // Have remote debugger raise existing debugger stop event.
                 remoteDebugger.CheckStateAndRaiseStopEvent();
@@ -4544,10 +4528,7 @@ namespace System.Management.Automation
                 // If this is a remote server debugger then we want to convert the pending remote
                 // debugger stop to a local debugger stop event for this Debug-Runspace to handle.
                 ServerRemoteDebugger serverRemoteDebugger = this._wrappedDebugger as ServerRemoteDebugger;
-                if (serverRemoteDebugger != null)
-                {
-                    serverRemoteDebugger.ReleaseAndRaiseDebugStopLocal();
-                }
+                serverRemoteDebugger?.ReleaseAndRaiseDebugStopLocal();
             }
         }
 
@@ -4654,8 +4635,7 @@ namespace System.Management.Automation
         {
             if (runningCmd == null) { return; }
 
-            var runningPowerShell = runningCmd as PowerShell;
-            if (runningPowerShell != null)
+            if (runningCmd is PowerShell runningPowerShell)
             {
                 runningPowerShell.ResumeIncomingData();
             }
@@ -4863,15 +4843,13 @@ namespace System.Management.Automation
                 int callingLineNumber = parentStackFrame.ScriptLineNumber;
 
                 StatementAst debugStatement = null;
-                StatementAst callingStatement = _parentScriptBlockAst.Find(
-                    ast => ast is StatementAst && (ast.Extent.StartLineNumber == callingLineNumber), true) as StatementAst;
 
-                if (callingStatement != null)
+                if (_parentScriptBlockAst.Find(
+                    ast => ast is StatementAst && (ast.Extent.StartLineNumber == callingLineNumber), true) is StatementAst callingStatement)
                 {
                     // Find first statement in calling statement.
-                    StatementAst firstStatement = callingStatement.Find(
-                        ast => ast is StatementAst && ast.Extent.StartLineNumber > callingLineNumber, true) as StatementAst;
-                    if (firstStatement != null)
+                    if (callingStatement.Find(
+                        ast => ast is StatementAst && ast.Extent.StartLineNumber > callingLineNumber, true) is StatementAst firstStatement)
                     {
                         int adjustedLineNumber = firstStatement.Extent.StartLineNumber + debugLineNumber - 1;
                         debugStatement = callingStatement.Find(
@@ -4951,18 +4929,14 @@ namespace System.Management.Automation
         {
             if (runningCmd == null) { return; }
 
-            PowerShell command = runningCmd as PowerShell;
-            if (command != null)
+            if (runningCmd is PowerShell command)
             {
                 command.ResumeIncomingData();
             }
             else
             {
                 Pipeline pipelineCommand = runningCmd as Pipeline;
-                if (pipelineCommand != null)
-                {
-                    pipelineCommand.ResumeIncomingData();
-                }
+                pipelineCommand?.ResumeIncomingData();
             }
         }
 
@@ -5342,10 +5316,7 @@ namespace System.Management.Automation
                 host.UI.WriteLine(line);
             }
 
-            if (output != null)
-            {
-                output.Add(new PSObject(line));
-            }
+            output?.Add(new PSObject(line));
         }
 
         private static void WriteCR(PSHost host, IList<PSObject> output)
@@ -5355,10 +5326,7 @@ namespace System.Management.Automation
                 host.UI.WriteLine();
             }
 
-            if (output != null)
-            {
-                output.Add(new PSObject(Crlf));
-            }
+            output?.Add(new PSObject(Crlf));
         }
 
         private static void WriteErrorLine(string error, PSHost host, IList<PSObject> output)
@@ -5368,16 +5336,7 @@ namespace System.Management.Automation
                 host.UI.WriteErrorLine(error);
             }
 
-            if (output != null)
-            {
-                output.Add(
-                    new PSObject(
-                        new ErrorRecord(
-                            new RuntimeException(error),
-                            "DebuggerError",
-                            ErrorCategory.InvalidOperation,
-                            null)));
-            }
+            output?.Add(new PSObject(new ErrorRecord(new RuntimeException(error), "DebuggerError", ErrorCategory.InvalidOperation, null)));
         }
     }
 
diff --git a/src/System.Management.Automation/engine/hostifaces/AsyncResult.cs b/src/System.Management.Automation/engine/hostifaces/AsyncResult.cs
index f1e57e6fe..87dd7b861 100644
--- a/src/System.Management.Automation/engine/hostifaces/AsyncResult.cs
+++ b/src/System.Management.Automation/engine/hostifaces/AsyncResult.cs
@@ -178,10 +178,7 @@ namespace System.Management.Automation.Runspaces
         {
             lock (SyncObject)
             {
-                if (_completedWaitHandle != null)
-                {
-                    _completedWaitHandle.Set();
-                }
+                _completedWaitHandle?.Set();
             }
         }
 
diff --git a/src/System.Management.Automation/engine/hostifaces/Connection.cs b/src/System.Management.Automation/engine/hostifaces/Connection.cs
index 5af011adb..b150e45ff 100644
--- a/src/System.Management.Automation/engine/hostifaces/Connection.cs
+++ b/src/System.Management.Automation/engine/hostifaces/Connection.cs
@@ -950,8 +950,7 @@ namespace System.Management.Automation.Runspaces
                             }
                             else
                             {
-                                RemoteRunspace remoteRunspace = this as RemoteRunspace;
-                                RemoteDebugger remoteDebugger = (remoteRunspace != null) ? remoteRunspace.Debugger as RemoteDebugger : null;
+                                RemoteDebugger remoteDebugger = (this is RemoteRunspace remoteRunspace) ? remoteRunspace.Debugger as RemoteDebugger : null;
                                 Internal.ConnectCommandInfo remoteCommand = remoteRunspace?.RemoteCommand;
                                 if (((pipelineState == PipelineState.Completed) || (pipelineState == PipelineState.Failed) ||
                                     ((pipelineState == PipelineState.Stopped) && (this.RunspaceStateInfo.State == RunspaceState.Opened)))
@@ -973,7 +972,7 @@ namespace System.Management.Automation.Runspaces
 
                                 Pipeline currentPipeline = this.GetCurrentlyRunningPipeline();
                                 RemotePipeline remotePipeline = currentPipeline as RemotePipeline;
-                                Guid? pipeLineCmdInstance = (remotePipeline != null && remotePipeline.PowerShell != null) ? remotePipeline.PowerShell.InstanceId : (Guid?)null;
+                                Guid? pipeLineCmdInstance = (remotePipeline?.PowerShell != null) ? remotePipeline.PowerShell.InstanceId : (Guid?)null;
                                 if (currentPipeline == null)
                                 {
                                     // A runspace is available:
@@ -983,7 +982,7 @@ namespace System.Management.Automation.Runspaces
                                     //    - if the remote runspace pool is marked as available for connection.
                                     if (remoteCommand == null)
                                     {
-                                        if (remoteRunspace != null)
+                                        if (this is RemoteRunspace remoteRunspace)
                                         {
                                             if ((remoteDebugger != null) && (pipelineState == PipelineState.Stopped))
                                             {
@@ -1116,15 +1115,13 @@ namespace System.Management.Automation.Runspaces
         protected void UpdateRunspaceAvailability(RunspaceState runspaceState, bool raiseEvent)
         {
             RunspaceAvailability oldAvailability = this.RunspaceAvailability;
-            RemoteRunspace remoteRunspace = this as RemoteRunspace;
             Internal.ConnectCommandInfo remoteCommand = null;
             bool remoteDebug = false;
 
-            if (remoteRunspace != null)
+            if (this is RemoteRunspace remoteRunspace)
             {
                 remoteCommand = remoteRunspace.RemoteCommand;
-                RemoteDebugger remoteDebugger = remoteRunspace.Debugger as RemoteDebugger;
-                remoteDebug = (remoteDebugger != null) && remoteDebugger.IsRemoteDebug;
+                remoteDebug = (remoteRunspace.Debugger is RemoteDebugger remoteDebugger) && remoteDebugger.IsRemoteDebug;
             }
 
             switch (oldAvailability)
@@ -1730,7 +1727,7 @@ namespace System.Management.Automation.Runspaces
                 throw PSTraceSource.NewArgumentNullException(nameof(name));
             }
 
-            if (name.Equals(string.Empty))
+            if (string.IsNullOrEmpty(name))
             {
                 return null;
             }
diff --git a/src/System.Management.Automation/engine/hostifaces/HostUtilities.cs b/src/System.Management.Automation/engine/hostifaces/HostUtilities.cs
index b3e29423a..b0857f372 100644
--- a/src/System.Management.Automation/engine/hostifaces/HostUtilities.cs
+++ b/src/System.Management.Automation/engine/hostifaces/HostUtilities.cs
@@ -337,9 +337,9 @@ namespace System.Management.Automation
                 {
                     lastErrorRecord = errorList[0] as ErrorRecord;
                 }
-                else if (lastError is RuntimeException)
+                else if (lastError is RuntimeException runtimeException)
                 {
-                    lastErrorRecord = ((RuntimeException)lastError).ErrorRecord;
+                    lastErrorRecord = runtimeException.ErrorRecord;
                 }
 
                 // If we got information about the error invocation,
@@ -463,8 +463,7 @@ namespace System.Management.Automation
                     {
                         if (lastError != null)
                         {
-                            Exception lastException = lastError as Exception;
-                            if (lastException != null)
+                            if (lastError is Exception lastException)
                             {
                                 matchText = lastException.Message;
                             }
@@ -476,7 +475,7 @@ namespace System.Management.Automation
                     }
                     else if (matchType == SuggestionMatchType.ErrorId)
                     {
-                        if (lastError != null && lastError is ErrorRecord errorRecord)
+                        if (lastError is ErrorRecord errorRecord)
                         {
                             matchText = errorRecord.FullyQualifiedErrorId;
                         }
@@ -653,10 +652,8 @@ namespace System.Management.Automation
         /// </summary>
         private static string GetSuggestionText(object suggestion, object[] suggestionArgs, PSModuleInfo invocationModule)
         {
-            if (suggestion is ScriptBlock)
+            if (suggestion is ScriptBlock suggestionScript)
             {
-                ScriptBlock suggestionScript = (ScriptBlock)suggestion;
-
                 object result = null;
                 try
                 {
@@ -689,10 +686,8 @@ namespace System.Management.Automation
                 return basePrompt;
             }
 
-            SSHConnectionInfo sshConnectionInfo = runspace.ConnectionInfo as SSHConnectionInfo;
-
             // Usernames are case-sensitive on Unix systems
-            if (sshConnectionInfo != null &&
+            if (runspace.ConnectionInfo is SSHConnectionInfo sshConnectionInfo &&
                 !string.IsNullOrEmpty(sshConnectionInfo.UserName) &&
                 !System.Environment.UserName.Equals(sshConnectionInfo.UserName, StringComparison.Ordinal))
             {
diff --git a/src/System.Management.Automation/engine/hostifaces/InternalHostUserInterface.cs b/src/System.Management.Automation/engine/hostifaces/InternalHostUserInterface.cs
index 57f3f675f..ed47206b1 100644
--- a/src/System.Management.Automation/engine/hostifaces/InternalHostUserInterface.cs
+++ b/src/System.Management.Automation/engine/hostifaces/InternalHostUserInterface.cs
@@ -340,10 +340,7 @@ namespace System.Management.Automation.Internal.Host
         /// <param name="record">DebugRecord.</param>
         internal void WriteDebugInfoBuffers(DebugRecord record)
         {
-            if (_informationalBuffers != null)
-            {
-                _informationalBuffers.AddDebug(record);
-            }
+            _informationalBuffers?.AddDebug(record);
         }
 
         /// <summary>
@@ -538,10 +535,7 @@ namespace System.Management.Automation.Internal.Host
             }
 
             // Write to Information Buffers
-            if (_informationalBuffers != null)
-            {
-                _informationalBuffers.AddProgress(record);
-            }
+            _informationalBuffers?.AddProgress(record);
 
             if (_externalUI == null)
             {
@@ -590,10 +584,7 @@ namespace System.Management.Automation.Internal.Host
         /// <param name="record">VerboseRecord.</param>
         internal void WriteVerboseInfoBuffers(VerboseRecord record)
         {
-            if (_informationalBuffers != null)
-            {
-                _informationalBuffers.AddVerbose(record);
-            }
+            _informationalBuffers?.AddVerbose(record);
         }
 
         /// <summary>
@@ -633,10 +624,7 @@ namespace System.Management.Automation.Internal.Host
         /// <param name="record">WarningRecord.</param>
         internal void WriteWarningInfoBuffers(WarningRecord record)
         {
-            if (_informationalBuffers != null)
-            {
-                _informationalBuffers.AddWarning(record);
-            }
+            _informationalBuffers?.AddWarning(record);
         }
 
         /// <summary>
@@ -659,10 +647,7 @@ namespace System.Management.Automation.Internal.Host
         /// <param name="record">WarningRecord.</param>
         internal void WriteInformationInfoBuffers(InformationRecord record)
         {
-            if (_informationalBuffers != null)
-            {
-                _informationalBuffers.AddInformation(record);
-            }
+            _informationalBuffers?.AddInformation(record);
         }
 
         internal static Type GetFieldType(FieldDescription field)
diff --git a/src/System.Management.Automation/engine/hostifaces/ListModifier.cs b/src/System.Management.Automation/engine/hostifaces/ListModifier.cs
index 4723db9a1..16e288c92 100644
--- a/src/System.Management.Automation/engine/hostifaces/ListModifier.cs
+++ b/src/System.Management.Automation/engine/hostifaces/ListModifier.cs
@@ -56,13 +56,13 @@ namespace System.Management.Automation
             {
                 _replacementItems = new Collection<object>();
             }
-            else if (replacementItems is Collection<object>)
+            else if (replacementItems is Collection<object> objects)
             {
-                _replacementItems = (Collection<object>)replacementItems;
+                _replacementItems = objects;
             }
-            else if (replacementItems is IList<object>)
+            else if (replacementItems is IList<object> objects)
             {
-                _replacementItems = new Collection<object>((IList<object>)replacementItems);
+                _replacementItems = new Collection<object>(objects);
             }
             else if (replacementItems is IList)
             {
diff --git a/src/System.Management.Automation/engine/hostifaces/LocalConnection.cs b/src/System.Management.Automation/engine/hostifaces/LocalConnection.cs
index 7f10b7552..38241e8b9 100644
--- a/src/System.Management.Automation/engine/hostifaces/LocalConnection.cs
+++ b/src/System.Management.Automation/engine/hostifaces/LocalConnection.cs
@@ -573,8 +573,7 @@ namespace System.Management.Automation.Runspaces
             DebugPreference processDebugPreference = null;
             if (debugPreference != null)
             {
-                PSObject debugPreferencePsObject = debugPreference as PSObject;
-                if (debugPreferencePsObject != null)
+                if (debugPreference is PSObject debugPreferencePsObject)
                 {
                     processDebugPreference = LanguagePrimitives.ConvertTo<DebugPreference>(debugPreferencePsObject);
                 }
@@ -840,10 +839,7 @@ namespace System.Management.Automation.Runspaces
                 if (executionContext != null)
                 {
                     PSHostUserInterface hostUI = executionContext.EngineHostInterface.UI;
-                    if (hostUI != null)
-                    {
-                        hostUI.StopAllTranscribing();
-                    }
+                    hostUI?.StopAllTranscribing();
                 }
 
                 AmsiUtils.Uninitialize();
@@ -1274,10 +1270,7 @@ namespace System.Management.Automation.Runspaces
 
             base.Close(); // call base.Close() first to make it stop the pipeline
 
-            if (_pipelineThread != null)
-            {
-                _pipelineThread.Close();
-            }
+            _pipelineThread?.Close();
         }
 
         #endregion IDisposable Members
diff --git a/src/System.Management.Automation/engine/hostifaces/LocalPipeline.cs b/src/System.Management.Automation/engine/hostifaces/LocalPipeline.cs
index ab430decb..737d1c206 100644
--- a/src/System.Management.Automation/engine/hostifaces/LocalPipeline.cs
+++ b/src/System.Management.Automation/engine/hostifaces/LocalPipeline.cs
@@ -473,7 +473,7 @@ namespace System.Management.Automation.Runspaces
                 finally
                 {
                     // Call StopProcessing() for all the commands.
-                    if (pipelineProcessor != null && pipelineProcessor.Commands != null)
+                    if (pipelineProcessor?.Commands != null)
                     {
                         for (int i = 0; i < pipelineProcessor.Commands.Count; i++)
                         {
@@ -491,10 +491,7 @@ namespace System.Management.Automation.Runspaces
                     }
 
                     PSLocalEventManager eventManager = LocalRunspace.Events as PSLocalEventManager;
-                    if (eventManager != null)
-                    {
-                        eventManager.ProcessPendingActions();
-                    }
+                    eventManager?.ProcessPendingActions();
 
                     // restore the trap state...
                     this.LocalRunspace.ExecutionContext.PropagateExceptionsToEnclosingStatementBlock = oldTrapState;
@@ -565,9 +562,7 @@ namespace System.Management.Automation.Runspaces
                 // Set up pipeline internal host if it is available.
                 if (InvocationSettings != null && InvocationSettings.Host != null)
                 {
-                    InternalHost internalHost = InvocationSettings.Host as InternalHost;
-
-                    if (internalHost != null) // if we are given an internal host, use the external host
+                    if (InvocationSettings.Host is InternalHost internalHost) // if we are given an internal host, use the external host
                     {
                         LocalRunspace.ExecutionContext.InternalHost.SetHostRef(internalHost.ExternalHost);
                     }
@@ -938,21 +933,18 @@ namespace System.Management.Automation.Runspaces
                 commandInfo = ((AliasInfo)commandInfo).ReferencedCommand;
             }
 
-            CmdletInfo cmdletInfo = commandInfo as CmdletInfo;
-            if (cmdletInfo != null)
+            if (commandInfo is CmdletInfo cmdletInfo)
             {
                 return new CommandProcessor(cmdletInfo, LocalRunspace.ExecutionContext);
             }
 
-            IScriptCommandInfo functionInfo = commandInfo as IScriptCommandInfo;
-            if (functionInfo != null)
+            if (commandInfo is IScriptCommandInfo functionInfo)
             {
                 return new CommandProcessor(functionInfo, LocalRunspace.ExecutionContext,
                     useLocalScope: false, fromScriptFile: false, sessionState: LocalRunspace.ExecutionContext.EngineSessionState);
             }
 
-            ApplicationInfo applicationInfo = commandInfo as ApplicationInfo;
-            if (applicationInfo != null)
+            if (commandInfo is ApplicationInfo applicationInfo)
             {
                 return new NativeCommandProcessor(applicationInfo, LocalRunspace.ExecutionContext);
             }
diff --git a/src/System.Management.Automation/engine/hostifaces/PSCommand.cs b/src/System.Management.Automation/engine/hostifaces/PSCommand.cs
index 77bf704f3..17cf4e500 100644
--- a/src/System.Management.Automation/engine/hostifaces/PSCommand.cs
+++ b/src/System.Management.Automation/engine/hostifaces/PSCommand.cs
@@ -92,10 +92,7 @@ namespace System.Management.Automation
                 throw PSTraceSource.NewArgumentNullException("cmdlet");
             }
 
-            if (_owner != null)
-            {
-                _owner.AssertChangesAreAccepted();
-            }
+            _owner?.AssertChangesAreAccepted();
 
             _currentCommand = new Command(command, false);
             _commands.Add(_currentCommand);
@@ -136,10 +133,7 @@ namespace System.Management.Automation
                 throw PSTraceSource.NewArgumentNullException(nameof(cmdlet));
             }
 
-            if (_owner != null)
-            {
-                _owner.AssertChangesAreAccepted();
-            }
+            _owner?.AssertChangesAreAccepted();
 
             _currentCommand = new Command(cmdlet, false, useLocalScope);
             _commands.Add(_currentCommand);
@@ -178,10 +172,7 @@ namespace System.Management.Automation
                 throw PSTraceSource.NewArgumentNullException(nameof(script));
             }
 
-            if (_owner != null)
-            {
-                _owner.AssertChangesAreAccepted();
-            }
+            _owner?.AssertChangesAreAccepted();
 
             _currentCommand = new Command(script, true);
             _commands.Add(_currentCommand);
@@ -223,10 +214,7 @@ namespace System.Management.Automation
                 throw PSTraceSource.NewArgumentNullException(nameof(script));
             }
 
-            if (_owner != null)
-            {
-                _owner.AssertChangesAreAccepted();
-            }
+            _owner?.AssertChangesAreAccepted();
 
             _currentCommand = new Command(script, true, useLocalScope);
             _commands.Add(_currentCommand);
@@ -261,10 +249,7 @@ namespace System.Management.Automation
                 throw PSTraceSource.NewArgumentNullException(nameof(command));
             }
 
-            if (_owner != null)
-            {
-                _owner.AssertChangesAreAccepted();
-            }
+            _owner?.AssertChangesAreAccepted();
 
             _currentCommand = command;
             _commands.Add(_currentCommand);
@@ -308,10 +293,7 @@ namespace System.Management.Automation
                                                                  new object[] { "PSCommand" });
             }
 
-            if (_owner != null)
-            {
-                _owner.AssertChangesAreAccepted();
-            }
+            _owner?.AssertChangesAreAccepted();
 
             _currentCommand.Parameters.Add(parameterName, value);
             return this;
@@ -350,10 +332,7 @@ namespace System.Management.Automation
                                                                  new object[] { "PSCommand" });
             }
 
-            if (_owner != null)
-            {
-                _owner.AssertChangesAreAccepted();
-            }
+            _owner?.AssertChangesAreAccepted();
 
             _currentCommand.Parameters.Add(parameterName, true);
             return this;
@@ -370,10 +349,7 @@ namespace System.Management.Automation
                                                                  new object[] { "PSCommand" });
             }
 
-            if (_owner != null)
-            {
-                _owner.AssertChangesAreAccepted();
-            }
+            _owner?.AssertChangesAreAccepted();
 
             _currentCommand.Parameters.Add(parameter);
             return this;
@@ -412,10 +388,7 @@ namespace System.Management.Automation
                                                                  new object[] { "PSCommand" });
             }
 
-            if (_owner != null)
-            {
-                _owner.AssertChangesAreAccepted();
-            }
+            _owner?.AssertChangesAreAccepted();
 
             _currentCommand.Parameters.Add(null, value);
             return this;
diff --git a/src/System.Management.Automation/engine/hostifaces/PSDataCollection.cs b/src/System.Management.Automation/engine/hostifaces/PSDataCollection.cs
index d51c96a33..3574bbfe1 100644
--- a/src/System.Management.Automation/engine/hostifaces/PSDataCollection.cs
+++ b/src/System.Management.Automation/engine/hostifaces/PSDataCollection.cs
@@ -553,11 +553,7 @@ namespace System.Management.Automation
                 // raise the events outside of the lock.
                 if (raiseEvents)
                 {
-                    if (_readWaitHandle != null)
-                    {
-                        // unblock any readers waiting on the handle
-                        _readWaitHandle.Set();
-                    }
+                    _readWaitHandle?.Set();
 
                     // A temporary variable is used as the Completed may
                     // reach null (because of -='s) after the null check
@@ -798,10 +794,7 @@ namespace System.Management.Automation
         {
             lock (SyncObject)
             {
-                if (_data != null)
-                {
-                    _data.Clear();
-                }
+                _data?.Clear();
             }
         }
 
@@ -1560,10 +1553,7 @@ namespace System.Management.Automation
                 if (_refCount != 0 && (!_blockingEnumerator || _refCount != 1)) return;
 
                 // release threads blocked on waithandle
-                if (_readWaitHandle != null)
-                {
-                    _readWaitHandle.Set();
-                }
+                _readWaitHandle?.Set();
 
                 // release any threads to notify refCount is 0. Enumerator
                 // blocks on this syncObject and it needs to be notified
@@ -1795,10 +1785,7 @@ namespace System.Management.Automation
                         _readWaitHandle = null;
                     }
 
-                    if (_data != null)
-                    {
-                        _data.Clear();
-                    }
+                    _data?.Clear();
                 }
             }
         }
@@ -2101,10 +2088,7 @@ namespace System.Management.Automation
         /// <param name="item"></param>
         internal void AddProgress(ProgressRecord item)
         {
-            if (progress != null)
-            {
-                progress.InternalAdd(_psInstanceId, item);
-            }
+            progress?.InternalAdd(_psInstanceId, item);
         }
 
         /// <summary>
@@ -2114,10 +2098,7 @@ namespace System.Management.Automation
         /// <param name="item"></param>
         internal void AddVerbose(VerboseRecord item)
         {
-            if (verbose != null)
-            {
-                verbose.InternalAdd(_psInstanceId, item);
-            }
+            verbose?.InternalAdd(_psInstanceId, item);
         }
 
         /// <summary>
@@ -2127,10 +2108,7 @@ namespace System.Management.Automation
         /// <param name="item"></param>
         internal void AddDebug(DebugRecord item)
         {
-            if (debug != null)
-            {
-                debug.InternalAdd(_psInstanceId, item);
-            }
+            debug?.InternalAdd(_psInstanceId, item);
         }
 
         /// <summary>
@@ -2140,10 +2118,7 @@ namespace System.Management.Automation
         /// <param name="item"></param>
         internal void AddWarning(WarningRecord item)
         {
-            if (Warning != null)
-            {
-                Warning.InternalAdd(_psInstanceId, item);
-            }
+            Warning?.InternalAdd(_psInstanceId, item);
         }
 
         /// <summary>
@@ -2153,10 +2128,7 @@ namespace System.Management.Automation
         /// <param name="item"></param>
         internal void AddInformation(InformationRecord item)
         {
-            if (Information != null)
-            {
-                Information.InternalAdd(_psInstanceId, item);
-            }
+            Information?.InternalAdd(_psInstanceId, item);
         }
 
         #endregion
diff --git a/src/System.Management.Automation/engine/hostifaces/PSTask.cs b/src/System.Management.Automation/engine/hostifaces/PSTask.cs
index 5f05d267f..091eac989 100644
--- a/src/System.Management.Automation/engine/hostifaces/PSTask.cs
+++ b/src/System.Management.Automation/engine/hostifaces/PSTask.cs
@@ -488,10 +488,7 @@ namespace System.Management.Automation.PSTasks
         /// </summary>
         public void SignalStop()
         {
-            if (_powershell != null)
-            {
-                _powershell.BeginStop(null, null);
-            }
+            _powershell?.BeginStop(null, null);
         }
 
         #endregion
diff --git a/src/System.Management.Automation/engine/hostifaces/PowerShell.cs b/src/System.Management.Automation/engine/hostifaces/PowerShell.cs
index a76dbe1c0..ef027e95b 100644
--- a/src/System.Management.Automation/engine/hostifaces/PowerShell.cs
+++ b/src/System.Management.Automation/engine/hostifaces/PowerShell.cs
@@ -662,14 +662,14 @@ namespace System.Management.Automation
 
             InvocationStateInfo = new PSInvocationStateInfo(PSInvocationState.Disconnected, null);
 
-            if (rsConnection is RemoteRunspace)
+            if (rsConnection is RemoteRunspace remoteRunspace)
             {
                 _runspace = rsConnection as Runspace;
-                _runspacePool = ((RemoteRunspace)rsConnection).RunspacePool;
+                _runspacePool = remoteRunspace.RunspacePool;
             }
-            else if (rsConnection is RunspacePool)
+            else if (rsConnection is RunspacePool runspacePool)
             {
-                _runspacePool = (RunspacePool)rsConnection;
+                _runspacePool = runspacePool;
             }
 
             Dbg.Assert(_runspacePool != null, "Invalid rsConnection parameter>");
@@ -699,7 +699,7 @@ namespace System.Management.Automation
             PSDataCollectionStream<ErrorRecord> errordatastream = (PSDataCollectionStream<ErrorRecord>)errorstream;
             _errorBuffer = errordatastream.ObjectStore;
 
-            if (runspacePool != null && runspacePool.RemoteRunspacePoolInternal != null)
+            if (runspacePool?.RemoteRunspacePoolInternal != null)
             {
                 RemotePowerShell = new ClientRemotePowerShell(this, runspacePool.RemoteRunspacePoolInternal);
             }
@@ -2117,8 +2117,7 @@ namespace System.Management.Automation
                 SetStateChanged(new PSInvocationStateInfo(PSInvocationState.Failed, exception));
 
                 // re-throw the exception
-                InvalidRunspacePoolStateException poolException = exception as InvalidRunspacePoolStateException;
-                if (poolException != null && _runspace != null) // the pool exception was actually thrown by a runspace
+                if (exception is InvalidRunspacePoolStateException poolException && _runspace != null) // the pool exception was actually thrown by a runspace
                 {
                     throw poolException.ToInvalidRunspaceStateException();
                 }
@@ -3332,9 +3331,7 @@ namespace System.Management.Automation
             {
                 SetupAsyncBatchExecution();
             }
-
-            RunspacePool pool = _rsConnection as RunspacePool;
-            if ((pool != null) && (pool.IsRemote))
+            if ((_rsConnection is RunspacePool pool) && (pool.IsRemote))
             {
                 // Server supports batch invocation, in this case, we just send everything to the server and return immediately
                 if (ServerSupportsBatchInvocation())
@@ -3628,7 +3625,7 @@ namespace System.Management.Automation
         {
             IContainsErrorRecord er = e as IContainsErrorRecord;
 
-            if (er != null && er.ErrorRecord != null)
+            if (er?.ErrorRecord != null)
             {
                 this.Streams.Error.Add(er.ErrorRecord);
             }
@@ -4127,10 +4124,7 @@ namespace System.Management.Automation
                     _runspace.Dispose();
                 }
 
-                if (RemotePowerShell != null)
-                {
-                    RemotePowerShell.Dispose();
-                }
+                RemotePowerShell?.Dispose();
 
                 _invokeAsyncResult = null;
                 _stopAsyncResult = null;
@@ -4144,10 +4138,7 @@ namespace System.Management.Automation
         {
             lock (_syncObject)
             {
-                if (_worker != null)
-                {
-                    _worker.InternalClearSuppressExceptions();
-                }
+                _worker?.InternalClearSuppressExceptions();
             }
         }
 
@@ -4273,10 +4264,7 @@ namespace System.Management.Automation
                     {
                         if (RunningExtraCommands)
                         {
-                            if (tempInvokeAsyncResult != null)
-                            {
-                                tempInvokeAsyncResult.SetAsCompleted(InvocationStateInfo.Reason);
-                            }
+                            tempInvokeAsyncResult?.SetAsCompleted(InvocationStateInfo.Reason);
 
                             RaiseStateChangeEvent(InvocationStateInfo.Clone());
                         }
@@ -4284,16 +4272,10 @@ namespace System.Management.Automation
                         {
                             RaiseStateChangeEvent(InvocationStateInfo.Clone());
 
-                            if (tempInvokeAsyncResult != null)
-                            {
-                                tempInvokeAsyncResult.SetAsCompleted(InvocationStateInfo.Reason);
-                            }
+                            tempInvokeAsyncResult?.SetAsCompleted(InvocationStateInfo.Reason);
                         }
 
-                        if (tempStopAsyncResult != null)
-                        {
-                            tempStopAsyncResult.SetAsCompleted(null);
-                        }
+                        tempStopAsyncResult?.SetAsCompleted(null);
                     }
                     catch (Exception)
                     {
@@ -4332,10 +4314,7 @@ namespace System.Management.Automation
                         // This object can be disconnected even if "BeginStop" was called if it is a remote object
                         // and robust connections is retrying a failed network connection.
                         // In this case release the stop wait handle to prevent not responding.
-                        if (tempStopAsyncResult != null)
-                        {
-                            tempStopAsyncResult.SetAsCompleted(null);
-                        }
+                        tempStopAsyncResult?.SetAsCompleted(null);
 
                         // Only raise the Disconnected state changed event if the PowerShell state
                         // actually transitions to Disconnected from some other state.  This condition
@@ -4401,10 +4380,7 @@ namespace System.Management.Automation
         {
             lock (_syncObject)
             {
-                if (RemotePowerShell != null)
-                {
-                    RemotePowerShell.Clear();
-                }
+                RemotePowerShell?.Clear();
             }
         }
 
@@ -4500,7 +4476,6 @@ namespace System.Management.Automation
         /// <param name="settings">Invocation settings.</param>
         private void CoreInvokeHelper<TInput, TOutput>(PSDataCollection<TInput> input, PSDataCollection<TOutput> output, PSInvocationSettings settings)
         {
-            RunspacePool pool = _rsConnection as RunspacePool;
 
             // Prepare the environment...non-remoting case.
             Prepare<TInput, TOutput>(input, output, settings, true);
@@ -4511,7 +4486,7 @@ namespace System.Management.Automation
                 Runspace rsToUse = null;
                 if (!IsNested)
                 {
-                    if (pool != null)
+                    if (_rsConnection is RunspacePool pool)
                     {
 #if !UNIX
                         VerifyThreadSettings(settings, pool.ApartmentState, pool.ThreadOptions, false);
@@ -4566,9 +4541,8 @@ namespace System.Management.Automation
                 SetStateChanged(new PSInvocationStateInfo(PSInvocationState.Failed, exception));
 
                 // re-throw the exception
-                InvalidRunspacePoolStateException poolException = exception as InvalidRunspacePoolStateException;
 
-                if (poolException != null && _runspace != null) // the pool exception was actually thrown by a runspace
+                if (exception is InvalidRunspacePoolStateException poolException && _runspace != null) // the pool exception was actually thrown by a runspace
                 {
                     throw poolException.ToInvalidRunspaceStateException();
                 }
@@ -4631,8 +4605,7 @@ namespace System.Management.Automation
             }
 
             SetHadErrors(false);
-            RunspacePool pool = _rsConnection as RunspacePool;
-            if ((pool != null) && (pool.IsRemote))
+            if ((_rsConnection is RunspacePool pool) && (pool.IsRemote))
             {
                 if (ServerSupportsBatchInvocation())
                 {
@@ -4709,7 +4682,7 @@ namespace System.Management.Automation
 
                             IContainsErrorRecord er = e as IContainsErrorRecord;
 
-                            if (er != null && er.ErrorRecord != null)
+                            if (er?.ErrorRecord != null)
                             {
                                 this.Streams.Error.Add(er.ErrorRecord);
                             }
@@ -4871,8 +4844,7 @@ namespace System.Management.Automation
                     }
                     else
                     {
-                        LocalRunspace rs = _rsConnection as LocalRunspace;
-                        if (rs != null)
+                        if (_rsConnection is LocalRunspace rs)
                         {
 #if !UNIX
                             VerifyThreadSettings(settings, rs.ApartmentState, rs.ThreadOptions, false);
@@ -4912,10 +4884,10 @@ namespace System.Management.Automation
                 // allow GC collection
                 _invokeAsyncResult = null;
                 SetStateChanged(new PSInvocationStateInfo(PSInvocationState.Failed, exception));
+
                 // re-throw the exception
-                InvalidRunspacePoolStateException poolException = exception as InvalidRunspacePoolStateException;
 
-                if (poolException != null && _runspace != null) // the pool exception was actually thrown by a runspace
+                if (exception is InvalidRunspacePoolStateException poolException && _runspace != null) // the pool exception was actually thrown by a runspace
                 {
                     throw poolException.ToInvalidRunspaceStateException();
                 }
@@ -5118,11 +5090,7 @@ namespace System.Management.Automation
             // cannot complete with this object.
             if (isDisconnected)
             {
-                if (_invokeAsyncResult != null)
-                {
-                    // Since object is stopped, allow result wait to end.
-                    _invokeAsyncResult.SetAsCompleted(null);
-                }
+                _invokeAsyncResult?.SetAsCompleted(null);
 
                 _stopAsyncResult.SetAsCompleted(null);
 
@@ -5138,9 +5106,8 @@ namespace System.Management.Automation
             RaiseStateChangeEvent(InvocationStateInfo.Clone());
 
             bool shouldRunStopHelper = false;
-            RunspacePool pool = _rsConnection as RunspacePool;
 
-            if (pool != null && pool.IsRemote)
+            if (_rsConnection is RunspacePool pool && pool.IsRemote)
             {
                 if ((RemotePowerShell != null) && RemotePowerShell.Initialized)
                 {
@@ -5183,10 +5150,7 @@ namespace System.Management.Automation
         private void ReleaseDebugger()
         {
             LocalRunspace localRunspace = _runspace as LocalRunspace;
-            if (localRunspace != null)
-            {
-                localRunspace.ReleaseDebugger();
-            }
+            localRunspace?.ReleaseDebugger();
         }
 
         /// <summary>
@@ -5287,10 +5251,7 @@ namespace System.Management.Automation
             else
             {
                 RemoteRunspacePoolInternal remoteRunspacePoolInternal = GetRemoteRunspacePoolInternal();
-                if (remoteRunspacePoolInternal != null)
-                {
-                    remoteRunspacePoolInternal.PushRunningPowerShell(this);
-                }
+                remoteRunspacePoolInternal?.PushRunningPowerShell(this);
             }
         }
 
@@ -5306,10 +5267,7 @@ namespace System.Management.Automation
             else
             {
                 RemoteRunspacePoolInternal remoteRunspacePoolInternal = GetRemoteRunspacePoolInternal();
-                if (remoteRunspacePoolInternal != null)
-                {
-                    remoteRunspacePoolInternal.PopRunningPowerShell();
-                }
+                remoteRunspacePoolInternal?.PopRunningPowerShell();
             }
         }
 
@@ -5529,10 +5487,7 @@ namespace System.Management.Automation
             {
                 Dbg.Assert(rs != null, "Runspace cannot be null in ConstructPipelineAndDoWork");
                 _shell.RunspaceAssigned.SafeInvoke(this, new PSEventArgs<Runspace>(rs));
-
-                // lock is needed until a pipeline is created to
-                // make stop() cleanly release resources.
-                LocalRunspace lrs = rs as LocalRunspace;
+                // lock is needed until a pipeline is created to                // make stop() cleanly release resources.
 
                 lock (_syncObject)
                 {
@@ -5541,7 +5496,7 @@ namespace System.Management.Automation
                         return false;
                     }
 
-                    if (lrs != null)
+                    if (rs is LocalRunspace lrs)
                     {
                         LocalPipeline localPipeline = new LocalPipeline(
                             lrs,
@@ -5577,7 +5532,7 @@ namespace System.Management.Automation
                 // Set pipeline specific settings
                 CurrentlyRunningPipeline.InvocationSettings = _settings;
 
-                Dbg.Assert(lrs != null, "LocalRunspace cannot be null here");
+                Dbg.Assert(rs is LocalRunspace lrs, "LocalRunspace cannot be null here");
 
                 if (performSyncInvoke)
                 {
@@ -5621,8 +5576,7 @@ namespace System.Management.Automation
 
                     if (GetRunspaceAsyncResult != null)
                     {
-                        RunspacePool pool = _shell._rsConnection as RunspacePool;
-                        Dbg.Assert(pool != null, "RunspaceConnection must be a runspace pool");
+                        Dbg.Assert(_shell._rsConnection is RunspacePool pool, "RunspaceConnection must be a runspace pool");
                         pool.CancelGetRunspace(GetRunspaceAsyncResult);
                     }
                 }
@@ -5678,10 +5632,7 @@ namespace System.Management.Automation
                     else
                     {
                         RunspacePool pool = _shell._rsConnection as RunspacePool;
-                        if (pool != null)
-                        {
-                            pool.ReleaseRunspace(CurrentlyRunningPipeline.Runspace);
-                        }
+                        pool?.ReleaseRunspace(CurrentlyRunningPipeline.Runspace);
                     }
 
                     CurrentlyRunningPipeline.Dispose();
diff --git a/src/System.Management.Automation/engine/interpreter/InstructionList.cs b/src/System.Management.Automation/engine/interpreter/InstructionList.cs
index 3c810d186..e71693f17 100644
--- a/src/System.Management.Automation/engine/interpreter/InstructionList.cs
+++ b/src/System.Management.Automation/engine/interpreter/InstructionList.cs
@@ -359,15 +359,14 @@ namespace System.Management.Automation.Interpreter
 
             if (type == null || type.IsValueType)
             {
-                if (value is bool)
+                if (value is bool b)
                 {
-                    EmitLoad((bool)value);
+                    EmitLoad(b);
                     return;
                 }
 
-                if (value is int)
+                if (value is int i)
                 {
-                    int i = (int)value;
                     if (i >= PushIntMinCachedValue && i <= PushIntMaxCachedValue)
                     {
                         if (s_ints == null)
@@ -419,9 +418,7 @@ namespace System.Management.Automation.Interpreter
 
         internal void SwitchToBoxed(int index, int instructionIndex)
         {
-            var instruction = _instructions[instructionIndex] as IBoxableInstruction;
-
-            if (instruction != null)
+            if (_instructions[instructionIndex] is IBoxableInstruction instruction)
             {
                 var newInstruction = instruction.BoxIfIndexMatches(index);
                 if (newInstruction != null)
diff --git a/src/System.Management.Automation/engine/interpreter/LabelInfo.cs b/src/System.Management.Automation/engine/interpreter/LabelInfo.cs
index a85180998..1f0f5638b 100644
--- a/src/System.Management.Automation/engine/interpreter/LabelInfo.cs
+++ b/src/System.Management.Automation/engine/interpreter/LabelInfo.cs
@@ -189,8 +189,7 @@ namespace System.Management.Automation.Interpreter
                 return true;
             }
 
-            HashSet<LabelScopeInfo> definitions = _definitions as HashSet<LabelScopeInfo>;
-            if (definitions != null)
+            if (_definitions is HashSet<LabelScopeInfo> definitions)
             {
                 return definitions.Contains(scope);
             }
@@ -208,8 +207,7 @@ namespace System.Management.Automation.Interpreter
 
         private LabelScopeInfo FirstDefinition()
         {
-            LabelScopeInfo scope = _definitions as LabelScopeInfo;
-            if (scope != null)
+            if (_definitions is LabelScopeInfo scope)
             {
                 return scope;
             }
diff --git a/src/System.Management.Automation/engine/interpreter/LightCompiler.cs b/src/System.Management.Automation/engine/interpreter/LightCompiler.cs
index 85f97ee7d..73fe77f4c 100644
--- a/src/System.Management.Automation/engine/interpreter/LightCompiler.cs
+++ b/src/System.Management.Automation/engine/interpreter/LightCompiler.cs
@@ -654,8 +654,7 @@ namespace System.Management.Automation.Interpreter
         {
             var member = (MemberExpression)node.Left;
 
-            PropertyInfo pi = member.Member as PropertyInfo;
-            if (pi != null)
+            if (member.Member is PropertyInfo pi)
             {
                 var method = pi.SetMethod;
                 if (member.Expression != null)
@@ -682,8 +681,7 @@ namespace System.Management.Automation.Interpreter
                 return;
             }
 
-            FieldInfo fi = member.Member as FieldInfo;
-            if (fi != null)
+            if (member.Member is FieldInfo fi)
             {
                 if (member.Expression != null)
                 {
@@ -1306,8 +1304,7 @@ namespace System.Management.Automation.Interpreter
             {
                 Expression e = block.Expressions[i];
 
-                var label = e as LabelExpression;
-                if (label != null)
+                if (e is LabelExpression label)
                 {
                     DefineLabel(label.Target);
                 }
@@ -1364,8 +1361,7 @@ namespace System.Management.Automation.Interpreter
                 return node.Operand == null;
             }
 
-            BlockExpression block = expr as BlockExpression;
-            if (block != null)
+            if (expr is BlockExpression block)
             {
                 return EndsWithRethrow(block.Expressions[block.Expressions.Count - 1]);
             }
@@ -1628,8 +1624,8 @@ namespace System.Management.Automation.Interpreter
             var node = (MemberExpression)expr;
 
             var member = node.Member;
-            FieldInfo fi = member as FieldInfo;
-            if (fi != null)
+
+            if (member is FieldInfo fi)
             {
                 if (fi.IsLiteral)
                 {
@@ -1655,8 +1651,7 @@ namespace System.Management.Automation.Interpreter
                 return;
             }
 
-            PropertyInfo pi = member as PropertyInfo;
-            if (pi != null)
+            if (member is PropertyInfo pi)
             {
                 var method = pi.GetMethod;
                 if (node.Expression != null)
@@ -1707,8 +1702,7 @@ namespace System.Management.Automation.Interpreter
 
         private void CompileExtensionExpression(Expression expr)
         {
-            var instructionProvider = expr as IInstructionProvider;
-            if (instructionProvider != null)
+            if (expr is IInstructionProvider instructionProvider)
             {
                 instructionProvider.AddInstructions(this);
                 return;
diff --git a/src/System.Management.Automation/engine/interpreter/LocalVariables.cs b/src/System.Management.Automation/engine/interpreter/LocalVariables.cs
index d52f1fc68..7b17b2bd1 100644
--- a/src/System.Management.Automation/engine/interpreter/LocalVariables.cs
+++ b/src/System.Management.Automation/engine/interpreter/LocalVariables.cs
@@ -110,9 +110,8 @@ namespace System.Management.Automation.Interpreter
 
         public override bool Equals(object obj)
         {
-            if (obj is LocalDefinition)
+            if (obj is LocalDefinition other)
             {
-                LocalDefinition other = (LocalDefinition)obj;
                 return other.Index == Index && other.Parameter == Parameter;
             }
 
diff --git a/src/System.Management.Automation/engine/interpreter/LoopCompiler.cs b/src/System.Management.Automation/engine/interpreter/LoopCompiler.cs
index 6ff0e36f5..fa663671b 100644
--- a/src/System.Management.Automation/engine/interpreter/LoopCompiler.cs
+++ b/src/System.Management.Automation/engine/interpreter/LoopCompiler.cs
@@ -260,8 +260,7 @@ namespace System.Management.Automation.Interpreter
 
             Debug.Assert(!node.NodeType.IsReadWriteAssignment());
 
-            var param = node.Left as ParameterExpression;
-            if (param != null && node.NodeType == ExpressionType.Assign)
+            if (node.Left is ParameterExpression param && node.NodeType == ExpressionType.Assign)
             {
                 var left = VisitVariable(param, ExpressionAccess.Write);
                 var right = Visit(node.Right);
diff --git a/src/System.Management.Automation/engine/lang/interface/PSToken.cs b/src/System.Management.Automation/engine/lang/interface/PSToken.cs
index 048de2fac..b02fb461b 100644
--- a/src/System.Management.Automation/engine/lang/interface/PSToken.cs
+++ b/src/System.Management.Automation/engine/lang/interface/PSToken.cs
@@ -31,13 +31,13 @@ namespace System.Management.Automation
         {
             Type = GetPSTokenType(token);
             _extent = token.Extent;
-            if (token is StringToken)
+            if (token is StringToken stringToken)
             {
-                _content = ((StringToken)token).Value;
+                _content = stringToken.Value;
             }
-            else if (token is VariableToken)
+            else if (token is VariableToken variableToken)
             {
-                _content = ((VariableToken)token).VariablePath.ToString();
+                _content = variableToken.VariablePath.ToString();
             }
         }
 
diff --git a/src/System.Management.Automation/engine/lang/parserutils.cs b/src/System.Management.Automation/engine/lang/parserutils.cs
index 52c64400c..77925fc5c 100644
--- a/src/System.Management.Automation/engine/lang/parserutils.cs
+++ b/src/System.Management.Automation/engine/lang/parserutils.cs
@@ -920,8 +920,8 @@ namespace System.Management.Automation
             object substitute = string.Empty;
 
             rval = PSObject.Base(rval);
-            IList rList = rval as IList;
-            if (rList != null)
+
+            if (rval is IList rList)
             {
                 if (rList.Count > 2)
                 {
@@ -1615,8 +1615,7 @@ namespace System.Management.Automation
                 }
                 else
                 {
-                    PSMethod adaptedMethod = targetMethod as PSMethod;
-                    if (adaptedMethod != null)
+                    if (targetMethod is PSMethod adaptedMethod)
                     {
                         return adaptedMethod.Invoke(invocationConstraints, paramArray);
                     }
@@ -1965,8 +1964,7 @@ namespace System.Management.Automation
                 return;
             }
 
-            var icer = exception as IContainsErrorRecord;
-            if (icer != null)
+            if (exception is IContainsErrorRecord icer)
             {
                 var errorRecord = icer.ErrorRecord;
                 var invocationInfo = errorRecord.InvocationInfo;
diff --git a/src/System.Management.Automation/engine/lang/scriptblock.cs b/src/System.Management.Automation/engine/lang/scriptblock.cs
index 765809be3..06dcf8c9b 100644
--- a/src/System.Management.Automation/engine/lang/scriptblock.cs
+++ b/src/System.Management.Automation/engine/lang/scriptblock.cs
@@ -1166,11 +1166,8 @@ namespace System.Management.Automation
                 _context.PushPipelineProcessor(_pipeline);
                 _expectInput = expectInput;
 
-                // Start the pipeline, if the command calling this pipeline is
-                // not expecting input (as indicated by it's position in the pipeline
-                // then neither should we.
-                MshCommandRuntime crt = commandRuntime as MshCommandRuntime;
-                if (crt != null)
+                // Start the pipeline, if the command calling this pipeline is                // not expecting input (as indicated by it's position in the pipeline                // then neither should we.
+                if (commandRuntime is MshCommandRuntime crt)
                 {
                     if (crt.OutputPipe != null)
                     {
diff --git a/src/System.Management.Automation/engine/parser/AstVisitor.cs b/src/System.Management.Automation/engine/parser/AstVisitor.cs
index 5c09ee78d..ac9ceb968 100644
--- a/src/System.Management.Automation/engine/parser/AstVisitor.cs
+++ b/src/System.Management.Automation/engine/parser/AstVisitor.cs
@@ -436,8 +436,7 @@ namespace System.Management.Automation.Language
                 ast,
                 ast_ =>
                 {
-                    var varAst = ast_ as VariableExpressionAst;
-                    if (varAst != null)
+                    if (ast_ is VariableExpressionAst varAst)
                     {
                         return varAst.VariablePath.IsVariable &&
                                varAst.VariablePath.UnqualifiedPath.Equals(SpecialVariables.Input,
diff --git a/src/System.Management.Automation/engine/parser/Compiler.cs b/src/System.Management.Automation/engine/parser/Compiler.cs
index 794b28343..14a7c7f83 100644
--- a/src/System.Management.Automation/engine/parser/Compiler.cs
+++ b/src/System.Management.Automation/engine/parser/Compiler.cs
@@ -6918,10 +6918,7 @@ namespace System.Management.Automation.Language
             compiler.PopLabelBlock(LabelScopeKind.Statement);
 
             // If enterLoop is null, we will never JIT compile the loop.
-            if (enterLoop != null)
-            {
-                enterLoop.FinishLoop(compiler.Instructions.Count);
-            }
+            enterLoop?.FinishLoop(compiler.Instructions.Count);
         }
     }
 
diff --git a/src/System.Management.Automation/engine/parser/PSType.cs b/src/System.Management.Automation/engine/parser/PSType.cs
index 7a60d06a6..a5a6fe525 100644
--- a/src/System.Management.Automation/engine/parser/PSType.cs
+++ b/src/System.Management.Automation/engine/parser/PSType.cs
@@ -1090,8 +1090,7 @@ namespace System.Management.Automation.Language
                                 // We only want to add edges for enums being defined in the current scope.
                                 // We detect this by seeing if the ast is in our graph or not.
                                 var typeName = typeExpr.TypeName as TypeName;
-                                if (typeName != null
-                                    && typeName._typeDefinitionAst != null
+                                if (typeName?._typeDefinitionAst != null
                                     && typeName._typeDefinitionAst != helper._enumDefinitionAst  // Don't add self edges
                                     && graph.ContainsKey(typeName._typeDefinitionAst))
                                 {
diff --git a/src/System.Management.Automation/engine/parser/Parser.cs b/src/System.Management.Automation/engine/parser/Parser.cs
index 5b8ca4334..16fe70e32 100644
--- a/src/System.Management.Automation/engine/parser/Parser.cs
+++ b/src/System.Management.Automation/engine/parser/Parser.cs
@@ -318,8 +318,7 @@ namespace System.Management.Automation.Language
                 context.SetVariable(SpecialVariables.FirstTokenVarPath, _previousFirstTokenText);
                 if (!IgnoreTokenWhenUpdatingPreviousFirstLast(firstToken))
                 {
-                    var stringToken = firstToken as StringToken;
-                    _previousFirstTokenText = stringToken != null
+                    _previousFirstTokenText = firstToken is StringToken stringToken
                         ? stringToken.Value
                         : firstToken.Text;
                 }
@@ -329,8 +328,7 @@ namespace System.Management.Automation.Language
                 var lastToken = _tokenizer.LastToken;
                 if (!IgnoreTokenWhenUpdatingPreviousFirstLast(lastToken))
                 {
-                    var stringToken = lastToken as StringToken;
-                    _previousLastTokenText = stringToken != null
+                    _previousLastTokenText = firstToken is StringToken stringToken
                         ? stringToken.Value
                         : lastToken.Text;
                 }
@@ -615,20 +613,17 @@ namespace System.Management.Automation.Language
             {
                 if (obj != null)
                 {
-                    var token = obj as Token;
-                    if (token != null)
+                    if (obj is Token token)
                     {
                         return token.Extent;
                     }
 
-                    var ast = obj as Ast;
-                    if (ast != null)
+                    if (obj is Ast ast)
                     {
                         return ast.Extent;
                     }
 
-                    var typename = obj as ITypeName;
-                    if (typename != null)
+                    if (obj is ITypeName typename)
                     {
                         return typename.Extent;
                     }
@@ -671,15 +666,13 @@ namespace System.Management.Automation.Language
             {
                 if (obj != null)
                 {
-                    Ast ast = obj as Ast;
-                    if (ast != null)
+                    if (obj is Ast ast)
                     {
                         yield return ast;
                     }
                     else
                     {
-                        var enumerable = obj as IEnumerable<Ast>;
-                        if (enumerable != null)
+                        if (obj is IEnumerable<Ast> enumerable)
                         {
                             foreach (var ast2 in enumerable)
                             {
@@ -821,10 +814,9 @@ namespace System.Management.Automation.Language
                         result = new List<UsingStatementAst>();
                     }
 
-                    var usingStatement = statement as UsingStatementAst;
                     // otherwise returned statement is ErrorStatementAst.
                     // We ignore it here, because error already reported to the parser.
-                    if (usingStatement != null)
+                    if (statement is UsingStatementAst usingStatement)
                     {
                         result.Add(usingStatement);
                     }
@@ -889,8 +881,7 @@ namespace System.Management.Automation.Language
             {
                 foreach (AttributeBaseAst attr in candidateAttributes)
                 {
-                    AttributeAst attribute = attr as AttributeAst;
-                    if (attribute != null)
+                    if (attr is AttributeAst attribute)
                     {
                         attributes.Add(attribute);
                     }
@@ -1873,8 +1864,7 @@ namespace System.Management.Automation.Language
 
                 _tokenizer.CheckAstIsBeforeSignature(statement);
 
-                var trapStatementAst = statement as TrapStatementAst;
-                if (trapStatementAst != null)
+                if (statement is TrapStatementAst trapStatementAst)
                 {
                     traps.Add(trapStatementAst);
                 }
@@ -3068,10 +3058,7 @@ namespace System.Management.Automation.Language
                 }
                 finally
                 {
-                    if (p != null)
-                    {
-                        p.Dispose();
-                    }
+                    p?.Dispose();
 
                     //
                     // Put the parser back...
@@ -3115,14 +3102,8 @@ namespace System.Management.Automation.Language
                     return new ErrorStatementAst(ExtentOf(startExtent, endErrorStatement), configurationToken);
                 }
 
-                #region "Add Configuration Keywords"
-
-                // If the configuration name is a constant string, then
-                // if we're not at the top level, we'll add it to the list of configuration resource keywords.
-                // If we are at the top level, then we'll add it to the list of keywords defined in this
-                // parse so it can be used as a resource in subsequent config statements.
-                var scAst = configurationName as StringConstantExpressionAst;
-                if (scAst != null)
+                // If the configuration name is a constant string, then                // if we're not at the top level, we'll add it to the list of configuration resource keywords.                // If we are at the top level, then we'll add it to the list of keywords defined in this                // parse so it can be used as a resource in subsequent config statements.
+                if (configurationName is StringConstantExpressionAst scAst)
                 {
                     var keywordToAddForThisConfigurationStatement = new System.Management.Automation.Language.DynamicKeyword
                     {
@@ -3148,10 +3129,8 @@ namespace System.Management.Automation.Language
                         Name = "PsDscRunAsCredential",
                     };
                     keywordToAddForThisConfigurationStatement.Properties.Add(RunAsProp.Name, RunAsProp);
-
                     // Extract the parameters, if any and them to the keyword definition.
-                    var sbeAst = configurationBodyScriptBlock as ScriptBlockExpressionAst;
-                    if (sbeAst != null)
+                    if (configurationBodyScriptBlock is ScriptBlockExpressionAst sbeAst)
                     {
                         var pList = sbeAst.ScriptBlock.ParamBlock;
                         if (pList != null)
@@ -3164,15 +3143,12 @@ namespace System.Management.Automation.Language
                                 {
                                     foreach (var attr in parm.Attributes)
                                     {
-                                        var typeConstraint = attr as TypeConstraintAst;
-                                        if (typeConstraint != null)
+                                        if (attr is TypeConstraintAst typeConstraint)
                                         {
                                             keywordProp.TypeConstraint = typeConstraint.TypeName.Name;
                                             continue;
                                         }
-
-                                        var aAst = attr as AttributeAst;
-                                        if (aAst != null)
+                                        if (attr is AttributeAst aAst)
                                         {
                                             if (string.Equals(aAst.TypeName.Name, "Parameter", StringComparison.OrdinalIgnoreCase))
                                             {
@@ -3188,8 +3164,7 @@ namespace System.Management.Automation.Language
                                                             }
                                                             else if (na.Argument != null)
                                                             {
-                                                                ConstantExpressionAst ceAst = na.Argument as ConstantExpressionAst;
-                                                                if (ceAst != null)
+                                                                if (na.Argument is ConstantExpressionAst ceAst)
                                                                 {
                                                                     keywordProp.Mandatory = System.Management.Automation.LanguagePrimitives.IsTrue(ceAst.Value);
                                                                 }
@@ -3908,17 +3883,9 @@ namespace System.Management.Automation.Language
 
                     if (lCurly.Kind != TokenKind.LCurly)
                     {
-                        // We need to generate a reasonable error message for this case:
-                        //
-                        // Configuration C {
-                        //   node $AllNode.NodeName{ # There is no space before curly, and we are converting scriptblock to and argument to call 'NodeName'
-                        //     ...
-                        //   }
-                        // } # we don't want to simple report an unexpected token here, it would be super-confusing.
+                        // We need to generate a reasonable error message for this case:                        //                        // Configuration C {                        //   node $AllNode.NodeName{ # There is no space before curly, and we are converting scriptblock to and argument to call 'NodeName'                        //     ...                        //   }                        // } # we don't want to simple report an unexpected token here, it would be super-confusing.
 
-                        InvokeMemberExpressionAst instanceInvokeMemberExpressionAst = instanceName as InvokeMemberExpressionAst;
-
-                        if (instanceInvokeMemberExpressionAst != null &&
+                        if (instanceName is InvokeMemberExpressionAst instanceInvokeMemberExpressionAst &&
                             instanceInvokeMemberExpressionAst.Arguments.Count == 1 &&
                             instanceInvokeMemberExpressionAst.Arguments[0] is ScriptBlockExpressionAst &&
                             // the last condition checks that there is no space between "method" name and '{'
@@ -4403,8 +4370,7 @@ namespace System.Management.Automation.Language
                         startExtent = attribute.Extent;
                     }
 
-                    var attributeAst = attribute as AttributeAst;
-                    if (attributeAst != null)
+                    if (attribute is AttributeAst attributeAst)
                     {
                         attributeList.Add(attributeAst);
                     }
@@ -6022,9 +5988,8 @@ namespace System.Management.Automation.Language
                     }
 
                     RedirectionAst[] redirections = null;
-                    var redirectionToken = PeekToken() as RedirectionToken;
                     RedirectionAst lastRedirection = null;
-                    while (redirectionToken != null)
+                    while (PeekToken() is RedirectionToken redirectionToken)
                     {
                         SkipToken();
 
@@ -6161,8 +6126,7 @@ namespace System.Management.Automation.Language
 
             RedirectionAst result;
 
-            var fileRedirectionToken = redirectionToken as FileRedirectionToken;
-            if (fileRedirectionToken != null || (redirectionToken is InputRedirectionToken))
+            if (redirectionToken is FileRedirectionToken fileRedirectionToken || (redirectionToken is InputRedirectionToken))
             {
                 // get location
                 var filename = GetSingleCommandArgument(CommandArgumentContext.FileName);
@@ -6347,10 +6311,10 @@ namespace System.Management.Automation.Language
                         }
 
                         var genericToken = (StringToken)token;
-                        var expandableToken = genericToken as StringExpandableToken;
+
                         // A command name w/o invocation operator is not expandable even if the token has expandable parts
                         // If we have seen an invocation operator, the command name is expandable.
-                        if (expandableToken != null && context != CommandArgumentContext.CommandName)
+                        if (genericToken is StringExpandableToken expandableToken && context != CommandArgumentContext.CommandName)
                         {
                             var nestedExpressions = ParseNestedExpressions(expandableToken);
                             exprAst = new ExpandableStringExpressionAst(expandableToken, expandableToken.Value,
@@ -6610,10 +6574,8 @@ namespace System.Management.Automation.Language
                             else
                             {
                                 var ast = GetCommandArgument(context, token);
-
                                 // If this is the special verbatim argument syntax, look for the next element
-                                StringToken argumentToken = token as StringToken;
-                                if ((argumentToken != null) && string.Equals(argumentToken.Value, VERBATIM_ARGUMENT, StringComparison.OrdinalIgnoreCase))
+                                if ((token is StringToken argumentToken) && string.Equals(argumentToken.Value, VERBATIM_ARGUMENT, StringComparison.OrdinalIgnoreCase))
                                 {
                                     elements.Add(ast);
                                     endExtent = ast.Extent;
@@ -7192,9 +7154,8 @@ namespace System.Management.Automation.Language
 
                 for (int i = attributes.Count - 2; i >= 0; --i)
                 {
-                    var typeConstraint = attributes[i] as TypeConstraintAst;
 
-                    expr = typeConstraint != null
+                    expr = attributes[i] is TypeConstraintAst typeConstraint
                                 ? new ConvertExpressionAst(ExtentOf(typeConstraint, expr), typeConstraint, expr)
                                 : new AttributedExpressionAst(ExtentOf(attributes[i], expr), attributes[i], expr);
                 }
@@ -7624,9 +7585,8 @@ namespace System.Management.Automation.Language
                 Diagnostics.Assert(!token.HasError || ErrorList.Count > 0, "No nested tokens should have unreported errors.");
 
                 ExpressionAst exprAst;
-                var varToken = token as VariableToken;
 
-                if (varToken != null)
+                if (token is VariableToken varToken)
                 {
                     exprAst = CheckUsingVariable(varToken, false);
                     if (_savingTokens) { newNestedTokens.Add(varToken); }
@@ -7979,7 +7939,7 @@ namespace System.Management.Automation.Language
                 }
             }
 
-            Diagnostics.Assert(msgCorrespondsToString, string.Format("Parser error ID \"{0}\" must correspond to the error message \"{1}\"", errorId, errorMsg));
+            Diagnostics.Assert(msgCorrespondsToString, $"Parser error ID \"{errorId}\" must correspond to the error message \"{errorMsg}\"");
         }
 
         private static object[] arrayOfOneArg
@@ -8061,7 +8021,7 @@ namespace System.Management.Automation.Language
         private static void ReportErrorsAsWarnings(Collection<Exception> errors)
         {
             var executionContext = Runspaces.Runspace.DefaultRunspace.ExecutionContext;
-            if (executionContext != null && executionContext.InternalHost != null && executionContext.InternalHost.UI != null)
+            if (executionContext?.InternalHost != null && executionContext.InternalHost.UI != null)
             {
                 foreach (var error in errors)
                 {
diff --git a/src/System.Management.Automation/engine/parser/PreOrderVisitor.cs b/src/System.Management.Automation/engine/parser/PreOrderVisitor.cs
index 33b2fadec..91c0c6247 100644
--- a/src/System.Management.Automation/engine/parser/PreOrderVisitor.cs
+++ b/src/System.Management.Automation/engine/parser/PreOrderVisitor.cs
@@ -37,10 +37,7 @@ namespace System.Management.Automation.Language
         internal AstVisitAction CheckForPostAction(Ast ast, AstVisitAction action)
         {
             var postActionHandler = this as IAstPostVisitHandler;
-            if (postActionHandler != null)
-            {
-                postActionHandler.PostVisit(ast);
-            }
+            postActionHandler?.PostVisit(ast);
 
             return action;
         }
diff --git a/src/System.Management.Automation/engine/parser/SemanticChecks.cs b/src/System.Management.Automation/engine/parser/SemanticChecks.cs
index 3afd10ff6..edd19da53 100644
--- a/src/System.Management.Automation/engine/parser/SemanticChecks.cs
+++ b/src/System.Management.Automation/engine/parser/SemanticChecks.cs
@@ -57,9 +57,7 @@ namespace System.Management.Automation.Language
             {
                 return false;
             }
-
-            var fnMemberAst = currentMember as FunctionMemberAst;
-            return fnMemberAst != null ? fnMemberAst.IsStatic : ((PropertyMemberAst)currentMember).IsStatic;
+            return currentMember is FunctionMemberAst fnMemberAst ? fnMemberAst.IsStatic : ((PropertyMemberAst)currentMember).IsStatic;
         }
 
         private static bool IsValidAttributeArgument(Ast ast, IsConstantValueVisitor visitor)
@@ -134,8 +132,8 @@ namespace System.Management.Automation.Language
             AttributeTargets attributeTargets = default(AttributeTargets);
 
             var parent = attributeAst.Parent;
-            TypeDefinitionAst typeDefinitionAst = parent as TypeDefinitionAst;
-            if (typeDefinitionAst != null)
+
+            if (parent is TypeDefinitionAst typeDefinitionAst)
             {
                 checkingAttributeOnClass = true;
                 attributeTargets = typeDefinitionAst.IsClass
@@ -151,8 +149,7 @@ namespace System.Management.Automation.Language
             }
             else
             {
-                var functionMemberAst = parent as FunctionMemberAst;
-                if (functionMemberAst != null)
+                if (parent is FunctionMemberAst functionMemberAst)
                 {
                     checkingAttributeOnClass = true;
                     attributeTargets = functionMemberAst.IsConstructor
@@ -210,8 +207,7 @@ namespace System.Management.Automation.Language
                             continue;
                         }
 
-                        var propertyInfo = members[0] as PropertyInfo;
-                        if (propertyInfo != null)
+                        if (members[0] is PropertyInfo propertyInfo)
                         {
                             if (propertyInfo.GetSetMethod() == null)
                             {
@@ -360,9 +356,9 @@ namespace System.Management.Automation.Language
                     break;
                 }
 
-                if (type is ArrayTypeName)
+                if (type is ArrayTypeName arrayTypeName)
                 {
-                    type = ((ArrayTypeName)type).ElementType;
+                    type = arrayTypeName.ElementType;
                 }
                 else
                 {
@@ -607,8 +603,7 @@ namespace System.Management.Automation.Language
                     break;
                 }
 
-                var loop = parent as LoopStatementAst;
-                if (loop != null)
+                if (parent is LoopStatementAst loop)
                 {
                     if (LoopFlowException.MatchLoopLabel(label, loop.Label ?? string.Empty))
                         break;
@@ -645,11 +640,9 @@ namespace System.Management.Automation.Language
                         break;
                 }
 
-                var stmtBlock = parent as StatementBlockAst;
-                if (stmtBlock != null)
+                if (parent is StatementBlockAst stmtBlock)
                 {
-                    var tryStatementAst = stmtBlock.Parent as TryStatementAst;
-                    if (tryStatementAst != null && tryStatementAst.Finally == stmtBlock)
+                    if (stmtBlock.Parent is TryStatementAst tryStatementAst && tryStatementAst.Finally == stmtBlock)
                     {
                         _parser.ReportError(ast.Extent,
                             nameof(ParserStrings.ControlLeavingFinally),
@@ -733,9 +726,9 @@ namespace System.Management.Automation.Language
         /// <param name="reportError">The action called to report any errors.</param>
         private void CheckAssignmentTarget(ExpressionAst ast, bool simpleAssignment, Action<Ast> reportError)
         {
-            ArrayLiteralAst arrayLiteralAst = ast as ArrayLiteralAst;
             Ast errorAst = null;
-            if (arrayLiteralAst != null)
+
+            if (ast is ArrayLiteralAst arrayLiteralAst)
             {
                 if (simpleAssignment)
                 {
@@ -748,8 +741,7 @@ namespace System.Management.Automation.Language
             }
             else
             {
-                ParenExpressionAst parenExpressionAst = ast as ParenExpressionAst;
-                if (parenExpressionAst != null)
+                if (ast is ParenExpressionAst parenExpressionAst)
                 {
                     ExpressionAst expr = parenExpressionAst.Pipeline.GetPureExpression();
                     if (expr == null)
@@ -782,8 +774,7 @@ namespace System.Management.Automation.Language
                     Type lastConvertType = null;
                     while (expr is AttributedExpressionAst)
                     {
-                        var convertExpr = expr as ConvertExpressionAst;
-                        if (convertExpr != null)
+                        if (expr is ConvertExpressionAst convertExpr)
                         {
                             converts += 1;
                             lastConvertType = convertExpr.Type.TypeName.GetReflectionType();
@@ -810,8 +801,7 @@ namespace System.Management.Automation.Language
                     }
                     else
                     {
-                        var varExprAst = expr as VariableExpressionAst;
-                        if (varExprAst != null)
+                        if (expr is VariableExpressionAst varExprAst)
                         {
                             var varPath = varExprAst.VariablePath;
                             if (varPath.IsVariable && varPath.IsAnyLocal())
@@ -926,11 +916,9 @@ namespace System.Management.Automation.Language
                 bool multipleRefs = false;
                 while (true)
                 {
-                    var childAttrExpr = child as AttributedExpressionAst;
-                    if (childAttrExpr != null)
+                    if (child is AttributedExpressionAst childAttrExpr)
                     {
-                        var childConvert = childAttrExpr as ConvertExpressionAst;
-                        if (childConvert != null && typeof(PSReference) == childConvert.Type.TypeName.GetReflectionType())
+                        if (childAttrExpr is ConvertExpressionAst childConvert && typeof(PSReference) == childConvert.Type.TypeName.GetReflectionType())
                         {
                             multipleRefs = true;
                             _parser.ReportError(childConvert.Type.Extent,
@@ -944,13 +932,10 @@ namespace System.Management.Automation.Language
 
                     break;
                 }
-
                 // Check for [int][ref], but don't add an extra error for [ref][ref].
-                var parent = convertExpressionAst.Parent as AttributedExpressionAst;
-                while (parent != null)
+                while (convertExpressionAst.Parent is AttributedExpressionAst parent)
                 {
-                    var parentConvert = parent as ConvertExpressionAst;
-                    if (parentConvert != null && !multipleRefs)
+                    if (parent is ConvertExpressionAst parentConvert && !multipleRefs)
                     {
                         if (typeof(PSReference) == parentConvert.Type.TypeName.GetReflectionType())
                         {
@@ -963,8 +948,7 @@ namespace System.Management.Automation.Language
                         bool skipError = false;
                         while (ast != null)
                         {
-                            var statementAst = ast as AssignmentStatementAst;
-                            if (statementAst != null)
+                            if (ast is AssignmentStatementAst statementAst)
                             {
                                 skipError = statementAst.Left.Find(ast1 => ast1 == convertExpressionAst, searchNestedScriptBlocks: true) != null;
                                 break;
@@ -1026,15 +1010,13 @@ namespace System.Management.Automation.Language
             }
 
             var memberExpr = exprAst as MemberExpressionAst;
-            if (memberExpr != null
-                && memberExpr is not InvokeMemberExpressionAst
+            if (memberExpr is not InvokeMemberExpressionAst
                 && memberExpr.Member is StringConstantExpressionAst)
             {
                 return CheckUsingExpression(memberExpr.Expression);
             }
 
-            var indexExpr = exprAst as IndexExpressionAst;
-            if (indexExpr != null)
+            if (exprAst is IndexExpressionAst indexExpr)
             {
                 if (!IsValidAttributeArgument(indexExpr.Index, s_isConstantAttributeArgVisitor))
                 {
@@ -1103,8 +1085,7 @@ namespace System.Management.Automation.Language
             HashSet<string> keys = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
             foreach (var entry in hashtableAst.KeyValuePairs)
             {
-                var keyStrAst = entry.Item1 as ConstantExpressionAst;
-                if (keyStrAst != null)
+                if (entry.Item1 is ConstantExpressionAst keyStrAst)
                 {
                     var keyStr = keyStrAst.Value.ToString();
                     if (keys.Contains(keyStr))
@@ -1255,30 +1236,21 @@ namespace System.Management.Automation.Language
                 int ancestorNodeLevel = 0; // The nearest ancestor PipelineAst should be two level above the 'scriptBlockExpressionAst'
                 while ((ast != null) && (ancestorNodeLevel <= 2))
                 {
-                    //
-                    // Find nearest ancestor NamedBlockAst
-                    //
-                    var namedBlockedAst = ast as NamedBlockAst;
-                    if ((namedBlockedAst != null) && (statementAst != null) && (ancestorNodeLevel == 2))
+                    //                    // Find nearest ancestor NamedBlockAst                    //
+                    if ((ast is NamedBlockAst namedBlockedAst) && (statementAst != null) && (ancestorNodeLevel == 2))
                     {
                         int index = namedBlockedAst.Statements.IndexOf(statementAst);
                         if (index > 0)
                         {
-                            //
-                            // Check if previous Statement is CommandAst
-                            //
-                            var pipelineAst = namedBlockedAst.Statements[index - 1] as PipelineAst;
-                            if (pipelineAst != null && pipelineAst.PipelineElements.Count == 1)
+                            //                            // Check if previous Statement is CommandAst                            //
+                            if (namedBlockedAst.Statements[index - 1] is PipelineAst pipelineAst && pipelineAst.PipelineElements.Count == 1)
                             {
-                                var commandAst = pipelineAst.PipelineElements[0] as CommandAst;
-                                if (commandAst != null &&
+                                if (pipelineAst.PipelineElements[0] is CommandAst commandAst &&
                                     commandAst.CommandElements.Count <= 2 &&
                                     commandAst.DefiningKeyword == null)
                                 {
-                                    // Here indicates a CommandAst followed by a ScriptBlockExpression,
-                                    // which is invalid if the DSC resource is not defined
-                                    var commandNameAst = commandAst.CommandElements[0] as StringConstantExpressionAst;
-                                    if (commandNameAst != null)
+                                    // Here indicates a CommandAst followed by a ScriptBlockExpression,                                    // which is invalid if the DSC resource is not defined
+                                    if (commandAst.CommandElements[0] is StringConstantExpressionAst commandNameAst)
                                     {
                                         _parser.ReportError(commandNameAst.Extent,
                                             nameof(ParserStrings.ResourceNotDefined),
@@ -1366,8 +1338,8 @@ namespace System.Management.Automation.Language
             }
 
             DynamicKeyword keyword = dynamicKeywordStatementAst.Keyword;
-            HashtableAst hashtable = dynamicKeywordStatementAst.BodyExpression as HashtableAst;
-            if (hashtable != null)
+
+            if (dynamicKeywordStatementAst.BodyExpression is HashtableAst hashtable)
             {
                 //
                 // If it's a hash table, validate that only valid members have been specified.
@@ -1403,8 +1375,7 @@ namespace System.Management.Automation.Language
             ConfigurationDefinitionAst configAst = Ast.GetAncestorAst<ConfigurationDefinitionAst>(dynamicKeywordStatementAst);
             if (configAst != null)
             {
-                StringConstantExpressionAst nameAst = dynamicKeywordStatementAst.CommandElements[0] as StringConstantExpressionAst;
-                Diagnostics.Assert(nameAst != null, "nameAst should never be null");
+                Diagnostics.Assert(dynamicKeywordStatementAst.CommandElements[0] is StringConstantExpressionAst nameAst, "nameAst should never be null");
                 if (!DscClassCache.SystemResourceNames.Contains(nameAst.Extent.Text.Trim()))
                 {
                     if (configAst.ConfigurationType == ConfigurationType.Meta && !dynamicKeywordStatementAst.Keyword.IsMetaDSCResource())
@@ -1449,8 +1420,7 @@ namespace System.Management.Automation.Language
 
         public void PostVisit(Ast ast)
         {
-            var scriptBlockAst = ast as ScriptBlockAst;
-            if (scriptBlockAst != null)
+            if (ast is ScriptBlockAst scriptBlockAst)
             {
                 if (scriptBlockAst.Parent == null
                     || scriptBlockAst.Parent is ScriptBlockExpressionAst
@@ -1494,9 +1464,7 @@ namespace System.Management.Automation.Language
 
             foreach (var member in typeDefinitionAst.Members)
             {
-                var functionMemberAst = member as FunctionMemberAst;
-
-                if (functionMemberAst != null)
+                if (member is FunctionMemberAst functionMemberAst)
                 {
                     CheckSet(functionMemberAst, ref hasSet);
                     CheckGet(parser, functionMemberAst, ref hasGet);
@@ -1604,8 +1572,7 @@ namespace System.Management.Automation.Language
 
                 foreach (var member in baseTypeDefinitionAst.Members)
                 {
-                    var functionMemberAst = member as FunctionMemberAst;
-                    if (functionMemberAst != null)
+                    if (member is FunctionMemberAst functionMemberAst)
                     {
                         CheckSet(functionMemberAst, ref hasSet);
                         CheckGet(parser, functionMemberAst, ref hasGet);
@@ -1721,8 +1688,7 @@ namespace System.Management.Automation.Language
                                 var propertyType = propertyMemberAst.PropertyType;
                                 if (propertyType != null)
                                 {
-                                    TypeName typeName = propertyType.TypeName as TypeName;
-                                    if (typeName != null)
+                                    if (propertyType.TypeName is TypeName typeName)
                                     {
                                         var type = typeName.GetReflectionType();
                                         if (type != null)
diff --git a/src/System.Management.Automation/engine/parser/TypeResolver.cs b/src/System.Management.Automation/engine/parser/TypeResolver.cs
index 8843ff5cd..503c256fd 100644
--- a/src/System.Management.Automation/engine/parser/TypeResolver.cs
+++ b/src/System.Management.Automation/engine/parser/TypeResolver.cs
@@ -933,10 +933,7 @@ namespace System.Management.Automation
         public static bool Remove(string typeName)
         {
             userTypeAccelerators.Remove(typeName);
-            if (s_allTypeAccelerators != null)
-            {
-                s_allTypeAccelerators.Remove(typeName);
-            }
+            s_allTypeAccelerators?.Remove(typeName);
 
             return true;
         }
diff --git a/src/System.Management.Automation/engine/parser/VariableAnalysis.cs b/src/System.Management.Automation/engine/parser/VariableAnalysis.cs
index 4cc8e98a2..7919712cf 100644
--- a/src/System.Management.Automation/engine/parser/VariableAnalysis.cs
+++ b/src/System.Management.Automation/engine/parser/VariableAnalysis.cs
@@ -279,8 +279,7 @@ namespace System.Management.Automation.Language
 
         public override AstVisitAction VisitCommand(CommandAst commandAst)
         {
-            var commandName = commandAst.CommandElements[0] as StringConstantExpressionAst;
-            if (commandName != null && s_hashOfPessimizingCmdlets.Contains(commandName.Value))
+            if (commandAst.CommandElements[0] is StringConstantExpressionAst commandName && s_hashOfPessimizingCmdlets.Contains(commandName.Value))
             {
                 // TODO: psuedo-bind the command invocation to figure out the variable and only force that variable to be unoptimized
                 _disableOptimizations = true;
@@ -756,8 +755,7 @@ namespace System.Management.Automation.Language
 
         private static void FixTupleIndex(Ast ast, int newIndex)
         {
-            var variableAst = ast as VariableExpressionAst;
-            if (variableAst != null)
+            if (ast is VariableExpressionAst variableAst)
             {
                 if (variableAst.TupleIndex != ForceDynamic)
                 {
@@ -766,8 +764,7 @@ namespace System.Management.Automation.Language
             }
             else
             {
-                var dataStatementAst = ast as DataStatementAst;
-                if (dataStatementAst != null)
+                if (ast is DataStatementAst dataStatementAst)
                 {
                     if (dataStatementAst.TupleIndex != ForceDynamic)
                     {
@@ -779,8 +776,7 @@ namespace System.Management.Automation.Language
 
         private static void FixAssigned(Ast ast, VariableAnalysisDetails details)
         {
-            var variableAst = ast as VariableExpressionAst;
-            if (variableAst != null && details.Assigned)
+            if (ast is VariableExpressionAst variableAst && details.Assigned)
             {
                 variableAst.Assigned = true;
             }
@@ -790,8 +786,7 @@ namespace System.Management.Automation.Language
         {
             foreach (var ast in block._asts)
             {
-                var variableExpressionAst = ast as VariableExpressionAst;
-                if (variableExpressionAst != null)
+                if (ast is VariableExpressionAst variableExpressionAst)
                 {
                     var varPath = variableExpressionAst.VariablePath;
                     if (varPath.IsAnyLocal())
@@ -814,8 +809,7 @@ namespace System.Management.Automation.Language
                     continue;
                 }
 
-                var assignmentTarget = ast as AssignmentTarget;
-                if (assignmentTarget != null)
+                if (ast is AssignmentTarget assignmentTarget)
                 {
                     if (assignmentTarget._targetAst != null)
                     {
@@ -829,8 +823,7 @@ namespace System.Management.Automation.Language
                     continue;
                 }
 
-                var dataStatementAst = ast as DataStatementAst;
-                if (dataStatementAst != null)
+                if (ast is DataStatementAst dataStatementAst)
                 {
                     var details = CheckLHSAssignVar(dataStatementAst.Variable, assignedBitArray, typeof(object));
                     dataStatementAst.TupleIndex = details.LocalTupleIndex;
@@ -844,9 +837,9 @@ namespace System.Management.Automation.Language
 
         private void CheckLHSAssign(ExpressionAst lhs, BitArray assignedBitArray)
         {
-            var convertExpr = lhs as ConvertExpressionAst;
             Type convertType = null;
-            if (convertExpr != null)
+
+            if (lhs is ConvertExpressionAst convertExpr)
             {
                 lhs = convertExpr.Child;
                 convertType = convertExpr.StaticType;
@@ -1425,8 +1418,7 @@ namespace System.Management.Automation.Language
                 label.Accept(this);
                 if (_loopTargets.Count > 0)
                 {
-                    var labelStrAst = label as StringConstantExpressionAst;
-                    if (labelStrAst != null)
+                    if (label is StringConstantExpressionAst labelStrAst)
                     {
                         targetBlock = (from t in _loopTargets
                                        where t.Label.Equals(labelStrAst.Value, StringComparison.OrdinalIgnoreCase)
@@ -1468,10 +1460,7 @@ namespace System.Management.Automation.Language
 
         private Block ControlFlowStatement(PipelineBaseAst pipelineAst)
         {
-            if (pipelineAst != null)
-            {
-                pipelineAst.Accept(this);
-            }
+            pipelineAst?.Accept(this);
 
             _currentBlock.FlowsTo(_exitBlock);
             var lastBlockInStatement = _currentBlock;
@@ -1503,8 +1492,7 @@ namespace System.Management.Automation.Language
 
         private static IEnumerable<ExpressionAst> GetAssignmentTargets(ExpressionAst expressionAst)
         {
-            var parenExpr = expressionAst as ParenExpressionAst;
-            if (parenExpr != null)
+            if (expressionAst is ParenExpressionAst parenExpr)
             {
                 foreach (var e in GetAssignmentTargets(parenExpr.Pipeline.GetPureExpression()))
                 {
@@ -1513,8 +1501,7 @@ namespace System.Management.Automation.Language
             }
             else
             {
-                var arrayLiteral = expressionAst as ArrayLiteralAst;
-                if (arrayLiteral != null)
+                if (expressionAst is ArrayLiteralAst arrayLiteral)
                 {
                     foreach (var e in arrayLiteral.Elements.SelectMany(GetAssignmentTargets))
                     {
@@ -1550,7 +1537,7 @@ namespace System.Management.Automation.Language
                     leftAst = ((AttributedExpressionAst)leftAst).Child;
                 }
 
-                if (leftAst is VariableExpressionAst)
+                if (leftAst is VariableExpressionAst variableExpressionAst)
                 {
                     // Two below if statements are similar, but there is a difference:
                     // The first one tells us about the dynamic nature of the local type.
@@ -1561,7 +1548,7 @@ namespace System.Management.Automation.Language
                     if (anyAttributes || convertCount > 1 ||
                         (convertAst != null && convertAst.Type.TypeName.GetReflectionType() == null))
                     {
-                        var varPath = ((VariableExpressionAst)leftAst).VariablePath;
+                        var varPath = variableExpressionAst.VariablePath;
                         if (varPath.IsAnyLocal())
                         {
                             var details = _variables[GetUnaliasedVariableName(varPath)];
diff --git a/src/System.Management.Automation/engine/parser/tokenizer.cs b/src/System.Management.Automation/engine/parser/tokenizer.cs
index 5ab09c0a4..32767ad4e 100644
--- a/src/System.Management.Automation/engine/parser/tokenizer.cs
+++ b/src/System.Management.Automation/engine/parser/tokenizer.cs
@@ -1208,10 +1208,7 @@ namespace System.Management.Automation.Language
 
         private T SaveToken<T>(T token) where T : Token
         {
-            if (TokenList != null)
-            {
-                TokenList.Add(token);
-            }
+            TokenList?.Add(token);
 
             // Keep track of the first and last token even if we're not saving tokens
             // for the special variables $$ and $^.
@@ -1909,14 +1906,13 @@ namespace System.Management.Automation.Language
             {
                 var requiresExtent = new InternalScriptExtent(_positionHelper, token.Extent.StartOffset + 1, token.Extent.EndOffset);
                 var state = StartNestedScan(new UnscannedSubExprToken(requiresExtent, TokenFlags.None, requiresExtent.Text, null));
-                var commandAst = _parser.CommandRule(forDynamicKeyword: false) as CommandAst;
                 _parser._ungotToken = null;
                 FinishNestedScan(state);
 
                 string snapinName = null;
                 Version snapinVersion = null;
 
-                if (commandAst != null)
+                if (_parser.CommandRule(forDynamicKeyword: false) is CommandAst commandAst)
                 {
                     var commandName = commandAst.GetCommandName();
                     if (!string.Equals(commandName, "requires", StringComparison.OrdinalIgnoreCase))
@@ -1929,9 +1925,7 @@ namespace System.Management.Automation.Language
                     var snapinSpecified = false;
                     for (int i = 1; i < commandAst.CommandElements.Count; i++)
                     {
-                        var parameter = commandAst.CommandElements[i] as CommandParameterAst;
-
-                        if (parameter != null &&
+                        if (commandAst.CommandElements[i] is CommandParameterAst parameter &&
                             PSSnapinToken.StartsWith(parameter.ParameterName, StringComparison.OrdinalIgnoreCase))
                         {
                             snapinSpecified = true;
@@ -1946,8 +1940,7 @@ namespace System.Management.Automation.Language
 
                     for (int i = 1; i < commandAst.CommandElements.Count; i++)
                     {
-                        var parameter = commandAst.CommandElements[i] as CommandParameterAst;
-                        if (parameter != null)
+                        if (commandAst.CommandElements[i] is CommandParameterAst parameter)
                         {
                             HandleRequiresParameter(parameter, commandAst.CommandElements, snapinSpecified,
                                 ref i, ref snapinName, ref snapinVersion,
diff --git a/src/System.Management.Automation/engine/pipeline.cs b/src/System.Management.Automation/engine/pipeline.cs
index 14837fd1c..77fcb1f17 100644
--- a/src/System.Management.Automation/engine/pipeline.cs
+++ b/src/System.Management.Automation/engine/pipeline.cs
@@ -182,7 +182,7 @@ namespace System.Management.Automation.Internal
         private static string GetCommand(Exception exception)
         {
             IContainsErrorRecord icer = exception as IContainsErrorRecord;
-            if (icer != null && icer.ErrorRecord != null)
+            if (icer?.ErrorRecord != null)
                 return GetCommand(icer.ErrorRecord.InvocationInfo);
 
             return string.Empty;
@@ -214,10 +214,7 @@ namespace System.Management.Automation.Internal
             // Log the cmdlet invocation execution details if we didn't have an associated script line with it.
             if ((invocation == null) || string.IsNullOrEmpty(invocation.Line))
             {
-                if (hostInterface != null)
-                {
-                    hostInterface.TranscribeCommand(logElement, invocation);
-                }
+                hostInterface?.TranscribeCommand(logElement, invocation);
             }
 
             if (!string.IsNullOrEmpty(logElement))
@@ -248,9 +245,7 @@ namespace System.Management.Automation.Internal
 
             foreach (CommandProcessorBase commandProcessor in _commands)
             {
-                MshCommandRuntime cmdRuntime = commandProcessor.Command.commandRuntime as MshCommandRuntime;
-
-                if (cmdRuntime != null && cmdRuntime.LogPipelineExecutionDetail)
+                if (commandProcessor.Command.commandRuntime is MshCommandRuntime cmdRuntime && cmdRuntime.LogPipelineExecutionDetail)
                     return true;
             }
 
@@ -750,10 +745,7 @@ namespace System.Management.Automation.Internal
                 Start(expectInput);
 
                 // If a terminating error occurred, report it now.
-                if (_firstTerminatingError != null)
-                {
-                    _firstTerminatingError.Throw();
-                }
+                _firstTerminatingError?.Throw();
             }
             catch (PipelineStoppedException)
             {
@@ -762,10 +754,7 @@ namespace System.Management.Automation.Internal
                 // The error we want to report is the first terminating error
                 // which occurred during pipeline execution, regardless
                 // of whether other errors occurred afterward.
-                if (_firstTerminatingError != null)
-                {
-                    _firstTerminatingError.Throw();
-                }
+                _firstTerminatingError?.Throw();
 
                 throw;
             }
@@ -863,10 +852,7 @@ namespace System.Management.Automation.Internal
                 Inject(input, enumerate: false);
 
                 // If a terminating error occurred, report it now.
-                if (_firstTerminatingError != null)
-                {
-                    _firstTerminatingError.Throw();
-                }
+                _firstTerminatingError?.Throw();
 
                 return RetrieveResults();
             }
@@ -877,10 +863,7 @@ namespace System.Management.Automation.Internal
                 // The error we want to report is the first terminating error
                 // which occurred during pipeline execution, regardless
                 // of whether other errors occurred afterward.
-                if (_firstTerminatingError != null)
-                {
-                    _firstTerminatingError.Throw();
-                }
+                _firstTerminatingError?.Throw();
 
                 throw;
             }
@@ -1319,9 +1302,7 @@ namespace System.Management.Automation.Internal
                             if (commandProcessor.Command != null)
                                 myInvocation = commandProcessor.Command.MyInvocation;
 
-                            ProviderInvocationException pie =
-                                e as ProviderInvocationException;
-                            if (pie != null)
+                            if (e is ProviderInvocationException pie)
                             {
                                 e = new CmdletProviderInvocationException(
                                     pie,
@@ -1361,10 +1342,7 @@ namespace System.Management.Automation.Internal
                     // exceptions...
                     try
                     {
-                        if (redirPipe != null)
-                        {
-                            redirPipe.Dispose();
-                        }
+                        redirPipe?.Dispose();
                     }
                     catch (Exception)
                     {
diff --git a/src/System.Management.Automation/engine/remoting/client/ClientMethodExecutor.cs b/src/System.Management.Automation/engine/remoting/client/ClientMethodExecutor.cs
index 120ca07a5..ca2257173 100644
--- a/src/System.Management.Automation/engine/remoting/client/ClientMethodExecutor.cs
+++ b/src/System.Management.Automation/engine/remoting/client/ClientMethodExecutor.cs
@@ -94,11 +94,10 @@ namespace System.Management.Automation.Remoting
             bool hostAllowSetShouldExit = false;
             if (clientHost != null)
             {
-                PSObject hostPrivateData = clientHost.PrivateData as PSObject;
-                if (hostPrivateData != null)
+                if (clientHost.PrivateData is PSObject hostPrivateData)
                 {
                     PSNoteProperty allowSetShouldExit = hostPrivateData.Properties["AllowSetShouldExitFromRemote"] as PSNoteProperty;
-                    hostAllowSetShouldExit = allowSetShouldExit != null && allowSetShouldExit.Value is bool && (bool)allowSetShouldExit.Value;
+                    hostAllowSetShouldExit = allowSetShouldExit?.Value is bool && (bool)allowSetShouldExit.Value;
                 }
             }
 
diff --git a/src/System.Management.Automation/engine/remoting/client/ClientRemotePowerShell.cs b/src/System.Management.Automation/engine/remoting/client/ClientRemotePowerShell.cs
index 4ea06ea2f..d9d4591e3 100644
--- a/src/System.Management.Automation/engine/remoting/client/ClientRemotePowerShell.cs
+++ b/src/System.Management.Automation/engine/remoting/client/ClientRemotePowerShell.cs
@@ -166,10 +166,7 @@ namespace System.Management.Automation.Runspaces.Internal
 
             outputstream.Close();
             errorstream.Close();
-            if (inputstream != null)
-            {
-                inputstream.Close();
-            }
+            inputstream?.Close();
         }
 
         /// <summary>
@@ -423,8 +420,7 @@ namespace System.Management.Automation.Runspaces.Internal
                     bool terminateSession = false;
                     if (stateInfo.State == PSInvocationState.Failed)
                     {
-                        PSRemotingTransportException remotingTransportException = stateInfo.Reason as PSRemotingTransportException;
-                        terminateSession = (remotingTransportException != null) &&
+                        terminateSession = (stateInfo.Reason is PSRemotingTransportException remotingTransportException) &&
                                            (remotingTransportException.ErrorCode == System.Management.Automation.Remoting.Client.WSManNativeApi.ERROR_WSMAN_TARGETSESSION_DOESNOTEXIST);
                     }
 
@@ -467,16 +463,14 @@ namespace System.Management.Automation.Runspaces.Internal
         /// <param name="ex">Exception.</param>
         private void CheckAndCloseRunspaceAfterStop(Exception ex)
         {
-            PSRemotingTransportException transportException = ex as PSRemotingTransportException;
-            if (transportException != null &&
+            if (ex is PSRemotingTransportException transportException &&
                 (transportException.ErrorCode == System.Management.Automation.Remoting.Client.WSManNativeApi.ERROR_WSMAN_SENDDATA_CANNOT_CONNECT ||
                  transportException.ErrorCode == System.Management.Automation.Remoting.Client.WSManNativeApi.ERROR_WSMAN_SENDDATA_CANNOT_COMPLETE ||
                  transportException.ErrorCode == System.Management.Automation.Remoting.Client.WSManNativeApi.ERROR_WSMAN_TARGETSESSION_DOESNOTEXIST))
             {
                 object rsObject = shell.GetRunspaceConnection();
-                if (rsObject is Runspace)
+                if (rsObject is Runspace runspace)
                 {
-                    Runspace runspace = (Runspace)rsObject;
                     if (runspace.RunspaceStateInfo.State == RunspaceState.Opened)
                     {
                         try
@@ -487,9 +481,8 @@ namespace System.Management.Automation.Runspaces.Internal
                         { }
                     }
                 }
-                else if (rsObject is RunspacePool)
+                else if (rsObject is RunspacePool runspacePool)
                 {
-                    RunspacePool runspacePool = (RunspacePool)rsObject;
                     if (runspacePool.RunspacePoolStateInfo.State == RunspacePoolState.Opened)
                     {
                         try
diff --git a/src/System.Management.Automation/engine/remoting/client/Job.cs b/src/System.Management.Automation/engine/remoting/client/Job.cs
index 657b72bef..a4205d5aa 100644
--- a/src/System.Management.Automation/engine/remoting/client/Job.cs
+++ b/src/System.Management.Automation/engine/remoting/client/Job.cs
@@ -1451,10 +1451,7 @@ namespace System.Management.Automation
                 {
                     lock (syncObject)
                     {
-                        if (_finished != null)
-                        {
-                            _finished.Set();
-                        }
+                        _finished?.Set();
                     }
                 }
 #pragma warning restore 56500
@@ -3090,8 +3087,7 @@ namespace System.Management.Automation
 
             foreach (object errorData in error)
             {
-                ErrorRecord er = errorData as ErrorRecord;
-                if (er != null)
+                if (errorData is ErrorRecord er)
                 {
                     OriginInfo originInfo = new OriginInfo(reader.ComputerName, reader.RunspaceId);
 
@@ -3125,9 +3121,7 @@ namespace System.Management.Automation
         /// <param name="eventArgs">The event args.</param>
         private void HandleHostCalls(object sender, EventArgs eventArgs)
         {
-            ObjectStream hostCallsStream = sender as ObjectStream;
-
-            if (hostCallsStream != null)
+            if (sender is ObjectStream hostCallsStream)
             {
                 Collection<object> hostCallMethodExecutors =
                     hostCallsStream.NonBlockingRead(hostCallsStream.Count);
@@ -3330,19 +3324,14 @@ namespace System.Management.Automation
                 object targetObject = runspace.ConnectionInfo.ComputerName;
 
                 string errorDetails = null;
-
-                // set the transport message in the error detail so that
-                // the user can directly get to see the message without
-                // having to mine through the error record details
-                PSRemotingTransportException transException =
-                            failureException as PSRemotingTransportException;
+                // set the transport message in the error detail so that                // the user can directly get to see the message without                // having to mine through the error record details
 
                 string fullyQualifiedErrorId =
                     System.Management.Automation.Remoting.Client.WSManTransportManagerUtils.GetFQEIDFromTransportError(
-                        (transException != null) ? transException.ErrorCode : 0,
+                        (failureException is PSRemotingTransportException transException) ? transException.ErrorCode : 0,
                         "PSSessionStateBroken");
 
-                if (transException != null)
+                if (failureException is PSRemotingTransportException transException)
                 {
                     errorDetails = "[" + runspace.ConnectionInfo.ComputerName + "] ";
 
@@ -3393,10 +3382,10 @@ namespace System.Management.Automation
                 failureException = pipeline.PipelineStateInfo.Reason;
                 if (failureException != null)
                 {
-                    RemoteException rException = failureException as RemoteException;
 
                     ErrorRecord errorRecord = null;
-                    if (rException != null)
+
+                    if (failureException is RemoteException rException)
                     {
                         errorRecord = rException.ErrorRecord;
 
@@ -4080,10 +4069,7 @@ namespace System.Management.Automation
         internal void CheckStateAndRaiseStopEvent()
         {
             RemoteDebugger remoteDebugger = _wrappedDebugger as RemoteDebugger;
-            if (remoteDebugger != null)
-            {
-                remoteDebugger.CheckStateAndRaiseStopEvent();
-            }
+            remoteDebugger?.CheckStateAndRaiseStopEvent();
         }
 
         /// <summary>
@@ -4133,10 +4119,7 @@ namespace System.Management.Automation
 
         private static void RestoreRemoteOutput(Pipeline runningCmd)
         {
-            if (runningCmd != null)
-            {
-                runningCmd.ResumeIncomingData();
-            }
+            runningCmd?.ResumeIncomingData();
         }
 
         private void HandleBreakpointUpdated(object sender, BreakpointUpdatedEventArgs e)
@@ -4251,8 +4234,7 @@ namespace System.Management.Automation
             foreach (ExecutionCmdletHelper helper in _helpers)
             {
                 // cleanup remote runspace related handlers
-                RemoteRunspace remoteRS = helper.PipelineRunspace as RemoteRunspace;
-                if (remoteRS != null)
+                if (helper.PipelineRunspace is RemoteRunspace remoteRS)
                 {
                     remoteRS.StateChanged -= HandleRunspaceStateChanged;
                     remoteRS.URIRedirectionReported -= HandleURIDirectionReported;
@@ -4427,10 +4409,9 @@ namespace System.Management.Automation
         /// <param name="e"></param>
         private void HandleRunspaceStateChanged(object sender, RunspaceStateEventArgs e)
         {
-            RemoteRunspace remoteRS = sender as RemoteRunspace;
             // remote runspace must be connected (or connection failed)
             // we dont need URI redirection any more..so clear it
-            if (remoteRS != null)
+            if (sender is RemoteRunspace remoteRS)
             {
                 if (e.RunspaceStateInfo.State != RunspaceState.Opening)
                 {
diff --git a/src/System.Management.Automation/engine/remoting/client/RemoteRunspacePoolInternal.cs b/src/System.Management.Automation/engine/remoting/client/RemoteRunspacePoolInternal.cs
index 94584c613..b8d85d719 100644
--- a/src/System.Management.Automation/engine/remoting/client/RemoteRunspacePoolInternal.cs
+++ b/src/System.Management.Automation/engine/remoting/client/RemoteRunspacePoolInternal.cs
@@ -1372,8 +1372,7 @@ namespace System.Management.Automation.Runspaces.Internal
 
             if (pspBufferMode != null)
             {
-                string bufferingMode = pspBufferMode.Value as string;
-                if (bufferingMode != null)
+                if (pspBufferMode.Value is string bufferingMode)
                 {
                     OutputBufferingMode outputBufferingMode;
                     if (Enum.TryParse<OutputBufferingMode>(bufferingMode, out outputBufferingMode))
@@ -1386,8 +1385,7 @@ namespace System.Management.Automation.Runspaces.Internal
 
             if (pspResourceUri != null)
             {
-                string strShellUri = pspResourceUri.Value as string;
-                if (strShellUri != null)
+                if (pspResourceUri.Value is string strShellUri)
                 {
                     wsmanConnectionInfo.ShellUri = strShellUri;
                 }
@@ -1395,8 +1393,7 @@ namespace System.Management.Automation.Runspaces.Internal
 
             if (pspLocale != null)
             {
-                string localString = pspLocale.Value as string;
-                if (localString != null)
+                if (pspLocale.Value is string localString)
                 {
                     try
                     {
@@ -1409,8 +1406,7 @@ namespace System.Management.Automation.Runspaces.Internal
 
             if (pspDataLocale != null)
             {
-                string dataLocalString = pspDataLocale.Value as string;
-                if (dataLocalString != null)
+                if (pspDataLocale.Value is string dataLocalString)
                 {
                     try
                     {
@@ -1423,8 +1419,7 @@ namespace System.Management.Automation.Runspaces.Internal
 
             if (pspCompressionMode != null)
             {
-                string compressionModeString = pspCompressionMode.Value as string;
-                if (compressionModeString != null)
+                if (pspCompressionMode.Value is string compressionModeString)
                 {
                     wsmanConnectionInfo.UseCompression = !compressionModeString.Equals("NoCompression", StringComparison.OrdinalIgnoreCase);
                 }
@@ -1432,8 +1427,7 @@ namespace System.Management.Automation.Runspaces.Internal
 
             if (pspEncoding != null)
             {
-                string encodingString = pspEncoding.Value as string;
-                if (encodingString != null)
+                if (pspEncoding.Value is string encodingString)
                 {
                     wsmanConnectionInfo.UseUTF16 = encodingString.Equals("UTF16", StringComparison.OrdinalIgnoreCase);
                 }
@@ -1441,8 +1435,7 @@ namespace System.Management.Automation.Runspaces.Internal
 
             if (pspProfile != null)
             {
-                string machineProfileLoadedString = pspProfile.Value as string;
-                if (machineProfileLoadedString != null)
+                if (pspProfile.Value is string machineProfileLoadedString)
                 {
                     wsmanConnectionInfo.NoMachineProfile = !machineProfileLoadedString.Equals("Yes", StringComparison.OrdinalIgnoreCase);
                 }
@@ -1468,9 +1461,8 @@ namespace System.Management.Automation.Runspaces.Internal
 
             if (pspIdleTimeOut != null && pspShellInactivity != null)
             {
-                string shellInactivityString = pspShellInactivity.Value as string;
                 int idleTimeout;
-                if ((shellInactivityString != null) &&
+                if ((pspShellInactivity.Value is string shellInactivityString) &&
                     GetTimeIntValue(pspIdleTimeOut.Value as string, out idleTimeout))
                 {
                     try
@@ -1763,8 +1755,7 @@ namespace System.Management.Automation.Runspaces.Internal
         /// <param name="eventArgs"></param>
         private void HandleURIDirectionReported(object sender, RemoteDataEventArgs<Uri> eventArgs)
         {
-            WSManConnectionInfo wsmanConnectionInfo = _connectionInfo as WSManConnectionInfo;
-            if (wsmanConnectionInfo != null)
+            if (_connectionInfo is WSManConnectionInfo wsmanConnectionInfo)
             {
                 wsmanConnectionInfo.ConnectionUri = eventArgs.Data;
                 URIRedirectionReported.SafeInvoke(this, eventArgs);
@@ -1810,8 +1801,8 @@ namespace System.Management.Automation.Runspaces.Internal
             {
                 _connectionInfo.IdleTimeout = eventArgs.ConnectionInfo.IdleTimeout;
                 _connectionInfo.MaxIdleTimeout = eventArgs.ConnectionInfo.MaxIdleTimeout;
-                WSManConnectionInfo wsmanConnectionInfo = _connectionInfo as WSManConnectionInfo;
-                if (wsmanConnectionInfo != null)
+
+                if (_connectionInfo is WSManConnectionInfo wsmanConnectionInfo)
                 {
                     wsmanConnectionInfo.OutputBufferingMode =
                         ((WSManConnectionInfo)eventArgs.ConnectionInfo).OutputBufferingMode;
@@ -1826,20 +1817,14 @@ namespace System.Management.Automation.Runspaces.Internal
         {
             // Reset DisconnectedOn/ExpiresOn
             WSManConnectionInfo wsManConnectionInfo = _connectionInfo as WSManConnectionInfo;
-            if (wsManConnectionInfo != null)
-            {
-                wsManConnectionInfo.NullDisconnectedExpiresOn();
-            }
+            wsManConnectionInfo?.NullDisconnectedExpiresOn();
         }
 
         private void UpdateDisconnectedExpiresOn()
         {
             // Set DisconnectedOn/ExpiresOn for disconnected session.
             WSManConnectionInfo wsManConnectionInfo = _connectionInfo as WSManConnectionInfo;
-            if (wsManConnectionInfo != null)
-            {
-                wsManConnectionInfo.SetDisconnectedExpiresOnToNow();
-            }
+            wsManConnectionInfo?.SetDisconnectedExpiresOnToNow();
         }
 
         /// <summary>
diff --git a/src/System.Management.Automation/engine/remoting/client/RemotingProtocol2.cs b/src/System.Management.Automation/engine/remoting/client/RemotingProtocol2.cs
index 8b8908b6e..b1272b4e2 100644
--- a/src/System.Management.Automation/engine/remoting/client/RemotingProtocol2.cs
+++ b/src/System.Management.Automation/engine/remoting/client/RemotingProtocol2.cs
@@ -275,10 +275,7 @@ namespace System.Management.Automation.Internal
             // if a data structure handler does not exist it means
             // the association has been removed -
             // discard messages
-            if (dsHandler != null)
-            {
-                dsHandler.ProcessReceivedData(rcvdData);
-            }
+            dsHandler?.ProcessReceivedData(rcvdData);
         }
 
         /// <summary>
@@ -919,8 +916,7 @@ namespace System.Management.Automation.Internal
         {
             get
             {
-                if (_transportManager != null &&
-                    _transportManager is WSManClientSessionTransportManager)
+                if (                    _transportManager is WSManClientSessionTransportManager)
                 {
                     return ((WSManClientSessionTransportManager)(_transportManager)).MaxRetryConnectionTime;
                 }
diff --git a/src/System.Management.Automation/engine/remoting/client/RunspaceRef.cs b/src/System.Management.Automation/engine/remoting/client/RunspaceRef.cs
index dfd1cd3bf..50afaea10 100644
--- a/src/System.Management.Automation/engine/remoting/client/RunspaceRef.cs
+++ b/src/System.Management.Automation/engine/remoting/client/RunspaceRef.cs
@@ -216,8 +216,7 @@ namespace System.Management.Automation.Remoting
             }
 
             // Add robust connection callback if this is a pushed runspace.
-            RemotePipeline remotePipeline = pipeline as RemotePipeline;
-            if (this.IsRunspaceOverridden && remotePipeline != null)
+            if (this.IsRunspaceOverridden && pipeline is RemotePipeline remotePipeline)
             {
                 PowerShell shell = remotePipeline.PowerShell;
                 if (shell.RemotePowerShell != null)
@@ -228,9 +227,7 @@ namespace System.Management.Automation.Remoting
                 // Add callback to write robust connection errors from stream.
                 shell.ErrorBuffer.DataAdded += (sender, eventArgs) =>
                 {
-                    RemoteRunspace remoteRunspace = _runspaceRef.Value as RemoteRunspace;
-                    PSDataCollection<ErrorRecord> erBuffer = sender as PSDataCollection<ErrorRecord>;
-                    if (remoteRunspace != null && erBuffer != null &&
+                    if (_runspaceRef.Value is RemoteRunspace remoteRunspace && sender is PSDataCollection<ErrorRecord> erBuffer &&
                         remoteRunspace.RunspacePool.RemoteRunspacePoolInternal.Host != null)
                     {
                         Collection<ErrorRecord> erRecords = erBuffer.ReadAll();
@@ -381,8 +378,7 @@ namespace System.Management.Automation.Remoting
 
         private void WriteRCFailedError()
         {
-            RemoteRunspace remoteRunspace = _runspaceRef.Value as RemoteRunspace;
-            if (remoteRunspace != null &&
+            if (_runspaceRef.Value is RemoteRunspace remoteRunspace &&
                 remoteRunspace.RunspacePool.RemoteRunspacePoolInternal.Host != null)
             {
                 remoteRunspace.RunspacePool.RemoteRunspacePoolInternal.Host.UI.WriteErrorLine(
@@ -396,8 +392,7 @@ namespace System.Management.Automation.Remoting
             string computerName,
             int totalSeconds)
         {
-            RemoteRunspace remoteRunspace = _runspaceRef.Value as RemoteRunspace;
-            if (remoteRunspace != null)
+            if (_runspaceRef.Value is RemoteRunspace remoteRunspace)
             {
                 s_RCProgress.StartProgress(
                     sourceId,
diff --git a/src/System.Management.Automation/engine/remoting/client/ThrottlingJob.cs b/src/System.Management.Automation/engine/remoting/client/ThrottlingJob.cs
index a00fdee17..5745be396 100644
--- a/src/System.Management.Automation/engine/remoting/client/ThrottlingJob.cs
+++ b/src/System.Management.Automation/engine/remoting/client/ThrottlingJob.cs
@@ -53,10 +53,7 @@ namespace System.Management.Automation
                         childJob.Dispose();
                     }
 
-                    if (_jobResultsThrottlingSemaphore != null)
-                    {
-                        _jobResultsThrottlingSemaphore.Dispose();
-                    }
+                    _jobResultsThrottlingSemaphore?.Dispose();
 
                     _cancellationTokenSource.Dispose();
                 }
@@ -541,10 +538,7 @@ namespace System.Management.Automation
                 } while (false);
             }
 
-            if (readyToRunChildJob != null)
-            {
-                readyToRunChildJob.StartJob();
-            }
+            readyToRunChildJob?.StartJob();
         }
 
         private void EnqueueReadyToRunChildJob(StartableJob childJob)
@@ -1227,10 +1221,7 @@ namespace System.Management.Automation
                             }
                             finally
                             {
-                                if (cancellationTokenRegistration != null)
-                                {
-                                    cancellationTokenRegistration.Dispose();
-                                }
+                                cancellationTokenRegistration?.Dispose();
                             }
                         }
                         finally
diff --git a/src/System.Management.Automation/engine/remoting/client/clientremotesessionprotocolstatemachine.cs b/src/System.Management.Automation/engine/remoting/client/clientremotesessionprotocolstatemachine.cs
index d035ce6e8..6c4b84533 100644
--- a/src/System.Management.Automation/engine/remoting/client/clientremotesessionprotocolstatemachine.cs
+++ b/src/System.Management.Automation/engine/remoting/client/clientremotesessionprotocolstatemachine.cs
@@ -254,10 +254,7 @@ namespace System.Management.Automation.Remoting
                         if (_state == RemoteSessionState.EstablishedAndKeySent)
                         {
                             Timer tmp = Interlocked.Exchange(ref _keyExchangeTimer, null);
-                            if (tmp != null)
-                            {
-                                tmp.Dispose();
-                            }
+                            tmp?.Dispose();
 
                             _keyExchanged = true;
                             SetState(RemoteSessionState.Established, eventArgs.Reason);
@@ -339,10 +336,7 @@ namespace System.Management.Automation.Remoting
             Dbg.Assert(_state == RemoteSessionState.EstablishedAndKeySent, "timeout should only happen when waiting for a key");
 
             Timer tmp = Interlocked.Exchange(ref _keyExchangeTimer, null);
-            if (tmp != null)
-            {
-                tmp.Dispose();
-            }
+            tmp?.Dispose();
 
             PSRemotingDataStructureException exception =
                 new PSRemotingDataStructureException(RemotingErrorIdStrings.ClientKeyExchangeFailed);
diff --git a/src/System.Management.Automation/engine/remoting/client/remoterunspace.cs b/src/System.Management.Automation/engine/remoting/client/remoterunspace.cs
index 7ddd65787..a824cd959 100644
--- a/src/System.Management.Automation/engine/remoting/client/remoterunspace.cs
+++ b/src/System.Management.Automation/engine/remoting/client/remoterunspace.cs
@@ -642,11 +642,7 @@ namespace System.Management.Automation
                         //
                     }
 
-                    if (_remoteDebugger != null)
-                    {
-                        // Release RunspacePool event forwarding handlers.
-                        _remoteDebugger.Dispose();
-                    }
+                    _remoteDebugger?.Dispose();
 
                     try
                     {
@@ -960,9 +956,8 @@ namespace System.Management.Automation
             }
             else
             {
-                ContainerConnectionInfo containerConnectionInfo = _connectionInfo as ContainerConnectionInfo;
 
-                if ((containerConnectionInfo != null) &&
+                if ((_connectionInfo is ContainerConnectionInfo containerConnectionInfo) &&
                     (containerConnectionInfo.ContainerProc.RuntimeId == Guid.Empty))
                 {
                     returnCaps |= RunspaceCapability.NamedPipeTransport;
@@ -1270,8 +1265,7 @@ namespace System.Management.Automation
             {
                 IHostSupportsInteractiveSession interactiveHost =
                     RunspacePool.RemoteRunspacePoolInternal.Host as IHostSupportsInteractiveSession;
-                if (interactiveHost != null &&
-                    interactiveHost.Runspace != null &&
+                if (interactiveHost?.Runspace != null &&
                     interactiveHost.Runspace.Debugger != null)
                 {
                     hostDebugMode = interactiveHost.Runspace.Debugger.DebugMode;
@@ -1576,8 +1570,7 @@ namespace System.Management.Automation
         /// <param name="eventArgs"></param>
         private void HandleURIDirectionReported(object sender, RemoteDataEventArgs<Uri> eventArgs)
         {
-            WSManConnectionInfo wsmanConnectionInfo = _connectionInfo as WSManConnectionInfo;
-            if (wsmanConnectionInfo != null)
+            if (_connectionInfo is WSManConnectionInfo wsmanConnectionInfo)
             {
                 // change the runspace's uri to the new URI.
                 wsmanConnectionInfo.ConnectionUri = eventArgs.Data;
@@ -1618,8 +1611,8 @@ namespace System.Management.Automation
             {
                 _connectionInfo.IdleTimeout = eventArgs.ConnectionInfo.IdleTimeout;
                 _connectionInfo.MaxIdleTimeout = eventArgs.ConnectionInfo.MaxIdleTimeout;
-                WSManConnectionInfo wsmanConnectionInfo = _connectionInfo as WSManConnectionInfo;
-                if (wsmanConnectionInfo != null)
+
+                if (_connectionInfo is WSManConnectionInfo wsmanConnectionInfo)
                 {
                     wsmanConnectionInfo.OutputBufferingMode =
                         ((WSManConnectionInfo)eventArgs.ConnectionInfo).OutputBufferingMode;
@@ -1632,8 +1625,7 @@ namespace System.Management.Automation
         /// </summary>
         private void UpdateDisconnectExpiresOn()
         {
-            WSManConnectionInfo wsmanConnectionInfo = RunspacePool.RemoteRunspacePoolInternal.ConnectionInfo as WSManConnectionInfo;
-            if (wsmanConnectionInfo != null)
+            if (RunspacePool.RemoteRunspacePoolInternal.ConnectionInfo is WSManConnectionInfo wsmanConnectionInfo)
             {
                 this.DisconnectedOn = wsmanConnectionInfo.DisconnectedOn;
                 this.ExpiresOn = wsmanConnectionInfo.ExpiresOn;
@@ -1731,10 +1723,7 @@ namespace System.Management.Automation
             System.Management.Automation.Remoting.Client.NamedPipeClientSessionTransportManager transportManager =
                 RunspacePool.RemoteRunspacePoolInternal.DataStructureHandler.TransportManager as System.Management.Automation.Remoting.Client.NamedPipeClientSessionTransportManager;
 
-            if (transportManager != null)
-            {
-                transportManager.AbortConnect();
-            }
+            transportManager?.AbortConnect();
         }
 
         #endregion Internal Methods
@@ -1907,8 +1896,7 @@ namespace System.Management.Automation
                         {
                             if (item == null) { return; }
 
-                            DebuggerCommand dbgCmd = item.BaseObject as DebuggerCommand;
-                            if (dbgCmd != null)
+                            if (item.BaseObject is DebuggerCommand dbgCmd)
                             {
                                 bool executedByDebugger = (dbgCmd.ResumeAction != null || dbgCmd.ExecutedByDebugger);
                                 results = new DebuggerCommandResults(dbgCmd.ResumeAction, executedByDebugger);
@@ -1931,8 +1919,7 @@ namespace System.Management.Automation
                 catch (Exception e)
                 {
                     executionError = true;
-                    RemoteException re = e as RemoteException;
-                    if ((re != null) && (re.ErrorRecord != null))
+                    if ((e is RemoteException re) && (re.ErrorRecord != null))
                     {
                         // Allow the IncompleteParseException to throw so that the console
                         // can handle here strings and continued parsing.
@@ -2577,8 +2564,7 @@ namespace System.Management.Automation
             // Raise BreakpointUpdated event to client for each breakpoint.
             foreach (PSObject obj in breakpoints)
             {
-                Breakpoint breakpoint = obj.BaseObject as Breakpoint;
-                if (breakpoint != null)
+                if (obj.BaseObject is Breakpoint breakpoint)
                 {
                     RaiseBreakpointUpdatedEvent(
                         new BreakpointUpdatedEventArgs(breakpoint, BreakpointUpdateType.Set, _breakpointCount));
@@ -2700,8 +2686,7 @@ namespace System.Management.Automation
                 SetRemoteDebug(true, RunspaceAvailability.RemoteDebug);
 
                 // Raise event and wait for response.
-                DebuggerStopEventArgs args = state as DebuggerStopEventArgs;
-                if (args != null)
+                if (state is DebuggerStopEventArgs args)
                 {
                     if (IsDebuggerStopEventSubscribed())
                     {
@@ -2761,9 +2746,8 @@ namespace System.Management.Automation
         private void HandleForwardedDebuggerBreakpointUpdatedEvent(object sender, PSEventArgs e)
         {
             Dbg.Assert(e.SourceArgs.Length == 1, "Forwarded debugger breakpoint event args must always contain one SourceArgs item.");
-            BreakpointUpdatedEventArgs bpArgs = e.SourceArgs[0] as BreakpointUpdatedEventArgs;
 
-            if (bpArgs != null)
+            if (e.SourceArgs[0] is BreakpointUpdatedEventArgs bpArgs)
             {
                 UpdateBreakpointCount(bpArgs.BreakpointCount);
                 base.RaiseBreakpointUpdatedEvent(bpArgs);
diff --git a/src/System.Management.Automation/engine/remoting/client/remotingprotocolimplementation.cs b/src/System.Management.Automation/engine/remoting/client/remotingprotocolimplementation.cs
index d88003111..441e1de98 100644
--- a/src/System.Management.Automation/engine/remoting/client/remotingprotocolimplementation.cs
+++ b/src/System.Management.Automation/engine/remoting/client/remotingprotocolimplementation.cs
@@ -300,8 +300,7 @@ namespace System.Management.Automation.Remoting
             // once session is established.. start receiving data (if not already done and only apples to wsmanclientsessionTM)
             if (arg.SessionStateInfo.State == RemoteSessionState.Established)
             {
-                WSManClientSessionTransportManager tm = _transportManager as WSManClientSessionTransportManager;
-                if (tm != null)
+                if (_transportManager is WSManClientSessionTransportManager tm)
                 {
                     tm.AdjustForProtocolVariations(_session.ServerProtocolVersion);
                     tm.StartReceivingData();
@@ -464,8 +463,7 @@ namespace System.Management.Automation.Remoting
         {
             Dbg.Assert(e != null, "HandleTransportError expects non-null eventargs");
             // handle uri redirections
-            PSRemotingTransportRedirectException redirectException = e.Exception as PSRemotingTransportRedirectException;
-            if ((redirectException != null) && (_maxUriRedirectionCount > 0))
+            if ((e.Exception is PSRemotingTransportRedirectException redirectException) && (_maxUriRedirectionCount > 0))
             {
                 Exception exception = null;
 
diff --git a/src/System.Management.Automation/engine/remoting/commands/ConnectPSSession.cs b/src/System.Management.Automation/engine/remoting/commands/ConnectPSSession.cs
index f58aa3563..8a2eb2351 100644
--- a/src/System.Management.Automation/engine/remoting/commands/ConnectPSSession.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/ConnectPSSession.cs
@@ -554,10 +554,7 @@ namespace Microsoft.PowerShell.Commands
 
             internal override void StopOperation()
             {
-                if (_queryRunspaces != null)
-                {
-                    _queryRunspaces.StopAllOperations();
-                }
+                _queryRunspaces?.StopAllOperations();
 
                 _session.Runspace.StateChanged -= StateCallBackHandler;
                 SendStopComplete();
@@ -624,8 +621,7 @@ namespace Microsoft.PowerShell.Commands
                     bool writeError = true;
                     if (_queryRunspaces == null)
                     {
-                        PSRemotingTransportException transportException = eArgs.RunspaceStateInfo.Reason as PSRemotingTransportException;
-                        if (transportException != null &&
+                        if (eArgs.RunspaceStateInfo.Reason is PSRemotingTransportException transportException &&
                             transportException.ErrorCode == WSManNativeApi.ERROR_WSMAN_INUSE_CANNOT_RECONNECT)
                         {
                             lock (s_LockObject)
@@ -707,8 +703,7 @@ namespace Microsoft.PowerShell.Commands
                     if (e != null && !string.IsNullOrEmpty(e.Message))
                     {
                         // Update fully qualified error Id if we have a transport error.
-                        PSRemotingTransportException transportException = e as PSRemotingTransportException;
-                        if (transportException != null)
+                        if (e is PSRemotingTransportException transportException)
                         {
                             FQEID = WSManTransportManagerUtils.GetFQEIDFromTransportError(transportException.ErrorCode, FQEID);
                         }
diff --git a/src/System.Management.Automation/engine/remoting/commands/CustomShellCommands.cs b/src/System.Management.Automation/engine/remoting/commands/CustomShellCommands.cs
index aa90fca60..c29ff27c3 100644
--- a/src/System.Management.Automation/engine/remoting/commands/CustomShellCommands.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/CustomShellCommands.cs
@@ -459,9 +459,7 @@ else
             RemotingCommandUtil.CheckRemotingCmdletPrerequisites();
             PSSessionConfigurationCommandUtilities.ThrowIfNotAdministrator();
 
-            WSManConfigurationOption wsmanOption = transportOption as WSManConfigurationOption;
-
-            if (wsmanOption != null)
+            if (transportOption is WSManConfigurationOption wsmanOption)
             {
                 if (wsmanOption.ProcessIdleTimeoutSec != null && !isUseSharedProcessSpecified)
                 {
@@ -1331,8 +1329,8 @@ else
             whatIf = false;
             // confirm is always true to start with
             confirm = false;
-            MshCommandRuntime cmdRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-            if (cmdRuntime != null)
+
+            if (cmdlet.CommandRuntime is MshCommandRuntime cmdRuntime)
             {
                 whatIf = cmdRuntime.WhatIf;
                 // take the value of confirm only if it is explicitly set by the user
@@ -1413,16 +1411,14 @@ else
                 StringBuilder sb = new StringBuilder();
                 foreach (object s in modulePath)
                 {
-                    var module = s as string;
-                    if (module != null)
+                    if (s is string module)
                     {
                         sb.Append(s);
                         sb.Append(',');
                     }
                     else
                     {
-                        var moduleSpec = s as ModuleSpecification;
-                        if (moduleSpec != null)
+                        if (s is ModuleSpecification moduleSpec)
                         {
                             // Double escaping on ModuleSpecification string is required to treat it as a single value along with module names/paths in SessionConfigurationData
                             sb.Append(SecurityElement.Escape(SecurityElement.Escape(moduleSpec.ToString())));
@@ -1799,24 +1795,8 @@ else
             // Start of condition
             sb.Append(OpenParenChar);
 
-            // Logical keyname value can contain:
-            //  Single group name
-            //      @{ Or = 'Group1' }
-            //      (Member_of {SID(Group1)})
-            //  Multiple group names
-            //      @{ Or = 'Group1','Group2' }
-            //      (Member_of {SID(Group2)} || Member_of {SID(Group2)})
-            //  Single hash table
-            //      @{ Or = @{ And = 'Group1' } }
-            //      (Member_of {SID(Group1)})
-            //  Multiple hash table
-            //      @{ Or = @{ And = 'Group1','Group2' }, @{ And = 'Group3','Group4' } }
-            //      ((Member_of {SID(Group1)} && Member_of {SID(Group2)}) || (Member_of {SID(Group3)} && Member_of {SID(Group4)}))
-            //  Mixed
-            //      @{ Or = 'Group1', @{ And = 'Group2','Group3' } }
-            //      (Member_of {SID(Group1)} || (Member_of {SID(Group2)} && Member_of {SID(Group3)}))
-            object[] values = keyValue as object[];
-            if (values != null)
+            // Logical keyname value can contain:            //  Single group name            //      @{ Or = 'Group1' }            //      (Member_of {SID(Group1)})            //  Multiple group names            //      @{ Or = 'Group1','Group2' }            //      (Member_of {SID(Group2)} || Member_of {SID(Group2)})            //  Single hash table            //      @{ Or = @{ And = 'Group1' } }            //      (Member_of {SID(Group1)})            //  Multiple hash table            //      @{ Or = @{ And = 'Group1','Group2' }, @{ And = 'Group3','Group4' } }            //      ((Member_of {SID(Group1)} && Member_of {SID(Group2)}) || (Member_of {SID(Group3)} && Member_of {SID(Group4)}))            //  Mixed            //      @{ Or = 'Group1', @{ And = 'Group2','Group3' } }            //      (Member_of {SID(Group1)} || (Member_of {SID(Group2)} && Member_of {SID(Group3)}))
+            if (keyValue is object[] values)
             {
                 int count = values.Length;
                 for (int i = 0; i < count;)
@@ -1843,8 +1823,7 @@ else
             object inValue)
         {
             // Value to parse can be a single object or an array of objects
-            object[] values = inValue as object[];
-            if (values != null)
+            if (inValue is object[] values)
             {
                 foreach (object value in values)
                 {
@@ -1862,8 +1841,7 @@ else
             object value)
         {
             // Single value objects can be either a group name or a new logical hash table
-            string groupName = value as string;
-            if (groupName != null)
+            if (value is string groupName)
             {
                 // Resolve group name to SID
                 NTAccount ntAccount = new NTAccount(groupName);
@@ -1872,8 +1850,7 @@ else
             }
             else
             {
-                Hashtable recurseCondition = value as Hashtable;
-                if (recurseCondition != null)
+                if (value is Hashtable recurseCondition)
                 {
                     // Recurse to handle logical hash table
                     AddCondition(sb, recurseCondition);
diff --git a/src/System.Management.Automation/engine/remoting/commands/DebugJob.cs b/src/System.Management.Automation/engine/remoting/commands/DebugJob.cs
index 777f56807..453115326 100644
--- a/src/System.Management.Automation/engine/remoting/commands/DebugJob.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/DebugJob.cs
@@ -204,10 +204,7 @@ namespace Microsoft.PowerShell.Commands
 
             // Unblock the data collection.
             PSDataCollection<PSStreamObject> debugCollection = _debugCollection;
-            if (debugCollection != null)
-            {
-                debugCollection.Complete();
-            }
+            debugCollection?.Complete();
         }
 
         #endregion
@@ -261,10 +258,7 @@ namespace Microsoft.PowerShell.Commands
                 // or this command is cancelled.
                 foreach (var streamItem in _debugCollection)
                 {
-                    if (streamItem != null)
-                    {
-                        streamItem.WriteStreamObject(this);
-                    }
+                    streamItem?.WriteStreamObject(this);
                 }
             }
             catch (Exception)
@@ -297,8 +291,7 @@ namespace Microsoft.PowerShell.Commands
         {
             if (_debugCollection.IsOpen)
             {
-                PSStreamObject streamObject = dataAddingArgs.ItemAdded as PSStreamObject;
-                if (streamObject != null)
+                if (dataAddingArgs.ItemAdded is PSStreamObject streamObject)
                 {
                     try
                     {
diff --git a/src/System.Management.Automation/engine/remoting/commands/DisconnectPSSession.cs b/src/System.Management.Automation/engine/remoting/commands/DisconnectPSSession.cs
index 0e2458dab..6c749b433 100644
--- a/src/System.Management.Automation/engine/remoting/commands/DisconnectPSSession.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/DisconnectPSSession.cs
@@ -369,9 +369,8 @@ namespace Microsoft.PowerShell.Commands
 
             foreach (PSSession psSession in psSessions.Values)
             {
-                WSManConnectionInfo wsManConnectionInfo = psSession.Runspace.ConnectionInfo as WSManConnectionInfo;
 
-                if ((wsManConnectionInfo != null) && (wsManConnectionInfo.IsLocalhostAndNetworkAccess))
+                if ((psSession.Runspace.ConnectionInfo is WSManConnectionInfo wsManConnectionInfo) && (wsManConnectionInfo.IsLocalhostAndNetworkAccess))
                 {
                     sb.Append(psSession.Name + ", ");
                 }
diff --git a/src/System.Management.Automation/engine/remoting/commands/EnterPSHostProcessCommand.cs b/src/System.Management.Automation/engine/remoting/commands/EnterPSHostProcessCommand.cs
index 756250eb8..24ccea6eb 100644
--- a/src/System.Management.Automation/engine/remoting/commands/EnterPSHostProcessCommand.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/EnterPSHostProcessCommand.cs
@@ -212,10 +212,7 @@ namespace Microsoft.PowerShell.Commands
         protected override void StopProcessing()
         {
             RemoteRunspace connectingRunspace = _connectingRemoteRunspace;
-            if (connectingRunspace != null)
-            {
-                connectingRunspace.AbortOpen();
-            }
+            connectingRunspace?.AbortOpen();
         }
 
         #endregion
diff --git a/src/System.Management.Automation/engine/remoting/commands/InvokeCommandCommand.cs b/src/System.Management.Automation/engine/remoting/commands/InvokeCommandCommand.cs
index b60f3131f..5479d4686 100644
--- a/src/System.Management.Automation/engine/remoting/commands/InvokeCommandCommand.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/InvokeCommandCommand.cs
@@ -861,8 +861,7 @@ namespace Microsoft.PowerShell.Commands
                     else if (session.Runspace.RunspaceAvailability != RunspaceAvailability.Available)
                     {
                         // Check to see if this is a steppable pipeline case.
-                        RemoteRunspace remoteRunspace = session.Runspace as RemoteRunspace;
-                        if ((remoteRunspace != null) &&
+                        if ((session.Runspace is RemoteRunspace remoteRunspace) &&
                             (remoteRunspace.RunspaceAvailability == RunspaceAvailability.Busy) &&
                             (remoteRunspace.IsAnotherInvokeCommandExecuting(this, localPipelineId)))
                         {
@@ -974,12 +973,9 @@ namespace Microsoft.PowerShell.Commands
                         // cases. For ICM | % ICM case, we are using remote steppable pipeline.
                         if ((MyInvocation != null) && (MyInvocation.PipelinePosition == 1) && !MyInvocation.ExpectingInput)
                         {
-                            PSPrimitiveDictionary table = (object)runspaceInfo.ApplicationPrivateData[PSVersionInfo.PSVersionTableName] as PSPrimitiveDictionary;
-                            if (table != null)
+                            if ((object)runspaceInfo.ApplicationPrivateData[PSVersionInfo.PSVersionTableName] is PSPrimitiveDictionary table)
                             {
-                                Version version = (object)table[PSVersionInfo.PSRemotingProtocolVersionName] as Version;
-
-                                if (version != null)
+                                if ((object)table[PSVersionInfo.PSRemotingProtocolVersionName] is Version version)
                                 {
                                     // In order to support foreach remoting properly ( icm | % { icm } ), the server must
                                     // be using protocol version 2.2. Otherwise, we skip this and assume the old behavior.
@@ -1420,10 +1416,7 @@ namespace Microsoft.PowerShell.Commands
             operation.RunspaceDebugStop -= HandleRunspaceDebugStop;
 
             var hostDebugger = GetHostDebugger();
-            if (hostDebugger != null)
-            {
-                hostDebugger.QueueRunspaceForDebug(args.Runspace);
-            }
+            hostDebugger?.QueueRunspaceForDebug(args.Runspace);
         }
 
         private void HandleJobStateChanged(object sender, JobStateEventArgs e)
@@ -1440,10 +1433,7 @@ namespace Microsoft.PowerShell.Commands
                 // Signal that this job has been disconnected, or has ended.
                 lock (_jobSyncObject)
                 {
-                    if (_disconnectComplete != null)
-                    {
-                        _disconnectComplete.Set();
-                    }
+                    _disconnectComplete?.Set();
                 }
             }
         }
@@ -1557,15 +1547,14 @@ namespace Microsoft.PowerShell.Commands
                 else
                 {
                     object rsConnection = ps.GetRunspaceConnection();
-                    RunspacePool rsPool = rsConnection as RunspacePool;
-                    if (rsPool != null)
+
+                    if (rsConnection is RunspacePool rsPool)
                     {
                         oldRunspacePool = rsPool;
                     }
                     else
                     {
-                        RemoteRunspace remoteRs = rsConnection as RemoteRunspace;
-                        if (remoteRs != null)
+                        if (rsConnection is RemoteRunspace remoteRs)
                         {
                             oldRunspacePool = remoteRs.RunspacePool;
                         }
@@ -1748,8 +1737,7 @@ namespace Microsoft.PowerShell.Commands
                             // Write warnings to user about each disconnect.
                             foreach (var cjob in rtnJob.ChildJobs)
                             {
-                                PSRemotingChildJob childJob = cjob as PSRemotingChildJob;
-                                if (childJob != null)
+                                if (cjob is PSRemotingChildJob childJob)
                                 {
                                     // Get session for this job.
                                     PSSession session = GetPSSession(childJob.Runspace.InstanceId);
@@ -1956,18 +1944,16 @@ namespace Microsoft.PowerShell.Commands
         /// <param name="streamObject">Stream object to process.</param>
         private static void PreProcessStreamObject(PSStreamObject streamObject)
         {
-            ErrorRecord errorRecord = streamObject.Value as ErrorRecord;
 
             //
             // In case of PSDirectException, we should output the precise error message
             // in inner exception instead of the generic one in outer exception.
             //
-            if ((errorRecord != null) &&
+            if ((streamObject.Value is ErrorRecord errorRecord) &&
                 (errorRecord.Exception != null) &&
                 (errorRecord.Exception.InnerException != null))
             {
-                PSDirectException ex = errorRecord.Exception.InnerException as PSDirectException;
-                if (ex != null)
+                if (errorRecord.Exception.InnerException is PSDirectException ex)
                 {
                     streamObject.Value = new ErrorRecord(errorRecord.Exception.InnerException,
                                                          errorRecord.FullyQualifiedErrorId,
@@ -2047,11 +2033,7 @@ namespace Microsoft.PowerShell.Commands
 
                 if (!_asjob)
                 {
-                    if (_job != null)
-                    {
-                        // job will be null in the "InProcess" case
-                        _job.Dispose();
-                    }
+                    _job?.Dispose();
 
                     _throttleManager.ThrottleComplete -= HandleThrottleComplete;
                     _throttleManager.Dispose();
diff --git a/src/System.Management.Automation/engine/remoting/commands/NewPSSessionConfigurationFile.cs b/src/System.Management.Automation/engine/remoting/commands/NewPSSessionConfigurationFile.cs
index 56bd72e90..0482854f7 100644
--- a/src/System.Management.Automation/engine/remoting/commands/NewPSSessionConfigurationFile.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/NewPSSessionConfigurationFile.cs
@@ -1006,9 +1006,7 @@ namespace Microsoft.PowerShell.Commands
                 }
                 else
                 {
-                    string varString = _variableDefinitions as string;
-
-                    if (varString != null)
+                    if (_variableDefinitions is string varString)
                     {
                         result.Append(SessionConfigurationUtils.ConfigFragment(ConfigFileConstants.VariableDefinitions, RemotingErrorIdStrings.DISCVariableDefinitionsComment,
                             varString, streamWriter, false));
@@ -1750,9 +1748,7 @@ namespace Microsoft.PowerShell.Commands
                 }
                 else
                 {
-                    string varString = _variableDefinitions as string;
-
-                    if (varString != null)
+                    if (_variableDefinitions is string varString)
                     {
                         result.Append(SessionConfigurationUtils.ConfigFragment(ConfigFileConstants.VariableDefinitions, RemotingErrorIdStrings.DISCVariableDefinitionsComment,
                             varString, streamWriter, false));
@@ -1957,8 +1953,7 @@ namespace Microsoft.PowerShell.Commands
                     continue;
                 }
 
-                IDictionary tableValue = table[key] as IDictionary;
-                if (tableValue != null)
+                if (table[key] is IDictionary tableValue)
                 {
                     sb.Append(CombineHashtable(tableValue, writer, indent + 1));
                     continue;
@@ -2012,8 +2007,7 @@ namespace Microsoft.PowerShell.Commands
             sb.Append(QuoteName(key));
             sb.Append(" = ");
 
-            object[] values = keyObject as object[];
-            if (values != null)
+            if (keyObject is object[] values)
             {
                 for (int i = 0; i < values.Length;)
                 {
@@ -2037,15 +2031,13 @@ namespace Microsoft.PowerShell.Commands
 
         private static void WriteRequiredGroup(object value, StringBuilder sb)
         {
-            string strValue = value as string;
-            if (strValue != null)
+            if (value is string strValue)
             {
                 sb.Append(QuoteName(strValue));
             }
             else
             {
-                Hashtable subTable = value as Hashtable;
-                if (subTable != null)
+                if (value is Hashtable subTable)
                 {
                     sb.Append(CombineRequiredGroupsHash(subTable));
                 }
diff --git a/src/System.Management.Automation/engine/remoting/commands/PSRemotingCmdlet.cs b/src/System.Management.Automation/engine/remoting/commands/PSRemotingCmdlet.cs
index 9fafd34ee..1b2e21aa5 100644
--- a/src/System.Management.Automation/engine/remoting/commands/PSRemotingCmdlet.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/PSRemotingCmdlet.cs
@@ -3452,10 +3452,7 @@ namespace Microsoft.PowerShell.Commands
                     OperationState.StopComplete;
             operationStateEventArgs.BaseEvent = baseEventArgs;
 
-            if (OperationComplete != null)
-            {
-                OperationComplete.SafeInvoke(this, operationStateEventArgs);
-            }
+            OperationComplete?.SafeInvoke(this, operationStateEventArgs);
         }
     }
 
@@ -3650,10 +3647,7 @@ namespace Microsoft.PowerShell.Commands
                 case PipelineState.Completed:
                 case PipelineState.Stopped:
                 case PipelineState.Failed:
-                    if (RemoteRunspace != null)
-                    {
-                        RemoteRunspace.CloseAsync();
-                    }
+                    RemoteRunspace?.CloseAsync();
 
                     break;
             }
@@ -3936,8 +3930,7 @@ namespace Microsoft.PowerShell.Commands
                         if (shellUri != null)
                         {
                             // Compare with returned shell Uri in connection info.
-                            WSManConnectionInfo wsmanConnectionInfo = runspace.ConnectionInfo as WSManConnectionInfo;
-                            if (wsmanConnectionInfo != null &&
+                            if (runspace.ConnectionInfo is WSManConnectionInfo wsmanConnectionInfo &&
                                 !shellUri.Equals(wsmanConnectionInfo.ShellUri, StringComparison.OrdinalIgnoreCase))
                             {
                                 continue;
diff --git a/src/System.Management.Automation/engine/remoting/commands/PushRunspaceCommand.cs b/src/System.Management.Automation/engine/remoting/commands/PushRunspaceCommand.cs
index cbc5f8274..a734f5a4c 100644
--- a/src/System.Management.Automation/engine/remoting/commands/PushRunspaceCommand.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/PushRunspaceCommand.cs
@@ -245,17 +245,12 @@ namespace Microsoft.PowerShell.Commands
                         null));
                 return;
             }
-
-            // for the console host and Graphical PowerShell host
-            // we want to skip pushing into the the runspace if
-            // the host is in a nested prompt
-            System.Management.Automation.Internal.Host.InternalHost chost =
-                this.Host as System.Management.Automation.Internal.Host.InternalHost;
+            // for the console host and Graphical PowerShell host            // we want to skip pushing into the the runspace if            // the host is in a nested prompt
 
             if (!IsParameterSetForVM() &&
                 !IsParameterSetForContainer() &&
                 !IsParameterSetForVMContainerSession() &&
-                chost != null && chost.HostInNestedPrompt())
+                this.Host is System.Management.Automation.Internal.Host.InternalHost chost && chost.HostInNestedPrompt())
             {
                 ThrowTerminatingError(new ErrorRecord(
                     new InvalidOperationException(PSRemotingErrorInvariants.FormatResourceString(RemotingErrorIdStrings.HostInNestedPrompt)),
@@ -601,13 +596,9 @@ namespace Microsoft.PowerShell.Commands
         /// </summary>
         private void WriteErrorCreateRemoteRunspaceFailed(Exception exception, object argument)
         {
-            // set the transport message in the error detail so that
-            // the user can directly get to see the message without
-            // having to mine through the error record details
-            PSRemotingTransportException transException =
-                        exception as PSRemotingTransportException;
+            // set the transport message in the error detail so that            // the user can directly get to see the message without            // having to mine through the error record details
             string errorDetails = null;
-            if ((transException != null) &&
+            if ((exception is PSRemotingTransportException transException) &&
                 (transException.ErrorCode ==
                     System.Management.Automation.Remoting.Client.WSManNativeApi.ERROR_WSMAN_REDIRECT_REQUESTED))
             {
@@ -836,8 +827,7 @@ namespace Microsoft.PowerShell.Commands
                 {
                     PSRemotingChildJob remotingChildJob = childJob as PSRemotingChildJob;
 
-                    if (remotingChildJob != null &&
-                        remotingChildJob.Runspace != null &&
+                    if (remotingChildJob?.Runspace != null &&
                         remotingChildJob.JobStateInfo.State == JobState.Running &&
                         remotingChildJob.Runspace.InstanceId.Equals(id))
                     {
@@ -1326,9 +1316,7 @@ namespace Microsoft.PowerShell.Commands
 
         internal static void ContinueCommand(RemoteRunspace remoteRunspace, Pipeline cmd, PSHost host, bool inDebugMode, System.Management.Automation.ExecutionContext context)
         {
-            RemotePipeline remotePipeline = cmd as RemotePipeline;
-
-            if (remotePipeline != null)
+            if (cmd is RemotePipeline remotePipeline)
             {
                 using (System.Management.Automation.PowerShell ps = System.Management.Automation.PowerShell.Create())
                 {
@@ -1343,9 +1331,7 @@ namespace Microsoft.PowerShell.Commands
                     Command outDefaultCommand = new Command(commandInfo);
                     ps.AddCommand(outDefaultCommand);
                     IAsyncResult async = ps.BeginInvoke<PSObject>(input, settings, null, null);
-
-                    RemoteDebugger remoteDebugger = remoteRunspace.Debugger as RemoteDebugger;
-                    if (remoteDebugger != null)
+                    if (remoteRunspace.Debugger is RemoteDebugger remoteDebugger)
                     {
                         // Update client with breakpoint information from pushed runspace.
                         // Information will be passed to the client via the Debugger.BreakpointUpdated event.
diff --git a/src/System.Management.Automation/engine/remoting/commands/ReceiveJob.cs b/src/System.Management.Automation/engine/remoting/commands/ReceiveJob.cs
index 97585f1de..feab8399e 100644
--- a/src/System.Management.Automation/engine/remoting/commands/ReceiveJob.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/ReceiveJob.cs
@@ -709,11 +709,8 @@ namespace Microsoft.PowerShell.Commands
             // should be able to handle this
             if (job.ChildJobs.Count != 0) return;
 
-            // we have a better way of handling blocked state logic
-            // for remoting jobs, so use that if job is a remoting
-            // job
-            PSRemotingChildJob remotingChildJob = job as PSRemotingChildJob;
-            if (remotingChildJob != null)
+            // we have a better way of handling blocked state logic            // for remoting jobs, so use that if job is a remoting            // job
+            if (job is PSRemotingChildJob remotingChildJob)
             {
                 remotingChildJob.UnblockJob();
             }
@@ -753,8 +750,7 @@ namespace Microsoft.PowerShell.Commands
             // job is re-connected.
             if (job.JobStateInfo.State == JobState.Disconnected)
             {
-                PSRemotingChildJob remotingChildJob = job as PSRemotingChildJob;
-                if (remotingChildJob != null && remotingChildJob.DisconnectedAndBlocked)
+                if (job is PSRemotingChildJob remotingChildJob && remotingChildJob.DisconnectedAndBlocked)
                 {
                     return;
                 }
@@ -809,8 +805,8 @@ namespace Microsoft.PowerShell.Commands
                 foreach (ErrorRecord e in errorRecords)
                 {
                     if (e == null) continue;
-                    MshCommandRuntime mshCommandRuntime = CommandRuntime as MshCommandRuntime;
-                    if (mshCommandRuntime != null)
+
+                    if (CommandRuntime is MshCommandRuntime mshCommandRuntime)
                     {
                         e.PreserveInvocationInfoOnce = true;
                         mshCommandRuntime.WriteError(e, true);
@@ -822,11 +818,7 @@ namespace Microsoft.PowerShell.Commands
                 foreach (VerboseRecord v in verboseRecords)
                 {
                     if (v == null) continue;
-                    MshCommandRuntime mshCommandRuntime = CommandRuntime as MshCommandRuntime;
-                    if (mshCommandRuntime != null)
-                    {
-                        mshCommandRuntime.WriteVerbose(v, true);
-                    }
+                    mshCommandRuntime?.WriteVerbose(v, true);
                 }
 
                 Collection<DebugRecord> debugRecords = ReadAll(job.Debug);
@@ -834,11 +826,7 @@ namespace Microsoft.PowerShell.Commands
                 foreach (DebugRecord d in debugRecords)
                 {
                     if (d == null) continue;
-                    MshCommandRuntime mshCommandRuntime = CommandRuntime as MshCommandRuntime;
-                    if (mshCommandRuntime != null)
-                    {
-                        mshCommandRuntime.WriteDebug(d, true);
-                    }
+                    mshCommandRuntime?.WriteDebug(d, true);
                 }
 
                 Collection<WarningRecord> warningRecords = ReadAll(job.Warning);
@@ -846,11 +834,7 @@ namespace Microsoft.PowerShell.Commands
                 foreach (WarningRecord w in warningRecords)
                 {
                     if (w == null) continue;
-                    MshCommandRuntime mshCommandRuntime = CommandRuntime as MshCommandRuntime;
-                    if (mshCommandRuntime != null)
-                    {
-                        mshCommandRuntime.WriteWarning(w, true);
-                    }
+                    mshCommandRuntime?.WriteWarning(w, true);
                 }
 
                 Collection<ProgressRecord> progressRecords = ReadAll(job.Progress);
@@ -858,11 +842,7 @@ namespace Microsoft.PowerShell.Commands
                 foreach (ProgressRecord p in progressRecords)
                 {
                     if (p == null) continue;
-                    MshCommandRuntime mshCommandRuntime = CommandRuntime as MshCommandRuntime;
-                    if (mshCommandRuntime != null)
-                    {
-                        mshCommandRuntime.WriteProgress(p, true);
-                    }
+                    mshCommandRuntime?.WriteProgress(p, true);
                 }
 
                 Collection<InformationRecord> informationRecords = ReadAll(job.Information);
@@ -870,11 +850,7 @@ namespace Microsoft.PowerShell.Commands
                 foreach (InformationRecord p in informationRecords)
                 {
                     if (p == null) continue;
-                    MshCommandRuntime mshCommandRuntime = CommandRuntime as MshCommandRuntime;
-                    if (mshCommandRuntime != null)
-                    {
-                        mshCommandRuntime.WriteInformation(p, true);
-                    }
+                    mshCommandRuntime?.WriteInformation(p, true);
                 }
             }
 
@@ -887,7 +863,7 @@ namespace Microsoft.PowerShell.Commands
         {
             // Write better error for the remoting case and generic error for the other case
             PSRemotingChildJob child = job as PSRemotingChildJob;
-            if (child != null && child.FailureErrorRecord != null)
+            if (child?.FailureErrorRecord != null)
             {
                 _results.Add(new PSStreamObject(PSStreamObjectType.Error, child.FailureErrorRecord, child.InstanceId));
             }
@@ -896,10 +872,8 @@ namespace Microsoft.PowerShell.Commands
                 Exception baseReason = job.JobStateInfo.Reason;
                 Exception resultReason = baseReason;
 
-                // If it was generated by a job that gave location information, unpack the
-                // base exception.
-                JobFailedException exceptionWithLocation = baseReason as JobFailedException;
-                if (exceptionWithLocation != null)
+                // If it was generated by a job that gave location information, unpack the                // base exception.
+                if (baseReason is JobFailedException exceptionWithLocation)
                 {
                     resultReason = exceptionWithLocation.Reason;
                 }
@@ -908,7 +882,7 @@ namespace Microsoft.PowerShell.Commands
 
                 // If it was generated by a job that gave location information, set the
                 // location information.
-                if ((exceptionWithLocation != null) && (exceptionWithLocation.DisplayScriptPosition != null))
+                if ((baseReason is JobFailedException exceptionWithLocation) && (exceptionWithLocation.DisplayScriptPosition != null))
                 {
                     if (errorRecord.InvocationInfo == null)
                     {
@@ -1412,8 +1386,7 @@ namespace Microsoft.PowerShell.Commands
                                      "Job has data and is being removed.");
             }
 
-            Job2 job2 = job as Job2;
-            if (job2 != null)
+            if (job is Job2 job2)
             {
 #pragma warning disable 56500
                 try
diff --git a/src/System.Management.Automation/engine/remoting/commands/ReceivePSSession.cs b/src/System.Management.Automation/engine/remoting/commands/ReceivePSSession.cs
index 12cced4ae..4f3691415 100644
--- a/src/System.Management.Automation/engine/remoting/commands/ReceivePSSession.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/ReceivePSSession.cs
@@ -389,15 +389,9 @@ namespace Microsoft.PowerShell.Commands
                 tmpJob = _job;
             }
 
-            if (tmpPipeline != null)
-            {
-                tmpPipeline.StopAsync();
-            }
+            tmpPipeline?.StopAsync();
 
-            if (tmpJob != null)
-            {
-                tmpJob.StopJob();
-            }
+            tmpJob?.StopJob();
         }
 
         #endregion
@@ -456,8 +450,7 @@ namespace Microsoft.PowerShell.Commands
                 if (shellUri != null)
                 {
                     // Compare with returned shell Uri in connection info.
-                    WSManConnectionInfo wsmanConnectionInfo = runspace.ConnectionInfo as WSManConnectionInfo;
-                    if (wsmanConnectionInfo != null &&
+                    if (runspace.ConnectionInfo is WSManConnectionInfo wsmanConnectionInfo &&
                         !shellUri.Equals(wsmanConnectionInfo.ShellUri, StringComparison.OrdinalIgnoreCase))
                     {
                         continue;
@@ -812,10 +805,7 @@ namespace Microsoft.PowerShell.Commands
                     catch (ObjectDisposedException) { }
                 }
 
-                if (job != null)
-                {
-                    job.StopJob();
-                }
+                job?.StopJob();
             }
         }
 
@@ -861,10 +851,7 @@ namespace Microsoft.PowerShell.Commands
 
                         foreach (var result in childJob.ReadAll())
                         {
-                            if (result != null)
-                            {
-                                result.WriteStreamObject(this);
-                            }
+                            result?.WriteStreamObject(this);
                         }
 
                         if (index == 0)
@@ -960,17 +947,16 @@ namespace Microsoft.PowerShell.Commands
                         while (!_remotePipeline.Error.EndOfPipeline)
                         {
                             object errorObj = _remotePipeline.Error.Read();
-                            if (errorObj is Collection<ErrorRecord>)
+                            if (errorObj is Collection<ErrorRecord> errorCollection)
                             {
-                                Collection<ErrorRecord> errorCollection = (Collection<ErrorRecord>)errorObj;
                                 foreach (ErrorRecord errorRecord in errorCollection)
                                 {
                                     WriteError(errorRecord);
                                 }
                             }
-                            else if (errorObj is ErrorRecord)
+                            else if (errorObj is ErrorRecord errorRecord)
                             {
-                                WriteError((ErrorRecord)errorObj);
+                                WriteError(errorRecord);
                             }
                             else
                             {
@@ -1195,8 +1181,7 @@ namespace Microsoft.PowerShell.Commands
             PSRemotingJob job = null;
             RemoteRunspace remoteSessionRunspace = session.Runspace as RemoteRunspace;
 
-            if (remoteSessionRunspace == null ||
-                remoteSessionRunspace.RemoteCommand != null)
+            if (remoteSessionRunspace?.RemoteCommand != null)
             {
                 // The provided session is created for *reconstruction* and we
                 // cannot connect a previous job even if one exists.  A new job
@@ -1206,14 +1191,14 @@ namespace Microsoft.PowerShell.Commands
 
             foreach (Job repJob in this.JobRepository.Jobs)
             {
-                if (repJob is PSRemotingJob)
+                if (repJob is PSRemotingJob pSRemotingJob)
                 {
                     foreach (PSRemotingChildJob childJob in repJob.ChildJobs)
                     {
                         if (childJob.Runspace.InstanceId.Equals(session.InstanceId) &&
                             (childJob.JobStateInfo.State == JobState.Disconnected))
                         {
-                            job = (PSRemotingJob)repJob;
+                            job = pSRemotingJob;
                             break;
                         }
                     }
diff --git a/src/System.Management.Automation/engine/remoting/commands/newrunspacecommand.cs b/src/System.Management.Automation/engine/remoting/commands/newrunspacecommand.cs
index 625bb86fd..57ace6d82 100644
--- a/src/System.Management.Automation/engine/remoting/commands/newrunspacecommand.cs
+++ b/src/System.Management.Automation/engine/remoting/commands/newrunspacecommand.cs
@@ -461,21 +461,14 @@ namespace Microsoft.PowerShell.Commands
 
                 case RunspaceState.Broken:
                     {
-                        // Open resulted in a broken state. Extract reason
-                        // and write an error record
-
-                        // set the transport message in the error detail so that
-                        // the user can directly get to see the message without
-                        // having to mine through the error record details
-                        PSRemotingTransportException transException =
-                            reason as PSRemotingTransportException;
+                        // Open resulted in a broken state. Extract reason                        // and write an error record                        // set the transport message in the error detail so that                        // the user can directly get to see the message without                        // having to mine through the error record details
                         string errorDetails = null;
                         int transErrorCode = 0;
-                        if (transException != null)
+
+                        if (reason is PSRemotingTransportException transException)
                         {
-                            OpenRunspaceOperation senderAsOp = sender as OpenRunspaceOperation;
                             transErrorCode = transException.ErrorCode;
-                            if (senderAsOp != null)
+                            if (sender is OpenRunspaceOperation senderAsOp)
                             {
                                 string host = senderAsOp.OperatedRunspace.ConnectionInfo.ComputerName;
 
@@ -510,13 +503,11 @@ namespace Microsoft.PowerShell.Commands
                         }
 
                         // add host identification information in data structure handler message
-                        PSRemotingDataStructureException protoException = reason as PSRemotingDataStructureException;
 
-                        if (protoException != null)
+                        if (reason is PSRemotingDataStructureException protoException)
                         {
-                            OpenRunspaceOperation senderAsOp = sender as OpenRunspaceOperation;
 
-                            if (senderAsOp != null)
+                            if (sender is OpenRunspaceOperation senderAsOp)
                             {
                                 string host = senderAsOp.OperatedRunspace.ConnectionInfo.ComputerName;
 
@@ -552,8 +543,7 @@ namespace Microsoft.PowerShell.Commands
                             if ((errorRecord.Exception != null) &&
                                 (errorRecord.Exception.InnerException != null))
                             {
-                                PSDirectException ex = errorRecord.Exception.InnerException as PSDirectException;
-                                if (ex != null)
+                                if (errorRecord.Exception.InnerException is PSDirectException ex)
                                 {
                                     errorRecord = new ErrorRecord(errorRecord.Exception.InnerException,
                                                                   errorRecord.FullyQualifiedErrorId,
@@ -658,10 +648,9 @@ namespace Microsoft.PowerShell.Commands
                         else
                         {
                             // WSMan case
-                            WSManConnectionInfo originalWSManConnectionInfo = remoteRunspace.ConnectionInfo as WSManConnectionInfo;
                             WSManConnectionInfo newWSManConnectionInfo = null;
 
-                            if (originalWSManConnectionInfo != null)
+                            if (remoteRunspace.ConnectionInfo is WSManConnectionInfo originalWSManConnectionInfo)
                             {
                                 newWSManConnectionInfo = originalWSManConnectionInfo.Copy();
                                 newWSManConnectionInfo.EnableNetworkAccess = newWSManConnectionInfo.EnableNetworkAccess || EnableNetworkAccess;
diff --git a/src/System.Management.Automation/engine/remoting/common/RemoteSessionNamedPipe.cs b/src/System.Management.Automation/engine/remoting/common/RemoteSessionNamedPipe.cs
index 7593bbcc3..8ce99965d 100644
--- a/src/System.Management.Automation/engine/remoting/common/RemoteSessionNamedPipe.cs
+++ b/src/System.Management.Automation/engine/remoting/common/RemoteSessionNamedPipe.cs
@@ -1101,10 +1101,7 @@ namespace System.Management.Automation.Remoting
         /// </summary>
         public void Close()
         {
-            if (_clientPipeStream != null)
-            {
-                _clientPipeStream.Dispose();
-            }
+            _clientPipeStream?.Dispose();
         }
 
         public virtual void AbortConnect()
diff --git a/src/System.Management.Automation/engine/remoting/common/RunspaceConnectionInfo.cs b/src/System.Management.Automation/engine/remoting/common/RunspaceConnectionInfo.cs
index ea8a9c1a9..98225f556 100644
--- a/src/System.Management.Automation/engine/remoting/common/RunspaceConnectionInfo.cs
+++ b/src/System.Management.Automation/engine/remoting/common/RunspaceConnectionInfo.cs
@@ -2110,8 +2110,7 @@ namespace System.Management.Automation.Runspaces
             var context = Runspaces.LocalPipeline.GetExecutionContextFromTLS();
             if (context != null)
             {
-                var cmdInfo = context.CommandDiscovery.LookupCommandInfo(sshCommand, CommandOrigin.Internal) as ApplicationInfo;
-                if (cmdInfo != null)
+                if (context.CommandDiscovery.LookupCommandInfo(sshCommand, CommandOrigin.Internal) is ApplicationInfo cmdInfo)
                 {
                     filePath = cmdInfo.Path;
                 }
@@ -2580,17 +2579,17 @@ namespace System.Management.Automation.Runspaces
             }
             catch (Exception)
             {
-                if (stdInPipeServer != null) { stdInPipeServer.Dispose(); }
+                stdInPipeServer?.Dispose();
 
-                if (stdInPipeClient != null) { stdInPipeClient.Dispose(); }
+                stdInPipeClient?.Dispose();
 
-                if (stdOutPipeServer != null) { stdOutPipeServer.Dispose(); }
+                stdOutPipeServer?.Dispose();
 
-                if (stdOutPipeClient != null) { stdOutPipeClient.Dispose(); }
+                stdOutPipeClient?.Dispose();
 
-                if (stdErrPipeServer != null) { stdErrPipeServer.Dispose(); }
+                stdErrPipeServer?.Dispose();
 
-                if (stdErrPipeClient != null) { stdErrPipeClient.Dispose(); }
+                stdErrPipeClient?.Dispose();
 
                 throw;
             }
@@ -2656,17 +2655,17 @@ namespace System.Management.Automation.Runspaces
             }
             catch (Exception)
             {
-                if (stdInPipeServer != null) { stdInPipeServer.Dispose(); }
+                stdInPipeServer?.Dispose();
 
-                if (stdInPipeClient != null) { stdInPipeClient.Dispose(); }
+                stdInPipeClient?.Dispose();
 
-                if (stdOutPipeServer != null) { stdOutPipeServer.Dispose(); }
+                stdOutPipeServer?.Dispose();
 
-                if (stdOutPipeClient != null) { stdOutPipeClient.Dispose(); }
+                stdOutPipeClient?.Dispose();
 
-                if (stdErrPipeServer != null) { stdErrPipeServer.Dispose(); }
+                stdErrPipeServer?.Dispose();
 
-                if (stdErrPipeClient != null) { stdErrPipeClient.Dispose(); }
+                stdErrPipeClient?.Dispose();
 
                 throw;
             }
diff --git a/src/System.Management.Automation/engine/remoting/common/WireDataFormat/EncodeAndDecode.cs b/src/System.Management.Automation/engine/remoting/common/WireDataFormat/EncodeAndDecode.cs
index d99fbe211..1db3cd604 100644
--- a/src/System.Management.Automation/engine/remoting/common/WireDataFormat/EncodeAndDecode.cs
+++ b/src/System.Management.Automation/engine/remoting/common/WireDataFormat/EncodeAndDecode.cs
@@ -1277,7 +1277,7 @@ namespace System.Management.Automation
         /// <returns>PS remoting protocol version.</returns>
         internal static Version GetPSRemotingProtocolVersion(RunspacePool rsPool)
         {
-            return (rsPool != null && rsPool.RemoteRunspacePoolInternal != null) ?
+            return (rsPool?.RemoteRunspacePoolInternal != null) ?
                 rsPool.RemoteRunspacePoolInternal.PSRemotingProtocolVersion : null;
         }
 
@@ -1546,8 +1546,8 @@ namespace System.Management.Automation
             Dbg.Assert(exception != null, "Caller should validate the data");
 
             ErrorRecord er = null;
-            IContainsErrorRecord cer = exception as IContainsErrorRecord;
-            if (cer != null)
+
+            if (exception is IContainsErrorRecord cer)
             {
                 er = cer.ErrorRecord;
                 // Exception inside the error record is ParentContainsErrorRecordException which
@@ -1643,11 +1643,10 @@ namespace System.Management.Automation
 
             if (typeof(T).IsEnum)
             {
-                if (propertyValue is string)
+                if (propertyValue is string stringValue)
                 {
                     try
                     {
-                        string stringValue = (string)propertyValue;
                         T value = (T)Enum.Parse(typeof(T), stringValue, true);
                         return value;
                     }
@@ -1710,9 +1709,8 @@ namespace System.Management.Automation
             {
                 return (T)(propertyValue);
             }
-            else if (propertyValue is PSObject)
+            else if (propertyValue is PSObject psObject)
             {
-                PSObject psObject = (PSObject)propertyValue;
                 return ConvertPropertyValueTo<T>(propertyName, psObject.BaseObject);
             }
             else if ((propertyValue is Hashtable) && (typeof(T).Equals(typeof(PSPrimitiveDictionary))))
@@ -2042,7 +2040,7 @@ namespace System.Management.Automation
         {
             // Check if exception is encoded as errorrecord
             PSPropertyInfo property = stateInfo.Properties[RemoteDataNameStrings.ExceptionAsErrorRecord];
-            if (property != null && property.Value != null)
+            if (property?.Value != null)
             {
                 return GetExceptionFromSerializedErrorRecord(property.Value);
             }
diff --git a/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteHost.cs b/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteHost.cs
index c29be1348..79b920c22 100644
--- a/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteHost.cs
+++ b/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteHost.cs
@@ -188,10 +188,7 @@ namespace System.Management.Automation.Remoting
             }
             finally
             {
-                if (remoteRunspaceToClose != null)
-                {
-                    remoteRunspaceToClose.Close();
-                }
+                remoteRunspaceToClose?.Close();
             }
         }
 
diff --git a/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteHostEncoder.cs b/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteHostEncoder.cs
index 3ffc278a8..01a84d7f3 100644
--- a/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteHostEncoder.cs
+++ b/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteHostEncoder.cs
@@ -324,14 +324,14 @@ namespace System.Management.Automation.Remoting
             }
 
             Type type = obj.GetType();
-            if (obj is PSObject)
+            if (obj is PSObject pSObject)
             {
                 // The "is" keyword takes care of PSObject and subclasses.
-                return EncodePSObject((PSObject)obj);
+                return EncodePSObject(pSObject);
             }
-            else if (obj is ProgressRecord)
+            else if (obj is ProgressRecord progressRecord)
             {
-                return ((ProgressRecord)obj).ToPSObjectForRemoting();
+                return progressRecord.ToPSObjectForRemoting();
             }
             else if (IsKnownType(type))
             {
@@ -346,9 +346,9 @@ namespace System.Management.Automation.Remoting
                 // The "is" keyword takes care of CultureInfo and subclasses.
                 return obj.ToString();
             }
-            else if (obj is Exception)
+            else if (obj is Exception exception)
             {
-                return EncodeException((Exception)obj);
+                return EncodeException(exception);
             }
             else if (type == typeof(object[]))
             {
@@ -376,13 +376,13 @@ namespace System.Management.Automation.Remoting
             {
                 return EncodeClassOrStruct(obj);
             }
-            else if (obj is RemoteHostCall)
+            else if (obj is RemoteHostCall remoteHostCall)
             {
-                return ((RemoteHostCall)obj).Encode();
+                return remoteHostCall.Encode();
             }
-            else if (obj is RemoteHostResponse)
+            else if (obj is RemoteHostResponse remoteHostResponse)
             {
-                return ((RemoteHostResponse)obj).Encode();
+                return remoteHostResponse.Encode();
             }
             else if (obj is SecureString)
             {
diff --git a/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteSessionCapability.cs b/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteSessionCapability.cs
index 0cddf7d85..ab600db6f 100644
--- a/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteSessionCapability.cs
+++ b/src/System.Management.Automation/engine/remoting/common/WireDataFormat/RemoteSessionCapability.cs
@@ -438,10 +438,10 @@ namespace System.Management.Automation.Remoting
                 // If host is null then the bools are correct. Nothing further to do here.
                 return;
             }
-            else if (host is InternalHost)
+            else if (host is InternalHost internalHost)
             {
                 // This nesting can only be one level deep.
-                host = ((InternalHost)host).ExternalHost;
+                host = internalHost.ExternalHost;
             }
 
             // At this point we know for sure that the host is not null.
diff --git a/src/System.Management.Automation/engine/remoting/common/psstreamobject.cs b/src/System.Management.Automation/engine/remoting/common/psstreamobject.cs
index 4e7558938..cc8dd0eb0 100644
--- a/src/System.Management.Automation/engine/remoting/common/psstreamobject.cs
+++ b/src/System.Management.Automation/engine/remoting/common/psstreamobject.cs
@@ -120,10 +120,7 @@ namespace System.Management.Automation.Remoting.Internal
                             ErrorRecord errorRecord = (ErrorRecord)this.Value;
                             errorRecord.PreserveInvocationInfoOnce = true;
                             MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                            if (mshCommandRuntime != null)
-                            {
-                                mshCommandRuntime.WriteError(errorRecord, overrideInquire);
-                            }
+                            mshCommandRuntime?.WriteError(errorRecord, overrideInquire);
                         }
 
                         break;
@@ -133,10 +130,7 @@ namespace System.Management.Automation.Remoting.Internal
                             string debug = (string)Value;
                             DebugRecord debugRecord = new DebugRecord(debug);
                             MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                            if (mshCommandRuntime != null)
-                            {
-                                mshCommandRuntime.WriteDebug(debugRecord, overrideInquire);
-                            }
+                            mshCommandRuntime?.WriteDebug(debugRecord, overrideInquire);
                         }
 
                         break;
@@ -146,10 +140,7 @@ namespace System.Management.Automation.Remoting.Internal
                             string warning = (string)Value;
                             WarningRecord warningRecord = new WarningRecord(warning);
                             MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                            if (mshCommandRuntime != null)
-                            {
-                                mshCommandRuntime.WriteWarning(warningRecord, overrideInquire);
-                            }
+                            mshCommandRuntime?.WriteWarning(warningRecord, overrideInquire);
                         }
 
                         break;
@@ -159,10 +150,7 @@ namespace System.Management.Automation.Remoting.Internal
                             string verbose = (string)Value;
                             VerboseRecord verboseRecord = new VerboseRecord(verbose);
                             MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                            if (mshCommandRuntime != null)
-                            {
-                                mshCommandRuntime.WriteVerbose(verboseRecord, overrideInquire);
-                            }
+                            mshCommandRuntime?.WriteVerbose(verboseRecord, overrideInquire);
                         }
 
                         break;
@@ -170,10 +158,7 @@ namespace System.Management.Automation.Remoting.Internal
                     case PSStreamObjectType.Progress:
                         {
                             MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                            if (mshCommandRuntime != null)
-                            {
-                                mshCommandRuntime.WriteProgress((ProgressRecord)Value, overrideInquire);
-                            }
+                            mshCommandRuntime?.WriteProgress((ProgressRecord)Value, overrideInquire);
                         }
 
                         break;
@@ -181,10 +166,7 @@ namespace System.Management.Automation.Remoting.Internal
                     case PSStreamObjectType.Information:
                         {
                             MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                            if (mshCommandRuntime != null)
-                            {
-                                mshCommandRuntime.WriteInformation((InformationRecord)Value, overrideInquire);
-                            }
+                            mshCommandRuntime?.WriteInformation((InformationRecord)Value, overrideInquire);
                         }
 
                         break;
@@ -193,10 +175,7 @@ namespace System.Management.Automation.Remoting.Internal
                         {
                             WarningRecord warningRecord = (WarningRecord)Value;
                             MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                            if (mshCommandRuntime != null)
-                            {
-                                mshCommandRuntime.AppendWarningVarList(warningRecord);
-                            }
+                            mshCommandRuntime?.AppendWarningVarList(warningRecord);
                         }
 
                         break;
@@ -273,8 +252,7 @@ namespace System.Management.Automation.Remoting.Internal
                     {
                         if (instanceId != Guid.Empty)
                         {
-                            PSObject o = Value as PSObject;
-                            if (o != null)
+                            if (Value is PSObject o)
                                 AddSourceJobNoteProperty(o, instanceId);
                         }
 
@@ -311,10 +289,7 @@ namespace System.Management.Automation.Remoting.Internal
 
                         errorRecord.PreserveInvocationInfoOnce = true;
                         MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                        if (mshCommandRuntime != null)
-                        {
-                            mshCommandRuntime.WriteError(errorRecord, overrideInquire);
-                        }
+                        mshCommandRuntime?.WriteError(errorRecord, overrideInquire);
                     }
 
                     break;
@@ -324,10 +299,7 @@ namespace System.Management.Automation.Remoting.Internal
                         string warning = (string)Value;
                         WarningRecord warningRecord = new WarningRecord(warning);
                         MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                        if (mshCommandRuntime != null)
-                        {
-                            mshCommandRuntime.WriteWarning(warningRecord, overrideInquire);
-                        }
+                        mshCommandRuntime?.WriteWarning(warningRecord, overrideInquire);
                     }
 
                     break;
@@ -337,10 +309,7 @@ namespace System.Management.Automation.Remoting.Internal
                         string verbose = (string)Value;
                         VerboseRecord verboseRecord = new VerboseRecord(verbose);
                         MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                        if (mshCommandRuntime != null)
-                        {
-                            mshCommandRuntime.WriteVerbose(verboseRecord, overrideInquire);
-                        }
+                        mshCommandRuntime?.WriteVerbose(verboseRecord, overrideInquire);
                     }
 
                     break;
@@ -365,10 +334,7 @@ namespace System.Management.Automation.Remoting.Internal
                         }
 
                         MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                        if (mshCommandRuntime != null)
-                        {
-                            mshCommandRuntime.WriteProgress(progressRecord, overrideInquire);
-                        }
+                        mshCommandRuntime?.WriteProgress(progressRecord, overrideInquire);
                     }
 
                     break;
@@ -378,10 +344,7 @@ namespace System.Management.Automation.Remoting.Internal
                         string debug = (string)Value;
                         DebugRecord debugRecord = new DebugRecord(debug);
                         MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                        if (mshCommandRuntime != null)
-                        {
-                            mshCommandRuntime.WriteDebug(debugRecord, overrideInquire);
-                        }
+                        mshCommandRuntime?.WriteDebug(debugRecord, overrideInquire);
                     }
 
                     break;
@@ -411,10 +374,7 @@ namespace System.Management.Automation.Remoting.Internal
                         }
 
                         MshCommandRuntime mshCommandRuntime = cmdlet.CommandRuntime as MshCommandRuntime;
-                        if (mshCommandRuntime != null)
-                        {
-                            mshCommandRuntime.WriteInformation(informationRecord, overrideInquire);
-                        }
+                        mshCommandRuntime?.WriteInformation(informationRecord, overrideInquire);
                     }
 
                     break;
diff --git a/src/System.Management.Automation/engine/remoting/common/throttlemanager.cs b/src/System.Management.Automation/engine/remoting/common/throttlemanager.cs
index afccc2836..fca2bf15c 100644
--- a/src/System.Management.Automation/engine/remoting/common/throttlemanager.cs
+++ b/src/System.Management.Automation/engine/remoting/common/throttlemanager.cs
@@ -532,10 +532,7 @@ namespace System.Management.Automation.Remoting
                 }
             }
 
-            if (operation != null)
-            {
-                operation.StartOperation();
-            }
+            operation?.StartOperation();
         }
 
         /// <summary>
diff --git a/src/System.Management.Automation/engine/remoting/fanin/InitialSessionStateProvider.cs b/src/System.Management.Automation/engine/remoting/fanin/InitialSessionStateProvider.cs
index 6cde06cea..e41da1940 100644
--- a/src/System.Management.Automation/engine/remoting/fanin/InitialSessionStateProvider.cs
+++ b/src/System.Management.Automation/engine/remoting/fanin/InitialSessionStateProvider.cs
@@ -824,12 +824,11 @@ namespace System.Management.Automation.Remoting
 
             InitialSessionState sessionState = InitialSessionState.CreateDefault2();
             // now get all the modules in the specified path and import the same
-            if (sessionConfigurationData != null && sessionConfigurationData.ModulesToImportInternal != null)
+            if (sessionConfigurationData?.ModulesToImportInternal != null)
             {
                 foreach (var module in sessionConfigurationData.ModulesToImportInternal)
                 {
-                    var moduleName = module as string;
-                    if (moduleName != null)
+                    if (module is string moduleName)
                     {
                         moduleName = Environment.ExpandEnvironmentVariables(moduleName);
 
@@ -837,8 +836,7 @@ namespace System.Management.Automation.Remoting
                     }
                     else
                     {
-                        var moduleSpec = module as ModuleSpecification;
-                        if (moduleSpec != null)
+                        if (module is ModuleSpecification moduleSpec)
                         {
                             var modulesToImport = new Collection<ModuleSpecification> { moduleSpec };
                             sessionState.ImportPSModule(modulesToImport);
@@ -2066,8 +2064,7 @@ namespace System.Management.Automation.Remoting
                         }
                         else
                         {
-                            Hashtable moduleHash = module as Hashtable;
-                            if (moduleHash != null)
+                            if (module is Hashtable moduleHash)
                             {
                                 moduleSpec = new ModuleSpecification(moduleHash);
                             }
@@ -2473,11 +2470,8 @@ namespace System.Management.Automation.Remoting
                 }
                 else
                 {
-                    // If it's a hashtable, it represents a customization to a cmdlet.
-                    // (I.e.: Exposed parameter with ValidateSet and / or ValidatePattern)
-                    // Collect these so that we can post-process them.
-                    IDictionary commandModification = commandObject as IDictionary;
-                    if (commandModification != null)
+                    // If it's a hashtable, it represents a customization to a cmdlet.                    // (I.e.: Exposed parameter with ValidateSet and / or ValidatePattern)                    // Collect these so that we can post-process them.
+                    if (commandObject is IDictionary commandModification)
                     {
                         ProcessCommandModification(commandModifications, commandModification);
                     }
@@ -2783,9 +2777,8 @@ namespace System.Management.Automation.Remoting
         internal static Hashtable[] TryGetHashtableArray(object hashObj)
         {
             // Scalar case
-            Hashtable hashtable = hashObj as Hashtable;
 
-            if (hashtable != null)
+            if (hashObj is Hashtable hashtable)
             {
                 return new[] { hashtable };
             }
@@ -2796,9 +2789,8 @@ namespace System.Management.Automation.Remoting
             if (hashArray == null)
             {
                 // 2. Convert from object array
-                object[] objArray = hashObj as object[];
 
-                if (objArray != null)
+                if (hashObj is object[] objArray)
                 {
                     hashArray = new Hashtable[objArray.Length];
 
@@ -2829,9 +2821,8 @@ namespace System.Management.Automation.Remoting
             if (objs == null)
             {
                 // Scalar case
-                object obj = hashObj as object;
 
-                if (obj != null)
+                if (hashObj is object obj)
                 {
                     return new string[] { obj.ToString() };
                 }
diff --git a/src/System.Management.Automation/engine/remoting/fanin/OutOfProcTransportManager.cs b/src/System.Management.Automation/engine/remoting/fanin/OutOfProcTransportManager.cs
index b8f6da13c..75cc62ae1 100644
--- a/src/System.Management.Automation/engine/remoting/fanin/OutOfProcTransportManager.cs
+++ b/src/System.Management.Automation/engine/remoting/fanin/OutOfProcTransportManager.cs
@@ -931,13 +931,7 @@ namespace System.Management.Automation.Remoting.Client
             {
                 // this is for a command
                 OutOfProcessClientCommandTransportManager cmdTM = GetCommandTransportManager(psGuid);
-                if (cmdTM != null)
-                {
-                    // not throwing the exception in null case as the command might have already
-                    // closed. The RS data structure handler does not wait for the close ack before
-                    // it clears the command transport manager..so this might happen.
-                    cmdTM.OnRemoteCmdDataReceived(rawData, streamTemp);
-                }
+                cmdTM?.OnRemoteCmdDataReceived(rawData, streamTemp);
             }
         }
 
@@ -952,13 +946,7 @@ namespace System.Management.Automation.Remoting.Client
             {
                 // this is for a command
                 OutOfProcessClientCommandTransportManager cmdTM = GetCommandTransportManager(psGuid);
-                if (cmdTM != null)
-                {
-                    // not throwing the exception in null case as the command might have already
-                    // closed. The RS data structure handler does not wait for the close ack before
-                    // it clears the command transport manager..so this might happen.
-                    cmdTM.OnRemoteCmdSendCompleted();
-                }
+                cmdTM?.OnRemoteCmdSendCompleted();
             }
         }
 
@@ -1002,10 +990,7 @@ namespace System.Management.Automation.Remoting.Client
             else
             {
                 OutOfProcessClientCommandTransportManager cmdTM = GetCommandTransportManager(psGuid);
-                if (cmdTM != null)
-                {
-                    cmdTM.OnRemoteCmdSignalCompleted();
-                }
+                cmdTM?.OnRemoteCmdSignalCompleted();
             }
         }
 
@@ -1035,12 +1020,7 @@ namespace System.Management.Automation.Remoting.Client
                 _tracer.WriteMessage("OutOfProcessClientSessionTransportManager.OnCloseAckReceived, in progress command count should be greater than zero: " + commandCount + ", RunSpacePool Id : " + this.RunspacePoolInstanceId + ", psGuid : " + psGuid.ToString());
 
                 OutOfProcessClientCommandTransportManager cmdTM = GetCommandTransportManager(psGuid);
-                if (cmdTM != null)
-                {
-                    // this might legitimately happen if cmd is already closed before we get an
-                    // ACK back from server.
-                    cmdTM.OnCloseCmdCompleted();
-                }
+                cmdTM?.OnCloseCmdCompleted();
             }
         }
 
@@ -1339,10 +1319,7 @@ namespace System.Management.Automation.Remoting.Client
 
             if (isDisposing)
             {
-                if (_client != null)
-                {
-                    _client.Dispose();
-                }
+                _client?.Dispose();
             }
         }
 
@@ -1661,13 +1638,13 @@ namespace System.Management.Automation.Remoting.Client
         private void CloseConnection()
         {
             var stdInWriter = Interlocked.Exchange(ref _stdInWriter, null);
-            if (stdInWriter != null) { stdInWriter.Dispose(); }
+            stdInWriter?.Dispose();
 
             var stdOutReader = Interlocked.Exchange(ref _stdOutReader, null);
-            if (stdOutReader != null) { stdOutReader.Dispose(); }
+            stdOutReader?.Dispose();
 
             var stdErrReader = Interlocked.Exchange(ref _stdErrReader, null);
-            if (stdErrReader != null) { stdErrReader.Dispose(); }
+            stdErrReader?.Dispose();
 
             // The CloseConnection() method can be called multiple times from multiple places.
             // Set the _sshProcessId to zero here so that we go through the work of finding
@@ -1902,10 +1879,7 @@ namespace System.Management.Automation.Remoting.Client
 
             if (isDisposing)
             {
-                if (_clientPipe != null)
-                {
-                    _clientPipe.Dispose();
-                }
+                _clientPipe?.Dispose();
             }
         }
 
@@ -2049,10 +2023,7 @@ namespace System.Management.Automation.Remoting.Client
         /// </summary>
         public void AbortConnect()
         {
-            if (_clientPipe != null)
-            {
-                _clientPipe.AbortConnect();
-            }
+            _clientPipe?.AbortConnect();
         }
 
         #endregion
diff --git a/src/System.Management.Automation/engine/remoting/fanin/PSSessionConfigurationData.cs b/src/System.Management.Automation/engine/remoting/fanin/PSSessionConfigurationData.cs
index 6da557cca..49225f46e 100644
--- a/src/System.Management.Automation/engine/remoting/fanin/PSSessionConfigurationData.cs
+++ b/src/System.Management.Automation/engine/remoting/fanin/PSSessionConfigurationData.cs
@@ -194,8 +194,7 @@ namespace System.Management.Automation.Remoting
                         object[] modulesToImport = optionValue.Split(',', StringSplitOptions.RemoveEmptyEntries);
                         foreach (var module in modulesToImport)
                         {
-                            var s = module as string;
-                            if (s != null)
+                            if (module is string s)
                             {
                                 _modulesToImport.Add(s.Trim());
 
diff --git a/src/System.Management.Automation/engine/remoting/fanin/PriorityCollection.cs b/src/System.Management.Automation/engine/remoting/fanin/PriorityCollection.cs
index 7baebdc98..a6725ec06 100644
--- a/src/System.Management.Automation/engine/remoting/fanin/PriorityCollection.cs
+++ b/src/System.Management.Automation/engine/remoting/fanin/PriorityCollection.cs
@@ -676,10 +676,7 @@ namespace System.Management.Automation.Remoting
         private void ResetReceiveData()
         {
             // reset resources used to store incoming data (for a single object)
-            if (_dataToProcessStream != null)
-            {
-                _dataToProcessStream.Dispose();
-            }
+            _dataToProcessStream?.Dispose();
 
             _currentObjectId = 0;
             _currentFrgId = 0;
diff --git a/src/System.Management.Automation/engine/remoting/fanin/WSManPluginFacade.cs b/src/System.Management.Automation/engine/remoting/fanin/WSManPluginFacade.cs
index e2679fcdf..156099268 100644
--- a/src/System.Management.Automation/engine/remoting/fanin/WSManPluginFacade.cs
+++ b/src/System.Management.Automation/engine/remoting/fanin/WSManPluginFacade.cs
@@ -447,10 +447,7 @@ namespace System.Management.Automation.Remoting
         {
             WSManPluginInstance.PerformShutdown(pluginContext);
 
-            if (workerPtrs != null)
-            {
-                workerPtrs.Dispose();
-            }
+            workerPtrs?.Dispose();
         }
 
         /// <summary>
diff --git a/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs b/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs
index 99b2d4848..0f0ed43a7 100644
--- a/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs
+++ b/src/System.Management.Automation/engine/remoting/fanin/WSManTransportManager.cs
@@ -1492,20 +1492,11 @@ namespace System.Management.Automation.Remoting.Client
             finally
             {
                 // release resources
-                if (proxyAuthCredentials != null)
-                {
-                    proxyAuthCredentials.Dispose();
-                }
+                proxyAuthCredentials?.Dispose();
 
-                if (proxyInfo != null)
-                {
-                    proxyInfo.Dispose();
-                }
+                proxyInfo?.Dispose();
 
-                if (authCredentials != null)
-                {
-                    authCredentials.Dispose();
-                }
+                authCredentials?.Dispose();
             }
 
             if (result != 0)
@@ -1732,15 +1723,13 @@ namespace System.Management.Automation.Remoting.Client
         internal override void ProcessPrivateData(object privateData)
         {
             // Raise the Robust
-            ConnectionStatusEventArgs rcArgs = privateData as ConnectionStatusEventArgs;
-            if (rcArgs != null)
+            if (privateData is ConnectionStatusEventArgs rcArgs)
             {
                 RaiseRobustConnectionNotification(rcArgs);
                 return;
             }
 
-            CompletionEventArgs completionArgs = privateData as CompletionEventArgs;
-            if (completionArgs != null)
+            if (privateData is CompletionEventArgs completionArgs)
             {
                 switch (completionArgs.Notification)
                 {
diff --git a/src/System.Management.Automation/engine/remoting/server/OutOfProcServerMediator.cs b/src/System.Management.Automation/engine/remoting/server/OutOfProcServerMediator.cs
index 1c2728cc6..f698b19de 100644
--- a/src/System.Management.Automation/engine/remoting/server/OutOfProcServerMediator.cs
+++ b/src/System.Management.Automation/engine/remoting/server/OutOfProcServerMediator.cs
@@ -209,10 +209,7 @@ namespace System.Management.Automation.Remoting.Server
                     }
 
                     // dont throw if there is no cmdTM as it might have legitimately closed
-                    if (cmdTM != null)
-                    {
-                        cmdTM.Close(null);
-                    }
+                    cmdTM?.Close(null);
                 }
                 finally
                 {
@@ -253,12 +250,7 @@ namespace System.Management.Automation.Remoting.Server
                 {
                     tracer.WriteMessage("OnClosePacketReceived, in progress commands count should be zero : " + _inProgressCommandsCount + ", psGuid : " + psGuid.ToString());
 
-                    if (sessionTM != null)
-                    {
-                        // it appears that when closing PowerShell ISE, therefore closing OutOfProcServerMediator, there are 2 Close command requests
-                        // changing PSRP/IPC at this point is too risky, therefore protecting about this duplication
-                        sessionTM.Close(null);
-                    }
+                    sessionTM?.Close(null);
 
                     tracer.WriteMessage("END calling close on session transport manager");
                     sessionTM = null;
@@ -277,10 +269,7 @@ namespace System.Management.Automation.Remoting.Server
                 }
 
                 // dont throw if there is no cmdTM as it might have legitimately closed
-                if (cmdTM != null)
-                {
-                    cmdTM.Close(null);
-                }
+                cmdTM?.Close(null);
 
                 lock (_syncObject)
                 {
diff --git a/src/System.Management.Automation/engine/remoting/server/ServerPowerShellDriver.cs b/src/System.Management.Automation/engine/remoting/server/ServerPowerShellDriver.cs
index 6a49d6f3a..a007e03e1 100644
--- a/src/System.Management.Automation/engine/remoting/server/ServerPowerShellDriver.cs
+++ b/src/System.Management.Automation/engine/remoting/server/ServerPowerShellDriver.cs
@@ -798,11 +798,7 @@ namespace System.Management.Automation
         {
             // Close input if its active. no need to synchronize as input stream would have already been processed
             // when connect call came into PS plugin
-            if (InputCollection != null)
-            {
-                // TODO: Post an ETW event
-                InputCollection.Complete();
-            }
+            InputCollection?.Complete();
         }
 
         /// <summary>
@@ -825,9 +821,7 @@ namespace System.Management.Automation
             Runspace rs = DataStructureHandler.RunspaceUsedToInvokePowerShell;
             if (rs != null)
             {
-                PSLocalEventManager events = (object)rs.Events as PSLocalEventManager;
-
-                if (events != null)
+                if ((object)rs.Events is PSLocalEventManager events)
                 {
                     foreach (PSEventSubscriber subscriber in events.Subscribers)
                     {
diff --git a/src/System.Management.Automation/engine/remoting/server/ServerRemoteHost.cs b/src/System.Management.Automation/engine/remoting/server/ServerRemoteHost.cs
index ca7ff805c..eaed49ef4 100644
--- a/src/System.Management.Automation/engine/remoting/server/ServerRemoteHost.cs
+++ b/src/System.Management.Automation/engine/remoting/server/ServerRemoteHost.cs
@@ -352,10 +352,7 @@ namespace System.Management.Automation.Remoting
         {
             if (_pushedRunspace != null)
             {
-                if (_debugger != null)
-                {
-                    _debugger.PopDebugger();
-                }
+                _debugger?.PopDebugger();
 
                 if (_hostSupportsPSEdit)
                 {
diff --git a/src/System.Management.Automation/engine/remoting/server/ServerRemotingProtocol2.cs b/src/System.Management.Automation/engine/remoting/server/ServerRemotingProtocol2.cs
index f87f89b5b..76783da04 100644
--- a/src/System.Management.Automation/engine/remoting/server/ServerRemotingProtocol2.cs
+++ b/src/System.Management.Automation/engine/remoting/server/ServerRemotingProtocol2.cs
@@ -243,8 +243,7 @@ namespace System.Management.Automation
                 {
                     foreach (object o in _associatedShells.Values)
                     {
-                        ServerPowerShellDataStructureHandler result = o as ServerPowerShellDataStructureHandler;
-                        if (result != null)
+                        if (o is ServerPowerShellDataStructureHandler result)
                         {
                             return result;
                         }
@@ -266,10 +265,7 @@ namespace System.Management.Automation
 
             // if data structure handler is not found, then association has already been
             // removed, discard message
-            if (dsHandler != null)
-            {
-                dsHandler.ProcessReceivedData(rcvdData);
-            }
+            dsHandler?.ProcessReceivedData(rcvdData);
         }
 
         /// <summary>
diff --git a/src/System.Management.Automation/engine/remoting/server/ServerRunspacePoolDriver.cs b/src/System.Management.Automation/engine/remoting/server/ServerRunspacePoolDriver.cs
index 2f2675e61..366cc6a34 100644
--- a/src/System.Management.Automation/engine/remoting/server/ServerRunspacePoolDriver.cs
+++ b/src/System.Management.Automation/engine/remoting/server/ServerRunspacePoolDriver.cs
@@ -350,10 +350,7 @@ namespace System.Management.Automation
                 {
                     Runspace runspaceToDispose = _remoteHost.PushedRunspace;
                     _remoteHost.PopRunspace();
-                    if (runspaceToDispose != null)
-                    {
-                        runspaceToDispose.Dispose();
-                    }
+                    runspaceToDispose?.Dispose();
                 }
 
                 DisposeRemoteDebugger();
@@ -479,7 +476,7 @@ namespace System.Management.Automation
             // or greater, and remote session supports debugging.
             if ((_driverNestedInvoker != null) &&
                 (_clientPSVersion != null && _clientPSVersion >= PSVersionInfo.PSV4Version) &&
-                (runspace != null && runspace.Debugger != null))
+                (runspace?.Debugger != null))
             {
                 _serverRemoteDebugger = new ServerRemoteDebugger(this, runspace, runspace.Debugger);
                 _remoteHost.ServerDebugger = _serverRemoteDebugger;
@@ -488,10 +485,7 @@ namespace System.Management.Automation
 
         private void DisposeRemoteDebugger()
         {
-            if (_serverRemoteDebugger != null)
-            {
-                _serverRemoteDebugger.Dispose();
-            }
+            _serverRemoteDebugger?.Dispose();
         }
 
         /// <summary>
@@ -551,15 +545,14 @@ namespace System.Management.Automation
             if (errorList.Count > 0)
             {
                 string exceptionThrown;
-                ErrorRecord lastErrorRecord = errorList[0] as ErrorRecord;
-                if (lastErrorRecord != null)
+
+                if (errorList[0] is ErrorRecord lastErrorRecord)
                 {
                     exceptionThrown = lastErrorRecord.ToString();
                 }
                 else
                 {
-                    Exception lastException = errorList[0] as Exception;
-                    if (lastException != null)
+                    if (errorList[0] is Exception lastException)
                     {
                         exceptionThrown = (lastException.Message != null) ? lastException.Message : string.Empty;
                     }
@@ -812,10 +805,7 @@ namespace System.Management.Automation
             {
                 // If we have a pushed runspace then execute there.
                 // Ensure debugger is enabled to the original mode it was set to.
-                if (_serverRemoteDebugger != null)
-                {
-                    _serverRemoteDebugger.CheckDebuggerState();
-                }
+                _serverRemoteDebugger?.CheckDebuggerState();
 
                 StartPowerShellCommandOnPushedRunspace(
                     powershell,
@@ -923,10 +913,7 @@ namespace System.Management.Automation
 
             // Invoke command normally.  Ensure debugger is enabled to the
             // original mode it was set to.
-            if (_serverRemoteDebugger != null)
-            {
-                _serverRemoteDebugger.CheckDebuggerState();
-            }
+            _serverRemoteDebugger?.CheckDebuggerState();
 
             // Invoke PowerShell on driver runspace pool.
             ServerPowerShellDriver driver = new ServerPowerShellDriver(
@@ -1321,8 +1308,8 @@ namespace System.Management.Automation
                 }
 
                 DebuggerResumeAction? resumeAction = null;
-                PSObject resumeObject = command.Parameters[0].Value as PSObject;
-                if (resumeObject != null)
+
+                if (command.Parameters[0].Value is PSObject resumeObject)
                 {
                     try
                     {
@@ -1349,8 +1336,8 @@ namespace System.Management.Automation
                 }
 
                 DebugModes? mode = null;
-                PSObject modeObject = command.Parameters[0].Value as PSObject;
-                if (modeObject != null)
+
+                if (command.Parameters[0].Value is PSObject modeObject)
                 {
                     try
                     {
@@ -1392,8 +1379,8 @@ namespace System.Management.Automation
                 }
 
                 UnhandledBreakpointProcessingMode? mode = null;
-                PSObject modeObject = command.Parameters[0].Value as PSObject;
-                if (modeObject != null)
+
+                if (command.Parameters[0].Value is PSObject modeObject)
                 {
                     try
                     {
@@ -2031,10 +2018,7 @@ namespace System.Management.Automation
             }
 
             ThreadCommandProcessing threadCommandProcessing = _threadCommandProcessing;
-            if (threadCommandProcessing != null)
-            {
-                threadCommandProcessing.Stop();
-            }
+            threadCommandProcessing?.Stop();
         }
 
         /// <summary>
@@ -2232,15 +2216,9 @@ namespace System.Management.Automation
                 ExitDebugMode(DebuggerResumeAction.Stop);
             }
 
-            if (_nestedDebugStopCompleteEvent != null)
-            {
-                _nestedDebugStopCompleteEvent.Dispose();
-            }
+            _nestedDebugStopCompleteEvent?.Dispose();
 
-            if (_processCommandCompleteEvent != null)
-            {
-                _processCommandCompleteEvent.Dispose();
-            }
+            _processCommandCompleteEvent?.Dispose();
         }
 
         #endregion
@@ -2312,10 +2290,7 @@ namespace System.Management.Automation
             public void Stop()
             {
                 Debugger debugger = _wrappedDebugger;
-                if (debugger != null)
-                {
-                    debugger.StopProcessCommand();
-                }
+                debugger?.StopProcessCommand();
             }
 
             internal void DoInvoke()
@@ -2632,8 +2607,7 @@ namespace System.Management.Automation
         private bool IsDebuggingSupported()
         {
             // Restriction only occurs on a (non-pushed) local runspace.
-            LocalRunspace localRunspace = _runspace as LocalRunspace;
-            if (localRunspace != null)
+            if (_runspace is LocalRunspace localRunspace)
             {
                 CmdletInfo cmdletInfo = localRunspace.ExecutionContext.EngineSessionState.GetCmdlet(SetPSBreakCommandText);
                 if ((cmdletInfo != null) && (cmdletInfo.Visibility != SessionStateEntryVisibility.Public))
@@ -2763,8 +2737,7 @@ namespace System.Management.Automation
 
         internal int GetBreakpointCount()
         {
-            ScriptDebugger scriptDebugger = _wrappedDebugger.Value as ScriptDebugger;
-            if (scriptDebugger != null)
+            if (_wrappedDebugger.Value is ScriptDebugger scriptDebugger)
             {
                 return scriptDebugger.GetBreakpoints().Count;
             }
diff --git a/src/System.Management.Automation/engine/remoting/server/ServerSteppablePipelineDriver.cs b/src/System.Management.Automation/engine/remoting/server/ServerSteppablePipelineDriver.cs
index 66fe9d927..3360df12d 100644
--- a/src/System.Management.Automation/engine/remoting/server/ServerSteppablePipelineDriver.cs
+++ b/src/System.Management.Automation/engine/remoting/server/ServerSteppablePipelineDriver.cs
@@ -241,10 +241,7 @@ namespace System.Management.Automation
 
             _eventSubscriber.FireStartSteppablePipeline(this);
 
-            if (_powershellInput != null)
-            {
-                _powershellInput.Pulse();
-            }
+            _powershellInput?.Pulse();
         }
 
         #endregion Internal Methods
@@ -262,20 +259,14 @@ namespace System.Management.Automation
 
             CheckAndPulseForProcessing(true);
 
-            if (_powershellInput != null)
-            {
-                _powershellInput.Pulse();
-            }
+            _powershellInput?.Pulse();
         }
 
         private void HandleSessionConnected(object sender, EventArgs eventArgs)
         {
             // Close input if its active. no need to synchronize as input stream would have already been processed
             // when connect call came into PS plugin
-            if (Input != null)
-            {
-                Input.Complete();
-            }
+            Input?.Complete();
         }
 
         /// <summary>
@@ -302,10 +293,7 @@ namespace System.Management.Automation
 
             PerformStop();
 
-            if (_powershellInput != null)
-            {
-                _powershellInput.Pulse();
-            }
+            _powershellInput?.Pulse();
         }
 
         /// <summary>
@@ -326,10 +314,7 @@ namespace System.Management.Automation
 
                 CheckAndPulseForProcessing(false);
 
-                if (_powershellInput != null)
-                {
-                    _powershellInput.Pulse();
-                }
+                _powershellInput?.Pulse();
             }
         }
 
diff --git a/src/System.Management.Automation/engine/remoting/server/ServerSteppablePipelineSubscriber.cs b/src/System.Management.Automation/engine/remoting/server/ServerSteppablePipelineSubscriber.cs
index 328571647..9a4112432 100644
--- a/src/System.Management.Automation/engine/remoting/server/ServerSteppablePipelineSubscriber.cs
+++ b/src/System.Management.Automation/engine/remoting/server/ServerSteppablePipelineSubscriber.cs
@@ -274,11 +274,7 @@ namespace System.Management.Automation
         {
             lock (_syncObject)
             {
-                if (_eventManager != null)
-                {
-                    _eventManager.GenerateEvent(_startSubscriber.SourceIdentifier, this,
-                        new object[1] { new ServerSteppablePipelineDriverEventArg(driver) }, null, true, false);
-                }
+                _eventManager?.GenerateEvent(_startSubscriber.SourceIdentifier, this, new object[1]{new ServerSteppablePipelineDriverEventArg(driver)}, null, true, false);
             }
         }
 
@@ -290,11 +286,7 @@ namespace System.Management.Automation
         {
             lock (_syncObject)
             {
-                if (_eventManager != null)
-                {
-                    _eventManager.GenerateEvent(_processSubscriber.SourceIdentifier, this,
-                        new object[1] { new ServerSteppablePipelineDriverEventArg(driver) }, null, true, false);
-                }
+                _eventManager?.GenerateEvent(_processSubscriber.SourceIdentifier, this, new object[1]{new ServerSteppablePipelineDriverEventArg(driver)}, null, true, false);
             }
         }
 
diff --git a/src/System.Management.Automation/engine/remoting/server/serverremotesession.cs b/src/System.Management.Automation/engine/remoting/server/serverremotesession.cs
index 7b08c6743..127285dcc 100644
--- a/src/System.Management.Automation/engine/remoting/server/serverremotesession.cs
+++ b/src/System.Management.Automation/engine/remoting/server/serverremotesession.cs
@@ -725,10 +725,7 @@ namespace System.Management.Automation.Remoting
         // pass on application private data when session is connected from new client
         internal void HandlePostConnect()
         {
-            if (_runspacePoolDriver != null)
-            {
-                _runspacePoolDriver.SendApplicationPrivateDataToClient();
-            }
+            _runspacePoolDriver?.SendApplicationPrivateDataToClient();
         }
 
         /// <summary>
@@ -829,13 +826,11 @@ namespace System.Management.Automation.Remoting
             Version psClientVersion = null;
             if (_senderInfo.ApplicationArguments != null && _senderInfo.ApplicationArguments.ContainsKey("PSversionTable"))
             {
-                var value = PSObject.Base(_senderInfo.ApplicationArguments["PSversionTable"]) as PSPrimitiveDictionary;
-                if (value != null)
+                if (PSObject.Base(_senderInfo.ApplicationArguments["PSversionTable"]) is PSPrimitiveDictionary value)
                 {
                     if (value.ContainsKey("WSManStackVersion"))
                     {
-                        var wsmanStackVersion = PSObject.Base(value["WSManStackVersion"]) as Version;
-                        if (wsmanStackVersion != null && wsmanStackVersion.Major < 3)
+                        if (PSObject.Base(value["WSManStackVersion"]) is Version wsmanStackVersion && wsmanStackVersion.Major < 3)
                         {
                             // The client side is PSv2. This is the Win7 to Win8 scenario. We need to add the PSv2
                             // TabExpansion function back in to keep the tab expansion functionable on the client side.
@@ -961,10 +956,7 @@ namespace System.Management.Automation.Remoting
         /// <param name="eventArgs"></param>
         private void HandleSessionDSHandlerClosing(object sender, EventArgs eventArgs)
         {
-            if (_runspacePoolDriver != null)
-            {
-                _runspacePoolDriver.Close();
-            }
+            _runspacePoolDriver?.Close();
 
             // dispose the session configuration object..this will let them
             // clean their resources.
diff --git a/src/System.Management.Automation/engine/remoting/server/serverremotesessionstatemachine.cs b/src/System.Management.Automation/engine/remoting/server/serverremotesessionstatemachine.cs
index 732e5a836..3a6bb4c1f 100644
--- a/src/System.Management.Automation/engine/remoting/server/serverremotesessionstatemachine.cs
+++ b/src/System.Management.Automation/engine/remoting/server/serverremotesessionstatemachine.cs
@@ -913,10 +913,7 @@ namespace System.Management.Automation.Remoting
                         {
                             // reset the timer
                             Timer tmp = Interlocked.Exchange(ref _keyExchangeTimer, null);
-                            if (tmp != null)
-                            {
-                                tmp.Dispose();
-                            }
+                            tmp?.Dispose();
                         }
 
                         // the key import would have been done
@@ -984,10 +981,7 @@ namespace System.Management.Automation.Remoting
             Dbg.Assert(_state == RemoteSessionState.EstablishedAndKeyRequested, "timeout should only happen when waiting for a key");
 
             Timer tmp = Interlocked.Exchange(ref _keyExchangeTimer, null);
-            if (tmp != null)
-            {
-                tmp.Dispose();
-            }
+            tmp?.Dispose();
 
             PSRemotingDataStructureException exception =
                 new PSRemotingDataStructureException(RemotingErrorIdStrings.ServerKeyExchangeFailed);
diff --git a/src/System.Management.Automation/engine/runtime/Binding/Binders.cs b/src/System.Management.Automation/engine/runtime/Binding/Binders.cs
index 275529b7b..e6611e002 100644
--- a/src/System.Management.Automation/engine/runtime/Binding/Binders.cs
+++ b/src/System.Management.Automation/engine/runtime/Binding/Binders.cs
@@ -654,8 +654,7 @@ namespace System.Management.Automation.Language
                     Expression.Call(CachedReflectionInfo.EnumerableOps_GetCOMEnumerator, target.Expression), bindingRestrictions).WriteToDebugLog(this);
             }
 
-            var enumerable = targetValue as IEnumerable;
-            if (enumerable != null)
+            if (targetValue is IEnumerable enumerable)
             {
                 // Normally it's safe to just call IEnumerable.GetEnumerator, but in some rare cases, the
                 // non-generic implementation throws or returns null, so we'll just avoid that problem and
@@ -679,8 +678,7 @@ namespace System.Management.Automation.Language
                     GetRestrictions(target))).WriteToDebugLog(this);
             }
 
-            var enumerator = targetValue as IEnumerator;
-            if (enumerator != null)
+            if (targetValue is IEnumerator enumerator)
             {
                 return (new DynamicMetaObject(
                     MaybeDebase(this, e => e.Cast(typeof(IEnumerator)), target),
@@ -751,16 +749,14 @@ namespace System.Management.Automation.Language
 
         private static IEnumerator PSObjectNotEnumerableRule(CallSite site, object obj)
         {
-            var psobj = obj as PSObject;
-            return psobj != null && obj != AutomationNull.Value
+            return obj is PSObject psobj && obj != AutomationNull.Value
                 ? NotEnumerableRule(site, PSObject.Base(obj))
                 : ((CallSite<Func<CallSite, object, IEnumerator>>)site).Update(site, obj);
         }
 
         private static IEnumerator ArrayRule(CallSite site, object obj)
         {
-            var array = obj as Array;
-            if (array != null) return array.GetEnumerator();
+            if (obj is Array array) return array.GetEnumerator();
             return ((CallSite<Func<CallSite, object, IEnumerator>>)site).Update(site, obj);
         }
 
@@ -771,8 +767,7 @@ namespace System.Management.Automation.Language
 
         private static IEnumerator PSObjectStringRule(CallSite site, object obj)
         {
-            var psobj = obj as PSObject;
-            if (psobj != null && PSObject.Base(psobj) is string) return null;
+            if (obj is PSObject psobj && PSObject.Base(psobj) is string) return null;
             return ((CallSite<Func<CallSite, object, IEnumerator>>)site).Update(site, obj);
         }
     }
@@ -974,8 +969,7 @@ namespace System.Management.Automation.Language
                 return this.DeferForPSObject(target).WriteToDebugLog(this);
             }
 
-            var iList = target.Value as IList;
-            if (iList != null)
+            if (target.Value is IList iList)
             {
                 // 3 possibilities - too few, exact, or too many elements.
 
@@ -1244,8 +1238,8 @@ namespace System.Management.Automation.Language
             object memberNameValue = PSObject.Base(memberNameArg.Value);
 
             Expression bindingStrExpr;
-            var memberName = memberNameValue as string;
-            if (memberName != null)
+
+            if (memberNameValue is string memberName)
             {
                 if (memberNameArg.Value is PSObject)
                 {
@@ -1330,8 +1324,8 @@ namespace System.Management.Automation.Language
 
             Expression bindingStrExpr;
             BindingRestrictions restrictions;
-            var memberName = memberNameValue as string;
-            if (memberName != null)
+
+            if (memberNameValue is string memberName)
             {
                 if (memberNameArg.Value is PSObject)
                 {
@@ -1439,8 +1433,8 @@ namespace System.Management.Automation.Language
             object memberNameValue = PSObject.Base(memberNameArg.Value);
 
             Expression bindingStrExpr;
-            var memberName = memberNameValue as string;
-            if (memberName != null)
+
+            if (memberNameValue is string memberName)
             {
                 if (memberNameArg.Value is PSObject)
                 {
@@ -1737,8 +1731,8 @@ namespace System.Management.Automation.Language
                     var member = members[0];
                     Expression lhs;
                     Type propertyType;
-                    var propertyInfo = member as PropertyInfo;
-                    if (propertyInfo != null)
+
+                    if (member is PropertyInfo propertyInfo)
                     {
                         if (propertyInfo.GetSetMethod() == null)
                         {
@@ -1897,8 +1891,7 @@ namespace System.Management.Automation.Language
                 return new DynamicMetaObject(ExpressionCache.NullConstant, target.PSGetTypeRestriction()).WriteToDebugLog(this);
             }
 
-            var psobj = value as PSObject;
-            if (psobj != null)
+            if (value is PSObject psobj)
             {
                 var restrictions = BindingRestrictions.GetTypeRestriction(target.Expression, psobj.GetType());
                 var expr = target.Expression;
@@ -2024,7 +2017,7 @@ namespace System.Management.Automation.Language
         private static object PSObjectStringRule(CallSite site, object obj)
         {
             var psobj = obj as PSObject;
-            if (psobj != null && psobj.BaseObject is string) return obj;
+            if (psobj?.BaseObject is string) return obj;
             return ((CallSite<Func<CallSite, object, object>>)site).Update(site, obj);
         }
 
@@ -3844,7 +3837,7 @@ namespace System.Management.Automation.Language
             var baseObject = PSObject.Base(argument.Value);
 
             // Source value cannot be null or AutomationNull, and it cannot be a pure PSObject.
-            if (baseObject != null && baseObject is not PSObject)
+            if (baseObject is not PSObject)
             {
                 Type fromType = baseObject.GetType();
                 ConversionRank rank = ConversionRank.None;
@@ -5241,21 +5234,16 @@ namespace System.Management.Automation.Language
             {
                 Diagnostics.Assert(memberInfo.instance == null, "We shouldn't be here if a member is already bound.");
 
-                // The most common case - we're getting some property.  We can optimize many different kinds
-                // of property accessors, so we special case each possibility.
-                var propertyInfo = memberInfo as PSPropertyInfo;
-                if (propertyInfo != null)
+                // The most common case - we're getting some property.  We can optimize many different kinds                // of property accessors, so we special case each possibility.
+                if (memberInfo is PSPropertyInfo propertyInfo)
                 {
                     if (!propertyInfo.IsGettable)
                     {
                         return GenerateGetPropertyException(restrictions).WriteToDebugLog(this);
                     }
-
-                    var property = propertyInfo as PSProperty;
-                    if (property != null)
+                    if (propertyInfo is PSProperty property)
                     {
-                        var adapterData = property.adapterData as DotNetAdapter.PropertyCacheEntry;
-                        Diagnostics.Assert(adapterData != null, "We have an unknown PSProperty that we aren't correctly optimizing.");
+                        Diagnostics.Assert(property.adapterData is DotNetAdapter.PropertyCacheEntry adapterData, "We have an unknown PSProperty that we aren't correctly optimizing.");
 
                         if (adapterData.member.DeclaringType.IsGenericTypeDefinition || adapterData.propertyType.IsByRefLike)
                         {
@@ -5268,8 +5256,7 @@ namespace System.Management.Automation.Language
                             // For static property access, the target expr must be null.  For non-static, we must convert
                             // because target.Expression is typeof(object) because this is a dynamic site.
                             var targetExpr = _static ? null : GetTargetExpr(target, adapterData.member.DeclaringType);
-                            var propertyAccessor = adapterData.member as PropertyInfo;
-                            if (propertyAccessor != null)
+                            if (adapterData.member is PropertyInfo propertyAccessor)
                             {
                                 if (propertyAccessor.GetMethod.IsFamily &&
                                     (_classScope == null || !_classScope.IsSubclassOf(propertyAccessor.DeclaringType)))
@@ -5287,16 +5274,12 @@ namespace System.Management.Automation.Language
                             }
                         }
                     }
-
-                    var scriptProperty = propertyInfo as PSScriptProperty;
-                    if (scriptProperty != null)
+                    if (propertyInfo is PSScriptProperty scriptProperty)
                     {
                         expr = Expression.Call(Expression.Constant(scriptProperty, typeof(PSScriptProperty)),
                                                CachedReflectionInfo.PSScriptProperty_InvokeGetter, target.Expression.Cast(typeof(object)));
                     }
-
-                    var codeProperty = propertyInfo as PSCodeProperty;
-                    if (codeProperty != null)
+                    if (propertyInfo is PSCodeProperty codeProperty)
                     {
                         Diagnostics.Assert(codeProperty.GetterCodeReference != null, "CodeProperty isn't gettable, should have generated error code above.");
                         Diagnostics.Assert(codeProperty.GetterCodeReference.IsStatic, "CodeProperty should be a static method.");
@@ -5304,9 +5287,7 @@ namespace System.Management.Automation.Language
                         expr = PSInvokeMemberBinder.InvokeMethod(codeProperty.GetterCodeReference, null, new[] { target },
                             false, PSInvokeMemberBinder.MethodInvocationType.Getter);
                     }
-
-                    var noteProperty = propertyInfo as PSNoteProperty;
-                    if (noteProperty != null)
+                    if (propertyInfo is PSNoteProperty noteProperty)
                     {
                         Diagnostics.Assert(!noteProperty.IsSettable, "If the note is settable, incorrect code is generated.");
                         expr = Expression.Property(Expression.Constant(propertyInfo, typeof(PSNoteProperty)), CachedReflectionInfo.PSNoteProperty_Value);
@@ -5396,10 +5377,8 @@ namespace System.Management.Automation.Language
         {
             var expr = target.Expression;
             var value = target.Value;
-
             // If the target value is actually a deserialized PSObject, we should use the original value
-            var psobj = value as PSObject;
-            if (psobj != null && psobj != AutomationNull.Value && !psobj.IsDeserialized)
+            if (value is PSObject psobj && psobj != AutomationNull.Value && !psobj.IsDeserialized)
             {
                 expr = Expression.Call(CachedReflectionInfo.PSObject_Base, expr);
                 value = PSObject.Base(value);
@@ -5687,13 +5666,9 @@ namespace System.Management.Automation.Language
             restrictions = versionRestriction;
 
             // When returning aliasRestrictions always include the version restriction
-            if (aliasRestrictions != null)
-            {
-                aliasRestrictions.Add(versionRestriction);
-            }
+            aliasRestrictions?.Add(versionRestriction);
 
-            var alias = memberInfo as PSAliasProperty;
-            if (alias != null)
+            if (memberInfo is PSAliasProperty alias)
             {
                 aliasConversionType = alias.ConversionType;
                 if (aliasRestrictions == null)
@@ -5723,8 +5698,7 @@ namespace System.Management.Automation.Language
                 {
                     if (this.Name.Equals(member.Name, StringComparison.OrdinalIgnoreCase))
                     {
-                        var propertyInfo = member as PropertyInfo;
-                        if (propertyInfo != null)
+                        if (member is PropertyInfo propertyInfo)
                         {
                             var getMethod = propertyInfo.GetGetMethod(nonPublic: true);
                             var setMethod = propertyInfo.GetSetMethod(nonPublic: true);
@@ -5737,8 +5711,7 @@ namespace System.Management.Automation.Language
                         }
                         else
                         {
-                            var fieldInfo = member as FieldInfo;
-                            if (fieldInfo != null)
+                            if (member is FieldInfo fieldInfo)
                             {
                                 if (fieldInfo.IsFamily)
                                 {
@@ -5747,8 +5720,7 @@ namespace System.Management.Automation.Language
                             }
                             else
                             {
-                                var methodInfo = member as MethodInfo;
-                                if (methodInfo != null && (methodInfo.IsPublic || methodInfo.IsFamily))
+                                if (member is MethodInfo methodInfo && (methodInfo.IsPublic || methodInfo.IsFamily))
                                 {
                                     if (candidateMethods == null)
                                     {
@@ -5764,8 +5736,7 @@ namespace System.Management.Automation.Language
 
                 if (candidateMethods != null && candidateMethods.Count > 0)
                 {
-                    var psMethodInfo = memberInfo as PSMethod;
-                    if (psMethodInfo != null)
+                    if (memberInfo is PSMethod psMethodInfo)
                     {
                         var cacheEntry = (DotNetAdapter.MethodCacheEntry)psMethodInfo.adapterData;
                         candidateMethods.AddRange(cacheEntry.methodInformationStructures.Select(e => e.method));
@@ -6194,19 +6165,15 @@ namespace System.Management.Automation.Language
                     restrictions)).WriteToDebugLog(this);
             }
 
-            var psPropertyInfo = memberInfo as PSPropertyInfo;
-            if (psPropertyInfo != null)
+            if (memberInfo is PSPropertyInfo psPropertyInfo)
             {
                 if (!psPropertyInfo.IsSettable)
                 {
                     return GeneratePropertyAssignmentException(restrictions).WriteToDebugLog(this);
                 }
-
-                var psProperty = psPropertyInfo as PSProperty;
-                if (psProperty != null)
+                if (psPropertyInfo is PSProperty psProperty)
                 {
-                    var data = psProperty.adapterData as DotNetAdapter.PropertyCacheEntry;
-                    if (data != null)
+                    if (psProperty.adapterData is DotNetAdapter.PropertyCacheEntry data)
                     {
                         Expression expr;
 
@@ -6248,8 +6215,6 @@ namespace System.Management.Automation.Language
 
                             return new DynamicMetaObject(expr, restrictions).WriteToDebugLog(this);
                         }
-
-                        var propertyInfo = data.member as PropertyInfo;
                         Expression lhs;
                         Type lhsType;
 
@@ -6263,7 +6228,7 @@ namespace System.Management.Automation.Language
                         // For static property access, the target expr must be null.  For non-static, we must convert
                         // because target.Expression is typeof(object) because this is a dynamic site.
                         var targetExpr = _static ? null : PSGetMemberBinder.GetTargetExpr(target, data.member.DeclaringType);
-                        if (propertyInfo != null)
+                        if (data.member is PropertyInfo propertyInfo)
                         {
                             if (propertyInfo.SetMethod.IsFamily &&
                                 (_classScope == null || !_classScope.IsSubclassOf(propertyInfo.DeclaringType)))
@@ -6350,9 +6315,7 @@ namespace System.Management.Automation.Language
                         return new DynamicMetaObject(expr, restrictions).WriteToDebugLog(this);
                     }
                 }
-
-                var codeProperty = psPropertyInfo as PSCodeProperty;
-                if (codeProperty != null)
+                if (psPropertyInfo is PSCodeProperty codeProperty)
                 {
                     var setterMethod = codeProperty.SetterCodeReference;
                     var parameters = setterMethod.GetParameters();
@@ -6389,9 +6352,7 @@ namespace System.Management.Automation.Language
                             temp),
                         restrictions).WriteToDebugLog(this);
                 }
-
-                var scriptProperty = psPropertyInfo as PSScriptProperty;
-                if (scriptProperty != null)
+                if (psPropertyInfo is PSScriptProperty scriptProperty)
                 {
                     // Invoke Setter
 
@@ -6768,8 +6729,7 @@ namespace System.Management.Automation.Language
             // defined in the TypeTable will only get affected by the PSTypeNames.
             if (methodInfo is PSMethod || methodInfo is PSParameterizedProperty)
             {
-                var psObj = target.Value as PSObject;
-                if (psObj != null && (targetValue.GetType() == typeof(Hashtable) || targetValue.GetType() == typeof(ArrayList)))
+                if (target.Value is PSObject psObj && (targetValue.GetType() == typeof(Hashtable) || targetValue.GetType() == typeof(ArrayList)))
                 {
                     // If we get here, then the target value should have 'isDeserialized == false', otherwise we cannot get a .NET methodInfo
                     // from _getMemberBinder.GetPSMemberInfo(). This is because when 'isDeserialized' is true, we use the PSObject to find the
@@ -6782,8 +6742,7 @@ namespace System.Management.Automation.Language
                 }
             }
 
-            var psMethod = methodInfo as PSMethod;
-            if (psMethod != null)
+            if (methodInfo is PSMethod psMethod)
             {
                 var data = (DotNetAdapter.MethodCacheEntry)psMethod.adapterData;
 
@@ -6791,8 +6750,7 @@ namespace System.Management.Automation.Language
                     data.methodInformationStructures, typeof(MethodException)).WriteToDebugLog(this);
             }
 
-            var scriptMethod = methodInfo as PSScriptMethod;
-            if (scriptMethod != null)
+            if (methodInfo is PSScriptMethod scriptMethod)
             {
                 return new DynamicMetaObject(
                     Expression.Call(CachedReflectionInfo.PSScriptMethod_InvokeScript,
@@ -6804,8 +6762,7 @@ namespace System.Management.Automation.Language
                     restrictions).WriteToDebugLog(this);
             }
 
-            var codeMethod = methodInfo as PSCodeMethod;
-            if (codeMethod != null)
+            if (methodInfo is PSCodeMethod codeMethod)
             {
                 Expression expr = InvokeMethod(codeMethod.CodeReference, null, args.Prepend(target).ToArray(), false, MethodInvocationType.Ordinary);
                 if (codeMethod.CodeReference.ReturnType == typeof(void))
@@ -6820,8 +6777,7 @@ namespace System.Management.Automation.Language
                 return new DynamicMetaObject(expr, restrictions).WriteToDebugLog(this);
             }
 
-            var parameterizedProperty = methodInfo as PSParameterizedProperty;
-            if (parameterizedProperty != null)
+            if (methodInfo is PSParameterizedProperty parameterizedProperty)
             {
                 var p = (DotNetAdapter.ParameterizedPropertyCacheEntry)parameterizedProperty.adapterData;
                 return InvokeDotNetMethod(CallInfo, Name, _invocationConstraints, _propertySetter ? MethodInvocationType.Setter : MethodInvocationType.Ordinary, target, args, restrictions,
@@ -7017,8 +6973,8 @@ namespace System.Management.Automation.Language
             List<Expression> copyOutTemps = new List<Expression>();
 
             ConstructorInfo constructorInfo = null;
-            MethodInfo methodInfo = mi as MethodInfo;
-            if (methodInfo != null)
+
+            if (mi is MethodInfo methodInfo)
             {
                 Type returnType = methodInfo.ReturnType;
                 if (returnType.IsByRefLike)
@@ -7405,13 +7361,12 @@ namespace System.Management.Automation.Language
         {
             var context = LocalPipeline.GetExecutionContextFromTLS();
             var adapterSet = PSObject.GetMappedAdapter(obj, context?.TypeTable);
-            var methodInfo = adapterSet.OriginalAdapter.BaseGetMember<PSMemberInfo>(obj, methodName) as PSMethodInfo;
             if (methodInfo == null && adapterSet.DotNetAdapter != null)
             {
                 methodInfo = adapterSet.DotNetAdapter.BaseGetMember<PSMemberInfo>(obj, methodName) as PSMethodInfo;
             }
 
-            if (methodInfo != null)
+            if (adapterSet.OriginalAdapter.BaseGetMember<PSMemberInfo>(obj, methodName) is PSMethodInfo methodInfo)
             {
                 return methodInfo.Invoke(args);
             }
diff --git a/src/System.Management.Automation/engine/runtime/CompiledScriptBlock.cs b/src/System.Management.Automation/engine/runtime/CompiledScriptBlock.cs
index 6478e9b09..7cb1ce370 100644
--- a/src/System.Management.Automation/engine/runtime/CompiledScriptBlock.cs
+++ b/src/System.Management.Automation/engine/runtime/CompiledScriptBlock.cs
@@ -369,11 +369,8 @@ namespace System.Management.Automation
 
         internal bool GetIsConfiguration()
         {
-            // Use _ast instead of Ast
-            //  If we access Ast, we may parse a "delay parsed" script block unnecessarily
-            //  if _ast is null - it can't be a configuration as there is no way to create a configuration that way
-            var scriptBlockAst = _ast as ScriptBlockAst;
-            return scriptBlockAst != null && scriptBlockAst.IsConfiguration;
+            // Use _ast instead of Ast            //  If we access Ast, we may parse a "delay parsed" script block unnecessarily            //  if _ast is null - it can't be a configuration as there is no way to create a configuration that way
+            return _ast is ScriptBlockAst scriptBlockAst && scriptBlockAst.IsConfiguration;
         }
 
         internal bool HasSuspiciousContent
@@ -511,8 +508,7 @@ namespace System.Management.Automation
                 return sbAst.ToStringForSerialization();
             }
 
-            var generatedMemberFunctionAst = _ast as CompilerGeneratedMemberFunctionAst;
-            if (generatedMemberFunctionAst != null)
+            if (_ast is CompilerGeneratedMemberFunctionAst generatedMemberFunctionAst)
             {
                 return generatedMemberFunctionAst.Extent.Text;
             }
@@ -1299,10 +1295,10 @@ namespace System.Management.Automation
                 if (i >= args.Length)
                 {
                     valueToBind = parameter.Value;
-                    if (valueToBind is Compiler.DefaultValueExpressionWrapper)
+                    if (valueToBind is Compiler.DefaultValueExpressionWrapper defaultValueExpressionWrapper)
                     {
                         // We pass in a null SessionStateInternal because the current scope is already set correctly.
-                        valueToBind = ((Compiler.DefaultValueExpressionWrapper)valueToBind).GetValue(context, null);
+                        valueToBind = defaultValueExpressionWrapper.GetValue(context, null);
                     }
 
                     wasDefaulted = true;
diff --git a/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs b/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs
index df8b36eb4..d9619200a 100644
--- a/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs
+++ b/src/System.Management.Automation/engine/runtime/Operations/MiscOps.cs
@@ -40,8 +40,8 @@ namespace System.Management.Automation
 
             Diagnostics.Assert(commandElements[0].ArgumentSpecified && !commandElements[0].ParameterNameSpecified,
                 "Compiler will pass first parameter as an argument.");
-            var mi = PSObject.Base(commandElements[0].ArgumentValue) as PSModuleInfo;
-            if (mi != null)
+
+            if (PSObject.Base(commandElements[0].ArgumentValue) is PSModuleInfo mi)
             {
                 if (mi.ModuleType == ModuleType.Binary && mi.SessionState == null)
                 {
@@ -89,15 +89,14 @@ namespace System.Management.Automation
 
             string invocationName = (dotSource) ? "." : invocationToken == TokenKind.Ampersand ? "&" : null;
             CommandProcessorBase commandProcessor;
-            var scriptBlock = command as ScriptBlock;
-            if (scriptBlock != null)
+
+            if (command is ScriptBlock scriptBlock)
             {
                 commandProcessor = CommandDiscovery.CreateCommandProcessorForScript(scriptBlock, context, !dotSource, commandSessionState);
             }
             else
             {
-                var commandInfo = command as CommandInfo;
-                if (commandInfo != null)
+                if (command is CommandInfo commandInfo)
                 {
                     commandProcessor = context.CommandDiscovery.LookupCommandProcessor(commandInfo, context.EngineSessionState.CurrentScope.ScopeOrigin, !dotSource, commandSessionState);
                 }
@@ -323,8 +322,7 @@ namespace System.Management.Automation
                 markUntrustedData = ExecutionContext.IsMarkedAsUntrusted(splattedValue);
             }
 
-            IDictionary splattedTable = splattedValue as IDictionary;
-            if (splattedTable != null)
+            if (splattedValue is IDictionary splattedTable)
             {
                 foreach (DictionaryEntry de in splattedTable)
                 {
@@ -349,8 +347,7 @@ namespace System.Management.Automation
             }
             else
             {
-                IEnumerable enumerableValue = splattedValue as IEnumerable;
-                if (enumerableValue != null)
+                if (splattedValue is IEnumerable enumerableValue)
                 {
                     foreach (object obj in enumerableValue)
                     {
@@ -371,12 +368,11 @@ namespace System.Management.Automation
 
         private static CommandParameterInternal SplatEnumerableElement(object splattedArgument, Ast splatAst)
         {
-            var psObject = splattedArgument as PSObject;
-            if (psObject != null)
+            if (splattedArgument is PSObject psObject)
             {
                 var prop = psObject.Properties[ScriptParameterBinderController.NotePropertyNameForSplattingParametersInArgs];
                 var baseObj = psObject.BaseObject;
-                if (prop != null && prop.Value is string && baseObj is string)
+                if (prop?.Value is string && baseObj is string)
                 {
                     return CommandParameterInternal.CreateParameter((string)prop.Value, (string)baseObj, splatAst);
                 }
@@ -612,9 +608,7 @@ namespace System.Management.Automation
             {
                 return null;
             }
-
-            var objAsArray = obj as object[];
-            return objAsArray != null ? CheckAutomationNullInCommandArgumentArray(objAsArray) : obj;
+            return obj is object[] objAsArray ? CheckAutomationNullInCommandArgumentArray(objAsArray) : obj;
         }
 
         internal static object[] CheckAutomationNullInCommandArgumentArray(object[] objArray)
@@ -690,8 +684,7 @@ namespace System.Management.Automation
                     var commandParameters = new List<CommandParameterInternal>();
                     foreach (var commandElement in commandAst.CommandElements)
                     {
-                        var commandParameterAst = commandElement as CommandParameterAst;
-                        if (commandParameterAst != null)
+                        if (commandElement is CommandParameterAst commandParameterAst)
                         {
                             commandParameters.Add(GetCommandParameter(commandParameterAst, isTrusted, context));
                             continue;
@@ -776,8 +769,7 @@ namespace System.Management.Automation
 
         private static CommandRedirection GetCommandRedirection(RedirectionAst redirectionAst, bool isTrusted, ExecutionContext context)
         {
-            var fileRedirection = redirectionAst as FileRedirectionAst;
-            if (fileRedirection != null)
+            if (redirectionAst is FileRedirectionAst fileRedirection)
             {
                 object fileName = Compiler.GetExpressionValue(fileRedirection.Location, isTrusted, context);
                 return new FileRedirection(fileRedirection.FromStream, fileRedirection.Append, fileName.ToString());
@@ -1207,11 +1199,7 @@ namespace System.Management.Automation
                 throw;
             }
 
-            if (parentPipelineProcessor != null)
-            {
-                // I think this is only necessary for calling Dispose on the commands in the redirection pipe.
-                parentPipelineProcessor.AddRedirectionPipe(PipelineProcessor);
-            }
+            parentPipelineProcessor?.AddRedirectionPipe(PipelineProcessor);
 
             return new Pipe(context, PipelineProcessor);
         }
@@ -1227,10 +1215,7 @@ namespace System.Management.Automation
         internal void CallDoCompleteForExpression()
         {
             // The pipe returned from 'GetRedirectionPipe' could be a NullPipe
-            if (PipelineProcessor != null)
-            {
-                PipelineProcessor.DoComplete();
-            }
+            PipelineProcessor?.DoComplete();
         }
 
         private bool _disposed;
@@ -1248,10 +1233,7 @@ namespace System.Management.Automation
 
             if (disposing)
             {
-                if (PipelineProcessor != null)
-                {
-                    PipelineProcessor.Dispose();
-                }
+                PipelineProcessor?.Dispose();
             }
 
             _disposed = true;
@@ -1507,8 +1489,7 @@ namespace System.Management.Automation
                 //     CmdletInvocationException - to cover cmdlets like Invoke-Expression
                 if (current.Rank > 0)
                 {
-                    var apse = rte as ActionPreferenceStopException;
-                    if (apse != null)
+                    if (rte is ActionPreferenceStopException apse)
                     {
                         var exceptionToPass = apse.ErrorRecord.Exception;
 
@@ -1923,10 +1904,7 @@ namespace System.Management.Automation
 
             if (rte is not PipelineStoppedException)
             {
-                if (outputPipe != null)
-                {
-                    outputPipe.AppendVariableList(VariableStreamKind.Error, errRec);
-                }
+                outputPipe?.AppendVariableList(VariableStreamKind.Error, errRec);
 
                 context.AppendDollarError(errRec);
             }
@@ -1980,8 +1958,7 @@ namespace System.Management.Automation
         {
             result = PSObject.Base(result);
 
-            RuntimeException runtimeException = result as RuntimeException;
-            if (runtimeException != null)
+            if (result is RuntimeException runtimeException)
             {
                 InterpreterError.UpdateExceptionErrorRecordPosition(runtimeException, extent);
                 runtimeException.WasThrownFromThrowStatement = true;
@@ -1989,8 +1966,7 @@ namespace System.Management.Automation
                 return runtimeException;
             }
 
-            ErrorRecord er = result as ErrorRecord;
-            if (er != null)
+            if (result is ErrorRecord er)
             {
                 runtimeException = new RuntimeException(er.ToString(), er.Exception, er) { WasThrownFromThrowStatement = true, WasRethrown = rethrow };
                 InterpreterError.UpdateExceptionErrorRecordPosition(runtimeException, extent);
@@ -1998,8 +1974,7 @@ namespace System.Management.Automation
                 return runtimeException;
             }
 
-            Exception exception = result as Exception;
-            if (exception != null)
+            if (result is Exception exception)
             {
                 er = new ErrorRecord(exception, exception.Message, ErrorCategory.OperationStopped, null);
                 runtimeException = new RuntimeException(exception.Message, exception, er) { WasThrownFromThrowStatement = true, WasRethrown = rethrow };
@@ -2025,8 +2000,7 @@ namespace System.Management.Automation
             RuntimeException runtimeException = exception as RuntimeException;
             if (runtimeException == null)
             {
-                var icer = exception as IContainsErrorRecord;
-                var er = icer != null
+                var er = exception is IContainsErrorRecord icer
                              ? icer.ErrorRecord
                              : new ErrorRecord(exception, exception.GetType().FullName, ErrorCategory.OperationStopped, null);
                 runtimeException = new RuntimeException(exception.Message, exception, er);
@@ -2125,12 +2099,8 @@ namespace System.Management.Automation
                                                                    typeName.FullName, exception.Message);
                 }
 
-                // For better error messages, figure out exactly which type we couldn't resolve.
-                // We recurse and relying on one of the recursive calls to throw, or if none do,
-                // then we just throw on the top level typeName.
-
-                var genericTypeName = typeName as GenericTypeName;
-                if (genericTypeName != null)
+                // For better error messages, figure out exactly which type we couldn't resolve.                // We recurse and relying on one of the recursive calls to throw, or if none do,                // then we just throw on the top level typeName.
+                if (typeName is GenericTypeName genericTypeName)
                 {
                     var generic = genericTypeName.GetGenericType(ResolveTypeName(genericTypeName.TypeName, errorPos));
                     var typeArgs = (from arg in genericTypeName.GenericArguments select ResolveTypeName(arg, errorPos)).ToArray();
@@ -2149,9 +2119,7 @@ namespace System.Management.Automation
                     }
                 }
 
-                var arrayTypeName = typeName as ArrayTypeName;
-
-                if (arrayTypeName != null)
+                if (typeName is ArrayTypeName arrayTypeName)
                 {
                     ResolveTypeName(arrayTypeName.ElementType, errorPos);
                 }
@@ -2307,9 +2275,9 @@ namespace System.Management.Automation
                     foreach (var p in helperType.GetFields(BindingFlags.Static | BindingFlags.NonPublic))
                     {
                         var field = p.GetValue(null);
+
                         // field can be one of two types: SessionStateKeeper or ScriptBlockMemberMethodWrapper
-                        var methodWrapper = field as ScriptBlockMemberMethodWrapper;
-                        if (methodWrapper != null)
+                        if (field is ScriptBlockMemberMethodWrapper methodWrapper)
                         {
                             methodWrapper.InitAtRuntime();
                         }
@@ -2340,8 +2308,7 @@ namespace System.Management.Automation
                                                         string str,
                                                         ExecutionContext context)
         {
-            WildcardPattern wildcard = condition as WildcardPattern;
-            if (wildcard != null)
+            if (condition is WildcardPattern wildcard)
             {
                 // If case sensitivity doesn't agree between the existing wildcard pattern and the switch mode,
                 // make a new wildcard pattern that agrees with the switch.
@@ -2374,10 +2341,9 @@ namespace System.Management.Automation
             {
                 Match m;
 
-                Regex regex = condition as Regex;
                 // Check if the regex agrees with the switch w.r.t. case sensitivity, if not,
                 // we must build a new regex.
-                if (regex != null && (((regex.Options & RegexOptions.IgnoreCase) != 0) != caseSensitive))
+                if (condition is Regex regex && (((regex.Options & RegexOptions.IgnoreCase) != 0) != caseSensitive))
                 {
                     m = regex.Match(str);
                 }
@@ -2401,7 +2367,7 @@ namespace System.Management.Automation
 
                     if (groups.Count > 0)
                     {
-                        Diagnostics.Assert(regex != null, "Logic above ensures regex is not null.");
+                        Diagnostics.Assert(condition is Regex regex, "Logic above ensures regex is not null.");
 
                         Hashtable h = new Hashtable(StringComparer.CurrentCultureIgnoreCase);
 
@@ -2780,11 +2746,8 @@ namespace System.Management.Automation
 
             var context = Runspace.DefaultRunspace.ExecutionContext;
 
-            // If expression argument is a .Net type then convert the collection to that type
-            // if the target type is a collection or array, then the result will be a collection of exactly
-            // that type. If the target type is not a collection type then return a generic collection of that type.
-            Type targetType = expression as Type;
-            if (targetType != null)
+            // If expression argument is a .Net type then convert the collection to that type            // if the target type is a collection or array, then the result will be a collection of exactly            // that type. If the target type is not a collection type then return a generic collection of that type.
+            if (expression is Type targetType)
             {
                 dynamic resultCollection = null;
 
@@ -2852,8 +2815,8 @@ namespace System.Management.Automation
             // If the expression is a script block, it will be executed in the current scope
             // once on each element.
             var result = new Collection<PSObject>();
-            ScriptBlock sb = expression as ScriptBlock;
-            if (sb != null)
+
+            if (expression is ScriptBlock sb)
             {
                 Pipe outputPipe = new Pipe(result);
                 if (sb.HasBeginBlock)
@@ -2889,8 +2852,7 @@ namespace System.Management.Automation
                 {
                     object current = Current(enumerator);
                     object basedCurrent = PSObject.Base(current);
-                    Hashtable ht = basedCurrent as Hashtable;
-                    if (ht != null)
+                    if (basedCurrent is Hashtable ht)
                     {
                         // special case hashtables since we don't want to hit a method name
                         switch (numArgs)
@@ -2961,9 +2923,7 @@ namespace System.Management.Automation
                                         ParserStrings.ForEachNonexistentMemberReference, name);
                                 }
                             }
-
-                            var method = member as PSMethodInfo;
-                            if (method != null)
+                            if (member is PSMethodInfo method)
                             {
                                 // It's a method so check language modes to see if it's allowed.
 
@@ -3018,8 +2978,7 @@ namespace System.Management.Automation
 
         internal static object SlicingIndex(object target, IEnumerator indexes, Func<object, object, object> indexer)
         {
-            var fakeEnumerator = indexes as NonEnumerableObjectEnumerator;
-            if (fakeEnumerator != null)
+            if (indexes is NonEnumerableObjectEnumerator fakeEnumerator)
             {
                 // We have a non-enumerable object, we're trying to slice index with it.  It really should have
                 // been a single index, so we don't want to return an array, we just want to return the indexed value.
@@ -3150,8 +3109,7 @@ namespace System.Management.Automation
                 catch (TargetInvocationException tie)
                 {
                     // If we tried to invoke a method that didn't exist, then we'll try enumerating the object and call the method on it's members.
-                    RuntimeException rte = tie.InnerException as RuntimeException;
-                    if (rte != null && rte.ErrorRecord.FullyQualifiedErrorId.Equals(ParserOps.MethodNotFoundErrorId, StringComparison.Ordinal))
+                    if (tie.InnerException is RuntimeException rte && rte.ErrorRecord.FullyQualifiedErrorId.Equals(ParserOps.MethodNotFoundErrorId, StringComparison.Ordinal))
                     {
                         var nestedEnumerator = LanguagePrimitives.GetEnumerator(current);
                         if (nestedEnumerator != null)
@@ -3209,8 +3167,7 @@ namespace System.Management.Automation
 
         internal static object Multiply(IEnumerator enumerator, uint times)
         {
-            var fakeEnumerator = enumerator as NonEnumerableObjectEnumerator;
-            if (fakeEnumerator != null)
+            if (enumerator is NonEnumerableObjectEnumerator fakeEnumerator)
             {
                 // We have a non-enumerable object, we're trying to multiply something to it.  Generate an error
                 // (or on the off chance that there is an implicit op, call that).
@@ -3411,18 +3368,15 @@ namespace System.Management.Automation
 
         internal static object AddFakeEnumerable(NonEnumerableObjectEnumerator fakeEnumerator, object rhs)
         {
-            // We have a non-enumerable object, we're trying to add something to it.  Generate an error
-            // (or on the off chance that there is an implicit op, call that).
-            var fakeEnumerator2 = rhs as NonEnumerableObjectEnumerator;
+            // We have a non-enumerable object, we're trying to add something to it.  Generate an error            // (or on the off chance that there is an implicit op, call that).
             return ParserOps.ImplicitOp(fakeEnumerator.GetNonEnumerableObject(),
-                                        fakeEnumerator2 != null ? fakeEnumerator2.GetNonEnumerableObject() : rhs,
+                                        rhs is NonEnumerableObjectEnumerator fakeEnumerator2 ? fakeEnumerator2.GetNonEnumerableObject() : rhs,
                                         "op_Addition", null, "+");
         }
 
         internal static object AddEnumerable(ExecutionContext context, IEnumerator lhs, IEnumerator rhs)
         {
-            var fakeEnumerator = lhs as NonEnumerableObjectEnumerator;
-            if (fakeEnumerator != null)
+            if (lhs is NonEnumerableObjectEnumerator fakeEnumerator)
             {
                 return AddFakeEnumerable(fakeEnumerator, rhs);
             }
@@ -3444,8 +3398,7 @@ namespace System.Management.Automation
 
         internal static object AddObject(ExecutionContext context, IEnumerator lhs, object rhs)
         {
-            var fakeEnumerator = lhs as NonEnumerableObjectEnumerator;
-            if (fakeEnumerator != null)
+            if (lhs is NonEnumerableObjectEnumerator fakeEnumerator)
             {
                 return AddFakeEnumerable(fakeEnumerator, rhs);
             }
@@ -3464,8 +3417,7 @@ namespace System.Management.Automation
 
         internal static object Compare(IEnumerator enumerator, object valueToCompareTo, Func<object, object, bool> compareDelegate)
         {
-            var fakeEnumerator = enumerator as NonEnumerableObjectEnumerator;
-            if (fakeEnumerator != null)
+            if (enumerator is NonEnumerableObjectEnumerator fakeEnumerator)
             {
                 return compareDelegate(fakeEnumerator.GetNonEnumerableObject(), valueToCompareTo) ? Boxed.True : Boxed.False;
             }
@@ -3497,10 +3449,7 @@ namespace System.Management.Automation
                 if (dispose)
                 {
                     var disposable = enumerator as IDisposable;
-                    if (disposable != null)
-                    {
-                        disposable.Dispose();
-                    }
+                    disposable?.Dispose();
                 }
             }
         }
diff --git a/src/System.Management.Automation/engine/runtime/Operations/StringOps.cs b/src/System.Management.Automation/engine/runtime/Operations/StringOps.cs
index 0c4658cc1..77399551c 100644
--- a/src/System.Management.Automation/engine/runtime/Operations/StringOps.cs
+++ b/src/System.Management.Automation/engine/runtime/Operations/StringOps.cs
@@ -69,8 +69,7 @@ namespace System.Management.Automation
         {
             try
             {
-                object[] formatArgsArray = formatArgs as object[];
-                return formatArgsArray != null
+                return formatArgs is object[] formatArgsArray
                            ? StringUtil.Format(formatString, formatArgsArray)
                            : StringUtil.Format(formatString, formatArgs);
             }
diff --git a/src/System.Management.Automation/engine/runtime/ScriptBlockToPowerShell.cs b/src/System.Management.Automation/engine/runtime/ScriptBlockToPowerShell.cs
index 93394be68..4ac67dc77 100644
--- a/src/System.Management.Automation/engine/runtime/ScriptBlockToPowerShell.cs
+++ b/src/System.Management.Automation/engine/runtime/ScriptBlockToPowerShell.cs
@@ -620,8 +620,7 @@ namespace System.Management.Automation
             {
                 current = current.Parent;
 
-                var sbAst = current as ScriptBlockAst;
-                if (sbAst != null)
+                if (current is ScriptBlockAst sbAst)
                 {
                     // We find the closest parent ScriptBlockAst of the current UsingExpression, which represents the scope
                     // that the current UsingExpression is in.
@@ -643,8 +642,7 @@ namespace System.Management.Automation
                     return true;
                 }
 
-                var funcAst = current as FunctionDefinitionAst;
-                if (funcAst != null)
+                if (current is FunctionDefinitionAst funcAst)
                 {
                     // The parent chain of the current UsingExpression reaches a FunctionDefinitionAst, then the UsingExpression
                     // must be in 'Parameters' property of this FunctionDefinitionAst.
@@ -735,13 +733,11 @@ namespace System.Management.Automation
             // Now the parameters and arguments.
             foreach (var ast in commandAst.CommandElements.Skip(1))
             {
-                var exprAst = ast as ExpressionAst;
-                if (exprAst != null)
+                if (ast is ExpressionAst exprAst)
                 {
                     VariableExpressionAst variableAst = null;
 
-                    var usingExprAst = ast as UsingExpressionAst;
-                    if (usingExprAst != null)
+                    if (ast is UsingExpressionAst usingExprAst)
                     {
                         string usingAstKey = PsUtils.GetUsingExpressionKey(usingExprAst);
                         object usingValue = _usingValueMap[usingAstKey];
@@ -749,16 +745,14 @@ namespace System.Management.Automation
                         if (variableAst != null && variableAst.Splatted)
                         {
                             // Support the splatting of a dictionary
-                            var parameters = usingValue as System.Collections.IDictionary;
-                            if (parameters != null)
+                            if (usingValue is System.Collections.IDictionary parameters)
                             {
                                 _powershell.AddParameters(parameters);
                             }
                             else
                             {
                                 // Support the splatting of an array
-                                var arguments = usingValue as System.Collections.IEnumerable;
-                                if (arguments != null)
+                                if (usingValue is System.Collections.IEnumerable arguments)
                                 {
                                     foreach (object argument in arguments)
                                     {
@@ -787,9 +781,9 @@ namespace System.Management.Automation
                     }
                     else
                     {
-                        var constantExprAst = ast as ConstantExpressionAst;
                         object argument;
-                        if (constantExprAst != null
+
+                        if (ast is ConstantExpressionAst constantExprAst
                             && (LanguagePrimitives.IsNumeric(LanguagePrimitives.GetTypeCode(constantExprAst.StaticType))
                             || constantExprAst.StaticType == typeof(System.Numerics.BigInteger)))
                         {
@@ -838,9 +832,9 @@ namespace System.Management.Automation
 
         private string GetCommandName(CommandElementAst commandNameAst, bool isTrustedInput)
         {
-            var exprAst = commandNameAst as ExpressionAst;
             string commandName;
-            if (exprAst != null)
+
+            if (commandNameAst is ExpressionAst exprAst)
             {
                 var value = GetExpressionValue(exprAst, isTrustedInput);
                 if (value == null)
@@ -851,9 +845,9 @@ namespace System.Management.Automation
                         exprAst);
                 }
 
-                if (value is CommandInfo)
+                if (value is CommandInfo commandInfo)
                 {
-                    commandName = ((CommandInfo)value).Name;
+                    commandName = commandInfo.Name;
                 }
                 else
                 {
diff --git a/src/System.Management.Automation/engine/scriptparameterbinder.cs b/src/System.Management.Automation/engine/scriptparameterbinder.cs
index d5d1dfbc6..4bdb9c1c4 100644
--- a/src/System.Management.Automation/engine/scriptparameterbinder.cs
+++ b/src/System.Management.Automation/engine/scriptparameterbinder.cs
@@ -143,8 +143,7 @@ namespace System.Management.Automation
         {
             object result = parameter.Value;
 
-            var compiledDefault = result as Compiler.DefaultValueExpressionWrapper;
-            if (compiledDefault != null)
+            if (result is Compiler.DefaultValueExpressionWrapper compiledDefault)
             {
                 result = compiledDefault.GetValue(Context, Script.SessionStateInternal, implicitUsingParameters);
             }
diff --git a/src/System.Management.Automation/engine/serialization.cs b/src/System.Management.Automation/engine/serialization.cs
index b4115de05..e61b5fbe5 100644
--- a/src/System.Management.Automation/engine/serialization.cs
+++ b/src/System.Management.Automation/engine/serialization.cs
@@ -695,8 +695,7 @@ namespace System.Management.Automation
                 return false;
             }
 
-            PSObject pso = o as PSObject;
-            if (pso != null)
+            if (o is PSObject pso)
             {
                 IEnumerable<string> typeNames = pso.InternalTypeNames;
                 if (typeNames != null)
@@ -1173,8 +1172,8 @@ namespace System.Management.Automation
             Dbg.Assert(source != null, "caller should validate the parameter");
 
             bool sourceHandled = false;
-            PSObject moSource = source as PSObject;
-            if (moSource != null && !moSource.ImmediateBaseObjectIsEmpty)
+
+            if (source is PSObject moSource && !moSource.ImmediateBaseObjectIsEmpty)
             {
                 // Check if baseObject is primitive known type
                 object baseObject = moSource.ImmediateBaseObject;
@@ -1200,18 +1199,17 @@ namespace System.Management.Automation
             Dbg.Assert(source != null, "caller should validate the parameter");
 
             ContainerType ct = ContainerType.None;
-            PSObject mshSource = source as PSObject;
             IEnumerable enumerable = null;
             IDictionary dictionary = null;
 
             // If passed in object is PSObject with no baseobject, return false.
-            if (mshSource != null && mshSource.ImmediateBaseObjectIsEmpty)
+            if (source is PSObject mshSource && mshSource.ImmediateBaseObjectIsEmpty)
             {
                 return false;
             }
 
             // Check if source (or baseobject in mshSource) is known container type
-            SerializationUtilities.GetKnownContainerTypeInfo(mshSource != null ? mshSource.ImmediateBaseObject : source, out ct,
+            SerializationUtilities.GetKnownContainerTypeInfo(source is PSObject mshSource ? mshSource.ImmediateBaseObject : source, out ct,
                                       out dictionary, out enumerable);
 
             if (ct == ContainerType.None)
@@ -1254,7 +1252,7 @@ namespace System.Management.Automation
                 // So on roundtrip it will show up as List.
                 // We serialize properties of enumerable and on deserialization mark the object as Deserialized.
                 // So if object is marked deserialized, we should write properties.
-                if (ct == ContainerType.Enumerable || (mshSource != null && mshSource.IsDeserialized))
+                if (ct == ContainerType.Enumerable || (source is PSObject mshSource && mshSource.IsDeserialized))
                 {
                     PSObject sourceAsPSObject = PSObject.AsPSObject(source);
                     PSMemberInfoInternalCollection<PSPropertyInfo> specificPropertiesToSerialize = SerializationUtilities.GetSpecificPropertiesToSerialize(sourceAsPSObject, AllPropertiesCollection, _typeTable);
@@ -1262,7 +1260,7 @@ namespace System.Management.Automation
                     SerializeExtendedProperties(sourceAsPSObject, depth, specificPropertiesToSerialize);
                 }
                 // always serialize instance properties if there are any
-                else if (mshSource != null)
+                else if (source is PSObject mshSource)
                 {
                     SerializeInstanceProperties(mshSource, depth);
                 }
@@ -1466,23 +1464,20 @@ namespace System.Management.Automation
             {
                 do // false loop
                 {
-                    CimInstance cimInstance = mshSource.ImmediateBaseObject as CimInstance;
-                    if (cimInstance != null)
+                    if (mshSource.ImmediateBaseObject is CimInstance cimInstance)
                     {
                         isCimInstance = true;
                         break;
                     }
 
-                    ErrorRecord errorRecord = mshSource.ImmediateBaseObject as ErrorRecord;
-                    if (errorRecord != null)
+                    if (mshSource.ImmediateBaseObject is ErrorRecord errorRecord)
                     {
                         errorRecord.ToPSObjectForRemoting(mshSource);
                         isErrorRecord = true;
                         break;
                     }
 
-                    InformationalRecord informationalRecord = mshSource.ImmediateBaseObject as InformationalRecord;
-                    if (informationalRecord != null)
+                    if (mshSource.ImmediateBaseObject is InformationalRecord informationalRecord)
                     {
                         informationalRecord.ToPSObjectForRemoting(mshSource);
                         isInformationalRecord = true;
@@ -1534,7 +1529,6 @@ namespace System.Management.Automation
 
             if (isCimInstance)
             {
-                CimInstance cimInstance = mshSource.ImmediateBaseObject as CimInstance;
                 PrepareCimInstanceForSerialization(mshSource, cimInstance);
             }
 
@@ -3208,8 +3202,7 @@ namespace System.Management.Automation
 
             if (deserializedProperty.Name.Equals(RemotingConstants.ComputerNameNoteProperty, StringComparison.OrdinalIgnoreCase))
             {
-                string psComputerNameValue = deserializedProperty.Value as string;
-                if (psComputerNameValue != null)
+                if (deserializedProperty.Value is string psComputerNameValue)
                 {
                     cimInstance.SetCimSessionComputerName(psComputerNameValue);
                 }
@@ -3364,9 +3357,9 @@ namespace System.Management.Automation
                     return null;
                 }
 
-                if (hashCodeObject is PSObject)
+                if (hashCodeObject is PSObject pSObject)
                 {
-                    hashCodeObject = ((PSObject)hashCodeObject).BaseObject;
+                    hashCodeObject = pSObject.BaseObject;
                 }
 
                 if (hashCodeObject is not int)
@@ -3449,13 +3442,10 @@ namespace System.Management.Automation
 
             // process __InstanceMetadata
             HashSet<string> namesOfModifiedProperties = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
-            PSPropertyInfo instanceMetadataProperty = deserializedObject.InstanceMembers[CimInstanceMetadataProperty] as PSPropertyInfo;
-            if ((instanceMetadataProperty != null) && (instanceMetadataProperty.Value != null))
+            if ((deserializedObject.InstanceMembers[CimInstanceMetadataProperty] is PSPropertyInfo instanceMetadataProperty) && (instanceMetadataProperty.Value != null))
             {
                 PSObject instanceMetadata = PSObject.AsPSObject(instanceMetadataProperty.Value);
-
-                PSPropertyInfo modifiedPropertiesProperty = instanceMetadata.InstanceMembers[CimModifiedProperties] as PSPropertyInfo;
-                if ((modifiedPropertiesProperty != null) && (modifiedPropertiesProperty.Value != null))
+                if ((instanceMetadata.InstanceMembers[CimModifiedProperties] is PSPropertyInfo modifiedPropertiesProperty) && (modifiedPropertiesProperty.Value != null))
                 {
                     string modifiedPropertiesString = modifiedPropertiesProperty.Value.ToString();
                     foreach (string nameOfModifiedProperty in modifiedPropertiesString.Split(Utils.Separators.Space))
@@ -3700,8 +3690,7 @@ namespace System.Management.Automation
 
             ReadEndElement();
 
-            PSObject immediateBasePso = dso.ImmediateBaseObject as PSObject;
-            if (immediateBasePso != null)
+            if (dso.ImmediateBaseObject is PSObject immediateBasePso)
             {
                 PSObject.CopyDeserializerFields(source: immediateBasePso, target: dso);
             }
@@ -4879,8 +4868,8 @@ namespace System.Management.Automation
             string message = StringUtil.Format(resourceString, args);
 
             XmlException ex = null;
-            IXmlLineInfo xmlLineInfo = _reader as IXmlLineInfo;
-            if (xmlLineInfo != null)
+
+            if (_reader is IXmlLineInfo xmlLineInfo)
             {
                 if (xmlLineInfo.HasLineInfo())
                 {
@@ -5587,14 +5576,13 @@ namespace System.Management.Automation
                 return null;
             }
 
-            PSAliasProperty alias = property as PSAliasProperty;
-            if (alias != null)
+            if (property is PSAliasProperty alias)
             {
                 property = alias.ReferencedMember as PSPropertyInfo;
             }
 
             PSScriptProperty script = property as PSScriptProperty;
-            Dbg.Assert(script == null || script.GetterScript != null, "scriptProperty.IsGettable => (scriptProperty.GetterScript != null)");
+            Dbg.Assert(script?.GetterScript != null, "scriptProperty.IsGettable => (scriptProperty.GetterScript != null)");
             if ((script != null) && (!canUseDefaultRunspaceInThreadSafeManner))
             {
                 PSEtwLog.LogAnalyticWarning(
@@ -7004,9 +6992,9 @@ namespace Microsoft.PowerShell
                     // an exception
                     message = PSObject.AsPSObject(propertyValue).Properties["Message"].Value as string;
                 }
-                else if (propertyValue is Exception)
+                else if (propertyValue is Exception exception)
                 {
-                    reason = (Exception)propertyValue;
+                    reason = exception;
                 }
                 else
                 {
@@ -7037,7 +7025,7 @@ namespace Microsoft.PowerShell
             JobStateInfo previousJobStateInfo = null;
             var previousJobStateInfoProperty = pso.Properties["PreviousJobStateInfo"];
 
-            if (previousJobStateInfoProperty != null && previousJobStateInfoProperty.Value != null)
+            if (previousJobStateInfoProperty?.Value != null)
             {
                 previousJobStateInfo = RehydrateJobStateInfo(PSObject.AsPSObject(previousJobStateInfoProperty.Value));
             }
@@ -7156,8 +7144,7 @@ namespace Microsoft.PowerShell
             Collection<Breakpoint> breakpoints = new Collection<Breakpoint>();
             foreach (var item in GetPropertyValue<ArrayList>(pso, "Breakpoints"))
             {
-                Breakpoint bp = item as Breakpoint;
-                if (bp != null)
+                if (item is Breakpoint bp)
                 {
                     breakpoints.Add(bp);
                 }
diff --git a/src/System.Management.Automation/help/AliasHelpProvider.cs b/src/System.Management.Automation/help/AliasHelpProvider.cs
index f14f81589..a0012bd9a 100644
--- a/src/System.Management.Automation/help/AliasHelpProvider.cs
+++ b/src/System.Management.Automation/help/AliasHelpProvider.cs
@@ -196,9 +196,7 @@ namespace System.Management.Automation
                         yield break;
                     }
 
-                    AliasInfo alias = current as AliasInfo;
-
-                    if (alias != null)
+                    if (current is AliasInfo alias)
                     {
                         string name = alias.Name;
                         HelpRequest exactMatchHelpRequest = helpRequest.Clone();
@@ -235,9 +233,7 @@ namespace System.Management.Automation
                         yield break;
                     }
 
-                    AliasInfo alias = current as AliasInfo;
-
-                    if (alias != null)
+                    if (current is AliasInfo alias)
                     {
                         string name = alias.Name;
 
diff --git a/src/System.Management.Automation/help/BaseCommandHelpInfo.cs b/src/System.Management.Automation/help/BaseCommandHelpInfo.cs
index 0c70b8159..0d82ae546 100644
--- a/src/System.Management.Automation/help/BaseCommandHelpInfo.cs
+++ b/src/System.Management.Automation/help/BaseCommandHelpInfo.cs
@@ -203,8 +203,7 @@ namespace System.Management.Automation
             string moduleName = string.Empty;
             if (this.FullHelp.Properties["ModuleName"] != null)
             {
-                PSNoteProperty moduleNameNP = this.FullHelp.Properties["ModuleName"] as PSNoteProperty;
-                if (moduleNameNP != null)
+                if (this.FullHelp.Properties["ModuleName"] is PSNoteProperty moduleNameNP)
                 {
                     LanguagePrimitives.TryConvertTo<string>(moduleNameNP.Value, CultureInfo.InvariantCulture,
                                                             out moduleName);
@@ -305,8 +304,8 @@ namespace System.Management.Automation
                 }
 
                 PSObject navigationLink = PSObject.AsPSObject(navigationLinkAsObject);
-                PSNoteProperty uriNP = navigationLink.Properties["uri"] as PSNoteProperty;
-                if (uriNP != null)
+
+                if (navigationLink.Properties["uri"] is PSNoteProperty uriNP)
                 {
                     string uriString = string.Empty;
                     LanguagePrimitives.TryConvertTo<string>(uriNP.Value, CultureInfo.InvariantCulture, out uriString);
diff --git a/src/System.Management.Automation/help/CabinetNativeApi.cs b/src/System.Management.Automation/help/CabinetNativeApi.cs
index 76e8fe853..9abe5a894 100644
--- a/src/System.Management.Automation/help/CabinetNativeApi.cs
+++ b/src/System.Management.Automation/help/CabinetNativeApi.cs
@@ -70,10 +70,7 @@ namespace System.Management.Automation.Internal
             }
 
             // Free managed objects within 'if (disposing)' if needed
-            if (fdiContext != null)
-            {
-                fdiContext.Dispose();
-            }
+            fdiContext?.Dispose();
             // Free unmanaged objects here
             this.CleanUpDelegates();
 
diff --git a/src/System.Management.Automation/help/DefaultCommandHelpObjectBuilder.cs b/src/System.Management.Automation/help/DefaultCommandHelpObjectBuilder.cs
index 34b1bd84c..c9e4ce48e 100644
--- a/src/System.Management.Automation/help/DefaultCommandHelpObjectBuilder.cs
+++ b/src/System.Management.Automation/help/DefaultCommandHelpObjectBuilder.cs
@@ -758,24 +758,19 @@ namespace System.Management.Automation.Help
                 navigationLinkObj.Properties.Add(new PSNoteProperty("uri", relatedLink));
 
                 List<PSObject> navigationLinkValues = new List<PSObject> { navigationLinkObj };
-
                 // check if obj already has relatedLinks property
-                PSNoteProperty relatedLinksPO = obj.Properties["relatedLinks"] as PSNoteProperty;
-                if ((relatedLinksPO != null) && (relatedLinksPO.Value != null))
+                if ((obj.Properties["relatedLinks"] is PSNoteProperty relatedLinksPO) && (relatedLinksPO.Value != null))
                 {
                     PSObject relatedLinksValue = PSObject.AsPSObject(relatedLinksPO.Value);
-                    PSNoteProperty navigationLinkPO = relatedLinksValue.Properties["navigationLink"] as PSNoteProperty;
-                    if ((navigationLinkPO != null) && (navigationLinkPO.Value != null))
+                    if ((relatedLinksValue.Properties["navigationLink"] is PSNoteProperty navigationLinkPO) && (navigationLinkPO.Value != null))
                     {
-                        PSObject navigationLinkValue = navigationLinkPO.Value as PSObject;
-                        if (navigationLinkValue != null)
+                        if (navigationLinkPO.Value is PSObject navigationLinkValue)
                         {
                             navigationLinkValues.Add(navigationLinkValue);
                         }
                         else
                         {
-                            PSObject[] navigationLinkValueArray = navigationLinkPO.Value as PSObject[];
-                            if (navigationLinkValueArray != null)
+                            if (navigationLinkPO.Value is PSObject[] navigationLinkValueArray)
                             {
                                 foreach (var psObject in navigationLinkValueArray)
                                 {
@@ -807,9 +802,7 @@ namespace System.Management.Automation.Help
 
             foreach (Attribute attribute in attributes)
             {
-                ParameterAttribute paramAttribute = (object)attribute as ParameterAttribute;
-
-                if (paramAttribute != null)
+                if ((object)attribute is ParameterAttribute paramAttribute)
                 {
                     paramAttributes.Add(paramAttribute);
                 }
@@ -829,9 +822,7 @@ namespace System.Management.Automation.Help
 
             foreach (Attribute attribute in attributes)
             {
-                ValidateSetAttribute validateSetAttribute = (object)attribute as ValidateSetAttribute;
-
-                if (validateSetAttribute != null)
+                if ((object)attribute is ValidateSetAttribute validateSetAttribute)
                 {
                     validateSetAttributes.Add(validateSetAttribute);
                 }
diff --git a/src/System.Management.Automation/help/HelpFileHelpProvider.cs b/src/System.Management.Automation/help/HelpFileHelpProvider.cs
index 8900a7167..acccdb02c 100644
--- a/src/System.Management.Automation/help/HelpFileHelpProvider.cs
+++ b/src/System.Management.Automation/help/HelpFileHelpProvider.cs
@@ -247,9 +247,7 @@ namespace System.Management.Automation
                     }
                 }
 
-                HelpFileHelpInfo helpInfo = GetCache(file) as HelpFileHelpInfo;
-
-                if (helpInfo != null)
+                if (GetCache(file) is HelpFileHelpInfo helpInfo)
                 {
                     if (searchOnlyContent)
                     {
diff --git a/src/System.Management.Automation/help/MamlClassHelpInfo.cs b/src/System.Management.Automation/help/MamlClassHelpInfo.cs
index 042ab21e7..909e2b924 100644
--- a/src/System.Management.Automation/help/MamlClassHelpInfo.cs
+++ b/src/System.Management.Automation/help/MamlClassHelpInfo.cs
@@ -97,7 +97,7 @@ namespace System.Management.Automation
                 string tempName = string.Empty;
                 var title = _fullHelpObject.Properties["title"];
 
-                if (title != null && title.Value != null)
+                if (title?.Value != null)
                 {
                     tempName = title.Value.ToString();
                 }
@@ -113,7 +113,7 @@ namespace System.Management.Automation
                 string tempSynopsis = string.Empty;
                 var intro = _fullHelpObject.Properties["introduction"];
 
-                if (intro != null && intro.Value != null)
+                if (intro?.Value != null)
                 {
                     tempSynopsis = intro.Value.ToString();
                 }
diff --git a/src/System.Management.Automation/help/SaveHelpCommand.cs b/src/System.Management.Automation/help/SaveHelpCommand.cs
index 94803728c..433be6e80 100644
--- a/src/System.Management.Automation/help/SaveHelpCommand.cs
+++ b/src/System.Management.Automation/help/SaveHelpCommand.cs
@@ -260,10 +260,7 @@ namespace Microsoft.PowerShell.Commands
                 }
                 finally
                 {
-                    if (helpInfoDrive != null)
-                    {
-                        helpInfoDrive.Dispose();
-                    }
+                    helpInfoDrive?.Dispose();
                 }
             }
 
@@ -407,10 +404,7 @@ namespace Microsoft.PowerShell.Commands
                         }
                         finally
                         {
-                            if (helpContentDrive != null)
-                            {
-                                helpContentDrive.Dispose();
-                            }
+                            helpContentDrive?.Dispose();
                         }
                     }
                 }
@@ -431,8 +425,7 @@ namespace Microsoft.PowerShell.Commands
             object argument = PSObject.Base(inputData);
 
             // deal with scalar string argument
-            var strArg = argument as string;
-            if (strArg != null)
+            if (argument is string strArg)
             {
                 return new PSModuleInfo(name: strArg, path: null, context: null, sessionState: null);
             }
@@ -453,9 +446,9 @@ namespace Microsoft.PowerShell.Commands
                     {
                         target.SetValue(elementValue, targetIndex++);
                     }
-                    else if (elementValue is string)
+                    else if (elementValue is string s)
                     {
-                        var elementAsModuleObj = new PSModuleInfo(name: (string)elementValue, path: null, context: null, sessionState: null);
+                        var elementAsModuleObj = new PSModuleInfo(s, path: null, context: null, sessionState: null);
                         target.SetValue(elementAsModuleObj, targetIndex++);
                     }
                     else
diff --git a/src/System.Management.Automation/help/UpdatableHelpCommandBase.cs b/src/System.Management.Automation/help/UpdatableHelpCommandBase.cs
index 49d1e67e5..3f74918c6 100644
--- a/src/System.Management.Automation/help/UpdatableHelpCommandBase.cs
+++ b/src/System.Management.Automation/help/UpdatableHelpCommandBase.cs
@@ -841,9 +841,9 @@ namespace Microsoft.PowerShell.Commands
         {
             UpdatableHelpSystemException except = null;
 
-            if (e is UpdatableHelpSystemException)
+            if (e is UpdatableHelpSystemException updatableHelpSystemException)
             {
-                except = (UpdatableHelpSystemException)e;
+                except = updatableHelpSystemException;
             }
 #if !CORECLR
             else if (e is WebException)
diff --git a/src/System.Management.Automation/help/UpdateHelpCommand.cs b/src/System.Management.Automation/help/UpdateHelpCommand.cs
index 01b17cbad..371a73214 100644
--- a/src/System.Management.Automation/help/UpdateHelpCommand.cs
+++ b/src/System.Management.Automation/help/UpdateHelpCommand.cs
@@ -322,10 +322,7 @@ namespace Microsoft.PowerShell.Commands
                 }
                 finally
                 {
-                    if (helpInfoDrive != null)
-                    {
-                        helpInfoDrive.Dispose();
-                    }
+                    helpInfoDrive?.Dispose();
                 }
             }
             else
diff --git a/src/System.Management.Automation/logging/LogProvider.cs b/src/System.Management.Automation/logging/LogProvider.cs
index a46f181b2..8de170cba 100644
--- a/src/System.Management.Automation/logging/LogProvider.cs
+++ b/src/System.Management.Automation/logging/LogProvider.cs
@@ -169,9 +169,7 @@ namespace System.Management.Automation
         {
             sb.AppendLine(StringUtil.Format(EtwLoggingStrings.ErrorRecordMessage, except.Message));
 
-            IContainsErrorRecord ier = except as IContainsErrorRecord;
-
-            if (ier != null)
+            if (except is IContainsErrorRecord ier)
             {
                 ErrorRecord er = ier.ErrorRecord;
 
diff --git a/src/System.Management.Automation/logging/MshLog.cs b/src/System.Management.Automation/logging/MshLog.cs
index 02a8990bc..78997479a 100644
--- a/src/System.Management.Automation/logging/MshLog.cs
+++ b/src/System.Management.Automation/logging/MshLog.cs
@@ -217,7 +217,7 @@ namespace System.Management.Automation
 
             InvocationInfo invocationInfo = null;
             IContainsErrorRecord icer = exception as IContainsErrorRecord;
-            if (icer != null && icer.ErrorRecord != null)
+            if (icer?.ErrorRecord != null)
                 invocationInfo = icer.ErrorRecord.InvocationInfo;
             foreach (LogProvider provider in GetLogProvider(executionContext))
             {
@@ -419,7 +419,7 @@ namespace System.Management.Automation
 
             InvocationInfo invocationInfo = null;
             IContainsErrorRecord icer = exception as IContainsErrorRecord;
-            if (icer != null && icer.ErrorRecord != null)
+            if (icer?.ErrorRecord != null)
                 invocationInfo = icer.ErrorRecord.InvocationInfo;
             foreach (LogProvider provider in GetLogProvider(executionContext))
             {
@@ -611,7 +611,7 @@ namespace System.Management.Automation
 
             InvocationInfo invocationInfo = null;
             IContainsErrorRecord icer = exception as IContainsErrorRecord;
-            if (icer != null && icer.ErrorRecord != null)
+            if (icer?.ErrorRecord != null)
                 invocationInfo = icer.ErrorRecord.InvocationInfo;
             foreach (LogProvider provider in GetLogProvider(executionContext))
             {
@@ -809,9 +809,7 @@ namespace System.Management.Automation
                 logContext.User = Logging.UnknownUserName;
             }
 
-            System.Management.Automation.Remoting.PSSenderInfo psSenderInfo =
-                    executionContext.SessionState.PSVariable.GetValue("PSSenderInfo") as System.Management.Automation.Remoting.PSSenderInfo;
-            if (psSenderInfo != null)
+            if (                    executionContext.SessionState.PSVariable.GetValue("PSSenderInfo") is System.Management.Automation.Remoting.PSSenderInfo psSenderInfo)
             {
                 logContext.ConnectedUser = psSenderInfo.UserInfo.Identity.Name;
             }
diff --git a/src/System.Management.Automation/namespaces/AliasProvider.cs b/src/System.Management.Automation/namespaces/AliasProvider.cs
index 8782a0d9b..e653158eb 100644
--- a/src/System.Management.Automation/namespaces/AliasProvider.cs
+++ b/src/System.Management.Automation/namespaces/AliasProvider.cs
@@ -154,8 +154,7 @@ namespace Microsoft.PowerShell.Commands
 
             object value = item;
 
-            AliasInfo aliasInfo = item as AliasInfo;
-            if (aliasInfo != null)
+            if (item is AliasInfo aliasInfo)
             {
                 value = aliasInfo.Definition;
             }
@@ -195,10 +194,7 @@ namespace Microsoft.PowerShell.Commands
                 {
                     item = (AliasInfo)GetSessionStateItem(name);
 
-                    if (item != null)
-                    {
-                        item.SetOptions(dynamicParameters.Options, Force);
-                    }
+                    item?.SetOptions(dynamicParameters.Options, Force);
                 }
                 else
                 {
@@ -209,8 +205,7 @@ namespace Microsoft.PowerShell.Commands
             {
                 do // false loop
                 {
-                    string stringValue = value as string;
-                    if (stringValue != null)
+                    if (value is string stringValue)
                     {
                         if (dynamicParametersSpecified)
                         {
@@ -224,8 +219,7 @@ namespace Microsoft.PowerShell.Commands
                         break;
                     }
 
-                    AliasInfo alias = value as AliasInfo;
-                    if (alias != null)
+                    if (value is AliasInfo alias)
                     {
                         AliasInfo newAliasInfo =
                             new AliasInfo(
@@ -295,8 +289,7 @@ namespace Microsoft.PowerShell.Commands
         {
             bool result = false;
 
-            AliasInfo aliasInfo = item as AliasInfo;
-            if (aliasInfo != null)
+            if (item is AliasInfo aliasInfo)
             {
                 if ((aliasInfo.Options & ScopedItemOptions.Constant) != 0 ||
                     ((aliasInfo.Options & ScopedItemOptions.ReadOnly) != 0 && !Force))
diff --git a/src/System.Management.Automation/namespaces/CoreCommandContext.cs b/src/System.Management.Automation/namespaces/CoreCommandContext.cs
index 5446b6b71..d7260a136 100644
--- a/src/System.Management.Automation/namespaces/CoreCommandContext.cs
+++ b/src/System.Management.Automation/namespaces/CoreCommandContext.cs
@@ -776,10 +776,7 @@ namespace System.Management.Automation
         /// </param>
         internal void WriteVerbose(string text)
         {
-            if (_command != null)
-            {
-                _command.WriteVerbose(text);
-            }
+            _command?.WriteVerbose(text);
         }
 
         /// <summary>
@@ -790,18 +787,12 @@ namespace System.Management.Automation
         /// </param>
         internal void WriteWarning(string text)
         {
-            if (_command != null)
-            {
-                _command.WriteWarning(text);
-            }
+            _command?.WriteWarning(text);
         }
 
         internal void WriteProgress(ProgressRecord record)
         {
-            if (_command != null)
-            {
-                _command.WriteProgress(record);
-            }
+            _command?.WriteProgress(record);
         }
 
         /// <summary>
@@ -812,26 +803,17 @@ namespace System.Management.Automation
         /// </param>
         internal void WriteDebug(string text)
         {
-            if (_command != null)
-            {
-                _command.WriteDebug(text);
-            }
+            _command?.WriteDebug(text);
         }
 
         internal void WriteInformation(InformationRecord record)
         {
-            if (_command != null)
-            {
-                _command.WriteInformation(record);
-            }
+            _command?.WriteInformation(record);
         }
 
         internal void WriteInformation(object messageData, string[] tags)
         {
-            if (_command != null)
-            {
-                _command.WriteInformation(messageData, tags);
-            }
+            _command?.WriteInformation(messageData, tags);
         }
 
         #endregion User feedback mechanisms
@@ -1154,14 +1136,7 @@ namespace System.Management.Automation
         {
             Stopping = true;
 
-            if (_providerInstance != null)
-            {
-                // We don't need to catch any of the exceptions here because
-                // we are terminating the pipeline and any exception will
-                // be caught by the engine.
-
-                _providerInstance.StopProcessing();
-            }
+            _providerInstance?.StopProcessing();
 
             // Call the stop referrals if any
 
diff --git a/src/System.Management.Automation/namespaces/EnvironmentProvider.cs b/src/System.Management.Automation/namespaces/EnvironmentProvider.cs
index 1ea71d1b1..22a12dde8 100644
--- a/src/System.Management.Automation/namespaces/EnvironmentProvider.cs
+++ b/src/System.Management.Automation/namespaces/EnvironmentProvider.cs
@@ -121,9 +121,9 @@ namespace Microsoft.PowerShell.Commands
                 // an item for this provider. If so, use the value from
                 // the dictionary entry.
 
-                if (value is DictionaryEntry)
+                if (value is DictionaryEntry dictionaryEntry)
                 {
-                    value = ((DictionaryEntry)value).Value;
+                    value = dictionaryEntry.Value;
                 }
 
                 string stringValue = value as string;
@@ -234,9 +234,9 @@ namespace Microsoft.PowerShell.Commands
 
             object value = item;
 
-            if (item is DictionaryEntry)
+            if (item is DictionaryEntry dictionaryEntry)
             {
-                value = ((DictionaryEntry)item).Value;
+                value = dictionaryEntry.Value;
             }
 
             return value;
diff --git a/src/System.Management.Automation/namespaces/FileSystemContentStream.cs b/src/System.Management.Automation/namespaces/FileSystemContentStream.cs
index f5d299ecf..d475c7f72 100644
--- a/src/System.Management.Automation/namespaces/FileSystemContentStream.cs
+++ b/src/System.Management.Automation/namespaces/FileSystemContentStream.cs
@@ -987,9 +987,9 @@ namespace Microsoft.PowerShell.Commands
 
             // Seek to the place we last left off.
             _stream.Seek(_fileOffset, SeekOrigin.Begin);
-            if (_reader != null) { _reader.DiscardBufferedData(); }
+            _reader?.DiscardBufferedData();
 
-            if (_backReader != null) { _backReader.DiscardBufferedData(); }
+            _backReader?.DiscardBufferedData();
         }
 
         /// <summary>
@@ -1003,15 +1003,15 @@ namespace Microsoft.PowerShell.Commands
         /// </param>
         public void Seek(long offset, SeekOrigin origin)
         {
-            if (_writer != null) { _writer.Flush(); }
+            _writer?.Flush();
 
             _stream.Seek(offset, origin);
 
-            if (_writer != null) { _writer.Flush(); }
+            _writer?.Flush();
 
-            if (_reader != null) { _reader.DiscardBufferedData(); }
+            _reader?.DiscardBufferedData();
 
-            if (_backReader != null) { _backReader.DiscardBufferedData(); }
+            _backReader?.DiscardBufferedData();
         }
 
         /// <summary>
@@ -1072,8 +1072,7 @@ namespace Microsoft.PowerShell.Commands
         {
             foreach (object line in content)
             {
-                object[] contentArray = line as object[];
-                if (contentArray != null)
+                if (line is object[] contentArray)
                 {
                     foreach (object obj in contentArray)
                     {
diff --git a/src/System.Management.Automation/namespaces/FileSystemProvider.cs b/src/System.Management.Automation/namespaces/FileSystemProvider.cs
index db619e3d1..f4e398986 100644
--- a/src/System.Management.Automation/namespaces/FileSystemProvider.cs
+++ b/src/System.Management.Automation/namespaces/FileSystemProvider.cs
@@ -252,8 +252,8 @@ namespace Microsoft.PowerShell.Commands
         internal override bool IsFilterSet()
         {
             bool attributeFilterSet = false;
-            GetChildDynamicParameters fspDynamicParam = DynamicParameters as GetChildDynamicParameters;
-            if (fspDynamicParam != null)
+
+            if (DynamicParameters is GetChildDynamicParameters fspDynamicParam)
             {
                 attributeFilterSet = (
                     (fspDynamicParam.Attributes != null)
@@ -1388,8 +1388,8 @@ namespace Microsoft.PowerShell.Commands
 
             FlagsExpression<FileAttributes> evaluator = null;
             FlagsExpression<FileAttributes> switchEvaluator = null;
-            GetChildDynamicParameters fspDynamicParam = DynamicParameters as GetChildDynamicParameters;
-            if (fspDynamicParam != null)
+
+            if (DynamicParameters is GetChildDynamicParameters fspDynamicParam)
             {
                 evaluator = fspDynamicParam.Attributes;
                 switchEvaluator = FormatAttributeSwitchParameters();
@@ -1651,8 +1651,7 @@ namespace Microsoft.PowerShell.Commands
 
                     if (recurse)
                     {
-                        GetChildDynamicParameters fspDynamicParam = DynamicParameters as GetChildDynamicParameters;
-                        if (fspDynamicParam != null && fspDynamicParam.FollowSymlink)
+                        if (DynamicParameters is GetChildDynamicParameters fspDynamicParam && fspDynamicParam.FollowSymlink)
                         {
                             tracker = new InodeTracker(fsinfo.FullName);
                         }
@@ -1665,8 +1664,8 @@ namespace Microsoft.PowerShell.Commands
                 {
                     FlagsExpression<FileAttributes> evaluator = null;
                     FlagsExpression<FileAttributes> switchEvaluator = null;
-                    GetChildDynamicParameters fspDynamicParam = DynamicParameters as GetChildDynamicParameters;
-                    if (fspDynamicParam != null)
+
+                    if (DynamicParameters is GetChildDynamicParameters fspDynamicParam)
                     {
                         evaluator = fspDynamicParam.Attributes;
                         switchEvaluator = FormatAttributeSwitchParameters();
@@ -1735,8 +1734,7 @@ namespace Microsoft.PowerShell.Commands
 
             try
             {
-                if (Filter != null &&
-                    Filter.Length > 0)
+                if (!string.IsNullOrEmpty(Filter))
                 {
                     if (returnContainers == ReturnContainers.ReturnAllContainers)
                     {
@@ -1776,8 +1774,7 @@ namespace Microsoft.PowerShell.Commands
                 FlagsExpression<FileAttributes> evaluator = null;
                 FlagsExpression<FileAttributes> switchEvaluator = null;
 
-                GetChildDynamicParameters fspDynamicParam = DynamicParameters as GetChildDynamicParameters;
-                if (fspDynamicParam != null)
+                if (DynamicParameters is GetChildDynamicParameters fspDynamicParam)
                 {
                     evaluator = fspDynamicParam.Attributes;
                     switchEvaluator = FormatAttributeSwitchParameters();
@@ -3417,11 +3414,8 @@ namespace Microsoft.PowerShell.Commands
                 var fsinfo = GetFileSystemInfo(path, out bool _);
                 result = fsinfo != null;
 
-                FileSystemItemProviderDynamicParameters itemExistsDynamicParameters =
-                    DynamicParameters as FileSystemItemProviderDynamicParameters;
-
                 // If the items see if we need to check the age of the file...
-                if (result && itemExistsDynamicParameters != null)
+                if (result && DynamicParameters is FileSystemItemProviderDynamicParameters itemExistsDynamicParameters)
                 {
                     DateTime lastWriteTime = fsinfo.LastWriteTime;
 
@@ -3622,9 +3616,7 @@ namespace Microsoft.PowerShell.Commands
             PSSession fromSession = null;
             PSSession toSession = null;
 
-            CopyItemDynamicParameters copyDynamicParameter = DynamicParameters as CopyItemDynamicParameters;
-
-            if (copyDynamicParameter != null)
+            if (DynamicParameters is CopyItemDynamicParameters copyDynamicParameter)
             {
                 if (copyDynamicParameter.FromSession != null)
                 {
@@ -4475,10 +4467,7 @@ namespace Microsoft.PowerShell.Commands
             }
             finally
             {
-                if (wStream != null)
-                {
-                    wStream.Dispose();
-                }
+                wStream?.Dispose();
 
                 // If copying the file from the remote session failed, then remove it.
                 if (errorWhileCopyRemoteFile && File.Exists(destinationFile.FullName))
@@ -4758,10 +4747,7 @@ namespace Microsoft.PowerShell.Commands
             }
             finally
             {
-                if (fStream != null)
-                {
-                    fStream.Dispose();
-                }
+                fStream?.Dispose();
             }
 
             return success;
@@ -6199,7 +6185,7 @@ namespace Microsoft.PowerShell.Commands
                     {
                         foreach (string property in providerSpecificPickList)
                         {
-                            if (property != null && property.Length > 0)
+                            if (!string.IsNullOrEmpty(property))
                             {
                                 try
                                 {
@@ -6375,8 +6361,8 @@ namespace Microsoft.PowerShell.Commands
                             {
                                 FileAttributes attributes;
 
-                                if (propertyValue is FileAttributes)
-                                    attributes = (FileAttributes)propertyValue;
+                                if (propertyValue is FileAttributes fileAttributes)
+                                    attributes = fileAttributes;
                                 else
                                     attributes = (FileAttributes)Enum.Parse(typeof(FileAttributes), propertyValueString, true);
 
@@ -6609,10 +6595,7 @@ namespace Microsoft.PowerShell.Commands
             // They override the defaults specified above.
             if (DynamicParameters != null)
             {
-                FileSystemContentReaderDynamicParameters dynParams =
-                    DynamicParameters as FileSystemContentReaderDynamicParameters;
-
-                if (dynParams != null)
+                if (DynamicParameters is FileSystemContentReaderDynamicParameters dynParams)
                 {
                     // -raw is not allowed when -first,-last or -wait is specified
                     // this call will validate that and throws.
@@ -6786,10 +6769,7 @@ namespace Microsoft.PowerShell.Commands
             // Get the dynamic parameters
             if (DynamicParameters != null)
             {
-                FileSystemContentWriterDynamicParameters dynParams =
-                    DynamicParameters as FileSystemContentWriterDynamicParameters;
-
-                if (dynParams != null)
+                if (DynamicParameters is FileSystemContentWriterDynamicParameters dynParams)
                 {
                     usingByteEncoding = dynParams.AsByteStream;
                     streamTypeSpecified = dynParams.WasStreamTypeSpecified;
@@ -8112,9 +8092,7 @@ namespace Microsoft.PowerShell.Commands
         /// <returns>The link type of the reparse point. SymbolicLink for symbolic links.</returns>
         public static string GetLinkType(PSObject instance)
         {
-            FileSystemInfo fileSysInfo = instance.BaseObject as FileSystemInfo;
-
-            if (fileSysInfo != null)
+            if (instance.BaseObject is FileSystemInfo fileSysInfo)
             {
                 return InternalGetLinkType(fileSysInfo);
             }
diff --git a/src/System.Management.Automation/namespaces/FunctionProvider.cs b/src/System.Management.Automation/namespaces/FunctionProvider.cs
index ea3d9a750..edfbe7700 100644
--- a/src/System.Management.Automation/namespaces/FunctionProvider.cs
+++ b/src/System.Management.Automation/namespaces/FunctionProvider.cs
@@ -184,14 +184,12 @@ namespace Microsoft.PowerShell.Commands
                 do // false loop
                 {
                     // Unwrap the PSObject before binding it as a scriptblock...
-                    PSObject pso = value as PSObject;
-                    if (pso != null)
+                    if (value is PSObject pso)
                     {
                         value = pso.BaseObject;
                     }
 
-                    ScriptBlock scriptBlockValue = value as ScriptBlock;
-                    if (scriptBlockValue != null)
+                    if (value is ScriptBlock scriptBlockValue)
                     {
                         if (dynamicParametersSpecified)
                         {
@@ -206,8 +204,7 @@ namespace Microsoft.PowerShell.Commands
                         break;
                     }
 
-                    FunctionInfo function = value as FunctionInfo;
-                    if (function != null)
+                    if (value is FunctionInfo function)
                     {
                         ScopedItemOptions options = function.Options;
 
@@ -220,8 +217,7 @@ namespace Microsoft.PowerShell.Commands
                         break;
                     }
 
-                    string stringValue = value as string;
-                    if (stringValue != null)
+                    if (value is string stringValue)
                     {
                         ScriptBlock scriptBlock = ScriptBlock.Create(Context.ExecutionContext, stringValue);
 
@@ -290,8 +286,7 @@ namespace Microsoft.PowerShell.Commands
 
             object value = item;
 
-            FunctionInfo function = item as FunctionInfo;
-            if (function != null)
+            if (item is FunctionInfo function)
             {
                 value = function.ScriptBlock;
             }
@@ -325,8 +320,7 @@ namespace Microsoft.PowerShell.Commands
         {
             bool result = false;
 
-            FunctionInfo functionInfo = item as FunctionInfo;
-            if (functionInfo != null)
+            if (item is FunctionInfo functionInfo)
             {
                 if ((functionInfo.Options & ScopedItemOptions.Constant) != 0 ||
                     ((functionInfo.Options & ScopedItemOptions.ReadOnly) != 0 && !Force))
diff --git a/src/System.Management.Automation/namespaces/ProviderBase.cs b/src/System.Management.Automation/namespaces/ProviderBase.cs
index 4ffc26db0..4d9662f1b 100644
--- a/src/System.Management.Automation/namespaces/ProviderBase.cs
+++ b/src/System.Management.Automation/namespaces/ProviderBase.cs
@@ -1765,11 +1765,8 @@ namespace System.Management.Automation.Provider
                 ProviderInfo != null,
                 "The ProviderInfo should always be set");
 
-            // Move the TypeNames to the wrapping object if the wrapped object
-            // was an PSObject
-
-            PSObject mshObj = item as PSObject;
-            if (mshObj != null)
+            // Move the TypeNames to the wrapping object if the wrapped object            // was an PSObject
+            if (item is PSObject mshObj)
             {
                 result.InternalTypeNames = new ConsolidatedString(mshObj.InternalTypeNames);
             }
@@ -1783,9 +1780,7 @@ namespace System.Management.Automation.Provider
             providerBaseTracer.WriteLine("Attaching {0} = {1}", "PSPath", providerQualifiedPath);
 
             // Now get the parent path and child name
-
-            NavigationCmdletProvider navProvider = this as NavigationCmdletProvider;
-            if (navProvider != null && path != null)
+            if (this is NavigationCmdletProvider navProvider && path != null)
             {
                 // Get the parent path
 
diff --git a/src/System.Management.Automation/namespaces/RegistryProvider.cs b/src/System.Management.Automation/namespaces/RegistryProvider.cs
index 1898c9606..5a77ac00a 100644
--- a/src/System.Management.Automation/namespaces/RegistryProvider.cs
+++ b/src/System.Management.Automation/namespaces/RegistryProvider.cs
@@ -282,10 +282,7 @@ namespace Microsoft.PowerShell.Commands
                 bool valueSet = false;
                 if (DynamicParameters != null)
                 {
-                    RegistryProviderSetItemDynamicParameter dynParams =
-                        DynamicParameters as RegistryProviderSetItemDynamicParameter;
-
-                    if (dynParams != null)
+                    if (DynamicParameters is RegistryProviderSetItemDynamicParameter dynParams)
                     {
                         try
                         {
@@ -1880,10 +1877,7 @@ namespace Microsoft.PowerShell.Commands
 
             if (DynamicParameters != null)
             {
-                RegistryProviderSetItemDynamicParameter dynParams =
-                    DynamicParameters as RegistryProviderSetItemDynamicParameter;
-
-                if (dynParams != null)
+                if (DynamicParameters is RegistryProviderSetItemDynamicParameter dynParams)
                 {
                     kind = dynParams.Type;
                 }
diff --git a/src/System.Management.Automation/namespaces/SessionStateProviderBase.cs b/src/System.Management.Automation/namespaces/SessionStateProviderBase.cs
index 3f0f52c94..ca0fea72a 100644
--- a/src/System.Management.Automation/namespaces/SessionStateProviderBase.cs
+++ b/src/System.Management.Automation/namespaces/SessionStateProviderBase.cs
@@ -105,9 +105,9 @@ namespace Microsoft.PowerShell.Commands
 
             object value = item;
 
-            if (item is DictionaryEntry)
+            if (item is DictionaryEntry dictionaryEntry)
             {
-                value = ((DictionaryEntry)item).Value;
+                value = dictionaryEntry.Value;
             }
 
             return value;
diff --git a/src/System.Management.Automation/namespaces/VariableProvider.cs b/src/System.Management.Automation/namespaces/VariableProvider.cs
index 5f9934d32..d8e99628e 100644
--- a/src/System.Management.Automation/namespaces/VariableProvider.cs
+++ b/src/System.Management.Automation/namespaces/VariableProvider.cs
@@ -132,9 +132,7 @@ namespace Microsoft.PowerShell.Commands
                 variable = new PSVariable(name, null);
             }
 
-            PSVariable item = SessionState.Internal.SetVariable(variable, Force, Context.Origin) as PSVariable;
-
-            if (writeItem && item != null)
+            if (writeItem && SessionState.Internal.SetVariable(variable, Force, Context.Origin) is PSVariable item)
             {
                 WriteItemObject(item, item.Name, false);
             }
@@ -188,8 +186,7 @@ namespace Microsoft.PowerShell.Commands
 
             object value = base.GetValueOfItem(item);
 
-            PSVariable var = item as PSVariable;
-            if (var != null)
+            if (item is PSVariable var)
             {
                 value = var.Value;
             }
@@ -211,8 +208,7 @@ namespace Microsoft.PowerShell.Commands
         {
             bool result = false;
 
-            PSVariable variable = item as PSVariable;
-            if (variable != null)
+            if (item is PSVariable variable)
             {
                 if ((variable.Options & ScopedItemOptions.Constant) != 0 ||
                     ((variable.Options & ScopedItemOptions.ReadOnly) != 0 && !Force))
diff --git a/src/System.Management.Automation/security/SecuritySupport.cs b/src/System.Management.Automation/security/SecuritySupport.cs
index 4afb15be5..320a0709a 100644
--- a/src/System.Management.Automation/security/SecuritySupport.cs
+++ b/src/System.Management.Automation/security/SecuritySupport.cs
@@ -664,8 +664,7 @@ namespace System.Management.Automation.Internal
         {
             foreach (X509Extension extension in c.Extensions)
             {
-                X509KeyUsageExtension keyUsageExtension = extension as X509KeyUsageExtension;
-                if (keyUsageExtension != null)
+                if (extension is X509KeyUsageExtension keyUsageExtension)
                 {
                     if ((keyUsageExtension.KeyUsages & keyUsage) == keyUsage)
                     {
diff --git a/src/System.Management.Automation/singleshell/config/MshSnapinInfo.cs b/src/System.Management.Automation/singleshell/config/MshSnapinInfo.cs
index db45a12b3..a47103799 100644
--- a/src/System.Management.Automation/singleshell/config/MshSnapinInfo.cs
+++ b/src/System.Management.Automation/singleshell/config/MshSnapinInfo.cs
@@ -773,8 +773,7 @@ namespace System.Management.Automation
             if (msv == null)
             {
                 // Check if the value is in string format
-                string singleValue = value as string;
-                if (singleValue != null)
+                if (value is string singleValue)
                 {
                     msv = new string[1];
                     msv[0] = singleValue;
diff --git a/src/System.Management.Automation/utils/CryptoUtils.cs b/src/System.Management.Automation/utils/CryptoUtils.cs
index e121dd62b..0f9dc3276 100644
--- a/src/System.Management.Automation/utils/CryptoUtils.cs
+++ b/src/System.Management.Automation/utils/CryptoUtils.cs
@@ -616,15 +616,9 @@ namespace System.Management.Automation.Internal
         {
             if (disposing)
             {
-                if (_rsa != null)
-                {
-                    _rsa.Dispose();
-                }
+                _rsa?.Dispose();
 
-                if (_aes != null)
-                {
-                    _aes.Dispose();
-                }
+                _aes?.Dispose();
             }
         }
 
@@ -851,10 +845,7 @@ namespace System.Management.Automation.Internal
         {
             if (disposing)
             {
-                if (_rsaCryptoProvider != null)
-                {
-                    _rsaCryptoProvider.Dispose();
-                }
+                _rsaCryptoProvider?.Dispose();
 
                 _rsaCryptoProvider = null;
 
@@ -906,12 +897,11 @@ namespace System.Management.Automation.Internal
 
         internal override string EncryptSecureString(SecureString secureString)
         {
-            ServerRemoteSession session = Session as ServerRemoteSession;
 
             // session!=null check required for DRTs TestEncryptSecureString* entries in CryptoUtilsTest/UTUtils.dll
             // for newer clients, server will never initiate key exchange.
             // for server, just the session key is required to encrypt/decrypt anything
-            if ((session != null) && (session.Context.ClientCapability.ProtocolVersion >= RemotingConstants.ProtocolVersionWin8RTM))
+            if ((Session is ServerRemoteSession session) && (session.Context.ClientCapability.ProtocolVersion >= RemotingConstants.ProtocolVersionWin8RTM))
             {
                 _rsaCryptoProvider.GenerateSessionKey();
             }
diff --git a/src/System.Management.Automation/utils/ExecutionExceptions.cs b/src/System.Management.Automation/utils/ExecutionExceptions.cs
index 226a9cb8c..5f5d73e97 100644
--- a/src/System.Management.Automation/utils/ExecutionExceptions.cs
+++ b/src/System.Management.Automation/utils/ExecutionExceptions.cs
@@ -62,7 +62,7 @@ namespace System.Management.Automation
             // invocationInfo may be null
 
             IContainsErrorRecord icer = innerException as IContainsErrorRecord;
-            if (icer != null && icer.ErrorRecord != null)
+            if (icer?.ErrorRecord != null)
             {
                 _errorRecord = new ErrorRecord(icer.ErrorRecord, innerException);
             }
diff --git a/src/System.Management.Automation/utils/ObjectStream.cs b/src/System.Management.Automation/utils/ObjectStream.cs
index 2f4cbef8a..b92211bba 100644
--- a/src/System.Management.Automation/utils/ObjectStream.cs
+++ b/src/System.Management.Automation/utils/ObjectStream.cs
@@ -1512,15 +1512,9 @@ namespace System.Management.Automation.Internal
                 _writeClosedHandle.Dispose();
                 _readClosedHandle.Dispose();
 
-                if (_readWaitHandle != null)
-                {
-                    _readWaitHandle.Dispose();
-                }
+                _readWaitHandle?.Dispose();
 
-                if (_writeWaitHandle != null)
-                {
-                    _writeWaitHandle.Dispose();
-                }
+                _writeWaitHandle?.Dispose();
 
                 if (_reader != null)
                 {
diff --git a/src/System.Management.Automation/utils/PowerShellExecutionHelper.cs b/src/System.Management.Automation/utils/PowerShellExecutionHelper.cs
index dcfc2682b..04f0e859c 100644
--- a/src/System.Management.Automation/utils/PowerShellExecutionHelper.cs
+++ b/src/System.Management.Automation/utils/PowerShellExecutionHelper.cs
@@ -184,12 +184,12 @@ namespace System.Management.Automation
 
             try
             {
-                PSObject pso = obj as PSObject;
                 string result;
-                if (pso != null)
+
+                if (obj is PSObject pso)
                 {
                     object baseObject = pso.BaseObject;
-                    if (baseObject != null && baseObject is not PSCustomObject)
+                    if (baseObject is not PSCustomObject)
                         result = baseObject.ToString();
                     else
                         result = pso.ToString();
diff --git a/src/System.Management.Automation/utils/SessionStateExceptions.cs b/src/System.Management.Automation/utils/SessionStateExceptions.cs
index a08e7615d..8dd70bcc6 100644
--- a/src/System.Management.Automation/utils/SessionStateExceptions.cs
+++ b/src/System.Management.Automation/utils/SessionStateExceptions.cs
@@ -67,7 +67,7 @@ namespace System.Management.Automation
             _providerInfo = provider;
 
             IContainsErrorRecord icer = innerException as IContainsErrorRecord;
-            if (icer != null && icer.ErrorRecord != null)
+            if (icer?.ErrorRecord != null)
             {
                 _errorRecord = new ErrorRecord(icer.ErrorRecord, innerException);
             }
@@ -203,7 +203,7 @@ namespace System.Management.Automation
             }
 
             IContainsErrorRecord icer = innerException as IContainsErrorRecord;
-            if (icer != null && icer.ErrorRecord != null)
+            if (icer?.ErrorRecord != null)
             {
                 _errorRecord = new ErrorRecord(icer.ErrorRecord, errorRecordException);
             }
diff --git a/src/System.Management.Automation/utils/tracing/EtwActivity.cs b/src/System.Management.Automation/utils/tracing/EtwActivity.cs
index b50f68e69..1a3067f0c 100644
--- a/src/System.Management.Automation/utils/tracing/EtwActivity.cs
+++ b/src/System.Management.Automation/utils/tracing/EtwActivity.cs
@@ -474,10 +474,7 @@ namespace System.Management.Automation.Tracing
             }
 
             bool success = provider.WriteEvent(in ed, payload);
-            if (EventWritten != null)
-            {
-                EventWritten.Invoke(this, new EtwEventArgs(ed, success, payload));
-            }
+            EventWritten?.Invoke(this, new EtwEventArgs(ed, success, payload));
         }
 
         private EventProvider GetProvider()
