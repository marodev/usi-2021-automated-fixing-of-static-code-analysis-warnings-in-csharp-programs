Found the following rules to apply: UseMethodAnyRewriterR6, MergeSequentialChecksRewriterR2, NullChecksShouldNotBeUsedWithIsRewriterR3, SimplifyLinqRewriterR4, TypeCheckAndCastRewriterR5, UseNullPropagationRewriterR7, UsePatternMatchingRewriterR8, UseStringInterpolationRewriterR9, UseStringIsNullOrEmptyRewriterR10

##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview
##vso[task.setvariable variable=GitAssemblyInformationalVersion;]1.4.365-preview+d7236cebc1
##vso[task.setvariable variable=GitBuildVersion;]1.4.365.50
##vso[task.setvariable variable=GitBuildVersionSimple;]1.4.365
##vso[build.updatebuildnumber]1.4.365-preview


Project: Opc.Ua.Server(net462)
    #1 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Configuration\ConfigurationNodeManager.cs, Line: 143, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #2 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Configuration\ConfigurationNodeManager.cs, Line: 262, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #3 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Configuration\ConfigurationNodeManager.cs, Line: 341, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #4 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs, Line: 1876, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #5 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs, Line: 654, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #6 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\DiagnosticsNodeManager.cs, Line: 1381, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #7 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\DiagnosticsNodeManager.cs, Line: 1442, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #8 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\DiagnosticsNodeManager.cs, Line: 659, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #9 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\DiagnosticsNodeManager.cs, Line: 795, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #10 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\DiagnosticsNodeManager.cs, Line: 818, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #11 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\MonitoredNode.cs, Line: 223, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #12 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs, Line: 461, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #13 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs, Line: 862, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #14 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\DataChangeMonitoredItem.cs, Line: 559, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #15 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\CoreNodeManager.cs, Line: 1258, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #16 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\CoreNodeManager.cs, Line: 1554, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #17 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\CoreNodeManager.cs, Line: 197, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #18 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\CoreNodeManager.cs, Line: 2315, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #19 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\CoreNodeManager.cs, Line: 2853, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #20 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\CoreNodeManager.cs, Line: 2977, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #21 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\CoreNodeManager.cs, Line: 3075, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #22 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\CoreNodeManager.cs, Line: 651, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #23 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\MasterNodeManager.cs, Line: 1033, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #24 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\MasterNodeManager.cs, Line: 1124, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #25 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\MasterNodeManager.cs, Line: 2659, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #26 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\MasterNodeManager.cs, Line: 356, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #27 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\ResourceManager.cs, Line: 115, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #28 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\ResourceManager.cs, Line: 529, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #29 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\SamplingGroup.cs, Line: 436, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #30 Path: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\SamplingGroupManager.cs, Line: 461, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #31 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Server\ServerInternalData.cs, Line: 538, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #32 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Server\ServerInternalData.cs, Line: 551, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #33 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Server\StandardServer.cs, Line: 2502, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #34 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Session\SessionManager.cs, Line: 479, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #35 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Subscription\MonitoredItem.cs, Line: 1153, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #36 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Subscription\MonitoredItem.cs, Line: 1611, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #37 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Subscription\MonitoredItem.cs, Line: 573, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #38 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Subscription\MonitoredItem.cs, Line: 821, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #39 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Subscription\MonitoredItem.cs, Line: 895, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #40 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Subscription\MonitoredItem.cs, Line: 948, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #41 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Subscription\SubscriptionManager.cs, Line: 363, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #42 Path: D:\a\1\s\Libraries\Opc.Ua.Server\Subscription\SubscriptionManager.cs, Line: 445, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: Opc.Ua.Core(net462)
    #43 Path: D:\a\1\s\Stack\Opc.Ua.Core\Schema\SecuredApplicationHelpers.cs, Line: 241, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #44 Path: D:\a\1\s\Stack\Opc.Ua.Core\Schema\UANodeSetHelpers.cs, Line: 651, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #45 Path: D:\a\1\s\Stack\Opc.Ua.Core\Schema\UANodeSetHelpers.cs, Line: 666, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #46 Path: D:\a\1\s\Stack\Opc.Ua.Core\Schema\UANodeSetHelpers.cs, Line: 903, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #47 Path: D:\a\1\s\Stack\Opc.Ua.Core\Schema\UANodeSetHelpers.cs, Line: 944, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #48 Path: D:\a\1\s\Stack\Opc.Ua.Core\Security\Certificates\DirectoryCertificateStore.cs, Line: 586, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #49 Path: D:\a\1\s\Stack\Opc.Ua.Core\Security\Certificates\DirectoryCertificateStore.cs, Line: 593, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #50 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Bindings\TransportBindingsBase.cs, Line: 101, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #51 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Bindings\TransportBindingsBase.cs, Line: 163, Message: ReSharper: Use '.Any()' to test whether this IEnumerable is empty or not. See ReSharper/UseMethodAny.0.html / SonarQube: "Any()" should be used to test for emptiness. See https://rules.sonarsource.com/csharp/RSPEC-1155
    #52 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Client\DiscoveryClient.cs, Line: 132, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #53 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Client\UaChannelBase.cs, Line: 100, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #54 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Client\UaChannelBase.cs, Line: 113, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #55 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Client\UaChannelBase.cs, Line: 975, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #56 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Client\UserIdentity.cs, Line: 164, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #57 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Client\UserIdentity.cs, Line: 173, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #58 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Client\UserIdentity.cs, Line: 190, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #59 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Client\UserIdentity.cs, Line: 211, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #60 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 104, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #61 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 109, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #62 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 1137, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #63 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 114, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #64 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 1142, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #65 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 1147, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #66 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 1152, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #67 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 1157, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #68 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 119, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #69 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 124, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #70 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 1962, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #71 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 24492, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #72 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 24779, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #73 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 24784, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #74 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 25122, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #75 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 25127, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #76 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 25132, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #77 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 25883, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #78 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 26112, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #79 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 26117, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #80 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 26122, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #81 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 26449, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #82 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 26454, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #83 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 26459, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #84 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 26464, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #85 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 26826, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #86 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 26831, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #87 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 26836, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #88 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 28665, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #89 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 29357, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #90 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 30049, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #91 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 30741, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #92 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 30746, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #93 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 30751, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #94 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 35031, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #95 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 35036, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #96 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 35041, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #97 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 35046, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #98 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 35051, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #99 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 35056, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #100 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 35061, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #101 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 35066, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #102 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 35071, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #103 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 35076, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #104 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3586, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #105 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3591, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #106 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3596, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #107 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3601, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #108 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3606, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #109 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3611, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #110 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3616, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #111 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3621, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #112 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3626, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #113 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3631, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #114 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3636, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #115 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 3641, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #116 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 37036, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #117 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 37217, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #118 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 37222, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #119 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 37511, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #120 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 37516, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #121 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 37521, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #122 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 39096, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #123 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 40776, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #124 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 40781, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #125 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 40786, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #126 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 40791, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #127 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 41366, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #128 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 41371, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #129 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43194, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #130 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43199, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #131 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43558, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #132 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43563, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #133 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43568, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #134 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43573, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #135 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43578, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #136 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43583, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #137 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43588, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #138 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43593, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #139 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43598, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #140 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43603, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #141 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43608, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #142 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43613, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #143 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43618, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #144 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43623, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #145 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43628, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #146 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43633, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #147 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43638, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #148 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43643, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #149 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43648, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #150 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 43653, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #151 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 4368, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #152 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 45505, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #153 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 45510, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #154 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 45515, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #155 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 45520, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #156 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 45525, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #157 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 45530, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #158 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 45535, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #159 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 45540, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #160 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 46366, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #161 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 46371, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #162 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 46376, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #163 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 46381, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #164 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 46989, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #165 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 47238, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #166 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 47440, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #167 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 47691, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #168 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 48632, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #169 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 48975, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #170 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 5016, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #171 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 50904, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #172 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 5205, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #173 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 5210, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #174 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 5215, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #175 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 5220, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #176 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 52361, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #177 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 52366, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #178 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 55743, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #179 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 55748, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #180 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 55753, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #181 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 55758, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #182 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 55763, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #183 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 55768, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #184 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 55773, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #185 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 55778, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #186 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 55783, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #187 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 59623, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #188 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 59628, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #189 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 59633, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #190 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 59638, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #191 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 5988, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #192 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 60380, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #193 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 60385, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #194 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 60885, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #195 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 60890, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #196 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 63142, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #197 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 63316, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #198 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 63321, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #199 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 63326, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #200 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 63331, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #201 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 64776, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #202 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 64781, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #203 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 64786, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #204 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 66168, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #205 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 66173, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #206 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 66178, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #207 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 66183, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #208 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 67116, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #209 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 67121, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #210 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 67889, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #211 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 67894, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #212 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 68448, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #213 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 6877, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #214 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 68900, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #215 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 68905, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #216 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 68910, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #217 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 68915, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #218 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 68920, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #219 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 68925, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #220 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 68930, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #221 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 70361, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #222 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 70366, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #223 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 70371, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #224 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 70376, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #225 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 70381, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #226 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 71505, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #227 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 71510, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #228 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 71914, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #229 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 71919, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #230 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 71924, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #231 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 71929, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #232 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 71934, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #233 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 73078, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #234 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 73083, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #235 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 73088, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #236 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 73093, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #237 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 73098, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #238 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 73944, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #239 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 73949, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #240 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 73954, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #241 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 73959, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #242 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 74686, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #243 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 74691, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #244 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 74696, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #245 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 74701, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #246 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 74706, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #247 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 74711, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #248 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 74716, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #249 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 74721, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #250 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 76319, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #251 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 76324, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #252 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 76926, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #253 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 76931, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #254 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 77673, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #255 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 79335, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #256 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 81190, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #257 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 81195, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #258 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 83332, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #259 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 89, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #260 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 94, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #261 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Generated\Opc.Ua.Classes.cs, Line: 99, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #262 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\ContentFilter.cs, Line: 1166, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #263 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\ContentFilter.cs, Line: 1262, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #264 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeSet.cs, Line: 243, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #265 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeSet.cs, Line: 274, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #266 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeSet.cs, Line: 286, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #267 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeSet.cs, Line: 441, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #268 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeSet.cs, Line: 455, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #269 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeSet.cs, Line: 492, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #270 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeSet.cs, Line: 513, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #271 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeSet.cs, Line: 520, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #272 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeSet.cs, Line: 527, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #273 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeSet.cs, Line: 531, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #274 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeTable.cs, Line: 478, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #275 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeTable.cs, Line: 517, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #276 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeTable.cs, Line: 534, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #277 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeTable.cs, Line: 566, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #278 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeTable.cs, Line: 622, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #279 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeTable.cs, Line: 658, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #280 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\NodeTable.cs, Line: 671, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #281 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\TypeTable.cs, Line: 385, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #282 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\TypeTable.cs, Line: 393, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #283 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\TypeTable.cs, Line: 525, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #284 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\TypeTable.cs, Line: 672, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #285 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Server\EndpointBase.cs, Line: 402, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #286 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Server\EndpointBase.cs, Line: 828, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #287 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Server\ServerBase.cs, Line: 444, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #288 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs, Line: 291, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #289 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceStateSnapshot.cs, Line: 204, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #290 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceStateSnapshot.cs, Line: 214, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #291 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseObjectState.cs, Line: 144, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #292 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseObjectState.cs, Line: 80, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #293 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseTypeState.cs, Line: 48, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #294 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\ConditionState.cs, Line: 289, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #295 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\MethodState.cs, Line: 184, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #296 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\MethodState.cs, Line: 70, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #297 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\NodeState.cs, Line: 2529, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #298 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\NodeState.cs, Line: 3208, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #299 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\NodeState.cs, Line: 3216, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #300 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\NodeState.cs, Line: 3220, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #301 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\NodeState.cs, Line: 4233, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #302 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\NodeState.cs, Line: 4233, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #303 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\NodeStateCollection.cs, Line: 217, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #304 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\NodeStateCollection.cs, Line: 582, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #305 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\ProgramStateMachineState.cs, Line: 162, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #306 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\ReferenceTypeState.cs, Line: 129, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #307 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\ReferenceTypeState.cs, Line: 63, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #308 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\ViewState.cs, Line: 180, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #309 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\ViewState.cs, Line: 66, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #310 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\ChannelAsyncOperation.cs, Line: 294, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #311 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\ChannelAsyncOperation.cs, Line: 311, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #312 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\TcpListenerChannel.cs, Line: 178, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #313 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\TcpListenerChannel.cs, Line: 336, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #314 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\TcpListenerChannel.cs, Line: 455, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #315 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\TcpListenerChannel.cs, Line: 529, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #316 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\TcpServerChannel.cs, Line: 504, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #317 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\TcpServerChannel.cs, Line: 698, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #318 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\TcpServerChannel.cs, Line: 765, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #319 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\TcpServerChannel.cs, Line: 832, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #320 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\TcpServerChannel.cs, Line: 951, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #321 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\TcpTransportListener.cs, Line: 199, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #322 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\UaSCBinaryChannel.Asymmetric.cs, Line: 890, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #323 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\UaSCBinaryChannel.cs, Line: 486, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #324 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\UaSCBinaryChannel.Symmetric.cs, Line: 436, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #325 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\UaSCBinaryClientChannel.cs, Line: 1334, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #326 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\UaSCBinaryClientChannel.cs, Line: 1432, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #327 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\UaSCBinaryClientChannel.cs, Line: 531, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #328 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\UaSCBinaryClientChannel.cs, Line: 664, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #329 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\UaSCBinaryClientChannel.cs, Line: 686, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #330 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\UaSCBinaryClientChannel.cs, Line: 967, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #331 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Types\ContentFilter.Evaluate.cs, Line: 1472, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #332 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Types\WriteValue.cs, Line: 116, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #333 Path: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Types\WriteValue.cs, Line: 132, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #334 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\DataValue.cs, Line: 219, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #335 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\DataValue.cs, Line: 527, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #336 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\DataValue.cs, Line: 566, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #337 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\DiagnosticInfo.cs, Line: 389, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #338 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\ExpandedNodeId.cs, Line: 794, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #339 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\ExtensionObject.cs, Line: 452, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #340 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\ExtensionObject.cs, Line: 512, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #341 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\ExtensionObject.cs, Line: 517, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #342 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\ExtensionObject.cs, Line: 522, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #343 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\ExtensionObject.cs, Line: 541, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #344 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\ExtensionObject.cs, Line: 603, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #345 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\ExtensionObject.cs, Line: 923, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #346 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\NodeId.cs, Line: 1067, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #347 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\NodeId.cs, Line: 2708, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #348 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\StatusCode.cs, Line: 442, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #349 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\StatusCode.cs, Line: 448, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #350 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\Uuid.cs, Line: 251, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #351 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\Uuid.cs, Line: 257, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #352 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\BinaryDecoder.cs, Line: 1579, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #353 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\BinaryDecoder.cs, Line: 76, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #354 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\BinaryDecoder.cs, Line: 794, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #355 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\BinaryDecoder.cs, Line: 81, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #356 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\BinaryEncoder.cs, Line: 1047, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #357 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\BinaryEncoder.cs, Line: 124, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #358 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\EncodeableFactory.cs, Line: 138, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #359 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\EncodeableFactory.cs, Line: 158, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #360 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\JsonDecoder.cs, Line: 374, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #361 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\XmlDecoder.cs, Line: 1451, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #362 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\XmlDecoder.cs, Line: 1485, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #363 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\XmlDecoder.cs, Line: 590, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #364 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\XmlEncoder.cs, Line: 874, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #365 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Schemas\BinarySchemaValidator.cs, Line: 272, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #366 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Schemas\BinarySchemaValidator.cs, Line: 309, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #367 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Schemas\BinarySchemaValidator.cs, Line: 320, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #368 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Schemas\BinarySchemaValidator.cs, Line: 397, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #369 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Schemas\BinarySchemaValidator.cs, Line: 412, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #370 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Schemas\BinarySchemaValidator.cs, Line: 423, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #371 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Schemas\XmlSchemaValidator.cs, Line: 128, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #372 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\DataComparer.cs, Line: 1014, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #373 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\DataComparer.cs, Line: 1014, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #374 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\DataComparer.cs, Line: 1027, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #375 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\DataComparer.cs, Line: 1027, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #376 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\DataComparer.cs, Line: 1061, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #377 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\DataComparer.cs, Line: 1061, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #378 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\DataComparer.cs, Line: 940, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #379 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\DataComparer.cs, Line: 957, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #380 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\DataComparer.cs, Line: 972, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #381 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\RelativePath.cs, Line: 438, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #382 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\ServiceResult.cs, Line: 1, Message: ReSharper: Use 'String.IsNullOrEmpty'. See https://www.jetbrains.com/help/resharper/ReplaceWithStringIsNullOrEmpty.html / SonarQube: "string.IsNullOrEmpty" should be used. See https://rules.sonarsource.com/csharp/RSPEC-3256
    #383 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\ServiceResult.cs, Line: 435, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #384 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\ServiceResult.cs, Line: 474, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #385 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\ServiceResult.cs, Line: 814, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #386 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1583, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #387 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1625, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #388 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1633, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #389 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1641, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #390 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1650, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #391 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1659, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #392 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1668, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #393 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1677, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #394 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1686, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #395 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1695, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #396 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1704, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #397 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1713, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #398 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1722, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #399 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1731, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #400 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1740, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #401 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1749, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #402 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1758, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #403 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1767, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #404 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1776, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #405 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1785, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #406 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1794, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #407 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1803, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #408 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1812, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #409 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1821, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #410 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1830, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #411 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1838, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #412 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1847, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #413 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1855, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #414 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1863, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #415 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1871, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #416 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1879, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #417 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1887, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #418 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1895, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #419 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1903, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #420 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1911, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #421 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1919, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #422 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1927, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #423 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1935, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #424 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1943, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #425 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 1951, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #426 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 2018, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #427 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 2026, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #428 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 2034, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #429 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 2049, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #430 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 2064, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #431 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 2098, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #432 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 2569, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #433 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 438, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #434 Path: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\Utils.cs, Line: 926, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Opc.Ua.Client(net462)
    #435 Path: D:\a\1\s\Libraries\Opc.Ua.Client\MonitoredItem.cs, Line: 641, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #436 Path: D:\a\1\s\Libraries\Opc.Ua.Client\NodeCache.cs, Line: 513, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #437 Path: D:\a\1\s\Libraries\Opc.Ua.Client\NodeCache.cs, Line: 521, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #438 Path: D:\a\1\s\Libraries\Opc.Ua.Client\Session.cs, Line: 1399, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #439 Path: D:\a\1\s\Libraries\Opc.Ua.Client\Session.cs, Line: 2099, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #440 Path: D:\a\1\s\Libraries\Opc.Ua.Client\Session.cs, Line: 2116, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #441 Path: D:\a\1\s\Libraries\Opc.Ua.Client\Session.cs, Line: 2192, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #442 Path: D:\a\1\s\Libraries\Opc.Ua.Client\Session.cs, Line: 3095, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #443 Path: D:\a\1\s\Libraries\Opc.Ua.Client\Session.cs, Line: 3252, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #444 Path: D:\a\1\s\Libraries\Opc.Ua.Client\SessionReconnectHandler.cs, Line: 187, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #445 Path: D:\a\1\s\Libraries\Opc.Ua.Client\Subscription.cs, Line: 1689, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #446 Path: D:\a\1\s\Libraries\Opc.Ua.Client\Subscription.cs, Line: 1706, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #447 Path: D:\a\1\s\Libraries\Opc.Ua.Client\Subscription.cs, Line: 1723, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Opc.Ua.Configuration(net462)
    #448 Path: D:\a\1\s\Libraries\Opc.Ua.Configuration\ApplicationInstance.cs, Line: 735, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html



Project: Opc.Ua.Client.ComplexTypes(net462)
    #449 Path: D:\a\1\s\Libraries\Opc.Ua.Client.ComplexTypes\ComplexTypeSystem.cs, Line: 598, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #450 Path: D:\a\1\s\Libraries\Opc.Ua.Client.ComplexTypes\ComplexTypeSystem.cs, Line: 798, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #451 Path: D:\a\1\s\Libraries\Opc.Ua.Client.ComplexTypes\ComplexTypeSystem.cs, Line: 800, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #452 Path: D:\a\1\s\Libraries\Opc.Ua.Client.ComplexTypes\ComplexTypeSystem.cs, Line: 975, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #453 Path: D:\a\1\s\Libraries\Opc.Ua.Client.ComplexTypes\Types\BaseComplexType.cs, Line: 332, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #454 Path: D:\a\1\s\Libraries\Opc.Ua.Client.ComplexTypes\Types\BaseComplexType.cs, Line: 338, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247



Project: ConsoleReferenceServer
    #455 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1496, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #456 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1521, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #457 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1633, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #458 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1638, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #459 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1639, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #460 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1788, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #461 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1835, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #462 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1886, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #463 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1959, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #464 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2192, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #465 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2193, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #466 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2196, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #467 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2232, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #468 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2233, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #469 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2427, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #470 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 89, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #471 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: UA Client Controls
    #472 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs, Line: 213, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #473 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs, Line: 229, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #474 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs, Line: 233, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #475 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs, Line: 237, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #476 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs, Line: 255, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #477 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs, Line: 260, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #478 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs, Line: 279, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #479 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs, Line: 282, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #480 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs, Line: 332, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #481 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs, Line: 371, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #482 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs, Line: 376, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #483 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\BrowseListCtrl.cs, Line: 118, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #484 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\BrowseListCtrl.cs, Line: 136, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #485 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\BrowseTreeCtrl.cs, Line: 307, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #486 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\BrowseTreeCtrl.cs, Line: 313, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #487 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\BrowseTreeCtrl.cs, Line: 411, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #488 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\BrowseTreeCtrl.cs, Line: 442, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #489 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\NodeListCtrl.cs, Line: 122, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #490 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\NodeListCtrl.cs, Line: 158, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #491 Path: D:\a\1\s\Applications\ClientControls.Net4\Browse\NodeListCtrl.cs, Line: 164, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #492 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\AttrributesListViewCtrl.cs, Line: 95, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #493 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\BrowseTreeViewCtrl.cs, Line: 246, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #494 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\BrowseTreeViewCtrl.cs, Line: 270, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #495 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\BrowseTreeViewCtrl.cs, Line: 350, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #496 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\BrowseTreeViewCtrl.cs, Line: 428, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #497 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValue2Dlg.cs, Line: 212, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #498 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValue2Dlg.cs, Line: 279, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #499 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs, Line: 1182, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #500 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs, Line: 683, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #501 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs, Line: 800, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #502 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs, Line: 807, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #503 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs, Line: 814, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #504 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs, Line: 821, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #505 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs, Line: 828, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #506 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs, Line: 835, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #507 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs, Line: 842, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #508 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs, Line: 849, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #509 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditMonitoredItemDlg.cs, Line: 151, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #510 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditMonitoredItemDlg.cs, Line: 166, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #511 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditReadValueIdDlg.cs, Line: 164, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #512 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditReadValueIdDlg.cs, Line: 259, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #513 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\HistoryDataListView.cs, Line: 1494, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #514 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\HistoryDataListView.cs, Line: 1644, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #515 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\HistoryDataListView.cs, Line: 477, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #516 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\HistoryDataListView.cs, Line: 483, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #517 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\SubscribeDataListViewCtrl.cs, Line: 156, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #518 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\SubscribeEventsDlg.cs, Line: 586, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #519 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\UserNamePasswordDlg.cs, Line: 69, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #520 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerListCtrl.cs, Line: 135, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #521 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerListCtrl.cs, Line: 172, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #522 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerListCtrl.cs, Line: 268, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #523 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerListCtrl.cs, Line: 310, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #524 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerListCtrl.cs, Line: 311, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #525 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerListCtrl.cs, Line: 312, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #526 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerListCtrl.cs, Line: 313, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #527 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerOnNetworkListCtrl.cs, Line: 125, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #528 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerOnNetworkListCtrl.cs, Line: 162, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #529 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerOnNetworkListCtrl.cs, Line: 273, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #530 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerOnNetworkListCtrl.cs, Line: 290, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #531 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerOnNetworkListCtrl.cs, Line: 291, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #532 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerOnNetworkListCtrl.cs, Line: 292, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #533 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\DiscoveredServerOnNetworkListCtrl.cs, Line: 293, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #534 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\EventListView.cs, Line: 305, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #535 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\EventListView.cs, Line: 381, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #536 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\EventListView.cs, Line: 387, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #537 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\EventListView.cs, Line: 555, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #538 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\EventListView.cs, Line: 716, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #539 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\EventListView.cs, Line: 742, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #540 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\EventListView.cs, Line: 756, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #541 Path: D:\a\1\s\Applications\ClientControls.Net4\Common\HostListCtrl.cs, Line: 172, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #542 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificateListCtrl.cs, Line: 320, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #543 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificatePropertiesListCtrl.cs, Line: 124, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #544 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificatePropertiesListCtrl.cs, Line: 148, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #545 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificatePropertiesListCtrl.cs, Line: 171, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #546 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificatePropertiesListCtrl.cs, Line: 198, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #547 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificatePropertiesListCtrl.cs, Line: 266, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #548 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificatePropertiesListCtrl.cs, Line: 267, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #549 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificateStoreTreeCtrl.cs, Line: 201, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #550 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificateStoreTreeCtrl.cs, Line: 226, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #551 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificateStoreTreeCtrl.cs, Line: 314, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #552 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\BaseListCtrl.cs, Line: 237, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #553 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\BaseListCtrl.cs, Line: 300, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #554 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\BaseListCtrl.cs, Line: 502, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #555 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\BaseListCtrl.cs, Line: 675, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #556 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\BaseTreeCtrl.cs, Line: 102, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #557 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\BaseTreeCtrl.cs, Line: 312, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #558 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs, Line: 1571, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #559 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs, Line: 342, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #560 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs, Line: 549, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #561 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs, Line: 730, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #562 Path: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\NodeIdCtrl.cs, Line: 178, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #563 Path: D:\a\1\s\Applications\ClientControls.Net4\Endpoints\ConfiguredServerDlg.cs, Line: 1330, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #564 Path: D:\a\1\s\Applications\ClientControls.Net4\Endpoints\ConfiguredServerListCtrl.cs, Line: 147, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #565 Path: D:\a\1\s\Applications\ClientControls.Net4\Endpoints\ConfiguredServerListCtrl.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #566 Path: D:\a\1\s\Applications\ClientControls.Net4\Endpoints\ConfiguredServerListCtrl.cs, Line: 149, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #567 Path: D:\a\1\s\Applications\ClientControls.Net4\Endpoints\ConfiguredServerListCtrl.cs, Line: 151, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #568 Path: D:\a\1\s\Applications\ClientControls.Net4\ExceptionDlg.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: UA Server Controls
    #569 Path: D:\a\1\s\Applications\ServerControls.Net4\ExceptionDlg.cs, Line: 115, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #570 Path: D:\a\1\s\Applications\ServerControls.Net4\ServerDiagnosticsCtrl.cs, Line: 118, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #571 Path: D:\a\1\s\Applications\ServerControls.Net4\ServerDiagnosticsCtrl.cs, Line: 147, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #572 Path: D:\a\1\s\Applications\ServerControls.Net4\ServerDiagnosticsCtrl.cs, Line: 148, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #573 Path: D:\a\1\s\Applications\ServerControls.Net4\ServerDiagnosticsCtrl.cs, Line: 152, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html



Project: Reference Server
    #574 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1496, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #575 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1521, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #576 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1633, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #577 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1638, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #578 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1639, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #579 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1788, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #580 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1835, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #581 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1886, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #582 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 1959, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #583 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2192, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #584 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2193, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #585 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2196, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #586 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2232, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #587 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2233, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #588 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 2427, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html
    #589 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 89, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #590 Path: D:\a\1\s\Applications\ReferenceServer\ReferenceNodeManager.cs, Line: 93, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Opc.Ua.Bindings.Https(net462)
    #591 Path: D:\a\1\s\Stack\Opc.Ua.Bindings.Https\Stack\Https\HttpsTransportChannel.cs, Line: 156, Message: ReSharper: Replace if statement with null-propagating code. See https://www.jetbrains.com/help/resharper/UseNullPropagation.html



Project: Opc.Ua.PubSub(net462)
    #592 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 1138, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #593 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 1315, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #594 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 1569, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #595 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 1679, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #596 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #597 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #598 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #599 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 5, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #600 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #601 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 6, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #602 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 7, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #603 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 807, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #604 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 9, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #605 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 9, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #606 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 9, Message: ReSharper: Type check and casts can be merged. See https://www.jetbrains.com/help/resharper/MergeCastWithTypeCheck.html / SonarQube: Duplicate casts should not be made. See https://rules.sonarsource.com/csharp/RSPEC-3247
    #607 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs, Line: 983, Message: ReSharper: Use string interpolation expression. See https://www.jetbrains.com/help/resharper/UseStringInterpolation.html
    #608 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\PublishedData\DataCollector.cs, Line: 142, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #609 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\PublishedData\DataCollector.cs, Line: 169, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #610 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\PublishedData\DataCollector.cs, Line: 75, Message: https://www.jetbrains.com/help/resharper/MergeSequentialChecks.html
    #611 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Uadp\UadpDataSetMessage.cs, Line: 341, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #612 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Uadp\UadpNetworkMessage.cs, Line: 954, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html
    #613 Path: D:\a\1\s\Libraries\Opc.Ua.PubSub\Uadp\UadpPubSubConnection.cs, Line: 218, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



Project: Opc.Ua.Security.Certificates(net462)
    #614 Path: D:\a\1\s\Libraries\Opc.Ua.Security.Certificates\Extensions\X509Extensions.cs, Line: 67, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #615 Path: D:\a\1\s\Libraries\Opc.Ua.Security.Certificates\Extensions\X509Extensions.cs, Line: 79, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #616 Path: D:\a\1\s\Libraries\Opc.Ua.Security.Certificates\Extensions\X509Extensions.cs, Line: 91, Message: ReSharper: ReplaceWithSingleCallToFirstOrDefault. / SonarQube "IEnumerable" LINQs should be simplified. See https://rules.sonarsource.com/csharp/RSPEC-2971
    #617 Path: D:\a\1\s\Libraries\Opc.Ua.Security.Certificates\Org.BouncyCastle\PEMReader.cs, Line: 75, Message: ReSharper: Convert 'as' expression type check and the following null check into pattern matching. See https://www.jetbrains.com/help/resharper/UsePatternMatching.html



--- Rules Summary ---
R7: 279
R8: 213
R9: 54
R5: 40
R2: 22
R4: 7
R6: 1
R10: 1

--- Summary ---
Fixed ReSharper issues: 595
Fixed SonarQube issues: 49
Total fixed issues: 617

Finished in: 1 min 4 s

######################################################################
Nr: 1 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\AverageAggregateCalculator.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class AverageAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public AverageAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = aggregateId != Opc.Ua.ObjectIds.AggregateFunction_Average;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            uint? id = AggregateId.Identifier as uint?;

            if (id != null)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_Average:
                    {
                        return ComputeAverage(slice);
                    }

                    case Objects.AggregateFunction_TimeAverage:
                    {
                        return ComputeTimeAverage(slice, false, 1);
                    }

                    case Objects.AggregateFunction_Total:
                    {
                        return ComputeTimeAverage(slice, false, 2);
                    }

                    case Objects.AggregateFunction_TimeAverage2:
                    {
                        return ComputeTimeAverage(slice, true, 1);
                    }

                    case Objects.AggregateFunction_Total2:
                    {
                        return ComputeTimeAverage(slice, true, 2);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculates the RegSlope, RegConst and RegStdDev aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeAverage(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // calculate total and count.
            int count = 0;
            double total = 0;

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (StatusCode.IsGood(values[ii].StatusCode))
                {
                    try
                    {
                        double sample = CastToDouble(values[ii]);
                        total += sample;
                        count++;
                    }
                    catch
                    {
                        // ignore conversion errors.
                    }
                }
            }

            // check for empty slice.
            if (count == 0)
            {
                return GetNoDataValue(slice);
            }

            // select the result.
            double result = total/count;

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(result, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
            value.StatusCode = GetValueBasedStatusCode(slice, values, value.StatusCode);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the StdDev, Variance, StdDev2 and Variance2 aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeTimeAverage(TimeSlice slice, bool useSimpleBounds, int valueType)
        {
            // get the values in the slice.
            List<DataValue> values = null;

            if (useSimpleBounds)
            {
                values = GetValuesWithSimpleBounds(slice);
            }
            else
            {
                values = GetValuesWithInterpolatedBounds(slice);
            }

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, !useSimpleBounds, Stepped);

            double total = 0;
            double totalDuration = 0;
            bool nonGoodRegionsExists = false;

            for (int ii = 0; ii < regions.Count; ii++)
            {
                double duration = regions[ii].Duration/1000.0;

                if (StatusCode.IsNotBad(regions[ii].StatusCode))
                {
                    total += (regions[ii].StartValue + regions[ii].EndValue) * duration / 2;
                    totalDuration += duration;
                }

                if (StatusCode.IsNotGood(regions[ii].StatusCode))
                {
                    nonGoodRegionsExists = true;
                }
            }

            // check if no good data.
            if (totalDuration == 0)
            {
                return GetNoDataValue(slice);
            }

            // select the result.
            double result = 0;

            switch (valueType)
            {
                case 1: { result = total/totalDuration; break; }
                case 2: { result = total; break; }
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(result, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);

            if (useSimpleBounds)
            {
                value.StatusCode = GetTimeBasedStatusCode(regions, value.StatusCode);
            }
            else
            {
                value.StatusCode = StatusCodes.Good;

                if (nonGoodRegionsExists)
                {
                    value.StatusCode = StatusCodes.UncertainDataSubNormal;
                }
            }

            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // return result.
            return value;
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class AverageAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public AverageAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = aggregateId != Opc.Ua.ObjectIds.AggregateFunction_Average;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            if (AggregateId.Identifier is uint? id)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_Average:
                    {
                        return ComputeAverage(slice);
                    }

                    case Objects.AggregateFunction_TimeAverage:
                    {
                        return ComputeTimeAverage(slice, false, 1);
                    }

                    case Objects.AggregateFunction_Total:
                    {
                        return ComputeTimeAverage(slice, false, 2);
                    }

                    case Objects.AggregateFunction_TimeAverage2:
                    {
                        return ComputeTimeAverage(slice, true, 1);
                    }

                    case Objects.AggregateFunction_Total2:
                    {
                        return ComputeTimeAverage(slice, true, 2);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculates the RegSlope, RegConst and RegStdDev aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeAverage(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // calculate total and count.
            int count = 0;
            double total = 0;

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (StatusCode.IsGood(values[ii].StatusCode))
                {
                    try
                    {
                        double sample = CastToDouble(values[ii]);
                        total += sample;
                        count++;
                    }
                    catch
                    {
                        // ignore conversion errors.
                    }
                }
            }

            // check for empty slice.
            if (count == 0)
            {
                return GetNoDataValue(slice);
            }

            // select the result.
            double result = total/count;

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(result, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
            value.StatusCode = GetValueBasedStatusCode(slice, values, value.StatusCode);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the StdDev, Variance, StdDev2 and Variance2 aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeTimeAverage(TimeSlice slice, bool useSimpleBounds, int valueType)
        {
            // get the values in the slice.
            List<DataValue> values = null;

            if (useSimpleBounds)
            {
                values = GetValuesWithSimpleBounds(slice);
            }
            else
            {
                values = GetValuesWithInterpolatedBounds(slice);
            }

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, !useSimpleBounds, Stepped);

            double total = 0;
            double totalDuration = 0;
            bool nonGoodRegionsExists = false;

            for (int ii = 0; ii < regions.Count; ii++)
            {
                double duration = regions[ii].Duration/1000.0;

                if (StatusCode.IsNotBad(regions[ii].StatusCode))
                {
                    total += (regions[ii].StartValue + regions[ii].EndValue) * duration / 2;
                    totalDuration += duration;
                }

                if (StatusCode.IsNotGood(regions[ii].StatusCode))
                {
                    nonGoodRegionsExists = true;
                }
            }

            // check if no good data.
            if (totalDuration == 0)
            {
                return GetNoDataValue(slice);
            }

            // select the result.
            double result = 0;

            switch (valueType)
            {
                case 1: { result = total/totalDuration; break; }
                case 2: { result = total; break; }
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(result, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);

            if (useSimpleBounds)
            {
                value.StatusCode = GetTimeBasedStatusCode(regions, value.StatusCode);
            }
            else
            {
                value.StatusCode = StatusCodes.Good;

                if (nonGoodRegionsExists)
                {
                    value.StatusCode = StatusCodes.UncertainDataSubNormal;
                }
            }

            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // return result.
            return value;
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\AverageAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\AverageAggregateCalculator.cs(71,43): error CS8116: It is not legal to use nullable type 'uint?' in a pattern; use the underlying type 'uint' instead.,D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\AverageAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 2 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\CountAggregateCalculator.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class CountAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public CountAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            uint? id = AggregateId.Identifier as uint?;

            if (id != null)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_Count:
                    {
                        return ComputeCount(slice);
                    }

                    case Objects.AggregateFunction_AnnotationCount:
                    {
                        return ComputeAnnotationCount(slice);
                    }

                    case Objects.AggregateFunction_DurationInStateZero:
                    {
                        return ComputeDurationInState(slice, false);
                    }

                    case Objects.AggregateFunction_DurationInStateNonZero:
                    {
                        return ComputeDurationInState(slice, true);
                    }

                    case Objects.AggregateFunction_NumberOfTransitions:
                    {
                        return ComputeNumberOfTransitions(slice);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculates the Count aggregate for the timeslice.
        /// </summary>
        protected DataValue ComputeCount(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null)
            {
                return GetNoDataValue(slice);
            }

            // count the values.
            int count = 0;

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (StatusCode.IsGood(values[ii].StatusCode))
                {
                    count++;
                }
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(count, TypeInfo.Scalars.Int32);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);           
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
            value.StatusCode = GetValueBasedStatusCode(slice, values, value.StatusCode);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the AnnotationCount aggregate for the timeslice.
        /// </summary>
        protected DataValue ComputeAnnotationCount(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null)
            {
                return GetNoDataValue(slice);
            }

            // count the values.
            int count = 0;

            for (int ii = 0; ii < values.Count; ii++)
            {
                count++;
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(count, TypeInfo.Scalars.Int32);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the DurationInStateZero and DurationInStateNonZero aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeDurationInState(TimeSlice slice, bool isNonZero)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, false, true);

            double duration = 0;

            for (int ii = 0; ii < regions.Count; ii++)
            {
                if (StatusCode.IsNotGood(regions[ii].StatusCode))
                {
                    continue;
                }

                if (isNonZero)
                {
                    if (regions[ii].StartValue != 0)
                    {
                        duration += regions[ii].Duration;
                    }
                }
                else
                {
                    if (regions[ii].StartValue == 0)
                    {
                        duration += regions[ii].Duration;
                    }
                }
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(duration, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
            value.StatusCode = GetTimeBasedStatusCode(regions, value.StatusCode);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the Count aggregate for the timeslice.
        /// </summary>
        protected DataValue ComputeNumberOfTransitions(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null)
            {
                return GetNoDataValue(slice);
            }

            // determine whether a transition occurs at the StartTime
            double lastValue = Double.NaN;

            if (slice.EarlyBound != null)
            {
                if (StatusCode.IsGood(slice.EarlyBound.Value.StatusCode))
                {
                    try
                    {
                        lastValue = CastToDouble(slice.EarlyBound.Value);
                    }
                    catch (Exception)
                    {
                        lastValue = Double.NaN;
                    }
                }
            }

            // count the transitions.
            int count = 0;

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (!IsGood(values[ii]))
                {
                    continue;
                }

                double nextValue = 0;

                try
                {
                    nextValue = CastToDouble(values[ii]);
                }
                catch (Exception)
                {
                    continue;
                }

                if (!Double.IsNaN(lastValue))
                {
                    if (lastValue != nextValue)
                    {
                        count++;
                    }
                }

                lastValue = nextValue;
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(count, TypeInfo.Scalars.Int32);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
            value.StatusCode = GetValueBasedStatusCode(slice, values, value.StatusCode);

            // return result.
            return value;
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class CountAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public CountAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            if (AggregateId.Identifier is uint? id)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_Count:
                    {
                        return ComputeCount(slice);
                    }

                    case Objects.AggregateFunction_AnnotationCount:
                    {
                        return ComputeAnnotationCount(slice);
                    }

                    case Objects.AggregateFunction_DurationInStateZero:
                    {
                        return ComputeDurationInState(slice, false);
                    }

                    case Objects.AggregateFunction_DurationInStateNonZero:
                    {
                        return ComputeDurationInState(slice, true);
                    }

                    case Objects.AggregateFunction_NumberOfTransitions:
                    {
                        return ComputeNumberOfTransitions(slice);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculates the Count aggregate for the timeslice.
        /// </summary>
        protected DataValue ComputeCount(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null)
            {
                return GetNoDataValue(slice);
            }

            // count the values.
            int count = 0;

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (StatusCode.IsGood(values[ii].StatusCode))
                {
                    count++;
                }
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(count, TypeInfo.Scalars.Int32);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);           
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
            value.StatusCode = GetValueBasedStatusCode(slice, values, value.StatusCode);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the AnnotationCount aggregate for the timeslice.
        /// </summary>
        protected DataValue ComputeAnnotationCount(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null)
            {
                return GetNoDataValue(slice);
            }

            // count the values.
            int count = 0;

            for (int ii = 0; ii < values.Count; ii++)
            {
                count++;
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(count, TypeInfo.Scalars.Int32);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the DurationInStateZero and DurationInStateNonZero aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeDurationInState(TimeSlice slice, bool isNonZero)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, false, true);

            double duration = 0;

            for (int ii = 0; ii < regions.Count; ii++)
            {
                if (StatusCode.IsNotGood(regions[ii].StatusCode))
                {
                    continue;
                }

                if (isNonZero)
                {
                    if (regions[ii].StartValue != 0)
                    {
                        duration += regions[ii].Duration;
                    }
                }
                else
                {
                    if (regions[ii].StartValue == 0)
                    {
                        duration += regions[ii].Duration;
                    }
                }
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(duration, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
            value.StatusCode = GetTimeBasedStatusCode(regions, value.StatusCode);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the Count aggregate for the timeslice.
        /// </summary>
        protected DataValue ComputeNumberOfTransitions(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null)
            {
                return GetNoDataValue(slice);
            }

            // determine whether a transition occurs at the StartTime
            double lastValue = Double.NaN;

            if (slice.EarlyBound != null)
            {
                if (StatusCode.IsGood(slice.EarlyBound.Value.StatusCode))
                {
                    try
                    {
                        lastValue = CastToDouble(slice.EarlyBound.Value);
                    }
                    catch (Exception)
                    {
                        lastValue = Double.NaN;
                    }
                }
            }

            // count the transitions.
            int count = 0;

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (!IsGood(values[ii]))
                {
                    continue;
                }

                double nextValue = 0;

                try
                {
                    nextValue = CastToDouble(values[ii]);
                }
                catch (Exception)
                {
                    continue;
                }

                if (!Double.IsNaN(lastValue))
                {
                    if (lastValue != nextValue)
                    {
                        count++;
                    }
                }

                lastValue = nextValue;
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(count, TypeInfo.Scalars.Int32);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
            value.StatusCode = GetValueBasedStatusCode(slice, values, value.StatusCode);

            // return result.
            return value;
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\CountAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\CountAggregateCalculator.cs(71,43): error CS8116: It is not legal to use nullable type 'uint?' in a pattern; use the underlying type 'uint' instead.,D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\CountAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 3 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\MinMaxAggregateCalculator.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class MinMaxAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public MinMaxAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            uint? id = AggregateId.Identifier as uint?;

            if (id != null)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_Minimum:
                    {
                        return ComputeMinMax(slice, 1, false);
                    }

                    case Objects.AggregateFunction_MinimumActualTime:
                    {
                        return ComputeMinMax(slice, 1, true);
                    }

                    case Objects.AggregateFunction_Maximum:
                    {
                        return ComputeMinMax(slice, 2, false);
                    }

                    case Objects.AggregateFunction_MaximumActualTime:
                    {
                        return ComputeMinMax(slice, 2, true);
                    }

                    case Objects.AggregateFunction_Range:
                    {
                        return ComputeMinMax(slice, 3, false);
                    }

                    case Objects.AggregateFunction_Minimum2:
                    {
                        return ComputeMinMax2(slice, 1, false);
                    }

                    case Objects.AggregateFunction_MinimumActualTime2:
                    {
                        return ComputeMinMax2(slice, 1, true);
                    }

                    case Objects.AggregateFunction_Maximum2:
                    {
                        return ComputeMinMax2(slice, 2, false);
                    }

                    case Objects.AggregateFunction_MaximumActualTime2:
                    {
                        return ComputeMinMax2(slice, 2, true);
                    }

                    case Objects.AggregateFunction_Range2:
                    {
                        return ComputeMinMax2(slice, 3, false);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculate the Minimum, Maximum, MinimumActualTime and MaximumActualTime aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeMinMax(TimeSlice slice, int valueType, bool returnActualTime)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            double minimumGoodValue = Double.MaxValue;
            double minimumUncertainValue = Double.MaxValue;
            double maximumGoodValue = Double.MinValue;
            double maximumUncertainValue = Double.MinValue;

            DateTime minimumGoodTimestamp = DateTime.MinValue;
            DateTime maximumGoodTimestamp = DateTime.MinValue;

            TypeInfo minimumOriginalType = null;
            TypeInfo maximumOriginalType = null;

            bool badValuesExist = false;
            bool duplicatesMinimumsExist = false;
            bool duplicatesMaximumsExist = false;
            bool goodValueExists = false;

            for (int ii = 0; ii < values.Count; ii++)
            {
                double currentValue = 0;
                DateTime currentTime = values[ii].SourceTimestamp;
                StatusCode currentStatus = values[ii].StatusCode;

                // ignore bad values.
                if (!IsGood(values[ii]))
                {
                    badValuesExist = true;
                    continue;
                }

                // convert to double.
                try
                {
                    currentValue = CastToDouble(values[ii]);
                }
                catch (Exception)
                {
                    badValuesExist = true;
                    continue;
                }

                // check for uncertain.
                if (StatusCode.IsUncertain(currentStatus))
                {
                    if (minimumUncertainValue > currentValue)
                    {
                        minimumUncertainValue = currentValue;
                    }

                    if (maximumUncertainValue < currentValue)
                    {
                        maximumUncertainValue = currentValue;
                    }

                    continue;
                }

                // check for new minimum.
                if (minimumGoodValue > currentValue)
                {
                    minimumGoodValue = currentValue;
                    minimumGoodTimestamp = currentTime;
                    minimumOriginalType = values[ii].WrappedValue.TypeInfo;
                    duplicatesMinimumsExist = false;
                    goodValueExists = true;
                }

                // check for duplicate minimums.
                else if (minimumGoodValue == currentValue)
                {
                    duplicatesMinimumsExist = true;
                }

                // check for new maximum.
                if (maximumGoodValue < currentValue)
                {
                    maximumGoodValue = currentValue;
                    maximumGoodTimestamp = currentTime;
                    maximumOriginalType = values[ii].WrappedValue.TypeInfo;
                    duplicatesMaximumsExist = false;
                    goodValueExists = true;
                }

                // check for duplicate maximums.
                else if (maximumGoodValue == currentValue)
                {
                    duplicatesMaximumsExist = true;
                }
            }

            // check if at least on good value exists.
            if (!goodValueExists)
            {
                return GetNoDataValue(slice);
            }

            // set the status code.
            StatusCode statusCode = StatusCodes.Good;

            // uncertain if any bad values exist.
            if (badValuesExist)
            {
                statusCode = StatusCodes.UncertainDataSubNormal;
            }

            // determine the calculated value to return.
            object processedValue = null;
            TypeInfo processedType = null;
            DateTime processedTimestamp = DateTime.MinValue;
            bool uncertainValueExists = false;
            bool duplicatesExist = false;

            if (valueType == 1)
            {
                processedValue = minimumGoodValue;
                processedTimestamp = minimumGoodTimestamp;
                processedType = minimumOriginalType;
                uncertainValueExists = minimumGoodValue > minimumUncertainValue;
                duplicatesExist = duplicatesMinimumsExist;
            }

            else if (valueType == 2)
            {
                processedValue = maximumGoodValue;
                processedTimestamp = maximumGoodTimestamp;
                processedType = maximumOriginalType;
                uncertainValueExists = maximumGoodValue < maximumUncertainValue;
                duplicatesExist = duplicatesMaximumsExist;
            }

            else if (valueType == 3)
            {
                processedValue = Math.Abs(maximumGoodValue - minimumGoodValue);
                processedType = TypeInfo.Scalars.Double;
                uncertainValueExists = maximumGoodValue < maximumUncertainValue || minimumGoodValue > minimumUncertainValue;
            }

            // set calculated if not returning actual time and value is not at the start time.
            if (!returnActualTime && processedTimestamp != slice.StartTime)
            {
                statusCode = statusCode.SetAggregateBits(AggregateBits.Calculated);
            }

            // set the multiple values flags.
            if (duplicatesExist)
            {
                statusCode = statusCode.SetAggregateBits(statusCode.AggregateBits | AggregateBits.MultipleValues);
            }

            // convert back to original datatype.
            if (processedType != null && processedType.BuiltInType != BuiltInType.Double)
            {
                processedValue = TypeInfo.Cast(processedValue, TypeInfo.Scalars.Double, processedType.BuiltInType);
            }
            else
            {
                processedType = TypeInfo.Scalars.Double;
            }

            // create processed value.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(processedValue, processedType);
            value.StatusCode = statusCode;

            if (returnActualTime)
            {
                value.SourceTimestamp = processedTimestamp;
                value.ServerTimestamp = processedTimestamp;
            }
            else
            {
                value.SourceTimestamp = GetTimestamp(slice);
                value.ServerTimestamp = GetTimestamp(slice);
            }

            return value;
        }

        /// <summary>
        /// Calculate the Minimum2, Maximum2, MinimumActualTime2, MaximumActualTime2 and Range2 aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeMinMax2(TimeSlice slice, int valueType, bool returnActualTime)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            double minimumGoodValue = Double.MaxValue;
            double maximumGoodValue = Double.MinValue;

            DateTime minimumGoodTimestamp = DateTime.MinValue;
            DateTime maximumGoodTimestamp = DateTime.MinValue;

            StatusCode minimumGoodStatusCode = StatusCodes.Good;
            StatusCode maximumGoodStatusCode = StatusCodes.Good;

            TypeInfo minimumOriginalType = null;
            TypeInfo maximumOriginalType = null;

            bool duplicatesMinimumsExist = false;
            bool duplicatesMaximumsExist = false;
            bool goodValueExists = false;

            for (int ii = 0; ii < values.Count; ii++)
            {
                double currentValue = 0;
                DateTime currentTime = values[ii].SourceTimestamp;
                StatusCode currentStatus = values[ii].StatusCode;

                // ignore bad values (as determined by the TreatUncertainAsBad parameter).
                if (!IsGood(values[ii]))
                {
                    continue;
                }

                // convert to double.
                try
                {
                    currentValue = CastToDouble(values[ii]);
                }
                catch (Exception)
                {
                    continue;
                }

                // skip endpoint if stepped.
                if (currentTime == slice.EndTime)
                {
                    if (Stepped)
                    {
                        break;
                    }
                }

                // check for new minimum.
                if (minimumGoodValue > currentValue)
                {
                    minimumGoodValue = currentValue;
                    minimumGoodTimestamp = currentTime;
                    minimumGoodStatusCode = currentStatus;
                    minimumOriginalType = values[ii].WrappedValue.TypeInfo;
                    duplicatesMinimumsExist = false;
                    goodValueExists = true;
                }

                // check for duplicate minimums.
                else if (minimumGoodValue == currentValue)
                {
                    duplicatesMinimumsExist = true;
                }

                // check for new maximum.
                if (maximumGoodValue < currentValue)
                {
                    maximumGoodValue = currentValue;
                    maximumGoodTimestamp = currentTime;
                    maximumGoodStatusCode = currentStatus;
                    maximumOriginalType = values[ii].WrappedValue.TypeInfo;
                    duplicatesMaximumsExist = false;
                    goodValueExists = true;
                }

                // check for duplicate maximums.
                else if (maximumGoodValue == currentValue)
                {
                    duplicatesMaximumsExist = true;
                }
            }

            // check if at least on good value exists.
            if (!goodValueExists)
            {
                return GetNoDataValue(slice);
            }

            // determine the calculated value to return.
            object processedValue = null;
            TypeInfo processedType = null;
            DateTime processedTimestamp = DateTime.MinValue;
            StatusCode processedStatusCode = StatusCodes.Good;
            bool duplicatesExist = false;

            if (valueType == 1)
            {
                processedValue = minimumGoodValue;
                processedTimestamp = minimumGoodTimestamp;
                processedStatusCode = minimumGoodStatusCode;
                processedType = minimumOriginalType;
                duplicatesExist = duplicatesMinimumsExist;
            }

            else if (valueType == 2)
            {
                processedValue = maximumGoodValue;
                processedTimestamp = maximumGoodTimestamp;
                processedStatusCode = maximumGoodStatusCode;
                processedType = maximumOriginalType;
                duplicatesExist = duplicatesMaximumsExist;
            }

            else if (valueType == 3)
            {
                processedValue = Math.Abs(maximumGoodValue - minimumGoodValue);
                processedType = TypeInfo.Scalars.Double;
            }

            // set the status code.
            StatusCode statusCode = processedStatusCode;

            // set calculated if not returning actual time and value is not at the start time.
            if (!returnActualTime && processedTimestamp != slice.StartTime && (statusCode.AggregateBits & AggregateBits.Interpolated) == 0)
            {
                statusCode = statusCode.SetAggregateBits(statusCode.AggregateBits | AggregateBits.Calculated);
            }

            // set the multiple values flags.
            if (duplicatesExist)
            {
                statusCode = statusCode.SetAggregateBits(statusCode.AggregateBits | AggregateBits.MultipleValues);
            }

            // convert back to original datatype.
            if (processedType != null && processedType.BuiltInType != BuiltInType.Double)
            {
                processedValue = TypeInfo.Cast(processedValue, TypeInfo.Scalars.Double, processedType.BuiltInType);
            }
            else
            {
                processedType = TypeInfo.Scalars.Double;
            }

            // create processed value.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(processedValue, processedType);
            value.StatusCode = GetTimeBasedStatusCode(slice, values, statusCode);

            // zero value if status is bad.
            if (StatusCode.IsBad(value.StatusCode))
            {
                value.WrappedValue = Variant.Null;
            }

            if (returnActualTime)
            {
                // calculate effective time if end bound is used.
                if (TimeFlowsBackward)
                {
                    if (processedTimestamp == slice.StartTime)
                    {
                        processedTimestamp = processedTimestamp.AddMilliseconds(+1);
                        value.StatusCode = value.StatusCode.SetAggregateBits(value.StatusCode.AggregateBits | AggregateBits.Interpolated);
                    }
                }
                else
                {
                    if (processedTimestamp == slice.EndTime)
                    {
                        processedTimestamp = processedTimestamp.AddMilliseconds(-1);
                        value.StatusCode = value.StatusCode.SetAggregateBits(value.StatusCode.AggregateBits | AggregateBits.Interpolated);
                    }
                }

                value.SourceTimestamp = processedTimestamp;
                value.ServerTimestamp = processedTimestamp;
            }
            else
            {
                value.SourceTimestamp = GetTimestamp(slice);
                value.ServerTimestamp = GetTimestamp(slice);
            }

            return value;
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class MinMaxAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public MinMaxAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            if (AggregateId.Identifier is uint? id)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_Minimum:
                    {
                        return ComputeMinMax(slice, 1, false);
                    }

                    case Objects.AggregateFunction_MinimumActualTime:
                    {
                        return ComputeMinMax(slice, 1, true);
                    }

                    case Objects.AggregateFunction_Maximum:
                    {
                        return ComputeMinMax(slice, 2, false);
                    }

                    case Objects.AggregateFunction_MaximumActualTime:
                    {
                        return ComputeMinMax(slice, 2, true);
                    }

                    case Objects.AggregateFunction_Range:
                    {
                        return ComputeMinMax(slice, 3, false);
                    }

                    case Objects.AggregateFunction_Minimum2:
                    {
                        return ComputeMinMax2(slice, 1, false);
                    }

                    case Objects.AggregateFunction_MinimumActualTime2:
                    {
                        return ComputeMinMax2(slice, 1, true);
                    }

                    case Objects.AggregateFunction_Maximum2:
                    {
                        return ComputeMinMax2(slice, 2, false);
                    }

                    case Objects.AggregateFunction_MaximumActualTime2:
                    {
                        return ComputeMinMax2(slice, 2, true);
                    }

                    case Objects.AggregateFunction_Range2:
                    {
                        return ComputeMinMax2(slice, 3, false);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculate the Minimum, Maximum, MinimumActualTime and MaximumActualTime aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeMinMax(TimeSlice slice, int valueType, bool returnActualTime)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            double minimumGoodValue = Double.MaxValue;
            double minimumUncertainValue = Double.MaxValue;
            double maximumGoodValue = Double.MinValue;
            double maximumUncertainValue = Double.MinValue;

            DateTime minimumGoodTimestamp = DateTime.MinValue;
            DateTime maximumGoodTimestamp = DateTime.MinValue;

            TypeInfo minimumOriginalType = null;
            TypeInfo maximumOriginalType = null;

            bool badValuesExist = false;
            bool duplicatesMinimumsExist = false;
            bool duplicatesMaximumsExist = false;
            bool goodValueExists = false;

            for (int ii = 0; ii < values.Count; ii++)
            {
                double currentValue = 0;
                DateTime currentTime = values[ii].SourceTimestamp;
                StatusCode currentStatus = values[ii].StatusCode;

                // ignore bad values.
                if (!IsGood(values[ii]))
                {
                    badValuesExist = true;
                    continue;
                }

                // convert to double.
                try
                {
                    currentValue = CastToDouble(values[ii]);
                }
                catch (Exception)
                {
                    badValuesExist = true;
                    continue;
                }

                // check for uncertain.
                if (StatusCode.IsUncertain(currentStatus))
                {
                    if (minimumUncertainValue > currentValue)
                    {
                        minimumUncertainValue = currentValue;
                    }

                    if (maximumUncertainValue < currentValue)
                    {
                        maximumUncertainValue = currentValue;
                    }

                    continue;
                }

                // check for new minimum.
                if (minimumGoodValue > currentValue)
                {
                    minimumGoodValue = currentValue;
                    minimumGoodTimestamp = currentTime;
                    minimumOriginalType = values[ii].WrappedValue.TypeInfo;
                    duplicatesMinimumsExist = false;
                    goodValueExists = true;
                }

                // check for duplicate minimums.
                else if (minimumGoodValue == currentValue)
                {
                    duplicatesMinimumsExist = true;
                }

                // check for new maximum.
                if (maximumGoodValue < currentValue)
                {
                    maximumGoodValue = currentValue;
                    maximumGoodTimestamp = currentTime;
                    maximumOriginalType = values[ii].WrappedValue.TypeInfo;
                    duplicatesMaximumsExist = false;
                    goodValueExists = true;
                }

                // check for duplicate maximums.
                else if (maximumGoodValue == currentValue)
                {
                    duplicatesMaximumsExist = true;
                }
            }

            // check if at least on good value exists.
            if (!goodValueExists)
            {
                return GetNoDataValue(slice);
            }

            // set the status code.
            StatusCode statusCode = StatusCodes.Good;

            // uncertain if any bad values exist.
            if (badValuesExist)
            {
                statusCode = StatusCodes.UncertainDataSubNormal;
            }

            // determine the calculated value to return.
            object processedValue = null;
            TypeInfo processedType = null;
            DateTime processedTimestamp = DateTime.MinValue;
            bool uncertainValueExists = false;
            bool duplicatesExist = false;

            if (valueType == 1)
            {
                processedValue = minimumGoodValue;
                processedTimestamp = minimumGoodTimestamp;
                processedType = minimumOriginalType;
                uncertainValueExists = minimumGoodValue > minimumUncertainValue;
                duplicatesExist = duplicatesMinimumsExist;
            }

            else if (valueType == 2)
            {
                processedValue = maximumGoodValue;
                processedTimestamp = maximumGoodTimestamp;
                processedType = maximumOriginalType;
                uncertainValueExists = maximumGoodValue < maximumUncertainValue;
                duplicatesExist = duplicatesMaximumsExist;
            }

            else if (valueType == 3)
            {
                processedValue = Math.Abs(maximumGoodValue - minimumGoodValue);
                processedType = TypeInfo.Scalars.Double;
                uncertainValueExists = maximumGoodValue < maximumUncertainValue || minimumGoodValue > minimumUncertainValue;
            }

            // set calculated if not returning actual time and value is not at the start time.
            if (!returnActualTime && processedTimestamp != slice.StartTime)
            {
                statusCode = statusCode.SetAggregateBits(AggregateBits.Calculated);
            }

            // set the multiple values flags.
            if (duplicatesExist)
            {
                statusCode = statusCode.SetAggregateBits(statusCode.AggregateBits | AggregateBits.MultipleValues);
            }

            // convert back to original datatype.
            if (processedType != null && processedType.BuiltInType != BuiltInType.Double)
            {
                processedValue = TypeInfo.Cast(processedValue, TypeInfo.Scalars.Double, processedType.BuiltInType);
            }
            else
            {
                processedType = TypeInfo.Scalars.Double;
            }

            // create processed value.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(processedValue, processedType);
            value.StatusCode = statusCode;

            if (returnActualTime)
            {
                value.SourceTimestamp = processedTimestamp;
                value.ServerTimestamp = processedTimestamp;
            }
            else
            {
                value.SourceTimestamp = GetTimestamp(slice);
                value.ServerTimestamp = GetTimestamp(slice);
            }

            return value;
        }

        /// <summary>
        /// Calculate the Minimum2, Maximum2, MinimumActualTime2, MaximumActualTime2 and Range2 aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeMinMax2(TimeSlice slice, int valueType, bool returnActualTime)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            double minimumGoodValue = Double.MaxValue;
            double maximumGoodValue = Double.MinValue;

            DateTime minimumGoodTimestamp = DateTime.MinValue;
            DateTime maximumGoodTimestamp = DateTime.MinValue;

            StatusCode minimumGoodStatusCode = StatusCodes.Good;
            StatusCode maximumGoodStatusCode = StatusCodes.Good;

            TypeInfo minimumOriginalType = null;
            TypeInfo maximumOriginalType = null;

            bool duplicatesMinimumsExist = false;
            bool duplicatesMaximumsExist = false;
            bool goodValueExists = false;

            for (int ii = 0; ii < values.Count; ii++)
            {
                double currentValue = 0;
                DateTime currentTime = values[ii].SourceTimestamp;
                StatusCode currentStatus = values[ii].StatusCode;

                // ignore bad values (as determined by the TreatUncertainAsBad parameter).
                if (!IsGood(values[ii]))
                {
                    continue;
                }

                // convert to double.
                try
                {
                    currentValue = CastToDouble(values[ii]);
                }
                catch (Exception)
                {
                    continue;
                }

                // skip endpoint if stepped.
                if (currentTime == slice.EndTime)
                {
                    if (Stepped)
                    {
                        break;
                    }
                }

                // check for new minimum.
                if (minimumGoodValue > currentValue)
                {
                    minimumGoodValue = currentValue;
                    minimumGoodTimestamp = currentTime;
                    minimumGoodStatusCode = currentStatus;
                    minimumOriginalType = values[ii].WrappedValue.TypeInfo;
                    duplicatesMinimumsExist = false;
                    goodValueExists = true;
                }

                // check for duplicate minimums.
                else if (minimumGoodValue == currentValue)
                {
                    duplicatesMinimumsExist = true;
                }

                // check for new maximum.
                if (maximumGoodValue < currentValue)
                {
                    maximumGoodValue = currentValue;
                    maximumGoodTimestamp = currentTime;
                    maximumGoodStatusCode = currentStatus;
                    maximumOriginalType = values[ii].WrappedValue.TypeInfo;
                    duplicatesMaximumsExist = false;
                    goodValueExists = true;
                }

                // check for duplicate maximums.
                else if (maximumGoodValue == currentValue)
                {
                    duplicatesMaximumsExist = true;
                }
            }

            // check if at least on good value exists.
            if (!goodValueExists)
            {
                return GetNoDataValue(slice);
            }

            // determine the calculated value to return.
            object processedValue = null;
            TypeInfo processedType = null;
            DateTime processedTimestamp = DateTime.MinValue;
            StatusCode processedStatusCode = StatusCodes.Good;
            bool duplicatesExist = false;

            if (valueType == 1)
            {
                processedValue = minimumGoodValue;
                processedTimestamp = minimumGoodTimestamp;
                processedStatusCode = minimumGoodStatusCode;
                processedType = minimumOriginalType;
                duplicatesExist = duplicatesMinimumsExist;
            }

            else if (valueType == 2)
            {
                processedValue = maximumGoodValue;
                processedTimestamp = maximumGoodTimestamp;
                processedStatusCode = maximumGoodStatusCode;
                processedType = maximumOriginalType;
                duplicatesExist = duplicatesMaximumsExist;
            }

            else if (valueType == 3)
            {
                processedValue = Math.Abs(maximumGoodValue - minimumGoodValue);
                processedType = TypeInfo.Scalars.Double;
            }

            // set the status code.
            StatusCode statusCode = processedStatusCode;

            // set calculated if not returning actual time and value is not at the start time.
            if (!returnActualTime && processedTimestamp != slice.StartTime && (statusCode.AggregateBits & AggregateBits.Interpolated) == 0)
            {
                statusCode = statusCode.SetAggregateBits(statusCode.AggregateBits | AggregateBits.Calculated);
            }

            // set the multiple values flags.
            if (duplicatesExist)
            {
                statusCode = statusCode.SetAggregateBits(statusCode.AggregateBits | AggregateBits.MultipleValues);
            }

            // convert back to original datatype.
            if (processedType != null && processedType.BuiltInType != BuiltInType.Double)
            {
                processedValue = TypeInfo.Cast(processedValue, TypeInfo.Scalars.Double, processedType.BuiltInType);
            }
            else
            {
                processedType = TypeInfo.Scalars.Double;
            }

            // create processed value.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(processedValue, processedType);
            value.StatusCode = GetTimeBasedStatusCode(slice, values, statusCode);

            // zero value if status is bad.
            if (StatusCode.IsBad(value.StatusCode))
            {
                value.WrappedValue = Variant.Null;
            }

            if (returnActualTime)
            {
                // calculate effective time if end bound is used.
                if (TimeFlowsBackward)
                {
                    if (processedTimestamp == slice.StartTime)
                    {
                        processedTimestamp = processedTimestamp.AddMilliseconds(+1);
                        value.StatusCode = value.StatusCode.SetAggregateBits(value.StatusCode.AggregateBits | AggregateBits.Interpolated);
                    }
                }
                else
                {
                    if (processedTimestamp == slice.EndTime)
                    {
                        processedTimestamp = processedTimestamp.AddMilliseconds(-1);
                        value.StatusCode = value.StatusCode.SetAggregateBits(value.StatusCode.AggregateBits | AggregateBits.Interpolated);
                    }
                }

                value.SourceTimestamp = processedTimestamp;
                value.ServerTimestamp = processedTimestamp;
            }
            else
            {
                value.SourceTimestamp = GetTimestamp(slice);
                value.ServerTimestamp = GetTimestamp(slice);
            }

            return value;
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\MinMaxAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\MinMaxAggregateCalculator.cs(71,43): error CS8116: It is not legal to use nullable type 'uint?' in a pattern; use the underlying type 'uint' instead.,D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\MinMaxAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 4 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StartEndAggregateCalculator.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class StartEndAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public StartEndAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            uint? id = AggregateId.Identifier as uint?;

            if (id != null)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_Start:
                    {
                        return ComputeStartEnd(slice, false);
                    }

                    case Objects.AggregateFunction_End:
                    {
                        return ComputeStartEnd(slice, true);
                    }

                    case Objects.AggregateFunction_Delta:
                    {
                        return ComputeDelta(slice);
                    }

                    case Objects.AggregateFunction_StartBound:
                    {
                        return ComputeStartEnd2(slice, false);
                    }

                    case Objects.AggregateFunction_EndBound:
                    {
                        return ComputeStartEnd2(slice, true);
                    }

                    case Objects.AggregateFunction_DeltaBounds:
                    {
                        return ComputeDelta2(slice);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculate the Start and End aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeStartEnd(TimeSlice slice, bool returnEnd)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // return start value.
            if (!returnEnd)
            {
                return values[0];
            }

            // return end value.
            else
            {
                return values[values.Count - 1];
            }
        }

        /// <summary>
        /// Calculates the Delta aggregate for the timeslice.
        /// </summary>
        protected DataValue ComputeDelta(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // find start value.
            DataValue start = null;
            double startValue = 0;
            TypeInfo originalType = null;
            bool badDataSkipped = false;

            for (int ii = 0; ii < values.Count; ii++)
            {
                start = values[ii];

                if (StatusCode.IsGood(start.StatusCode))
                {
                    try
                    {
                        startValue = CastToDouble(start);
                        originalType = start.WrappedValue.TypeInfo;
                        break;
                    }
                    catch (Exception)
                    {
                        startValue = Double.NaN;
                    }
                }

                start = null;
                badDataSkipped = true;
            }

            // find end value.
            DataValue end = null;
            double endValue = 0;

            for (int ii = values.Count - 1; ii >= 0; ii--)
            {
                end = values[ii];

                if (StatusCode.IsGood(end.StatusCode))
                {
                    try
                    {
                        endValue = CastToDouble(end);
                        break;
                    }
                    catch (Exception)
                    {
                        endValue = Double.NaN;
                    }

                    break;
                }

                end = null;
                badDataSkipped = true;
            }

            // check if no good data.
            if (Double.IsNaN(startValue) || Double.IsNaN(endValue))
            {
                return GetNoDataValue(slice);
            }
            
            DataValue value = new DataValue();
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);

            // set status code.
            if (badDataSkipped)
            {
                value.StatusCode = StatusCodes.UncertainDataSubNormal;
            }
            
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
            
            // calculate delta.
            double delta = endValue - startValue;

            if (originalType != null && originalType.BuiltInType != BuiltInType.Double)
            {
                object delta2 = TypeInfo.Cast(delta, TypeInfo.Scalars.Double, originalType.BuiltInType);
                value.WrappedValue = new Variant(delta2, originalType);
            }
            else
            {
                value.WrappedValue = new Variant(delta, TypeInfo.Scalars.Double);
            }

            // return result.
            return value;
        }

        /// <summary>
        /// Calculate the Start2 and End2 aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeStartEnd2(TimeSlice slice, bool returnEnd)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            DataValue value = null;

            // return start bound.
            if ((!returnEnd && !TimeFlowsBackward) || (returnEnd && TimeFlowsBackward))
            {
                value = values[0];
            }

            // return end bound.
            else
            {
                value = values[values.Count - 1];
            }

            if (returnEnd)
            {
                value.SourceTimestamp = GetTimestamp(slice);
                value.ServerTimestamp = GetTimestamp(slice);

                if (StatusCode.IsNotBad(value.StatusCode))
                {
                    value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
                }
            }

            return value;
        }

        /// <summary>
        /// Calculates the Delta2 aggregate for the timeslice.
        /// </summary>
        protected DataValue ComputeDelta2(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            DataValue start = values[0];
            DataValue end = values[values.Count-1];

            // check for bad bounds.
            if (StatusCode.IsBad(start.StatusCode) || StatusCode.IsBad(end.StatusCode))
            {
                return GetNoDataValue(slice);
            }

            // convert to doubles.
            double startValue = 0;
            TypeInfo originalType = null;

            try
            {
                startValue = CastToDouble(start);
                originalType = start.WrappedValue.TypeInfo;
            }
            catch (Exception)
            {
                startValue = Double.NaN;
            }

            double endValue = 0;

            try
            {
                endValue = CastToDouble(end);
            }
            catch (Exception)
            {
                endValue = Double.NaN;
            }

            // check for bad bounds.
            if (Double.IsNaN(startValue) || Double.IsNaN(endValue))
            {
                return GetNoDataValue(slice);
            }

            DataValue value = new DataValue();
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);

            if (StatusCode.IsNotGood(start.StatusCode) || StatusCode.IsNotGood(end.StatusCode))
            {
                value.StatusCode = StatusCodes.UncertainDataSubNormal;
            }

            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // calculate delta.
            double delta = endValue - startValue;

            if (originalType != null && originalType.BuiltInType != BuiltInType.Double)
            {
                object delta2 = TypeInfo.Cast(delta, TypeInfo.Scalars.Double, originalType.BuiltInType);
                value.WrappedValue = new Variant(delta2, originalType);
            }
            else
            {
                value.WrappedValue = new Variant(delta, TypeInfo.Scalars.Double);
            }

            // return result.
            return value;
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class StartEndAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public StartEndAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            if (AggregateId.Identifier is uint? id)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_Start:
                    {
                        return ComputeStartEnd(slice, false);
                    }

                    case Objects.AggregateFunction_End:
                    {
                        return ComputeStartEnd(slice, true);
                    }

                    case Objects.AggregateFunction_Delta:
                    {
                        return ComputeDelta(slice);
                    }

                    case Objects.AggregateFunction_StartBound:
                    {
                        return ComputeStartEnd2(slice, false);
                    }

                    case Objects.AggregateFunction_EndBound:
                    {
                        return ComputeStartEnd2(slice, true);
                    }

                    case Objects.AggregateFunction_DeltaBounds:
                    {
                        return ComputeDelta2(slice);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculate the Start and End aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeStartEnd(TimeSlice slice, bool returnEnd)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // return start value.
            if (!returnEnd)
            {
                return values[0];
            }

            // return end value.
            else
            {
                return values[values.Count - 1];
            }
        }

        /// <summary>
        /// Calculates the Delta aggregate for the timeslice.
        /// </summary>
        protected DataValue ComputeDelta(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValues(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // find start value.
            DataValue start = null;
            double startValue = 0;
            TypeInfo originalType = null;
            bool badDataSkipped = false;

            for (int ii = 0; ii < values.Count; ii++)
            {
                start = values[ii];

                if (StatusCode.IsGood(start.StatusCode))
                {
                    try
                    {
                        startValue = CastToDouble(start);
                        originalType = start.WrappedValue.TypeInfo;
                        break;
                    }
                    catch (Exception)
                    {
                        startValue = Double.NaN;
                    }
                }

                start = null;
                badDataSkipped = true;
            }

            // find end value.
            DataValue end = null;
            double endValue = 0;

            for (int ii = values.Count - 1; ii >= 0; ii--)
            {
                end = values[ii];

                if (StatusCode.IsGood(end.StatusCode))
                {
                    try
                    {
                        endValue = CastToDouble(end);
                        break;
                    }
                    catch (Exception)
                    {
                        endValue = Double.NaN;
                    }

                    break;
                }

                end = null;
                badDataSkipped = true;
            }

            // check if no good data.
            if (Double.IsNaN(startValue) || Double.IsNaN(endValue))
            {
                return GetNoDataValue(slice);
            }
            
            DataValue value = new DataValue();
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);

            // set status code.
            if (badDataSkipped)
            {
                value.StatusCode = StatusCodes.UncertainDataSubNormal;
            }
            
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
            
            // calculate delta.
            double delta = endValue - startValue;

            if (originalType != null && originalType.BuiltInType != BuiltInType.Double)
            {
                object delta2 = TypeInfo.Cast(delta, TypeInfo.Scalars.Double, originalType.BuiltInType);
                value.WrappedValue = new Variant(delta2, originalType);
            }
            else
            {
                value.WrappedValue = new Variant(delta, TypeInfo.Scalars.Double);
            }

            // return result.
            return value;
        }

        /// <summary>
        /// Calculate the Start2 and End2 aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeStartEnd2(TimeSlice slice, bool returnEnd)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            DataValue value = null;

            // return start bound.
            if ((!returnEnd && !TimeFlowsBackward) || (returnEnd && TimeFlowsBackward))
            {
                value = values[0];
            }

            // return end bound.
            else
            {
                value = values[values.Count - 1];
            }

            if (returnEnd)
            {
                value.SourceTimestamp = GetTimestamp(slice);
                value.ServerTimestamp = GetTimestamp(slice);

                if (StatusCode.IsNotBad(value.StatusCode))
                {
                    value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);
                }
            }

            return value;
        }

        /// <summary>
        /// Calculates the Delta2 aggregate for the timeslice.
        /// </summary>
        protected DataValue ComputeDelta2(TimeSlice slice)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            DataValue start = values[0];
            DataValue end = values[values.Count-1];

            // check for bad bounds.
            if (StatusCode.IsBad(start.StatusCode) || StatusCode.IsBad(end.StatusCode))
            {
                return GetNoDataValue(slice);
            }

            // convert to doubles.
            double startValue = 0;
            TypeInfo originalType = null;

            try
            {
                startValue = CastToDouble(start);
                originalType = start.WrappedValue.TypeInfo;
            }
            catch (Exception)
            {
                startValue = Double.NaN;
            }

            double endValue = 0;

            try
            {
                endValue = CastToDouble(end);
            }
            catch (Exception)
            {
                endValue = Double.NaN;
            }

            // check for bad bounds.
            if (Double.IsNaN(startValue) || Double.IsNaN(endValue))
            {
                return GetNoDataValue(slice);
            }

            DataValue value = new DataValue();
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);

            if (StatusCode.IsNotGood(start.StatusCode) || StatusCode.IsNotGood(end.StatusCode))
            {
                value.StatusCode = StatusCodes.UncertainDataSubNormal;
            }

            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // calculate delta.
            double delta = endValue - startValue;

            if (originalType != null && originalType.BuiltInType != BuiltInType.Double)
            {
                object delta2 = TypeInfo.Cast(delta, TypeInfo.Scalars.Double, originalType.BuiltInType);
                value.WrappedValue = new Variant(delta2, originalType);
            }
            else
            {
                value.WrappedValue = new Variant(delta, TypeInfo.Scalars.Double);
            }

            // return result.
            return value;
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StartEndAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StartEndAggregateCalculator.cs(71,43): error CS8116: It is not legal to use nullable type 'uint?' in a pattern; use the underlying type 'uint' instead.,D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StartEndAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 5 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StatusAggregateCalculator.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class StatusAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public StatusAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            uint? id = AggregateId.Identifier as uint?;

            if (id != null)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_DurationGood:
                    {
                        return ComputeDurationGoodBad(slice, false, false);
                    }

                    case Objects.AggregateFunction_DurationBad:
                    {
                        return ComputeDurationGoodBad(slice, true, false);
                    }

                    case Objects.AggregateFunction_PercentGood:
                    {
                        return ComputeDurationGoodBad(slice, false, true);
                    }

                    case Objects.AggregateFunction_PercentBad:
                    {
                        return ComputeDurationGoodBad(slice, true, true);
                    }

                    case Objects.AggregateFunction_WorstQuality:
                    {
                        return ComputeWorstQuality(slice, false);
                    }

                    case Objects.AggregateFunction_WorstQuality2:
                    {
                        return ComputeWorstQuality(slice, true);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculates the DurationGood and DurationBad aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeDurationGoodBad(TimeSlice slice, bool isBad, bool usePercent)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, false, true);

            double duration = 0;
            double total = 0;

            for (int ii = 0; ii < regions.Count; ii++)
            {
                total += regions[ii].Duration;

                if (isBad)
                {
                    if (StatusCode.IsBad(regions[ii].StatusCode))
                    {
                        duration += regions[ii].Duration;
                    }
                }
                else
                {
                    if (StatusCode.IsGood(regions[ii].StatusCode))
                    {
                        duration += regions[ii].Duration;
                    }
                }
            }

            if (usePercent)
            {
                duration = (duration / total) * 100;
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(duration, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);            
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the DurationGood and DurationBad aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeWorstQuality(TimeSlice slice, bool includeBounds)
        {
            // get the values in the slice.
            List<DataValue> values = null;
            
            if (!includeBounds)
            {
                values = GetValues(slice);
            }
            else
            {
                values = GetValuesWithSimpleBounds(slice);
            }

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, false, true);

            StatusCode worstQuality = StatusCodes.Good;
            int badQualityCount = 0;
            int uncertainQualityCount = 0;

            for (int ii = 0; ii < values.Count; ii++)
            {
                StatusCode quality = values[ii].StatusCode;

                if (StatusCode.IsBad(quality))
                {
                    badQualityCount++;

                    if (StatusCode.IsNotBad(worstQuality))
                    {
                        worstQuality = quality.CodeBits;
                    }

                    continue;
                }

                if (StatusCode.IsUncertain(quality))
                {
                    uncertainQualityCount++;

                    if (StatusCode.IsGood(worstQuality))
                    {
                        worstQuality = quality.CodeBits;
                    }

                    continue;
                }
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(worstQuality, TypeInfo.Scalars.StatusCode);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            if ((StatusCode.IsBad(worstQuality) && badQualityCount > 1) || (StatusCode.IsUncertain(worstQuality) && uncertainQualityCount > 1))
            {
                value.StatusCode = value.StatusCode.SetAggregateBits(value.StatusCode.AggregateBits | AggregateBits.MultipleValues);
            }

            // return result.
            return value;
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class StatusAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public StatusAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            if (AggregateId.Identifier is uint? id)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_DurationGood:
                    {
                        return ComputeDurationGoodBad(slice, false, false);
                    }

                    case Objects.AggregateFunction_DurationBad:
                    {
                        return ComputeDurationGoodBad(slice, true, false);
                    }

                    case Objects.AggregateFunction_PercentGood:
                    {
                        return ComputeDurationGoodBad(slice, false, true);
                    }

                    case Objects.AggregateFunction_PercentBad:
                    {
                        return ComputeDurationGoodBad(slice, true, true);
                    }

                    case Objects.AggregateFunction_WorstQuality:
                    {
                        return ComputeWorstQuality(slice, false);
                    }

                    case Objects.AggregateFunction_WorstQuality2:
                    {
                        return ComputeWorstQuality(slice, true);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculates the DurationGood and DurationBad aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeDurationGoodBad(TimeSlice slice, bool isBad, bool usePercent)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, false, true);

            double duration = 0;
            double total = 0;

            for (int ii = 0; ii < regions.Count; ii++)
            {
                total += regions[ii].Duration;

                if (isBad)
                {
                    if (StatusCode.IsBad(regions[ii].StatusCode))
                    {
                        duration += regions[ii].Duration;
                    }
                }
                else
                {
                    if (StatusCode.IsGood(regions[ii].StatusCode))
                    {
                        duration += regions[ii].Duration;
                    }
                }
            }

            if (usePercent)
            {
                duration = (duration / total) * 100;
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(duration, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);            
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the DurationGood and DurationBad aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeWorstQuality(TimeSlice slice, bool includeBounds)
        {
            // get the values in the slice.
            List<DataValue> values = null;
            
            if (!includeBounds)
            {
                values = GetValues(slice);
            }
            else
            {
                values = GetValuesWithSimpleBounds(slice);
            }

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, false, true);

            StatusCode worstQuality = StatusCodes.Good;
            int badQualityCount = 0;
            int uncertainQualityCount = 0;

            for (int ii = 0; ii < values.Count; ii++)
            {
                StatusCode quality = values[ii].StatusCode;

                if (StatusCode.IsBad(quality))
                {
                    badQualityCount++;

                    if (StatusCode.IsNotBad(worstQuality))
                    {
                        worstQuality = quality.CodeBits;
                    }

                    continue;
                }

                if (StatusCode.IsUncertain(quality))
                {
                    uncertainQualityCount++;

                    if (StatusCode.IsGood(worstQuality))
                    {
                        worstQuality = quality.CodeBits;
                    }

                    continue;
                }
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(worstQuality, TypeInfo.Scalars.StatusCode);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);
            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            if ((StatusCode.IsBad(worstQuality) && badQualityCount > 1) || (StatusCode.IsUncertain(worstQuality) && uncertainQualityCount > 1))
            {
                value.StatusCode = value.StatusCode.SetAggregateBits(value.StatusCode.AggregateBits | AggregateBits.MultipleValues);
            }

            // return result.
            return value;
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StatusAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StatusAggregateCalculator.cs(71,43): error CS8116: It is not legal to use nullable type 'uint?' in a pattern; use the underlying type 'uint' instead.,D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StatusAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 6 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StdDevAggregateCalculator.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class StdDevAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public StdDevAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            uint? id = AggregateId.Identifier as uint?;

            if (id != null)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_StandardDeviationPopulation:
                    {
                        return ComputeStdDev(slice, false, 1);
                    }

                    case Objects.AggregateFunction_StandardDeviationSample:
                    {
                        return ComputeStdDev(slice, false, 2);
                    }

                    case Objects.AggregateFunction_VariancePopulation:
                    {
                        return ComputeStdDev(slice, true, 1);
                    }

                    case Objects.AggregateFunction_VarianceSample:
                    {
                        return ComputeStdDev(slice, true, 2);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculates the RegSlope, RegConst and RegStdDev aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeRegression(TimeSlice slice, int valueType)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, false, true);

            List<double> xData = new List<double>();
            List<double> yData = new List<double>();

            double duration = 0;
            bool nonGoodDataExists = false;

            for (int ii = 0; ii < regions.Count; ii++)
            {
                if (StatusCode.IsGood(regions[ii].StatusCode))
                {
                    xData.Add(regions[ii].StartValue);
                    yData.Add(duration);
                }
                else
                {
                    nonGoodDataExists = true;
                }

                // normalize to seconds.
                duration += regions[ii].Duration/1000.0;
            }

            // check if no good data.
            if (xData.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // compute the regression parameters.
            double regSlope = 0;
            double regConst = 0;
            double regStdDev = 0;

            if (xData.Count > 1)
            {
                double xAvg = 0;
                double yAvg = 0;
                double xxAgv = 0;
                double xyAvg = 0;

                for (int ii = 0; ii < xData.Count; ii++)
                {
                    xAvg += xData[ii];
                    yAvg += yData[ii];
                    xxAgv += xData[ii] * xData[ii];
                    xyAvg += xData[ii] * yData[ii];
                }

                xAvg /= xData.Count;
                yAvg /= xData.Count;
                xxAgv /= xData.Count;
                xyAvg /= xData.Count;

                regSlope = (xyAvg - xAvg * yAvg) / (xxAgv - xAvg * xAvg);
                regConst = yAvg - regSlope * xAvg;
                
                List<double> errors = new List<double>();

                double eAvg = 0;

                for (int ii = 0; ii < xData.Count; ii++)
                {
                    double error = yData[ii] - regConst - regSlope * xData[ii];
                    errors.Add(error);
                    eAvg += error;
                }

                eAvg /= errors.Count;

                double variance = 0;

                for (int ii = 0; ii < errors.Count; ii++)
                {
                    double error = errors[ii] - eAvg;
                    variance += error * error;
                }

                variance /= errors.Count;
                regStdDev = Math.Sqrt(variance);
            }

            // select the result.
            double result = 0;

            switch (valueType)
            {
                case 1: { result = regSlope;  break; }
                case 2: { result = regConst;  break; }
                case 3: { result = regStdDev; break; }
            }
            
            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(result, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);

            if (nonGoodDataExists)
            {
                value.StatusCode = StatusCodes.UncertainDataSubNormal;
            }

            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the StdDev, Variance, StdDev2 and Variance2 aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeStdDev(TimeSlice slice, bool includeBounds, int valueType)
        {
            // get the values in the slice.
            List<DataValue> values = null;

            if (includeBounds)
            {
                values = GetValuesWithSimpleBounds(slice);
            }
            else
            {
                values = GetValues(slice);
            }

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, false, true);

            List<double> xData = new List<double>();
            double average = 0;
            bool nonGoodDataExists = false;

            for (int ii = 0; ii < regions.Count; ii++)
            {
                if (StatusCode.IsGood(regions[ii].StatusCode))
                {
                    xData.Add(regions[ii].StartValue);
                    average += regions[ii].StartValue;
                }
                else
                {
                    nonGoodDataExists = true;
                }
            }

            // check if no good data.
            if (xData.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            average /= xData.Count;

            // calculate variance.
            double variance = 0;

            for (int ii = 0; ii < xData.Count; ii++)
            {
                double error = xData[ii] - average;
                variance += error*error;
            }

            // use the sample variance if bounds are included.
            if (includeBounds)
            {
                variance /= (xData.Count + 1);
            }
            
           // use the population variance if bounds are not included.
            else
            {
                variance /= xData.Count;
            }

            // select the result.
            double result = 0;

            switch (valueType)
            {
                case 1: { result = Math.Sqrt(variance); break; }
                case 2: { result = variance; break; }
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(result, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);

            if (nonGoodDataExists)
            {
                value.StatusCode = StatusCodes.UncertainDataSubNormal;
            }

            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // return result.
            return value;
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua.Server
{
    /// <summary>
    /// Calculates the value of an aggregate. 
    /// </summary>
    public class StdDevAggregateCalculator : AggregateCalculator
    {
        #region Constructors
        /// <summary>
        /// Initializes the aggregate calculator.
        /// </summary>
        /// <param name="aggregateId">The aggregate function to apply.</param>
        /// <param name="startTime">The start time.</param>
        /// <param name="endTime">The end time.</param>
        /// <param name="processingInterval">The processing interval.</param>
        /// <param name="stepped">Whether to use stepped interpolation.</param>
        /// <param name="configuration">The aggregate configuration.</param>
        public StdDevAggregateCalculator(
            NodeId aggregateId,
            DateTime startTime,
            DateTime endTime,
            double processingInterval,
            bool stepped,
            AggregateConfiguration configuration)
        : 
            base(aggregateId, startTime, endTime, processingInterval, stepped, configuration)
        {
            SetPartialBit = true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Computes the value for the timeslice.
        /// </summary>
        protected override DataValue ComputeValue(TimeSlice slice)
        {
            if (AggregateId.Identifier is uint? id)
            {
                switch (id.Value)
                {
                    case Objects.AggregateFunction_StandardDeviationPopulation:
                    {
                        return ComputeStdDev(slice, false, 1);
                    }

                    case Objects.AggregateFunction_StandardDeviationSample:
                    {
                        return ComputeStdDev(slice, false, 2);
                    }

                    case Objects.AggregateFunction_VariancePopulation:
                    {
                        return ComputeStdDev(slice, true, 1);
                    }

                    case Objects.AggregateFunction_VarianceSample:
                    {
                        return ComputeStdDev(slice, true, 2);
                    }
                }
            }

            return base.ComputeValue(slice);
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Calculates the RegSlope, RegConst and RegStdDev aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeRegression(TimeSlice slice, int valueType)
        {
            // get the values in the slice.
            List<DataValue> values = GetValuesWithSimpleBounds(slice);

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, false, true);

            List<double> xData = new List<double>();
            List<double> yData = new List<double>();

            double duration = 0;
            bool nonGoodDataExists = false;

            for (int ii = 0; ii < regions.Count; ii++)
            {
                if (StatusCode.IsGood(regions[ii].StatusCode))
                {
                    xData.Add(regions[ii].StartValue);
                    yData.Add(duration);
                }
                else
                {
                    nonGoodDataExists = true;
                }

                // normalize to seconds.
                duration += regions[ii].Duration/1000.0;
            }

            // check if no good data.
            if (xData.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // compute the regression parameters.
            double regSlope = 0;
            double regConst = 0;
            double regStdDev = 0;

            if (xData.Count > 1)
            {
                double xAvg = 0;
                double yAvg = 0;
                double xxAgv = 0;
                double xyAvg = 0;

                for (int ii = 0; ii < xData.Count; ii++)
                {
                    xAvg += xData[ii];
                    yAvg += yData[ii];
                    xxAgv += xData[ii] * xData[ii];
                    xyAvg += xData[ii] * yData[ii];
                }

                xAvg /= xData.Count;
                yAvg /= xData.Count;
                xxAgv /= xData.Count;
                xyAvg /= xData.Count;

                regSlope = (xyAvg - xAvg * yAvg) / (xxAgv - xAvg * xAvg);
                regConst = yAvg - regSlope * xAvg;
                
                List<double> errors = new List<double>();

                double eAvg = 0;

                for (int ii = 0; ii < xData.Count; ii++)
                {
                    double error = yData[ii] - regConst - regSlope * xData[ii];
                    errors.Add(error);
                    eAvg += error;
                }

                eAvg /= errors.Count;

                double variance = 0;

                for (int ii = 0; ii < errors.Count; ii++)
                {
                    double error = errors[ii] - eAvg;
                    variance += error * error;
                }

                variance /= errors.Count;
                regStdDev = Math.Sqrt(variance);
            }

            // select the result.
            double result = 0;

            switch (valueType)
            {
                case 1: { result = regSlope;  break; }
                case 2: { result = regConst;  break; }
                case 3: { result = regStdDev; break; }
            }
            
            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(result, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);

            if (nonGoodDataExists)
            {
                value.StatusCode = StatusCodes.UncertainDataSubNormal;
            }

            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // return result.
            return value;
        }

        /// <summary>
        /// Calculates the StdDev, Variance, StdDev2 and Variance2 aggregates for the timeslice.
        /// </summary>
        protected DataValue ComputeStdDev(TimeSlice slice, bool includeBounds, int valueType)
        {
            // get the values in the slice.
            List<DataValue> values = null;

            if (includeBounds)
            {
                values = GetValuesWithSimpleBounds(slice);
            }
            else
            {
                values = GetValues(slice);
            }

            // check for empty slice.
            if (values == null || values.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            // get the regions.
            List<SubRegion> regions = GetRegionsInValueSet(values, false, true);

            List<double> xData = new List<double>();
            double average = 0;
            bool nonGoodDataExists = false;

            for (int ii = 0; ii < regions.Count; ii++)
            {
                if (StatusCode.IsGood(regions[ii].StatusCode))
                {
                    xData.Add(regions[ii].StartValue);
                    average += regions[ii].StartValue;
                }
                else
                {
                    nonGoodDataExists = true;
                }
            }

            // check if no good data.
            if (xData.Count == 0)
            {
                return GetNoDataValue(slice);
            }

            average /= xData.Count;

            // calculate variance.
            double variance = 0;

            for (int ii = 0; ii < xData.Count; ii++)
            {
                double error = xData[ii] - average;
                variance += error*error;
            }

            // use the sample variance if bounds are included.
            if (includeBounds)
            {
                variance /= (xData.Count + 1);
            }
            
           // use the population variance if bounds are not included.
            else
            {
                variance /= xData.Count;
            }

            // select the result.
            double result = 0;

            switch (valueType)
            {
                case 1: { result = Math.Sqrt(variance); break; }
                case 2: { result = variance; break; }
            }

            // set the timestamp and status.
            DataValue value = new DataValue();
            value.WrappedValue = new Variant(result, TypeInfo.Scalars.Double);
            value.SourceTimestamp = GetTimestamp(slice);
            value.ServerTimestamp = GetTimestamp(slice);

            if (nonGoodDataExists)
            {
                value.StatusCode = StatusCodes.UncertainDataSubNormal;
            }

            value.StatusCode = value.StatusCode.SetAggregateBits(AggregateBits.Calculated);

            // return result.
            return value;
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StdDevAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StdDevAggregateCalculator.cs(71,43): error CS8116: It is not legal to use nullable type 'uint?' in a pattern; use the underlying type 'uint' instead.,D:\a\1\s\Libraries\Opc.Ua.Server\Aggregates\StdDevAggregateCalculator.cs(32,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 7 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Text;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;
using Opc.Ua;
using Opc.Ua.Server;

namespace Opc.Ua.Server
{
    /// <summary>
    /// A sample implementation of the INodeManager interface.
    /// </summary>
    /// <remarks>
    /// This node manager is a base class used in multiple samples. It implements the INodeManager
    /// interface and allows sub-classes to override only the methods that they need. This example
    /// is not part of the SDK because most real implementations of a INodeManager will need to
    /// modify the behavior of the base class.
    /// </remarks>
    public class CustomNodeManager2 : INodeManager2, INodeIdFactory, IDisposable
    {
        #region Constructors
        /// <summary>
        /// Initializes the node manager.
        /// </summary>
        protected CustomNodeManager2(
            IServerInternal server,
            params string[] namespaceUris)
        :
            this(server, (ApplicationConfiguration)null, namespaceUris)
        {
        }

        /// <summary>
        /// Initializes the node manager.
        /// </summary>
        protected CustomNodeManager2(
            IServerInternal server,
            ApplicationConfiguration configuration,
            params string[] namespaceUris)
        {
            // set defaults.
            m_maxQueueSize = 1000;

            if (configuration != null)
            {
                if (configuration.ServerConfiguration != null)
                {
                    m_maxQueueSize = (uint)configuration.ServerConfiguration.MaxNotificationQueueSize;
                }
            }

            // save a reference to the UA server instance that owns the node manager.
            m_server = server;

            // all operations require information about the system 
            m_systemContext = m_server.DefaultSystemContext.Copy();

            // the node id factory assigns new node ids to new nodes. 
            // the strategy used by a NodeManager depends on what kind of information it provides.
            m_systemContext.NodeIdFactory = this;

            // create the table of namespaces that are used by the NodeManager.
            m_namespaceUris = namespaceUris;

            // add the uris to the server's namespace table and cache the indexes.
            if (namespaceUris != null)
            {
                m_namespaceIndexes = new ushort[m_namespaceUris.Length];

                for (int ii = 0; ii < m_namespaceUris.Length; ii++)
                {
                    m_namespaceIndexes[ii] = m_server.NamespaceUris.GetIndexOrAppend(m_namespaceUris[ii]);
                }
            }

            // create the table of monitored items.
            // these are items created by clients when they subscribe to data or events.
            m_monitoredItems = new Dictionary<uint, IDataChangeMonitoredItem>();

            // create the table of monitored nodes.
            // these are created by the node manager whenever a client subscribe to an attribute of the node.
            m_monitoredNodes = new Dictionary<NodeId, MonitoredNode2>();
        }
        #endregion

        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                lock (m_lock)
                {
                    if (m_predefinedNodes != null)
                    {
                        foreach (NodeState node in m_predefinedNodes.Values)
                        {
                            Utils.SilentDispose(node);
                        }

                        m_predefinedNodes.Clear();
                    }
                }
            }
        }
        #endregion

        #region INodeIdFactory Members
        /// <summary>
        /// Creates the NodeId for the specified node.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="node">The node.</param>
        /// <returns>The new NodeId.</returns>
        public virtual NodeId New(ISystemContext context, NodeState node)
        {
            return node.NodeId;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Acquires the lock on the node manager.
        /// </summary>
        public object Lock
        {
            get { return m_lock; }
        }

        /// <summary>
        /// Gets the server that the node manager belongs to.
        /// </summary>
        public IServerInternal Server
        {
            get { return m_server; }
        }

        /// <summary>
        /// The default context to use.
        /// </summary>
        public ServerSystemContext SystemContext
        {
            get { return m_systemContext; }
        }

        /// <summary>
        /// Gets the default index for the node manager's namespace.
        /// </summary>
        public ushort NamespaceIndex
        {
            get { return m_namespaceIndexes[0]; }
        }

        /// <summary>
        /// Gets the namespace indexes owned by the node manager.
        /// </summary>
        /// <value>The namespace indexes.</value>
        public ushort[] NamespaceIndexes
        {
            get { return m_namespaceIndexes; }
        }

        /// <summary>
        /// Gets or sets the maximum size of a monitored item queue.
        /// </summary>
        /// <value>The maximum size of a monitored item queue.</value>
        public uint MaxQueueSize
        {
            get { return m_maxQueueSize; }
            set { m_maxQueueSize = value; }
        }

        /// <summary>
        /// The root for the alias assigned to the node manager.
        /// </summary>
        public string AliasRoot
        {
            get { return m_aliasRoot; }
            set { m_aliasRoot = value; }
        }
        #endregion

        #region Protected Members
        /// <summary>
        /// The predefined nodes managed by the node manager.
        /// </summary>
        protected NodeIdDictionary<NodeState> PredefinedNodes
        {
            get { return m_predefinedNodes; }
        }

        /// <summary>
        /// The root notifiers for the node manager.
        /// </summary>
        protected List<NodeState> RootNotifiers
        {
            get { return m_rootNotifiers; }
        }

        /// <summary>
        /// Gets the table of monitored items.
        /// </summary>
        protected Dictionary<uint, IDataChangeMonitoredItem> MonitoredItems
        {
            get { return m_monitoredItems; }
        }

        /// <summary>
        /// Gets the table of nodes being monitored.
        /// </summary>
        protected Dictionary<NodeId, MonitoredNode2> MonitoredNodes
        {
            get { return m_monitoredNodes; }
        }

        /// <summary>
        /// Sets the namespaces supported by the NodeManager.
        /// </summary>
        /// <param name="namespaceUris">The namespace uris.</param>
        protected void SetNamespaces(params string[] namespaceUris)
        {
            // create the table of namespaces that are used by the NodeManager.
            m_namespaceUris = namespaceUris;

            // add the uris to the server's namespace table and cache the indexes.
            m_namespaceIndexes = new ushort[m_namespaceUris.Length];

            for (int ii = 0; ii < m_namespaceUris.Length; ii++)
            {
                m_namespaceIndexes[ii] = m_server.NamespaceUris.GetIndexOrAppend(m_namespaceUris[ii]);
            }
        }

        /// <summary>
        /// Sets the namespace indexes supported by the NodeManager.
        /// </summary>
        protected void SetNamespaceIndexes(ushort[] namespaceIndexes)
        {
            m_namespaceIndexes = namespaceIndexes;
            m_namespaceUris = new string[namespaceIndexes.Length];

            for (int ii = 0; ii < namespaceIndexes.Length; ii++)
            {
                m_namespaceUris[ii] = m_server.NamespaceUris.GetString(namespaceIndexes[ii]);
            }
        }

        /// <summary>
        /// Returns true if the namespace for the node id is one of the namespaces managed by the node manager.
        /// </summary>
        /// <param name="nodeId">The node id to check.</param>
        /// <returns>True if the namespace is one of the nodes.</returns>
        protected virtual bool IsNodeIdInNamespace(NodeId nodeId)
        {
            // nulls are never a valid node.
            if (NodeId.IsNull(nodeId))
            {
                return false;
            }

            // quickly exclude nodes that not in the namespace.
            for (int ii = 0; ii < m_namespaceIndexes.Length; ii++)
            {
                if (nodeId.NamespaceIndex == m_namespaceIndexes[ii])
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Returns the node if the handle refers to a node managed by this manager.
        /// </summary>
        /// <param name="managerHandle">The handle to check.</param>
        /// <returns>Non-null if the handle belongs to the node manager.</returns>
        protected virtual NodeHandle IsHandleInNamespace(object managerHandle)
        {
            NodeHandle source = managerHandle as NodeHandle;

            if (source == null)
            {
                return null;
            }

            if (!IsNodeIdInNamespace(source.NodeId))
            {
                return null;
            }

            return source;
        }

        /// <summary>
        /// Returns the state object for the specified node if it exists.
        /// </summary>
        public NodeState Find(NodeId nodeId)
        {
            lock (Lock)
            {
                if (PredefinedNodes == null)
                {
                    return null;
                }

                NodeState node = null;

                if (!PredefinedNodes.TryGetValue(nodeId, out node))
                {
                    return null;
                }

                return node;
            }
        }

        /// <summary>
        /// Creates a new instance and assigns unique identifiers to all children.
        /// </summary>
        /// <param name="context">The operation context.</param>
        /// <param name="parentId">An optional parent identifier.</param>
        /// <param name="referenceTypeId">The reference type from the parent.</param>
        /// <param name="browseName">The browse name.</param>
        /// <param name="instance">The instance to create.</param>
        /// <returns>The new node id.</returns>
        public NodeId CreateNode(
            ServerSystemContext context,
            NodeId parentId,
            NodeId referenceTypeId,
            QualifiedName browseName,
            BaseInstanceState instance)
        {
            ServerSystemContext contextToUse = (ServerSystemContext)m_systemContext.Copy(context);

            lock (Lock)
            {
                if (m_predefinedNodes == null)
                {
                    m_predefinedNodes = new NodeIdDictionary<NodeState>();
                }

                instance.ReferenceTypeId = referenceTypeId;

                NodeState parent = null;

                if (parentId != null)
                {
                    if (!m_predefinedNodes.TryGetValue(parentId, out parent))
                    {
                        throw ServiceResultException.Create(
                            StatusCodes.BadNodeIdUnknown,
                            "Cannot find parent with id: {0}",
                            parentId);
                    }

                    parent.AddChild(instance);
                }

                instance.Create(contextToUse, null, browseName, null, true);
                AddPredefinedNode(contextToUse, instance);

                return instance.NodeId;
            }
        }

        /// <summary>
        /// Deletes a node and all of its children.
        /// </summary>
        public bool DeleteNode(
            ServerSystemContext context,
            NodeId nodeId)
        {
            ServerSystemContext contextToUse = m_systemContext.Copy(context);

            bool found = false;
            List<LocalReference> referencesToRemove = new List<LocalReference>();

            lock (Lock)
            {
                if (m_predefinedNodes == null)
                {
                    return false;
                }

                NodeState node = null;

                if (PredefinedNodes.TryGetValue(nodeId, out node))
                {
                    RemovePredefinedNode(contextToUse, node, referencesToRemove);
                    found = true;
                }

                RemoveRootNotifier(node);
            }

            // must release the lock before removing cross references to other node managers.
            if (referencesToRemove.Count > 0)
            {
                Server.NodeManager.RemoveReferences(referencesToRemove);
            }

            return found;
        }

        /// <summary>
        /// Searches the node id in all node managers 
        /// </summary>
        /// <param name="nodeId"></param>
        /// <returns></returns>
        public NodeState FindNodeInAddressSpace(NodeId nodeId)
        {
            if (nodeId == null)
            {
                return null;
            }
            // search node id in all node managers
            foreach (INodeManager nodeManager in Server.NodeManager.NodeManagers)
            {
                NodeHandle handle = nodeManager.GetManagerHandle(nodeId) as NodeHandle;
                if (handle == null)
                {
                    continue;
                }
                return handle.Node;
            }
            return null;
        }
        #endregion

        #region INodeManager Members
        /// <summary>
        /// Returns the namespaces used by the node manager.
        /// </summary>
        /// <remarks>
        /// All NodeIds exposed by the node manager must be qualified by a namespace URI. This property
        /// returns the URIs used by the node manager. In this example all NodeIds use a single URI.
        /// </remarks>
        public virtual IEnumerable<string> NamespaceUris
        {
            get
            {
                return m_namespaceUris;
            }

            protected set
            {
                if (value == null) throw new ArgumentNullException(nameof(value));
                List<string> namespaceUris = new List<string>(value);
                SetNamespaces(namespaceUris.ToArray());
            }
        }

        /// <summary>
        /// Does any initialization required before the address space can be used.
        /// </summary>
        /// <remarks>
        /// The externalReferences is an out parameter that allows the node manager to link to nodes
        /// in other node managers. For example, the 'Objects' node is managed by the CoreNodeManager and
        /// should have a reference to the root folder node(s) exposed by this node manager.  
        /// </remarks>
        public virtual void CreateAddressSpace(IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            LoadPredefinedNodes(m_systemContext, externalReferences);
        }

        #region CreateAddressSpace Support Functions
        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        public virtual void LoadPredefinedNodes(
            ISystemContext context,
            Assembly assembly,
            string resourcePath,
            IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            if (m_predefinedNodes == null)
            {
                m_predefinedNodes = new NodeIdDictionary<NodeState>();
            }

            // load the predefined nodes from an XML document.
            NodeStateCollection predefinedNodes = new NodeStateCollection();
            predefinedNodes.LoadFromResource(context, resourcePath, assembly, true);

            // add the predefined nodes to the node manager.
            for (int ii = 0; ii < predefinedNodes.Count; ii++)
            {
                AddPredefinedNode(context, predefinedNodes[ii]);
            }

            // ensure the reverse references exist.
            AddReverseReferences(externalReferences);
        }

        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        protected virtual NodeStateCollection LoadPredefinedNodes(ISystemContext context)
        {
            return new NodeStateCollection();
        }

        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        protected virtual void LoadPredefinedNodes(
            ISystemContext context,
            IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            // load the predefined nodes from an XML document.
            NodeStateCollection predefinedNodes = LoadPredefinedNodes(context);

            // add the predefined nodes to the node manager.
            for (int ii = 0; ii < predefinedNodes.Count; ii++)
            {
                AddPredefinedNode(context, predefinedNodes[ii]);
            }

            // ensure the reverse references exist.
            AddReverseReferences(externalReferences);
        }

        /// <summary>
        /// Replaces the generic node with a node specific to the model.
        /// </summary>
        protected virtual NodeState AddBehaviourToPredefinedNode(ISystemContext context, NodeState predefinedNode)
        {
            BaseObjectState passiveNode = predefinedNode as BaseObjectState;

            if (passiveNode == null)
            {
                return predefinedNode;
            }

            return predefinedNode;
        }

        /// <summary>
        /// Recursively indexes the node and its children.
        /// </summary>
        protected virtual void AddPredefinedNode(ISystemContext context, NodeState node)
        {
            if (m_predefinedNodes == null)
            {
                m_predefinedNodes = new NodeIdDictionary<NodeState>();
            }

            NodeState activeNode = AddBehaviourToPredefinedNode(context, node);
            m_predefinedNodes[activeNode.NodeId] = activeNode;

            BaseTypeState type = activeNode as BaseTypeState;

            if (type != null)
            {
                AddTypesToTypeTree(type);
            }

            // update the root notifiers.
            if (m_rootNotifiers != null)
            {
                for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
                {
                    if (m_rootNotifiers[ii].NodeId == activeNode.NodeId)
                    {
                        m_rootNotifiers[ii] = activeNode;

                        // need to prevent recursion with the server object.
                        if (activeNode.NodeId != ObjectIds.Server)
                        {
                            activeNode.OnReportEvent = OnReportEvent;

                            if (!activeNode.ReferenceExists(ReferenceTypeIds.HasNotifier, true, ObjectIds.Server))
                            {
                                activeNode.AddReference(ReferenceTypeIds.HasNotifier, true, ObjectIds.Server);
                            }
                        }

                        break;
                    }
                }
            }

            List<BaseInstanceState> children = new List<BaseInstanceState>();
            activeNode.GetChildren(context, children);

            for (int ii = 0; ii < children.Count; ii++)
            {
                AddPredefinedNode(context, children[ii]);
            }
        }

        /// <summary>
        /// Recursively indexes the node and its children.
        /// </summary>
        protected virtual void RemovePredefinedNode(
            ISystemContext context,
            NodeState node,
            List<LocalReference> referencesToRemove)
        {
            if (m_predefinedNodes == null)
            {
                return;
            }

            m_predefinedNodes.Remove(node.NodeId);
            node.UpdateChangeMasks(NodeStateChangeMasks.Deleted);
            node.ClearChangeMasks(context, false);
            OnNodeRemoved(node);

            // remove from the parent.
            BaseInstanceState instance = node as BaseInstanceState;

            if (instance?.Parent != null)
            {
                instance.Parent.RemoveChild(instance);
            }

            // remove children.
            List<BaseInstanceState> children = new List<BaseInstanceState>();
            node.GetChildren(context, children);

            for (int ii = 0; ii < children.Count; ii++)
            {
                node.RemoveChild(children[ii]);
            }

            for (int ii = 0; ii < children.Count; ii++)
            {
                RemovePredefinedNode(context, children[ii], referencesToRemove);
            }

            // remove from type table.
            BaseTypeState type = node as BaseTypeState;

            if (type != null)
            {
                m_server.TypeTree.Remove(type.NodeId);
            }

            // remove inverse references.
            List<IReference> references = new List<IReference>();
            node.GetReferences(context, references);

            for (int ii = 0; ii < references.Count; ii++)
            {
                IReference reference = references[ii];

                if (reference.TargetId.IsAbsolute)
                {
                    continue;
                }

                LocalReference referenceToRemove = new LocalReference(
                    (NodeId)reference.TargetId,
                    reference.ReferenceTypeId,
                    reference.IsInverse,
                    node.NodeId);

                referencesToRemove.Add(referenceToRemove);
            }
        }

        /// <summary>
        /// Called after a node has been deleted.
        /// </summary>
        protected virtual void OnNodeRemoved(NodeState node)
        {
            // overridden by the sub-class.            
        }

        /// <summary>
        /// Ensures that all reverse references exist.
        /// </summary>
        /// <param name="externalReferences">A list of references to add to external targets.</param>
        protected virtual void AddReverseReferences(IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            if (m_predefinedNodes == null)
            {
                return;
            }

            foreach (NodeState source in m_predefinedNodes.Values)
            {
                // assign a default value to any variable value.
                BaseVariableState variable = source as BaseVariableState;

                if (variable != null && variable.Value == null)
                {
                    variable.Value = TypeInfo.GetDefaultValue(variable.DataType, variable.ValueRank, Server.TypeTree);
                }

                IList<IReference> references = new List<IReference>();
                source.GetReferences(SystemContext, references);

                for (int ii = 0; ii < references.Count; ii++)
                {
                    IReference reference = references[ii];

                    // nothing to do with external nodes.
                    if (reference.TargetId == null || reference.TargetId.IsAbsolute)
                    {
                        continue;
                    }

                    // no need to add HasSubtype references since these are handled via the type table.
                    if (reference.ReferenceTypeId == ReferenceTypeIds.HasSubtype)
                    {
                        continue;
                    }

                    NodeId targetId = (NodeId)reference.TargetId;

                    // check for data type encoding references.
                    if (reference.IsInverse && reference.ReferenceTypeId == ReferenceTypeIds.HasEncoding)
                    {
                        Server.TypeTree.AddEncoding(targetId, source.NodeId);
                    }

                    // add inverse reference to internal targets.
                    NodeState target = null;

                    if (m_predefinedNodes.TryGetValue(targetId, out target))
                    {
                        if (!target.ReferenceExists(reference.ReferenceTypeId, !reference.IsInverse, source.NodeId))
                        {
                            target.AddReference(reference.ReferenceTypeId, !reference.IsInverse, source.NodeId);
                        }

                        continue;
                    }

                    // check for inverse references to external notifiers.
                    if (reference.IsInverse && reference.ReferenceTypeId == ReferenceTypeIds.HasNotifier)
                    {
                        AddRootNotifier(source);
                    }

                    // nothing more to do for references to nodes managed by this manager.
                    if (IsNodeIdInNamespace(targetId))
                    {
                        continue;
                    }

                    // add external reference.
                    AddExternalReference(
                        targetId,
                        reference.ReferenceTypeId,
                        !reference.IsInverse,
                        source.NodeId,
                        externalReferences);
                }
            }
        }

        /// <summary>
        /// Adds an external reference to the dictionary.
        /// </summary>
        protected void AddExternalReference(
            NodeId sourceId,
            NodeId referenceTypeId,
            bool isInverse,
            NodeId targetId,
            IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            // get list of references to external nodes.
            IList<IReference> referencesToAdd = null;

            if (!externalReferences.TryGetValue(sourceId, out referencesToAdd))
            {
                externalReferences[sourceId] = referencesToAdd = new List<IReference>();
            }

            // add reserve reference from external node.
            ReferenceNode referenceToAdd = new ReferenceNode();

            referenceToAdd.ReferenceTypeId = referenceTypeId;
            referenceToAdd.IsInverse = isInverse;
            referenceToAdd.TargetId = targetId;

            referencesToAdd.Add(referenceToAdd);
        }

        /// <summary>
        /// Recursively adds the types to the type tree.
        /// </summary>
        protected void AddTypesToTypeTree(BaseTypeState type)
        {
            if (!NodeId.IsNull(type.SuperTypeId))
            {
                if (!Server.TypeTree.IsKnown(type.SuperTypeId))
                {
                    AddTypesToTypeTree(type.SuperTypeId);
                }
            }

            if (type.NodeClass != NodeClass.ReferenceType)
            {
                Server.TypeTree.AddSubtype(type.NodeId, type.SuperTypeId);
            }
            else
            {
                Server.TypeTree.AddReferenceSubtype(type.NodeId, type.SuperTypeId, type.BrowseName);
            }
        }

        /// <summary>
        /// Recursively adds the types to the type tree.
        /// </summary>
        protected void AddTypesToTypeTree(NodeId typeId)
        {
            NodeState node = null;

            if (!PredefinedNodes.TryGetValue(typeId, out node))
            {
                return;
            }

            BaseTypeState type = node as BaseTypeState;

            if (type == null)
            {
                return;
            }

            AddTypesToTypeTree(type);
        }

        /// <summary>
        /// Finds the specified and checks if it is of the expected type. 
        /// </summary>
        /// <returns>Returns null if not found or not of the correct type.</returns>
        public NodeState FindPredefinedNode(NodeId nodeId, Type expectedType)
        {
            if (nodeId == null)
            {
                return null;
            }

            NodeState node = null;

            if (!PredefinedNodes.TryGetValue(nodeId, out node))
            {
                return null;
            }

            if (expectedType != null)
            {
                if (!expectedType.IsInstanceOfType(node))
                {
                    return null;
                }
            }

            return node;
        }
        #endregion

        /// <summary>
        /// Frees any resources allocated for the address space.
        /// </summary>
        public virtual void DeleteAddressSpace()
        {
            lock (m_lock)
            {
                if (m_predefinedNodes != null)
                {
                    foreach (NodeState node in m_predefinedNodes.Values)
                    {
                        Utils.SilentDispose(node);
                    }

                    m_predefinedNodes.Clear();
                }
            }
        }

        /// <summary>
        /// Returns a unique handle for the node.
        /// </summary>
        /// <remarks>
        /// This must efficiently determine whether the node belongs to the node manager. If it does belong to 
        /// NodeManager it should return a handle that does not require the NodeId to be validated again when
        /// the handle is passed into other methods such as 'Read' or 'Write'.
        /// </remarks>
        public virtual object GetManagerHandle(NodeId nodeId)
        {
            lock (Lock)
            {
                return GetManagerHandle(m_systemContext, nodeId, null);
            }
        }

        /// <summary>
        /// Returns a unique handle for the node.
        /// </summary>
        protected virtual NodeHandle GetManagerHandle(ServerSystemContext context, NodeId nodeId, IDictionary<NodeId, NodeState> cache)
        {
            if (!IsNodeIdInNamespace(nodeId))
            {
                return null;
            }

            if (m_predefinedNodes != null)
            {
                NodeState node = null;

                if (m_predefinedNodes.TryGetValue(nodeId, out node))
                {
                    NodeHandle handle = new NodeHandle();

                    handle.NodeId = nodeId;
                    handle.Node = node;
                    handle.Validated = true;

                    return handle;
                }
            }

            return null;
        }

        /// <summary>
        /// This method is used to add bi-directional references to nodes from other node managers.
        /// </summary>
        /// <remarks>
        /// The additional references are optional, however, the NodeManager should support them.
        /// </remarks>
        public virtual void AddReferences(IDictionary<NodeId, IList<IReference>> references)
        {
            lock (Lock)
            {
                foreach (KeyValuePair<NodeId, IList<IReference>> current in references)
                {
                    // get the handle.
                    NodeHandle source = GetManagerHandle(m_systemContext, current.Key, null);

                    // only support external references to nodes that are stored in memory.
                    if (source == null || !source.Validated || source.Node == null)
                    {
                        continue;
                    }

                    // add reference to external target.
                    foreach (IReference reference in current.Value)
                    {
                        if (!source.Node.ReferenceExists(reference.ReferenceTypeId, reference.IsInverse, reference.TargetId))
                        {
                            source.Node.AddReference(reference.ReferenceTypeId, reference.IsInverse, reference.TargetId);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// This method is used to delete bi-directional references to nodes from other node managers.
        /// </summary>
        public virtual ServiceResult DeleteReference(
            object         sourceHandle, 
            NodeId         referenceTypeId, 
            bool           isInverse, 
            ExpandedNodeId targetId, 
            bool           deleteBiDirectional)
        {
            lock (Lock)
            {
                // get the handle.
                NodeHandle source = IsHandleInNamespace(sourceHandle);

                if (source == null)
                {
                    return StatusCodes.BadNodeIdUnknown;
                }

                // only support external references to nodes that are stored in memory.
                if (!source.Validated || source.Node == null)
                {
                    return StatusCodes.BadNotSupported;
                }

                // only support references to Source Areas.
                source.Node.RemoveReference(referenceTypeId, isInverse, targetId);

                if (deleteBiDirectional)
                {
                    // check if the target is also managed by this node manager.
                    if (!targetId.IsAbsolute)
                    {
                        NodeHandle target = GetManagerHandle(m_systemContext, (NodeId)targetId, null);

                        if (target != null && target.Validated && target.Node != null)
                        {
                            target.Node.RemoveReference(referenceTypeId, !isInverse, source.NodeId);
                        }
                    }
                }

                return ServiceResult.Good;
            }
        }

        /// <summary>
        /// Returns the basic metadata for the node. Returns null if the node does not exist.
        /// </summary>
        /// <remarks>
        /// This method validates any placeholder handle.
        /// </remarks>
        public virtual NodeMetadata GetNodeMetadata(
            OperationContext context, 
            object           targetHandle, 
            BrowseResultMask resultMask)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                // check for valid handle.
                NodeHandle handle = IsHandleInNamespace(targetHandle);

                if (handle == null)
                {
                    return null;
                }

                // validate node.
                NodeState target = ValidateNode(systemContext, handle, null);

                if (target == null)
                {
                    return null;
                }

                // read the attributes.
                List<object> values = target.ReadAttributes(
                    systemContext,
                    Attributes.WriteMask,
                    Attributes.UserWriteMask,
                    Attributes.DataType,
                    Attributes.ValueRank,
                    Attributes.ArrayDimensions,
                    Attributes.AccessLevel,
                    Attributes.UserAccessLevel,
                    Attributes.EventNotifier,
                    Attributes.Executable,
                    Attributes.UserExecutable,
                    Attributes.AccessRestrictions,
                    Attributes.RolePermissions,
                    Attributes.UserRolePermissions);

                // construct the meta-data object.
                NodeMetadata metadata = new NodeMetadata(target, target.NodeId);

                metadata.NodeClass = target.NodeClass;
                metadata.BrowseName = target.BrowseName;
                metadata.DisplayName = target.DisplayName;

                if (values[0] != null && values[1] != null)
                {
                    metadata.WriteMask = (AttributeWriteMask)(((uint)values[0]) & ((uint)values[1]));
                }

                metadata.DataType = (NodeId)values[2];

                if (values[3] != null)
                {
                    metadata.ValueRank = (int)values[3];
                }

                metadata.ArrayDimensions = (IList<uint>)values[4];

                if (values[5] != null && values[6] != null)
                {
                    metadata.AccessLevel = (byte)(((byte)values[5]) & ((byte)values[6]));
                }

                if (values[7] != null)
                {
                    metadata.EventNotifier = (byte)values[7];
                }

                if (values[8] != null && values[9] != null)
                {
                    metadata.Executable = (((bool)values[8]) && ((bool)values[9]));
                }

                if (values[10] != null)
                {
                    metadata.AccessRestrictions = (AccessRestrictionType)Enum.ToObject(typeof(AccessRestrictionType), values[10]);
                }

                if (values[11] != null)
                {
                    metadata.RolePermissions = new RolePermissionTypeCollection(ExtensionObject.ToList<RolePermissionType>(values[11]));
                }

                if (values[12] != null)
                {
                    metadata.UserRolePermissions = new RolePermissionTypeCollection(ExtensionObject.ToList<RolePermissionType>(values[12]));
                }

                // check if NamespaceMetadata is defined for NamespaceUri
                string namespaceUri = Server.NamespaceUris.GetString(target.NodeId.NamespaceIndex);
                NamespaceMetadataState namespaceMetadataState = Server.NodeManager.ConfigurationNodeManager.GetNamespaceMetadataState(namespaceUri);

                if (namespaceMetadataState != null)
                {
                    List<object> namespaceMetadataValues;

                    if (namespaceMetadataState.DefaultAccessRestrictions != null)
                    {
                        // get DefaultAccessRestrictions for Namespace
                        namespaceMetadataValues = namespaceMetadataState.DefaultAccessRestrictions.ReadAttributes(systemContext, Attributes.Value);

                        if (namespaceMetadataValues[0] != null)
                        {
                            metadata.DefaultAccessRestrictions = (AccessRestrictionType)Enum.ToObject(typeof(AccessRestrictionType), namespaceMetadataValues[0]);
                        }
                    }

                    if (namespaceMetadataState.DefaultRolePermissions != null)
                    {
                        // get DefaultRolePermissions for Namespace
                        namespaceMetadataValues = namespaceMetadataState.DefaultRolePermissions.ReadAttributes(systemContext, Attributes.Value);

                        if (namespaceMetadataValues[0] != null)
                        {
                            metadata.DefaultRolePermissions = new RolePermissionTypeCollection(ExtensionObject.ToList<RolePermissionType>(namespaceMetadataValues[0]));
                        }
                    }

                    if (namespaceMetadataState.DefaultUserRolePermissions != null)
                    {
                        // get DefaultUserRolePermissions for Namespace
                        namespaceMetadataValues = namespaceMetadataState.DefaultUserRolePermissions.ReadAttributes(systemContext, Attributes.Value);

                        if (namespaceMetadataValues[0] != null)
                        {
                            metadata.DefaultUserRolePermissions = new RolePermissionTypeCollection(ExtensionObject.ToList<RolePermissionType>(namespaceMetadataValues[0]));
                        }
                    }
                }

                // get instance references.
                BaseInstanceState instance = target as BaseInstanceState;

                if (instance != null)
                {
                    metadata.TypeDefinition = instance.TypeDefinitionId;
                    metadata.ModellingRule = instance.ModellingRuleId;
                }

                // fill in the common attributes.
                return metadata;
            }
        }

        /// <summary>
        /// Browses the references from a node managed by the node manager.
        /// </summary>
        /// <remarks>
        /// The continuation point is created for every browse operation and contains the browse parameters.
        /// The node manager can store its state information in the Data and Index properties.
        /// </remarks>
        public virtual void Browse(
            OperationContext            context, 
            ref ContinuationPoint       continuationPoint, 
            IList<ReferenceDescription> references)
        {
            if (continuationPoint == null) throw new ArgumentNullException(nameof(continuationPoint));
            if (references == null) throw new ArgumentNullException(nameof(references));

            ServerSystemContext systemContext = m_systemContext.Copy(context);

            // check for valid view.
            ValidateViewDescription(systemContext, continuationPoint.View);

            INodeBrowser browser = null;

            lock (Lock)
            {
                // check for valid handle.
                NodeHandle handle = IsHandleInNamespace(continuationPoint.NodeToBrowse);

                if (handle == null)
                {
                    throw new ServiceResultException(StatusCodes.BadNodeIdUnknown);
                }

                // validate node.
                NodeState source = ValidateNode(systemContext, handle, null);

                if (source == null)
                {
                    throw new ServiceResultException(StatusCodes.BadNodeIdUnknown);
                }

                // check if node is in the view.
                if (!IsNodeInView(systemContext, continuationPoint, source))
                {
                    throw new ServiceResultException(StatusCodes.BadNodeNotInView);
                }

                // check for previous continuation point.
                browser = continuationPoint.Data as INodeBrowser;

                // fetch list of references.
                if (browser == null)
                {
                    // create a new browser.
                    continuationPoint.Data = browser = source.CreateBrowser(
                        systemContext,
                        continuationPoint.View,
                        continuationPoint.ReferenceTypeId,
                        continuationPoint.IncludeSubtypes,
                        continuationPoint.BrowseDirection,
                        null,
                        null,
                        false);
                }
            }
            // prevent multiple access the browser object.
            lock (browser)
            {
                // apply filters to references.
                Dictionary<NodeId, NodeState> cache = new Dictionary<NodeId, NodeState>();

                for (IReference reference = browser.Next(); reference != null; reference = browser.Next())
                {
                    // validate Browse permission
                    ServiceResult serviceResult = ValidateRolePermissions(context,
                        ExpandedNodeId.ToNodeId(reference.TargetId, Server.NamespaceUris),
                        PermissionType.Browse);
                    if (ServiceResult.IsBad(serviceResult))
                    {
                        // ignore reference
                        continue;
                    }
                    // create the type definition reference.        
                    ReferenceDescription description = GetReferenceDescription(systemContext, cache, reference, continuationPoint);

                    if (description == null)
                    {
                        continue;
                    }

                    // check if limit reached.
                    if (continuationPoint.MaxResultsToReturn != 0 && references.Count >= continuationPoint.MaxResultsToReturn)
                    {
                        browser.Push(reference);
                        return;
                    }

                    references.Add(description);
                }

                // release the continuation point if all done.
                continuationPoint.Dispose();
                continuationPoint = null;
            }
        }

        #region Browse Support Functions
        /// <summary>
        /// Validates the view description passed to a browse request (throws on error).
        /// </summary>
        protected virtual void ValidateViewDescription(ServerSystemContext context, ViewDescription view)
        {
            if (ViewDescription.IsDefault(view))
            {
                return;
            }

            ViewState node = (ViewState)FindPredefinedNode(view.ViewId, typeof(ViewState));

            if (node == null)
            {
                throw new ServiceResultException(StatusCodes.BadViewIdUnknown);
            }

            if (view.Timestamp != DateTime.MinValue)
            {
                throw new ServiceResultException(StatusCodes.BadViewTimestampInvalid);
            }

            if (view.ViewVersion != 0)
            {
                throw new ServiceResultException(StatusCodes.BadViewVersionInvalid);
            }
        }

        /// <summary>
        /// Checks if the node is in the view.
        /// </summary>
        protected virtual bool IsNodeInView(ServerSystemContext context, ContinuationPoint continuationPoint, NodeState node)
        {
            if (continuationPoint == null || ViewDescription.IsDefault(continuationPoint.View))
            {
                return true;
            }

            return IsNodeInView(context, continuationPoint.View.ViewId, node);
        }

        /// <summary>
        /// Checks if the node is in the view.
        /// </summary>
        protected virtual bool IsNodeInView(ServerSystemContext context, NodeId viewId, NodeState node)
        {
            ViewState view = (ViewState)FindPredefinedNode(viewId, typeof(ViewState));

            if (view != null)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if the reference is in the view.
        /// </summary>
        protected virtual bool IsReferenceInView(ServerSystemContext context, ContinuationPoint continuationPoint, IReference reference)
        {
            return true;
        }

        /// <summary>
        /// Returns the references for the node that meets the criteria specified.
        /// </summary>
        protected virtual ReferenceDescription GetReferenceDescription(
            ServerSystemContext context,
            Dictionary<NodeId, NodeState> cache,
            IReference reference,
            ContinuationPoint continuationPoint)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            // create the type definition reference.        
            ReferenceDescription description = new ReferenceDescription();

            description.NodeId = reference.TargetId;
            description.SetReferenceType(continuationPoint.ResultMask, reference.ReferenceTypeId, !reference.IsInverse);

            // check if reference is in the view.
            if (!IsReferenceInView(context, continuationPoint, reference))
            {
                return null;
            }

            // do not cache target parameters for remote nodes.
            if (reference.TargetId.IsAbsolute)
            {
                // only return remote references if no node class filter is specified.
                if (continuationPoint.NodeClassMask != 0)
                {
                    return null;
                }

                return description;
            }

            NodeState target = null;

            // check for local reference.
            NodeStateReference referenceInfo = reference as NodeStateReference;

            if (referenceInfo != null)
            {
                target = referenceInfo.Target;
            }

            // check for internal reference.
            if (target == null)
            {
                NodeHandle handle = GetManagerHandle(context, (NodeId)reference.TargetId, null) as NodeHandle;

                if (handle != null)
                {
                    target = ValidateNode(context, handle, null);
                }
            }

            // the target may be a reference to a node in another node manager. In these cases
            // the target attributes must be fetched by the caller. The Unfiltered flag tells the
            // caller to do that.
            if (target == null)
            {
                description.Unfiltered = true;
                return description;
            }

            // apply node class filter.
            if (continuationPoint.NodeClassMask != 0 && ((continuationPoint.NodeClassMask & (uint)target.NodeClass) == 0))
            {
                return null;
            }

            // check if target is in the view.
            if (!IsNodeInView(context, continuationPoint, target))
            {
                return null;
            }

            // look up the type definition.
            NodeId typeDefinition = null;

            BaseInstanceState instance = target as BaseInstanceState;

            if (instance != null)
            {
                typeDefinition = instance.TypeDefinitionId;
            }

            // set target attributes.
            description.SetTargetAttributes(
                continuationPoint.ResultMask,
                target.NodeClass,
                target.BrowseName,
                target.DisplayName,
                typeDefinition);

            return description;
        }
        #endregion

        /// <summary>
        /// Returns the target of the specified browse path fragment(s).
        /// </summary>
        /// <remarks>
        /// If reference exists but the node manager does not know the browse name it must 
        /// return the NodeId as an unresolvedTargetIds. The caller will try to check the
        /// browse name. 
        /// </remarks>
        public virtual void TranslateBrowsePath(
            OperationContext      context, 
            object                sourceHandle, 
            RelativePathElement   relativePath, 
            IList<ExpandedNodeId> targetIds, 
            IList<NodeId>         unresolvedTargetIds)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();

            lock (Lock)
            {
                // check for valid handle.
                NodeHandle handle = IsHandleInNamespace(sourceHandle);

                if (handle == null)
                {
                    return;
                }

                // validate node.
                NodeState source = ValidateNode(systemContext, handle, operationCache);

                if (source == null)
                {
                    return;
                }

                // get list of references that relative path.
                INodeBrowser browser = source.CreateBrowser(
                    systemContext,
                    null,
                    relativePath.ReferenceTypeId,
                    relativePath.IncludeSubtypes,
                    (relativePath.IsInverse) ? BrowseDirection.Inverse : BrowseDirection.Forward,
                    relativePath.TargetName,
                    null,
                    false);

                // check the browse names.
                try
                {
                    for (IReference reference = browser.Next(); reference != null; reference = browser.Next())
                    {
                        // ignore unknown external references.
                        if (reference.TargetId.IsAbsolute)
                        {
                            continue;
                        }

                        NodeState target = null;

                        // check for local reference.
                        NodeStateReference referenceInfo = reference as NodeStateReference;

                        if (referenceInfo != null)
                        {
                            target = referenceInfo.Target;
                        }

                        if (target == null)
                        {
                            NodeId targetId = (NodeId)reference.TargetId;

                            // the target may be a reference to a node in another node manager.
                            if (!IsNodeIdInNamespace(targetId))
                            {
                                unresolvedTargetIds.Add((NodeId)reference.TargetId);
                                continue;
                            }

                            // look up the target manually.
                            NodeHandle targetHandle = GetManagerHandle(systemContext, targetId, operationCache);

                            if (targetHandle == null)
                            {
                                continue;
                            }

                            // validate target.
                            target = ValidateNode(systemContext, targetHandle, operationCache);

                            if (target == null)
                            {
                                continue;
                            }
                        }

                        // check browse name.
                        if (target.BrowseName == relativePath.TargetName)
                        {
                            if (!targetIds.Contains(reference.TargetId))
                            {
                                targetIds.Add(reference.TargetId);
                            }
                        }
                    }
                }
                finally
                {
                    browser.Dispose();
                }
            }
        }

        /// <summary>
        /// Reads the value for the specified attribute.
        /// </summary>
        public virtual void Read(
            OperationContext     context, 
            double               maxAge, 
            IList<ReadValueId>   nodesToRead, 
            IList<DataValue>     values, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<NodeHandle> nodesToValidate = new List<NodeHandle>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToRead.Count; ii++)
                {
                    ReadValueId nodeToRead = nodesToRead[ii];

                    // skip items that have already been processed.
                    if (nodeToRead.Processed)
                    {
                        continue;
                    }

                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, nodeToRead.NodeId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToRead.Processed = true;

                    // create an initial value.
                    DataValue value = values[ii] = new DataValue();

                    value.Value = null;
                    value.ServerTimestamp = DateTime.UtcNow;
                    value.SourceTimestamp = DateTime.MinValue;
                    value.StatusCode = StatusCodes.Good;

                    // check if the node is a area in memory.
                    if (handle.Node == null)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;

                        // must validate node in a separate operation
                        handle.Index = ii;
                        nodesToValidate.Add(handle);

                        continue;
                    }

                    // read the attribute value.
                    errors[ii] = handle.Node.ReadAttribute(
                        systemContext,
                        nodeToRead.AttributeId,
                        nodeToRead.ParsedIndexRange,
                        nodeToRead.DataEncoding,
                        value);
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }
            }

            // validates the nodes (reads values from the underlying data source if required).
            Read(
                systemContext,
                nodesToRead,
                values,
                errors,
                nodesToValidate,
                operationCache);
        }

        #region Read Support Functions
        /// <summary>
        /// Finds a node in the dynamic cache.
        /// </summary>
        /// <param name="context">The current context.</param>
        /// <param name="handle">The node handle.</param>
        /// <param name="cache">The cache to search.</param>
        /// <returns>The node if found. Null otherwise.</returns>
        protected virtual NodeState FindNodeInCache(
            ServerSystemContext context,
            NodeHandle handle,
            IDictionary<NodeId, NodeState> cache)
        {
            NodeState target = null;

            // not valid if no root.
            if (handle == null)
            {
                return null;
            }

            // check if previously validated.
            if (handle.Validated)
            {
                return handle.Node;
            }

            // construct id for root node.
            NodeId rootId = handle.RootId;

            if (cache != null)
            {
                // lookup component in local cache for request.
                if (cache.TryGetValue(handle.NodeId, out target))
                {
                    return target;
                }

                // lookup root in local cache for request.
                if (!String.IsNullOrEmpty(handle.ComponentPath))
                {
                    if (cache.TryGetValue(rootId, out target))
                    {
                        target = target.FindChildBySymbolicName(context, handle.ComponentPath);

                        // component exists.
                        if (target != null)
                        {
                            return target;
                        }
                    }
                }
            }

            // lookup component in shared cache.
            target = LookupNodeInComponentCache(context, handle);

            if (target != null)
            {
                return target;
            }

            return null;
        }

        /// <summary>
        /// Marks the handle as validated and saves the node in the dynamic cache.
        /// </summary>
        protected virtual NodeState ValidationComplete(
            ServerSystemContext context,
            NodeHandle handle,
            NodeState node,
            IDictionary<NodeId, NodeState> cache)
        {
            handle.Node = node;
            handle.Validated = true;

            if (cache != null && handle != null)
            {
                cache[handle.NodeId] = node;
            }

            return node;
        }

        /// <summary>
        /// Verifies that the specified node exists.
        /// </summary>
        protected virtual NodeState ValidateNode(
            ServerSystemContext context,
            NodeHandle handle,
            IDictionary<NodeId, NodeState> cache)
        {
            // lookup in cache.
            NodeState target = FindNodeInCache(context, handle, cache);

            if (target != null)
            {
                handle.Node = target;
                handle.Validated = true;
                return handle.Node;
            }

            // return default.
            return handle.Node;
        }

        /// <summary>
        /// Validates the nodes and reads the values from the underlying source.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="nodesToRead">The nodes to read.</param>
        /// <param name="values">The values.</param>
        /// <param name="errors">The errors.</param>
        /// <param name="nodesToValidate">The nodes to validate.</param>
        /// <param name="cache">The cache.</param>
        protected virtual void Read(
            ServerSystemContext context,
            IList<ReadValueId> nodesToRead,
            IList<DataValue> values,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToValidate,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToValidate.Count; ii++)
            {
                NodeHandle handle = nodesToValidate[ii];

                lock (Lock)
                {
                    // validate node.
                    NodeState source = ValidateNode(context, handle, cache);

                    if (source == null)
                    {
                        continue;
                    }

                    ReadValueId nodeToRead = nodesToRead[handle.Index];
                    DataValue value = values[handle.Index];

                    // update the attribute value.
                    errors[handle.Index] = source.ReadAttribute(
                        context,
                        nodeToRead.AttributeId,
                        nodeToRead.ParsedIndexRange,
                        nodeToRead.DataEncoding,
                        value);
                }
            }
        }
        #endregion

        /// <summary>
        /// Writes the value for the specified attributes.
        /// </summary>
        public virtual void Write(
            OperationContext     context, 
            IList<WriteValue>    nodesToWrite, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<NodeHandle> nodesToValidate = new List<NodeHandle>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToWrite.Count; ii++)
                {

                    WriteValue nodeToWrite = nodesToWrite[ii];

                    // skip items that have already been processed.
                    if (nodeToWrite.Processed)
                    {
                        continue;
                    }

                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, nodeToWrite.NodeId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToWrite.Processed = true;

                    // index range is not supported.
                    if (nodeToWrite.AttributeId != Attributes.Value)
                    {
                        if (!String.IsNullOrEmpty(nodeToWrite.IndexRange))
                        {
                            errors[ii] = StatusCodes.BadWriteNotSupported;
                            continue;
                        }
                    }

                    // check if the node is a area in memory.
                    if (handle.Node == null)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;

                        // must validate node in a separate operation.
                        handle.Index = ii;
                        nodesToValidate.Add(handle);

                        continue;
                    }

                    // check if the node is AnalogItem and the value is outside the InstrumentRange.
                    AnalogItemState analogItemState = handle.Node as AnalogItemState;
                    if (analogItemState?.InstrumentRange != null)
                    {
                        try
                        {
                            double newValue = System.Convert.ToDouble(nodeToWrite.Value.Value);

                            if (newValue > analogItemState.InstrumentRange.Value.High ||
                                newValue < analogItemState.InstrumentRange.Value.Low)
                            {
                                errors[ii] = StatusCodes.BadOutOfRange;
                                continue;
                            }
                        }
                        catch
                        {
                            //skip the InstrumentRange check if the transformation isn't possible.
                        }
                    }

                    Utils.TraceDebug("WRITE: Value={0} Range={1}", nodeToWrite.Value.WrappedValue, nodeToWrite.IndexRange);

                    PropertyState propertyState = handle.Node as PropertyState;
                    object previousPropertyValue = null;

                    if (propertyState != null)
                    {
                        ExtensionObject extension = propertyState.Value as ExtensionObject;
                        if (extension != null)
                        {
                            previousPropertyValue = extension.Body;
                        }
                        else
                        {
                            previousPropertyValue = propertyState.Value;
                        }
                    }

                    // write the attribute value.
                    errors[ii] = handle.Node.WriteAttribute(
                        systemContext,
                        nodeToWrite.AttributeId,
                        nodeToWrite.ParsedIndexRange,
                        nodeToWrite.Value);

                    if (!ServiceResult.IsGood(errors[ii]))
                    {
                        continue;
                    }

                    if (propertyState != null)
                    {
                        object propertyValue;
                        ExtensionObject extension = nodeToWrite.Value.Value as ExtensionObject;

                        if (extension != null)
                        {
                            propertyValue = extension.Body;
                        }
                        else
                        {
                            propertyValue = nodeToWrite.Value.Value;
                        }

                        CheckIfSemanticsHaveChanged(systemContext, propertyState, propertyValue, previousPropertyValue);
                    }

                    // updates to source finished - report changes to monitored items.
                    handle.Node.ClearChangeMasks(systemContext, false);
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }
            }

            // validates the nodes and writes the value to the underlying system.
            Write(
                systemContext,
                nodesToWrite,
                errors,
                nodesToValidate,
                operationCache);
        }

        private void CheckIfSemanticsHaveChanged(ServerSystemContext systemContext, PropertyState property, object newPropertyValue, object previousPropertyValue)
        {
            // check if the changed property is one that can trigger semantic changes
            string propertyName = property.BrowseName.Name;

            if (propertyName != BrowseNames.EURange &&
                propertyName != BrowseNames.InstrumentRange &&
                propertyName != BrowseNames.EngineeringUnits &&
                propertyName != BrowseNames.Title &&
                propertyName != BrowseNames.AxisDefinition &&
                propertyName != BrowseNames.FalseState &&
                propertyName != BrowseNames.TrueState &&
                propertyName != BrowseNames.EnumStrings &&
                propertyName != BrowseNames.XAxisDefinition &&
                propertyName != BrowseNames.YAxisDefinition &&
                propertyName != BrowseNames.ZAxisDefinition)
            {
                return;
            }

            //look for the Parent and its monitoring items
            foreach (var monitoredNode in m_monitoredNodes.Values)
            {
                var propertyState = monitoredNode.Node.FindChild(systemContext, property.BrowseName);

                if (propertyState != null && property != null && propertyState.NodeId == property.NodeId && !Utils.IsEqual(newPropertyValue, previousPropertyValue))
                {
                    foreach (var monitoredItem in monitoredNode.DataChangeMonitoredItems)
                    {
                        if (monitoredItem.AttributeId == Attributes.Value)
                        {
                            NodeState node = monitoredNode.Node;

                            if ((node is AnalogItemState && (propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits)) ||
                                (node is TwoStateDiscreteState && (propertyName == BrowseNames.FalseState || propertyName == BrowseNames.TrueState)) ||
                                (node is MultiStateDiscreteState && (propertyName == BrowseNames.EnumStrings)) ||
                                (node is ArrayItemState && (propertyName == BrowseNames.InstrumentRange || propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits || propertyName == BrowseNames.Title)) ||
                                ((node is YArrayItemState || node is XYArrayItemState) && (propertyName == BrowseNames.InstrumentRange || propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits || propertyName == BrowseNames.Title || propertyName == BrowseNames.XAxisDefinition)) ||
                                (node is ImageItemState && (propertyName == BrowseNames.InstrumentRange || propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits || propertyName == BrowseNames.Title || propertyName == BrowseNames.XAxisDefinition || propertyName == BrowseNames.YAxisDefinition)) ||
                                (node is CubeItemState && (propertyName == BrowseNames.InstrumentRange || propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits || propertyName == BrowseNames.Title || propertyName == BrowseNames.XAxisDefinition || propertyName == BrowseNames.YAxisDefinition || propertyName == BrowseNames.ZAxisDefinition)) ||
                                (node is NDimensionArrayItemState && (propertyName == BrowseNames.InstrumentRange || propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits || propertyName == BrowseNames.Title || propertyName == BrowseNames.AxisDefinition)))
                            {
                                monitoredItem.SetSemanticsChanged();

                                DataValue value = new DataValue();
                                value.ServerTimestamp = DateTime.UtcNow;

                                monitoredNode.Node.ReadAttribute(systemContext, Attributes.Value, monitoredItem.IndexRange, null, value);

                                monitoredItem.QueueValue(value, ServiceResult.Good, true);
                            }
                        }
                    }
                }
            }
        }

        #region Write Support Functions
        /// <summary>
        /// Validates the nodes and writes the value to the underlying system.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="nodesToWrite">The nodes to write.</param>
        /// <param name="errors">The errors.</param>
        /// <param name="nodesToValidate">The nodes to validate.</param>
        /// <param name="cache">The cache.</param>
        protected virtual void Write(
            ServerSystemContext context,
            IList<WriteValue> nodesToWrite,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToValidate,
            IDictionary<NodeId, NodeState> cache)
        {
            // validates the nodes (reads values from the underlying data source if required).
            for (int ii = 0; ii < nodesToValidate.Count; ii++)
            {
                NodeHandle handle = nodesToValidate[ii];

                lock (Lock)
                {
                    // validate node.
                    NodeState source = ValidateNode(context, handle, cache);

                    if (source == null)
                    {
                        continue;
                    }

                    WriteValue nodeToWrite = nodesToWrite[handle.Index];

                    // write the attribute value.
                    errors[handle.Index] = source.WriteAttribute(
                        context,
                        nodeToWrite.AttributeId,
                        nodeToWrite.ParsedIndexRange,
                        nodeToWrite.Value);

                    // updates to source finished - report changes to monitored items.
                    source.ClearChangeMasks(context, false);
                }
            }
        }
        #endregion

        /// <summary>
        /// Reads the history for the specified nodes.
        /// </summary>
        public virtual void HistoryRead(
            OperationContext          context, 
            HistoryReadDetails        details, 
            TimestampsToReturn        timestampsToReturn, 
            bool                      releaseContinuationPoints, 
            IList<HistoryReadValueId> nodesToRead, 
            IList<HistoryReadResult>  results, 
            IList<ServiceResult>      errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<NodeHandle> nodesToProcess = new List<NodeHandle>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToRead.Count; ii++)
                {
                    HistoryReadValueId nodeToRead = nodesToRead[ii];

                    // skip items that have already been processed.
                    if (nodeToRead.Processed)
                    {
                        continue;
                    }

                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, nodeToRead.NodeId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToRead.Processed = true;

                    // create an initial result.
                    HistoryReadResult result = results[ii] = new HistoryReadResult();

                    result.HistoryData       = null;
                    result.ContinuationPoint = null;
                    result.StatusCode        = StatusCodes.Good;

                    // check if the node is a area in memory.
                    if (handle.Node == null)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;

                        // must validate node in a seperate operation
                        handle.Index = ii;
                        nodesToProcess.Add(handle);

                        continue;
                    }

                    errors[ii] = StatusCodes.BadHistoryOperationUnsupported;

                    // check for data history variable.
                    BaseVariableState variable = handle.Node as BaseVariableState;

                    if (variable != null)
                    {
                        if ((variable.AccessLevel & AccessLevels.HistoryRead) != 0)
                        {
                            handle.Index = ii;
                            nodesToProcess.Add(handle);
                            continue;
                        }
                    }

                    // check for event history object.
                    BaseObjectState notifier = handle.Node as BaseObjectState;

                    if (notifier != null)
                    {
                        if ((notifier.EventNotifier & EventNotifiers.HistoryRead) != 0)
                        {
                            handle.Index = ii;
                            nodesToProcess.Add(handle);
                            continue;
                        }
                    }
                }

                // check for nothing to do.
                if (nodesToProcess.Count == 0)
                {
                    return;
                }
            }

            // validates the nodes (reads values from the underlying data source if required).
            HistoryRead(
                systemContext,
                details,
                timestampsToReturn,
                releaseContinuationPoints,
                nodesToRead,
                results,
                errors,
                nodesToProcess,
                operationCache);
        }

        #region HistoryRead Support Functions
        /// <summary>
        /// Releases the continuation points.
        /// </summary>
        protected virtual void HistoryReleaseContinuationPoints(
            ServerSystemContext context,
            IList<HistoryReadValueId> nodesToRead,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadContinuationPointInvalid;
            }
        }

        /// <summary>
        /// Reads raw history data.
        /// </summary>
        protected virtual void HistoryReadRawModified(
            ServerSystemContext context,
            ReadRawModifiedDetails details,
            TimestampsToReturn timestampsToReturn,
            IList<HistoryReadValueId> nodesToRead,
            IList<HistoryReadResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Reads processed history data.
        /// </summary>
        protected virtual void HistoryReadProcessed(
            ServerSystemContext context,
            ReadProcessedDetails details,
            TimestampsToReturn timestampsToReturn,
            IList<HistoryReadValueId> nodesToRead,
            IList<HistoryReadResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Reads history data at specified times.
        /// </summary>
        protected virtual void HistoryReadAtTime(
            ServerSystemContext context,
            ReadAtTimeDetails details,
            TimestampsToReturn timestampsToReturn,
            IList<HistoryReadValueId> nodesToRead,
            IList<HistoryReadResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Reads history events.
        /// </summary>
        protected virtual void HistoryReadEvents(
            ServerSystemContext context,
            ReadEventDetails details,
            TimestampsToReturn timestampsToReturn,
            IList<HistoryReadValueId> nodesToRead,
            IList<HistoryReadResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Validates the nodes and reads the values from the underlying source.
        /// </summary>
        protected virtual void HistoryRead(
            ServerSystemContext context,
            HistoryReadDetails details,
            TimestampsToReturn timestampsToReturn,
            bool releaseContinuationPoints,
            IList<HistoryReadValueId> nodesToRead,
            IList<HistoryReadResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            // check if continuation points are being released.
            if (releaseContinuationPoints)
            {
                HistoryReleaseContinuationPoints(
                    context,
                    nodesToRead,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // check timestamps to return.
            if (timestampsToReturn < TimestampsToReturn.Source || timestampsToReturn > TimestampsToReturn.Neither)
            {
                throw new ServiceResultException(StatusCodes.BadTimestampsToReturnInvalid);
            }

            // handle raw data request.
            ReadRawModifiedDetails readRawModifiedDetails = details as ReadRawModifiedDetails;

            if (readRawModifiedDetails != null)
            {
                // at least one must be provided.
                if (readRawModifiedDetails.StartTime == DateTime.MinValue && readRawModifiedDetails.EndTime == DateTime.MinValue)
                {
                    throw new ServiceResultException(StatusCodes.BadInvalidTimestampArgument);
                }

                // if one is null the num values must be provided.
                if (readRawModifiedDetails.StartTime == DateTime.MinValue || readRawModifiedDetails.EndTime == DateTime.MinValue)
                {
                    if (readRawModifiedDetails.NumValuesPerNode == 0)
                    {
                        throw new ServiceResultException(StatusCodes.BadInvalidTimestampArgument);
                    }
                }

                HistoryReadRawModified(
                    context,
                    readRawModifiedDetails,
                    timestampsToReturn,
                    nodesToRead,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle processed data request.
            ReadProcessedDetails readProcessedDetails = details as ReadProcessedDetails;

            if (readProcessedDetails != null)
            {
                // check the list of aggregates.
                if (readProcessedDetails.AggregateType == null || readProcessedDetails.AggregateType.Count != nodesToRead.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadAggregateListMismatch);
                }

                // check start/end time.
                if (readProcessedDetails.StartTime == DateTime.MinValue || readProcessedDetails.EndTime == DateTime.MinValue)
                {
                    throw new ServiceResultException(StatusCodes.BadInvalidTimestampArgument);
                }

                HistoryReadProcessed(
                    context,
                    readProcessedDetails,
                    timestampsToReturn,
                    nodesToRead,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle raw data at time request.
            ReadAtTimeDetails readAtTimeDetails = details as ReadAtTimeDetails;

            if (readAtTimeDetails != null)
            {
                HistoryReadAtTime(
                    context,
                    readAtTimeDetails,
                    timestampsToReturn,
                    nodesToRead,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle read events request.
            ReadEventDetails readEventDetails = details as ReadEventDetails;

            if (readEventDetails != null)
            {
                // check start/end time and max values.
                if (readEventDetails.NumValuesPerNode == 0)
                {
                    if (readEventDetails.StartTime == DateTime.MinValue || readEventDetails.EndTime == DateTime.MinValue)
                    {
                        throw new ServiceResultException(StatusCodes.BadInvalidTimestampArgument);
                    }
                }
                else
                {
                    if (readEventDetails.StartTime == DateTime.MinValue && readEventDetails.EndTime == DateTime.MinValue)
                    {
                        throw new ServiceResultException(StatusCodes.BadInvalidTimestampArgument);
                    }
                }

                // validate the event filter.
                EventFilter.Result result = readEventDetails.Filter.Validate(new FilterContext(m_server.NamespaceUris, m_server.TypeTree, context));

                if (ServiceResult.IsBad(result.Status))
                {
                    throw new ServiceResultException(result.Status);
                }

                // read the event history.
                HistoryReadEvents(
                    context,
                    readEventDetails,
                    timestampsToReturn,
                    nodesToRead,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }
        }
        #endregion

        /// <summary>
        /// Updates the history for the specified nodes.
        /// </summary>
        public virtual void HistoryUpdate(
            OperationContext            context, 
            Type                        detailsType, 
            IList<HistoryUpdateDetails> nodesToUpdate, 
            IList<HistoryUpdateResult>  results,
            IList<ServiceResult>        errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<NodeHandle> nodesToProcess = new List<NodeHandle>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToUpdate.Count; ii++)
                {
                    HistoryUpdateDetails nodeToUpdate = nodesToUpdate[ii];

                    // skip items that have already been processed.
                    if (nodeToUpdate.Processed)
                    {
                        continue;
                    }

                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, nodeToUpdate.NodeId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToUpdate.Processed = true;

                    // create an initial result.
                    HistoryUpdateResult result = results[ii] = new HistoryUpdateResult();
                    result.StatusCode = StatusCodes.Good;

                    // check if the node is a area in memory.
                    if (handle.Node == null)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;

                        // must validate node in a seperate operation
                        handle.Index = ii;
                        nodesToProcess.Add(handle);
                        continue;
                    }

                    errors[ii] = StatusCodes.BadHistoryOperationUnsupported;

                    // check for data history variable.
                    BaseVariableState variable = handle.Node as BaseVariableState;

                    if (variable != null)
                    {
                        if ((variable.AccessLevel & AccessLevels.HistoryWrite) != 0)
                        {
                            handle.Index = ii;
                            nodesToProcess.Add(handle);
                            continue;
                        }
                    }

                    // check for event history object.
                    BaseObjectState notifier = handle.Node as BaseObjectState;

                    if (notifier != null)
                    {
                        if ((notifier.EventNotifier & EventNotifiers.HistoryWrite) != 0)
                        {
                            handle.Index = ii;
                            nodesToProcess.Add(handle);
                            continue;
                        }
                    }
                }

                // check for nothing to do.
                if (nodesToProcess.Count == 0)
                {
                    return;
                }
            }

            // validates the nodes and updates.
            HistoryUpdate(
                systemContext,
                detailsType,
                nodesToUpdate,
                results,
                errors,
                nodesToProcess,
                operationCache);
        }

        #region HistoryUpdate Support Functions
        /// <summary>
        /// Validates the nodes and updates the history.
        /// </summary>
        protected virtual void HistoryUpdate(
            ServerSystemContext context,
            Type                           detailsType, 
            IList<HistoryUpdateDetails>    nodesToUpdate, 
            IList<HistoryUpdateResult>     results,
            IList<ServiceResult>           errors,
            List<NodeHandle>               nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            // handle update data request.
            if (detailsType == typeof(UpdateDataDetails))
            {
                UpdateDataDetails[] details = new UpdateDataDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (UpdateDataDetails)nodesToUpdate[ii];
                }

                HistoryUpdateData(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle update structure data request.
            if (detailsType == typeof(UpdateStructureDataDetails))
            {
                UpdateStructureDataDetails[] details = new UpdateStructureDataDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (UpdateStructureDataDetails)nodesToUpdate[ii];
                }

                HistoryUpdateStructureData(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle update events request.
            if (detailsType == typeof(UpdateEventDetails))
            {
                UpdateEventDetails[] details = new UpdateEventDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (UpdateEventDetails)nodesToUpdate[ii];
                }

                HistoryUpdateEvents(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle delete raw data request.
            if (detailsType == typeof(DeleteRawModifiedDetails))
            {
                DeleteRawModifiedDetails[] details = new DeleteRawModifiedDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (DeleteRawModifiedDetails)nodesToUpdate[ii];
                }

                HistoryDeleteRawModified(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle delete at time request.
            if (detailsType == typeof(DeleteAtTimeDetails))
            {
                DeleteAtTimeDetails[] details = new DeleteAtTimeDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (DeleteAtTimeDetails)nodesToUpdate[ii];
                }

                HistoryDeleteAtTime(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle delete at time request.
            if (detailsType == typeof(DeleteEventDetails))
            {
                DeleteEventDetails[] details = new DeleteEventDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (DeleteEventDetails)nodesToUpdate[ii];
                }

                HistoryDeleteEvents(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }
        }

        /// <summary>
        /// Updates the data history for one or more nodes.
        /// </summary>
        protected virtual void HistoryUpdateData(
            ServerSystemContext context,
            IList<UpdateDataDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Updates the structured data history for one or more nodes.
        /// </summary>
        protected virtual void HistoryUpdateStructureData(
            ServerSystemContext context,
            IList<UpdateStructureDataDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Updates the event history for one or more nodes.
        /// </summary>
        protected virtual void HistoryUpdateEvents(
            ServerSystemContext context,
            IList<UpdateEventDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Deletes the data history for one or more nodes.
        /// </summary>
        protected virtual void HistoryDeleteRawModified(
            ServerSystemContext context,
            IList<DeleteRawModifiedDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Deletes the data history for one or more nodes.
        /// </summary>
        protected virtual void HistoryDeleteAtTime(
            ServerSystemContext context,
            IList<DeleteAtTimeDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Deletes the event history for one or more nodes.
        /// </summary>
        protected virtual void HistoryDeleteEvents(
            ServerSystemContext context,
            IList<DeleteEventDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }
        #endregion

        /// <summary>
        /// Calls a method on the specified nodes.
        /// </summary>
        public virtual void Call(
            OperationContext         context,
            IList<CallMethodRequest> methodsToCall,
            IList<CallMethodResult>  results,
            IList<ServiceResult>     errors)
        {
            ServerSystemContext systemContext = SystemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();

            for (int ii = 0; ii < methodsToCall.Count; ii++)
            {
                CallMethodRequest methodToCall = methodsToCall[ii];

                // skip items that have already been processed.
                if (methodToCall.Processed)
                {
                    continue;
                }

                MethodState method = null;

                lock (Lock)
                {
                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, methodToCall.ObjectId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    methodToCall.Processed = true;

                    // validate the source node.
                    NodeState source = ValidateNode(systemContext, handle, operationCache);

                    if (source == null)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        continue;
                    }

                    // find the method.
                    method = source.FindMethod(systemContext, methodToCall.MethodId);

                    if (method == null)
                    {
                        // check for loose coupling.
                        if (source.ReferenceExists(ReferenceTypeIds.HasComponent, false, methodToCall.MethodId))
                        {
                            method = (MethodState)FindPredefinedNode(methodToCall.MethodId, typeof(MethodState));
                        }

                        if (method == null)
                        {
                            errors[ii] = StatusCodes.BadMethodInvalid;
                            continue;
                        }
                    }
                }

                // call the method.
                CallMethodResult result = results[ii] = new CallMethodResult();

                errors[ii] = Call(
                    systemContext,
                    methodToCall,
                    method,
                    result);
            }
        }

        /// <summary>
        /// Calls a method on an object.
        /// </summary>
        protected virtual ServiceResult Call(
            ISystemContext    context,
            CallMethodRequest methodToCall,
            MethodState       method,
            CallMethodResult  result)
        {
            ServerSystemContext systemContext = context as ServerSystemContext;
            List<ServiceResult> argumentErrors = new List<ServiceResult>();
            VariantCollection outputArguments = new VariantCollection();

            ServiceResult error = method.Call(
                context,
                methodToCall.ObjectId,
                methodToCall.InputArguments,
                argumentErrors,
                outputArguments);

            if (ServiceResult.IsBad(error))
            {
                return error;
            }

            // check for argument errors.
            bool argumentsValid = true;

            for (int jj = 0; jj < argumentErrors.Count; jj++)
            {
                ServiceResult argumentError = argumentErrors[jj];

                if (argumentError != null)
                {
                    result.InputArgumentResults.Add(argumentError.StatusCode);

                    if (ServiceResult.IsBad(argumentError))
                    {
                        argumentsValid = false;
                    }
                }
                else
                {
                    result.InputArgumentResults.Add(StatusCodes.Good);
                }

                // only fill in diagnostic info if it is requested.
                if (systemContext.OperationContext != null)
                {
                    if ((systemContext.OperationContext.DiagnosticsMask & DiagnosticsMasks.OperationAll) != 0)
                    {
                        if (ServiceResult.IsBad(argumentError))
                        {
                            argumentsValid = false;
                            result.InputArgumentDiagnosticInfos.Add(new DiagnosticInfo(argumentError, systemContext.OperationContext.DiagnosticsMask, false, systemContext.OperationContext.StringTable));
                        }
                        else
                        {
                            result.InputArgumentDiagnosticInfos.Add(null);
                        }
                    }
                }
            }

            // check for validation errors.
            if (!argumentsValid)
            {
                result.StatusCode = StatusCodes.BadInvalidArgument;
                return result.StatusCode;
            }

            // do not return diagnostics if there are no errors.
            result.InputArgumentDiagnosticInfos.Clear();

            // return output arguments.
            result.OutputArguments = outputArguments;

            return ServiceResult.Good;
        }


        /// <summary>
        /// Subscribes or unsubscribes to events produced by the specified source.
        /// </summary>
        /// <remarks>
        /// This method is called when a event subscription is created or deletes. The node manager 
        /// must  start/stop reporting events for the specified object and all objects below it in 
        /// the notifier hierarchy.
        /// </remarks>
        public virtual ServiceResult SubscribeToEvents(
            OperationContext    context, 
            object              sourceId, 
            uint                subscriptionId, 
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe)
        {
            ServerSystemContext systemContext = SystemContext.Copy(context);

            lock (Lock)
            {
                // check for valid handle.
                NodeHandle handle = IsHandleInNamespace(sourceId);

                if (handle == null)
                {
                    return StatusCodes.BadNodeIdInvalid;
                }

                // check for valid node.
                NodeState source = ValidateNode(systemContext, handle, null);

                if (source == null)
                {
                    return StatusCodes.BadNodeIdUnknown;
                }

                // subscribe to events.
                return SubscribeToEvents(systemContext, source, monitoredItem, unsubscribe);
            }
        }

        /// <summary>
        /// Subscribes or unsubscribes to events produced by all event sources.
        /// </summary>
        /// <remarks>
        /// This method is called when a event subscription is created or deleted. The node 
        /// manager must start/stop reporting events for all objects that it manages.
        /// </remarks>
        public virtual ServiceResult SubscribeToAllEvents(
            OperationContext    context, 
            uint                subscriptionId, 
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe)
        {
            ServerSystemContext systemContext = SystemContext.Copy(context);

            lock (Lock)
            {
                // A client has subscribed to the Server object which means all events produced
                // by this manager must be reported. This is done by incrementing the monitoring
                // reference count for all root notifiers.
                if (m_rootNotifiers != null)
                {
                    for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
                    {
                        SubscribeToEvents(systemContext, m_rootNotifiers[ii], monitoredItem, unsubscribe);
                    }
                }

                return ServiceResult.Good;
            }
        }

        #region SubscribeToEvents Support Functions
        /// <summary>
        /// Adds a root notifier.
        /// </summary>
        /// <param name="notifier">The notifier.</param>
        /// <remarks>
        /// A root notifier is a notifier owned by the NodeManager that is not the target of a 
        /// HasNotifier reference. These nodes need to be linked directly to the Server object.
        /// </remarks>
        protected virtual void AddRootNotifier(NodeState notifier)
        {
            if (m_rootNotifiers == null)
            {
                m_rootNotifiers = new List<NodeState>();
            }

            bool mustAdd = true;

            for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
            {
                if (Object.ReferenceEquals(notifier, m_rootNotifiers[ii]))
                {
                    return;
                }

                if (m_rootNotifiers[ii].NodeId == notifier.NodeId)
                {
                    m_rootNotifiers[ii] = notifier;
                    mustAdd = false;
                    break;
                }
            }

            if (mustAdd)
            {
                m_rootNotifiers.Add(notifier);
            }

            // need to prevent recursion with the server object.
            if (notifier.NodeId != ObjectIds.Server)
            {
                notifier.OnReportEvent = OnReportEvent;

                if (!notifier.ReferenceExists(ReferenceTypeIds.HasNotifier, true, ObjectIds.Server))
                {
                    notifier.AddReference(ReferenceTypeIds.HasNotifier, true, ObjectIds.Server);
                }
            }

            // subscribe to existing events.
            if (m_server.EventManager != null)
            {
                IList<IEventMonitoredItem> monitoredItems = m_server.EventManager.GetMonitoredItems();

                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    if (monitoredItems[ii].MonitoringAllEvents)
                    {
                        SubscribeToEvents(
                            SystemContext,
                            notifier,
                            monitoredItems[ii],
                            true);
                    }
                }
            }
        }

        /// <summary>
        /// Removes a root notifier previously added with AddRootNotifier.
        /// </summary>
        /// <param name="notifier">The notifier.</param>
        protected virtual void RemoveRootNotifier(NodeState notifier)
        {
            if (m_rootNotifiers != null)
            {
                for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
                {
                    if (Object.ReferenceEquals(notifier, m_rootNotifiers[ii]))
                    {
                        notifier.OnReportEvent = null;
                        notifier.RemoveReference(ReferenceTypeIds.HasNotifier, true, ObjectIds.Server);
                        m_rootNotifiers.RemoveAt(ii);
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Reports an event for a root notifier.
        /// </summary>
        protected virtual void OnReportEvent(
            ISystemContext context,
            NodeState node,
            IFilterTarget e)
        {
            Server.ReportEvent(context, e);
        }

        /// <summary>
        /// Subscribes to events.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="source">The source.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        /// <param name="unsubscribe">if set to <c>true</c> [unsubscribe].</param>
        /// <returns>Any error code.</returns>
        protected virtual ServiceResult SubscribeToEvents(
            ServerSystemContext context, 
            NodeState           source,
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe)
        {
            MonitoredNode2 monitoredNode = null;

            // handle unsubscribe.
            if (unsubscribe)
            {
                // check for existing monitored node.
                if (!MonitoredNodes.TryGetValue(source.NodeId, out monitoredNode))
                {
                    return StatusCodes.BadNodeIdUnknown;
                }

                monitoredNode.Remove(monitoredItem);

                // check if node is no longer being monitored.
                if (!monitoredNode.HasMonitoredItems)
                {
                    MonitoredNodes.Remove(source.NodeId);
                }

                // update flag.
                source.SetAreEventsMonitored(context, !unsubscribe, true);

                // call subclass.
                OnSubscribeToEvents(context, monitoredNode, unsubscribe);

                // all done.
                return ServiceResult.Good;
            }

            // only objects or views can be subscribed to.
            BaseObjectState instance = source as BaseObjectState;

            if (instance == null || (instance.EventNotifier & EventNotifiers.SubscribeToEvents) == 0)
            {
                ViewState view = source as ViewState;

                if (view == null || (view.EventNotifier & EventNotifiers.SubscribeToEvents) == 0)
                {
                    return StatusCodes.BadNotSupported;
                }
            }

            // check for existing monitored node.
            if (!MonitoredNodes.TryGetValue(source.NodeId, out monitoredNode))
            {
                MonitoredNodes[source.NodeId] = monitoredNode = new MonitoredNode2(this, source);
            }

            // this links the node to specified monitored item and ensures all events
            // reported by the node are added to the monitored item's queue.
            monitoredNode.Add(monitoredItem);

            // This call recursively updates a reference count all nodes in the notifier
            // hierarchy below the area. Sources with a reference count of 0 do not have 
            // any active subscriptions so they do not need to report events.
            source.SetAreEventsMonitored(context, !unsubscribe, true);

            // signal update.
            OnSubscribeToEvents(context, monitoredNode, unsubscribe);

            // all done.
            return ServiceResult.Good;
        }

        /// <summary>
        /// Called after subscribing/unsubscribing to events.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="monitoredNode">The monitored node.</param>
        /// <param name="unsubscribe">if set to <c>true</c> unsubscribing.</param>
        protected virtual void OnSubscribeToEvents(
            ServerSystemContext context,
            MonitoredNode2       monitoredNode, 
            bool                unsubscribe)
        {
            // defined by the sub-class
        }
        #endregion

        /// <summary>
        /// Tells the node manager to refresh any conditions associated with the specified monitored items.
        /// </summary>
        /// <remarks>
        /// This method is called when the condition refresh method is called for a subscription.
        /// The node manager must create a refresh event for each condition monitored by the subscription.
        /// </remarks>
        public virtual ServiceResult ConditionRefresh(
            OperationContext           context,
            IList<IEventMonitoredItem> monitoredItems)
        {
            ServerSystemContext systemContext = SystemContext.Copy(context);

            for (int ii = 0; ii < monitoredItems.Count; ii++)
            {
                // the IEventMonitoredItem should always be MonitoredItems since they are created by the MasterNodeManager.
                MonitoredItem monitoredItem = monitoredItems[ii] as MonitoredItem;

                if (monitoredItem == null)
                {
                    continue;
                }

                List<IFilterTarget> events = new List<IFilterTarget>();
                List<NodeState> nodesToRefresh = new List<NodeState>();

                lock (Lock)
                {
                    // check for server subscription.
                    if (monitoredItem.NodeId == ObjectIds.Server)
                    {
                        if (m_rootNotifiers != null)
                        {
                            nodesToRefresh.AddRange(m_rootNotifiers);
                        }
                    }
                    else
                    {
                        // check for existing monitored node.
                        MonitoredNode2 monitoredNode = null;

                        if (!MonitoredNodes.TryGetValue(monitoredItem.NodeId, out monitoredNode))
                        {
                            continue;
                        }

                        // get the refresh events.
                        nodesToRefresh.Add(monitoredNode.Node);
                    }
                }

                // block and wait for the refresh.
                for (int jj = 0; jj < nodesToRefresh.Count; jj++)
                {
                    nodesToRefresh[jj].ConditionRefresh(systemContext, events, true);
                }

                // queue the events.
                for (int jj = 0; jj < events.Count; jj++)
                {
                    monitoredItem.QueueEvent(events[jj]);
                }
            }

            // all done.
            return ServiceResult.Good;
        }

        /// <summary>
        /// Creates a new set of monitored items for a set of variables.
        /// </summary>
        /// <remarks>
        /// This method only handles data change subscriptions. Event subscriptions are created by the SDK.
        /// </remarks>
        public virtual void CreateMonitoredItems(
            OperationContext                  context, 
            uint                              subscriptionId, 
            double                            publishingInterval, 
            TimestampsToReturn                timestampsToReturn, 
            IList<MonitoredItemCreateRequest> itemsToCreate, 
            IList<ServiceResult>              errors, 
            IList<MonitoringFilterResult>     filterResults, 
            IList<IMonitoredItem>             monitoredItems,
            ref long                          globalIdCounter)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<NodeHandle> nodesToValidate = new List<NodeHandle>();
            List<IMonitoredItem> createdItems = new List<IMonitoredItem>();

            lock (Lock)
            {
                for (int ii = 0; ii < itemsToCreate.Count; ii++)
                {
                    MonitoredItemCreateRequest itemToCreate = itemsToCreate[ii];

                    // skip items that have already been processed.
                    if (itemToCreate.Processed)
                    {
                        continue;
                    }

                    ReadValueId itemToMonitor = itemToCreate.ItemToMonitor;

                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, itemToMonitor.NodeId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    itemToCreate.Processed = true;

                    // must validate node in a seperate operation.
                    errors[ii] = StatusCodes.BadNodeIdUnknown;

                    handle.Index = ii;
                    nodesToValidate.Add(handle);
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }
            }

            // validates the nodes (reads values from the underlying data source if required).
            for (int ii = 0; ii < nodesToValidate.Count; ii++)
            {
                NodeHandle handle = nodesToValidate[ii];

                MonitoringFilterResult filterResult = null;
                IMonitoredItem monitoredItem = null;

                lock (Lock)
                {
                    // validate node.
                    NodeState source = ValidateNode(systemContext, handle, operationCache);

                    if (source == null)
                    {
                        continue;
                    }

                    MonitoredItemCreateRequest itemToCreate = itemsToCreate[handle.Index];

                    // create monitored item.
                    errors[handle.Index] = CreateMonitoredItem(
                        systemContext,
                        handle,
                        subscriptionId,
                        publishingInterval,
                        context.DiagnosticsMask,
                        timestampsToReturn,
                        itemToCreate,
                        ref globalIdCounter,
                        out filterResult,
                        out monitoredItem);
                }

                // save any filter error details.
                filterResults[handle.Index] = filterResult;

                if (ServiceResult.IsBad(errors[handle.Index]))
                {
                    continue;
                }

                // save the monitored item.
                monitoredItems[handle.Index] = monitoredItem;
                createdItems.Add(monitoredItem);
            }

            // do any post processing.
            OnCreateMonitoredItemsComplete(systemContext, createdItems);
        }

        #region CreateMonitoredItem Support Functions
        /// <summary>
        /// Called when a batch of monitored items has been created.
        /// </summary>
        protected virtual void OnCreateMonitoredItemsComplete(ServerSystemContext context, IList<IMonitoredItem> monitoredItems)
        {
            // defined by the sub-class
        }

        /// <summary>
        /// Creates a new set of monitored items for a set of variables.
        /// </summary>
        /// <remarks>
        /// This method only handles data change subscriptions. Event subscriptions are created by the SDK.
        /// </remarks>
        protected virtual ServiceResult CreateMonitoredItem(
            ServerSystemContext context,
            NodeHandle handle,
            uint subscriptionId,
            double publishingInterval,
            DiagnosticsMasks diagnosticsMasks,
            TimestampsToReturn timestampsToReturn,
            MonitoredItemCreateRequest itemToCreate,
            ref long globalIdCounter,
            out MonitoringFilterResult filterResult,
            out IMonitoredItem monitoredItem)
        {
            filterResult = null;
            monitoredItem = null;

            // validate parameters.
            MonitoringParameters parameters = itemToCreate.RequestedParameters;

            // validate attribute.
            if (!Attributes.IsValid(handle.Node.NodeClass, itemToCreate.ItemToMonitor.AttributeId))
            {
                return StatusCodes.BadAttributeIdInvalid;
            }

            NodeState cachedNode = AddNodeToComponentCache(context, handle, handle.Node);

            // check if the node is already being monitored.
            MonitoredNode2 monitoredNode = null;

            if (!m_monitoredNodes.TryGetValue(handle.Node.NodeId, out monitoredNode))
            {
                m_monitoredNodes[handle.Node.NodeId] = monitoredNode = new MonitoredNode2(this, cachedNode);
            }

            handle.Node = monitoredNode.Node;
            handle.MonitoredNode = monitoredNode;

            // create a globally unique identifier.
            uint monitoredItemId = Utils.IncrementIdentifier(ref globalIdCounter);

            // determine the sampling interval.
            double samplingInterval = itemToCreate.RequestedParameters.SamplingInterval;

            if (samplingInterval < 0)
            {
                samplingInterval = publishingInterval;
            }

            // ensure minimum sampling interval is not exceeded.
            if (itemToCreate.ItemToMonitor.AttributeId == Attributes.Value)
            {
                BaseVariableState variable = handle.Node as BaseVariableState;

                if (variable != null && samplingInterval < variable.MinimumSamplingInterval)
                {
                    samplingInterval = variable.MinimumSamplingInterval;
                }
            }

            // put a large upper limit on sampling.
            if (samplingInterval == Double.MaxValue)
            {
                samplingInterval = 365 * 24 * 3600 * 1000.0;
            }

            // put an upper limit on queue size.
            uint queueSize = itemToCreate.RequestedParameters.QueueSize;

            if (queueSize > m_maxQueueSize)
            {
                queueSize = m_maxQueueSize;
            }

            // validate the monitoring filter.
            Range euRange = null;
            MonitoringFilter filterToUse = null;

            ServiceResult error = ValidateMonitoringFilter(
                context,
                handle,
                itemToCreate.ItemToMonitor.AttributeId,
                samplingInterval,
                queueSize,
                parameters.Filter,
                out filterToUse,
                out euRange,
                out filterResult);

            if (ServiceResult.IsBad(error))
            {
                return error;
            }

            // create the item.
            MonitoredItem datachangeItem = new MonitoredItem(
                Server,
                this,
                handle,
                subscriptionId,
                monitoredItemId,
                context.OperationContext.Session,
                itemToCreate.ItemToMonitor,
                diagnosticsMasks,
                timestampsToReturn,
                itemToCreate.MonitoringMode,
                itemToCreate.RequestedParameters.ClientHandle,
                filterToUse,
                filterToUse,
                euRange,
                samplingInterval,
                queueSize,
                itemToCreate.RequestedParameters.DiscardOldest,
                0);

            // report the initial value.
            ReadInitialValue(context, handle, datachangeItem);

            // update monitored item list.
            monitoredItem = datachangeItem;

            // save the monitored item.
            m_monitoredItems.Add(monitoredItemId, datachangeItem);
            monitoredNode.Add(datachangeItem);

            // report change.
            OnMonitoredItemCreated(context, handle, datachangeItem);

            return error;
        }

        /// <summary>
        /// Reads the initial value for a monitored item.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The item handle.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        protected virtual void ReadInitialValue(
            ServerSystemContext context,
            NodeHandle handle,
            MonitoredItem monitoredItem)
        {
            DataValue initialValue = new DataValue();

            initialValue.Value = null;
            initialValue.ServerTimestamp = DateTime.UtcNow;
            initialValue.SourceTimestamp = DateTime.MinValue;
            initialValue.StatusCode = StatusCodes.BadWaitingForInitialData;

            ServiceResult error = handle.Node.ReadAttribute(
                context,
                monitoredItem.AttributeId,
                monitoredItem.IndexRange,
                monitoredItem.DataEncoding,
                initialValue);

            monitoredItem.QueueValue(initialValue, error);
        }

        /// <summary>
        /// Called after creating a MonitoredItem.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The handle for the node.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        protected virtual void OnMonitoredItemCreated(
            ServerSystemContext context,
            NodeHandle handle,
            MonitoredItem monitoredItem)
        {
            // overridden by the sub-class.
        }

        /// <summary>
        /// Validates Role permissions for the specified NodeId 
        /// </summary>
        /// <param name="operationContext"></param>
        /// <param name="nodeId"></param>
        /// <param name="requestedPermission"></param>
        /// <returns></returns>
        public ServiceResult ValidateRolePermissions(OperationContext operationContext, NodeId nodeId, PermissionType requestedPermission)
        {
            if (operationContext.Session == null || requestedPermission == PermissionType.None)
            {
                // no permission is required hence the validation passes.
                return StatusCodes.Good;
            }

            INodeManager nodeManager = null;
            object nodeHandle = Server.NodeManager.GetManagerHandle(nodeId, out nodeManager);

            if (nodeHandle == null || nodeManager == null)
            {
                // ignore unknown nodes.
                return StatusCodes.Good;
            }

            NodeMetadata nodeMetadata = nodeManager.GetNodeMetadata(operationContext, nodeHandle, BrowseResultMask.All);

            return MasterNodeManager.ValidateRolePermissions(operationContext, nodeMetadata, requestedPermission);
        }

        /// <summary>
        /// Validates the monitoring filter specified by the client.
        /// </summary>
        protected virtual StatusCode ValidateMonitoringFilter(
            ServerSystemContext context,
            NodeHandle handle,
            uint attributeId,
            double samplingInterval,
            uint queueSize,
            ExtensionObject filter,
            out MonitoringFilter filterToUse,
            out Range range,
            out MonitoringFilterResult result)
        {
            range = null;
            filterToUse = null;
            result = null;

            // nothing to do if the filter is not specified.
            if (ExtensionObject.IsNull(filter))
            {
                return StatusCodes.Good;
            }

            // extension objects wrap any data structure. must check that the client provided the correct structure.
            DataChangeFilter deadbandFilter = ExtensionObject.ToEncodeable(filter) as DataChangeFilter;

            if (deadbandFilter == null)
            {
                AggregateFilter aggregateFilter = ExtensionObject.ToEncodeable(filter) as AggregateFilter;

                if (aggregateFilter == null || attributeId != Attributes.Value)
                {
                    return StatusCodes.BadFilterNotAllowed;
                }

                if (!Server.AggregateManager.IsSupported(aggregateFilter.AggregateType))
                {
                    return StatusCodes.BadAggregateNotSupported;
                }

                ServerAggregateFilter revisedFilter = new ServerAggregateFilter();
                revisedFilter.AggregateType = aggregateFilter.AggregateType;
                revisedFilter.StartTime = aggregateFilter.StartTime;
                revisedFilter.ProcessingInterval = aggregateFilter.ProcessingInterval;
                revisedFilter.AggregateConfiguration = aggregateFilter.AggregateConfiguration;
                revisedFilter.Stepped = false;

                StatusCode error = ReviseAggregateFilter(context, handle, samplingInterval, queueSize, revisedFilter);

                if (StatusCode.IsBad(error))
                {
                    return error;
                }

                AggregateFilterResult aggregateFilterResult = new AggregateFilterResult();
                aggregateFilterResult.RevisedProcessingInterval = aggregateFilter.ProcessingInterval;
                aggregateFilterResult.RevisedStartTime = aggregateFilter.StartTime;
                aggregateFilterResult.RevisedAggregateConfiguration = aggregateFilter.AggregateConfiguration;

                filterToUse = revisedFilter;
                result = aggregateFilterResult;
                return StatusCodes.Good;
            }

            // deadband filters only allowed for variable values.
            if (attributeId != Attributes.Value)
            {
                return StatusCodes.BadFilterNotAllowed;
            }

            BaseVariableState variable = handle.Node as BaseVariableState;

            if (variable == null)
            {
                return StatusCodes.BadFilterNotAllowed;
            }

            // check for status filter.
            if (deadbandFilter.DeadbandType == (uint)DeadbandType.None)
            {
                filterToUse = deadbandFilter;
                return StatusCodes.Good;
            }

            // deadband filters can only be used for numeric values.
            if (!Server.TypeTree.IsTypeOf(variable.DataType, DataTypeIds.Number))
            {
                return StatusCodes.BadFilterNotAllowed;
            }

            // nothing more to do for absolute filters.
            if (deadbandFilter.DeadbandType == (uint)DeadbandType.Absolute)
            {
                filterToUse = deadbandFilter;
                return StatusCodes.Good;
            }

            // need to look up the EU range if a percent filter is requested.
            if (deadbandFilter.DeadbandType == (uint)DeadbandType.Percent)
            {
                PropertyState property = handle.Node.FindChild(context, Opc.Ua.BrowseNames.EURange) as PropertyState;

                if (property == null)
                {
                    return StatusCodes.BadMonitoredItemFilterUnsupported;
                }

                range = property.Value as Range;

                if (range == null)
                {
                    return StatusCodes.BadMonitoredItemFilterUnsupported;
                }

                filterToUse = deadbandFilter;

                return StatusCodes.Good;
            }

            // no other type of filter supported.
            return StatusCodes.BadFilterNotAllowed;
        }

        /// <summary>
        /// Revises an aggregate filter (may require knowledge of the variable being used). 
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The handle.</param>
        /// <param name="samplingInterval">The sampling interval for the monitored item.</param>
        /// <param name="queueSize">The queue size for the monitored item.</param>
        /// <param name="filterToUse">The filter to revise.</param>
        /// <returns>Good if the </returns>
        protected virtual StatusCode ReviseAggregateFilter(
            ServerSystemContext context,
            NodeHandle handle,
            double samplingInterval,
            uint queueSize,
            ServerAggregateFilter filterToUse)
        {
            if (filterToUse.ProcessingInterval < samplingInterval)
            {
                filterToUse.ProcessingInterval = samplingInterval;
            }

            if (filterToUse.ProcessingInterval < Server.AggregateManager.MinimumProcessingInterval)
            {
                filterToUse.ProcessingInterval = Server.AggregateManager.MinimumProcessingInterval;
            }

            DateTime earliestStartTime = DateTime.UtcNow.AddMilliseconds(-(queueSize - 1) * filterToUse.ProcessingInterval);

            if (earliestStartTime > filterToUse.StartTime)
            {
                filterToUse.StartTime = earliestStartTime;
            }

            if (filterToUse.AggregateConfiguration.UseServerCapabilitiesDefaults)
            {
                filterToUse.AggregateConfiguration = Server.AggregateManager.GetDefaultConfiguration(null);
            }

            return StatusCodes.Good;
        }
        #endregion

        /// <summary>
        /// Modifies the parameters for a set of monitored items.
        /// </summary>
        public virtual void ModifyMonitoredItems(
            OperationContext                  context, 
            TimestampsToReturn                timestampsToReturn, 
            IList<IMonitoredItem>             monitoredItems, 
            IList<MonitoredItemModifyRequest> itemsToModify, 
            IList<ServiceResult>              errors, 
            IList<MonitoringFilterResult>     filterResults)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            List<IMonitoredItem> modifiedItems = new List<IMonitoredItem>();

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    MonitoredItemModifyRequest itemToModify = itemsToModify[ii];

                    // skip items that have already been processed.
                    if (itemToModify.Processed || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // check handle.
                    NodeHandle handle = IsHandleInNamespace(monitoredItems[ii].ManagerHandle);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    itemToModify.Processed = true;

                    // modify the monitored item.
                    MonitoringFilterResult filterResult = null;

                    errors[ii] = ModifyMonitoredItem(
                        systemContext,
                        context.DiagnosticsMask,
                        timestampsToReturn,
                        monitoredItems[ii],
                        itemToModify,
                        handle,
                        out filterResult);

                    // save any filter error details.
                    filterResults[ii] = filterResult;

                    // save the modified item.
                    if (ServiceResult.IsGood(errors[ii]))
                    {
                        modifiedItems.Add(monitoredItems[ii]);
                    }
                }
            }

            // do any post processing.
            OnModifyMonitoredItemsComplete(systemContext, modifiedItems);
        }

        #region ModifyMonitoredItem Support Functions
        /// <summary>
        /// Called when a batch of monitored items has been modified.
        /// </summary>
        protected virtual void OnModifyMonitoredItemsComplete(ServerSystemContext context, IList<IMonitoredItem> monitoredItems)
        {
            // defined by the sub-class
        }

        /// <summary>
        /// Modifies the parameters for a monitored item.
        /// </summary>
        protected virtual ServiceResult ModifyMonitoredItem(
            ServerSystemContext context,
            DiagnosticsMasks diagnosticsMasks,
            TimestampsToReturn timestampsToReturn,
            IMonitoredItem monitoredItem,
            MonitoredItemModifyRequest itemToModify,
            NodeHandle handle,
            out MonitoringFilterResult filterResult)
        {
            filterResult = null;

            // check for valid monitored item.
            MonitoredItem datachangeItem = monitoredItem as MonitoredItem;

            // validate parameters.
            MonitoringParameters parameters = itemToModify.RequestedParameters;

            double previousSamplingInterval = datachangeItem.SamplingInterval;

            // check if the variable needs to be sampled.
            double samplingInterval = itemToModify.RequestedParameters.SamplingInterval;

            if (samplingInterval < 0)
            {
                samplingInterval = previousSamplingInterval;
            }

            // ensure minimum sampling interval is not exceeded.
            if (datachangeItem.AttributeId == Attributes.Value)
            {
                BaseVariableState variable = handle.Node as BaseVariableState;

                if (variable != null && samplingInterval < variable.MinimumSamplingInterval)
                {
                    samplingInterval = variable.MinimumSamplingInterval;
                }
            }

            // put a large upper limit on sampling.
            if (samplingInterval == Double.MaxValue)
            {
                samplingInterval = 365 * 24 * 3600 * 1000.0;
            }

            // put an upper limit on queue size.
            uint queueSize = itemToModify.RequestedParameters.QueueSize;

            if (queueSize > m_maxQueueSize)
            {
                queueSize = m_maxQueueSize;
            }

            // validate the monitoring filter.
            Range euRange = null;
            MonitoringFilter filterToUse = null;

            ServiceResult error = ValidateMonitoringFilter(
                context,
                handle,
                datachangeItem.AttributeId,
                samplingInterval,
                queueSize,
                parameters.Filter,
                out filterToUse,
                out euRange,
                out filterResult);

            if (ServiceResult.IsBad(error))
            {
                return error;
            }

            // modify the monitored item parameters.
            error = datachangeItem.ModifyAttributes(
                diagnosticsMasks,
                timestampsToReturn,
                itemToModify.RequestedParameters.ClientHandle,
                filterToUse,
                filterToUse,
                euRange,
                samplingInterval,
                queueSize,
                itemToModify.RequestedParameters.DiscardOldest);

            // report change.
            if (ServiceResult.IsGood(error))
            {
                OnMonitoredItemModified(context, handle, datachangeItem);
            }

            return error;
        }

        /// <summary>
        /// Called after modifying a MonitoredItem.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The handle for the node.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        protected virtual void OnMonitoredItemModified(
            ServerSystemContext context,
            NodeHandle handle,
            MonitoredItem monitoredItem)
        {
            // overridden by the sub-class.
        }
        #endregion

        /// <summary>
        /// Deletes a set of monitored items.
        /// </summary>
        public virtual void DeleteMonitoredItems(
            OperationContext      context, 
            IList<IMonitoredItem> monitoredItems, 
            IList<bool>           processedItems, 
            IList<ServiceResult>  errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            List<IMonitoredItem> deletedItems = new List<IMonitoredItem>();

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    // skip items that have already been processed.
                    if (processedItems[ii] || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // check handle.
                    NodeHandle handle = IsHandleInNamespace(monitoredItems[ii].ManagerHandle);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    processedItems[ii] = true;

                    errors[ii] = DeleteMonitoredItem(
                        systemContext,
                        monitoredItems[ii],
                        handle);

                    // save the modified item.
                    if (ServiceResult.IsGood(errors[ii]))
                    {
                        deletedItems.Add(monitoredItems[ii]);
                        RemoveNodeFromComponentCache(systemContext, handle);
                    }
                }
            }

            // do any post processing.
            OnDeleteMonitoredItemsComplete(systemContext, deletedItems);
        }

        #region DeleteMonitoredItems Support Functions
        /// <summary>
        /// Called when a batch of monitored items has been modified.
        /// </summary>
        protected virtual void OnDeleteMonitoredItemsComplete(ServerSystemContext context, IList<IMonitoredItem> monitoredItems)
        {
            // defined by the sub-class
        }

        /// <summary>
        /// Deletes a monitored item.
        /// </summary>
        protected virtual ServiceResult DeleteMonitoredItem(
            ServerSystemContext context,
            IMonitoredItem monitoredItem,
            NodeHandle handle)
        {
            // check for valid monitored item.
            MonitoredItem datachangeItem = monitoredItem as MonitoredItem;

            // check if the node is already being monitored.
            MonitoredNode2 monitoredNode = null;

            if (m_monitoredNodes.TryGetValue(handle.NodeId, out monitoredNode))
            {
                monitoredNode.Remove(datachangeItem);

                // check if node is no longer being monitored.
                if (!monitoredNode.HasMonitoredItems)
                {
                    MonitoredNodes.Remove(handle.NodeId);
                }
            }

            // remove the monitored item.
            m_monitoredItems.Remove(monitoredItem.Id);

            // report change.
            OnMonitoredItemDeleted(context, handle, datachangeItem);

            return ServiceResult.Good;
        }

        /// <summary>
        /// Called after deleting a MonitoredItem.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The handle for the node.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        protected virtual void OnMonitoredItemDeleted(
            ServerSystemContext context,
            NodeHandle handle,
            MonitoredItem monitoredItem)
        {
            // overridden by the sub-class.
        }
        #endregion

        /// <summary>
        /// Changes the monitoring mode for a set of monitored items.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="monitoringMode">The monitoring mode.</param>
        /// <param name="monitoredItems">The set of monitoring items to update.</param>
        /// <param name="processedItems">Flags indicating which items have been processed.</param>
        /// <param name="errors">Any errors.</param>
        public virtual void SetMonitoringMode(
            OperationContext      context, 
            MonitoringMode        monitoringMode, 
            IList<IMonitoredItem> monitoredItems, 
            IList<bool>           processedItems, 
            IList<ServiceResult>  errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            List<IMonitoredItem> changedItems = new List<IMonitoredItem>();

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    // skip items that have already been processed.
                    if (processedItems[ii] || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // check handle.
                    NodeHandle handle = IsHandleInNamespace(monitoredItems[ii].ManagerHandle);

                    if (handle == null)
                    {
                        continue;
                    }

                    // indicate whether it was processed or not.
                    processedItems[ii] = true;

                    // update monitoring mode.
                    errors[ii] = SetMonitoringMode(
                        systemContext,
                        monitoredItems[ii],
                        monitoringMode,
                        handle);

                    // save the modified item.
                    if (ServiceResult.IsGood(errors[ii]))
                    {
                        changedItems.Add(monitoredItems[ii]);
                    }
                }
            }

            // do any post processing.
            OnSetMonitoringModeComplete(systemContext, changedItems);
        }

        #region SetMonitoringMode Support Functions
        /// <summary>
        /// Called when a batch of monitored items has their monitoring mode changed.
        /// </summary>
        protected virtual void OnSetMonitoringModeComplete(ServerSystemContext context, IList<IMonitoredItem> monitoredItems)
        {
            // defined by the sub-class
        }

        /// <summary>
        /// Changes the monitoring mode for an item.
        /// </summary>
        protected virtual ServiceResult SetMonitoringMode(
            ServerSystemContext context,
            IMonitoredItem monitoredItem,
            MonitoringMode monitoringMode,
            NodeHandle handle)
        {
            // check for valid monitored item.
            MonitoredItem datachangeItem = monitoredItem as MonitoredItem;

            // update monitoring mode.
            MonitoringMode previousMode = datachangeItem.SetMonitoringMode(monitoringMode);

            // must send the latest value after enabling a disabled item.
            if (monitoringMode == MonitoringMode.Reporting && previousMode == MonitoringMode.Disabled)
            {
                handle.MonitoredNode.QueueValue(context, handle.Node, datachangeItem);
            }

            // report change.
            if (previousMode != monitoringMode)
            {
                OnMonitoringModeChanged(
                    context,
                    handle,
                    datachangeItem,
                    previousMode,
                    monitoringMode);
            }

            return ServiceResult.Good;
        }

        /// <summary>
        /// Called after changing the MonitoringMode for a MonitoredItem.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The handle for the node.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        /// <param name="previousMode">The previous monitoring mode.</param>
        /// <param name="monitoringMode">The current monitoring mode.</param>
        protected virtual void OnMonitoringModeChanged(
            ServerSystemContext context,
            NodeHandle handle,
            MonitoredItem monitoredItem,
            MonitoringMode previousMode,
            MonitoringMode monitoringMode)
        {
            // overridden by the sub-class.
        }
        #endregion
        #endregion

        #region INodeManager2 Members
        /// <summary>
        /// Called when a session is closed.
        /// </summary>
        public virtual void SessionClosing(OperationContext context, NodeId sessionId, bool deleteSubscriptions)
        {
        }

        /// <summary>
        /// Returns true if a node is in a view.
        /// </summary>
        public virtual bool IsNodeInView(OperationContext context, NodeId viewId, object nodeHandle)
        {
            NodeHandle handle = nodeHandle as NodeHandle;

            if (handle == null)
            {
                return false;
            }

            if (handle.Node != null)
            {
                return IsNodeInView(context, viewId, handle.Node);
            }

            return false;
        }
        #endregion

        #region ComponentCache Functions
        /// <summary>
        /// Stores a reference count for entries in the component cache.
        /// </summary>
        private class CacheEntry
        {
            public int RefCount;
            public NodeState Entry;
        }

        /// <summary>
        /// Looks up a component in cache.
        /// </summary>
        protected NodeState LookupNodeInComponentCache(ISystemContext context, NodeHandle handle)
        {
            lock (Lock)
            {
                if (m_componentCache == null)
                {
                    return null;
                }

                CacheEntry entry = null;

                if (!String.IsNullOrEmpty(handle.ComponentPath))
                {
                    if (m_componentCache.TryGetValue(handle.RootId, out entry))
                    {
                        return entry.Entry.FindChildBySymbolicName(context, handle.ComponentPath);
                    }
                }
                else
                {
                    if (m_componentCache.TryGetValue(handle.NodeId, out entry))
                    {
                        return entry.Entry;
                    }
                }

                return null;
            }
        }

        /// <summary>
        /// Removes a reference to a component in thecache.
        /// </summary>
        protected void RemoveNodeFromComponentCache(ISystemContext context, NodeHandle handle)
        {
            lock (Lock)
            {
                if (handle == null)
                {
                    return;
                }

                if (m_componentCache != null)
                {
                    NodeId nodeId = handle.NodeId;

                    if (!String.IsNullOrEmpty(handle.ComponentPath))
                    {
                        nodeId = handle.RootId;
                    }

                    CacheEntry entry = null;

                    if (m_componentCache.TryGetValue(nodeId, out entry))
                    {
                        entry.RefCount--;

                        if (entry.RefCount == 0)
                        {
                            m_componentCache.Remove(nodeId);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Adds a node to the component cache.
        /// </summary>
        protected NodeState AddNodeToComponentCache(ISystemContext context, NodeHandle handle, NodeState node)
        {
            lock (Lock)
            {
                if (handle == null)
                {
                    return node;
                }

                if (m_componentCache == null)
                {
                    m_componentCache = new Dictionary<NodeId, CacheEntry>();
                }

                // check if a component is actually specified.
                if (!String.IsNullOrEmpty(handle.ComponentPath))
                {
                    CacheEntry entry = null;

                    if (m_componentCache.TryGetValue(handle.RootId, out entry))
                    {
                        entry.RefCount++;

                        if (!String.IsNullOrEmpty(handle.ComponentPath))
                        {
                            return entry.Entry.FindChildBySymbolicName(context, handle.ComponentPath);
                        }

                        return entry.Entry;
                    }

                    NodeState root = node.GetHierarchyRoot();

                    if (root != null)
                    {
                        entry = new CacheEntry();
                        entry.RefCount = 1;
                        entry.Entry = root;
                        m_componentCache.Add(handle.RootId, entry);
                    }
                }

                // simply add the node to the cache.
                else
                {
                    CacheEntry entry = null;

                    if (m_componentCache.TryGetValue(handle.NodeId, out entry))
                    {
                        entry.RefCount++;
                        return entry.Entry;
                    }

                    entry = new CacheEntry();
                    entry.RefCount = 1;
                    entry.Entry = node;
                    m_componentCache.Add(handle.NodeId, entry);
                }

                return node;
            }
        }
        #endregion

        #region Private Fields
        private object m_lock = new object();
        private IServerInternal m_server;
        private ServerSystemContext m_systemContext;
        private string[] m_namespaceUris;
        private ushort[] m_namespaceIndexes;
        private Dictionary<uint, IDataChangeMonitoredItem> m_monitoredItems;
        private Dictionary<NodeId, MonitoredNode2> m_monitoredNodes;
        private Dictionary<NodeId, CacheEntry> m_componentCache;
        private NodeIdDictionary<NodeState> m_predefinedNodes;
        private List<NodeState> m_rootNotifiers;
        private uint m_maxQueueSize;
        private string m_aliasRoot;
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Text;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;
using Opc.Ua;
using Opc.Ua.Server;

namespace Opc.Ua.Server
{
    /// <summary>
    /// A sample implementation of the INodeManager interface.
    /// </summary>
    /// <remarks>
    /// This node manager is a base class used in multiple samples. It implements the INodeManager
    /// interface and allows sub-classes to override only the methods that they need. This example
    /// is not part of the SDK because most real implementations of a INodeManager will need to
    /// modify the behavior of the base class.
    /// </remarks>
    public class CustomNodeManager2 : INodeManager2, INodeIdFactory, IDisposable
    {
        #region Constructors
        /// <summary>
        /// Initializes the node manager.
        /// </summary>
        protected CustomNodeManager2(
            IServerInternal server,
            params string[] namespaceUris)
        :
            this(server, (ApplicationConfiguration)null, namespaceUris)
        {
        }

        /// <summary>
        /// Initializes the node manager.
        /// </summary>
        protected CustomNodeManager2(
            IServerInternal server,
            ApplicationConfiguration configuration,
            params string[] namespaceUris)
        {
            // set defaults.
            m_maxQueueSize = 1000;

            if (configuration != null)
            {
                if (configuration.ServerConfiguration != null)
                {
                    m_maxQueueSize = (uint)configuration.ServerConfiguration.MaxNotificationQueueSize;
                }
            }

            // save a reference to the UA server instance that owns the node manager.
            m_server = server;

            // all operations require information about the system 
            m_systemContext = m_server.DefaultSystemContext.Copy();

            // the node id factory assigns new node ids to new nodes. 
            // the strategy used by a NodeManager depends on what kind of information it provides.
            m_systemContext.NodeIdFactory = this;

            // create the table of namespaces that are used by the NodeManager.
            m_namespaceUris = namespaceUris;

            // add the uris to the server's namespace table and cache the indexes.
            if (namespaceUris != null)
            {
                m_namespaceIndexes = new ushort[m_namespaceUris.Length];

                for (int ii = 0; ii < m_namespaceUris.Length; ii++)
                {
                    m_namespaceIndexes[ii] = m_server.NamespaceUris.GetIndexOrAppend(m_namespaceUris[ii]);
                }
            }

            // create the table of monitored items.
            // these are items created by clients when they subscribe to data or events.
            m_monitoredItems = new Dictionary<uint, IDataChangeMonitoredItem>();

            // create the table of monitored nodes.
            // these are created by the node manager whenever a client subscribe to an attribute of the node.
            m_monitoredNodes = new Dictionary<NodeId, MonitoredNode2>();
        }
        #endregion

        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                lock (m_lock)
                {
                    if (m_predefinedNodes != null)
                    {
                        foreach (NodeState node in m_predefinedNodes.Values)
                        {
                            Utils.SilentDispose(node);
                        }

                        m_predefinedNodes.Clear();
                    }
                }
            }
        }
        #endregion

        #region INodeIdFactory Members
        /// <summary>
        /// Creates the NodeId for the specified node.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="node">The node.</param>
        /// <returns>The new NodeId.</returns>
        public virtual NodeId New(ISystemContext context, NodeState node)
        {
            return node.NodeId;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Acquires the lock on the node manager.
        /// </summary>
        public object Lock
        {
            get { return m_lock; }
        }

        /// <summary>
        /// Gets the server that the node manager belongs to.
        /// </summary>
        public IServerInternal Server
        {
            get { return m_server; }
        }

        /// <summary>
        /// The default context to use.
        /// </summary>
        public ServerSystemContext SystemContext
        {
            get { return m_systemContext; }
        }

        /// <summary>
        /// Gets the default index for the node manager's namespace.
        /// </summary>
        public ushort NamespaceIndex
        {
            get { return m_namespaceIndexes[0]; }
        }

        /// <summary>
        /// Gets the namespace indexes owned by the node manager.
        /// </summary>
        /// <value>The namespace indexes.</value>
        public ushort[] NamespaceIndexes
        {
            get { return m_namespaceIndexes; }
        }

        /// <summary>
        /// Gets or sets the maximum size of a monitored item queue.
        /// </summary>
        /// <value>The maximum size of a monitored item queue.</value>
        public uint MaxQueueSize
        {
            get { return m_maxQueueSize; }
            set { m_maxQueueSize = value; }
        }

        /// <summary>
        /// The root for the alias assigned to the node manager.
        /// </summary>
        public string AliasRoot
        {
            get { return m_aliasRoot; }
            set { m_aliasRoot = value; }
        }
        #endregion

        #region Protected Members
        /// <summary>
        /// The predefined nodes managed by the node manager.
        /// </summary>
        protected NodeIdDictionary<NodeState> PredefinedNodes
        {
            get { return m_predefinedNodes; }
        }

        /// <summary>
        /// The root notifiers for the node manager.
        /// </summary>
        protected List<NodeState> RootNotifiers
        {
            get { return m_rootNotifiers; }
        }

        /// <summary>
        /// Gets the table of monitored items.
        /// </summary>
        protected Dictionary<uint, IDataChangeMonitoredItem> MonitoredItems
        {
            get { return m_monitoredItems; }
        }

        /// <summary>
        /// Gets the table of nodes being monitored.
        /// </summary>
        protected Dictionary<NodeId, MonitoredNode2> MonitoredNodes
        {
            get { return m_monitoredNodes; }
        }

        /// <summary>
        /// Sets the namespaces supported by the NodeManager.
        /// </summary>
        /// <param name="namespaceUris">The namespace uris.</param>
        protected void SetNamespaces(params string[] namespaceUris)
        {
            // create the table of namespaces that are used by the NodeManager.
            m_namespaceUris = namespaceUris;

            // add the uris to the server's namespace table and cache the indexes.
            m_namespaceIndexes = new ushort[m_namespaceUris.Length];

            for (int ii = 0; ii < m_namespaceUris.Length; ii++)
            {
                m_namespaceIndexes[ii] = m_server.NamespaceUris.GetIndexOrAppend(m_namespaceUris[ii]);
            }
        }

        /// <summary>
        /// Sets the namespace indexes supported by the NodeManager.
        /// </summary>
        protected void SetNamespaceIndexes(ushort[] namespaceIndexes)
        {
            m_namespaceIndexes = namespaceIndexes;
            m_namespaceUris = new string[namespaceIndexes.Length];

            for (int ii = 0; ii < namespaceIndexes.Length; ii++)
            {
                m_namespaceUris[ii] = m_server.NamespaceUris.GetString(namespaceIndexes[ii]);
            }
        }

        /// <summary>
        /// Returns true if the namespace for the node id is one of the namespaces managed by the node manager.
        /// </summary>
        /// <param name="nodeId">The node id to check.</param>
        /// <returns>True if the namespace is one of the nodes.</returns>
        protected virtual bool IsNodeIdInNamespace(NodeId nodeId)
        {
            // nulls are never a valid node.
            if (NodeId.IsNull(nodeId))
            {
                return false;
            }

            // quickly exclude nodes that not in the namespace.
            for (int ii = 0; ii < m_namespaceIndexes.Length; ii++)
            {
                if (nodeId.NamespaceIndex == m_namespaceIndexes[ii])
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Returns the node if the handle refers to a node managed by this manager.
        /// </summary>
        /// <param name="managerHandle">The handle to check.</param>
        /// <returns>Non-null if the handle belongs to the node manager.</returns>
        protected virtual NodeHandle IsHandleInNamespace(object managerHandle)
        {
            NodeHandle source = managerHandle as NodeHandle;

            if (source == null)
            {
                return null;
            }

            if (!IsNodeIdInNamespace(source.NodeId))
            {
                return null;
            }

            return source;
        }

        /// <summary>
        /// Returns the state object for the specified node if it exists.
        /// </summary>
        public NodeState Find(NodeId nodeId)
        {
            lock (Lock)
            {
                if (PredefinedNodes == null)
                {
                    return null;
                }

                NodeState node = null;

                if (!PredefinedNodes.TryGetValue(nodeId, out node))
                {
                    return null;
                }

                return node;
            }
        }

        /// <summary>
        /// Creates a new instance and assigns unique identifiers to all children.
        /// </summary>
        /// <param name="context">The operation context.</param>
        /// <param name="parentId">An optional parent identifier.</param>
        /// <param name="referenceTypeId">The reference type from the parent.</param>
        /// <param name="browseName">The browse name.</param>
        /// <param name="instance">The instance to create.</param>
        /// <returns>The new node id.</returns>
        public NodeId CreateNode(
            ServerSystemContext context,
            NodeId parentId,
            NodeId referenceTypeId,
            QualifiedName browseName,
            BaseInstanceState instance)
        {
            ServerSystemContext contextToUse = (ServerSystemContext)m_systemContext.Copy(context);

            lock (Lock)
            {
                if (m_predefinedNodes == null)
                {
                    m_predefinedNodes = new NodeIdDictionary<NodeState>();
                }

                instance.ReferenceTypeId = referenceTypeId;

                NodeState parent = null;

                if (parentId != null)
                {
                    if (!m_predefinedNodes.TryGetValue(parentId, out parent))
                    {
                        throw ServiceResultException.Create(
                            StatusCodes.BadNodeIdUnknown,
                            "Cannot find parent with id: {0}",
                            parentId);
                    }

                    parent.AddChild(instance);
                }

                instance.Create(contextToUse, null, browseName, null, true);
                AddPredefinedNode(contextToUse, instance);

                return instance.NodeId;
            }
        }

        /// <summary>
        /// Deletes a node and all of its children.
        /// </summary>
        public bool DeleteNode(
            ServerSystemContext context,
            NodeId nodeId)
        {
            ServerSystemContext contextToUse = m_systemContext.Copy(context);

            bool found = false;
            List<LocalReference> referencesToRemove = new List<LocalReference>();

            lock (Lock)
            {
                if (m_predefinedNodes == null)
                {
                    return false;
                }

                NodeState node = null;

                if (PredefinedNodes.TryGetValue(nodeId, out node))
                {
                    RemovePredefinedNode(contextToUse, node, referencesToRemove);
                    found = true;
                }

                RemoveRootNotifier(node);
            }

            // must release the lock before removing cross references to other node managers.
            if (referencesToRemove.Count > 0)
            {
                Server.NodeManager.RemoveReferences(referencesToRemove);
            }

            return found;
        }

        /// <summary>
        /// Searches the node id in all node managers 
        /// </summary>
        /// <param name="nodeId"></param>
        /// <returns></returns>
        public NodeState FindNodeInAddressSpace(NodeId nodeId)
        {
            if (nodeId == null)
            {
                return null;
            }
            // search node id in all node managers
            foreach (INodeManager nodeManager in Server.NodeManager.NodeManagers)
            {
                NodeHandle handle = nodeManager.GetManagerHandle(nodeId) as NodeHandle;
                if (handle == null)
                {
                    continue;
                }
                return handle.Node;
            }
            return null;
        }
        #endregion

        #region INodeManager Members
        /// <summary>
        /// Returns the namespaces used by the node manager.
        /// </summary>
        /// <remarks>
        /// All NodeIds exposed by the node manager must be qualified by a namespace URI. This property
        /// returns the URIs used by the node manager. In this example all NodeIds use a single URI.
        /// </remarks>
        public virtual IEnumerable<string> NamespaceUris
        {
            get
            {
                return m_namespaceUris;
            }

            protected set
            {
                if (value == null) throw new ArgumentNullException(nameof(value));
                List<string> namespaceUris = new List<string>(value);
                SetNamespaces(namespaceUris.ToArray());
            }
        }

        /// <summary>
        /// Does any initialization required before the address space can be used.
        /// </summary>
        /// <remarks>
        /// The externalReferences is an out parameter that allows the node manager to link to nodes
        /// in other node managers. For example, the 'Objects' node is managed by the CoreNodeManager and
        /// should have a reference to the root folder node(s) exposed by this node manager.  
        /// </remarks>
        public virtual void CreateAddressSpace(IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            LoadPredefinedNodes(m_systemContext, externalReferences);
        }

        #region CreateAddressSpace Support Functions
        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        public virtual void LoadPredefinedNodes(
            ISystemContext context,
            Assembly assembly,
            string resourcePath,
            IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            if (m_predefinedNodes == null)
            {
                m_predefinedNodes = new NodeIdDictionary<NodeState>();
            }

            // load the predefined nodes from an XML document.
            NodeStateCollection predefinedNodes = new NodeStateCollection();
            predefinedNodes.LoadFromResource(context, resourcePath, assembly, true);

            // add the predefined nodes to the node manager.
            for (int ii = 0; ii < predefinedNodes.Count; ii++)
            {
                AddPredefinedNode(context, predefinedNodes[ii]);
            }

            // ensure the reverse references exist.
            AddReverseReferences(externalReferences);
        }

        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        protected virtual NodeStateCollection LoadPredefinedNodes(ISystemContext context)
        {
            return new NodeStateCollection();
        }

        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        protected virtual void LoadPredefinedNodes(
            ISystemContext context,
            IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            // load the predefined nodes from an XML document.
            NodeStateCollection predefinedNodes = LoadPredefinedNodes(context);

            // add the predefined nodes to the node manager.
            for (int ii = 0; ii < predefinedNodes.Count; ii++)
            {
                AddPredefinedNode(context, predefinedNodes[ii]);
            }

            // ensure the reverse references exist.
            AddReverseReferences(externalReferences);
        }

        /// <summary>
        /// Replaces the generic node with a node specific to the model.
        /// </summary>
        protected virtual NodeState AddBehaviourToPredefinedNode(ISystemContext context, NodeState predefinedNode)
        {
            BaseObjectState passiveNode = predefinedNode as BaseObjectState;

            if (passiveNode == null)
            {
                return predefinedNode;
            }

            return predefinedNode;
        }

        /// <summary>
        /// Recursively indexes the node and its children.
        /// </summary>
        protected virtual void AddPredefinedNode(ISystemContext context, NodeState node)
        {
            if (m_predefinedNodes == null)
            {
                m_predefinedNodes = new NodeIdDictionary<NodeState>();
            }

            NodeState activeNode = AddBehaviourToPredefinedNode(context, node);
            m_predefinedNodes[activeNode.NodeId] = activeNode;

            if (activeNode is BaseTypeState type)
            {
                AddTypesToTypeTree(type);
            }

            // update the root notifiers.
            if (m_rootNotifiers != null)
            {
                for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
                {
                    if (m_rootNotifiers[ii].NodeId == activeNode.NodeId)
                    {
                        m_rootNotifiers[ii] = activeNode;

                        // need to prevent recursion with the server object.
                        if (activeNode.NodeId != ObjectIds.Server)
                        {
                            activeNode.OnReportEvent = OnReportEvent;

                            if (!activeNode.ReferenceExists(ReferenceTypeIds.HasNotifier, true, ObjectIds.Server))
                            {
                                activeNode.AddReference(ReferenceTypeIds.HasNotifier, true, ObjectIds.Server);
                            }
                        }

                        break;
                    }
                }
            }

            List<BaseInstanceState> children = new List<BaseInstanceState>();
            activeNode.GetChildren(context, children);

            for (int ii = 0; ii < children.Count; ii++)
            {
                AddPredefinedNode(context, children[ii]);
            }
        }

        /// <summary>
        /// Recursively indexes the node and its children.
        /// </summary>
        protected virtual void RemovePredefinedNode(
            ISystemContext context,
            NodeState node,
            List<LocalReference> referencesToRemove)
        {
            if (m_predefinedNodes == null)
            {
                return;
            }

            m_predefinedNodes.Remove(node.NodeId);
            node.UpdateChangeMasks(NodeStateChangeMasks.Deleted);
            node.ClearChangeMasks(context, false);
            OnNodeRemoved(node);

            // remove from the parent.
            BaseInstanceState instance = node as BaseInstanceState;

            if (instance?.Parent != null)
            {
                instance.Parent.RemoveChild(instance);
            }

            // remove children.
            List<BaseInstanceState> children = new List<BaseInstanceState>();
            node.GetChildren(context, children);

            for (int ii = 0; ii < children.Count; ii++)
            {
                node.RemoveChild(children[ii]);
            }

            for (int ii = 0; ii < children.Count; ii++)
            {
                RemovePredefinedNode(context, children[ii], referencesToRemove);
            }

            // remove from type table.

            if (node is BaseTypeState type)
            {
                m_server.TypeTree.Remove(type.NodeId);
            }

            // remove inverse references.
            List<IReference> references = new List<IReference>();
            node.GetReferences(context, references);

            for (int ii = 0; ii < references.Count; ii++)
            {
                IReference reference = references[ii];

                if (reference.TargetId.IsAbsolute)
                {
                    continue;
                }

                LocalReference referenceToRemove = new LocalReference(
                    (NodeId)reference.TargetId,
                    reference.ReferenceTypeId,
                    reference.IsInverse,
                    node.NodeId);

                referencesToRemove.Add(referenceToRemove);
            }
        }

        /// <summary>
        /// Called after a node has been deleted.
        /// </summary>
        protected virtual void OnNodeRemoved(NodeState node)
        {
            // overridden by the sub-class.            
        }

        /// <summary>
        /// Ensures that all reverse references exist.
        /// </summary>
        /// <param name="externalReferences">A list of references to add to external targets.</param>
        protected virtual void AddReverseReferences(IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            if (m_predefinedNodes == null)
            {
                return;
            }

            foreach (NodeState source in m_predefinedNodes.Values)
            {
                // assign a default value to any variable value.

                if (source is BaseVariableState variable && variable.Value == null)
                {
                    variable.Value = TypeInfo.GetDefaultValue(variable.DataType, variable.ValueRank, Server.TypeTree);
                }

                IList<IReference> references = new List<IReference>();
                source.GetReferences(SystemContext, references);

                for (int ii = 0; ii < references.Count; ii++)
                {
                    IReference reference = references[ii];

                    // nothing to do with external nodes.
                    if (reference.TargetId == null || reference.TargetId.IsAbsolute)
                    {
                        continue;
                    }

                    // no need to add HasSubtype references since these are handled via the type table.
                    if (reference.ReferenceTypeId == ReferenceTypeIds.HasSubtype)
                    {
                        continue;
                    }

                    NodeId targetId = (NodeId)reference.TargetId;

                    // check for data type encoding references.
                    if (reference.IsInverse && reference.ReferenceTypeId == ReferenceTypeIds.HasEncoding)
                    {
                        Server.TypeTree.AddEncoding(targetId, source.NodeId);
                    }

                    // add inverse reference to internal targets.
                    NodeState target = null;

                    if (m_predefinedNodes.TryGetValue(targetId, out target))
                    {
                        if (!target.ReferenceExists(reference.ReferenceTypeId, !reference.IsInverse, source.NodeId))
                        {
                            target.AddReference(reference.ReferenceTypeId, !reference.IsInverse, source.NodeId);
                        }

                        continue;
                    }

                    // check for inverse references to external notifiers.
                    if (reference.IsInverse && reference.ReferenceTypeId == ReferenceTypeIds.HasNotifier)
                    {
                        AddRootNotifier(source);
                    }

                    // nothing more to do for references to nodes managed by this manager.
                    if (IsNodeIdInNamespace(targetId))
                    {
                        continue;
                    }

                    // add external reference.
                    AddExternalReference(
                        targetId,
                        reference.ReferenceTypeId,
                        !reference.IsInverse,
                        source.NodeId,
                        externalReferences);
                }
            }
        }

        /// <summary>
        /// Adds an external reference to the dictionary.
        /// </summary>
        protected void AddExternalReference(
            NodeId sourceId,
            NodeId referenceTypeId,
            bool isInverse,
            NodeId targetId,
            IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            // get list of references to external nodes.
            IList<IReference> referencesToAdd = null;

            if (!externalReferences.TryGetValue(sourceId, out referencesToAdd))
            {
                externalReferences[sourceId] = referencesToAdd = new List<IReference>();
            }

            // add reserve reference from external node.
            ReferenceNode referenceToAdd = new ReferenceNode();

            referenceToAdd.ReferenceTypeId = referenceTypeId;
            referenceToAdd.IsInverse = isInverse;
            referenceToAdd.TargetId = targetId;

            referencesToAdd.Add(referenceToAdd);
        }

        /// <summary>
        /// Recursively adds the types to the type tree.
        /// </summary>
        protected void AddTypesToTypeTree(BaseTypeState type)
        {
            if (!NodeId.IsNull(type.SuperTypeId))
            {
                if (!Server.TypeTree.IsKnown(type.SuperTypeId))
                {
                    AddTypesToTypeTree(type.SuperTypeId);
                }
            }

            if (type.NodeClass != NodeClass.ReferenceType)
            {
                Server.TypeTree.AddSubtype(type.NodeId, type.SuperTypeId);
            }
            else
            {
                Server.TypeTree.AddReferenceSubtype(type.NodeId, type.SuperTypeId, type.BrowseName);
            }
        }

        /// <summary>
        /// Recursively adds the types to the type tree.
        /// </summary>
        protected void AddTypesToTypeTree(NodeId typeId)
        {
            NodeState node = null;

            if (!PredefinedNodes.TryGetValue(typeId, out node))
            {
                return;
            }

            BaseTypeState type = node as BaseTypeState;

            if (type == null)
            {
                return;
            }

            AddTypesToTypeTree(type);
        }

        /// <summary>
        /// Finds the specified and checks if it is of the expected type. 
        /// </summary>
        /// <returns>Returns null if not found or not of the correct type.</returns>
        public NodeState FindPredefinedNode(NodeId nodeId, Type expectedType)
        {
            if (nodeId == null)
            {
                return null;
            }

            NodeState node = null;

            if (!PredefinedNodes.TryGetValue(nodeId, out node))
            {
                return null;
            }

            if (expectedType != null)
            {
                if (!expectedType.IsInstanceOfType(node))
                {
                    return null;
                }
            }

            return node;
        }
        #endregion

        /// <summary>
        /// Frees any resources allocated for the address space.
        /// </summary>
        public virtual void DeleteAddressSpace()
        {
            lock (m_lock)
            {
                if (m_predefinedNodes != null)
                {
                    foreach (NodeState node in m_predefinedNodes.Values)
                    {
                        Utils.SilentDispose(node);
                    }

                    m_predefinedNodes.Clear();
                }
            }
        }

        /// <summary>
        /// Returns a unique handle for the node.
        /// </summary>
        /// <remarks>
        /// This must efficiently determine whether the node belongs to the node manager. If it does belong to 
        /// NodeManager it should return a handle that does not require the NodeId to be validated again when
        /// the handle is passed into other methods such as 'Read' or 'Write'.
        /// </remarks>
        public virtual object GetManagerHandle(NodeId nodeId)
        {
            lock (Lock)
            {
                return GetManagerHandle(m_systemContext, nodeId, null);
            }
        }

        /// <summary>
        /// Returns a unique handle for the node.
        /// </summary>
        protected virtual NodeHandle GetManagerHandle(ServerSystemContext context, NodeId nodeId, IDictionary<NodeId, NodeState> cache)
        {
            if (!IsNodeIdInNamespace(nodeId))
            {
                return null;
            }

            if (m_predefinedNodes != null)
            {
                NodeState node = null;

                if (m_predefinedNodes.TryGetValue(nodeId, out node))
                {
                    NodeHandle handle = new NodeHandle();

                    handle.NodeId = nodeId;
                    handle.Node = node;
                    handle.Validated = true;

                    return handle;
                }
            }

            return null;
        }

        /// <summary>
        /// This method is used to add bi-directional references to nodes from other node managers.
        /// </summary>
        /// <remarks>
        /// The additional references are optional, however, the NodeManager should support them.
        /// </remarks>
        public virtual void AddReferences(IDictionary<NodeId, IList<IReference>> references)
        {
            lock (Lock)
            {
                foreach (KeyValuePair<NodeId, IList<IReference>> current in references)
                {
                    // get the handle.
                    NodeHandle source = GetManagerHandle(m_systemContext, current.Key, null);

                    // only support external references to nodes that are stored in memory.
                    if (source == null || !source.Validated || source.Node == null)
                    {
                        continue;
                    }

                    // add reference to external target.
                    foreach (IReference reference in current.Value)
                    {
                        if (!source.Node.ReferenceExists(reference.ReferenceTypeId, reference.IsInverse, reference.TargetId))
                        {
                            source.Node.AddReference(reference.ReferenceTypeId, reference.IsInverse, reference.TargetId);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// This method is used to delete bi-directional references to nodes from other node managers.
        /// </summary>
        public virtual ServiceResult DeleteReference(
            object         sourceHandle, 
            NodeId         referenceTypeId, 
            bool           isInverse, 
            ExpandedNodeId targetId, 
            bool           deleteBiDirectional)
        {
            lock (Lock)
            {
                // get the handle.
                NodeHandle source = IsHandleInNamespace(sourceHandle);

                if (source == null)
                {
                    return StatusCodes.BadNodeIdUnknown;
                }

                // only support external references to nodes that are stored in memory.
                if (!source.Validated || source.Node == null)
                {
                    return StatusCodes.BadNotSupported;
                }

                // only support references to Source Areas.
                source.Node.RemoveReference(referenceTypeId, isInverse, targetId);

                if (deleteBiDirectional)
                {
                    // check if the target is also managed by this node manager.
                    if (!targetId.IsAbsolute)
                    {
                        NodeHandle target = GetManagerHandle(m_systemContext, (NodeId)targetId, null);

                        if (target != null && target.Validated && target.Node != null)
                        {
                            target.Node.RemoveReference(referenceTypeId, !isInverse, source.NodeId);
                        }
                    }
                }

                return ServiceResult.Good;
            }
        }

        /// <summary>
        /// Returns the basic metadata for the node. Returns null if the node does not exist.
        /// </summary>
        /// <remarks>
        /// This method validates any placeholder handle.
        /// </remarks>
        public virtual NodeMetadata GetNodeMetadata(
            OperationContext context, 
            object           targetHandle, 
            BrowseResultMask resultMask)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                // check for valid handle.
                NodeHandle handle = IsHandleInNamespace(targetHandle);

                if (handle == null)
                {
                    return null;
                }

                // validate node.
                NodeState target = ValidateNode(systemContext, handle, null);

                if (target == null)
                {
                    return null;
                }

                // read the attributes.
                List<object> values = target.ReadAttributes(
                    systemContext,
                    Attributes.WriteMask,
                    Attributes.UserWriteMask,
                    Attributes.DataType,
                    Attributes.ValueRank,
                    Attributes.ArrayDimensions,
                    Attributes.AccessLevel,
                    Attributes.UserAccessLevel,
                    Attributes.EventNotifier,
                    Attributes.Executable,
                    Attributes.UserExecutable,
                    Attributes.AccessRestrictions,
                    Attributes.RolePermissions,
                    Attributes.UserRolePermissions);

                // construct the meta-data object.
                NodeMetadata metadata = new NodeMetadata(target, target.NodeId);

                metadata.NodeClass = target.NodeClass;
                metadata.BrowseName = target.BrowseName;
                metadata.DisplayName = target.DisplayName;

                if (values[0] != null && values[1] != null)
                {
                    metadata.WriteMask = (AttributeWriteMask)(((uint)values[0]) & ((uint)values[1]));
                }

                metadata.DataType = (NodeId)values[2];

                if (values[3] != null)
                {
                    metadata.ValueRank = (int)values[3];
                }

                metadata.ArrayDimensions = (IList<uint>)values[4];

                if (values[5] != null && values[6] != null)
                {
                    metadata.AccessLevel = (byte)(((byte)values[5]) & ((byte)values[6]));
                }

                if (values[7] != null)
                {
                    metadata.EventNotifier = (byte)values[7];
                }

                if (values[8] != null && values[9] != null)
                {
                    metadata.Executable = (((bool)values[8]) && ((bool)values[9]));
                }

                if (values[10] != null)
                {
                    metadata.AccessRestrictions = (AccessRestrictionType)Enum.ToObject(typeof(AccessRestrictionType), values[10]);
                }

                if (values[11] != null)
                {
                    metadata.RolePermissions = new RolePermissionTypeCollection(ExtensionObject.ToList<RolePermissionType>(values[11]));
                }

                if (values[12] != null)
                {
                    metadata.UserRolePermissions = new RolePermissionTypeCollection(ExtensionObject.ToList<RolePermissionType>(values[12]));
                }

                // check if NamespaceMetadata is defined for NamespaceUri
                string namespaceUri = Server.NamespaceUris.GetString(target.NodeId.NamespaceIndex);
                NamespaceMetadataState namespaceMetadataState = Server.NodeManager.ConfigurationNodeManager.GetNamespaceMetadataState(namespaceUri);

                if (namespaceMetadataState != null)
                {
                    List<object> namespaceMetadataValues;

                    if (namespaceMetadataState.DefaultAccessRestrictions != null)
                    {
                        // get DefaultAccessRestrictions for Namespace
                        namespaceMetadataValues = namespaceMetadataState.DefaultAccessRestrictions.ReadAttributes(systemContext, Attributes.Value);

                        if (namespaceMetadataValues[0] != null)
                        {
                            metadata.DefaultAccessRestrictions = (AccessRestrictionType)Enum.ToObject(typeof(AccessRestrictionType), namespaceMetadataValues[0]);
                        }
                    }

                    if (namespaceMetadataState.DefaultRolePermissions != null)
                    {
                        // get DefaultRolePermissions for Namespace
                        namespaceMetadataValues = namespaceMetadataState.DefaultRolePermissions.ReadAttributes(systemContext, Attributes.Value);

                        if (namespaceMetadataValues[0] != null)
                        {
                            metadata.DefaultRolePermissions = new RolePermissionTypeCollection(ExtensionObject.ToList<RolePermissionType>(namespaceMetadataValues[0]));
                        }
                    }

                    if (namespaceMetadataState.DefaultUserRolePermissions != null)
                    {
                        // get DefaultUserRolePermissions for Namespace
                        namespaceMetadataValues = namespaceMetadataState.DefaultUserRolePermissions.ReadAttributes(systemContext, Attributes.Value);

                        if (namespaceMetadataValues[0] != null)
                        {
                            metadata.DefaultUserRolePermissions = new RolePermissionTypeCollection(ExtensionObject.ToList<RolePermissionType>(namespaceMetadataValues[0]));
                        }
                    }
                }

                // get instance references.

                if (target is BaseInstanceState instance)
                {
                    metadata.TypeDefinition = instance.TypeDefinitionId;
                    metadata.ModellingRule = instance.ModellingRuleId;
                }

                // fill in the common attributes.
                return metadata;
            }
        }

        /// <summary>
        /// Browses the references from a node managed by the node manager.
        /// </summary>
        /// <remarks>
        /// The continuation point is created for every browse operation and contains the browse parameters.
        /// The node manager can store its state information in the Data and Index properties.
        /// </remarks>
        public virtual void Browse(
            OperationContext            context, 
            ref ContinuationPoint       continuationPoint, 
            IList<ReferenceDescription> references)
        {
            if (continuationPoint == null) throw new ArgumentNullException(nameof(continuationPoint));
            if (references == null) throw new ArgumentNullException(nameof(references));

            ServerSystemContext systemContext = m_systemContext.Copy(context);

            // check for valid view.
            ValidateViewDescription(systemContext, continuationPoint.View);

            INodeBrowser browser = null;

            lock (Lock)
            {
                // check for valid handle.
                NodeHandle handle = IsHandleInNamespace(continuationPoint.NodeToBrowse);

                if (handle == null)
                {
                    throw new ServiceResultException(StatusCodes.BadNodeIdUnknown);
                }

                // validate node.
                NodeState source = ValidateNode(systemContext, handle, null);

                if (source == null)
                {
                    throw new ServiceResultException(StatusCodes.BadNodeIdUnknown);
                }

                // check if node is in the view.
                if (!IsNodeInView(systemContext, continuationPoint, source))
                {
                    throw new ServiceResultException(StatusCodes.BadNodeNotInView);
                }

                // check for previous continuation point.
                browser = continuationPoint.Data as INodeBrowser;

                // fetch list of references.
                if (browser == null)
                {
                    // create a new browser.
                    continuationPoint.Data = browser = source.CreateBrowser(
                        systemContext,
                        continuationPoint.View,
                        continuationPoint.ReferenceTypeId,
                        continuationPoint.IncludeSubtypes,
                        continuationPoint.BrowseDirection,
                        null,
                        null,
                        false);
                }
            }
            // prevent multiple access the browser object.
            lock (browser)
            {
                // apply filters to references.
                Dictionary<NodeId, NodeState> cache = new Dictionary<NodeId, NodeState>();

                for (IReference reference = browser.Next(); reference != null; reference = browser.Next())
                {
                    // validate Browse permission
                    ServiceResult serviceResult = ValidateRolePermissions(context,
                        ExpandedNodeId.ToNodeId(reference.TargetId, Server.NamespaceUris),
                        PermissionType.Browse);
                    if (ServiceResult.IsBad(serviceResult))
                    {
                        // ignore reference
                        continue;
                    }
                    // create the type definition reference.        
                    ReferenceDescription description = GetReferenceDescription(systemContext, cache, reference, continuationPoint);

                    if (description == null)
                    {
                        continue;
                    }

                    // check if limit reached.
                    if (continuationPoint.MaxResultsToReturn != 0 && references.Count >= continuationPoint.MaxResultsToReturn)
                    {
                        browser.Push(reference);
                        return;
                    }

                    references.Add(description);
                }

                // release the continuation point if all done.
                continuationPoint.Dispose();
                continuationPoint = null;
            }
        }

        #region Browse Support Functions
        /// <summary>
        /// Validates the view description passed to a browse request (throws on error).
        /// </summary>
        protected virtual void ValidateViewDescription(ServerSystemContext context, ViewDescription view)
        {
            if (ViewDescription.IsDefault(view))
            {
                return;
            }

            ViewState node = (ViewState)FindPredefinedNode(view.ViewId, typeof(ViewState));

            if (node == null)
            {
                throw new ServiceResultException(StatusCodes.BadViewIdUnknown);
            }

            if (view.Timestamp != DateTime.MinValue)
            {
                throw new ServiceResultException(StatusCodes.BadViewTimestampInvalid);
            }

            if (view.ViewVersion != 0)
            {
                throw new ServiceResultException(StatusCodes.BadViewVersionInvalid);
            }
        }

        /// <summary>
        /// Checks if the node is in the view.
        /// </summary>
        protected virtual bool IsNodeInView(ServerSystemContext context, ContinuationPoint continuationPoint, NodeState node)
        {
            if (continuationPoint == null || ViewDescription.IsDefault(continuationPoint.View))
            {
                return true;
            }

            return IsNodeInView(context, continuationPoint.View.ViewId, node);
        }

        /// <summary>
        /// Checks if the node is in the view.
        /// </summary>
        protected virtual bool IsNodeInView(ServerSystemContext context, NodeId viewId, NodeState node)
        {
            ViewState view = (ViewState)FindPredefinedNode(viewId, typeof(ViewState));

            if (view != null)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if the reference is in the view.
        /// </summary>
        protected virtual bool IsReferenceInView(ServerSystemContext context, ContinuationPoint continuationPoint, IReference reference)
        {
            return true;
        }

        /// <summary>
        /// Returns the references for the node that meets the criteria specified.
        /// </summary>
        protected virtual ReferenceDescription GetReferenceDescription(
            ServerSystemContext context,
            Dictionary<NodeId, NodeState> cache,
            IReference reference,
            ContinuationPoint continuationPoint)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            // create the type definition reference.        
            ReferenceDescription description = new ReferenceDescription();

            description.NodeId = reference.TargetId;
            description.SetReferenceType(continuationPoint.ResultMask, reference.ReferenceTypeId, !reference.IsInverse);

            // check if reference is in the view.
            if (!IsReferenceInView(context, continuationPoint, reference))
            {
                return null;
            }

            // do not cache target parameters for remote nodes.
            if (reference.TargetId.IsAbsolute)
            {
                // only return remote references if no node class filter is specified.
                if (continuationPoint.NodeClassMask != 0)
                {
                    return null;
                }

                return description;
            }

            NodeState target = null;

            // check for local reference.

            if (reference is NodeStateReference referenceInfo)
            {
                target = referenceInfo.Target;
            }

            // check for internal reference.
            if (target == null)
            {
                if (GetManagerHandle(context, (NodeId)reference.TargetId, null) is NodeHandle handle)
                {
                    target = ValidateNode(context, handle, null);
                }
            }

            // the target may be a reference to a node in another node manager. In these cases
            // the target attributes must be fetched by the caller. The Unfiltered flag tells the
            // caller to do that.
            if (target == null)
            {
                description.Unfiltered = true;
                return description;
            }

            // apply node class filter.
            if (continuationPoint.NodeClassMask != 0 && ((continuationPoint.NodeClassMask & (uint)target.NodeClass) == 0))
            {
                return null;
            }

            // check if target is in the view.
            if (!IsNodeInView(context, continuationPoint, target))
            {
                return null;
            }

            // look up the type definition.
            NodeId typeDefinition = null;

            if (target is BaseInstanceState instance)
            {
                typeDefinition = instance.TypeDefinitionId;
            }

            // set target attributes.
            description.SetTargetAttributes(
                continuationPoint.ResultMask,
                target.NodeClass,
                target.BrowseName,
                target.DisplayName,
                typeDefinition);

            return description;
        }
        #endregion

        /// <summary>
        /// Returns the target of the specified browse path fragment(s).
        /// </summary>
        /// <remarks>
        /// If reference exists but the node manager does not know the browse name it must 
        /// return the NodeId as an unresolvedTargetIds. The caller will try to check the
        /// browse name. 
        /// </remarks>
        public virtual void TranslateBrowsePath(
            OperationContext      context, 
            object                sourceHandle, 
            RelativePathElement   relativePath, 
            IList<ExpandedNodeId> targetIds, 
            IList<NodeId>         unresolvedTargetIds)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();

            lock (Lock)
            {
                // check for valid handle.
                NodeHandle handle = IsHandleInNamespace(sourceHandle);

                if (handle == null)
                {
                    return;
                }

                // validate node.
                NodeState source = ValidateNode(systemContext, handle, operationCache);

                if (source == null)
                {
                    return;
                }

                // get list of references that relative path.
                INodeBrowser browser = source.CreateBrowser(
                    systemContext,
                    null,
                    relativePath.ReferenceTypeId,
                    relativePath.IncludeSubtypes,
                    (relativePath.IsInverse) ? BrowseDirection.Inverse : BrowseDirection.Forward,
                    relativePath.TargetName,
                    null,
                    false);

                // check the browse names.
                try
                {
                    for (IReference reference = browser.Next(); reference != null; reference = browser.Next())
                    {
                        // ignore unknown external references.
                        if (reference.TargetId.IsAbsolute)
                        {
                            continue;
                        }

                        NodeState target = null;

                        // check for local reference.

                        if (reference is NodeStateReference referenceInfo)
                        {
                            target = referenceInfo.Target;
                        }

                        if (target == null)
                        {
                            NodeId targetId = (NodeId)reference.TargetId;

                            // the target may be a reference to a node in another node manager.
                            if (!IsNodeIdInNamespace(targetId))
                            {
                                unresolvedTargetIds.Add((NodeId)reference.TargetId);
                                continue;
                            }

                            // look up the target manually.
                            NodeHandle targetHandle = GetManagerHandle(systemContext, targetId, operationCache);

                            if (targetHandle == null)
                            {
                                continue;
                            }

                            // validate target.
                            target = ValidateNode(systemContext, targetHandle, operationCache);

                            if (target == null)
                            {
                                continue;
                            }
                        }

                        // check browse name.
                        if (target.BrowseName == relativePath.TargetName)
                        {
                            if (!targetIds.Contains(reference.TargetId))
                            {
                                targetIds.Add(reference.TargetId);
                            }
                        }
                    }
                }
                finally
                {
                    browser.Dispose();
                }
            }
        }

        /// <summary>
        /// Reads the value for the specified attribute.
        /// </summary>
        public virtual void Read(
            OperationContext     context, 
            double               maxAge, 
            IList<ReadValueId>   nodesToRead, 
            IList<DataValue>     values, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<NodeHandle> nodesToValidate = new List<NodeHandle>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToRead.Count; ii++)
                {
                    ReadValueId nodeToRead = nodesToRead[ii];

                    // skip items that have already been processed.
                    if (nodeToRead.Processed)
                    {
                        continue;
                    }

                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, nodeToRead.NodeId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToRead.Processed = true;

                    // create an initial value.
                    DataValue value = values[ii] = new DataValue();

                    value.Value = null;
                    value.ServerTimestamp = DateTime.UtcNow;
                    value.SourceTimestamp = DateTime.MinValue;
                    value.StatusCode = StatusCodes.Good;

                    // check if the node is a area in memory.
                    if (handle.Node == null)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;

                        // must validate node in a separate operation
                        handle.Index = ii;
                        nodesToValidate.Add(handle);

                        continue;
                    }

                    // read the attribute value.
                    errors[ii] = handle.Node.ReadAttribute(
                        systemContext,
                        nodeToRead.AttributeId,
                        nodeToRead.ParsedIndexRange,
                        nodeToRead.DataEncoding,
                        value);
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }
            }

            // validates the nodes (reads values from the underlying data source if required).
            Read(
                systemContext,
                nodesToRead,
                values,
                errors,
                nodesToValidate,
                operationCache);
        }

        #region Read Support Functions
        /// <summary>
        /// Finds a node in the dynamic cache.
        /// </summary>
        /// <param name="context">The current context.</param>
        /// <param name="handle">The node handle.</param>
        /// <param name="cache">The cache to search.</param>
        /// <returns>The node if found. Null otherwise.</returns>
        protected virtual NodeState FindNodeInCache(
            ServerSystemContext context,
            NodeHandle handle,
            IDictionary<NodeId, NodeState> cache)
        {
            NodeState target = null;

            // not valid if no root.
            if (handle == null)
            {
                return null;
            }

            // check if previously validated.
            if (handle.Validated)
            {
                return handle.Node;
            }

            // construct id for root node.
            NodeId rootId = handle.RootId;

            if (cache != null)
            {
                // lookup component in local cache for request.
                if (cache.TryGetValue(handle.NodeId, out target))
                {
                    return target;
                }

                // lookup root in local cache for request.
                if (!String.IsNullOrEmpty(handle.ComponentPath))
                {
                    if (cache.TryGetValue(rootId, out target))
                    {
                        target = target.FindChildBySymbolicName(context, handle.ComponentPath);

                        // component exists.
                        if (target != null)
                        {
                            return target;
                        }
                    }
                }
            }

            // lookup component in shared cache.
            target = LookupNodeInComponentCache(context, handle);

            if (target != null)
            {
                return target;
            }

            return null;
        }

        /// <summary>
        /// Marks the handle as validated and saves the node in the dynamic cache.
        /// </summary>
        protected virtual NodeState ValidationComplete(
            ServerSystemContext context,
            NodeHandle handle,
            NodeState node,
            IDictionary<NodeId, NodeState> cache)
        {
            handle.Node = node;
            handle.Validated = true;

            if (cache != null && handle != null)
            {
                cache[handle.NodeId] = node;
            }

            return node;
        }

        /// <summary>
        /// Verifies that the specified node exists.
        /// </summary>
        protected virtual NodeState ValidateNode(
            ServerSystemContext context,
            NodeHandle handle,
            IDictionary<NodeId, NodeState> cache)
        {
            // lookup in cache.
            NodeState target = FindNodeInCache(context, handle, cache);

            if (target != null)
            {
                handle.Node = target;
                handle.Validated = true;
                return handle.Node;
            }

            // return default.
            return handle.Node;
        }

        /// <summary>
        /// Validates the nodes and reads the values from the underlying source.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="nodesToRead">The nodes to read.</param>
        /// <param name="values">The values.</param>
        /// <param name="errors">The errors.</param>
        /// <param name="nodesToValidate">The nodes to validate.</param>
        /// <param name="cache">The cache.</param>
        protected virtual void Read(
            ServerSystemContext context,
            IList<ReadValueId> nodesToRead,
            IList<DataValue> values,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToValidate,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToValidate.Count; ii++)
            {
                NodeHandle handle = nodesToValidate[ii];

                lock (Lock)
                {
                    // validate node.
                    NodeState source = ValidateNode(context, handle, cache);

                    if (source == null)
                    {
                        continue;
                    }

                    ReadValueId nodeToRead = nodesToRead[handle.Index];
                    DataValue value = values[handle.Index];

                    // update the attribute value.
                    errors[handle.Index] = source.ReadAttribute(
                        context,
                        nodeToRead.AttributeId,
                        nodeToRead.ParsedIndexRange,
                        nodeToRead.DataEncoding,
                        value);
                }
            }
        }
        #endregion

        /// <summary>
        /// Writes the value for the specified attributes.
        /// </summary>
        public virtual void Write(
            OperationContext     context, 
            IList<WriteValue>    nodesToWrite, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<NodeHandle> nodesToValidate = new List<NodeHandle>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToWrite.Count; ii++)
                {

                    WriteValue nodeToWrite = nodesToWrite[ii];

                    // skip items that have already been processed.
                    if (nodeToWrite.Processed)
                    {
                        continue;
                    }

                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, nodeToWrite.NodeId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToWrite.Processed = true;

                    // index range is not supported.
                    if (nodeToWrite.AttributeId != Attributes.Value)
                    {
                        if (!String.IsNullOrEmpty(nodeToWrite.IndexRange))
                        {
                            errors[ii] = StatusCodes.BadWriteNotSupported;
                            continue;
                        }
                    }

                    // check if the node is a area in memory.
                    if (handle.Node == null)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;

                        // must validate node in a separate operation.
                        handle.Index = ii;
                        nodesToValidate.Add(handle);

                        continue;
                    }

                    // check if the node is AnalogItem and the value is outside the InstrumentRange.
                    AnalogItemState analogItemState = handle.Node as AnalogItemState;
                    if (analogItemState?.InstrumentRange != null)
                    {
                        try
                        {
                            double newValue = System.Convert.ToDouble(nodeToWrite.Value.Value);

                            if (newValue > analogItemState.InstrumentRange.Value.High ||
                                newValue < analogItemState.InstrumentRange.Value.Low)
                            {
                                errors[ii] = StatusCodes.BadOutOfRange;
                                continue;
                            }
                        }
                        catch
                        {
                            //skip the InstrumentRange check if the transformation isn't possible.
                        }
                    }

                    Utils.TraceDebug("WRITE: Value={0} Range={1}", nodeToWrite.Value.WrappedValue, nodeToWrite.IndexRange);
                    object previousPropertyValue = null;

                    if (handle.Node is PropertyState propertyState)
                    {
                        if (propertyState.Value is ExtensionObject extension)
                        {
                            previousPropertyValue = extension.Body;
                        }
                        else
                        {
                            previousPropertyValue = propertyState.Value;
                        }
                    }

                    // write the attribute value.
                    errors[ii] = handle.Node.WriteAttribute(
                        systemContext,
                        nodeToWrite.AttributeId,
                        nodeToWrite.ParsedIndexRange,
                        nodeToWrite.Value);

                    if (!ServiceResult.IsGood(errors[ii]))
                    {
                        continue;
                    }

                    if (handle.Node is PropertyState propertyState)
                    {
                        object propertyValue;

                        if (propertyState.Value is ExtensionObject extension)
                        {
                            propertyValue = extension.Body;
                        }
                        else
                        {
                            propertyValue = nodeToWrite.Value.Value;
                        }

                        CheckIfSemanticsHaveChanged(systemContext, propertyState, propertyValue, previousPropertyValue);
                    }

                    // updates to source finished - report changes to monitored items.
                    handle.Node.ClearChangeMasks(systemContext, false);
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }
            }

            // validates the nodes and writes the value to the underlying system.
            Write(
                systemContext,
                nodesToWrite,
                errors,
                nodesToValidate,
                operationCache);
        }

        private void CheckIfSemanticsHaveChanged(ServerSystemContext systemContext, PropertyState property, object newPropertyValue, object previousPropertyValue)
        {
            // check if the changed property is one that can trigger semantic changes
            string propertyName = property.BrowseName.Name;

            if (propertyName != BrowseNames.EURange &&
                propertyName != BrowseNames.InstrumentRange &&
                propertyName != BrowseNames.EngineeringUnits &&
                propertyName != BrowseNames.Title &&
                propertyName != BrowseNames.AxisDefinition &&
                propertyName != BrowseNames.FalseState &&
                propertyName != BrowseNames.TrueState &&
                propertyName != BrowseNames.EnumStrings &&
                propertyName != BrowseNames.XAxisDefinition &&
                propertyName != BrowseNames.YAxisDefinition &&
                propertyName != BrowseNames.ZAxisDefinition)
            {
                return;
            }

            //look for the Parent and its monitoring items
            foreach (var monitoredNode in m_monitoredNodes.Values)
            {
                var propertyState = monitoredNode.Node.FindChild(systemContext, property.BrowseName);

                if (propertyState != null && property != null && propertyState.NodeId == property.NodeId && !Utils.IsEqual(newPropertyValue, previousPropertyValue))
                {
                    foreach (var monitoredItem in monitoredNode.DataChangeMonitoredItems)
                    {
                        if (monitoredItem.AttributeId == Attributes.Value)
                        {
                            NodeState node = monitoredNode.Node;

                            if ((node is AnalogItemState && (propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits)) ||
                                (node is TwoStateDiscreteState && (propertyName == BrowseNames.FalseState || propertyName == BrowseNames.TrueState)) ||
                                (node is MultiStateDiscreteState && (propertyName == BrowseNames.EnumStrings)) ||
                                (node is ArrayItemState && (propertyName == BrowseNames.InstrumentRange || propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits || propertyName == BrowseNames.Title)) ||
                                ((node is YArrayItemState || node is XYArrayItemState) && (propertyName == BrowseNames.InstrumentRange || propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits || propertyName == BrowseNames.Title || propertyName == BrowseNames.XAxisDefinition)) ||
                                (node is ImageItemState && (propertyName == BrowseNames.InstrumentRange || propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits || propertyName == BrowseNames.Title || propertyName == BrowseNames.XAxisDefinition || propertyName == BrowseNames.YAxisDefinition)) ||
                                (node is CubeItemState && (propertyName == BrowseNames.InstrumentRange || propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits || propertyName == BrowseNames.Title || propertyName == BrowseNames.XAxisDefinition || propertyName == BrowseNames.YAxisDefinition || propertyName == BrowseNames.ZAxisDefinition)) ||
                                (node is NDimensionArrayItemState && (propertyName == BrowseNames.InstrumentRange || propertyName == BrowseNames.EURange || propertyName == BrowseNames.EngineeringUnits || propertyName == BrowseNames.Title || propertyName == BrowseNames.AxisDefinition)))
                            {
                                monitoredItem.SetSemanticsChanged();

                                DataValue value = new DataValue();
                                value.ServerTimestamp = DateTime.UtcNow;

                                monitoredNode.Node.ReadAttribute(systemContext, Attributes.Value, monitoredItem.IndexRange, null, value);

                                monitoredItem.QueueValue(value, ServiceResult.Good, true);
                            }
                        }
                    }
                }
            }
        }

        #region Write Support Functions
        /// <summary>
        /// Validates the nodes and writes the value to the underlying system.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="nodesToWrite">The nodes to write.</param>
        /// <param name="errors">The errors.</param>
        /// <param name="nodesToValidate">The nodes to validate.</param>
        /// <param name="cache">The cache.</param>
        protected virtual void Write(
            ServerSystemContext context,
            IList<WriteValue> nodesToWrite,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToValidate,
            IDictionary<NodeId, NodeState> cache)
        {
            // validates the nodes (reads values from the underlying data source if required).
            for (int ii = 0; ii < nodesToValidate.Count; ii++)
            {
                NodeHandle handle = nodesToValidate[ii];

                lock (Lock)
                {
                    // validate node.
                    NodeState source = ValidateNode(context, handle, cache);

                    if (source == null)
                    {
                        continue;
                    }

                    WriteValue nodeToWrite = nodesToWrite[handle.Index];

                    // write the attribute value.
                    errors[handle.Index] = source.WriteAttribute(
                        context,
                        nodeToWrite.AttributeId,
                        nodeToWrite.ParsedIndexRange,
                        nodeToWrite.Value);

                    // updates to source finished - report changes to monitored items.
                    source.ClearChangeMasks(context, false);
                }
            }
        }
        #endregion

        /// <summary>
        /// Reads the history for the specified nodes.
        /// </summary>
        public virtual void HistoryRead(
            OperationContext          context, 
            HistoryReadDetails        details, 
            TimestampsToReturn        timestampsToReturn, 
            bool                      releaseContinuationPoints, 
            IList<HistoryReadValueId> nodesToRead, 
            IList<HistoryReadResult>  results, 
            IList<ServiceResult>      errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<NodeHandle> nodesToProcess = new List<NodeHandle>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToRead.Count; ii++)
                {
                    HistoryReadValueId nodeToRead = nodesToRead[ii];

                    // skip items that have already been processed.
                    if (nodeToRead.Processed)
                    {
                        continue;
                    }

                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, nodeToRead.NodeId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToRead.Processed = true;

                    // create an initial result.
                    HistoryReadResult result = results[ii] = new HistoryReadResult();

                    result.HistoryData       = null;
                    result.ContinuationPoint = null;
                    result.StatusCode        = StatusCodes.Good;

                    // check if the node is a area in memory.
                    if (handle.Node == null)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;

                        // must validate node in a seperate operation
                        handle.Index = ii;
                        nodesToProcess.Add(handle);

                        continue;
                    }

                    errors[ii] = StatusCodes.BadHistoryOperationUnsupported;

                    // check for data history variable.

                    if (handle.Node is BaseVariableState variable)
                    {
                        if ((variable.AccessLevel & AccessLevels.HistoryRead) != 0)
                        {
                            handle.Index = ii;
                            nodesToProcess.Add(handle);
                            continue;
                        }
                    }

                    // check for event history object.

                    if (handle.Node is BaseObjectState notifier)
                    {
                        if ((notifier.EventNotifier & EventNotifiers.HistoryRead) != 0)
                        {
                            handle.Index = ii;
                            nodesToProcess.Add(handle);
                            continue;
                        }
                    }
                }

                // check for nothing to do.
                if (nodesToProcess.Count == 0)
                {
                    return;
                }
            }

            // validates the nodes (reads values from the underlying data source if required).
            HistoryRead(
                systemContext,
                details,
                timestampsToReturn,
                releaseContinuationPoints,
                nodesToRead,
                results,
                errors,
                nodesToProcess,
                operationCache);
        }

        #region HistoryRead Support Functions
        /// <summary>
        /// Releases the continuation points.
        /// </summary>
        protected virtual void HistoryReleaseContinuationPoints(
            ServerSystemContext context,
            IList<HistoryReadValueId> nodesToRead,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadContinuationPointInvalid;
            }
        }

        /// <summary>
        /// Reads raw history data.
        /// </summary>
        protected virtual void HistoryReadRawModified(
            ServerSystemContext context,
            ReadRawModifiedDetails details,
            TimestampsToReturn timestampsToReturn,
            IList<HistoryReadValueId> nodesToRead,
            IList<HistoryReadResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Reads processed history data.
        /// </summary>
        protected virtual void HistoryReadProcessed(
            ServerSystemContext context,
            ReadProcessedDetails details,
            TimestampsToReturn timestampsToReturn,
            IList<HistoryReadValueId> nodesToRead,
            IList<HistoryReadResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Reads history data at specified times.
        /// </summary>
        protected virtual void HistoryReadAtTime(
            ServerSystemContext context,
            ReadAtTimeDetails details,
            TimestampsToReturn timestampsToReturn,
            IList<HistoryReadValueId> nodesToRead,
            IList<HistoryReadResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Reads history events.
        /// </summary>
        protected virtual void HistoryReadEvents(
            ServerSystemContext context,
            ReadEventDetails details,
            TimestampsToReturn timestampsToReturn,
            IList<HistoryReadValueId> nodesToRead,
            IList<HistoryReadResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Validates the nodes and reads the values from the underlying source.
        /// </summary>
        protected virtual void HistoryRead(
            ServerSystemContext context,
            HistoryReadDetails details,
            TimestampsToReturn timestampsToReturn,
            bool releaseContinuationPoints,
            IList<HistoryReadValueId> nodesToRead,
            IList<HistoryReadResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            // check if continuation points are being released.
            if (releaseContinuationPoints)
            {
                HistoryReleaseContinuationPoints(
                    context,
                    nodesToRead,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // check timestamps to return.
            if (timestampsToReturn < TimestampsToReturn.Source || timestampsToReturn > TimestampsToReturn.Neither)
            {
                throw new ServiceResultException(StatusCodes.BadTimestampsToReturnInvalid);
            }

            // handle raw data request.

            if (details is ReadRawModifiedDetails readRawModifiedDetails)
            {
                // at least one must be provided.
                if (readRawModifiedDetails.StartTime == DateTime.MinValue && readRawModifiedDetails.EndTime == DateTime.MinValue)
                {
                    throw new ServiceResultException(StatusCodes.BadInvalidTimestampArgument);
                }

                // if one is null the num values must be provided.
                if (readRawModifiedDetails.StartTime == DateTime.MinValue || readRawModifiedDetails.EndTime == DateTime.MinValue)
                {
                    if (readRawModifiedDetails.NumValuesPerNode == 0)
                    {
                        throw new ServiceResultException(StatusCodes.BadInvalidTimestampArgument);
                    }
                }

                HistoryReadRawModified(
                    context,
                    readRawModifiedDetails,
                    timestampsToReturn,
                    nodesToRead,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle processed data request.

            if (details is ReadProcessedDetails readProcessedDetails)
            {
                // check the list of aggregates.
                if (readProcessedDetails.AggregateType == null || readProcessedDetails.AggregateType.Count != nodesToRead.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadAggregateListMismatch);
                }

                // check start/end time.
                if (readProcessedDetails.StartTime == DateTime.MinValue || readProcessedDetails.EndTime == DateTime.MinValue)
                {
                    throw new ServiceResultException(StatusCodes.BadInvalidTimestampArgument);
                }

                HistoryReadProcessed(
                    context,
                    readProcessedDetails,
                    timestampsToReturn,
                    nodesToRead,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle raw data at time request.

            if (details is ReadAtTimeDetails readAtTimeDetails)
            {
                HistoryReadAtTime(
                    context,
                    readAtTimeDetails,
                    timestampsToReturn,
                    nodesToRead,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle read events request.

            if (details is ReadEventDetails readEventDetails)
            {
                // check start/end time and max values.
                if (readEventDetails.NumValuesPerNode == 0)
                {
                    if (readEventDetails.StartTime == DateTime.MinValue || readEventDetails.EndTime == DateTime.MinValue)
                    {
                        throw new ServiceResultException(StatusCodes.BadInvalidTimestampArgument);
                    }
                }
                else
                {
                    if (readEventDetails.StartTime == DateTime.MinValue && readEventDetails.EndTime == DateTime.MinValue)
                    {
                        throw new ServiceResultException(StatusCodes.BadInvalidTimestampArgument);
                    }
                }

                // validate the event filter.
                EventFilter.Result result = readEventDetails.Filter.Validate(new FilterContext(m_server.NamespaceUris, m_server.TypeTree, context));

                if (ServiceResult.IsBad(result.Status))
                {
                    throw new ServiceResultException(result.Status);
                }

                // read the event history.
                HistoryReadEvents(
                    context,
                    readEventDetails,
                    timestampsToReturn,
                    nodesToRead,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }
        }
        #endregion

        /// <summary>
        /// Updates the history for the specified nodes.
        /// </summary>
        public virtual void HistoryUpdate(
            OperationContext            context, 
            Type                        detailsType, 
            IList<HistoryUpdateDetails> nodesToUpdate, 
            IList<HistoryUpdateResult>  results,
            IList<ServiceResult>        errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<NodeHandle> nodesToProcess = new List<NodeHandle>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToUpdate.Count; ii++)
                {
                    HistoryUpdateDetails nodeToUpdate = nodesToUpdate[ii];

                    // skip items that have already been processed.
                    if (nodeToUpdate.Processed)
                    {
                        continue;
                    }

                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, nodeToUpdate.NodeId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToUpdate.Processed = true;

                    // create an initial result.
                    HistoryUpdateResult result = results[ii] = new HistoryUpdateResult();
                    result.StatusCode = StatusCodes.Good;

                    // check if the node is a area in memory.
                    if (handle.Node == null)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;

                        // must validate node in a seperate operation
                        handle.Index = ii;
                        nodesToProcess.Add(handle);
                        continue;
                    }

                    errors[ii] = StatusCodes.BadHistoryOperationUnsupported;

                    // check for data history variable.

                    if (handle.Node is BaseVariableState variable)
                    {
                        if ((variable.AccessLevel & AccessLevels.HistoryWrite) != 0)
                        {
                            handle.Index = ii;
                            nodesToProcess.Add(handle);
                            continue;
                        }
                    }

                    // check for event history object.

                    if (handle.Node is BaseObjectState notifier)
                    {
                        if ((notifier.EventNotifier & EventNotifiers.HistoryWrite) != 0)
                        {
                            handle.Index = ii;
                            nodesToProcess.Add(handle);
                            continue;
                        }
                    }
                }

                // check for nothing to do.
                if (nodesToProcess.Count == 0)
                {
                    return;
                }
            }

            // validates the nodes and updates.
            HistoryUpdate(
                systemContext,
                detailsType,
                nodesToUpdate,
                results,
                errors,
                nodesToProcess,
                operationCache);
        }

        #region HistoryUpdate Support Functions
        /// <summary>
        /// Validates the nodes and updates the history.
        /// </summary>
        protected virtual void HistoryUpdate(
            ServerSystemContext context,
            Type                           detailsType, 
            IList<HistoryUpdateDetails>    nodesToUpdate, 
            IList<HistoryUpdateResult>     results,
            IList<ServiceResult>           errors,
            List<NodeHandle>               nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            // handle update data request.
            if (detailsType == typeof(UpdateDataDetails))
            {
                UpdateDataDetails[] details = new UpdateDataDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (UpdateDataDetails)nodesToUpdate[ii];
                }

                HistoryUpdateData(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle update structure data request.
            if (detailsType == typeof(UpdateStructureDataDetails))
            {
                UpdateStructureDataDetails[] details = new UpdateStructureDataDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (UpdateStructureDataDetails)nodesToUpdate[ii];
                }

                HistoryUpdateStructureData(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle update events request.
            if (detailsType == typeof(UpdateEventDetails))
            {
                UpdateEventDetails[] details = new UpdateEventDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (UpdateEventDetails)nodesToUpdate[ii];
                }

                HistoryUpdateEvents(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle delete raw data request.
            if (detailsType == typeof(DeleteRawModifiedDetails))
            {
                DeleteRawModifiedDetails[] details = new DeleteRawModifiedDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (DeleteRawModifiedDetails)nodesToUpdate[ii];
                }

                HistoryDeleteRawModified(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle delete at time request.
            if (detailsType == typeof(DeleteAtTimeDetails))
            {
                DeleteAtTimeDetails[] details = new DeleteAtTimeDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (DeleteAtTimeDetails)nodesToUpdate[ii];
                }

                HistoryDeleteAtTime(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }

            // handle delete at time request.
            if (detailsType == typeof(DeleteEventDetails))
            {
                DeleteEventDetails[] details = new DeleteEventDetails[nodesToUpdate.Count];

                for (int ii = 0; ii < details.Length; ii++)
                {
                    details[ii] = (DeleteEventDetails)nodesToUpdate[ii];
                }

                HistoryDeleteEvents(
                    context,
                    details,
                    results,
                    errors,
                    nodesToProcess,
                    cache);

                return;
            }
        }

        /// <summary>
        /// Updates the data history for one or more nodes.
        /// </summary>
        protected virtual void HistoryUpdateData(
            ServerSystemContext context,
            IList<UpdateDataDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Updates the structured data history for one or more nodes.
        /// </summary>
        protected virtual void HistoryUpdateStructureData(
            ServerSystemContext context,
            IList<UpdateStructureDataDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Updates the event history for one or more nodes.
        /// </summary>
        protected virtual void HistoryUpdateEvents(
            ServerSystemContext context,
            IList<UpdateEventDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Deletes the data history for one or more nodes.
        /// </summary>
        protected virtual void HistoryDeleteRawModified(
            ServerSystemContext context,
            IList<DeleteRawModifiedDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Deletes the data history for one or more nodes.
        /// </summary>
        protected virtual void HistoryDeleteAtTime(
            ServerSystemContext context,
            IList<DeleteAtTimeDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }

        /// <summary>
        /// Deletes the event history for one or more nodes.
        /// </summary>
        protected virtual void HistoryDeleteEvents(
            ServerSystemContext context,
            IList<DeleteEventDetails> nodesToUpdate,
            IList<HistoryUpdateResult> results,
            IList<ServiceResult> errors,
            List<NodeHandle> nodesToProcess,
            IDictionary<NodeId, NodeState> cache)
        {
            for (int ii = 0; ii < nodesToProcess.Count; ii++)
            {
                NodeHandle handle = nodesToProcess[ii];

                // validate node.
                NodeState source = ValidateNode(context, handle, cache);

                if (source == null)
                {
                    continue;
                }

                errors[handle.Index] = StatusCodes.BadHistoryOperationUnsupported;
            }
        }
        #endregion

        /// <summary>
        /// Calls a method on the specified nodes.
        /// </summary>
        public virtual void Call(
            OperationContext         context,
            IList<CallMethodRequest> methodsToCall,
            IList<CallMethodResult>  results,
            IList<ServiceResult>     errors)
        {
            ServerSystemContext systemContext = SystemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();

            for (int ii = 0; ii < methodsToCall.Count; ii++)
            {
                CallMethodRequest methodToCall = methodsToCall[ii];

                // skip items that have already been processed.
                if (methodToCall.Processed)
                {
                    continue;
                }

                MethodState method = null;

                lock (Lock)
                {
                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, methodToCall.ObjectId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    methodToCall.Processed = true;

                    // validate the source node.
                    NodeState source = ValidateNode(systemContext, handle, operationCache);

                    if (source == null)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        continue;
                    }

                    // find the method.
                    method = source.FindMethod(systemContext, methodToCall.MethodId);

                    if (method == null)
                    {
                        // check for loose coupling.
                        if (source.ReferenceExists(ReferenceTypeIds.HasComponent, false, methodToCall.MethodId))
                        {
                            method = (MethodState)FindPredefinedNode(methodToCall.MethodId, typeof(MethodState));
                        }

                        if (method == null)
                        {
                            errors[ii] = StatusCodes.BadMethodInvalid;
                            continue;
                        }
                    }
                }

                // call the method.
                CallMethodResult result = results[ii] = new CallMethodResult();

                errors[ii] = Call(
                    systemContext,
                    methodToCall,
                    method,
                    result);
            }
        }

        /// <summary>
        /// Calls a method on an object.
        /// </summary>
        protected virtual ServiceResult Call(
            ISystemContext    context,
            CallMethodRequest methodToCall,
            MethodState       method,
            CallMethodResult  result)
        {
            ServerSystemContext systemContext = context as ServerSystemContext;
            List<ServiceResult> argumentErrors = new List<ServiceResult>();
            VariantCollection outputArguments = new VariantCollection();

            ServiceResult error = method.Call(
                context,
                methodToCall.ObjectId,
                methodToCall.InputArguments,
                argumentErrors,
                outputArguments);

            if (ServiceResult.IsBad(error))
            {
                return error;
            }

            // check for argument errors.
            bool argumentsValid = true;

            for (int jj = 0; jj < argumentErrors.Count; jj++)
            {
                ServiceResult argumentError = argumentErrors[jj];

                if (argumentError != null)
                {
                    result.InputArgumentResults.Add(argumentError.StatusCode);

                    if (ServiceResult.IsBad(argumentError))
                    {
                        argumentsValid = false;
                    }
                }
                else
                {
                    result.InputArgumentResults.Add(StatusCodes.Good);
                }

                // only fill in diagnostic info if it is requested.
                if (systemContext.OperationContext != null)
                {
                    if ((systemContext.OperationContext.DiagnosticsMask & DiagnosticsMasks.OperationAll) != 0)
                    {
                        if (ServiceResult.IsBad(argumentError))
                        {
                            argumentsValid = false;
                            result.InputArgumentDiagnosticInfos.Add(new DiagnosticInfo(argumentError, systemContext.OperationContext.DiagnosticsMask, false, systemContext.OperationContext.StringTable));
                        }
                        else
                        {
                            result.InputArgumentDiagnosticInfos.Add(null);
                        }
                    }
                }
            }

            // check for validation errors.
            if (!argumentsValid)
            {
                result.StatusCode = StatusCodes.BadInvalidArgument;
                return result.StatusCode;
            }

            // do not return diagnostics if there are no errors.
            result.InputArgumentDiagnosticInfos.Clear();

            // return output arguments.
            result.OutputArguments = outputArguments;

            return ServiceResult.Good;
        }


        /// <summary>
        /// Subscribes or unsubscribes to events produced by the specified source.
        /// </summary>
        /// <remarks>
        /// This method is called when a event subscription is created or deletes. The node manager 
        /// must  start/stop reporting events for the specified object and all objects below it in 
        /// the notifier hierarchy.
        /// </remarks>
        public virtual ServiceResult SubscribeToEvents(
            OperationContext    context, 
            object              sourceId, 
            uint                subscriptionId, 
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe)
        {
            ServerSystemContext systemContext = SystemContext.Copy(context);

            lock (Lock)
            {
                // check for valid handle.
                NodeHandle handle = IsHandleInNamespace(sourceId);

                if (handle == null)
                {
                    return StatusCodes.BadNodeIdInvalid;
                }

                // check for valid node.
                NodeState source = ValidateNode(systemContext, handle, null);

                if (source == null)
                {
                    return StatusCodes.BadNodeIdUnknown;
                }

                // subscribe to events.
                return SubscribeToEvents(systemContext, source, monitoredItem, unsubscribe);
            }
        }

        /// <summary>
        /// Subscribes or unsubscribes to events produced by all event sources.
        /// </summary>
        /// <remarks>
        /// This method is called when a event subscription is created or deleted. The node 
        /// manager must start/stop reporting events for all objects that it manages.
        /// </remarks>
        public virtual ServiceResult SubscribeToAllEvents(
            OperationContext    context, 
            uint                subscriptionId, 
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe)
        {
            ServerSystemContext systemContext = SystemContext.Copy(context);

            lock (Lock)
            {
                // A client has subscribed to the Server object which means all events produced
                // by this manager must be reported. This is done by incrementing the monitoring
                // reference count for all root notifiers.
                if (m_rootNotifiers != null)
                {
                    for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
                    {
                        SubscribeToEvents(systemContext, m_rootNotifiers[ii], monitoredItem, unsubscribe);
                    }
                }

                return ServiceResult.Good;
            }
        }

        #region SubscribeToEvents Support Functions
        /// <summary>
        /// Adds a root notifier.
        /// </summary>
        /// <param name="notifier">The notifier.</param>
        /// <remarks>
        /// A root notifier is a notifier owned by the NodeManager that is not the target of a 
        /// HasNotifier reference. These nodes need to be linked directly to the Server object.
        /// </remarks>
        protected virtual void AddRootNotifier(NodeState notifier)
        {
            if (m_rootNotifiers == null)
            {
                m_rootNotifiers = new List<NodeState>();
            }

            bool mustAdd = true;

            for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
            {
                if (Object.ReferenceEquals(notifier, m_rootNotifiers[ii]))
                {
                    return;
                }

                if (m_rootNotifiers[ii].NodeId == notifier.NodeId)
                {
                    m_rootNotifiers[ii] = notifier;
                    mustAdd = false;
                    break;
                }
            }

            if (mustAdd)
            {
                m_rootNotifiers.Add(notifier);
            }

            // need to prevent recursion with the server object.
            if (notifier.NodeId != ObjectIds.Server)
            {
                notifier.OnReportEvent = OnReportEvent;

                if (!notifier.ReferenceExists(ReferenceTypeIds.HasNotifier, true, ObjectIds.Server))
                {
                    notifier.AddReference(ReferenceTypeIds.HasNotifier, true, ObjectIds.Server);
                }
            }

            // subscribe to existing events.
            if (m_server.EventManager != null)
            {
                IList<IEventMonitoredItem> monitoredItems = m_server.EventManager.GetMonitoredItems();

                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    if (monitoredItems[ii].MonitoringAllEvents)
                    {
                        SubscribeToEvents(
                            SystemContext,
                            notifier,
                            monitoredItems[ii],
                            true);
                    }
                }
            }
        }

        /// <summary>
        /// Removes a root notifier previously added with AddRootNotifier.
        /// </summary>
        /// <param name="notifier">The notifier.</param>
        protected virtual void RemoveRootNotifier(NodeState notifier)
        {
            if (m_rootNotifiers != null)
            {
                for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
                {
                    if (Object.ReferenceEquals(notifier, m_rootNotifiers[ii]))
                    {
                        notifier.OnReportEvent = null;
                        notifier.RemoveReference(ReferenceTypeIds.HasNotifier, true, ObjectIds.Server);
                        m_rootNotifiers.RemoveAt(ii);
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Reports an event for a root notifier.
        /// </summary>
        protected virtual void OnReportEvent(
            ISystemContext context,
            NodeState node,
            IFilterTarget e)
        {
            Server.ReportEvent(context, e);
        }

        /// <summary>
        /// Subscribes to events.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="source">The source.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        /// <param name="unsubscribe">if set to <c>true</c> [unsubscribe].</param>
        /// <returns>Any error code.</returns>
        protected virtual ServiceResult SubscribeToEvents(
            ServerSystemContext context, 
            NodeState           source,
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe)
        {
            MonitoredNode2 monitoredNode = null;

            // handle unsubscribe.
            if (unsubscribe)
            {
                // check for existing monitored node.
                if (!MonitoredNodes.TryGetValue(source.NodeId, out monitoredNode))
                {
                    return StatusCodes.BadNodeIdUnknown;
                }

                monitoredNode.Remove(monitoredItem);

                // check if node is no longer being monitored.
                if (!monitoredNode.HasMonitoredItems)
                {
                    MonitoredNodes.Remove(source.NodeId);
                }

                // update flag.
                source.SetAreEventsMonitored(context, !unsubscribe, true);

                // call subclass.
                OnSubscribeToEvents(context, monitoredNode, unsubscribe);

                // all done.
                return ServiceResult.Good;
            }

            // only objects or views can be subscribed to.
            BaseObjectState instance = source as BaseObjectState;

            if (instance == null || (instance.EventNotifier & EventNotifiers.SubscribeToEvents) == 0)
            {
                ViewState view = source as ViewState;

                if (view == null || (view.EventNotifier & EventNotifiers.SubscribeToEvents) == 0)
                {
                    return StatusCodes.BadNotSupported;
                }
            }

            // check for existing monitored node.
            if (!MonitoredNodes.TryGetValue(source.NodeId, out monitoredNode))
            {
                MonitoredNodes[source.NodeId] = monitoredNode = new MonitoredNode2(this, source);
            }

            // this links the node to specified monitored item and ensures all events
            // reported by the node are added to the monitored item's queue.
            monitoredNode.Add(monitoredItem);

            // This call recursively updates a reference count all nodes in the notifier
            // hierarchy below the area. Sources with a reference count of 0 do not have 
            // any active subscriptions so they do not need to report events.
            source.SetAreEventsMonitored(context, !unsubscribe, true);

            // signal update.
            OnSubscribeToEvents(context, monitoredNode, unsubscribe);

            // all done.
            return ServiceResult.Good;
        }

        /// <summary>
        /// Called after subscribing/unsubscribing to events.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="monitoredNode">The monitored node.</param>
        /// <param name="unsubscribe">if set to <c>true</c> unsubscribing.</param>
        protected virtual void OnSubscribeToEvents(
            ServerSystemContext context,
            MonitoredNode2       monitoredNode, 
            bool                unsubscribe)
        {
            // defined by the sub-class
        }
        #endregion

        /// <summary>
        /// Tells the node manager to refresh any conditions associated with the specified monitored items.
        /// </summary>
        /// <remarks>
        /// This method is called when the condition refresh method is called for a subscription.
        /// The node manager must create a refresh event for each condition monitored by the subscription.
        /// </remarks>
        public virtual ServiceResult ConditionRefresh(
            OperationContext           context,
            IList<IEventMonitoredItem> monitoredItems)
        {
            ServerSystemContext systemContext = SystemContext.Copy(context);

            for (int ii = 0; ii < monitoredItems.Count; ii++)
            {
                // the IEventMonitoredItem should always be MonitoredItems since they are created by the MasterNodeManager.
                MonitoredItem monitoredItem = monitoredItems[ii] as MonitoredItem;

                if (monitoredItem == null)
                {
                    continue;
                }

                List<IFilterTarget> events = new List<IFilterTarget>();
                List<NodeState> nodesToRefresh = new List<NodeState>();

                lock (Lock)
                {
                    // check for server subscription.
                    if (monitoredItem.NodeId == ObjectIds.Server)
                    {
                        if (m_rootNotifiers != null)
                        {
                            nodesToRefresh.AddRange(m_rootNotifiers);
                        }
                    }
                    else
                    {
                        // check for existing monitored node.
                        MonitoredNode2 monitoredNode = null;

                        if (!MonitoredNodes.TryGetValue(monitoredItem.NodeId, out monitoredNode))
                        {
                            continue;
                        }

                        // get the refresh events.
                        nodesToRefresh.Add(monitoredNode.Node);
                    }
                }

                // block and wait for the refresh.
                for (int jj = 0; jj < nodesToRefresh.Count; jj++)
                {
                    nodesToRefresh[jj].ConditionRefresh(systemContext, events, true);
                }

                // queue the events.
                for (int jj = 0; jj < events.Count; jj++)
                {
                    monitoredItem.QueueEvent(events[jj]);
                }
            }

            // all done.
            return ServiceResult.Good;
        }

        /// <summary>
        /// Creates a new set of monitored items for a set of variables.
        /// </summary>
        /// <remarks>
        /// This method only handles data change subscriptions. Event subscriptions are created by the SDK.
        /// </remarks>
        public virtual void CreateMonitoredItems(
            OperationContext                  context, 
            uint                              subscriptionId, 
            double                            publishingInterval, 
            TimestampsToReturn                timestampsToReturn, 
            IList<MonitoredItemCreateRequest> itemsToCreate, 
            IList<ServiceResult>              errors, 
            IList<MonitoringFilterResult>     filterResults, 
            IList<IMonitoredItem>             monitoredItems,
            ref long                          globalIdCounter)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId, NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<NodeHandle> nodesToValidate = new List<NodeHandle>();
            List<IMonitoredItem> createdItems = new List<IMonitoredItem>();

            lock (Lock)
            {
                for (int ii = 0; ii < itemsToCreate.Count; ii++)
                {
                    MonitoredItemCreateRequest itemToCreate = itemsToCreate[ii];

                    // skip items that have already been processed.
                    if (itemToCreate.Processed)
                    {
                        continue;
                    }

                    ReadValueId itemToMonitor = itemToCreate.ItemToMonitor;

                    // check for valid handle.
                    NodeHandle handle = GetManagerHandle(systemContext, itemToMonitor.NodeId, operationCache);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    itemToCreate.Processed = true;

                    // must validate node in a seperate operation.
                    errors[ii] = StatusCodes.BadNodeIdUnknown;

                    handle.Index = ii;
                    nodesToValidate.Add(handle);
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }
            }

            // validates the nodes (reads values from the underlying data source if required).
            for (int ii = 0; ii < nodesToValidate.Count; ii++)
            {
                NodeHandle handle = nodesToValidate[ii];

                MonitoringFilterResult filterResult = null;
                IMonitoredItem monitoredItem = null;

                lock (Lock)
                {
                    // validate node.
                    NodeState source = ValidateNode(systemContext, handle, operationCache);

                    if (source == null)
                    {
                        continue;
                    }

                    MonitoredItemCreateRequest itemToCreate = itemsToCreate[handle.Index];

                    // create monitored item.
                    errors[handle.Index] = CreateMonitoredItem(
                        systemContext,
                        handle,
                        subscriptionId,
                        publishingInterval,
                        context.DiagnosticsMask,
                        timestampsToReturn,
                        itemToCreate,
                        ref globalIdCounter,
                        out filterResult,
                        out monitoredItem);
                }

                // save any filter error details.
                filterResults[handle.Index] = filterResult;

                if (ServiceResult.IsBad(errors[handle.Index]))
                {
                    continue;
                }

                // save the monitored item.
                monitoredItems[handle.Index] = monitoredItem;
                createdItems.Add(monitoredItem);
            }

            // do any post processing.
            OnCreateMonitoredItemsComplete(systemContext, createdItems);
        }

        #region CreateMonitoredItem Support Functions
        /// <summary>
        /// Called when a batch of monitored items has been created.
        /// </summary>
        protected virtual void OnCreateMonitoredItemsComplete(ServerSystemContext context, IList<IMonitoredItem> monitoredItems)
        {
            // defined by the sub-class
        }

        /// <summary>
        /// Creates a new set of monitored items for a set of variables.
        /// </summary>
        /// <remarks>
        /// This method only handles data change subscriptions. Event subscriptions are created by the SDK.
        /// </remarks>
        protected virtual ServiceResult CreateMonitoredItem(
            ServerSystemContext context,
            NodeHandle handle,
            uint subscriptionId,
            double publishingInterval,
            DiagnosticsMasks diagnosticsMasks,
            TimestampsToReturn timestampsToReturn,
            MonitoredItemCreateRequest itemToCreate,
            ref long globalIdCounter,
            out MonitoringFilterResult filterResult,
            out IMonitoredItem monitoredItem)
        {
            filterResult = null;
            monitoredItem = null;

            // validate parameters.
            MonitoringParameters parameters = itemToCreate.RequestedParameters;

            // validate attribute.
            if (!Attributes.IsValid(handle.Node.NodeClass, itemToCreate.ItemToMonitor.AttributeId))
            {
                return StatusCodes.BadAttributeIdInvalid;
            }

            NodeState cachedNode = AddNodeToComponentCache(context, handle, handle.Node);

            // check if the node is already being monitored.
            MonitoredNode2 monitoredNode = null;

            if (!m_monitoredNodes.TryGetValue(handle.Node.NodeId, out monitoredNode))
            {
                m_monitoredNodes[handle.Node.NodeId] = monitoredNode = new MonitoredNode2(this, cachedNode);
            }

            handle.Node = monitoredNode.Node;
            handle.MonitoredNode = monitoredNode;

            // create a globally unique identifier.
            uint monitoredItemId = Utils.IncrementIdentifier(ref globalIdCounter);

            // determine the sampling interval.
            double samplingInterval = itemToCreate.RequestedParameters.SamplingInterval;

            if (samplingInterval < 0)
            {
                samplingInterval = publishingInterval;
            }

            // ensure minimum sampling interval is not exceeded.
            if (itemToCreate.ItemToMonitor.AttributeId == Attributes.Value)
            {
                if (handle.Node is BaseVariableState variable && samplingInterval < variable.MinimumSamplingInterval)
                {
                    samplingInterval = variable.MinimumSamplingInterval;
                }
            }

            // put a large upper limit on sampling.
            if (samplingInterval == Double.MaxValue)
            {
                samplingInterval = 365 * 24 * 3600 * 1000.0;
            }

            // put an upper limit on queue size.
            uint queueSize = itemToCreate.RequestedParameters.QueueSize;

            if (queueSize > m_maxQueueSize)
            {
                queueSize = m_maxQueueSize;
            }

            // validate the monitoring filter.
            Range euRange = null;
            MonitoringFilter filterToUse = null;

            ServiceResult error = ValidateMonitoringFilter(
                context,
                handle,
                itemToCreate.ItemToMonitor.AttributeId,
                samplingInterval,
                queueSize,
                parameters.Filter,
                out filterToUse,
                out euRange,
                out filterResult);

            if (ServiceResult.IsBad(error))
            {
                return error;
            }

            // create the item.
            MonitoredItem datachangeItem = new MonitoredItem(
                Server,
                this,
                handle,
                subscriptionId,
                monitoredItemId,
                context.OperationContext.Session,
                itemToCreate.ItemToMonitor,
                diagnosticsMasks,
                timestampsToReturn,
                itemToCreate.MonitoringMode,
                itemToCreate.RequestedParameters.ClientHandle,
                filterToUse,
                filterToUse,
                euRange,
                samplingInterval,
                queueSize,
                itemToCreate.RequestedParameters.DiscardOldest,
                0);

            // report the initial value.
            ReadInitialValue(context, handle, datachangeItem);

            // update monitored item list.
            monitoredItem = datachangeItem;

            // save the monitored item.
            m_monitoredItems.Add(monitoredItemId, datachangeItem);
            monitoredNode.Add(datachangeItem);

            // report change.
            OnMonitoredItemCreated(context, handle, datachangeItem);

            return error;
        }

        /// <summary>
        /// Reads the initial value for a monitored item.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The item handle.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        protected virtual void ReadInitialValue(
            ServerSystemContext context,
            NodeHandle handle,
            MonitoredItem monitoredItem)
        {
            DataValue initialValue = new DataValue();

            initialValue.Value = null;
            initialValue.ServerTimestamp = DateTime.UtcNow;
            initialValue.SourceTimestamp = DateTime.MinValue;
            initialValue.StatusCode = StatusCodes.BadWaitingForInitialData;

            ServiceResult error = handle.Node.ReadAttribute(
                context,
                monitoredItem.AttributeId,
                monitoredItem.IndexRange,
                monitoredItem.DataEncoding,
                initialValue);

            monitoredItem.QueueValue(initialValue, error);
        }

        /// <summary>
        /// Called after creating a MonitoredItem.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The handle for the node.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        protected virtual void OnMonitoredItemCreated(
            ServerSystemContext context,
            NodeHandle handle,
            MonitoredItem monitoredItem)
        {
            // overridden by the sub-class.
        }

        /// <summary>
        /// Validates Role permissions for the specified NodeId 
        /// </summary>
        /// <param name="operationContext"></param>
        /// <param name="nodeId"></param>
        /// <param name="requestedPermission"></param>
        /// <returns></returns>
        public ServiceResult ValidateRolePermissions(OperationContext operationContext, NodeId nodeId, PermissionType requestedPermission)
        {
            if (operationContext.Session == null || requestedPermission == PermissionType.None)
            {
                // no permission is required hence the validation passes.
                return StatusCodes.Good;
            }

            INodeManager nodeManager = null;
            object nodeHandle = Server.NodeManager.GetManagerHandle(nodeId, out nodeManager);

            if (nodeHandle == null || nodeManager == null)
            {
                // ignore unknown nodes.
                return StatusCodes.Good;
            }

            NodeMetadata nodeMetadata = nodeManager.GetNodeMetadata(operationContext, nodeHandle, BrowseResultMask.All);

            return MasterNodeManager.ValidateRolePermissions(operationContext, nodeMetadata, requestedPermission);
        }

        /// <summary>
        /// Validates the monitoring filter specified by the client.
        /// </summary>
        protected virtual StatusCode ValidateMonitoringFilter(
            ServerSystemContext context,
            NodeHandle handle,
            uint attributeId,
            double samplingInterval,
            uint queueSize,
            ExtensionObject filter,
            out MonitoringFilter filterToUse,
            out Range range,
            out MonitoringFilterResult result)
        {
            range = null;
            filterToUse = null;
            result = null;

            // nothing to do if the filter is not specified.
            if (ExtensionObject.IsNull(filter))
            {
                return StatusCodes.Good;
            }

            // extension objects wrap any data structure. must check that the client provided the correct structure.
            DataChangeFilter deadbandFilter = ExtensionObject.ToEncodeable(filter) as DataChangeFilter;

            if (deadbandFilter == null)
            {
                AggregateFilter aggregateFilter = ExtensionObject.ToEncodeable(filter) as AggregateFilter;

                if (aggregateFilter == null || attributeId != Attributes.Value)
                {
                    return StatusCodes.BadFilterNotAllowed;
                }

                if (!Server.AggregateManager.IsSupported(aggregateFilter.AggregateType))
                {
                    return StatusCodes.BadAggregateNotSupported;
                }

                ServerAggregateFilter revisedFilter = new ServerAggregateFilter();
                revisedFilter.AggregateType = aggregateFilter.AggregateType;
                revisedFilter.StartTime = aggregateFilter.StartTime;
                revisedFilter.ProcessingInterval = aggregateFilter.ProcessingInterval;
                revisedFilter.AggregateConfiguration = aggregateFilter.AggregateConfiguration;
                revisedFilter.Stepped = false;

                StatusCode error = ReviseAggregateFilter(context, handle, samplingInterval, queueSize, revisedFilter);

                if (StatusCode.IsBad(error))
                {
                    return error;
                }

                AggregateFilterResult aggregateFilterResult = new AggregateFilterResult();
                aggregateFilterResult.RevisedProcessingInterval = aggregateFilter.ProcessingInterval;
                aggregateFilterResult.RevisedStartTime = aggregateFilter.StartTime;
                aggregateFilterResult.RevisedAggregateConfiguration = aggregateFilter.AggregateConfiguration;

                filterToUse = revisedFilter;
                result = aggregateFilterResult;
                return StatusCodes.Good;
            }

            // deadband filters only allowed for variable values.
            if (attributeId != Attributes.Value)
            {
                return StatusCodes.BadFilterNotAllowed;
            }

            BaseVariableState variable = handle.Node as BaseVariableState;

            if (variable == null)
            {
                return StatusCodes.BadFilterNotAllowed;
            }

            // check for status filter.
            if (deadbandFilter.DeadbandType == (uint)DeadbandType.None)
            {
                filterToUse = deadbandFilter;
                return StatusCodes.Good;
            }

            // deadband filters can only be used for numeric values.
            if (!Server.TypeTree.IsTypeOf(variable.DataType, DataTypeIds.Number))
            {
                return StatusCodes.BadFilterNotAllowed;
            }

            // nothing more to do for absolute filters.
            if (deadbandFilter.DeadbandType == (uint)DeadbandType.Absolute)
            {
                filterToUse = deadbandFilter;
                return StatusCodes.Good;
            }

            // need to look up the EU range if a percent filter is requested.
            if (deadbandFilter.DeadbandType == (uint)DeadbandType.Percent)
            {
                PropertyState property = handle.Node.FindChild(context, Opc.Ua.BrowseNames.EURange) as PropertyState;

                if (property == null)
                {
                    return StatusCodes.BadMonitoredItemFilterUnsupported;
                }

                range = property.Value as Range;

                if (range == null)
                {
                    return StatusCodes.BadMonitoredItemFilterUnsupported;
                }

                filterToUse = deadbandFilter;

                return StatusCodes.Good;
            }

            // no other type of filter supported.
            return StatusCodes.BadFilterNotAllowed;
        }

        /// <summary>
        /// Revises an aggregate filter (may require knowledge of the variable being used). 
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The handle.</param>
        /// <param name="samplingInterval">The sampling interval for the monitored item.</param>
        /// <param name="queueSize">The queue size for the monitored item.</param>
        /// <param name="filterToUse">The filter to revise.</param>
        /// <returns>Good if the </returns>
        protected virtual StatusCode ReviseAggregateFilter(
            ServerSystemContext context,
            NodeHandle handle,
            double samplingInterval,
            uint queueSize,
            ServerAggregateFilter filterToUse)
        {
            if (filterToUse.ProcessingInterval < samplingInterval)
            {
                filterToUse.ProcessingInterval = samplingInterval;
            }

            if (filterToUse.ProcessingInterval < Server.AggregateManager.MinimumProcessingInterval)
            {
                filterToUse.ProcessingInterval = Server.AggregateManager.MinimumProcessingInterval;
            }

            DateTime earliestStartTime = DateTime.UtcNow.AddMilliseconds(-(queueSize - 1) * filterToUse.ProcessingInterval);

            if (earliestStartTime > filterToUse.StartTime)
            {
                filterToUse.StartTime = earliestStartTime;
            }

            if (filterToUse.AggregateConfiguration.UseServerCapabilitiesDefaults)
            {
                filterToUse.AggregateConfiguration = Server.AggregateManager.GetDefaultConfiguration(null);
            }

            return StatusCodes.Good;
        }
        #endregion

        /// <summary>
        /// Modifies the parameters for a set of monitored items.
        /// </summary>
        public virtual void ModifyMonitoredItems(
            OperationContext                  context, 
            TimestampsToReturn                timestampsToReturn, 
            IList<IMonitoredItem>             monitoredItems, 
            IList<MonitoredItemModifyRequest> itemsToModify, 
            IList<ServiceResult>              errors, 
            IList<MonitoringFilterResult>     filterResults)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            List<IMonitoredItem> modifiedItems = new List<IMonitoredItem>();

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    MonitoredItemModifyRequest itemToModify = itemsToModify[ii];

                    // skip items that have already been processed.
                    if (itemToModify.Processed || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // check handle.
                    NodeHandle handle = IsHandleInNamespace(monitoredItems[ii].ManagerHandle);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    itemToModify.Processed = true;

                    // modify the monitored item.
                    MonitoringFilterResult filterResult = null;

                    errors[ii] = ModifyMonitoredItem(
                        systemContext,
                        context.DiagnosticsMask,
                        timestampsToReturn,
                        monitoredItems[ii],
                        itemToModify,
                        handle,
                        out filterResult);

                    // save any filter error details.
                    filterResults[ii] = filterResult;

                    // save the modified item.
                    if (ServiceResult.IsGood(errors[ii]))
                    {
                        modifiedItems.Add(monitoredItems[ii]);
                    }
                }
            }

            // do any post processing.
            OnModifyMonitoredItemsComplete(systemContext, modifiedItems);
        }

        #region ModifyMonitoredItem Support Functions
        /// <summary>
        /// Called when a batch of monitored items has been modified.
        /// </summary>
        protected virtual void OnModifyMonitoredItemsComplete(ServerSystemContext context, IList<IMonitoredItem> monitoredItems)
        {
            // defined by the sub-class
        }

        /// <summary>
        /// Modifies the parameters for a monitored item.
        /// </summary>
        protected virtual ServiceResult ModifyMonitoredItem(
            ServerSystemContext context,
            DiagnosticsMasks diagnosticsMasks,
            TimestampsToReturn timestampsToReturn,
            IMonitoredItem monitoredItem,
            MonitoredItemModifyRequest itemToModify,
            NodeHandle handle,
            out MonitoringFilterResult filterResult)
        {
            filterResult = null;

            // check for valid monitored item.
            MonitoredItem datachangeItem = monitoredItem as MonitoredItem;

            // validate parameters.
            MonitoringParameters parameters = itemToModify.RequestedParameters;

            double previousSamplingInterval = datachangeItem.SamplingInterval;

            // check if the variable needs to be sampled.
            double samplingInterval = itemToModify.RequestedParameters.SamplingInterval;

            if (samplingInterval < 0)
            {
                samplingInterval = previousSamplingInterval;
            }

            // ensure minimum sampling interval is not exceeded.
            if (datachangeItem.AttributeId == Attributes.Value)
            {
                if (handle.Node is BaseVariableState variable && samplingInterval < variable.MinimumSamplingInterval)
                {
                    samplingInterval = variable.MinimumSamplingInterval;
                }
            }

            // put a large upper limit on sampling.
            if (samplingInterval == Double.MaxValue)
            {
                samplingInterval = 365 * 24 * 3600 * 1000.0;
            }

            // put an upper limit on queue size.
            uint queueSize = itemToModify.RequestedParameters.QueueSize;

            if (queueSize > m_maxQueueSize)
            {
                queueSize = m_maxQueueSize;
            }

            // validate the monitoring filter.
            Range euRange = null;
            MonitoringFilter filterToUse = null;

            ServiceResult error = ValidateMonitoringFilter(
                context,
                handle,
                datachangeItem.AttributeId,
                samplingInterval,
                queueSize,
                parameters.Filter,
                out filterToUse,
                out euRange,
                out filterResult);

            if (ServiceResult.IsBad(error))
            {
                return error;
            }

            // modify the monitored item parameters.
            error = datachangeItem.ModifyAttributes(
                diagnosticsMasks,
                timestampsToReturn,
                itemToModify.RequestedParameters.ClientHandle,
                filterToUse,
                filterToUse,
                euRange,
                samplingInterval,
                queueSize,
                itemToModify.RequestedParameters.DiscardOldest);

            // report change.
            if (ServiceResult.IsGood(error))
            {
                OnMonitoredItemModified(context, handle, datachangeItem);
            }

            return error;
        }

        /// <summary>
        /// Called after modifying a MonitoredItem.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The handle for the node.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        protected virtual void OnMonitoredItemModified(
            ServerSystemContext context,
            NodeHandle handle,
            MonitoredItem monitoredItem)
        {
            // overridden by the sub-class.
        }
        #endregion

        /// <summary>
        /// Deletes a set of monitored items.
        /// </summary>
        public virtual void DeleteMonitoredItems(
            OperationContext      context, 
            IList<IMonitoredItem> monitoredItems, 
            IList<bool>           processedItems, 
            IList<ServiceResult>  errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            List<IMonitoredItem> deletedItems = new List<IMonitoredItem>();

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    // skip items that have already been processed.
                    if (processedItems[ii] || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // check handle.
                    NodeHandle handle = IsHandleInNamespace(monitoredItems[ii].ManagerHandle);

                    if (handle == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    processedItems[ii] = true;

                    errors[ii] = DeleteMonitoredItem(
                        systemContext,
                        monitoredItems[ii],
                        handle);

                    // save the modified item.
                    if (ServiceResult.IsGood(errors[ii]))
                    {
                        deletedItems.Add(monitoredItems[ii]);
                        RemoveNodeFromComponentCache(systemContext, handle);
                    }
                }
            }

            // do any post processing.
            OnDeleteMonitoredItemsComplete(systemContext, deletedItems);
        }

        #region DeleteMonitoredItems Support Functions
        /// <summary>
        /// Called when a batch of monitored items has been modified.
        /// </summary>
        protected virtual void OnDeleteMonitoredItemsComplete(ServerSystemContext context, IList<IMonitoredItem> monitoredItems)
        {
            // defined by the sub-class
        }

        /// <summary>
        /// Deletes a monitored item.
        /// </summary>
        protected virtual ServiceResult DeleteMonitoredItem(
            ServerSystemContext context,
            IMonitoredItem monitoredItem,
            NodeHandle handle)
        {
            // check for valid monitored item.
            MonitoredItem datachangeItem = monitoredItem as MonitoredItem;

            // check if the node is already being monitored.
            MonitoredNode2 monitoredNode = null;

            if (m_monitoredNodes.TryGetValue(handle.NodeId, out monitoredNode))
            {
                monitoredNode.Remove(datachangeItem);

                // check if node is no longer being monitored.
                if (!monitoredNode.HasMonitoredItems)
                {
                    MonitoredNodes.Remove(handle.NodeId);
                }
            }

            // remove the monitored item.
            m_monitoredItems.Remove(monitoredItem.Id);

            // report change.
            OnMonitoredItemDeleted(context, handle, datachangeItem);

            return ServiceResult.Good;
        }

        /// <summary>
        /// Called after deleting a MonitoredItem.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The handle for the node.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        protected virtual void OnMonitoredItemDeleted(
            ServerSystemContext context,
            NodeHandle handle,
            MonitoredItem monitoredItem)
        {
            // overridden by the sub-class.
        }
        #endregion

        /// <summary>
        /// Changes the monitoring mode for a set of monitored items.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="monitoringMode">The monitoring mode.</param>
        /// <param name="monitoredItems">The set of monitoring items to update.</param>
        /// <param name="processedItems">Flags indicating which items have been processed.</param>
        /// <param name="errors">Any errors.</param>
        public virtual void SetMonitoringMode(
            OperationContext      context, 
            MonitoringMode        monitoringMode, 
            IList<IMonitoredItem> monitoredItems, 
            IList<bool>           processedItems, 
            IList<ServiceResult>  errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            List<IMonitoredItem> changedItems = new List<IMonitoredItem>();

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    // skip items that have already been processed.
                    if (processedItems[ii] || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // check handle.
                    NodeHandle handle = IsHandleInNamespace(monitoredItems[ii].ManagerHandle);

                    if (handle == null)
                    {
                        continue;
                    }

                    // indicate whether it was processed or not.
                    processedItems[ii] = true;

                    // update monitoring mode.
                    errors[ii] = SetMonitoringMode(
                        systemContext,
                        monitoredItems[ii],
                        monitoringMode,
                        handle);

                    // save the modified item.
                    if (ServiceResult.IsGood(errors[ii]))
                    {
                        changedItems.Add(monitoredItems[ii]);
                    }
                }
            }

            // do any post processing.
            OnSetMonitoringModeComplete(systemContext, changedItems);
        }

        #region SetMonitoringMode Support Functions
        /// <summary>
        /// Called when a batch of monitored items has their monitoring mode changed.
        /// </summary>
        protected virtual void OnSetMonitoringModeComplete(ServerSystemContext context, IList<IMonitoredItem> monitoredItems)
        {
            // defined by the sub-class
        }

        /// <summary>
        /// Changes the monitoring mode for an item.
        /// </summary>
        protected virtual ServiceResult SetMonitoringMode(
            ServerSystemContext context,
            IMonitoredItem monitoredItem,
            MonitoringMode monitoringMode,
            NodeHandle handle)
        {
            // check for valid monitored item.
            MonitoredItem datachangeItem = monitoredItem as MonitoredItem;

            // update monitoring mode.
            MonitoringMode previousMode = datachangeItem.SetMonitoringMode(monitoringMode);

            // must send the latest value after enabling a disabled item.
            if (monitoringMode == MonitoringMode.Reporting && previousMode == MonitoringMode.Disabled)
            {
                handle.MonitoredNode.QueueValue(context, handle.Node, datachangeItem);
            }

            // report change.
            if (previousMode != monitoringMode)
            {
                OnMonitoringModeChanged(
                    context,
                    handle,
                    datachangeItem,
                    previousMode,
                    monitoringMode);
            }

            return ServiceResult.Good;
        }

        /// <summary>
        /// Called after changing the MonitoringMode for a MonitoredItem.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="handle">The handle for the node.</param>
        /// <param name="monitoredItem">The monitored item.</param>
        /// <param name="previousMode">The previous monitoring mode.</param>
        /// <param name="monitoringMode">The current monitoring mode.</param>
        protected virtual void OnMonitoringModeChanged(
            ServerSystemContext context,
            NodeHandle handle,
            MonitoredItem monitoredItem,
            MonitoringMode previousMode,
            MonitoringMode monitoringMode)
        {
            // overridden by the sub-class.
        }
        #endregion
        #endregion

        #region INodeManager2 Members
        /// <summary>
        /// Called when a session is closed.
        /// </summary>
        public virtual void SessionClosing(OperationContext context, NodeId sessionId, bool deleteSubscriptions)
        {
        }

        /// <summary>
        /// Returns true if a node is in a view.
        /// </summary>
        public virtual bool IsNodeInView(OperationContext context, NodeId viewId, object nodeHandle)
        {
            NodeHandle handle = nodeHandle as NodeHandle;

            if (handle == null)
            {
                return false;
            }

            if (handle.Node != null)
            {
                return IsNodeInView(context, viewId, handle.Node);
            }

            return false;
        }
        #endregion

        #region ComponentCache Functions
        /// <summary>
        /// Stores a reference count for entries in the component cache.
        /// </summary>
        private class CacheEntry
        {
            public int RefCount;
            public NodeState Entry;
        }

        /// <summary>
        /// Looks up a component in cache.
        /// </summary>
        protected NodeState LookupNodeInComponentCache(ISystemContext context, NodeHandle handle)
        {
            lock (Lock)
            {
                if (m_componentCache == null)
                {
                    return null;
                }

                CacheEntry entry = null;

                if (!String.IsNullOrEmpty(handle.ComponentPath))
                {
                    if (m_componentCache.TryGetValue(handle.RootId, out entry))
                    {
                        return entry.Entry.FindChildBySymbolicName(context, handle.ComponentPath);
                    }
                }
                else
                {
                    if (m_componentCache.TryGetValue(handle.NodeId, out entry))
                    {
                        return entry.Entry;
                    }
                }

                return null;
            }
        }

        /// <summary>
        /// Removes a reference to a component in thecache.
        /// </summary>
        protected void RemoveNodeFromComponentCache(ISystemContext context, NodeHandle handle)
        {
            lock (Lock)
            {
                if (handle == null)
                {
                    return;
                }

                if (m_componentCache != null)
                {
                    NodeId nodeId = handle.NodeId;

                    if (!String.IsNullOrEmpty(handle.ComponentPath))
                    {
                        nodeId = handle.RootId;
                    }

                    CacheEntry entry = null;

                    if (m_componentCache.TryGetValue(nodeId, out entry))
                    {
                        entry.RefCount--;

                        if (entry.RefCount == 0)
                        {
                            m_componentCache.Remove(nodeId);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Adds a node to the component cache.
        /// </summary>
        protected NodeState AddNodeToComponentCache(ISystemContext context, NodeHandle handle, NodeState node)
        {
            lock (Lock)
            {
                if (handle == null)
                {
                    return node;
                }

                if (m_componentCache == null)
                {
                    m_componentCache = new Dictionary<NodeId, CacheEntry>();
                }

                // check if a component is actually specified.
                if (!String.IsNullOrEmpty(handle.ComponentPath))
                {
                    CacheEntry entry = null;

                    if (m_componentCache.TryGetValue(handle.RootId, out entry))
                    {
                        entry.RefCount++;

                        if (!String.IsNullOrEmpty(handle.ComponentPath))
                        {
                            return entry.Entry.FindChildBySymbolicName(context, handle.ComponentPath);
                        }

                        return entry.Entry;
                    }

                    NodeState root = node.GetHierarchyRoot();

                    if (root != null)
                    {
                        entry = new CacheEntry();
                        entry.RefCount = 1;
                        entry.Entry = root;
                        m_componentCache.Add(handle.RootId, entry);
                    }
                }

                // simply add the node to the cache.
                else
                {
                    CacheEntry entry = null;

                    if (m_componentCache.TryGetValue(handle.NodeId, out entry))
                    {
                        entry.RefCount++;
                        return entry.Entry;
                    }

                    entry = new CacheEntry();
                    entry.RefCount = 1;
                    entry.Entry = node;
                    m_componentCache.Add(handle.NodeId, entry);
                }

                return node;
            }
        }
        #endregion

        #region Private Fields
        private object m_lock = new object();
        private IServerInternal m_server;
        private ServerSystemContext m_systemContext;
        private string[] m_namespaceUris;
        private ushort[] m_namespaceIndexes;
        private Dictionary<uint, IDataChangeMonitoredItem> m_monitoredItems;
        private Dictionary<NodeId, MonitoredNode2> m_monitoredNodes;
        private Dictionary<NodeId, CacheEntry> m_componentCache;
        private NodeIdDictionary<NodeState> m_predefinedNodes;
        private List<NodeState> m_rootNotifiers;
        private uint m_maxQueueSize;
        private string m_aliasRoot;
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs(36,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs(31,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs(35,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs(34,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs(1911,54): error CS0128: A local variable or function named 'propertyState' is already defined in this scope,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs(1915,29): error CS0165: Use of unassigned local variable 'propertyState',D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs(31,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs(35,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs(34,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\CustomNodeManager.cs(36,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 8 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.Xml;
using System.IO;
using System.Threading;
using System.Reflection;

namespace Opc.Ua.Server
{
    /// <summary>
    /// A node manager for a variety of test data.
    /// </summary>
    [Obsolete("Class replaced by Opc.Ua.Server.CustomNodeManager2")]
    public class CustomNodeManager : INodeManager, INodeIdFactory, IDisposable
    {
        #region Constructors
        /// <summary>
        /// Initializes the node manager.
        /// </summary>
        public CustomNodeManager(IServerInternal server)
        {
            // save a reference to the server that owns the node manager.
            m_server = server;  
            
            // create the default context.
            m_systemContext = m_server.DefaultSystemContext.Copy();

            m_systemContext.SystemHandle = null;
            m_systemContext.NodeIdFactory = this;

            // create the table of nodes. 
            m_predefinedNodes = new NodeIdDictionary<NodeState>();
            m_rootNotifiers = new List<NodeState>();
            m_sampledItems = new List<DataChangeMonitoredItem>();
            m_minimumSamplingInterval = 100;
        }
        #endregion
        
        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {   
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {  
            if (disposing)
            {
                lock (m_lock)
                {
                    Utils.SilentDispose(m_samplingTimer);
                    m_samplingTimer = null;

                    if (m_predefinedNodes != null)
                    {
                        foreach (NodeState node in m_predefinedNodes.Values)
                        {
                            Utils.SilentDispose(node);
                        }
                    }
                }
            }
        }
        #endregion

        #region INodeIdFactory Members
        /// <summary>
        /// Creates the NodeId for the specified node.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="node">The node.</param>
        /// <returns>The new NodeId.</returns>
        public virtual NodeId New(ISystemContext context, NodeState node)
        {
            return node.NodeId;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Acquires the lock on the node manager.
        /// </summary>
        public object Lock
        {
            get { return m_lock; }
        }
        #endregion

        #region Protected Members
        /// <summary>
        /// The server that the node manager belongs to.
        /// </summary>
        protected IServerInternal Server
        {
            get { return m_server; }
        }

        /// <summary>
        /// The default context to use.
        /// </summary>
        protected ServerSystemContext SystemContext
        {
            get { return m_systemContext; }
        }

        /// <summary>
        /// The predefined nodes managed by the node manager.
        /// </summary>
        protected NodeIdDictionary<NodeState> PredefinedNodes
        {
            get { return m_predefinedNodes; }
        }

        /// <summary>
        /// The root notifiers for the node manager.
        /// </summary>
        protected List<NodeState> RootNotifiers
        {
            get { return m_rootNotifiers; }
        }

        /// <summary>
        /// Returns true if the namespace for the node id is one of the namespaces managed by the node manager.
        /// </summary>
        /// <param name="nodeId">The node id to check.</param>
        /// <returns>True if the namespace is one of the nodes.</returns>
        protected virtual bool IsNodeIdInNamespace(NodeId nodeId)
        {
            if (NodeId.IsNull(nodeId))
            {
                return false;
            }

            // quickly exclude nodes that not in the namespace.
            for (int ii = 0; ii < m_namespaceIndexes.Length; ii++)
            {
                if (nodeId.NamespaceIndex == m_namespaceIndexes[ii])
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Returns the node if the handle refers to a node managed by this manager.
        /// </summary>
        /// <param name="managerHandle">The handle to check.</param>
        /// <returns>Non-null if the handle belongs to the node manager.</returns>
        protected virtual NodeState IsHandleInNamespace(object managerHandle)
        {
            NodeState source = managerHandle as NodeState;

            if (source == null)
            {
                return null;
            }

            if (!IsNodeIdInNamespace(source.NodeId))
            {
                return null;
            }

            return source;
        }

        /// <summary>
        /// Returns the state object for the specified node if it exists.
        /// </summary>
        public NodeState Find(NodeId nodeId)
        {
            lock (Lock)
            {
                NodeState node = null;

                if (!PredefinedNodes.TryGetValue(nodeId, out node))
                {
                    return null;
                }

                return node;
            }
        }

        /// <summary>
        /// Creates a new instance and assigns unique identifiers to all children.
        /// </summary>
        /// <param name="context">The operation context.</param>
        /// <param name="parentId">An optional parent identifier.</param>
        /// <param name="referenceTypeId">The reference type from the parent.</param>
        /// <param name="browseName">The browse name.</param>
        /// <param name="instance">The instance to create.</param>
        /// <returns>The new node id.</returns>
        public NodeId CreateNode(
            ServerSystemContext context,
            NodeId parentId,
            NodeId referenceTypeId,
            QualifiedName browseName,
            BaseInstanceState instance)
        {
            ServerSystemContext contextToUse = (ServerSystemContext)m_systemContext.Copy(context);

            lock (Lock)
            {
                instance.ReferenceTypeId = referenceTypeId;

                NodeState parent = null;

                if (parentId != null)
                {
                    if (!PredefinedNodes.TryGetValue(parentId, out parent))
                    {
                        throw ServiceResultException.Create(
                            StatusCodes.BadNodeIdUnknown,
                            "Cannot find parent with id: {0}",
                            parentId);
                    }

                    parent.AddChild(instance);
                }

                instance.Create(contextToUse, null, browseName, null, true);
                AddPredefinedNode(contextToUse, instance);

                return instance.NodeId;
            }
        }

        /// <summary>
        /// Deletes a node and all of its children.
        /// </summary>
        public bool DeleteNode(
            ServerSystemContext context,
            NodeId nodeId)
        {
            ServerSystemContext contextToUse = m_systemContext.Copy(context);

            bool found = false;
            List<LocalReference> referencesToRemove = new List<LocalReference>();

            lock (Lock)
            {
                NodeState node = null;

                if (PredefinedNodes.TryGetValue(nodeId, out node))
                {
                    RemovePredefinedNode(contextToUse, node, referencesToRemove);
                    found = true;
                }

                RemoveRootNotifier(node);
            }

            // must release the lock before removing cross references to other node managers.
            if (referencesToRemove.Count > 0)
            {
                Server.NodeManager.RemoveReferences(referencesToRemove);
            }

            return found;
        }
        #endregion

        #region INodeManager Members
        /// <summary>
        /// Returns the namespaces used by the node manager.
        /// </summary>
        /// <remarks>
        /// All NodeIds exposed by the node manager must be qualified by a namespace URI. This property
        /// returns the URIs used by the node manager. In this example all NodeIds use a single URI.
        /// </remarks>
        public virtual IEnumerable<string> NamespaceUris
        {
            get 
            { 
                return m_namespaceUris; 
            }
            
            protected set
            {
                if (value != null)
                {
                    m_namespaceUris = new List<string>(value);
                }
                else
                {
                    m_namespaceUris = new List<string>();
                }

                m_namespaceIndexes = new ushort[m_namespaceUris.Count];
            }
        }

        /// <summary>
        /// Does any initialization required before the address space can be used.
        /// </summary>
        /// <remarks>
        /// The externalReferences is an out parameter that allows the node manager to link to nodes
        /// in other node managers. For example, the 'Objects' node is managed by the CoreNodeManager and
        /// should have a reference to the root folder node(s) exposed by this node manager.  
        /// </remarks>
        public virtual void CreateAddressSpace(IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            lock (Lock)
            {
                // add the uris to the server's namespace table and cache the indexes.
                for (int ii = 0; ii < m_namespaceUris.Count; ii++)
                {
                    m_namespaceIndexes[ii] = m_server.NamespaceUris.GetIndexOrAppend(m_namespaceUris[ii]);
                }

                LoadPredefinedNodes(m_systemContext, externalReferences);
            }
        }

        #region CreateAddressSpace Support Functions
        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        public virtual void LoadPredefinedNodes(
            ISystemContext context, 
            Assembly assembly,
            string resourcePath,
            IDictionary<NodeId,IList<IReference>> externalReferences)
        {
            // load the predefined nodes from an XML document.
            NodeStateCollection predefinedNodes = new NodeStateCollection();
            predefinedNodes.LoadFromResource(context, resourcePath, assembly, true);

            // add the predefined nodes to the node manager.
            for (int ii = 0; ii < predefinedNodes.Count; ii++)
            {
                AddPredefinedNode(context, predefinedNodes[ii]);
            }

            // ensure the reverse references exist.
            AddReverseReferences(externalReferences);
        }

        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        protected virtual NodeStateCollection LoadPredefinedNodes(ISystemContext context)
        {
            return new NodeStateCollection();
        }

        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        protected virtual void LoadPredefinedNodes(
            ISystemContext context, 
            IDictionary<NodeId,IList<IReference>> externalReferences)
        {
            // load the predefined nodes from an XML document.
            NodeStateCollection predefinedNodes = LoadPredefinedNodes(context);

            // add the predefined nodes to the node manager.
            for (int ii = 0; ii < predefinedNodes.Count; ii++)
            {
                AddPredefinedNode(context, predefinedNodes[ii]);
            }

            // ensure the reverse references exist.
            AddReverseReferences(externalReferences);
        }

        /// <summary>
        /// Replaces the generic node with a node specific to the model.
        /// </summary>
        protected virtual NodeState AddBehaviourToPredefinedNode(ISystemContext context, NodeState predefinedNode)
        {
            BaseObjectState passiveNode = predefinedNode as BaseObjectState; 
            
            if (passiveNode == null)
            {
                return predefinedNode;
            }

            return predefinedNode;
        }

        /// <summary>
        /// Recursively indexes the node and its children.
        /// </summary>
        protected virtual void AddPredefinedNode(ISystemContext context, NodeState node)
        {
            NodeState activeNode = AddBehaviourToPredefinedNode(context, node);
            m_predefinedNodes[activeNode.NodeId] = activeNode;
            
            BaseTypeState type = activeNode as BaseTypeState;

            if (type != null)
            {
                AddTypesToTypeTree(type);
            }

            List<BaseInstanceState> children = new List<BaseInstanceState>();
            activeNode.GetChildren(context, children);

            for (int ii = 0; ii < children.Count; ii++)
            {
                AddPredefinedNode(context, children[ii]);
            }
        }

        /// <summary>
        /// Recursively indexes the node and its children.
        /// </summary>
        protected virtual void RemovePredefinedNode(
            ISystemContext context, 
            NodeState node, 
            List<LocalReference> referencesToRemove)
        {
            m_predefinedNodes.Remove(node.NodeId);
            node.UpdateChangeMasks(NodeStateChangeMasks.Deleted);
            node.ClearChangeMasks(context, false);
            OnNodeRemoved(node);

            // remove from the parent.
            BaseInstanceState instance = node as BaseInstanceState;

            if (instance?.Parent != null)
            {
                instance.Parent.RemoveChild(instance);
            }

            // remove children.
            List<BaseInstanceState> children = new List<BaseInstanceState>();
            node.GetChildren(context, children);

            for (int ii = 0; ii < children.Count; ii++)
            {
                node.RemoveChild(children[ii]);
            }

            for (int ii = 0; ii < children.Count; ii++)
            {
                RemovePredefinedNode(context, children[ii], referencesToRemove);
            }
                        
            // remove from type table.
            BaseTypeState type = node as BaseTypeState;

            if (type != null)
            {
                m_server.TypeTree.Remove(type.NodeId);
            }
            
            // remove inverse references.
            List<IReference> references = new List<IReference>();
            node.GetReferences(context, references);

            for (int ii = 0; ii < references.Count; ii++)
            {
                IReference reference = references[ii];

                if (reference.TargetId.IsAbsolute)
                {
                    continue;
                }

                LocalReference referenceToRemove = new LocalReference(
                    (NodeId)reference.TargetId,
                    reference.ReferenceTypeId,
                    reference.IsInverse,
                    node.NodeId);

                referencesToRemove.Add(referenceToRemove);
            }
        }

        /// <summary>
        /// Called after a node has been deleted.
        /// </summary>
        protected virtual void OnNodeRemoved(NodeState node)
        {
            // overridden by the sub-class.            
        }

        /// <summary>
        /// Add the node to the set of root notifiers.
        /// </summary>
        protected virtual void AddRootNotifier(NodeState notifier)
        {
            for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
            {
                if (Object.ReferenceEquals(notifier, m_rootNotifiers[ii]))
                {
                    return;
                }
            }

            m_rootNotifiers.Add(notifier);

            // subscribe to existing events.
            if (m_server.EventManager != null)
            {
                IList<IEventMonitoredItem> monitoredItems = m_server.EventManager.GetMonitoredItems();

                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    if (monitoredItems[ii].MonitoringAllEvents)
                    {
                        SubscribeToAllEvents(
                            SystemContext,
                            monitoredItems[ii],
                            true,
                            notifier);
                    }
                }
            }
        }

        /// <summary>
        /// Remove the node from the set of root notifiers.
        /// </summary>
        protected virtual void RemoveRootNotifier(NodeState notifier)
        {
            for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
            {
                if (Object.ReferenceEquals(notifier, m_rootNotifiers[ii]))
                {
                    m_rootNotifiers.RemoveAt(ii);
                    break;
                }
            }
        }

        /// <summary>
        /// Ensures that all reverse references exist.
        /// </summary>
        /// <param name="externalReferences">A list of references to add to external targets.</param>
        protected virtual void AddReverseReferences(IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            foreach (NodeState source in m_predefinedNodes.Values)
            {
                // assign a default value to any variable value.
                BaseVariableState variable = source as BaseVariableState; 
                
                if (variable != null && variable.Value == null)
                {
                    variable.Value = TypeInfo.GetDefaultValue(variable.DataType, variable.ValueRank, Server.TypeTree);
                }

                // add reference from supertype for type nodes.
                BaseTypeState type = source as BaseTypeState;

                if (type != null && !NodeId.IsNull(type.SuperTypeId))
                {
                    if (!IsNodeIdInNamespace(type.SuperTypeId))
                    {
                        AddExternalReference(
                            type.SuperTypeId,
                            ReferenceTypeIds.HasSubtype,
                            false,
                            type.NodeId,
                            externalReferences);
                    }
                }

                IList<IReference> references = new List<IReference>();
                source.GetReferences(SystemContext, references);

                for (int ii = 0; ii < references.Count; ii++)
                {
                    IReference reference = references[ii]; 

                    // nothing to do with external nodes.
                    if (reference.TargetId == null || reference.TargetId.IsAbsolute)
                    {
                        continue;
                    }

                    NodeId targetId = (NodeId)reference.TargetId;
                    
                    // add inverse reference to internal targets.
                    NodeState target = null;

                    if (m_predefinedNodes.TryGetValue(targetId, out target))
                    {
                        if (!target.ReferenceExists(reference.ReferenceTypeId, !reference.IsInverse, source.NodeId))
                        {
                            target.AddReference(reference.ReferenceTypeId, !reference.IsInverse, source.NodeId);
                        }

                        continue;
                    }
                    
                    // check for inverse references to external notifiers.
                    if (reference.IsInverse && reference.ReferenceTypeId == ReferenceTypeIds.HasNotifier)
                    {
                        AddRootNotifier(source);
                    }

                    // nothing more to do for references to nodes managed by this manager.
                    if (IsNodeIdInNamespace(targetId))
                    {
                        continue;
                    }

                    // add external reference.
                    AddExternalReference(
                        targetId,
                        reference.ReferenceTypeId,
                        !reference.IsInverse,
                        source.NodeId,
                        externalReferences);
                }
            }
        }

        /// <summary>
        /// Adds an external reference to the dictionary.
        /// </summary>
        protected void AddExternalReference(
            NodeId sourceId,
            NodeId referenceTypeId,
            bool isInverse,
            NodeId targetId,
            IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            // get list of references to external nodes.
            IList<IReference> referencesToAdd = null;

            if (!externalReferences.TryGetValue(sourceId, out referencesToAdd))
            {
                externalReferences[sourceId] = referencesToAdd = new List<IReference>();
            }

            // add reserve reference from external node.
            ReferenceNode referenceToAdd = new ReferenceNode();

            referenceToAdd.ReferenceTypeId = referenceTypeId;
            referenceToAdd.IsInverse = isInverse;
            referenceToAdd.TargetId = targetId;

            referencesToAdd.Add(referenceToAdd);
        }

        /// <summary>
        /// Recursively adds the types to the type tree.
        /// </summary>
        protected void AddTypesToTypeTree(BaseTypeState type)
        {
            if (!NodeId.IsNull(type.SuperTypeId))
            {
                if (!Server.TypeTree.IsKnown(type.SuperTypeId))
                {
                    AddTypesToTypeTree(type.SuperTypeId);
                }
            }

            if (type.NodeClass != NodeClass.ReferenceType)
            {
                Server.TypeTree.AddSubtype(type.NodeId, type.SuperTypeId);
            }
            else
            {
                Server.TypeTree.AddReferenceSubtype(type.NodeId, type.SuperTypeId, type.BrowseName);
            }
        }

        /// <summary>
        /// Recursively adds the types to the type tree.
        /// </summary>
        protected void AddTypesToTypeTree(NodeId typeId)
        {
            BaseTypeState type = Find(typeId) as BaseTypeState;

            if (type == null)
            {
                return;
            }

            AddTypesToTypeTree(type);
        }

        /// <summary>
        /// Finds the specified and checks if it is of the expected type. 
        /// </summary>
        /// <returns>Returns null if not found or not of the correct type.</returns>
        public NodeState FindPredefinedNode(NodeId nodeId, Type expectedType)
        {
            if (nodeId == null)
            {
                return null;
            }

            NodeState node = null;

            if (!PredefinedNodes.TryGetValue(nodeId, out node))
            {
                return null;
            }

            if (expectedType != null)
            {
                if (!expectedType.IsInstanceOfType(node))
                {
                    return null;
                }
            }
                
            return node;
        }
        #endregion

        /// <summary>
        /// Frees any resources allocated for the address space.
        /// </summary>
        public virtual void DeleteAddressSpace()
        {
            lock (Lock)
            {
                m_predefinedNodes.Clear();
            }
        }

        /// <summary>
        /// Returns a unique handle for the node.
        /// </summary>
        /// <remarks>
        /// This must efficiently determine whether the node belongs to the node manager. If it does belong to 
        /// NodeManager it should return a handle that does not require the NodeId to be validated again when
        /// the handle is passed into other methods such as 'Read' or 'Write'.
        /// </remarks>
        public virtual object GetManagerHandle(NodeId nodeId)
        {
            lock (Lock)
            {
                return GetManagerHandle(m_systemContext, nodeId, null);
            }
        }

        /// <summary>
        /// Returns a unique handle for the node.
        /// </summary>
        /// <remarks>
        /// This must efficiently determine whether the node belongs to the node manager. If it does belong to 
        /// NodeManager it should return a handle that does not require the NodeId to be validated again when
        /// the handle is passed into other methods such as 'Read' or 'Write'.
        /// </remarks>
        protected virtual object GetManagerHandle(ISystemContext context, NodeId nodeId, IDictionary<NodeId,NodeState> cache)
        {
            lock (Lock)
            {
                // quickly exclude nodes that not in the namespace.
                if (!IsNodeIdInNamespace(nodeId))
                {
                    return null;
                }

                // lookup the node.
                NodeState node = null;

                if (!m_predefinedNodes.TryGetValue(nodeId, out node))
                {
                    return null;
                }

                return node;
            }
        }

        /// <summary>
        /// This method is used to add bi-directional references to nodes from other node managers.
        /// </summary>
        /// <remarks>
        /// The additional references are optional, however, the NodeManager should support them.
        /// </remarks>
        public virtual void AddReferences(IDictionary<NodeId, IList<IReference>> references)
        {
            lock (Lock)
            {
                foreach (KeyValuePair<NodeId, IList<IReference>> current in references)
                {
                    // check for valid handle.
                    NodeState source = GetManagerHandle(m_systemContext, current.Key, null) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // add reference to external target.
                    foreach (IReference reference in current.Value)
                    {
                        source.AddReference(reference.ReferenceTypeId, reference.IsInverse, reference.TargetId);
                    }
                }
            }
        }
        
        /// <summary>
        /// This method is used to delete bi-directional references to nodes from other node managers.
        /// </summary>
        public virtual ServiceResult DeleteReference(
            object         sourceHandle, 
            NodeId         referenceTypeId, 
            bool           isInverse, 
            ExpandedNodeId targetId, 
            bool           deleteBiDirectional)
        {
            lock (Lock)
            {
                // check for valid handle.
                NodeState source = IsHandleInNamespace(sourceHandle);

                if (source == null)
                {
                    return StatusCodes.BadNodeIdUnknown;
                }

                source.RemoveReference(referenceTypeId, isInverse, targetId);

                if (deleteBiDirectional)
                {
                    // check if the target is also managed by the node manager.
                    if (!targetId.IsAbsolute)
                    {
                        NodeState target = GetManagerHandle(m_systemContext, (NodeId)targetId, null) as NodeState;

                        target?.RemoveReference(referenceTypeId, !isInverse, source.NodeId);
                    }
                }

                return ServiceResult.Good;
            }
        }

        /// <summary>
        /// Returns the basic metadata for the node. Returns null if the node does not exist.
        /// </summary>
        /// <remarks>
        /// This method validates any placeholder handle.
        /// </remarks>
        public virtual NodeMetadata GetNodeMetadata(
            OperationContext context, 
            object           targetHandle, 
            BrowseResultMask resultMask)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                // check for valid handle.
                NodeState target = IsHandleInNamespace(targetHandle);

                if (target == null)
                {
                    return null;                
                }

                // validate node.
                if (!ValidateNode(systemContext, target))
                {
                    return null;
                }

                // read the attributes.
                List<object> values = target.ReadAttributes(
                    systemContext,
                    Attributes.WriteMask,
                    Attributes.UserWriteMask,
                    Attributes.DataType,
                    Attributes.ValueRank,
                    Attributes.ArrayDimensions,
                    Attributes.AccessLevel,
                    Attributes.UserAccessLevel,
                    Attributes.EventNotifier,
                    Attributes.Executable,
                    Attributes.UserExecutable);

                // construct the metadata object.

                NodeMetadata metadata = new NodeMetadata(target, target.NodeId);

                metadata.NodeClass = target.NodeClass;
                metadata.BrowseName = target.BrowseName;
                metadata.DisplayName = target.DisplayName;

                if (values[0] != null && values[1] != null)
                {
                    metadata.WriteMask = (AttributeWriteMask)(((uint)values[0]) & ((uint)values[1]));
                }

                metadata.DataType = (NodeId)values[2];

                if (values[3] != null)
                {
                    metadata.ValueRank = (int)values[3];
                }

                metadata.ArrayDimensions = (IList<uint>)values[4];
                
                if (values[5] != null && values[6] != null)
                {
                    metadata.AccessLevel = (byte)(((byte)values[5]) & ((byte)values[6]));
                }

                if (values[7] != null)
                {
                    metadata.EventNotifier = (byte)values[7];
                }

                if (values[8] != null && values[9] != null)
                {
                    metadata.Executable = (((bool)values[8]) && ((bool)values[9]));
                }

                // get instance references.
                BaseInstanceState instance = target as BaseInstanceState;

                if (instance != null)
                {
                    metadata.TypeDefinition = instance.TypeDefinitionId;
                    metadata.ModellingRule = instance.ModellingRuleId;
                }

                // fill in the common attributes.
                return metadata;
            }
        }

        /// <summary>
        /// Browses the references from a node managed by the node manager.
        /// </summary>
        /// <remarks>
        /// The continuation point is created for every browse operation and contains the browse parameters.
        /// The node manager can store its state information in the Data and Index properties.
        /// </remarks>
        public virtual void Browse(
            OperationContext            context, 
            ref ContinuationPoint       continuationPoint, 
            IList<ReferenceDescription> references)
        {
            if (continuationPoint == null) throw new ArgumentNullException(nameof(continuationPoint));
            if (references == null) throw new ArgumentNullException(nameof(references));

            // check for view.
            if (!ViewDescription.IsDefault(continuationPoint.View))
            {
                throw new ServiceResultException(StatusCodes.BadViewIdUnknown);
            }

            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                // verify that the node exists.
                NodeState source = IsHandleInNamespace(continuationPoint.NodeToBrowse);

                if (source == null)
                {
                    throw new ServiceResultException(StatusCodes.BadNodeIdUnknown);
                }

                // validate node.
                if (!ValidateNode(systemContext, source))
                {
                    throw new ServiceResultException(StatusCodes.BadNodeIdUnknown);
                }

                // check for previous continuation point.
                INodeBrowser browser = continuationPoint.Data as INodeBrowser;

                // fetch list of references.
                if (browser == null)
                {
                    // create a new browser.
                    browser = source.CreateBrowser(
                        systemContext,
                        continuationPoint.View,
                        continuationPoint.ReferenceTypeId,
                        continuationPoint.IncludeSubtypes,
                        continuationPoint.BrowseDirection,
                        null,
                        null,
                        false);
                }

                // apply filters to references.
                for (IReference reference = browser.Next(); reference != null; reference = browser.Next())
                {
                    // create the type definition reference.        
                    ReferenceDescription description = GetReferenceDescription(context, reference, continuationPoint);

                    if (description == null)
                    {
                        continue;
                    }

                    // check if limit reached.
                    if (continuationPoint.MaxResultsToReturn != 0 && references.Count >= continuationPoint.MaxResultsToReturn)
                    {
                        browser.Push(reference);
                        continuationPoint.Data = browser;
                        return;
                    }

                    references.Add(description);
                }

                // release the continuation point if all done.
                continuationPoint.Dispose();
                continuationPoint = null;
            }
        }

        #region Browse Support Functions
        /// <summary>
        /// Returns the references for the node that meets the criteria specified.
        /// </summary>
        private ReferenceDescription GetReferenceDescription(
            OperationContext context,
            IReference reference,
            ContinuationPoint continuationPoint)
        {
            // create the type definition reference.        
            ReferenceDescription description = new ReferenceDescription();

            description.NodeId = reference.TargetId;
            description.SetReferenceType(continuationPoint.ResultMask, reference.ReferenceTypeId, !reference.IsInverse);

            // do not cache target parameters for remote nodes.
            if (reference.TargetId.IsAbsolute)
            {
                // only return remote references if no node class filter is specified.
                if (continuationPoint.NodeClassMask != 0)
                {
                    return null;
                }

                return description;
            }

            NodeState target = null;

            // check for local reference.
            NodeStateReference referenceInfo = reference as NodeStateReference;

            if (referenceInfo != null)
            {
                target = referenceInfo.Target;
            }

            // check for internal reference.
            if (target == null)
            {
                NodeId targetId = (NodeId)reference.TargetId;

                if (IsNodeIdInNamespace(targetId))
                {
                    if (!PredefinedNodes.TryGetValue(targetId, out target))
                    {
                        target = null;
                    }
                }
            }

            // the target may be a reference to a node in another node manager. In these cases
            // the target attributes must be fetched by the caller. The Unfiltered flag tells the
            // caller to do that.
            if (target == null)
            {
                description.Unfiltered = true;
                return description;
            }

            // apply node class filter.
            if (continuationPoint.NodeClassMask != 0 && ((continuationPoint.NodeClassMask & (uint)target.NodeClass) == 0))
            {
                return null;
            }

            NodeId typeDefinition = null;

            BaseInstanceState instance = target as BaseInstanceState;

            if (instance != null)
            {
                typeDefinition = instance.TypeDefinitionId;
            }

            // set target attributes.
            description.SetTargetAttributes(
                continuationPoint.ResultMask,
                target.NodeClass,
                target.BrowseName,
                target.DisplayName,
                typeDefinition);

            return description;
        }
        #endregion

        /// <summary>
        /// Returns the target of the specified browse path fragment(s).
        /// </summary>
        /// <remarks>
        /// If reference exists but the node manager does not know the browse name it must 
        /// return the NodeId as an unresolvedTargetIds. The caller will try to check the
        /// browse name. 
        /// </remarks>
        public virtual void TranslateBrowsePath(
            OperationContext      context, 
            object                sourceHandle, 
            RelativePathElement   relativePath, 
            IList<ExpandedNodeId> targetIds, 
            IList<NodeId>         unresolvedTargetIds)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();

            lock (Lock)
            {
                // verify that the node exists.
                NodeState source = IsHandleInNamespace(sourceHandle);

                if (source == null)
                {
                    return;
                }

                // validate node.
                if (!ValidateNode(systemContext, source))
                {
                    return;
                }

                // get list of references that relative path.
                INodeBrowser browser = source.CreateBrowser(
                    systemContext,
                    null,
                    relativePath.ReferenceTypeId,
                    relativePath.IncludeSubtypes,
                    (relativePath.IsInverse) ? BrowseDirection.Inverse : BrowseDirection.Forward,
                    relativePath.TargetName,
                    null,
                    false);

                // check the browse names.
                try
                {
                    for (IReference reference = browser.Next(); reference != null; reference = browser.Next())
                    {
                        // ignore unknown external references.
                        if (reference.TargetId.IsAbsolute)
                        {
                            continue;
                        }

                        NodeState target = null;

                        // check for local reference.
                        NodeStateReference referenceInfo = reference as NodeStateReference;

                        if (referenceInfo != null)
                        {
                            target = referenceInfo.Target;
                        }

                        if (target == null)
                        {
                            NodeId targetId = (NodeId)reference.TargetId;

                            // the target may be a reference to a node in another node manager.
                            if (!IsNodeIdInNamespace(targetId))
                            {
                                unresolvedTargetIds.Add((NodeId)reference.TargetId);
                                continue;
                            }

                            // look up the target manually.
                            target = GetManagerHandle(systemContext, targetId, operationCache) as NodeState;

                            if (target == null)
                            {
                                continue;
                            }
                        }

                        // check browse name.
                        if (target.BrowseName == relativePath.TargetName)
                        {
                            if (!targetIds.Contains(reference.TargetId))
                            {
                                targetIds.Add(reference.TargetId);
                            }
                        }
                    }
                }
                finally
                {
                    browser.Dispose();
                }
            }
        }
        
        /// <summary>
        /// Reads the value for the specified attribute.
        /// </summary>
        public virtual void Read(
            OperationContext     context, 
            double               maxAge, 
            IList<ReadValueId>   nodesToRead, 
            IList<DataValue>     values, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<ReadWriteOperationState> nodesToValidate = new List<ReadWriteOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToRead.Count; ii++)
                {                    
                    ReadValueId nodeToRead = nodesToRead[ii];

                    // skip items that have already been processed.
                    if (nodeToRead.Processed)
                    {
                        continue;
                    }
                    
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, nodeToRead.NodeId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToRead.Processed = true;
                    
                    // create an initial value.
                    DataValue value = values[ii] = new DataValue();
                    
                    value.Value           = null;
                    value.ServerTimestamp = DateTime.UtcNow;
                    value.SourceTimestamp = DateTime.MinValue;
                    value.StatusCode      = StatusCodes.Good;

                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        
                        // must validate node in a seperate operation.
                        ReadWriteOperationState operation = new ReadWriteOperationState();
                        
                        operation.Source = source;
                        operation.Index = ii;

                        nodesToValidate.Add(operation);
                        
                        continue;
                    }

                    // read the attribute value.
                    errors[ii] = source.ReadAttribute(
                        systemContext,
                        nodeToRead.AttributeId,
                        nodeToRead.ParsedIndexRange,
                        nodeToRead.DataEncoding,
                        value);
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    ReadWriteOperationState operation = nodesToValidate[ii];

                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }
                    
                    ReadValueId nodeToRead = nodesToRead[operation.Index];
                    DataValue value = values[operation.Index];

                    // update the attribute value.
                    errors[operation.Index] = operation.Source.ReadAttribute(
                        systemContext,
                        nodeToRead.AttributeId,
                        nodeToRead.ParsedIndexRange,
                        nodeToRead.DataEncoding,
                        value);
                }
            }
        }        
        
        /// <summary>
        /// Stores the state of a call method operation.
        /// </summary>
        private struct ReadWriteOperationState
        {
            public NodeState Source;
            public int Index;
        }        
        
        /// <summary>
        /// Verifies that the specified node exists.
        /// </summary>
        protected virtual bool ValidateNode(ServerSystemContext context, NodeState node)
        {
            // validate node only if required.
            if (node.ValidationRequired)
            {
                return node.Validate(context);
            }

            return true;
        }
        
        /// <summary>
        /// Reads the history for the specified nodes.
        /// </summary>
        public virtual void HistoryRead(
            OperationContext          context, 
            HistoryReadDetails        details, 
            TimestampsToReturn        timestampsToReturn, 
            bool                      releaseContinuationPoints, 
            IList<HistoryReadValueId> nodesToRead, 
            IList<HistoryReadResult>  results, 
            IList<ServiceResult>      errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<ReadWriteOperationState> nodesToValidate = new List<ReadWriteOperationState>();
            List<ReadWriteOperationState> readsToComplete = new List<ReadWriteOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToRead.Count; ii++)
                {                    
                    HistoryReadValueId nodeToRead = nodesToRead[ii];

                    // skip items that have already been processed.
                    if (nodeToRead.Processed)
                    {
                        continue;
                    }
                    
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, nodeToRead.NodeId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToRead.Processed = true;

                    // only variables supported.
                    BaseVariableState variable = source as BaseVariableState;

                    if (variable == null)
                    {
                        errors[ii] = StatusCodes.BadHistoryOperationUnsupported;
                        continue;
                    }
                    
                    results[ii] = new HistoryReadResult();
                    
                    ReadWriteOperationState operation = new ReadWriteOperationState();
                    
                    operation.Source = source;
                    operation.Index = ii;

                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        // must validate node in a seperate operation.
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        nodesToValidate.Add(operation);                        
                        continue;
                    }

                    // read the data.
                    readsToComplete.Add(operation);
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    ReadWriteOperationState operation = nodesToValidate[ii];

                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }

                    readsToComplete.Add(operation);
                }
            }

            // reads the data without holding onto the lock.
            for (int ii = 0; ii < readsToComplete.Count; ii++)
            {
                ReadWriteOperationState operation = readsToComplete[ii];

                errors[operation.Index] = HistoryRead(
                    systemContext,
                    operation.Source,
                    details,
                    timestampsToReturn,
                    releaseContinuationPoints,
                    nodesToRead[operation.Index],
                    results[operation.Index]);
            }
        }

        /// <summary>
        /// Reads the history for a single node which has already been validated.
        /// </summary>
        protected virtual ServiceResult HistoryRead(
            ISystemContext context, 
            NodeState           source,
            HistoryReadDetails  details, 
            TimestampsToReturn  timestampsToReturn, 
            bool                releaseContinuationPoints, 
            HistoryReadValueId  nodesToRead, 
            HistoryReadResult   result)
        {
            // check for variable.
            BaseVariableState variable = source as BaseVariableState;

            if (variable == null)
            {
                return StatusCodes.BadHistoryOperationUnsupported;
            }

            // check for access.
            lock (Lock)
            {
                if ((variable.AccessLevel & AccessLevels.HistoryRead) == 0)
                {
                    return StatusCodes.BadNotReadable;
                }
            }

            // handle read raw.
            ReadRawModifiedDetails readRawDetails = details as ReadRawModifiedDetails;

            if (readRawDetails != null)
            {
                return HistoryReadRaw(
                    context,
                    variable,
                    readRawDetails,
                    timestampsToReturn,
                    releaseContinuationPoints,
                    nodesToRead,
                    result);
            }

            // handle read processed.
            ReadProcessedDetails readProcessedDetails = details as ReadProcessedDetails;

            if (readProcessedDetails != null)
            {
                return HistoryReadProcessed(
                    context,
                    variable,
                    readProcessedDetails,
                    timestampsToReturn,
                    releaseContinuationPoints,
                    nodesToRead,
                    result);
            }

            // handle read processed.
            ReadAtTimeDetails readAtTimeDetails = details as ReadAtTimeDetails;

            if (readAtTimeDetails != null)
            {
                return HistoryReadAtTime(
                    context,
                    variable,
                    readAtTimeDetails,
                    timestampsToReturn,
                    releaseContinuationPoints,
                    nodesToRead,
                    result);
            }
 
            return StatusCodes.BadHistoryOperationUnsupported;
        }
         
        /// <summary>
        /// Reads the raw history for the variable value.
        /// </summary>
        protected virtual ServiceResult HistoryReadRaw(
            ISystemContext context, 
            BaseVariableState      source,
            ReadRawModifiedDetails details, 
            TimestampsToReturn     timestampsToReturn, 
            bool                   releaseContinuationPoints, 
            HistoryReadValueId     nodeToRead, 
            HistoryReadResult      result)
        {
            return StatusCodes.BadHistoryOperationUnsupported;
        }
         
        /// <summary>
        /// Reads the processed history for the variable value.
        /// </summary>
        protected virtual ServiceResult HistoryReadProcessed(
            ISystemContext context, 
            BaseVariableState      source,
            ReadProcessedDetails   details, 
            TimestampsToReturn     timestampsToReturn, 
            bool                   releaseContinuationPoints, 
            HistoryReadValueId     nodeToRead, 
            HistoryReadResult      result)
        {
            return StatusCodes.BadHistoryOperationUnsupported;
        }
         
        /// <summary>
        /// Reads the history for the variable value.
        /// </summary>
        protected virtual ServiceResult HistoryReadAtTime(
            ISystemContext context, 
            BaseVariableState      source,
            ReadAtTimeDetails      details, 
            TimestampsToReturn     timestampsToReturn, 
            bool                   releaseContinuationPoints, 
            HistoryReadValueId     nodeToRead, 
            HistoryReadResult      result)
        {
            return StatusCodes.BadHistoryOperationUnsupported;
        }
        
        
        /// <summary>
        /// Writes the value for the specified attributes.
        /// </summary>
        public virtual void Write(
            OperationContext     context, 
            IList<WriteValue>    nodesToWrite, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<ReadWriteOperationState> nodesToValidate = new List<ReadWriteOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToWrite.Count; ii++)
                {                    
                    WriteValue nodeToWrite = nodesToWrite[ii];

                    // skip items that have already been processed.
                    if (nodeToWrite.Processed)
                    {
                        continue;
                    }
                    
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, nodeToWrite.NodeId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToWrite.Processed = true;

                    // index range is not supported.
                    if (!String.IsNullOrEmpty(nodeToWrite.IndexRange))
                    {
                        errors[ii] = StatusCodes.BadIndexRangeInvalid;
                        continue;
                    }
                    
                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        
                        // must validate node in a seperate operation.
                        ReadWriteOperationState operation = new ReadWriteOperationState();
                        
                        operation.Source = source;
                        operation.Index = ii;

                        nodesToValidate.Add(operation);
                        
                        continue;
                    }

                    // write the attribute value.
                    errors[ii] = source.WriteAttribute(
                        systemContext,
                        nodeToWrite.AttributeId,
                        nodeToWrite.ParsedIndexRange,
                        nodeToWrite.Value);

                    // updates to source finished - report changes to monitored items.
                    source.ClearChangeMasks(systemContext, false);
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    ReadWriteOperationState operation = nodesToValidate[ii];

                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }
                    
                    WriteValue nodeToWrite = nodesToWrite[operation.Index];

                    // write the attribute value.
                    errors[operation.Index] = operation.Source.WriteAttribute(
                        systemContext,
                        nodeToWrite.AttributeId,
                        nodeToWrite.ParsedIndexRange,
                        nodeToWrite.Value);

                    // updates to source finished - report changes to monitored items.
                    operation.Source.ClearChangeMasks(systemContext, false);
                }
            }
        }
        
        /// <summary>
        /// Updates the history for the specified nodes.
        /// </summary>
        public virtual void HistoryUpdate(
            OperationContext            context, 
            Type                        detailsType, 
            IList<HistoryUpdateDetails> nodesToUpdate, 
            IList<HistoryUpdateResult>  results,
            IList<ServiceResult>        errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<ReadWriteOperationState> nodesToValidate = new List<ReadWriteOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToUpdate.Count; ii++)
                {                    
                    HistoryUpdateDetails nodeToUpdate = nodesToUpdate[ii];

                    // skip items that have already been processed.
                    if (nodeToUpdate.Processed)
                    {
                        continue;
                    }
                    
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, nodeToUpdate.NodeId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToUpdate.Processed = true;
                    
                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        
                        // must validate node in a seperate operation.
                        ReadWriteOperationState operation = new ReadWriteOperationState();
                        
                        operation.Source = source;
                        operation.Index = ii;

                        nodesToValidate.Add(operation);
                        
                        continue;
                    }

                    // historical data not available.
                    errors[ii] = StatusCodes.BadHistoryOperationUnsupported;
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    ReadWriteOperationState operation = nodesToValidate[ii];

                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }
                    
                    // historical data not available.
                    errors[ii] = StatusCodes.BadHistoryOperationUnsupported;
                }
            }
        }

        /// <summary>
        /// Calls a method on the specified nodes.
        /// </summary>
        public virtual void Call(
            OperationContext         context, 
            IList<CallMethodRequest> methodsToCall, 
            IList<CallMethodResult>  results, 
            IList<ServiceResult>     errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<CallOperationState> nodesToValidate = new List<CallOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < methodsToCall.Count; ii++)
                {                    
                    CallMethodRequest methodToCall = methodsToCall[ii];

                    // skip items that have already been processed.
                    if (methodToCall.Processed)
                    {
                        continue;
                    }
                    
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, methodToCall.ObjectId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    methodToCall.Processed = true;

                    // check for valid method.
                    MethodState method = GetManagerHandle(systemContext, methodToCall.MethodId, operationCache) as MethodState;

                    if (method == null)
                    {
                        errors[ii] = StatusCodes.BadMethodInvalid;
                        continue;
                    }

                    // check if method belongs to the object.
                    if (!Object.ReferenceEquals(method.Parent, source))
                    {
                        errors[ii] = StatusCodes.BadMethodInvalid;
                        continue;
                    }
                    
                    CallMethodResult result = results[ii] = new CallMethodResult();

                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        
                        // must validate node in a seperate operation.
                        CallOperationState operation = new CallOperationState();
                        
                        operation.Source = source;
                        operation.Method = method;
                        operation.Index = ii;

                        nodesToValidate.Add(operation);

                        continue;
                    }
                    
                    // call the method.
                    errors[ii] = Call(
                        systemContext,
                        methodToCall,
                        source,
                        method,
                        result);
                }
                                
                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    CallOperationState operation = nodesToValidate[ii];

                    // validate the object.
                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }
                             
                    // call the method.
                    CallMethodResult result = results[operation.Index];

                    errors[operation.Index] = Call(
                        systemContext,
                        methodsToCall[operation.Index],
                        operation.Source,
                        operation.Method,
                        result);
                }
            }
        }
        
        /// <summary>
        /// Stores the state of a call method operation.
        /// </summary>
        private struct CallOperationState
        {
            public NodeState Source;
            public MethodState Method;
            public int Index;
        }
        
        /// <summary>
        /// Calls a method on an object.
        /// </summary>
        protected virtual ServiceResult Call(
            ISystemContext context,
            CallMethodRequest methodToCall,
            NodeState source,
            MethodState method,
            CallMethodResult result)
        {
            ServerSystemContext systemContext = context as ServerSystemContext;
            List<ServiceResult> argumentErrors = new List<ServiceResult>();
            VariantCollection outputArguments = new VariantCollection();

            ServiceResult error = method.Call(
                context,
                methodToCall.ObjectId,
                methodToCall.InputArguments,
                argumentErrors,
                outputArguments);

            if (ServiceResult.IsBad(error))
            {
                return error;
            }

            // check for argument errors.
            bool argumentsValid = true;

            for (int jj = 0; jj < argumentErrors.Count; jj++)
            {
                ServiceResult argumentError = argumentErrors[jj];

                if (argumentError != null)
                {
                    result.InputArgumentResults.Add(argumentError.StatusCode);
                                  
                    if (ServiceResult.IsBad(argumentError))
                    {
                        argumentsValid = false;
                    }
                }
                else
                {
                    result.InputArgumentResults.Add(StatusCodes.Good);
                }

                // only fill in diagnostic info if it is requested.
                if ((systemContext.OperationContext.DiagnosticsMask & DiagnosticsMasks.OperationAll) != 0)
                {
                    if (ServiceResult.IsBad(argumentError))
                    {
                        argumentsValid = false;
                        result.InputArgumentDiagnosticInfos.Add(new DiagnosticInfo(argumentError, systemContext.OperationContext.DiagnosticsMask, false, systemContext.OperationContext.StringTable));
                    }
                    else
                    {
                        result.InputArgumentDiagnosticInfos.Add(null);
                    }
                }
            }

            // check for validation errors.
            if (!argumentsValid)
            {
                result.StatusCode = StatusCodes.BadInvalidArgument;
                return result.StatusCode;
            }

            // do not return diagnostics if there are no errors.
            result.InputArgumentDiagnosticInfos.Clear();

            // return output arguments.
            result.OutputArguments = outputArguments;

            return ServiceResult.Good;
        }

        /// <summary>
        /// Subscribes or unsubscribes to events produced by the specified source.
        /// </summary>
        /// <remarks>
        /// This method is called when a event subscription is created or deletes. The node manager 
        /// must  start/stop reporting events for the specified object and all objects below it in 
        /// the notifier hierarchy.
        /// </remarks>
        public virtual ServiceResult SubscribeToEvents(
            OperationContext    context, 
            object              sourceId, 
            uint                subscriptionId, 
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();

            lock (Lock)
            {
                // check for valid handle.
                NodeState source = IsHandleInNamespace(sourceId);

                if (source == null)
                {
                    return StatusCodes.BadNodeIdInvalid;
                }

                // check if the object supports subscritions.
                BaseObjectState instance = sourceId as BaseObjectState;

                if (instance == null || instance.EventNotifier != EventNotifiers.SubscribeToEvents)
                {
                    return StatusCodes.BadNotSupported;
                }

                MonitoredNode monitoredNode = instance.Handle as MonitoredNode;

                // handle unsubscribe.
                if (unsubscribe)
                {
                    if (monitoredNode != null)
                    {
                        monitoredNode.UnsubscribeToEvents(systemContext, monitoredItem);

                        // do any post processing.
                        OnUnsubscribeToEvents(systemContext, monitoredNode, monitoredItem);
                    }

                    return ServiceResult.Good;
                }

                // subscribe to events.
                if (monitoredNode == null)
                {
                    instance.Handle = monitoredNode = new MonitoredNode(m_server, this, source);
                }

                monitoredNode.SubscribeToEvents(systemContext, monitoredItem);

                // do any post processing.
                OnSubscribeToEvents(systemContext, monitoredNode, monitoredItem);

                return ServiceResult.Good;
            }
        }
        
        /// <summary>
        /// Subscribes or unsubscribes to events produced by all event sources.
        /// </summary>
        /// <remarks>
        /// This method is called when a event subscription is created or deleted. The node 
        /// manager must start/stop reporting events for all objects that it manages.
        /// </remarks>
        public virtual ServiceResult SubscribeToAllEvents(
            OperationContext    context, 
            uint                subscriptionId, 
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();

            lock (Lock)
            {
                // update root notifiers.
                for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
                {
                    SubscribeToAllEvents(
                        systemContext,
                        monitoredItem,
                        unsubscribe,
                        m_rootNotifiers[ii]);
                }

                return ServiceResult.Good;
            }
        }

        /// <summary>
        /// Subscribes/unsubscribes to all events produced by the specified node.
        /// </summary>
        protected void SubscribeToAllEvents(
            ISystemContext      systemContext, 
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe,
            NodeState           source)
        {
            MonitoredNode monitoredNode = source.Handle as MonitoredNode;

            // handle unsubscribe.
            if (unsubscribe)
            {
                if (monitoredNode != null)
                {
                    monitoredNode.UnsubscribeToEvents(systemContext, monitoredItem);

                    // do any post processing.
                    OnUnsubscribeToEvents(systemContext, monitoredNode, monitoredItem);
                }

                return;
            }

            // subscribe to events.
            if (monitoredNode == null)
            {
                source.Handle = monitoredNode = new MonitoredNode(m_server, this, source);
            }

            monitoredNode.SubscribeToEvents(systemContext, monitoredItem);

            // do any post processing.
            OnSubscribeToEvents(systemContext, monitoredNode, monitoredItem);
        }

        /// <summary>
        /// Does any processing after a monitored item is subscribed to.
        /// </summary>
        protected virtual void OnSubscribeToEvents(
            ISystemContext systemContext,
            MonitoredNode monitoredNode,
            IEventMonitoredItem monitoredItem)
        {
            // does nothing.
        }

        /// <summary>
        /// Does any processing after a monitored item is subscribed to.
        /// </summary>
        protected virtual void OnUnsubscribeToEvents(
            ISystemContext systemContext,
            MonitoredNode monitoredNode,
            IEventMonitoredItem monitoredItem)
        {
            // does nothing.
        }

        /// <summary>
        /// Tells the node manager to refresh any conditions associated with the specified monitored items.
        /// </summary>
        /// <remarks>
        /// This method is called when the condition refresh method is called for a subscription.
        /// The node manager must create a refresh event for each condition monitored by the subscription.
        /// </remarks>
        public virtual ServiceResult ConditionRefresh(
            OperationContext           context, 
            IList<IEventMonitoredItem> monitoredItems)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    IEventMonitoredItem monitoredItem = monitoredItems[ii];

                    if (monitoredItem == null)
                    {
                        continue;
                    }
                    
                    // check for global subscription.
                    if (monitoredItem.MonitoringAllEvents)
                    {
                        for (int jj = 0; jj < m_rootNotifiers.Count; jj++)
                        {
                            MonitoredNode monitoredNode = m_rootNotifiers[jj].Handle as MonitoredNode;

                            if (monitoredNode == null)
                            {
                                continue;
                            }

                            monitoredNode.ConditionRefresh(systemContext, monitoredItem);
                        }
                    }

                    // check for subscription to local node.
                    else
                    {
                        NodeState source = IsHandleInNamespace(monitoredItem.ManagerHandle );

                        if (source == null)
                        {
                            continue;
                        }
                        
                        MonitoredNode monitoredNode = source.Handle as MonitoredNode;
                        
                        if (monitoredNode == null)
                        {
                            continue;
                        }
                                
                        monitoredNode.ConditionRefresh(systemContext, monitoredItem);
                    }
                }
            }

            return ServiceResult.Good;
        }

        /// <summary>
        /// Creates a new set of monitored items for a set of variables.
        /// </summary>
        /// <remarks>
        /// This method only handles data change subscriptions. Event subscriptions are created by the SDK.
        /// </remarks>
        public virtual void CreateMonitoredItems(
            OperationContext                  context, 
            uint                              subscriptionId, 
            double                            publishingInterval, 
            TimestampsToReturn                timestampsToReturn, 
            IList<MonitoredItemCreateRequest> itemsToCreate, 
            IList<ServiceResult>              errors, 
            IList<MonitoringFilterResult>     filterErrors, 
            IList<IMonitoredItem>             monitoredItems,
            ref long                          globalIdCounter)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<ReadWriteOperationState> nodesToValidate = new List<ReadWriteOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < itemsToCreate.Count; ii++)
                {                    
                    MonitoredItemCreateRequest itemToCreate = itemsToCreate[ii];

                    // skip items that have already been processed.
                    if (itemToCreate.Processed)
                    {
                        continue;
                    }

                    ReadValueId itemToMonitor = itemToCreate.ItemToMonitor;
                                        
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, itemToMonitor.NodeId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    itemToCreate.Processed = true;

                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        
                        // must validate node in a seperate operation.
                        ReadWriteOperationState operation = new ReadWriteOperationState();
                        
                        operation.Source = source;
                        operation.Index = ii;

                        nodesToValidate.Add(operation);

                        continue;
                    }

                    MonitoringFilterResult filterError = null;
                    IMonitoredItem monitoredItem = null;

                    errors[ii] = CreateMonitoredItem(
                        systemContext,
                        source,
                        subscriptionId,
                        publishingInterval,
                        context.DiagnosticsMask,
                        timestampsToReturn,
                        itemToCreate,
                        ref globalIdCounter,
                        out filterError,
                        out monitoredItem);

                    // save any filter error details.
                    filterErrors[ii] = filterError;

                    if (ServiceResult.IsBad(errors[ii]))
                    {
                        continue;
                    }

                    // save the monitored item.
                    monitoredItems[ii] = monitoredItem;
                }
                                
                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    ReadWriteOperationState operation = nodesToValidate[ii];

                    // validate the object.
                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }
                    
                    MonitoredItemCreateRequest itemToCreate = itemsToCreate[operation.Index];

                    MonitoringFilterResult filterError = null;
                    IMonitoredItem monitoredItem = null;

                    errors[operation.Index] = CreateMonitoredItem(
                        systemContext,
                        operation.Source,
                        subscriptionId,
                        publishingInterval,
                        context.DiagnosticsMask,
                        timestampsToReturn,
                        itemToCreate,
                        ref globalIdCounter,
                        out filterError,
                        out monitoredItem);

                    // save any filter error details.
                    filterErrors[operation.Index] = filterError;

                    if (ServiceResult.IsBad(errors[operation.Index]))
                    {
                        continue;
                    }

                    // save the monitored item.
                    monitoredItems[operation.Index] = monitoredItem;
                }
            }
        }

        /// <summary>
        /// Validates a data change filter provided by the client.
        /// </summary>
        /// <param name="context">The system context.</param>
        /// <param name="source">The node being monitored.</param>
        /// <param name="attributeId">The attribute being monitored.</param>
        /// <param name="requestedFilter">The requested monitoring filter.</param>
        /// <param name="filter">The validated data change filter.</param>
        /// <param name="range">The EU range associated with the value if required by the filter.</param>
        /// <returns>Any error condition. Good if no errors occurred.</returns>
        protected ServiceResult ValidateDataChangeFilter(
            ISystemContext context,
            NodeState source,
            uint attributeId,
            ExtensionObject requestedFilter,
            out DataChangeFilter filter,
            out Range range)
        {
            filter = null;
            range = null;

            // check for valid filter type.
            filter = requestedFilter.Body as DataChangeFilter;

            if (filter == null)
            {
                return StatusCodes.BadMonitoredItemFilterUnsupported;
            }

            // only supported for value attributes.
            if (attributeId != Attributes.Value)
            {
                return StatusCodes.BadMonitoredItemFilterUnsupported;
            }

            // only supported for variables.
            BaseVariableState variable = source as BaseVariableState;
            
            if (variable == null)
            {
                return StatusCodes.BadMonitoredItemFilterUnsupported;
            }

            // check the datatype.
            if (filter.DeadbandType != (uint)DeadbandType.None)
            {
                BuiltInType builtInType = TypeInfo.GetBuiltInType(variable.DataType, Server.TypeTree);

                if (!TypeInfo.IsNumericType(builtInType))
                {
                    return StatusCodes.BadMonitoredItemFilterUnsupported;
                }
            }

            // validate filter.
            ServiceResult error = filter.Validate();

            if (ServiceResult.IsBad(error))
            {
                return error;
            }

            if (filter.DeadbandType ==(uint)DeadbandType.Percent)
            {
                BaseVariableState euRange = variable.FindChild(context, BrowseNames.EURange) as BaseVariableState;

                if (euRange == null)
                {
                    return StatusCodes.BadMonitoredItemFilterUnsupported;
                }

                range = euRange.Value as Range;
                
                if (range == null)
                {
                    return StatusCodes.BadMonitoredItemFilterUnsupported;
                }
            }

            // all good.
            return ServiceResult.Good;
        }

        /// <summary>
        /// Creates a new set of monitored items for a set of variables.
        /// </summary>
        /// <remarks>
        /// This method only handles data change subscriptions. Event subscriptions are created by the SDK.
        /// </remarks>
        protected virtual ServiceResult CreateMonitoredItem(
            ISystemContext context,
            NodeState source,
            uint subscriptionId,
            double publishingInterval,
            DiagnosticsMasks diagnosticsMasks,
            TimestampsToReturn timestampsToReturn,
            MonitoredItemCreateRequest itemToCreate,
            ref long globalIdCounter,
            out MonitoringFilterResult filterError,
            out IMonitoredItem monitoredItem)
        {
            filterError = null;
            monitoredItem = null;
            ServiceResult error = null;
            
            // read initial value.
            DataValue initialValue = new DataValue();

            initialValue.Value = null;
            initialValue.ServerTimestamp = DateTime.UtcNow;
            initialValue.SourceTimestamp = DateTime.MinValue;
            initialValue.StatusCode = StatusCodes.Good;

            error = source.ReadAttribute(
                context,
                itemToCreate.ItemToMonitor.AttributeId,
                itemToCreate.ItemToMonitor.ParsedIndexRange,
                itemToCreate.ItemToMonitor.DataEncoding,
                initialValue);

            if (ServiceResult.IsBad(error))
            {
                return error;
            }
            
            // validate parameters.
            MonitoringParameters parameters = itemToCreate.RequestedParameters;

            // validate the data change filter.
            DataChangeFilter filter = null;
            Range range = null;

            if (!ExtensionObject.IsNull(parameters.Filter))
            {
                error = ValidateDataChangeFilter(
                    context,
                    source,
                    itemToCreate.ItemToMonitor.AttributeId,
                    parameters.Filter,
                    out filter,
                    out range);

                if (ServiceResult.IsBad(error))
                {
                    return error;
                }
            }

            // create monitored node.
            MonitoredNode monitoredNode = source.Handle as MonitoredNode;

            if (monitoredNode == null)
            {
                source.Handle = monitoredNode = new MonitoredNode(m_server, this, source);
            }

            // create a globally unique identifier.
            uint monitoredItemId = Utils.IncrementIdentifier(ref globalIdCounter);

            // determine the sampling interval.
            double samplingInterval = itemToCreate.RequestedParameters.SamplingInterval;

            if (samplingInterval < 0)
            {
                samplingInterval = publishingInterval;
            }

            // check if the variable needs to be sampled.
            bool samplingRequired = false;

            if (itemToCreate.ItemToMonitor.AttributeId == Attributes.Value)
            {
                BaseVariableState variable = source as BaseVariableState;

                if (variable.MinimumSamplingInterval > 0)
                {
                    samplingInterval = CalculateSamplingInterval(variable, samplingInterval);
                    samplingRequired = true;
                }
            }

            // create the item.
            DataChangeMonitoredItem datachangeItem = monitoredNode.CreateDataChangeItem(
                context,
                monitoredItemId,
                itemToCreate.ItemToMonitor.AttributeId,
                itemToCreate.ItemToMonitor.ParsedIndexRange,
                itemToCreate.ItemToMonitor.DataEncoding,
                diagnosticsMasks,
                timestampsToReturn,
                itemToCreate.MonitoringMode,
                itemToCreate.RequestedParameters.ClientHandle,
                samplingInterval,
                itemToCreate.RequestedParameters.QueueSize,
                itemToCreate.RequestedParameters.DiscardOldest,
                filter,
                range,
                false);

            if (samplingRequired)
            {
                CreateSampledItem(samplingInterval, datachangeItem);
            }

            // report the initial value.
            datachangeItem.QueueValue(initialValue, null);

            // do any post processing.
            OnCreateMonitoredItem(context, itemToCreate, monitoredNode, datachangeItem);

            // update monitored item list.
            monitoredItem = datachangeItem;

            return ServiceResult.Good;
        }

        /// <summary>
        /// Calculates the sampling interval.
        /// </summary>
        private double CalculateSamplingInterval(BaseVariableState variable, double samplingInterval)
        {
            if (samplingInterval < variable.MinimumSamplingInterval)
            {
                samplingInterval = variable.MinimumSamplingInterval;
            }

            if ((samplingInterval % m_minimumSamplingInterval) != 0)
            {
                samplingInterval = Math.Truncate(samplingInterval/m_minimumSamplingInterval);
                samplingInterval += 1;
                samplingInterval *= m_minimumSamplingInterval;
            }

            return samplingInterval;
        }
        
        /// <summary>
        /// Creates a new sampled item.
        /// </summary>
        private void CreateSampledItem(double samplingInterval, DataChangeMonitoredItem monitoredItem)
        {
            m_sampledItems.Add(monitoredItem);

            if (m_samplingTimer == null)
            {
                m_samplingTimer = new Timer(DoSample, null, (int)m_minimumSamplingInterval, (int)m_minimumSamplingInterval);
            }
        }
        
        /// <summary>
        /// Deletes a sampled item.
        /// </summary>
        private void DeleteSampledItem(DataChangeMonitoredItem monitoredItem)
        {
            for (int ii = 0; ii < m_sampledItems.Count; ii++)
            {
                if (Object.ReferenceEquals(monitoredItem, m_sampledItems[ii]))
                {
                    m_sampledItems.RemoveAt(ii);
                    break;
                }
            }

            if (m_sampledItems.Count == 0)
            {
                if (m_samplingTimer != null)
                {
                    m_samplingTimer.Dispose();
                    m_samplingTimer = null;
                }
            }
        }

        /// <summary>
        /// Polls each monitored item which requires sample. 
        /// </summary>
        private void DoSample(object state)
        {
            try
            {
                lock (m_lock)
                {
                    for (int ii = 0; ii < m_sampledItems.Count; ii++)
                    {
                        DataChangeMonitoredItem monitoredItem = m_sampledItems[ii];

                        if (monitoredItem.TimeToNextSample < m_minimumSamplingInterval)
                        {
                            monitoredItem.ValueChanged(SystemContext);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Unexpected error during diagnostics scan.");
            }
        }

        /// <summary>
        /// Does any processing after a monitored item is created.
        /// </summary>
        protected virtual void OnCreateMonitoredItem(
            ISystemContext systemContext,
            MonitoredItemCreateRequest itemToCreate,
            MonitoredNode monitoredNode, 
            DataChangeMonitoredItem monitoredItem)
        {
            // does nothing.
        }

        /// <summary>
        /// Modifies the parameters for a set of monitored items.
        /// </summary>
        public virtual void ModifyMonitoredItems(
            OperationContext                  context, 
            TimestampsToReturn                timestampsToReturn, 
            IList<IMonitoredItem>             monitoredItems, 
            IList<MonitoredItemModifyRequest> itemsToModify, 
            IList<ServiceResult>              errors, 
            IList<MonitoringFilterResult>     filterErrors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {                    
                    MonitoredItemModifyRequest itemToModify = itemsToModify[ii];

                    // skip items that have already been processed.
                    if (itemToModify.Processed || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // modify the monitored item.
                    MonitoringFilterResult filterError = null;

                    errors[ii] = ModifyMonitoredItem(
                        systemContext,
                        context.DiagnosticsMask,
                        timestampsToReturn,
                        monitoredItems[ii],
                        itemToModify,
                        out filterError);

                    // save any filter error details.
                    filterErrors[ii] = filterError;
                }
            }
        }

        /// <summary>
        /// Modifies the parameters for a monitored item.
        /// </summary>
        protected virtual ServiceResult ModifyMonitoredItem(
            ISystemContext context,
            DiagnosticsMasks diagnosticsMasks,
            TimestampsToReturn timestampsToReturn,
            IMonitoredItem monitoredItem,
            MonitoredItemModifyRequest itemToModify,
            out MonitoringFilterResult filterError)
        {
            filterError = null;
            ServiceResult error = null;

            // check for valid handle.
            MonitoredNode monitoredNode = monitoredItem.ManagerHandle as MonitoredNode;

            if (monitoredNode == null)
            {
                return ServiceResult.Good;
            }

            if (IsHandleInNamespace(monitoredNode.Node) == null)
            {
                return ServiceResult.Good;
            }

            // owned by this node manager.
            itemToModify.Processed = true;

            // check for valid monitored item.
            DataChangeMonitoredItem datachangeItem = monitoredItem as DataChangeMonitoredItem;

            // validate parameters.
            MonitoringParameters parameters = itemToModify.RequestedParameters;

            // validate the data change filter.
            DataChangeFilter filter = null;
            Range range = null;

            if (!ExtensionObject.IsNull(parameters.Filter))
            {
                error = ValidateDataChangeFilter(
                    context,
                    monitoredNode.Node,
                    datachangeItem.AttributeId,
                    parameters.Filter,
                    out filter,
                    out range);

                if (ServiceResult.IsBad(error))
                {
                    return error;
                }
            }

            double previousSamplingInterval = datachangeItem.SamplingInterval;
            
            // check if the variable needs to be sampled.
            double samplingInterval = itemToModify.RequestedParameters.SamplingInterval;

            if (datachangeItem.AttributeId == Attributes.Value)
            {
                BaseVariableState variable = monitoredNode.Node as BaseVariableState;

                if (variable.MinimumSamplingInterval > 0)
                {
                    samplingInterval = CalculateSamplingInterval(variable, samplingInterval);
                }
            }

            // modify the monitored item parameters.
            error = datachangeItem.Modify(
                diagnosticsMasks,
                timestampsToReturn,
                itemToModify.RequestedParameters.ClientHandle,
                samplingInterval,
                itemToModify.RequestedParameters.QueueSize,
                itemToModify.RequestedParameters.DiscardOldest,
                filter,
                range);

            // do any post processing.
            OnModifyMonitoredItem(
                context, 
                itemToModify, 
                monitoredNode, 
                datachangeItem,
                previousSamplingInterval);

            return ServiceResult.Good;
        }

        /// <summary>
        /// Does any processing after a monitored item is created.
        /// </summary>
        protected virtual void OnModifyMonitoredItem(
            ISystemContext systemContext,
            MonitoredItemModifyRequest itemToModify,
            MonitoredNode monitoredNode,
            DataChangeMonitoredItem monitoredItem,
            double previousSamplingInterval)
        {
            // does nothing.
        }

        /// <summary>
        /// Deletes a set of monitored items.
        /// </summary>
        public virtual void DeleteMonitoredItems(
            OperationContext     context, 
            IList<IMonitoredItem> monitoredItems, 
            IList<bool>          processedItems, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    // skip items that have already been processed.
                    if (processedItems[ii] || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // delete the monitored item.
                    bool processed = false;

                    errors[ii] = DeleteMonitoredItem(
                        systemContext,
                        monitoredItems[ii],
                        out processed);

                    // indicate whether it was processed or not.
                    processedItems[ii] = processed;
                }
            }
        }

        /// <summary>
        /// Deletes a monitored item.
        /// </summary>
        protected virtual ServiceResult DeleteMonitoredItem(
            ISystemContext context,
            IMonitoredItem monitoredItem,
            out bool processed)
        {
            processed = false;

            // check for valid handle.
            MonitoredNode monitoredNode = monitoredItem.ManagerHandle as MonitoredNode;

            if (monitoredNode == null)
            {
                return ServiceResult.Good;
            }

            if (IsHandleInNamespace(monitoredNode.Node) == null)
            {
                return ServiceResult.Good;
            }

            // owned by this node manager.
            processed = true;

            // get the  source.
            NodeState source = monitoredNode.Node;

            // check for valid monitored item.
            DataChangeMonitoredItem datachangeItem = monitoredItem as DataChangeMonitoredItem;
            
            // check if the variable needs to be sampled.
            if (datachangeItem.AttributeId == Attributes.Value)
            {
                BaseVariableState variable = monitoredNode.Node as BaseVariableState;

                if (variable.MinimumSamplingInterval > 0)
                {
                    DeleteSampledItem(datachangeItem);
                }
            }

            // remove item.
            monitoredNode.DeleteItem(datachangeItem);

            // do any post processing.
            OnDeleteMonitoredItem(context, monitoredNode, datachangeItem);

            return ServiceResult.Good;
        }

        /// <summary>
        /// Does any processing after a monitored item is deleted.
        /// </summary>
        protected virtual void OnDeleteMonitoredItem(
            ISystemContext systemContext,
            MonitoredNode monitoredNode,
            DataChangeMonitoredItem monitoredItem)
        {
            // does nothing.
        }

        /// <summary>
        /// Changes the monitoring mode for a set of monitored items.
        /// </summary>
        public virtual void SetMonitoringMode(
            OperationContext     context, 
            MonitoringMode       monitoringMode, 
            IList<IMonitoredItem> monitoredItems, 
            IList<bool>          processedItems, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    // skip items that have already been processed.
                    if (processedItems[ii] || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // update monitoring mode.
                    bool processed = false;

                    errors[ii] = SetMonitoringMode(
                        systemContext,
                        monitoredItems[ii],
                        monitoringMode,
                        out processed);

                    // indicate whether it was processed or not.
                    processedItems[ii] = processed;
                }
            }
        }

        /// <summary>
        /// Changes the monitoring mode for an item.
        /// </summary>
        protected virtual ServiceResult SetMonitoringMode(
            ISystemContext context,
            IMonitoredItem monitoredItem,
            MonitoringMode monitoringMode, 
            out bool processed)
        {
            processed = false;

            // check for valid handle.
            MonitoredNode monitoredNode = monitoredItem.ManagerHandle as MonitoredNode;

            if (monitoredNode == null)
            {
                return ServiceResult.Good;
            }

            if (IsHandleInNamespace(monitoredNode.Node) == null)
            {
                return ServiceResult.Good;
            }

            // owned by this node manager.
            processed = true;

            // check for valid monitored item.
            DataChangeMonitoredItem datachangeItem = monitoredItem as DataChangeMonitoredItem;

            // update monitoring mode.
            MonitoringMode previousMode = datachangeItem.SetMonitoringMode(monitoringMode);

            // need to provide an immediate update after enabling.
            if (previousMode == MonitoringMode.Disabled && monitoringMode != MonitoringMode.Disabled)
            {
                DataValue initialValue = new DataValue();

                initialValue.Value = null;
                initialValue.ServerTimestamp = DateTime.UtcNow;
                initialValue.SourceTimestamp = DateTime.MinValue;
                initialValue.StatusCode = StatusCodes.Good;

                ServiceResult error = monitoredNode.Node.ReadAttribute(
                    context,
                    datachangeItem.AttributeId,
                    datachangeItem.IndexRange,
                    datachangeItem.DataEncoding,
                    initialValue);

                datachangeItem.QueueValue(initialValue, error);
            }
            
            // do any post processing.
            OnSetMonitoringMode(context, monitoredNode, datachangeItem, previousMode, monitoringMode);

            return ServiceResult.Good;
        }

        /// <summary>
        /// Does any processing after a monitored item is created.
        /// </summary>
        protected virtual void OnSetMonitoringMode(
            ISystemContext systemContext,
            MonitoredNode monitoredNode,
            DataChangeMonitoredItem monitoredItem,
            MonitoringMode previousMode,
            MonitoringMode currentMode)
        {
            // does nothing.
        }
        #endregion

        #region Private Fields
        private object m_lock = new object();
        private IServerInternal m_server;
        private ServerSystemContext m_systemContext;
        private IList<string> m_namespaceUris;
        private ushort[] m_namespaceIndexes;
        private NodeIdDictionary<NodeState> m_predefinedNodes;
        private List<NodeState> m_rootNotifiers;
        
        private Timer m_samplingTimer;
        private List<DataChangeMonitoredItem> m_sampledItems;
        private double m_minimumSamplingInterval;
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.Xml;
using System.IO;
using System.Threading;
using System.Reflection;

namespace Opc.Ua.Server
{
    /// <summary>
    /// A node manager for a variety of test data.
    /// </summary>
    [Obsolete("Class replaced by Opc.Ua.Server.CustomNodeManager2")]
    public class CustomNodeManager : INodeManager, INodeIdFactory, IDisposable
    {
        #region Constructors
        /// <summary>
        /// Initializes the node manager.
        /// </summary>
        public CustomNodeManager(IServerInternal server)
        {
            // save a reference to the server that owns the node manager.
            m_server = server;  
            
            // create the default context.
            m_systemContext = m_server.DefaultSystemContext.Copy();

            m_systemContext.SystemHandle = null;
            m_systemContext.NodeIdFactory = this;

            // create the table of nodes. 
            m_predefinedNodes = new NodeIdDictionary<NodeState>();
            m_rootNotifiers = new List<NodeState>();
            m_sampledItems = new List<DataChangeMonitoredItem>();
            m_minimumSamplingInterval = 100;
        }
        #endregion
        
        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {   
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {  
            if (disposing)
            {
                lock (m_lock)
                {
                    Utils.SilentDispose(m_samplingTimer);
                    m_samplingTimer = null;

                    if (m_predefinedNodes != null)
                    {
                        foreach (NodeState node in m_predefinedNodes.Values)
                        {
                            Utils.SilentDispose(node);
                        }
                    }
                }
            }
        }
        #endregion

        #region INodeIdFactory Members
        /// <summary>
        /// Creates the NodeId for the specified node.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="node">The node.</param>
        /// <returns>The new NodeId.</returns>
        public virtual NodeId New(ISystemContext context, NodeState node)
        {
            return node.NodeId;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Acquires the lock on the node manager.
        /// </summary>
        public object Lock
        {
            get { return m_lock; }
        }
        #endregion

        #region Protected Members
        /// <summary>
        /// The server that the node manager belongs to.
        /// </summary>
        protected IServerInternal Server
        {
            get { return m_server; }
        }

        /// <summary>
        /// The default context to use.
        /// </summary>
        protected ServerSystemContext SystemContext
        {
            get { return m_systemContext; }
        }

        /// <summary>
        /// The predefined nodes managed by the node manager.
        /// </summary>
        protected NodeIdDictionary<NodeState> PredefinedNodes
        {
            get { return m_predefinedNodes; }
        }

        /// <summary>
        /// The root notifiers for the node manager.
        /// </summary>
        protected List<NodeState> RootNotifiers
        {
            get { return m_rootNotifiers; }
        }

        /// <summary>
        /// Returns true if the namespace for the node id is one of the namespaces managed by the node manager.
        /// </summary>
        /// <param name="nodeId">The node id to check.</param>
        /// <returns>True if the namespace is one of the nodes.</returns>
        protected virtual bool IsNodeIdInNamespace(NodeId nodeId)
        {
            if (NodeId.IsNull(nodeId))
            {
                return false;
            }

            // quickly exclude nodes that not in the namespace.
            for (int ii = 0; ii < m_namespaceIndexes.Length; ii++)
            {
                if (nodeId.NamespaceIndex == m_namespaceIndexes[ii])
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Returns the node if the handle refers to a node managed by this manager.
        /// </summary>
        /// <param name="managerHandle">The handle to check.</param>
        /// <returns>Non-null if the handle belongs to the node manager.</returns>
        protected virtual NodeState IsHandleInNamespace(object managerHandle)
        {
            NodeState source = managerHandle as NodeState;

            if (source == null)
            {
                return null;
            }

            if (!IsNodeIdInNamespace(source.NodeId))
            {
                return null;
            }

            return source;
        }

        /// <summary>
        /// Returns the state object for the specified node if it exists.
        /// </summary>
        public NodeState Find(NodeId nodeId)
        {
            lock (Lock)
            {
                NodeState node = null;

                if (!PredefinedNodes.TryGetValue(nodeId, out node))
                {
                    return null;
                }

                return node;
            }
        }

        /// <summary>
        /// Creates a new instance and assigns unique identifiers to all children.
        /// </summary>
        /// <param name="context">The operation context.</param>
        /// <param name="parentId">An optional parent identifier.</param>
        /// <param name="referenceTypeId">The reference type from the parent.</param>
        /// <param name="browseName">The browse name.</param>
        /// <param name="instance">The instance to create.</param>
        /// <returns>The new node id.</returns>
        public NodeId CreateNode(
            ServerSystemContext context,
            NodeId parentId,
            NodeId referenceTypeId,
            QualifiedName browseName,
            BaseInstanceState instance)
        {
            ServerSystemContext contextToUse = (ServerSystemContext)m_systemContext.Copy(context);

            lock (Lock)
            {
                instance.ReferenceTypeId = referenceTypeId;

                NodeState parent = null;

                if (parentId != null)
                {
                    if (!PredefinedNodes.TryGetValue(parentId, out parent))
                    {
                        throw ServiceResultException.Create(
                            StatusCodes.BadNodeIdUnknown,
                            "Cannot find parent with id: {0}",
                            parentId);
                    }

                    parent.AddChild(instance);
                }

                instance.Create(contextToUse, null, browseName, null, true);
                AddPredefinedNode(contextToUse, instance);

                return instance.NodeId;
            }
        }

        /// <summary>
        /// Deletes a node and all of its children.
        /// </summary>
        public bool DeleteNode(
            ServerSystemContext context,
            NodeId nodeId)
        {
            ServerSystemContext contextToUse = m_systemContext.Copy(context);

            bool found = false;
            List<LocalReference> referencesToRemove = new List<LocalReference>();

            lock (Lock)
            {
                NodeState node = null;

                if (PredefinedNodes.TryGetValue(nodeId, out node))
                {
                    RemovePredefinedNode(contextToUse, node, referencesToRemove);
                    found = true;
                }

                RemoveRootNotifier(node);
            }

            // must release the lock before removing cross references to other node managers.
            if (referencesToRemove.Count > 0)
            {
                Server.NodeManager.RemoveReferences(referencesToRemove);
            }

            return found;
        }
        #endregion

        #region INodeManager Members
        /// <summary>
        /// Returns the namespaces used by the node manager.
        /// </summary>
        /// <remarks>
        /// All NodeIds exposed by the node manager must be qualified by a namespace URI. This property
        /// returns the URIs used by the node manager. In this example all NodeIds use a single URI.
        /// </remarks>
        public virtual IEnumerable<string> NamespaceUris
        {
            get 
            { 
                return m_namespaceUris; 
            }
            
            protected set
            {
                if (value != null)
                {
                    m_namespaceUris = new List<string>(value);
                }
                else
                {
                    m_namespaceUris = new List<string>();
                }

                m_namespaceIndexes = new ushort[m_namespaceUris.Count];
            }
        }

        /// <summary>
        /// Does any initialization required before the address space can be used.
        /// </summary>
        /// <remarks>
        /// The externalReferences is an out parameter that allows the node manager to link to nodes
        /// in other node managers. For example, the 'Objects' node is managed by the CoreNodeManager and
        /// should have a reference to the root folder node(s) exposed by this node manager.  
        /// </remarks>
        public virtual void CreateAddressSpace(IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            lock (Lock)
            {
                // add the uris to the server's namespace table and cache the indexes.
                for (int ii = 0; ii < m_namespaceUris.Count; ii++)
                {
                    m_namespaceIndexes[ii] = m_server.NamespaceUris.GetIndexOrAppend(m_namespaceUris[ii]);
                }

                LoadPredefinedNodes(m_systemContext, externalReferences);
            }
        }

        #region CreateAddressSpace Support Functions
        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        public virtual void LoadPredefinedNodes(
            ISystemContext context, 
            Assembly assembly,
            string resourcePath,
            IDictionary<NodeId,IList<IReference>> externalReferences)
        {
            // load the predefined nodes from an XML document.
            NodeStateCollection predefinedNodes = new NodeStateCollection();
            predefinedNodes.LoadFromResource(context, resourcePath, assembly, true);

            // add the predefined nodes to the node manager.
            for (int ii = 0; ii < predefinedNodes.Count; ii++)
            {
                AddPredefinedNode(context, predefinedNodes[ii]);
            }

            // ensure the reverse references exist.
            AddReverseReferences(externalReferences);
        }

        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        protected virtual NodeStateCollection LoadPredefinedNodes(ISystemContext context)
        {
            return new NodeStateCollection();
        }

        /// <summary>
        /// Loads a node set from a file or resource and addes them to the set of predefined nodes.
        /// </summary>
        protected virtual void LoadPredefinedNodes(
            ISystemContext context, 
            IDictionary<NodeId,IList<IReference>> externalReferences)
        {
            // load the predefined nodes from an XML document.
            NodeStateCollection predefinedNodes = LoadPredefinedNodes(context);

            // add the predefined nodes to the node manager.
            for (int ii = 0; ii < predefinedNodes.Count; ii++)
            {
                AddPredefinedNode(context, predefinedNodes[ii]);
            }

            // ensure the reverse references exist.
            AddReverseReferences(externalReferences);
        }

        /// <summary>
        /// Replaces the generic node with a node specific to the model.
        /// </summary>
        protected virtual NodeState AddBehaviourToPredefinedNode(ISystemContext context, NodeState predefinedNode)
        {
            BaseObjectState passiveNode = predefinedNode as BaseObjectState; 
            
            if (passiveNode == null)
            {
                return predefinedNode;
            }

            return predefinedNode;
        }

        /// <summary>
        /// Recursively indexes the node and its children.
        /// </summary>
        protected virtual void AddPredefinedNode(ISystemContext context, NodeState node)
        {
            NodeState activeNode = AddBehaviourToPredefinedNode(context, node);
            m_predefinedNodes[activeNode.NodeId] = activeNode;

            if (activeNode is BaseTypeState type)
            {
                AddTypesToTypeTree(type);
            }

            List<BaseInstanceState> children = new List<BaseInstanceState>();
            activeNode.GetChildren(context, children);

            for (int ii = 0; ii < children.Count; ii++)
            {
                AddPredefinedNode(context, children[ii]);
            }
        }

        /// <summary>
        /// Recursively indexes the node and its children.
        /// </summary>
        protected virtual void RemovePredefinedNode(
            ISystemContext context, 
            NodeState node, 
            List<LocalReference> referencesToRemove)
        {
            m_predefinedNodes.Remove(node.NodeId);
            node.UpdateChangeMasks(NodeStateChangeMasks.Deleted);
            node.ClearChangeMasks(context, false);
            OnNodeRemoved(node);

            // remove from the parent.
            BaseInstanceState instance = node as BaseInstanceState;

            if (instance?.Parent != null)
            {
                instance.Parent.RemoveChild(instance);
            }

            // remove children.
            List<BaseInstanceState> children = new List<BaseInstanceState>();
            node.GetChildren(context, children);

            for (int ii = 0; ii < children.Count; ii++)
            {
                node.RemoveChild(children[ii]);
            }

            for (int ii = 0; ii < children.Count; ii++)
            {
                RemovePredefinedNode(context, children[ii], referencesToRemove);
            }

            // remove from type table.

            if (node is BaseTypeState type)
            {
                m_server.TypeTree.Remove(type.NodeId);
            }
            
            // remove inverse references.
            List<IReference> references = new List<IReference>();
            node.GetReferences(context, references);

            for (int ii = 0; ii < references.Count; ii++)
            {
                IReference reference = references[ii];

                if (reference.TargetId.IsAbsolute)
                {
                    continue;
                }

                LocalReference referenceToRemove = new LocalReference(
                    (NodeId)reference.TargetId,
                    reference.ReferenceTypeId,
                    reference.IsInverse,
                    node.NodeId);

                referencesToRemove.Add(referenceToRemove);
            }
        }

        /// <summary>
        /// Called after a node has been deleted.
        /// </summary>
        protected virtual void OnNodeRemoved(NodeState node)
        {
            // overridden by the sub-class.            
        }

        /// <summary>
        /// Add the node to the set of root notifiers.
        /// </summary>
        protected virtual void AddRootNotifier(NodeState notifier)
        {
            for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
            {
                if (Object.ReferenceEquals(notifier, m_rootNotifiers[ii]))
                {
                    return;
                }
            }

            m_rootNotifiers.Add(notifier);

            // subscribe to existing events.
            if (m_server.EventManager != null)
            {
                IList<IEventMonitoredItem> monitoredItems = m_server.EventManager.GetMonitoredItems();

                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    if (monitoredItems[ii].MonitoringAllEvents)
                    {
                        SubscribeToAllEvents(
                            SystemContext,
                            monitoredItems[ii],
                            true,
                            notifier);
                    }
                }
            }
        }

        /// <summary>
        /// Remove the node from the set of root notifiers.
        /// </summary>
        protected virtual void RemoveRootNotifier(NodeState notifier)
        {
            for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
            {
                if (Object.ReferenceEquals(notifier, m_rootNotifiers[ii]))
                {
                    m_rootNotifiers.RemoveAt(ii);
                    break;
                }
            }
        }

        /// <summary>
        /// Ensures that all reverse references exist.
        /// </summary>
        /// <param name="externalReferences">A list of references to add to external targets.</param>
        protected virtual void AddReverseReferences(IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            foreach (NodeState source in m_predefinedNodes.Values)
            {
                // assign a default value to any variable value.
                
                if (source is BaseVariableState variable && variable.Value == null)
                {
                    variable.Value = TypeInfo.GetDefaultValue(variable.DataType, variable.ValueRank, Server.TypeTree);
                }

                // add reference from supertype for type nodes.

                if (source is BaseTypeState type && !NodeId.IsNull(type.SuperTypeId))
                {
                    if (!IsNodeIdInNamespace(type.SuperTypeId))
                    {
                        AddExternalReference(
                            type.SuperTypeId,
                            ReferenceTypeIds.HasSubtype,
                            false,
                            type.NodeId,
                            externalReferences);
                    }
                }

                IList<IReference> references = new List<IReference>();
                source.GetReferences(SystemContext, references);

                for (int ii = 0; ii < references.Count; ii++)
                {
                    IReference reference = references[ii]; 

                    // nothing to do with external nodes.
                    if (reference.TargetId == null || reference.TargetId.IsAbsolute)
                    {
                        continue;
                    }

                    NodeId targetId = (NodeId)reference.TargetId;
                    
                    // add inverse reference to internal targets.
                    NodeState target = null;

                    if (m_predefinedNodes.TryGetValue(targetId, out target))
                    {
                        if (!target.ReferenceExists(reference.ReferenceTypeId, !reference.IsInverse, source.NodeId))
                        {
                            target.AddReference(reference.ReferenceTypeId, !reference.IsInverse, source.NodeId);
                        }

                        continue;
                    }
                    
                    // check for inverse references to external notifiers.
                    if (reference.IsInverse && reference.ReferenceTypeId == ReferenceTypeIds.HasNotifier)
                    {
                        AddRootNotifier(source);
                    }

                    // nothing more to do for references to nodes managed by this manager.
                    if (IsNodeIdInNamespace(targetId))
                    {
                        continue;
                    }

                    // add external reference.
                    AddExternalReference(
                        targetId,
                        reference.ReferenceTypeId,
                        !reference.IsInverse,
                        source.NodeId,
                        externalReferences);
                }
            }
        }

        /// <summary>
        /// Adds an external reference to the dictionary.
        /// </summary>
        protected void AddExternalReference(
            NodeId sourceId,
            NodeId referenceTypeId,
            bool isInverse,
            NodeId targetId,
            IDictionary<NodeId, IList<IReference>> externalReferences)
        {
            // get list of references to external nodes.
            IList<IReference> referencesToAdd = null;

            if (!externalReferences.TryGetValue(sourceId, out referencesToAdd))
            {
                externalReferences[sourceId] = referencesToAdd = new List<IReference>();
            }

            // add reserve reference from external node.
            ReferenceNode referenceToAdd = new ReferenceNode();

            referenceToAdd.ReferenceTypeId = referenceTypeId;
            referenceToAdd.IsInverse = isInverse;
            referenceToAdd.TargetId = targetId;

            referencesToAdd.Add(referenceToAdd);
        }

        /// <summary>
        /// Recursively adds the types to the type tree.
        /// </summary>
        protected void AddTypesToTypeTree(BaseTypeState type)
        {
            if (!NodeId.IsNull(type.SuperTypeId))
            {
                if (!Server.TypeTree.IsKnown(type.SuperTypeId))
                {
                    AddTypesToTypeTree(type.SuperTypeId);
                }
            }

            if (type.NodeClass != NodeClass.ReferenceType)
            {
                Server.TypeTree.AddSubtype(type.NodeId, type.SuperTypeId);
            }
            else
            {
                Server.TypeTree.AddReferenceSubtype(type.NodeId, type.SuperTypeId, type.BrowseName);
            }
        }

        /// <summary>
        /// Recursively adds the types to the type tree.
        /// </summary>
        protected void AddTypesToTypeTree(NodeId typeId)
        {
            BaseTypeState type = Find(typeId) as BaseTypeState;

            if (type == null)
            {
                return;
            }

            AddTypesToTypeTree(type);
        }

        /// <summary>
        /// Finds the specified and checks if it is of the expected type. 
        /// </summary>
        /// <returns>Returns null if not found or not of the correct type.</returns>
        public NodeState FindPredefinedNode(NodeId nodeId, Type expectedType)
        {
            if (nodeId == null)
            {
                return null;
            }

            NodeState node = null;

            if (!PredefinedNodes.TryGetValue(nodeId, out node))
            {
                return null;
            }

            if (expectedType != null)
            {
                if (!expectedType.IsInstanceOfType(node))
                {
                    return null;
                }
            }
                
            return node;
        }
        #endregion

        /// <summary>
        /// Frees any resources allocated for the address space.
        /// </summary>
        public virtual void DeleteAddressSpace()
        {
            lock (Lock)
            {
                m_predefinedNodes.Clear();
            }
        }

        /// <summary>
        /// Returns a unique handle for the node.
        /// </summary>
        /// <remarks>
        /// This must efficiently determine whether the node belongs to the node manager. If it does belong to 
        /// NodeManager it should return a handle that does not require the NodeId to be validated again when
        /// the handle is passed into other methods such as 'Read' or 'Write'.
        /// </remarks>
        public virtual object GetManagerHandle(NodeId nodeId)
        {
            lock (Lock)
            {
                return GetManagerHandle(m_systemContext, nodeId, null);
            }
        }

        /// <summary>
        /// Returns a unique handle for the node.
        /// </summary>
        /// <remarks>
        /// This must efficiently determine whether the node belongs to the node manager. If it does belong to 
        /// NodeManager it should return a handle that does not require the NodeId to be validated again when
        /// the handle is passed into other methods such as 'Read' or 'Write'.
        /// </remarks>
        protected virtual object GetManagerHandle(ISystemContext context, NodeId nodeId, IDictionary<NodeId,NodeState> cache)
        {
            lock (Lock)
            {
                // quickly exclude nodes that not in the namespace.
                if (!IsNodeIdInNamespace(nodeId))
                {
                    return null;
                }

                // lookup the node.
                NodeState node = null;

                if (!m_predefinedNodes.TryGetValue(nodeId, out node))
                {
                    return null;
                }

                return node;
            }
        }

        /// <summary>
        /// This method is used to add bi-directional references to nodes from other node managers.
        /// </summary>
        /// <remarks>
        /// The additional references are optional, however, the NodeManager should support them.
        /// </remarks>
        public virtual void AddReferences(IDictionary<NodeId, IList<IReference>> references)
        {
            lock (Lock)
            {
                foreach (KeyValuePair<NodeId, IList<IReference>> current in references)
                {
                    // check for valid handle.
                    NodeState source = GetManagerHandle(m_systemContext, current.Key, null) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // add reference to external target.
                    foreach (IReference reference in current.Value)
                    {
                        source.AddReference(reference.ReferenceTypeId, reference.IsInverse, reference.TargetId);
                    }
                }
            }
        }
        
        /// <summary>
        /// This method is used to delete bi-directional references to nodes from other node managers.
        /// </summary>
        public virtual ServiceResult DeleteReference(
            object         sourceHandle, 
            NodeId         referenceTypeId, 
            bool           isInverse, 
            ExpandedNodeId targetId, 
            bool           deleteBiDirectional)
        {
            lock (Lock)
            {
                // check for valid handle.
                NodeState source = IsHandleInNamespace(sourceHandle);

                if (source == null)
                {
                    return StatusCodes.BadNodeIdUnknown;
                }

                source.RemoveReference(referenceTypeId, isInverse, targetId);

                if (deleteBiDirectional)
                {
                    // check if the target is also managed by the node manager.
                    if (!targetId.IsAbsolute)
                    {
                        NodeState target = GetManagerHandle(m_systemContext, (NodeId)targetId, null) as NodeState;

                        target?.RemoveReference(referenceTypeId, !isInverse, source.NodeId);
                    }
                }

                return ServiceResult.Good;
            }
        }

        /// <summary>
        /// Returns the basic metadata for the node. Returns null if the node does not exist.
        /// </summary>
        /// <remarks>
        /// This method validates any placeholder handle.
        /// </remarks>
        public virtual NodeMetadata GetNodeMetadata(
            OperationContext context, 
            object           targetHandle, 
            BrowseResultMask resultMask)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                // check for valid handle.
                NodeState target = IsHandleInNamespace(targetHandle);

                if (target == null)
                {
                    return null;                
                }

                // validate node.
                if (!ValidateNode(systemContext, target))
                {
                    return null;
                }

                // read the attributes.
                List<object> values = target.ReadAttributes(
                    systemContext,
                    Attributes.WriteMask,
                    Attributes.UserWriteMask,
                    Attributes.DataType,
                    Attributes.ValueRank,
                    Attributes.ArrayDimensions,
                    Attributes.AccessLevel,
                    Attributes.UserAccessLevel,
                    Attributes.EventNotifier,
                    Attributes.Executable,
                    Attributes.UserExecutable);

                // construct the metadata object.

                NodeMetadata metadata = new NodeMetadata(target, target.NodeId);

                metadata.NodeClass = target.NodeClass;
                metadata.BrowseName = target.BrowseName;
                metadata.DisplayName = target.DisplayName;

                if (values[0] != null && values[1] != null)
                {
                    metadata.WriteMask = (AttributeWriteMask)(((uint)values[0]) & ((uint)values[1]));
                }

                metadata.DataType = (NodeId)values[2];

                if (values[3] != null)
                {
                    metadata.ValueRank = (int)values[3];
                }

                metadata.ArrayDimensions = (IList<uint>)values[4];
                
                if (values[5] != null && values[6] != null)
                {
                    metadata.AccessLevel = (byte)(((byte)values[5]) & ((byte)values[6]));
                }

                if (values[7] != null)
                {
                    metadata.EventNotifier = (byte)values[7];
                }

                if (values[8] != null && values[9] != null)
                {
                    metadata.Executable = (((bool)values[8]) && ((bool)values[9]));
                }

                // get instance references.

                if (target is BaseInstanceState instance)
                {
                    metadata.TypeDefinition = instance.TypeDefinitionId;
                    metadata.ModellingRule = instance.ModellingRuleId;
                }

                // fill in the common attributes.
                return metadata;
            }
        }

        /// <summary>
        /// Browses the references from a node managed by the node manager.
        /// </summary>
        /// <remarks>
        /// The continuation point is created for every browse operation and contains the browse parameters.
        /// The node manager can store its state information in the Data and Index properties.
        /// </remarks>
        public virtual void Browse(
            OperationContext            context, 
            ref ContinuationPoint       continuationPoint, 
            IList<ReferenceDescription> references)
        {
            if (continuationPoint == null) throw new ArgumentNullException(nameof(continuationPoint));
            if (references == null) throw new ArgumentNullException(nameof(references));

            // check for view.
            if (!ViewDescription.IsDefault(continuationPoint.View))
            {
                throw new ServiceResultException(StatusCodes.BadViewIdUnknown);
            }

            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                // verify that the node exists.
                NodeState source = IsHandleInNamespace(continuationPoint.NodeToBrowse);

                if (source == null)
                {
                    throw new ServiceResultException(StatusCodes.BadNodeIdUnknown);
                }

                // validate node.
                if (!ValidateNode(systemContext, source))
                {
                    throw new ServiceResultException(StatusCodes.BadNodeIdUnknown);
                }

                // check for previous continuation point.
                INodeBrowser browser = continuationPoint.Data as INodeBrowser;

                // fetch list of references.
                if (browser == null)
                {
                    // create a new browser.
                    browser = source.CreateBrowser(
                        systemContext,
                        continuationPoint.View,
                        continuationPoint.ReferenceTypeId,
                        continuationPoint.IncludeSubtypes,
                        continuationPoint.BrowseDirection,
                        null,
                        null,
                        false);
                }

                // apply filters to references.
                for (IReference reference = browser.Next(); reference != null; reference = browser.Next())
                {
                    // create the type definition reference.        
                    ReferenceDescription description = GetReferenceDescription(context, reference, continuationPoint);

                    if (description == null)
                    {
                        continue;
                    }

                    // check if limit reached.
                    if (continuationPoint.MaxResultsToReturn != 0 && references.Count >= continuationPoint.MaxResultsToReturn)
                    {
                        browser.Push(reference);
                        continuationPoint.Data = browser;
                        return;
                    }

                    references.Add(description);
                }

                // release the continuation point if all done.
                continuationPoint.Dispose();
                continuationPoint = null;
            }
        }

        #region Browse Support Functions
        /// <summary>
        /// Returns the references for the node that meets the criteria specified.
        /// </summary>
        private ReferenceDescription GetReferenceDescription(
            OperationContext context,
            IReference reference,
            ContinuationPoint continuationPoint)
        {
            // create the type definition reference.        
            ReferenceDescription description = new ReferenceDescription();

            description.NodeId = reference.TargetId;
            description.SetReferenceType(continuationPoint.ResultMask, reference.ReferenceTypeId, !reference.IsInverse);

            // do not cache target parameters for remote nodes.
            if (reference.TargetId.IsAbsolute)
            {
                // only return remote references if no node class filter is specified.
                if (continuationPoint.NodeClassMask != 0)
                {
                    return null;
                }

                return description;
            }

            NodeState target = null;

            // check for local reference.

            if (reference is NodeStateReference referenceInfo)
            {
                target = referenceInfo.Target;
            }

            // check for internal reference.
            if (target == null)
            {
                NodeId targetId = (NodeId)reference.TargetId;

                if (IsNodeIdInNamespace(targetId))
                {
                    if (!PredefinedNodes.TryGetValue(targetId, out target))
                    {
                        target = null;
                    }
                }
            }

            // the target may be a reference to a node in another node manager. In these cases
            // the target attributes must be fetched by the caller. The Unfiltered flag tells the
            // caller to do that.
            if (target == null)
            {
                description.Unfiltered = true;
                return description;
            }

            // apply node class filter.
            if (continuationPoint.NodeClassMask != 0 && ((continuationPoint.NodeClassMask & (uint)target.NodeClass) == 0))
            {
                return null;
            }

            NodeId typeDefinition = null;

            if (target is BaseInstanceState instance)
            {
                typeDefinition = instance.TypeDefinitionId;
            }

            // set target attributes.
            description.SetTargetAttributes(
                continuationPoint.ResultMask,
                target.NodeClass,
                target.BrowseName,
                target.DisplayName,
                typeDefinition);

            return description;
        }
        #endregion

        /// <summary>
        /// Returns the target of the specified browse path fragment(s).
        /// </summary>
        /// <remarks>
        /// If reference exists but the node manager does not know the browse name it must 
        /// return the NodeId as an unresolvedTargetIds. The caller will try to check the
        /// browse name. 
        /// </remarks>
        public virtual void TranslateBrowsePath(
            OperationContext      context, 
            object                sourceHandle, 
            RelativePathElement   relativePath, 
            IList<ExpandedNodeId> targetIds, 
            IList<NodeId>         unresolvedTargetIds)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();

            lock (Lock)
            {
                // verify that the node exists.
                NodeState source = IsHandleInNamespace(sourceHandle);

                if (source == null)
                {
                    return;
                }

                // validate node.
                if (!ValidateNode(systemContext, source))
                {
                    return;
                }

                // get list of references that relative path.
                INodeBrowser browser = source.CreateBrowser(
                    systemContext,
                    null,
                    relativePath.ReferenceTypeId,
                    relativePath.IncludeSubtypes,
                    (relativePath.IsInverse) ? BrowseDirection.Inverse : BrowseDirection.Forward,
                    relativePath.TargetName,
                    null,
                    false);

                // check the browse names.
                try
                {
                    for (IReference reference = browser.Next(); reference != null; reference = browser.Next())
                    {
                        // ignore unknown external references.
                        if (reference.TargetId.IsAbsolute)
                        {
                            continue;
                        }

                        NodeState target = null;

                        // check for local reference.

                        if (reference is NodeStateReference referenceInfo)
                        {
                            target = referenceInfo.Target;
                        }

                        if (target == null)
                        {
                            NodeId targetId = (NodeId)reference.TargetId;

                            // the target may be a reference to a node in another node manager.
                            if (!IsNodeIdInNamespace(targetId))
                            {
                                unresolvedTargetIds.Add((NodeId)reference.TargetId);
                                continue;
                            }

                            // look up the target manually.
                            target = GetManagerHandle(systemContext, targetId, operationCache) as NodeState;

                            if (target == null)
                            {
                                continue;
                            }
                        }

                        // check browse name.
                        if (target.BrowseName == relativePath.TargetName)
                        {
                            if (!targetIds.Contains(reference.TargetId))
                            {
                                targetIds.Add(reference.TargetId);
                            }
                        }
                    }
                }
                finally
                {
                    browser.Dispose();
                }
            }
        }
        
        /// <summary>
        /// Reads the value for the specified attribute.
        /// </summary>
        public virtual void Read(
            OperationContext     context, 
            double               maxAge, 
            IList<ReadValueId>   nodesToRead, 
            IList<DataValue>     values, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<ReadWriteOperationState> nodesToValidate = new List<ReadWriteOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToRead.Count; ii++)
                {                    
                    ReadValueId nodeToRead = nodesToRead[ii];

                    // skip items that have already been processed.
                    if (nodeToRead.Processed)
                    {
                        continue;
                    }
                    
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, nodeToRead.NodeId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToRead.Processed = true;
                    
                    // create an initial value.
                    DataValue value = values[ii] = new DataValue();
                    
                    value.Value           = null;
                    value.ServerTimestamp = DateTime.UtcNow;
                    value.SourceTimestamp = DateTime.MinValue;
                    value.StatusCode      = StatusCodes.Good;

                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        
                        // must validate node in a seperate operation.
                        ReadWriteOperationState operation = new ReadWriteOperationState();
                        
                        operation.Source = source;
                        operation.Index = ii;

                        nodesToValidate.Add(operation);
                        
                        continue;
                    }

                    // read the attribute value.
                    errors[ii] = source.ReadAttribute(
                        systemContext,
                        nodeToRead.AttributeId,
                        nodeToRead.ParsedIndexRange,
                        nodeToRead.DataEncoding,
                        value);
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    ReadWriteOperationState operation = nodesToValidate[ii];

                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }
                    
                    ReadValueId nodeToRead = nodesToRead[operation.Index];
                    DataValue value = values[operation.Index];

                    // update the attribute value.
                    errors[operation.Index] = operation.Source.ReadAttribute(
                        systemContext,
                        nodeToRead.AttributeId,
                        nodeToRead.ParsedIndexRange,
                        nodeToRead.DataEncoding,
                        value);
                }
            }
        }        
        
        /// <summary>
        /// Stores the state of a call method operation.
        /// </summary>
        private struct ReadWriteOperationState
        {
            public NodeState Source;
            public int Index;
        }        
        
        /// <summary>
        /// Verifies that the specified node exists.
        /// </summary>
        protected virtual bool ValidateNode(ServerSystemContext context, NodeState node)
        {
            // validate node only if required.
            if (node.ValidationRequired)
            {
                return node.Validate(context);
            }

            return true;
        }
        
        /// <summary>
        /// Reads the history for the specified nodes.
        /// </summary>
        public virtual void HistoryRead(
            OperationContext          context, 
            HistoryReadDetails        details, 
            TimestampsToReturn        timestampsToReturn, 
            bool                      releaseContinuationPoints, 
            IList<HistoryReadValueId> nodesToRead, 
            IList<HistoryReadResult>  results, 
            IList<ServiceResult>      errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<ReadWriteOperationState> nodesToValidate = new List<ReadWriteOperationState>();
            List<ReadWriteOperationState> readsToComplete = new List<ReadWriteOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToRead.Count; ii++)
                {                    
                    HistoryReadValueId nodeToRead = nodesToRead[ii];

                    // skip items that have already been processed.
                    if (nodeToRead.Processed)
                    {
                        continue;
                    }
                    
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, nodeToRead.NodeId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToRead.Processed = true;

                    // only variables supported.
                    BaseVariableState variable = source as BaseVariableState;

                    if (variable == null)
                    {
                        errors[ii] = StatusCodes.BadHistoryOperationUnsupported;
                        continue;
                    }
                    
                    results[ii] = new HistoryReadResult();
                    
                    ReadWriteOperationState operation = new ReadWriteOperationState();
                    
                    operation.Source = source;
                    operation.Index = ii;

                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        // must validate node in a seperate operation.
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        nodesToValidate.Add(operation);                        
                        continue;
                    }

                    // read the data.
                    readsToComplete.Add(operation);
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    ReadWriteOperationState operation = nodesToValidate[ii];

                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }

                    readsToComplete.Add(operation);
                }
            }

            // reads the data without holding onto the lock.
            for (int ii = 0; ii < readsToComplete.Count; ii++)
            {
                ReadWriteOperationState operation = readsToComplete[ii];

                errors[operation.Index] = HistoryRead(
                    systemContext,
                    operation.Source,
                    details,
                    timestampsToReturn,
                    releaseContinuationPoints,
                    nodesToRead[operation.Index],
                    results[operation.Index]);
            }
        }

        /// <summary>
        /// Reads the history for a single node which has already been validated.
        /// </summary>
        protected virtual ServiceResult HistoryRead(
            ISystemContext context, 
            NodeState           source,
            HistoryReadDetails  details, 
            TimestampsToReturn  timestampsToReturn, 
            bool                releaseContinuationPoints, 
            HistoryReadValueId  nodesToRead, 
            HistoryReadResult   result)
        {
            // check for variable.
            BaseVariableState variable = source as BaseVariableState;

            if (variable == null)
            {
                return StatusCodes.BadHistoryOperationUnsupported;
            }

            // check for access.
            lock (Lock)
            {
                if ((variable.AccessLevel & AccessLevels.HistoryRead) == 0)
                {
                    return StatusCodes.BadNotReadable;
                }
            }

            // handle read raw.

            if (details is ReadRawModifiedDetails readRawDetails)
            {
                return HistoryReadRaw(
                    context,
                    variable,
                    readRawDetails,
                    timestampsToReturn,
                    releaseContinuationPoints,
                    nodesToRead,
                    result);
            }

            // handle read processed.

            if (details is ReadProcessedDetails readProcessedDetails)
            {
                return HistoryReadProcessed(
                    context,
                    variable,
                    readProcessedDetails,
                    timestampsToReturn,
                    releaseContinuationPoints,
                    nodesToRead,
                    result);
            }

            // handle read processed.

            if (details is ReadAtTimeDetails readAtTimeDetails)
            {
                return HistoryReadAtTime(
                    context,
                    variable,
                    readAtTimeDetails,
                    timestampsToReturn,
                    releaseContinuationPoints,
                    nodesToRead,
                    result);
            }
 
            return StatusCodes.BadHistoryOperationUnsupported;
        }
         
        /// <summary>
        /// Reads the raw history for the variable value.
        /// </summary>
        protected virtual ServiceResult HistoryReadRaw(
            ISystemContext context, 
            BaseVariableState      source,
            ReadRawModifiedDetails details, 
            TimestampsToReturn     timestampsToReturn, 
            bool                   releaseContinuationPoints, 
            HistoryReadValueId     nodeToRead, 
            HistoryReadResult      result)
        {
            return StatusCodes.BadHistoryOperationUnsupported;
        }
         
        /// <summary>
        /// Reads the processed history for the variable value.
        /// </summary>
        protected virtual ServiceResult HistoryReadProcessed(
            ISystemContext context, 
            BaseVariableState      source,
            ReadProcessedDetails   details, 
            TimestampsToReturn     timestampsToReturn, 
            bool                   releaseContinuationPoints, 
            HistoryReadValueId     nodeToRead, 
            HistoryReadResult      result)
        {
            return StatusCodes.BadHistoryOperationUnsupported;
        }
         
        /// <summary>
        /// Reads the history for the variable value.
        /// </summary>
        protected virtual ServiceResult HistoryReadAtTime(
            ISystemContext context, 
            BaseVariableState      source,
            ReadAtTimeDetails      details, 
            TimestampsToReturn     timestampsToReturn, 
            bool                   releaseContinuationPoints, 
            HistoryReadValueId     nodeToRead, 
            HistoryReadResult      result)
        {
            return StatusCodes.BadHistoryOperationUnsupported;
        }
        
        
        /// <summary>
        /// Writes the value for the specified attributes.
        /// </summary>
        public virtual void Write(
            OperationContext     context, 
            IList<WriteValue>    nodesToWrite, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<ReadWriteOperationState> nodesToValidate = new List<ReadWriteOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToWrite.Count; ii++)
                {                    
                    WriteValue nodeToWrite = nodesToWrite[ii];

                    // skip items that have already been processed.
                    if (nodeToWrite.Processed)
                    {
                        continue;
                    }
                    
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, nodeToWrite.NodeId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToWrite.Processed = true;

                    // index range is not supported.
                    if (!String.IsNullOrEmpty(nodeToWrite.IndexRange))
                    {
                        errors[ii] = StatusCodes.BadIndexRangeInvalid;
                        continue;
                    }
                    
                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        
                        // must validate node in a seperate operation.
                        ReadWriteOperationState operation = new ReadWriteOperationState();
                        
                        operation.Source = source;
                        operation.Index = ii;

                        nodesToValidate.Add(operation);
                        
                        continue;
                    }

                    // write the attribute value.
                    errors[ii] = source.WriteAttribute(
                        systemContext,
                        nodeToWrite.AttributeId,
                        nodeToWrite.ParsedIndexRange,
                        nodeToWrite.Value);

                    // updates to source finished - report changes to monitored items.
                    source.ClearChangeMasks(systemContext, false);
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    ReadWriteOperationState operation = nodesToValidate[ii];

                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }
                    
                    WriteValue nodeToWrite = nodesToWrite[operation.Index];

                    // write the attribute value.
                    errors[operation.Index] = operation.Source.WriteAttribute(
                        systemContext,
                        nodeToWrite.AttributeId,
                        nodeToWrite.ParsedIndexRange,
                        nodeToWrite.Value);

                    // updates to source finished - report changes to monitored items.
                    operation.Source.ClearChangeMasks(systemContext, false);
                }
            }
        }
        
        /// <summary>
        /// Updates the history for the specified nodes.
        /// </summary>
        public virtual void HistoryUpdate(
            OperationContext            context, 
            Type                        detailsType, 
            IList<HistoryUpdateDetails> nodesToUpdate, 
            IList<HistoryUpdateResult>  results,
            IList<ServiceResult>        errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<ReadWriteOperationState> nodesToValidate = new List<ReadWriteOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < nodesToUpdate.Count; ii++)
                {                    
                    HistoryUpdateDetails nodeToUpdate = nodesToUpdate[ii];

                    // skip items that have already been processed.
                    if (nodeToUpdate.Processed)
                    {
                        continue;
                    }
                    
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, nodeToUpdate.NodeId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    nodeToUpdate.Processed = true;
                    
                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        
                        // must validate node in a seperate operation.
                        ReadWriteOperationState operation = new ReadWriteOperationState();
                        
                        operation.Source = source;
                        operation.Index = ii;

                        nodesToValidate.Add(operation);
                        
                        continue;
                    }

                    // historical data not available.
                    errors[ii] = StatusCodes.BadHistoryOperationUnsupported;
                }

                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    ReadWriteOperationState operation = nodesToValidate[ii];

                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }
                    
                    // historical data not available.
                    errors[ii] = StatusCodes.BadHistoryOperationUnsupported;
                }
            }
        }

        /// <summary>
        /// Calls a method on the specified nodes.
        /// </summary>
        public virtual void Call(
            OperationContext         context, 
            IList<CallMethodRequest> methodsToCall, 
            IList<CallMethodResult>  results, 
            IList<ServiceResult>     errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<CallOperationState> nodesToValidate = new List<CallOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < methodsToCall.Count; ii++)
                {                    
                    CallMethodRequest methodToCall = methodsToCall[ii];

                    // skip items that have already been processed.
                    if (methodToCall.Processed)
                    {
                        continue;
                    }
                    
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, methodToCall.ObjectId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    methodToCall.Processed = true;

                    // check for valid method.
                    MethodState method = GetManagerHandle(systemContext, methodToCall.MethodId, operationCache) as MethodState;

                    if (method == null)
                    {
                        errors[ii] = StatusCodes.BadMethodInvalid;
                        continue;
                    }

                    // check if method belongs to the object.
                    if (!Object.ReferenceEquals(method.Parent, source))
                    {
                        errors[ii] = StatusCodes.BadMethodInvalid;
                        continue;
                    }
                    
                    CallMethodResult result = results[ii] = new CallMethodResult();

                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        
                        // must validate node in a seperate operation.
                        CallOperationState operation = new CallOperationState();
                        
                        operation.Source = source;
                        operation.Method = method;
                        operation.Index = ii;

                        nodesToValidate.Add(operation);

                        continue;
                    }
                    
                    // call the method.
                    errors[ii] = Call(
                        systemContext,
                        methodToCall,
                        source,
                        method,
                        result);
                }
                                
                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    CallOperationState operation = nodesToValidate[ii];

                    // validate the object.
                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }
                             
                    // call the method.
                    CallMethodResult result = results[operation.Index];

                    errors[operation.Index] = Call(
                        systemContext,
                        methodsToCall[operation.Index],
                        operation.Source,
                        operation.Method,
                        result);
                }
            }
        }
        
        /// <summary>
        /// Stores the state of a call method operation.
        /// </summary>
        private struct CallOperationState
        {
            public NodeState Source;
            public MethodState Method;
            public int Index;
        }
        
        /// <summary>
        /// Calls a method on an object.
        /// </summary>
        protected virtual ServiceResult Call(
            ISystemContext context,
            CallMethodRequest methodToCall,
            NodeState source,
            MethodState method,
            CallMethodResult result)
        {
            ServerSystemContext systemContext = context as ServerSystemContext;
            List<ServiceResult> argumentErrors = new List<ServiceResult>();
            VariantCollection outputArguments = new VariantCollection();

            ServiceResult error = method.Call(
                context,
                methodToCall.ObjectId,
                methodToCall.InputArguments,
                argumentErrors,
                outputArguments);

            if (ServiceResult.IsBad(error))
            {
                return error;
            }

            // check for argument errors.
            bool argumentsValid = true;

            for (int jj = 0; jj < argumentErrors.Count; jj++)
            {
                ServiceResult argumentError = argumentErrors[jj];

                if (argumentError != null)
                {
                    result.InputArgumentResults.Add(argumentError.StatusCode);
                                  
                    if (ServiceResult.IsBad(argumentError))
                    {
                        argumentsValid = false;
                    }
                }
                else
                {
                    result.InputArgumentResults.Add(StatusCodes.Good);
                }

                // only fill in diagnostic info if it is requested.
                if ((systemContext.OperationContext.DiagnosticsMask & DiagnosticsMasks.OperationAll) != 0)
                {
                    if (ServiceResult.IsBad(argumentError))
                    {
                        argumentsValid = false;
                        result.InputArgumentDiagnosticInfos.Add(new DiagnosticInfo(argumentError, systemContext.OperationContext.DiagnosticsMask, false, systemContext.OperationContext.StringTable));
                    }
                    else
                    {
                        result.InputArgumentDiagnosticInfos.Add(null);
                    }
                }
            }

            // check for validation errors.
            if (!argumentsValid)
            {
                result.StatusCode = StatusCodes.BadInvalidArgument;
                return result.StatusCode;
            }

            // do not return diagnostics if there are no errors.
            result.InputArgumentDiagnosticInfos.Clear();

            // return output arguments.
            result.OutputArguments = outputArguments;

            return ServiceResult.Good;
        }

        /// <summary>
        /// Subscribes or unsubscribes to events produced by the specified source.
        /// </summary>
        /// <remarks>
        /// This method is called when a event subscription is created or deletes. The node manager 
        /// must  start/stop reporting events for the specified object and all objects below it in 
        /// the notifier hierarchy.
        /// </remarks>
        public virtual ServiceResult SubscribeToEvents(
            OperationContext    context, 
            object              sourceId, 
            uint                subscriptionId, 
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();

            lock (Lock)
            {
                // check for valid handle.
                NodeState source = IsHandleInNamespace(sourceId);

                if (source == null)
                {
                    return StatusCodes.BadNodeIdInvalid;
                }

                // check if the object supports subscritions.
                BaseObjectState instance = sourceId as BaseObjectState;

                if (instance == null || instance.EventNotifier != EventNotifiers.SubscribeToEvents)
                {
                    return StatusCodes.BadNotSupported;
                }

                // handle unsubscribe.
                if (unsubscribe)
                {
                    if (instance.Handle is MonitoredNode monitoredNode)
                    {
                        monitoredNode.UnsubscribeToEvents(systemContext, monitoredItem);

                        // do any post processing.
                        OnUnsubscribeToEvents(systemContext, monitoredNode, monitoredItem);
                    }

                    return ServiceResult.Good;
                }

                // subscribe to events.
                if (monitoredNode == null)
                {
                    instance.Handle = monitoredNode = new MonitoredNode(m_server, this, source);
                }

                monitoredNode.SubscribeToEvents(systemContext, monitoredItem);

                // do any post processing.
                OnSubscribeToEvents(systemContext, monitoredNode, monitoredItem);

                return ServiceResult.Good;
            }
        }
        
        /// <summary>
        /// Subscribes or unsubscribes to events produced by all event sources.
        /// </summary>
        /// <remarks>
        /// This method is called when a event subscription is created or deleted. The node 
        /// manager must start/stop reporting events for all objects that it manages.
        /// </remarks>
        public virtual ServiceResult SubscribeToAllEvents(
            OperationContext    context, 
            uint                subscriptionId, 
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();

            lock (Lock)
            {
                // update root notifiers.
                for (int ii = 0; ii < m_rootNotifiers.Count; ii++)
                {
                    SubscribeToAllEvents(
                        systemContext,
                        monitoredItem,
                        unsubscribe,
                        m_rootNotifiers[ii]);
                }

                return ServiceResult.Good;
            }
        }

        /// <summary>
        /// Subscribes/unsubscribes to all events produced by the specified node.
        /// </summary>
        protected void SubscribeToAllEvents(
            ISystemContext      systemContext, 
            IEventMonitoredItem monitoredItem, 
            bool                unsubscribe,
            NodeState           source)
        {

            // handle unsubscribe.
            if (unsubscribe)
            {
                if (source.Handle is MonitoredNode monitoredNode)
                {
                    monitoredNode.UnsubscribeToEvents(systemContext, monitoredItem);

                    // do any post processing.
                    OnUnsubscribeToEvents(systemContext, monitoredNode, monitoredItem);
                }

                return;
            }

            // subscribe to events.
            if (monitoredNode == null)
            {
                source.Handle = monitoredNode = new MonitoredNode(m_server, this, source);
            }

            monitoredNode.SubscribeToEvents(systemContext, monitoredItem);

            // do any post processing.
            OnSubscribeToEvents(systemContext, monitoredNode, monitoredItem);
        }

        /// <summary>
        /// Does any processing after a monitored item is subscribed to.
        /// </summary>
        protected virtual void OnSubscribeToEvents(
            ISystemContext systemContext,
            MonitoredNode monitoredNode,
            IEventMonitoredItem monitoredItem)
        {
            // does nothing.
        }

        /// <summary>
        /// Does any processing after a monitored item is subscribed to.
        /// </summary>
        protected virtual void OnUnsubscribeToEvents(
            ISystemContext systemContext,
            MonitoredNode monitoredNode,
            IEventMonitoredItem monitoredItem)
        {
            // does nothing.
        }

        /// <summary>
        /// Tells the node manager to refresh any conditions associated with the specified monitored items.
        /// </summary>
        /// <remarks>
        /// This method is called when the condition refresh method is called for a subscription.
        /// The node manager must create a refresh event for each condition monitored by the subscription.
        /// </remarks>
        public virtual ServiceResult ConditionRefresh(
            OperationContext           context, 
            IList<IEventMonitoredItem> monitoredItems)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    IEventMonitoredItem monitoredItem = monitoredItems[ii];

                    if (monitoredItem == null)
                    {
                        continue;
                    }
                    
                    // check for global subscription.
                    if (monitoredItem.MonitoringAllEvents)
                    {
                        for (int jj = 0; jj < m_rootNotifiers.Count; jj++)
                        {
                            MonitoredNode monitoredNode = m_rootNotifiers[jj].Handle as MonitoredNode;

                            if (monitoredNode == null)
                            {
                                continue;
                            }

                            monitoredNode.ConditionRefresh(systemContext, monitoredItem);
                        }
                    }

                    // check for subscription to local node.
                    else
                    {
                        NodeState source = IsHandleInNamespace(monitoredItem.ManagerHandle );

                        if (source == null)
                        {
                            continue;
                        }
                        
                        MonitoredNode monitoredNode = source.Handle as MonitoredNode;
                        
                        if (monitoredNode == null)
                        {
                            continue;
                        }
                                
                        monitoredNode.ConditionRefresh(systemContext, monitoredItem);
                    }
                }
            }

            return ServiceResult.Good;
        }

        /// <summary>
        /// Creates a new set of monitored items for a set of variables.
        /// </summary>
        /// <remarks>
        /// This method only handles data change subscriptions. Event subscriptions are created by the SDK.
        /// </remarks>
        public virtual void CreateMonitoredItems(
            OperationContext                  context, 
            uint                              subscriptionId, 
            double                            publishingInterval, 
            TimestampsToReturn                timestampsToReturn, 
            IList<MonitoredItemCreateRequest> itemsToCreate, 
            IList<ServiceResult>              errors, 
            IList<MonitoringFilterResult>     filterErrors, 
            IList<IMonitoredItem>             monitoredItems,
            ref long                          globalIdCounter)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);
            IDictionary<NodeId,NodeState> operationCache = new NodeIdDictionary<NodeState>();
            List<ReadWriteOperationState> nodesToValidate = new List<ReadWriteOperationState>();

            lock (Lock)
            {
                for (int ii = 0; ii < itemsToCreate.Count; ii++)
                {                    
                    MonitoredItemCreateRequest itemToCreate = itemsToCreate[ii];

                    // skip items that have already been processed.
                    if (itemToCreate.Processed)
                    {
                        continue;
                    }

                    ReadValueId itemToMonitor = itemToCreate.ItemToMonitor;
                                        
                    // check for valid handle.
                    NodeState source = GetManagerHandle(systemContext, itemToMonitor.NodeId, operationCache) as NodeState;

                    if (source == null)
                    {
                        continue;
                    }

                    // owned by this node manager.
                    itemToCreate.Processed = true;

                    // check if the node is ready for reading.
                    if (source.ValidationRequired)
                    {
                        errors[ii] = StatusCodes.BadNodeIdUnknown;
                        
                        // must validate node in a seperate operation.
                        ReadWriteOperationState operation = new ReadWriteOperationState();
                        
                        operation.Source = source;
                        operation.Index = ii;

                        nodesToValidate.Add(operation);

                        continue;
                    }

                    MonitoringFilterResult filterError = null;
                    IMonitoredItem monitoredItem = null;

                    errors[ii] = CreateMonitoredItem(
                        systemContext,
                        source,
                        subscriptionId,
                        publishingInterval,
                        context.DiagnosticsMask,
                        timestampsToReturn,
                        itemToCreate,
                        ref globalIdCounter,
                        out filterError,
                        out monitoredItem);

                    // save any filter error details.
                    filterErrors[ii] = filterError;

                    if (ServiceResult.IsBad(errors[ii]))
                    {
                        continue;
                    }

                    // save the monitored item.
                    monitoredItems[ii] = monitoredItem;
                }
                                
                // check for nothing to do.
                if (nodesToValidate.Count == 0)
                {
                    return;
                }

                // validates the nodes (reads values from the underlying data source if required).
                for (int ii = 0; ii < nodesToValidate.Count; ii++)
                {
                    ReadWriteOperationState operation = nodesToValidate[ii];

                    // validate the object.
                    if (!ValidateNode(systemContext, operation.Source))
                    {
                        continue;
                    }
                    
                    MonitoredItemCreateRequest itemToCreate = itemsToCreate[operation.Index];

                    MonitoringFilterResult filterError = null;
                    IMonitoredItem monitoredItem = null;

                    errors[operation.Index] = CreateMonitoredItem(
                        systemContext,
                        operation.Source,
                        subscriptionId,
                        publishingInterval,
                        context.DiagnosticsMask,
                        timestampsToReturn,
                        itemToCreate,
                        ref globalIdCounter,
                        out filterError,
                        out monitoredItem);

                    // save any filter error details.
                    filterErrors[operation.Index] = filterError;

                    if (ServiceResult.IsBad(errors[operation.Index]))
                    {
                        continue;
                    }

                    // save the monitored item.
                    monitoredItems[operation.Index] = monitoredItem;
                }
            }
        }

        /// <summary>
        /// Validates a data change filter provided by the client.
        /// </summary>
        /// <param name="context">The system context.</param>
        /// <param name="source">The node being monitored.</param>
        /// <param name="attributeId">The attribute being monitored.</param>
        /// <param name="requestedFilter">The requested monitoring filter.</param>
        /// <param name="filter">The validated data change filter.</param>
        /// <param name="range">The EU range associated with the value if required by the filter.</param>
        /// <returns>Any error condition. Good if no errors occurred.</returns>
        protected ServiceResult ValidateDataChangeFilter(
            ISystemContext context,
            NodeState source,
            uint attributeId,
            ExtensionObject requestedFilter,
            out DataChangeFilter filter,
            out Range range)
        {
            filter = null;
            range = null;

            // check for valid filter type.
            filter = requestedFilter.Body as DataChangeFilter;

            if (filter == null)
            {
                return StatusCodes.BadMonitoredItemFilterUnsupported;
            }

            // only supported for value attributes.
            if (attributeId != Attributes.Value)
            {
                return StatusCodes.BadMonitoredItemFilterUnsupported;
            }

            // only supported for variables.
            BaseVariableState variable = source as BaseVariableState;
            
            if (variable == null)
            {
                return StatusCodes.BadMonitoredItemFilterUnsupported;
            }

            // check the datatype.
            if (filter.DeadbandType != (uint)DeadbandType.None)
            {
                BuiltInType builtInType = TypeInfo.GetBuiltInType(variable.DataType, Server.TypeTree);

                if (!TypeInfo.IsNumericType(builtInType))
                {
                    return StatusCodes.BadMonitoredItemFilterUnsupported;
                }
            }

            // validate filter.
            ServiceResult error = filter.Validate();

            if (ServiceResult.IsBad(error))
            {
                return error;
            }

            if (filter.DeadbandType ==(uint)DeadbandType.Percent)
            {
                BaseVariableState euRange = variable.FindChild(context, BrowseNames.EURange) as BaseVariableState;

                if (euRange == null)
                {
                    return StatusCodes.BadMonitoredItemFilterUnsupported;
                }

                range = euRange.Value as Range;
                
                if (range == null)
                {
                    return StatusCodes.BadMonitoredItemFilterUnsupported;
                }
            }

            // all good.
            return ServiceResult.Good;
        }

        /// <summary>
        /// Creates a new set of monitored items for a set of variables.
        /// </summary>
        /// <remarks>
        /// This method only handles data change subscriptions. Event subscriptions are created by the SDK.
        /// </remarks>
        protected virtual ServiceResult CreateMonitoredItem(
            ISystemContext context,
            NodeState source,
            uint subscriptionId,
            double publishingInterval,
            DiagnosticsMasks diagnosticsMasks,
            TimestampsToReturn timestampsToReturn,
            MonitoredItemCreateRequest itemToCreate,
            ref long globalIdCounter,
            out MonitoringFilterResult filterError,
            out IMonitoredItem monitoredItem)
        {
            filterError = null;
            monitoredItem = null;
            ServiceResult error = null;
            
            // read initial value.
            DataValue initialValue = new DataValue();

            initialValue.Value = null;
            initialValue.ServerTimestamp = DateTime.UtcNow;
            initialValue.SourceTimestamp = DateTime.MinValue;
            initialValue.StatusCode = StatusCodes.Good;

            error = source.ReadAttribute(
                context,
                itemToCreate.ItemToMonitor.AttributeId,
                itemToCreate.ItemToMonitor.ParsedIndexRange,
                itemToCreate.ItemToMonitor.DataEncoding,
                initialValue);

            if (ServiceResult.IsBad(error))
            {
                return error;
            }
            
            // validate parameters.
            MonitoringParameters parameters = itemToCreate.RequestedParameters;

            // validate the data change filter.
            DataChangeFilter filter = null;
            Range range = null;

            if (!ExtensionObject.IsNull(parameters.Filter))
            {
                error = ValidateDataChangeFilter(
                    context,
                    source,
                    itemToCreate.ItemToMonitor.AttributeId,
                    parameters.Filter,
                    out filter,
                    out range);

                if (ServiceResult.IsBad(error))
                {
                    return error;
                }
            }

            // create monitored node.
            MonitoredNode monitoredNode = source.Handle as MonitoredNode;

            if (monitoredNode == null)
            {
                source.Handle = monitoredNode = new MonitoredNode(m_server, this, source);
            }

            // create a globally unique identifier.
            uint monitoredItemId = Utils.IncrementIdentifier(ref globalIdCounter);

            // determine the sampling interval.
            double samplingInterval = itemToCreate.RequestedParameters.SamplingInterval;

            if (samplingInterval < 0)
            {
                samplingInterval = publishingInterval;
            }

            // check if the variable needs to be sampled.
            bool samplingRequired = false;

            if (itemToCreate.ItemToMonitor.AttributeId == Attributes.Value)
            {
                BaseVariableState variable = source as BaseVariableState;

                if (variable.MinimumSamplingInterval > 0)
                {
                    samplingInterval = CalculateSamplingInterval(variable, samplingInterval);
                    samplingRequired = true;
                }
            }

            // create the item.
            DataChangeMonitoredItem datachangeItem = monitoredNode.CreateDataChangeItem(
                context,
                monitoredItemId,
                itemToCreate.ItemToMonitor.AttributeId,
                itemToCreate.ItemToMonitor.ParsedIndexRange,
                itemToCreate.ItemToMonitor.DataEncoding,
                diagnosticsMasks,
                timestampsToReturn,
                itemToCreate.MonitoringMode,
                itemToCreate.RequestedParameters.ClientHandle,
                samplingInterval,
                itemToCreate.RequestedParameters.QueueSize,
                itemToCreate.RequestedParameters.DiscardOldest,
                filter,
                range,
                false);

            if (samplingRequired)
            {
                CreateSampledItem(samplingInterval, datachangeItem);
            }

            // report the initial value.
            datachangeItem.QueueValue(initialValue, null);

            // do any post processing.
            OnCreateMonitoredItem(context, itemToCreate, monitoredNode, datachangeItem);

            // update monitored item list.
            monitoredItem = datachangeItem;

            return ServiceResult.Good;
        }

        /// <summary>
        /// Calculates the sampling interval.
        /// </summary>
        private double CalculateSamplingInterval(BaseVariableState variable, double samplingInterval)
        {
            if (samplingInterval < variable.MinimumSamplingInterval)
            {
                samplingInterval = variable.MinimumSamplingInterval;
            }

            if ((samplingInterval % m_minimumSamplingInterval) != 0)
            {
                samplingInterval = Math.Truncate(samplingInterval/m_minimumSamplingInterval);
                samplingInterval += 1;
                samplingInterval *= m_minimumSamplingInterval;
            }

            return samplingInterval;
        }
        
        /// <summary>
        /// Creates a new sampled item.
        /// </summary>
        private void CreateSampledItem(double samplingInterval, DataChangeMonitoredItem monitoredItem)
        {
            m_sampledItems.Add(monitoredItem);

            if (m_samplingTimer == null)
            {
                m_samplingTimer = new Timer(DoSample, null, (int)m_minimumSamplingInterval, (int)m_minimumSamplingInterval);
            }
        }
        
        /// <summary>
        /// Deletes a sampled item.
        /// </summary>
        private void DeleteSampledItem(DataChangeMonitoredItem monitoredItem)
        {
            for (int ii = 0; ii < m_sampledItems.Count; ii++)
            {
                if (Object.ReferenceEquals(monitoredItem, m_sampledItems[ii]))
                {
                    m_sampledItems.RemoveAt(ii);
                    break;
                }
            }

            if (m_sampledItems.Count == 0)
            {
                if (m_samplingTimer != null)
                {
                    m_samplingTimer.Dispose();
                    m_samplingTimer = null;
                }
            }
        }

        /// <summary>
        /// Polls each monitored item which requires sample. 
        /// </summary>
        private void DoSample(object state)
        {
            try
            {
                lock (m_lock)
                {
                    for (int ii = 0; ii < m_sampledItems.Count; ii++)
                    {
                        DataChangeMonitoredItem monitoredItem = m_sampledItems[ii];

                        if (monitoredItem.TimeToNextSample < m_minimumSamplingInterval)
                        {
                            monitoredItem.ValueChanged(SystemContext);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Unexpected error during diagnostics scan.");
            }
        }

        /// <summary>
        /// Does any processing after a monitored item is created.
        /// </summary>
        protected virtual void OnCreateMonitoredItem(
            ISystemContext systemContext,
            MonitoredItemCreateRequest itemToCreate,
            MonitoredNode monitoredNode, 
            DataChangeMonitoredItem monitoredItem)
        {
            // does nothing.
        }

        /// <summary>
        /// Modifies the parameters for a set of monitored items.
        /// </summary>
        public virtual void ModifyMonitoredItems(
            OperationContext                  context, 
            TimestampsToReturn                timestampsToReturn, 
            IList<IMonitoredItem>             monitoredItems, 
            IList<MonitoredItemModifyRequest> itemsToModify, 
            IList<ServiceResult>              errors, 
            IList<MonitoringFilterResult>     filterErrors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {                    
                    MonitoredItemModifyRequest itemToModify = itemsToModify[ii];

                    // skip items that have already been processed.
                    if (itemToModify.Processed || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // modify the monitored item.
                    MonitoringFilterResult filterError = null;

                    errors[ii] = ModifyMonitoredItem(
                        systemContext,
                        context.DiagnosticsMask,
                        timestampsToReturn,
                        monitoredItems[ii],
                        itemToModify,
                        out filterError);

                    // save any filter error details.
                    filterErrors[ii] = filterError;
                }
            }
        }

        /// <summary>
        /// Modifies the parameters for a monitored item.
        /// </summary>
        protected virtual ServiceResult ModifyMonitoredItem(
            ISystemContext context,
            DiagnosticsMasks diagnosticsMasks,
            TimestampsToReturn timestampsToReturn,
            IMonitoredItem monitoredItem,
            MonitoredItemModifyRequest itemToModify,
            out MonitoringFilterResult filterError)
        {
            filterError = null;
            ServiceResult error = null;

            // check for valid handle.
            MonitoredNode monitoredNode = monitoredItem.ManagerHandle as MonitoredNode;

            if (monitoredNode == null)
            {
                return ServiceResult.Good;
            }

            if (IsHandleInNamespace(monitoredNode.Node) == null)
            {
                return ServiceResult.Good;
            }

            // owned by this node manager.
            itemToModify.Processed = true;

            // check for valid monitored item.
            DataChangeMonitoredItem datachangeItem = monitoredItem as DataChangeMonitoredItem;

            // validate parameters.
            MonitoringParameters parameters = itemToModify.RequestedParameters;

            // validate the data change filter.
            DataChangeFilter filter = null;
            Range range = null;

            if (!ExtensionObject.IsNull(parameters.Filter))
            {
                error = ValidateDataChangeFilter(
                    context,
                    monitoredNode.Node,
                    datachangeItem.AttributeId,
                    parameters.Filter,
                    out filter,
                    out range);

                if (ServiceResult.IsBad(error))
                {
                    return error;
                }
            }

            double previousSamplingInterval = datachangeItem.SamplingInterval;
            
            // check if the variable needs to be sampled.
            double samplingInterval = itemToModify.RequestedParameters.SamplingInterval;

            if (datachangeItem.AttributeId == Attributes.Value)
            {
                BaseVariableState variable = monitoredNode.Node as BaseVariableState;

                if (variable.MinimumSamplingInterval > 0)
                {
                    samplingInterval = CalculateSamplingInterval(variable, samplingInterval);
                }
            }

            // modify the monitored item parameters.
            error = datachangeItem.Modify(
                diagnosticsMasks,
                timestampsToReturn,
                itemToModify.RequestedParameters.ClientHandle,
                samplingInterval,
                itemToModify.RequestedParameters.QueueSize,
                itemToModify.RequestedParameters.DiscardOldest,
                filter,
                range);

            // do any post processing.
            OnModifyMonitoredItem(
                context, 
                itemToModify, 
                monitoredNode, 
                datachangeItem,
                previousSamplingInterval);

            return ServiceResult.Good;
        }

        /// <summary>
        /// Does any processing after a monitored item is created.
        /// </summary>
        protected virtual void OnModifyMonitoredItem(
            ISystemContext systemContext,
            MonitoredItemModifyRequest itemToModify,
            MonitoredNode monitoredNode,
            DataChangeMonitoredItem monitoredItem,
            double previousSamplingInterval)
        {
            // does nothing.
        }

        /// <summary>
        /// Deletes a set of monitored items.
        /// </summary>
        public virtual void DeleteMonitoredItems(
            OperationContext     context, 
            IList<IMonitoredItem> monitoredItems, 
            IList<bool>          processedItems, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    // skip items that have already been processed.
                    if (processedItems[ii] || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // delete the monitored item.
                    bool processed = false;

                    errors[ii] = DeleteMonitoredItem(
                        systemContext,
                        monitoredItems[ii],
                        out processed);

                    // indicate whether it was processed or not.
                    processedItems[ii] = processed;
                }
            }
        }

        /// <summary>
        /// Deletes a monitored item.
        /// </summary>
        protected virtual ServiceResult DeleteMonitoredItem(
            ISystemContext context,
            IMonitoredItem monitoredItem,
            out bool processed)
        {
            processed = false;

            // check for valid handle.
            MonitoredNode monitoredNode = monitoredItem.ManagerHandle as MonitoredNode;

            if (monitoredNode == null)
            {
                return ServiceResult.Good;
            }

            if (IsHandleInNamespace(monitoredNode.Node) == null)
            {
                return ServiceResult.Good;
            }

            // owned by this node manager.
            processed = true;

            // get the  source.
            NodeState source = monitoredNode.Node;

            // check for valid monitored item.
            DataChangeMonitoredItem datachangeItem = monitoredItem as DataChangeMonitoredItem;
            
            // check if the variable needs to be sampled.
            if (datachangeItem.AttributeId == Attributes.Value)
            {
                BaseVariableState variable = monitoredNode.Node as BaseVariableState;

                if (variable.MinimumSamplingInterval > 0)
                {
                    DeleteSampledItem(datachangeItem);
                }
            }

            // remove item.
            monitoredNode.DeleteItem(datachangeItem);

            // do any post processing.
            OnDeleteMonitoredItem(context, monitoredNode, datachangeItem);

            return ServiceResult.Good;
        }

        /// <summary>
        /// Does any processing after a monitored item is deleted.
        /// </summary>
        protected virtual void OnDeleteMonitoredItem(
            ISystemContext systemContext,
            MonitoredNode monitoredNode,
            DataChangeMonitoredItem monitoredItem)
        {
            // does nothing.
        }

        /// <summary>
        /// Changes the monitoring mode for a set of monitored items.
        /// </summary>
        public virtual void SetMonitoringMode(
            OperationContext     context, 
            MonitoringMode       monitoringMode, 
            IList<IMonitoredItem> monitoredItems, 
            IList<bool>          processedItems, 
            IList<ServiceResult> errors)
        {
            ServerSystemContext systemContext = m_systemContext.Copy(context);

            lock (Lock)
            {
                for (int ii = 0; ii < monitoredItems.Count; ii++)
                {
                    // skip items that have already been processed.
                    if (processedItems[ii] || monitoredItems[ii] == null)
                    {
                        continue;
                    }

                    // update monitoring mode.
                    bool processed = false;

                    errors[ii] = SetMonitoringMode(
                        systemContext,
                        monitoredItems[ii],
                        monitoringMode,
                        out processed);

                    // indicate whether it was processed or not.
                    processedItems[ii] = processed;
                }
            }
        }

        /// <summary>
        /// Changes the monitoring mode for an item.
        /// </summary>
        protected virtual ServiceResult SetMonitoringMode(
            ISystemContext context,
            IMonitoredItem monitoredItem,
            MonitoringMode monitoringMode, 
            out bool processed)
        {
            processed = false;

            // check for valid handle.
            MonitoredNode monitoredNode = monitoredItem.ManagerHandle as MonitoredNode;

            if (monitoredNode == null)
            {
                return ServiceResult.Good;
            }

            if (IsHandleInNamespace(monitoredNode.Node) == null)
            {
                return ServiceResult.Good;
            }

            // owned by this node manager.
            processed = true;

            // check for valid monitored item.
            DataChangeMonitoredItem datachangeItem = monitoredItem as DataChangeMonitoredItem;

            // update monitoring mode.
            MonitoringMode previousMode = datachangeItem.SetMonitoringMode(monitoringMode);

            // need to provide an immediate update after enabling.
            if (previousMode == MonitoringMode.Disabled && monitoringMode != MonitoringMode.Disabled)
            {
                DataValue initialValue = new DataValue();

                initialValue.Value = null;
                initialValue.ServerTimestamp = DateTime.UtcNow;
                initialValue.SourceTimestamp = DateTime.MinValue;
                initialValue.StatusCode = StatusCodes.Good;

                ServiceResult error = monitoredNode.Node.ReadAttribute(
                    context,
                    datachangeItem.AttributeId,
                    datachangeItem.IndexRange,
                    datachangeItem.DataEncoding,
                    initialValue);

                datachangeItem.QueueValue(initialValue, error);
            }
            
            // do any post processing.
            OnSetMonitoringMode(context, monitoredNode, datachangeItem, previousMode, monitoringMode);

            return ServiceResult.Good;
        }

        /// <summary>
        /// Does any processing after a monitored item is created.
        /// </summary>
        protected virtual void OnSetMonitoringMode(
            ISystemContext systemContext,
            MonitoredNode monitoredNode,
            DataChangeMonitoredItem monitoredItem,
            MonitoringMode previousMode,
            MonitoringMode currentMode)
        {
            // does nothing.
        }
        #endregion

        #region Private Fields
        private object m_lock = new object();
        private IServerInternal m_server;
        private ServerSystemContext m_systemContext;
        private IList<string> m_namespaceUris;
        private ushort[] m_namespaceIndexes;
        private NodeIdDictionary<NodeState> m_predefinedNodes;
        private List<NodeState> m_rootNotifiers;
        
        private Timer m_samplingTimer;
        private List<DataChangeMonitoredItem> m_sampledItems;
        private double m_minimumSamplingInterval;
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(35,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(33,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(34,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(1999,21): error CS0103: The name 'monitoredNode' does not exist in the current context,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(2001,39): error CS0103: The name 'monitoredNode' does not exist in the current context,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(2004,17): error CS0103: The name 'monitoredNode' does not exist in the current context,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(2007,52): error CS0103: The name 'monitoredNode' does not exist in the current context,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(2070,17): error CS0103: The name 'monitoredNode' does not exist in the current context,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(2072,33): error CS0103: The name 'monitoredNode' does not exist in the current context,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(2075,13): error CS0103: The name 'monitoredNode' does not exist in the current context,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(2078,48): error CS0103: The name 'monitoredNode' does not exist in the current context,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(33,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(34,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\Diagnostics\v10\CustomNodeManager.cs(35,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 9 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\ResourceManager.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Resources;
using System.Globalization;
using System.Xml;
using System.Reflection;

namespace Opc.Ua.Server
{    
    /// <summary>
    /// An object that manages access to localized resources.
    /// </summary>
    public class ResourceManager : IDisposable, ITranslationManager
    {
        #region Constructors
        /// <summary>
        /// Initializes the resource manager with the server instance that owns it.
        /// </summary>
        public ResourceManager(IServerInternal server, ApplicationConfiguration configuration)
        {
            if (server == null) throw new ArgumentNullException(nameof(server));    
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
           
            m_server = server;
            m_translationTables = new List<TranslationTable>();
        }
        #endregion
        
        #region IDisposable Members
        /// <summary>
        /// May be called by the application to clean up resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// Cleans up all resources held by the object.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                // nothing to do at this time.
            }
        }
        #endregion

        #region ITranslationManager Members
        /// <summary cref="ITranslationManager.Translate(IList{string}, string, string, object[])" />
        public virtual LocalizedText Translate(IList<string> preferredLocales, string key, string text, params object[] args)
        {
            return Translate(preferredLocales, null, new TranslationInfo(key, String.Empty, text, args));
        }
        
        /// <virtual cref="ITranslationManager.Translate(IList{string}, LocalizedText)" />
        public LocalizedText Translate(IList<string> preferredLocales, LocalizedText text)
        {
            return Translate(preferredLocales, text, text.TranslationInfo);
        }

        /// <summary>
        /// Translates a service result.
        /// </summary>
        public ServiceResult Translate(IList<string> preferredLocales, ServiceResult result)
        {
            if (result == null)
            {
                return null;
            }

            // translate localized text.
            LocalizedText translatedText = result.LocalizedText;

            if (LocalizedText.IsNullOrEmpty(result.LocalizedText))
            {
                // extract any additional arguments from the translation info.
                object[] args = null;

                if (result.LocalizedText != null && result.LocalizedText.TranslationInfo != null)
                {
                    TranslationInfo info = result.LocalizedText.TranslationInfo;

                    if (info?.Args != null && info.Args.Length > 0)
                    {
                        args = info.Args;
                    }
                }

                if (!String.IsNullOrEmpty(result.SymbolicId))
                {
                    translatedText = TranslateSymbolicId(preferredLocales, result.SymbolicId, result.NamespaceUri, args);
                }
                else
                {
                    translatedText = TranslateStatusCode(preferredLocales, result.StatusCode, args);
                }
            }
            else
            {
                if (preferredLocales == null || preferredLocales.Count == 0)
                {
                    return result;
                }
            
                translatedText = Translate(preferredLocales, result.LocalizedText);
            }

            // construct new service result.
            ServiceResult translatedResult = new ServiceResult(
                result.StatusCode,
                result.SymbolicId,
                result.NamespaceUri,
                translatedText,
                result.AdditionalInfo,
                Translate(preferredLocales, result.InnerResult));

            return translatedResult;
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Returns the locales supported by the resource manager.
        /// </summary>
        public virtual string[] GetAvailableLocales()
        {
            lock (m_lock)
            {
                string[] availableLocales = new string[m_translationTables.Count];

                for (int ii = 0; ii < m_translationTables.Count; ii++)
                {
                    availableLocales[ii] = m_translationTables[ii].Locale.Name;
                }

                return availableLocales;
            }
        }
        
        /// <summary>
        /// Returns the locales supported by the resource manager.
        /// </summary>
        [Obsolete("preferredLocales argument is ignored.")]
        public string[] GetAvailableLocales(IEnumerable<string> preferredLocales)
        {
            return GetAvailableLocales();
        }

        /// <summary>
        /// Returns the localized form of the text that best matches the preferred locales.
        /// </summary>
        [Obsolete("Replaced by the overrideable ITranslationManager methods.")]
        public LocalizedText GetText(IList<string> preferredLocales, string textId, string defaultText, params object[] args)
        {
            return Translate(preferredLocales, textId, defaultText, args);
        }  

        /// <summary>
        /// Adds a translation to the resource manager.
        /// </summary>
        public void Add(string key, string locale, string text)
        {
            if (key == null) throw new ArgumentNullException(nameof(key));
            if (locale == null) throw new ArgumentNullException(nameof(locale));
            if (text == null) throw new ArgumentNullException(nameof(text));

            CultureInfo culture = new CultureInfo(locale);
            
            if (culture.IsNeutralCulture)
            {
                throw new ArgumentException("Cannot specify neutral locales for translation tables.", nameof(locale));
            }

            lock (m_lock)
            {
                TranslationTable table = GetTable(culture.Name);
                table.Translations[key] = text;
            }
        }

        /// <summary>
        /// Adds the translations to the resource manager.
        /// </summary>
        public void Add(string locale, IDictionary<string,string> translations)
        {
            if (locale == null) throw new ArgumentNullException(nameof(locale));
            if (translations == null) throw new ArgumentNullException(nameof(translations));

            CultureInfo culture = new CultureInfo(locale);
            
            if (culture.IsNeutralCulture)
            {
                throw new ArgumentException("Cannot specify neutral locales for translation tables.", nameof(locale));
            }

            lock (m_lock)
            {
                TranslationTable table = GetTable(culture.Name);

                foreach (KeyValuePair<string,string> translation in translations)
                {
                    table.Translations[translation.Key] = translation.Value;
                }
            }
        }

        /// <summary>
        /// Adds the translations to the resource manager.
        /// </summary>
        public void Add(uint statusCode, string locale, string text)
        {
            lock (m_lock)
            {
                string key = statusCode.ToString();

                Add(key, locale, text);

                if (m_statusCodeMapping == null)
                {
                    m_statusCodeMapping = new Dictionary<uint,TranslationInfo>();
                }
                
                if (String.IsNullOrEmpty(locale) || locale == "en-US")
                {
                    m_statusCodeMapping[statusCode] = new TranslationInfo(key, locale, text);
                }
            }
        }

        /// <summary>
        /// Adds the translations to the resource manager.
        /// </summary>
        public void Add(XmlQualifiedName symbolicId, string locale, string text)
        {
            lock (m_lock)
            {
                if (symbolicId != null)
                {
                    string key = symbolicId.ToString();

                    Add(key, locale, text);

                    if (m_symbolicIdMapping == null)
                    {
                        m_symbolicIdMapping = new Dictionary<XmlQualifiedName, TranslationInfo>();
                    }

                    if (String.IsNullOrEmpty(locale) || locale == "en-US")
                    {
                        m_symbolicIdMapping[symbolicId] = new TranslationInfo(key, locale, text);
                    }
                }
            }
        }

        /// <summary>
        /// Uses reflection to load default text for standard StatusCodes.
        /// </summary>
        public void LoadDefaultText()
        {
            System.Reflection.FieldInfo[] fields = typeof(StatusCodes).GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);

            foreach (System.Reflection.FieldInfo field in fields)
            {
                uint? id = field.GetValue(typeof(StatusCodes)) as uint?;

                if (id != null)
                {
                    this.Add(id.Value, "en-US", field.Name);
                }
            }
        }
        #endregion
        
        #region Protected Methods
        /// <summary>
        /// Returns the text for the specified locale (null if the locale is not supported).
        /// </summary>
        [Obsolete("Replaced by the overrideable methods on Translate(IList<string>, LocalizedText, TranslationInfo)")]
        protected virtual string GetTextForLocale(string locale, string textId, string defaultText, params object[] args)
        {
            return null;
        }

        /// <summary>
        /// Translates the text provided.
        /// </summary>
        protected virtual LocalizedText Translate(IList<string> preferredLocales, LocalizedText defaultText, TranslationInfo info)
        {
            // check for trivial case.
            if (info == null || String.IsNullOrEmpty(info.Text))
            {
                return defaultText;
            }

            // check for exact match.
            if (preferredLocales != null && preferredLocales.Count > 0)
            {
                if (defaultText != null && preferredLocales[0] == defaultText.Locale)
                {
                    return defaultText;
                }

                if (preferredLocales[0] == info.Locale)
                {
                    return new LocalizedText(info);
                }
            }

            // use the text as the key.
            string key = info.Key;

            if (key == null)
            {
                key = info.Text;
            }

            // find the best translation.
            string translatedText = info.Text;
            CultureInfo culture = CultureInfo.InvariantCulture;

            lock (m_lock)
            {
                translatedText = FindBestTranslation(preferredLocales, key, out culture);

                // use the default if no translation available.
                if (translatedText == null)
                {
                    return defaultText;
                }

                // get a culture to use for formatting
                if (culture == null)
                {
                    if (info.Args != null && info.Args.Length > 0 && !String.IsNullOrEmpty(info.Locale))
                    {
                        try
                        {
                            culture = new CultureInfo(info.Locale);
                        }
                        catch
                        {
                            culture = CultureInfo.InvariantCulture;
                        }
                    }
                }
            }

            // format translated text.
            string formattedText = translatedText;

            if (info.Args != null && info.Args.Length > 0)
            {            
                try
                {
                    formattedText = String.Format(culture, translatedText, info.Args);
                }
                catch
                {
                    formattedText = translatedText;
                }
            }

            // construct translated localized text.
            Opc.Ua.LocalizedText finalText = new LocalizedText(culture.Name, formattedText);
            finalText.TranslationInfo = info;
            return finalText;
        }
        #endregion
        
        #region Private Methods
        /// <summary>
        /// Stores the translations for a locale.
        /// </summary>
        private class TranslationTable
        {
            public CultureInfo Locale;
            public SortedDictionary<string,string> Translations = new SortedDictionary<string,string>();
        }

        /// <summary>
        /// Finds the translation table for the locale. Creates a new table if it does not exist.
        /// </summary>
        private TranslationTable GetTable(string locale)
        {
            lock (m_lock)
            {
                // search for table.
                for (int ii = 0; ii < m_translationTables.Count; ii++)
                {
                    TranslationTable translationTable = m_translationTables[ii];
                    
                    if (translationTable.Locale.Name == locale)
                    {
                        return translationTable;
                    }
                }

                // add table.
                TranslationTable table = new TranslationTable();
                table.Locale = new CultureInfo(locale);
                m_translationTables.Add(table);

                return table;
            }
        }

        /// <summary>
        /// Finds the best translation for the requested locales.
        /// </summary>
        private string FindBestTranslation(IList<string> preferredLocales, string key, out CultureInfo culture)
        {
            culture = null;
            TranslationTable match = null;
            
            for (int jj = 0; jj < preferredLocales.Count; jj++)
            {
                // parse the locale.
                string language = preferredLocales[jj];

                int index = language.IndexOf('-');

                if (index != -1)
                {
                    language = language.Substring(0, index);
                }

                // search for translation.
                string translatedText = null;

                for (int ii = 0; ii < m_translationTables.Count; ii++)
                {
                    TranslationTable translationTable = m_translationTables[ii];
                
                    // all done if exact match found.
                    if (translationTable.Locale.Name == preferredLocales[jj])
                    {
                        if (translationTable.Translations.TryGetValue(key, out translatedText))
                        {
                            culture = translationTable.Locale;
                            return translatedText;
                        }
                    }
                
                    // check for matching language but different region.
                    if (match == null && translationTable.Locale.TwoLetterISOLanguageName == language)
                    {
                        if (translationTable.Translations.TryGetValue(key, out translatedText))
                        {
                            culture = translationTable.Locale;
                            match = translationTable;
                        }

                        continue;
                    }
                }

                // take a partial match if one found.
                if (match != null)
                {
                    return translatedText;
                }
           }

           // no translations available.
           return null;
        }

        /// <summary>
        /// Translates a status code.
        /// </summary>
        private LocalizedText TranslateStatusCode(IList<string> preferredLocales, StatusCode statusCode, object[] args)
        {
            lock (m_lock)
            {
                if (m_statusCodeMapping != null)
                {
                    TranslationInfo info = null;

                    if (m_statusCodeMapping.TryGetValue(statusCode.Code, out info))
                    {
                        // merge the argument list with the trahslateion info cached for the status code.
                        if (args != null)
                        {
                            info = new TranslationInfo(
                                info.Key,
                                info.Locale,
                                info.Text,
                                args);
                        }

                        return Translate(preferredLocales, null, info);
                    }
                }
            }

            return String.Format("{0:X8}", statusCode.Code);
        }

        /// <summary>
        /// Translates a symbolic id.
        /// </summary>
        private LocalizedText TranslateSymbolicId(IList<string> preferredLocales, string symbolicId, string namespaceUri, object[] args)
        {
            lock (m_lock)
            {
                if (m_symbolicIdMapping != null)
                {
                    TranslationInfo info = null;

                    if (m_symbolicIdMapping.TryGetValue(new XmlQualifiedName(symbolicId, namespaceUri), out info))
                    {
                        // merge the argument list with the trahslateion info cached for the symbolic id.
                        if (args != null)
                        {
                            info = new TranslationInfo(
                                info.Key,
                                info.Locale,
                                info.Text,
                                args);
                        }

                        return Translate(preferredLocales, null, info);
                    }
                }
            }

            return symbolicId;
        }
        #endregion

        #region Private Fields
        private object m_lock = new object();
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        private IServerInternal m_server;
        private List<TranslationTable> m_translationTables;
        private Dictionary<uint,TranslationInfo> m_statusCodeMapping;
        private Dictionary<XmlQualifiedName,TranslationInfo> m_symbolicIdMapping;
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Resources;
using System.Globalization;
using System.Xml;
using System.Reflection;

namespace Opc.Ua.Server
{    
    /// <summary>
    /// An object that manages access to localized resources.
    /// </summary>
    public class ResourceManager : IDisposable, ITranslationManager
    {
        #region Constructors
        /// <summary>
        /// Initializes the resource manager with the server instance that owns it.
        /// </summary>
        public ResourceManager(IServerInternal server, ApplicationConfiguration configuration)
        {
            if (server == null) throw new ArgumentNullException(nameof(server));    
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
           
            m_server = server;
            m_translationTables = new List<TranslationTable>();
        }
        #endregion
        
        #region IDisposable Members
        /// <summary>
        /// May be called by the application to clean up resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// Cleans up all resources held by the object.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                // nothing to do at this time.
            }
        }
        #endregion

        #region ITranslationManager Members
        /// <summary cref="ITranslationManager.Translate(IList{string}, string, string, object[])" />
        public virtual LocalizedText Translate(IList<string> preferredLocales, string key, string text, params object[] args)
        {
            return Translate(preferredLocales, null, new TranslationInfo(key, String.Empty, text, args));
        }
        
        /// <virtual cref="ITranslationManager.Translate(IList{string}, LocalizedText)" />
        public LocalizedText Translate(IList<string> preferredLocales, LocalizedText text)
        {
            return Translate(preferredLocales, text, text.TranslationInfo);
        }

        /// <summary>
        /// Translates a service result.
        /// </summary>
        public ServiceResult Translate(IList<string> preferredLocales, ServiceResult result)
        {
            if (result == null)
            {
                return null;
            }

            // translate localized text.
            LocalizedText translatedText = result.LocalizedText;

            if (LocalizedText.IsNullOrEmpty(result.LocalizedText))
            {
                // extract any additional arguments from the translation info.
                object[] args = null;

                if (result.LocalizedText != null && result.LocalizedText.TranslationInfo != null)
                {
                    TranslationInfo info = result.LocalizedText.TranslationInfo;

                    if (info?.Args != null && info.Args.Length > 0)
                    {
                        args = info.Args;
                    }
                }

                if (!String.IsNullOrEmpty(result.SymbolicId))
                {
                    translatedText = TranslateSymbolicId(preferredLocales, result.SymbolicId, result.NamespaceUri, args);
                }
                else
                {
                    translatedText = TranslateStatusCode(preferredLocales, result.StatusCode, args);
                }
            }
            else
            {
                if (preferredLocales == null || preferredLocales.Count == 0)
                {
                    return result;
                }
            
                translatedText = Translate(preferredLocales, result.LocalizedText);
            }

            // construct new service result.
            ServiceResult translatedResult = new ServiceResult(
                result.StatusCode,
                result.SymbolicId,
                result.NamespaceUri,
                translatedText,
                result.AdditionalInfo,
                Translate(preferredLocales, result.InnerResult));

            return translatedResult;
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Returns the locales supported by the resource manager.
        /// </summary>
        public virtual string[] GetAvailableLocales()
        {
            lock (m_lock)
            {
                string[] availableLocales = new string[m_translationTables.Count];

                for (int ii = 0; ii < m_translationTables.Count; ii++)
                {
                    availableLocales[ii] = m_translationTables[ii].Locale.Name;
                }

                return availableLocales;
            }
        }
        
        /// <summary>
        /// Returns the locales supported by the resource manager.
        /// </summary>
        [Obsolete("preferredLocales argument is ignored.")]
        public string[] GetAvailableLocales(IEnumerable<string> preferredLocales)
        {
            return GetAvailableLocales();
        }

        /// <summary>
        /// Returns the localized form of the text that best matches the preferred locales.
        /// </summary>
        [Obsolete("Replaced by the overrideable ITranslationManager methods.")]
        public LocalizedText GetText(IList<string> preferredLocales, string textId, string defaultText, params object[] args)
        {
            return Translate(preferredLocales, textId, defaultText, args);
        }  

        /// <summary>
        /// Adds a translation to the resource manager.
        /// </summary>
        public void Add(string key, string locale, string text)
        {
            if (key == null) throw new ArgumentNullException(nameof(key));
            if (locale == null) throw new ArgumentNullException(nameof(locale));
            if (text == null) throw new ArgumentNullException(nameof(text));

            CultureInfo culture = new CultureInfo(locale);
            
            if (culture.IsNeutralCulture)
            {
                throw new ArgumentException("Cannot specify neutral locales for translation tables.", nameof(locale));
            }

            lock (m_lock)
            {
                TranslationTable table = GetTable(culture.Name);
                table.Translations[key] = text;
            }
        }

        /// <summary>
        /// Adds the translations to the resource manager.
        /// </summary>
        public void Add(string locale, IDictionary<string,string> translations)
        {
            if (locale == null) throw new ArgumentNullException(nameof(locale));
            if (translations == null) throw new ArgumentNullException(nameof(translations));

            CultureInfo culture = new CultureInfo(locale);
            
            if (culture.IsNeutralCulture)
            {
                throw new ArgumentException("Cannot specify neutral locales for translation tables.", nameof(locale));
            }

            lock (m_lock)
            {
                TranslationTable table = GetTable(culture.Name);

                foreach (KeyValuePair<string,string> translation in translations)
                {
                    table.Translations[translation.Key] = translation.Value;
                }
            }
        }

        /// <summary>
        /// Adds the translations to the resource manager.
        /// </summary>
        public void Add(uint statusCode, string locale, string text)
        {
            lock (m_lock)
            {
                string key = statusCode.ToString();

                Add(key, locale, text);

                if (m_statusCodeMapping == null)
                {
                    m_statusCodeMapping = new Dictionary<uint,TranslationInfo>();
                }
                
                if (String.IsNullOrEmpty(locale) || locale == "en-US")
                {
                    m_statusCodeMapping[statusCode] = new TranslationInfo(key, locale, text);
                }
            }
        }

        /// <summary>
        /// Adds the translations to the resource manager.
        /// </summary>
        public void Add(XmlQualifiedName symbolicId, string locale, string text)
        {
            lock (m_lock)
            {
                if (symbolicId != null)
                {
                    string key = symbolicId.ToString();

                    Add(key, locale, text);

                    if (m_symbolicIdMapping == null)
                    {
                        m_symbolicIdMapping = new Dictionary<XmlQualifiedName, TranslationInfo>();
                    }

                    if (String.IsNullOrEmpty(locale) || locale == "en-US")
                    {
                        m_symbolicIdMapping[symbolicId] = new TranslationInfo(key, locale, text);
                    }
                }
            }
        }

        /// <summary>
        /// Uses reflection to load default text for standard StatusCodes.
        /// </summary>
        public void LoadDefaultText()
        {
            System.Reflection.FieldInfo[] fields = typeof(StatusCodes).GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);

            foreach (System.Reflection.FieldInfo field in fields)
            {
                if (field.GetValue(typeof(StatusCodes)) is uint? id)
                {
                    this.Add(id.Value, "en-US", field.Name);
                }
            }
        }
        #endregion
        
        #region Protected Methods
        /// <summary>
        /// Returns the text for the specified locale (null if the locale is not supported).
        /// </summary>
        [Obsolete("Replaced by the overrideable methods on Translate(IList<string>, LocalizedText, TranslationInfo)")]
        protected virtual string GetTextForLocale(string locale, string textId, string defaultText, params object[] args)
        {
            return null;
        }

        /// <summary>
        /// Translates the text provided.
        /// </summary>
        protected virtual LocalizedText Translate(IList<string> preferredLocales, LocalizedText defaultText, TranslationInfo info)
        {
            // check for trivial case.
            if (info == null || String.IsNullOrEmpty(info.Text))
            {
                return defaultText;
            }

            // check for exact match.
            if (preferredLocales != null && preferredLocales.Count > 0)
            {
                if (defaultText != null && preferredLocales[0] == defaultText.Locale)
                {
                    return defaultText;
                }

                if (preferredLocales[0] == info.Locale)
                {
                    return new LocalizedText(info);
                }
            }

            // use the text as the key.
            string key = info.Key;

            if (key == null)
            {
                key = info.Text;
            }

            // find the best translation.
            string translatedText = info.Text;
            CultureInfo culture = CultureInfo.InvariantCulture;

            lock (m_lock)
            {
                translatedText = FindBestTranslation(preferredLocales, key, out culture);

                // use the default if no translation available.
                if (translatedText == null)
                {
                    return defaultText;
                }

                // get a culture to use for formatting
                if (culture == null)
                {
                    if (info.Args != null && info.Args.Length > 0 && !String.IsNullOrEmpty(info.Locale))
                    {
                        try
                        {
                            culture = new CultureInfo(info.Locale);
                        }
                        catch
                        {
                            culture = CultureInfo.InvariantCulture;
                        }
                    }
                }
            }

            // format translated text.
            string formattedText = translatedText;

            if (info.Args != null && info.Args.Length > 0)
            {            
                try
                {
                    formattedText = String.Format(culture, translatedText, info.Args);
                }
                catch
                {
                    formattedText = translatedText;
                }
            }

            // construct translated localized text.
            Opc.Ua.LocalizedText finalText = new LocalizedText(culture.Name, formattedText);
            finalText.TranslationInfo = info;
            return finalText;
        }
        #endregion
        
        #region Private Methods
        /// <summary>
        /// Stores the translations for a locale.
        /// </summary>
        private class TranslationTable
        {
            public CultureInfo Locale;
            public SortedDictionary<string,string> Translations = new SortedDictionary<string,string>();
        }

        /// <summary>
        /// Finds the translation table for the locale. Creates a new table if it does not exist.
        /// </summary>
        private TranslationTable GetTable(string locale)
        {
            lock (m_lock)
            {
                // search for table.
                for (int ii = 0; ii < m_translationTables.Count; ii++)
                {
                    TranslationTable translationTable = m_translationTables[ii];
                    
                    if (translationTable.Locale.Name == locale)
                    {
                        return translationTable;
                    }
                }

                // add table.
                TranslationTable table = new TranslationTable();
                table.Locale = new CultureInfo(locale);
                m_translationTables.Add(table);

                return table;
            }
        }

        /// <summary>
        /// Finds the best translation for the requested locales.
        /// </summary>
        private string FindBestTranslation(IList<string> preferredLocales, string key, out CultureInfo culture)
        {
            culture = null;
            TranslationTable match = null;
            
            for (int jj = 0; jj < preferredLocales.Count; jj++)
            {
                // parse the locale.
                string language = preferredLocales[jj];

                int index = language.IndexOf('-');

                if (index != -1)
                {
                    language = language.Substring(0, index);
                }

                // search for translation.
                string translatedText = null;

                for (int ii = 0; ii < m_translationTables.Count; ii++)
                {
                    TranslationTable translationTable = m_translationTables[ii];
                
                    // all done if exact match found.
                    if (translationTable.Locale.Name == preferredLocales[jj])
                    {
                        if (translationTable.Translations.TryGetValue(key, out translatedText))
                        {
                            culture = translationTable.Locale;
                            return translatedText;
                        }
                    }
                
                    // check for matching language but different region.
                    if (match == null && translationTable.Locale.TwoLetterISOLanguageName == language)
                    {
                        if (translationTable.Translations.TryGetValue(key, out translatedText))
                        {
                            culture = translationTable.Locale;
                            match = translationTable;
                        }

                        continue;
                    }
                }

                // take a partial match if one found.
                if (match != null)
                {
                    return translatedText;
                }
           }

           // no translations available.
           return null;
        }

        /// <summary>
        /// Translates a status code.
        /// </summary>
        private LocalizedText TranslateStatusCode(IList<string> preferredLocales, StatusCode statusCode, object[] args)
        {
            lock (m_lock)
            {
                if (m_statusCodeMapping != null)
                {
                    TranslationInfo info = null;

                    if (m_statusCodeMapping.TryGetValue(statusCode.Code, out info))
                    {
                        // merge the argument list with the trahslateion info cached for the status code.
                        if (args != null)
                        {
                            info = new TranslationInfo(
                                info.Key,
                                info.Locale,
                                info.Text,
                                args);
                        }

                        return Translate(preferredLocales, null, info);
                    }
                }
            }

            return String.Format("{0:X8}", statusCode.Code);
        }

        /// <summary>
        /// Translates a symbolic id.
        /// </summary>
        private LocalizedText TranslateSymbolicId(IList<string> preferredLocales, string symbolicId, string namespaceUri, object[] args)
        {
            lock (m_lock)
            {
                if (m_symbolicIdMapping != null)
                {
                    TranslationInfo info = null;

                    if (m_symbolicIdMapping.TryGetValue(new XmlQualifiedName(symbolicId, namespaceUri), out info))
                    {
                        // merge the argument list with the trahslateion info cached for the symbolic id.
                        if (args != null)
                        {
                            info = new TranslationInfo(
                                info.Key,
                                info.Locale,
                                info.Text,
                                args);
                        }

                        return Translate(preferredLocales, null, info);
                    }
                }
            }

            return symbolicId;
        }
        #endregion

        #region Private Fields
        private object m_lock = new object();
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1823:AvoidUnusedPrivateFields")]
        private IServerInternal m_server;
        private List<TranslationTable> m_translationTables;
        private Dictionary<uint,TranslationInfo> m_statusCodeMapping;
        private Dictionary<XmlQualifiedName,TranslationInfo> m_symbolicIdMapping;
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\ResourceManager.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\ResourceManager.cs(36,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\ResourceManager.cs(33,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\ResourceManager.cs(297,60): error CS8116: It is not legal to use nullable type 'uint?' in a pattern; use the underlying type 'uint' instead.,D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\ResourceManager.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\ResourceManager.cs(36,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Server\NodeManager\ResourceManager.cs(33,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 10 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Server\Subscription\MonitoredItem.cs
Description: Error: Unable to create valid SyntaxTree for document: MonitoredItem.cs. Caught exception: System.ArgumentException: An item with the same key has already been added. Key: if (value1 is XmlElement xmlElement1 && value2 is XmlElement xmlElement2)
                {
                    return xmlElement1.OuterXml.Equals(xmlElement2.OuterXml);
                }
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.AddLeadingLineFeedToIfStatements(IEnumerable`1 ifStatementChildren) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 289
   at EagleRepair.Ast.Rewriter.UsePatternMatchingRewriterR8.VisitMethodDeclaration(MethodDeclarationSyntax node) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Rewriter/UsePatternMatchingRewriterR8.cs:line 201
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitClassDeclaration(ClassDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitListElement[TNode](TNode node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitList[TNode](SyntaxList`1 list)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitCompilationUnit(CompilationUnitSyntax node)
   at Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.Visit(SyntaxNode node)
   at EagleRepair.Ast.Engine.VisitNodes(Solution solution, ICollection`1 documents, IList`1 visitors) in /Users/martinodermatt/repos/thesis/EagleRepair/EagleRepair/src/EagleRepair.Ast/Engine.cs:line 107, Message: An item with the same key has already been added. Key: if (value1 is XmlElement xmlElement1 && value2 is XmlElement xmlElement2)
                {
                    return xmlElement1.OuterXml.Equals(xmlElement2.OuterXml);
                }
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Xml;
using static Opc.Ua.Utils;

namespace Opc.Ua.Server
{
    /// <summary>
    /// A handle that describes how to access a node/attribute via an i/o manager.
    /// </summary>
    public class MonitoredItem : IEventMonitoredItem, ISampledDataChangeMonitoredItem, ITriggeredMonitoredItem
    {
        #region Constructors
        /// <summary>
        /// Initializes the object with its node type.
        /// </summary>
        public MonitoredItem(
            IServerInternal server,
            INodeManager nodeManager,
            object mangerHandle,
            uint subscriptionId,
            uint id,
            Session session,
            ReadValueId itemToMonitor,
            DiagnosticsMasks diagnosticsMasks,
            TimestampsToReturn timestampsToReturn,
            MonitoringMode monitoringMode,
            uint clientHandle,
            MonitoringFilter originalFilter,
            MonitoringFilter filterToUse,
            Range range,
            double samplingInterval,
            uint queueSize,
            bool discardOldest,
            double sourceSamplingInterval)
        {
            if (itemToMonitor == null) throw new ArgumentNullException(nameof(itemToMonitor));

            Initialize();

            m_server = server;
            m_nodeManager = nodeManager;
            m_managerHandle = mangerHandle;
            m_subscriptionId = subscriptionId;
            m_id = id;
            m_session = session;
            m_nodeId = itemToMonitor.NodeId;
            m_attributeId = itemToMonitor.AttributeId;
            m_indexRange = itemToMonitor.IndexRange;
            m_parsedIndexRange = itemToMonitor.ParsedIndexRange;
            m_encoding = itemToMonitor.DataEncoding;
            m_diagnosticsMasks = diagnosticsMasks;
            m_timestampsToReturn = timestampsToReturn;
            m_monitoringMode = monitoringMode;
            m_clientHandle = clientHandle;
            m_originalFilter = originalFilter;
            m_filterToUse = filterToUse;
            m_range = 0;
            m_samplingInterval = samplingInterval;
            m_queueSize = queueSize;
            m_discardOldest = discardOldest;
            m_sourceSamplingInterval = (int)sourceSamplingInterval;
            m_calculator = null;
            m_nextSamplingTime = HiResClock.TickCount64;
            m_alwaysReportUpdates = false;

            m_typeMask = MonitoredItemTypeMask.DataChange;

            if (originalFilter is EventFilter)
            {
                m_typeMask = MonitoredItemTypeMask.Events;

                if (itemToMonitor.NodeId == Objects.Server)
                {
                    m_typeMask |= MonitoredItemTypeMask.AllEvents;
                }
            }

            // create aggregate calculator.
            ServerAggregateFilter aggregateFilter = filterToUse as ServerAggregateFilter;

            if (filterToUse is ServerAggregateFilter)
            {
                m_calculator = m_server.AggregateManager.CreateCalculator(
                    aggregateFilter.AggregateType,
                    aggregateFilter.StartTime,
                    DateTime.MaxValue,
                    aggregateFilter.ProcessingInterval,
                    aggregateFilter.Stepped,
                    aggregateFilter.AggregateConfiguration);
            }

            if (range != null)
            {
                m_range = range.High - range.Low;
            }

            // report change to item state.
            ServerUtils.ReportCreateMonitoredItem(
                m_nodeId,
                m_id,
                m_samplingInterval,
                m_queueSize,
                m_discardOldest,
                m_filterToUse,
                m_monitoringMode);

            InitializeQueue();
        }

        /// <summary>
        /// Sets private members to default values.
        /// </summary>
        private void Initialize()
        {
            m_server = null;
            m_nodeManager = null;
            m_managerHandle = null;
            m_subscriptionId = 0;
            m_id = 0;
            m_session = null;
            m_nodeId = null;
            m_attributeId = 0;
            m_indexRange = null;
            m_parsedIndexRange = NumericRange.Empty;
            m_encoding = null;
            m_clientHandle = 0;
            m_monitoringMode = MonitoringMode.Disabled;
            m_samplingInterval = 0;
            m_queueSize = 0;
            m_discardOldest = true;
            m_originalFilter = null;
            m_lastValue = null;
            m_lastError = null;
            m_events = null;
            m_overflow = false;
            m_readyToPublish = false;
            m_readyToTrigger = false;
            m_sourceSamplingInterval = 0;
            m_samplingError = ServiceResult.Good;
        }
        #endregion

        #region IMonitoredItem Members
        /// <summary>
        /// The node manager that created the item.
        /// </summary>
        public INodeManager NodeManager => m_nodeManager;

        /// <summary>
        /// The handle assigned by the node manager when it created the item.
        /// </summary>
        public object ManagerHandle => m_managerHandle;

        /// <summary>
        /// The identifier for the subscription that owns the monitored item.
        /// </summary>
        public uint SubscriptionId => m_subscriptionId;

        /// <summary>
        /// A bit mask that indicates what the monitored item is.
        /// </summary>
        /// <remarks>
        /// Predefined bits are defined by the MonitoredItemTypeMasks class.
        /// NodeManagers may use the remaining bits.
        /// </remarks>
        public int MonitoredItemType => m_typeMask;

        /// <summary>
        /// Returns true if the item is ready to publish.
        /// </summary>
        public bool IsReadyToPublish
        {
            get
            {
                // check if aggregate interval has passed.
                if (m_calculator != null)
                {
                    if (m_calculator.HasEndTimePassed(DateTime.UtcNow))
                    {
                        return true;
                    }
                }

                // check if not ready to publish.
                if (!m_readyToPublish)
                {
                    Utils.Trace((int)TraceMasks.OperationDetail, "IsReadyToPublish[{0}] FALSE", m_id);
                    return false;
                }

                // check if it has been triggered.
                if (m_monitoringMode != MonitoringMode.Disabled && m_triggered)
                {
                    Utils.Trace((int)TraceMasks.OperationDetail, "IsReadyToPublish[{0}] TRIGGERED", m_id);
                    return true;
                }

                // check if monitoring was turned off.
                if (m_monitoringMode != MonitoringMode.Reporting)
                {
                    Utils.Trace((int)TraceMasks.OperationDetail, "IsReadyToPublish[{0}] FALSE", m_id);
                    return false;
                }

                if (m_sourceSamplingInterval == 0)
                {
                    // re-queue if too little time has passed since the last publish.
                    long now = HiResClock.TickCount64;

                    if (m_nextSamplingTime > now)
                    {
                        Utils.Trace((int)TraceMasks.OperationDetail, "IsReadyToPublish[{0}] FALSE {1}", m_id, new TimeSpan(m_nextSamplingTime - now).TotalSeconds);
                        return false;
                    }
                }

                Utils.Trace((int)TraceMasks.OperationDetail, "IsReadyToPublish[{0}] NORMAL", m_id);
                return true;
            }
        }

        /// <summary>
        /// Gets or Sets a value indicating whether the item is ready to trigger in case it has some linked items.
        /// </summary>
        public bool IsReadyToTrigger
        {
            get
            {
                lock (m_lock)
                {
                    // only allow to trigger if sampling or reporting.
                    if (m_monitoringMode == MonitoringMode.Disabled)
                    {
                        return false;
                    }

                    return m_readyToTrigger;
                }
            }

            set
            {
                lock (m_lock)
                {
                    m_readyToTrigger = value;
                }
            }
        }

        /// <summary>
        /// Sets a flag indicating that the item has been triggered and should publish.
        /// </summary>
        public bool SetTriggered()
        {
            lock (m_lock)
            {
                if (m_readyToPublish)
                {
                    Utils.Trace("SetTriggered[{0}]", m_id);
                    m_triggered = true;
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Sets a flag indicating that the semantics for the monitored node have changed.
        /// </summary>
        /// <remarks>
        /// The StatusCode for next value reported by the monitored item will have the SemanticsChanged bit set.
        /// </remarks>
        public void SetSemanticsChanged()
        {
            m_semanticsChanged = true;
        }

        /// <summary>
        /// Sets a flag indicating that the structure of the monitored node has changed.
        /// </summary>
        /// <remarks>
        /// The StatusCode for next value reported by the monitored item will have the StructureChanged bit set.
        /// </remarks>
        public void SetStructureChanged()
        {
            m_structureChanged = true;
        }

        /// <summary>
        /// The filter used by the monitored item.
        /// </summary>
        public MonitoringFilter Filter => m_originalFilter;

        /// <summary>
        /// The event filter used by the monitored item.
        /// </summary>
        public EventFilter EventFilter => m_originalFilter as EventFilter;

        /// <summary>
        /// The data change filter used by the monitored item.
        /// </summary>
        public DataChangeFilter DataChangeFilter => m_originalFilter as DataChangeFilter;

        /// <summary>
        /// The session that owns the monitored item.
        /// </summary>
        public Session Session
        {
            get
            {
                lock (m_lock)
                {
                    return m_session;
                }
            }
        }

        /// <summary>
        /// The identifier for the item that is unique within the server.
        /// </summary>
        public uint Id => m_id;

        /// <summary>
        /// The identifier for the client handle assigned to the monitored item.
        /// </summary>
        public uint ClientHandle => m_clientHandle;

        /// <summary>
        /// The node id being monitored.
        /// </summary>
        public NodeId NodeId => m_nodeId;

        /// <summary>
        /// The attribute being monitored.
        /// </summary>
        public uint AttributeId => m_attributeId;

        /// <summary>
        /// The current monitoring mode for the item
        /// </summary>
        public MonitoringMode MonitoringMode => m_monitoringMode;

        /// <summary>
        /// The sampling interval for the item.
        /// </summary>
        public double SamplingInterval
        {
            get
            {
                lock (m_lock)
                {
                    return m_samplingInterval;
                }
            }
        }

        /// <summary>
        /// The minimum sampling interval for the item.
        /// </summary>
        public double MinimumSamplingInterval => m_sourceSamplingInterval;

        /// <summary>
        /// The queue size for the item.
        /// </summary>
        public uint QueueSize => m_queueSize;

        /// <summary>
        /// Gets number of elements actually contained in value queue.
        /// </summary>
        public int ItemsInQueue
        {
            get
            {
                lock (m_lock)
                {
                    if (m_events != null)
                    {
                        return m_events.Count;
                    }

                    if (m_queue != null)
                    {
                        return m_queue.ItemsInQueue;
                    }

                    return 0;
                }
            }
        }

        /// <summary>
        /// The diagnostics masks to use when collecting notifications for the item.
        /// </summary>
        public DiagnosticsMasks DiagnosticsMasks => m_diagnosticsMasks;

        /// <summary>
        /// The index range requested by the monitored item.
        /// </summary>
        public NumericRange IndexRange => m_parsedIndexRange;

        /// <summary>
        /// The data encoding requested by the monitored item.
        /// </summary>
        public QualifiedName DataEncoding => m_encoding;

        /// <summary>
        /// Whether the monitored item should report a value without checking if it was changed.
        /// </summary>
        public bool AlwaysReportUpdates
        {
            get { return m_alwaysReportUpdates; }
            set { m_alwaysReportUpdates = value; }
        }

        /// <summary>
        /// Returns a description of the item being monitored. 
        /// </summary>
        public ReadValueId GetReadValueId()
        {
            lock (m_lock)
            {
                ReadValueId valueId = new ReadValueId();

                valueId.NodeId = m_nodeId;
                valueId.AttributeId = m_attributeId;
                valueId.IndexRange = m_indexRange;
                valueId.ParsedIndexRange = m_parsedIndexRange;
                valueId.DataEncoding = m_encoding;
                valueId.Handle = m_managerHandle;

                return valueId;
            }
        }

        /// <summary>
        /// Sets an error that occured in the sampling group.
        /// </summary>
        /// <remarks>
        /// The sampling group or node manager that owns the item may call this to indicate that
        /// a fatal error occurred which means the item will no longer receive any data updates.
        /// This error state can be cleared by calling this method and passing in ServiceResult.Good.
        /// </remarks>
        public void SetSamplingError(ServiceResult error)
        {
            lock (m_lock)
            {
                if (error == null)
                {
                    m_samplingError = ServiceResult.Good;
                }

                m_samplingError = error;
            }
        }

        /// <summary>
        /// Returns the result after creating the monitor item.
        /// </summary>
        public ServiceResult GetCreateResult(out MonitoredItemCreateResult result)
        {
            lock (m_lock)
            {
                result = new MonitoredItemCreateResult();

                result.MonitoredItemId = m_id;
                result.RevisedSamplingInterval = m_samplingInterval;
                result.RevisedQueueSize = m_queueSize;
                result.StatusCode = StatusCodes.Good;

                if (ServiceResult.IsBad(m_samplingError))
                {
                    result.StatusCode = m_samplingError.Code;
                }

                return m_samplingError;
            }
        }

        /// <summary>
        /// Returns the result after modifying the monitor item.
        /// </summary>
        public ServiceResult GetModifyResult(out MonitoredItemModifyResult result)
        {
            lock (m_lock)
            {
                result = new MonitoredItemModifyResult();

                result.RevisedSamplingInterval = m_samplingInterval;
                result.RevisedQueueSize = m_queueSize;
                result.StatusCode = StatusCodes.Good;

                if (ServiceResult.IsBad(m_samplingError))
                {
                    result.StatusCode = m_samplingError.Code;
                }

                return m_samplingError;
            }
        }

        /// <summary>
        /// Modifies the attributes for monitored item.
        /// </summary>
        public ServiceResult ModifyAttributes(
            DiagnosticsMasks diagnosticsMasks,
            TimestampsToReturn timestampsToReturn,
            uint clientHandle,
            MonitoringFilter originalFilter,
            MonitoringFilter filterToUse,
            Range range,
            double samplingInterval,
            uint queueSize,
            bool discardOldest)
        {
            lock (m_lock)
            {
                m_diagnosticsMasks = diagnosticsMasks;
                m_timestampsToReturn = timestampsToReturn;
                m_clientHandle = clientHandle;
                m_discardOldest = discardOldest;

                m_originalFilter = originalFilter;
                m_filterToUse = filterToUse;

                if (range != null)
                {
                    m_range = range.High - range.Low;
                }

                SetSamplingInterval(samplingInterval);
                m_queueSize = queueSize;

                // check if aggregate filter has been updated.
                ServerAggregateFilter aggregateFilter = filterToUse as ServerAggregateFilter;

                if (filterToUse is ServerAggregateFilter)
                {
                    ServerAggregateFilter existingFilter = filterToUse as ServerAggregateFilter;

                    bool match = existingFilter != null;

                    if (match) if (existingFilter.AggregateType != aggregateFilter.AggregateType) match = false;
                    if (match) if (existingFilter.ProcessingInterval != aggregateFilter.ProcessingInterval) match = false;
                    if (match) if (existingFilter.StartTime != aggregateFilter.StartTime) match = false;
                    if (match) if (!existingFilter.AggregateConfiguration.IsEqual(aggregateFilter.AggregateConfiguration)) match = false;

                    if (!match)
                    {
                        m_calculator = m_server.AggregateManager.CreateCalculator(
                            aggregateFilter.AggregateType,
                            aggregateFilter.StartTime,
                            DateTime.MaxValue,
                            aggregateFilter.ProcessingInterval,
                            aggregateFilter.Stepped,
                            aggregateFilter.AggregateConfiguration);
                    }
                }

                // report change to item state.
                ServerUtils.ReportModifyMonitoredItem(
                    m_nodeId,
                    m_id,
                    m_samplingInterval,
                    m_queueSize,
                    m_discardOldest,
                    m_filterToUse,
                    m_monitoringMode);

                InitializeQueue();

                return null;
            }
        }

        /// <summary>
        /// Updates the sampling interval for an item.
        /// </summary>
        public void SetSamplingInterval(double samplingInterval)
        {
            lock (m_lock)
            {
                if (samplingInterval == -1)
                {
                    return;
                }

                // subtract the previous sampling interval.
                long oldSamplingInterval = (long)m_samplingInterval;

                if (oldSamplingInterval < m_nextSamplingTime)
                {
                    m_nextSamplingTime -= oldSamplingInterval;
                }

                m_samplingInterval = samplingInterval;

                // calculate the next sampling interval.                
                long newSamplingInterval = (long)m_samplingInterval;

                if (m_samplingInterval > 0)
                {
                    m_nextSamplingTime += newSamplingInterval;
                }
                else
                {
                    m_nextSamplingTime = 0;
                }
            }
        }

        /// <summary>
        /// Changes the monitoring mode for the item.
        /// </summary>
        void ISampledDataChangeMonitoredItem.SetMonitoringMode(MonitoringMode monitoringMode)
        {
            SetMonitoringMode(monitoringMode);
        }

        /// <summary>
        /// Changes the monitoring mode for the item.
        /// </summary>
        void IEventMonitoredItem.SetMonitoringMode(MonitoringMode monitoringMode)
        {
            SetMonitoringMode(monitoringMode);
        }

        /// <summary>
        /// Changes the monitoring mode for the item.
        /// </summary>
        public MonitoringMode SetMonitoringMode(MonitoringMode monitoringMode)
        {
            lock (m_lock)
            {
                MonitoringMode previousMode = m_monitoringMode;

                if (previousMode == monitoringMode)
                {
                    return previousMode;
                }

                Utils.Trace("MONITORING MODE[{0}] {1} -> {2}", m_id, m_monitoringMode, monitoringMode);

                if (previousMode == MonitoringMode.Disabled)
                {
                    m_nextSamplingTime = HiResClock.TickCount64;
                    m_lastError = null;
                    m_lastValue = null;
                }

                m_monitoringMode = monitoringMode;

                if (monitoringMode == MonitoringMode.Disabled)
                {
                    m_readyToPublish = false;
                    m_readyToTrigger = false;
                    m_triggered = false;
                }

                // report change to item state.
                ServerUtils.ReportModifyMonitoredItem(
                    m_nodeId,
                    m_id,
                    m_samplingInterval,
                    m_queueSize,
                    m_discardOldest,
                    m_filterToUse,
                    m_monitoringMode);

                InitializeQueue();

                return previousMode;
            }
        }

        /// <summary>
        /// Adds an event to the queue.
        /// </summary>
        public virtual void QueueValue(DataValue value, ServiceResult error)
        {
            QueueValue(value, error, false);
        }

        /// <summary>
        /// Updates the queue with a data value or an error.
        /// </summary>
        public virtual void QueueValue(DataValue value, ServiceResult error, bool bypassFilter)
        {
            lock (m_lock)
            {
                // this method should only be called for variables. 
                if ((m_typeMask & MonitoredItemTypeMask.DataChange) == 0)
                {
                    throw new ServiceResultException(StatusCodes.BadInternalError);
                }

                // check monitoring mode.
                if (m_monitoringMode == MonitoringMode.Disabled)
                {
                    return;
                }

                // make a shallow copy of the value.
                if (value != null)
                {
                    Utils.Trace("RECEIVED VALUE[{0}] Value={1}", this.m_id, value.WrappedValue);

                    DataValue copy = new DataValue();

                    copy.WrappedValue = value.WrappedValue;
                    copy.StatusCode = value.StatusCode;
                    copy.SourceTimestamp = value.SourceTimestamp;
                    copy.SourcePicoseconds = value.SourcePicoseconds;
                    copy.ServerTimestamp = value.ServerTimestamp;
                    copy.ServerPicoseconds = value.ServerPicoseconds;

                    value = copy;

                    // ensure the data value matches the error status code.
                    if (error != null && error.StatusCode.Code != 0)
                    {
                        value.StatusCode = error.StatusCode;
                    }
                }

                // create empty value if none provided.
                if (ServiceResult.IsBad(error))
                {
                    if (value == null)
                    {
                        value = new DataValue();
                        value.StatusCode = error.StatusCode;
                        value.SourceTimestamp = DateTime.UtcNow;
                        value.ServerTimestamp = DateTime.UtcNow;
                    }
                }

                // this should never happen.
                if (value == null)
                {
                    return;
                }

                // apply aggregate filter.
                if (m_calculator != null)
                {
                    if (!m_calculator.QueueRawValue(value))
                    {
                        Utils.Trace("Value received out of order: {1}, ServerHandle={0}", m_id, value.SourceTimestamp.ToLocalTime().ToString("HH:mm:ss.fff"));
                    }

                    DataValue processedValue = m_calculator.GetProcessedValue(false);

                    while (processedValue != null)
                    {
                        AddValueToQueue(processedValue, null);
                        processedValue = m_calculator.GetProcessedValue(false);
                    }

                    return;
                }

                // apply filter to incoming item.
                if (!m_alwaysReportUpdates && !bypassFilter)
                {
                    if (!ApplyFilter(value, error))
                    {
                        ServerUtils.ReportFilteredValue(m_nodeId, m_id, value);
                        return;
                    }
                }

                ServerUtils.ReportQueuedValue(m_nodeId, m_id, value);

                // add the value to the queue.
                AddValueToQueue(value, error);
            }
        }

        /// <summary>
        /// Sets the overflow bit.
        /// </summary>
        private ServiceResult SetOverflowBit(
            object value,
            ServiceResult error)
        {
            DataValue dataValue = value as DataValue;

            if (dataValue != null)
            {
                dataValue.StatusCode = dataValue.StatusCode.SetOverflow(true);
            }

            if (error != null)
            {
                error = new ServiceResult(
                    error.StatusCode.SetOverflow(true),
                    error.SymbolicId,
                    error.NamespaceUri,
                    error.LocalizedText,
                    error.AdditionalInfo,
                    error.InnerResult);
            }

            return error;
        }

        /// <summary>
        /// Adds a value to the queue.
        /// </summary>
        private void AddValueToQueue(DataValue value, ServiceResult error)
        {
            if (m_queueSize > 1)
            {
                m_queue.QueueValue(value, error);
            }

            if (m_lastValue != null)
            {
                m_readyToTrigger = true;
            }

            // save last value received.
            m_lastValue = value;
            m_lastError = error;
            m_readyToPublish = true;

            Utils.Trace("QUEUE VALUE[{0}]: Value={1} CODE={2}<{2:X8}> OVERFLOW={3}", m_id, m_lastValue.WrappedValue, m_lastValue.StatusCode.Code, m_lastValue.StatusCode.Overflow);
        }

        /// <summary>
        /// Whether the item is monitoring all events produced by the server.
        /// </summary>
        public bool MonitoringAllEvents => this.m_nodeId == ObjectIds.Server;

        /// <summary>
        /// Fetches the event fields from the event.
        /// </summary>
        private EventFieldList GetEventFields(FilterContext context, EventFilter filter, IFilterTarget instance)
        {
            // fetch the event fields.
            EventFieldList fields = new EventFieldList();

            fields.ClientHandle = m_clientHandle;
            fields.Handle = instance;

            foreach (SimpleAttributeOperand clause in filter.SelectClauses)
            {
                // get the value of the attribute (apply localization).
                object value = instance.GetAttributeValue(
                    context,
                    clause.TypeDefinitionId,
                    clause.BrowsePath,
                    clause.AttributeId,
                    clause.ParsedIndexRange);

                // add the value to the list of event fields.
                if (value != null)
                {
                    // translate any localized text.
                    LocalizedText text = value as LocalizedText;

                    if (text != null)
                    {
                        value = m_server.ResourceManager.Translate(m_session.PreferredLocales, text);
                    }

                    // add value.
                    fields.EventFields.Add(new Variant(value));
                }

                // add a dummy entry for missing values.
                else
                {
                    fields.EventFields.Add(Variant.Null);
                }
            }

            return fields;
        }

        /// <summary>
        /// Adds an event to the queue.
        /// </summary>
        public virtual void QueueEvent(IFilterTarget instance)
        {
            QueueEvent(instance, false);
        }

        /// <summary>
        /// Adds an event to the queue.
        /// </summary>
        public virtual void QueueEvent(IFilterTarget instance, bool bypassFilter)
        {
            if (instance == null) throw new ArgumentNullException(nameof(instance));

            lock (m_lock)
            {
                // this method should only be called for objects or views. 
                if ((m_typeMask & MonitoredItemTypeMask.Events) == 0)
                {
                    throw new ServiceResultException(StatusCodes.BadInternalError);
                }

                // can't do anything if queuing is disabled.
                if (m_events == null)
                {
                    return;
                }

                // check for duplicate instances being reported via multiple paths.
                for (int ii = 0; ii < m_events.Count; ii++)
                {
                    EventFieldList processedEvent = m_events[ii] as EventFieldList;

                    if (processedEvent != null)
                    {
                        if (Object.ReferenceEquals(instance, processedEvent.Handle))
                        {
                            return;
                        }
                    }
                }

                // check for space in the queue.
                if (m_events.Count >= m_queueSize)
                {
                    if (!m_discardOldest)
                    {
                        m_overflow = true;
                        return;
                    }
                }

                // construct the context to use for the event filter.
                FilterContext context = new FilterContext(m_server.NamespaceUris, m_server.TypeTree, m_session.PreferredLocales);

                // event filter must be specified.
                EventFilter filter = m_filterToUse as EventFilter;

                if (filter == null)
                {
                    throw new ServiceResultException(StatusCodes.BadInternalError);
                }

                // apply filter.
                if (!bypassFilter)
                {
                    if (!filter.WhereClause.Evaluate(context, instance))
                    {
                        return;
                    }
                }

                // fetch the event fields.
                EventFieldList fields = GetEventFields(context, filter, instance);
                QueueEvent(fields);
            }
        }

        /// <summary>
        /// Adds an event to the queue.
        /// </summary>
        public virtual void QueueEvent(EventFieldList fields)
        {
            lock (m_lock)
            {
                // make space in the queue.
                if (m_events.Count >= m_queueSize)
                {
                    m_overflow = true;

                    if (m_discardOldest)
                    {
                        m_events.RemoveAt(0);
                    }
                }

                // queue the event.
                m_events.Add(fields);
                m_readyToPublish = true;
                m_readyToTrigger = true;
            }
        }

        /// <summary>
        /// Whether the item has notifications that are ready to publish.
        /// </summary>
        [Obsolete("Not used - Use IsReadyToPublish")]
        public virtual bool ReadyToPublish
        {
            get
            {
                lock (m_lock)
                {
                    // only publish if reporting.
                    if (m_monitoringMode != MonitoringMode.Reporting)
                    {
                        return false;
                    }

                    return m_readyToPublish;
                }
            }
        }

        /// <summary>
        /// Used to check whether the item is ready to sample.
        /// </summary>
        public bool SamplingIntervalExpired()
        {
            lock (m_lock)
            {
                return TimeToNextSample <= 0;
            }
        }

        /// <summary>
        /// Increments the sample time to the next interval.
        /// </summary>
        private void IncrementSampleTime()
        {
            // update next sample time.
            long now = HiResClock.TickCount64;
            long samplingInterval = (long)m_samplingInterval;

            if (m_nextSamplingTime > 0)
            {
                long delta = now - m_nextSamplingTime;

                if (samplingInterval > 0 && delta >= 0)
                {
                    m_nextSamplingTime += ((delta / samplingInterval) + 1) * samplingInterval;
                }
            }

            // set sampling time based on current time.
            else
            {
                m_nextSamplingTime = now + samplingInterval;
            }
        }

        /// <summary>
        /// Publishes all available event notifications.
        /// </summary>
        public virtual bool Publish(OperationContext context, Queue<EventFieldList> notifications)
        {
            if (context == null) throw new ArgumentNullException(nameof(context));
            if (notifications == null) throw new ArgumentNullException(nameof(notifications));

            lock (m_lock)
            {
                // check if the item reports events.
                if ((m_typeMask & MonitoredItemTypeMask.Events) == 0)
                {
                    return false;
                }

                // only publish if reporting.
                if (!IsReadyToPublish)
                {
                    return false;
                }

                // go to the next sampling interval.
                IncrementSampleTime();

                // publish events.
                if (m_events != null)
                {
                    Utils.Trace("MONITORED ITEM: Publish(QueueSize={0})", notifications.Count);

                    EventFieldList overflowEvent = null;

                    if (m_overflow)
                    {
                        // construct event.
                        EventQueueOverflowEventState e = new EventQueueOverflowEventState(null);

                        TranslationInfo message = new TranslationInfo(
                            "EventQueueOverflowEventState",
                            "en-US",
                            "Events lost due to queue overflow.");

                        ISystemContext systemContext = new ServerSystemContext(m_server, context);

                        e.Initialize(
                            systemContext,
                            null,
                            EventSeverity.Low,
                            new LocalizedText(message));

                        e.SetChildValue(systemContext, BrowseNames.SourceNode, ObjectIds.Server, false);
                        e.SetChildValue(systemContext, BrowseNames.SourceName, "Internal", false);

                        // fetch the event fields.
                        overflowEvent = GetEventFields(
                            new FilterContext(m_server.NamespaceUris, m_server.TypeTree, m_session.PreferredLocales),
                            m_filterToUse as EventFilter,
                            e);
                    }

                    // place event at the beginning of the queue.
                    if (overflowEvent != null && m_discardOldest)
                    {
                        notifications.Enqueue(overflowEvent);
                    }

                    for (int ii = 0; ii < m_events.Count; ii++)
                    {
                        EventFieldList fields = (EventFieldList)m_events[ii];

                        // apply any diagnostic masks.
                        for (int jj = 0; jj < fields.EventFields.Count; jj++)
                        {
                            object value = fields.EventFields[jj].Value;

                            StatusResult result = value as StatusResult;

                            result?.ApplyDiagnosticMasks(context.DiagnosticsMask, context.StringTable);
                        }

                        notifications.Enqueue((EventFieldList)m_events[ii]);
                    }

                    m_events.Clear();

                    // place event at the end of the queue.
                    if (overflowEvent != null && !m_discardOldest)
                    {
                        notifications.Enqueue(overflowEvent);
                    }

                    Utils.Trace("MONITORED ITEM: Publish(QueueSize={0})", notifications.Count);
                }

                // reset state variables.
                m_overflow = false;
                m_readyToPublish = false;
                m_readyToTrigger = false;
                m_triggered = false;

                return false;
            }
        }

        /// <summary>
        /// Publishes all available data change notifications.
        /// </summary>
        public virtual bool Publish(
            OperationContext context,
            Queue<MonitoredItemNotification> notifications,
            Queue<DiagnosticInfo> diagnostics)
        {
            if (context == null) throw new ArgumentNullException(nameof(context));
            if (notifications == null) throw new ArgumentNullException(nameof(notifications));
            if (diagnostics == null) throw new ArgumentNullException(nameof(diagnostics));

            lock (m_lock)
            {
                // check if the item reports data changes.
                if ((m_typeMask & MonitoredItemTypeMask.DataChange) == 0)
                {
                    return false;
                }

                // only publish if reporting.
                if (!IsReadyToPublish)
                {
                    return false;
                }

                // pull any unprocessed data.
                if (m_calculator != null)
                {
                    if (m_calculator.HasEndTimePassed(DateTime.UtcNow))
                    {
                        DataValue processedValue = m_calculator.GetProcessedValue(false);

                        while (processedValue != null)
                        {
                            AddValueToQueue(processedValue, null);
                        }

                        processedValue = m_calculator.GetProcessedValue(true);
                        AddValueToQueue(processedValue, null);
                    }
                }

                // go to the next sampling interval.
                IncrementSampleTime();

                // check if queueing enabled.
                if (m_queue != null)
                {
                    DataValue value = null;
                    ServiceResult error = null;

                    while (m_queue.Publish(out value, out error))
                    {
                        Publish(context, notifications, diagnostics, value, error);
                    }
                }

                // publish last value if no queuing.
                else
                {
                    Utils.Trace("DEQUEUE VALUE: Value={0} CODE={1}<{1:X8}> OVERFLOW={2}", m_lastValue.WrappedValue, m_lastValue.StatusCode.Code, m_lastValue.StatusCode.Overflow);
                    Publish(context, notifications, diagnostics, m_lastValue, m_lastError);
                }

                // reset state variables.
                m_overflow = false;
                m_readyToPublish = false;
                m_readyToTrigger = false;
                m_triggered = false;

                return false;
            }
        }

        /// <summary>
        /// Publishes a single data change notifications.
        /// </summary>
        protected virtual bool Publish(
            OperationContext context,
            Queue<MonitoredItemNotification> notifications,
            Queue<DiagnosticInfo> diagnostics,
            DataValue value,
            ServiceResult error)
        {
            // set semantics changed bit.
            if (m_semanticsChanged)
            {
                if (value != null)
                {
                    value.StatusCode = value.StatusCode.SetSemanticsChanged(true);
                }

                if (error != null)
                {
                    error = new ServiceResult(
                        error.StatusCode.SetSemanticsChanged(true),
                        error.SymbolicId,
                        error.NamespaceUri,
                        error.LocalizedText,
                        error.AdditionalInfo,
                        error.InnerResult);
                }

                m_semanticsChanged = false;
            }

            // set structure changed bit.
            if (m_structureChanged)
            {
                if (value != null)
                {
                    value.StatusCode = value.StatusCode.SetStructureChanged(true);
                }

                if (error != null)
                {
                    error = new ServiceResult(
                        error.StatusCode.SetStructureChanged(true),
                        error.SymbolicId,
                        error.NamespaceUri,
                        error.LocalizedText,
                        error.AdditionalInfo,
                        error.InnerResult);
                }

                m_structureChanged = false;
            }

            // copy data value.
            MonitoredItemNotification item = new MonitoredItemNotification();

            item.ClientHandle = m_clientHandle;
            item.Value = value;

            // apply timestamp filter.
            if (m_timestampsToReturn != TimestampsToReturn.Server && m_timestampsToReturn != TimestampsToReturn.Both)
            {
                item.Value.ServerTimestamp = DateTime.MinValue;
            }

            if (m_timestampsToReturn != TimestampsToReturn.Source && m_timestampsToReturn != TimestampsToReturn.Both)
            {
                item.Value.SourceTimestamp = DateTime.MinValue;
            }

            ServerUtils.ReportPublishValue(m_nodeId, m_id, item.Value);
            notifications.Enqueue(item);

            // update diagnostic info.
            DiagnosticInfo diagnosticInfo = null;

            if ((m_diagnosticsMasks & DiagnosticsMasks.OperationAll) != 0)
            {
                diagnosticInfo = ServerUtils.CreateDiagnosticInfo(m_server, context, error);
            }

            diagnostics.Enqueue(diagnosticInfo);

            return false;
        }

        /// <summary>
        /// The object to call when item is ready to publish.
        /// </summary>
        public ISubscription SubscriptionCallback
        {
            get
            {
                lock (m_lock)
                {
                    return m_subscription;
                }
            }

            set
            {
                lock (m_lock)
                {
                    m_subscription = value;
                }
            }
        }

        /// <summary>
        /// The number of milliseconds until the next sample.
        /// </summary>
        public int TimeToNextSample
        {
            get
            {
                lock (m_lock)
                {
                    if (m_monitoringMode == MonitoringMode.Disabled)
                    {
                        return Int32.MaxValue;
                    }

                    // node manager responsible for ensuring correct sampling.
                    if (m_sourceSamplingInterval > 0)
                    {
                        return 0;
                    }

                    var now = HiResClock.TickCount64;

                    if (m_nextSamplingTime <= now)
                    {
                        return 0;
                    }

                    return (int)(m_nextSamplingTime - now);
                }
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Applies the filter to value to determine if the new value should be kept.
        /// </summary>
        protected virtual bool ApplyFilter(DataValue value, ServiceResult error)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            bool changed = ValueChanged(
                value,
                error,
                m_lastValue,
                m_lastError,
                m_filterToUse as DataChangeFilter,
                m_range);

            return changed;
        }

        /// <summary>
        /// Applies the filter to value to determine if the new value should be kept.
        /// </summary>
        public static bool ValueChanged(
            DataValue value,
            ServiceResult error,
            DataValue lastValue,
            ServiceResult lastError,
            DataChangeFilter filter,
            double range)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            // select default data change filters.
            double deadband = 0.0;
            DeadbandType deadbandType = DeadbandType.None;
            DataChangeTrigger trigger = DataChangeTrigger.StatusValue;

            // apply filter.
            if (filter != null)
            {
                trigger = filter.Trigger;
                deadbandType = (DeadbandType)(int)filter.DeadbandType;
                deadband = filter.DeadbandValue;

                // when deadband is used and the trigger is StatusValueTimestamp, then it should behave as if trigger is StatusValue.
                if ((deadbandType != DeadbandType.None) && (trigger == DataChangeTrigger.StatusValueTimestamp))
                {
                    trigger = DataChangeTrigger.StatusValue;
                }
            }

            // get the current status.
            uint status = StatusCodes.Good;

            if (error != null)
            {
                status = error.StatusCode.Code;
            }
            else if (lastValue != null)
            {
                status = value.StatusCode.Code;
            }

            // get the last status.
            uint lastStatus = StatusCodes.Good;

            if (lastError != null)
            {
                lastStatus = lastError.StatusCode.Code;
            }
            else if (lastValue != null)
            {
                lastStatus = lastValue.StatusCode.Code;
            }

            // value changed if any status change occurrs.
            if (status != lastStatus)
            {
                return true;
            }

            // value changed if only one is null.
            if (value == null || lastValue == null)
            {
                return lastValue != null || value != null;
            }

            // check if timestamp has changed.
            if (trigger == DataChangeTrigger.StatusValueTimestamp)
            {
                if (lastValue.SourceTimestamp != value.SourceTimestamp)
                {
                    return true;
                }
            }

            // check if value changes are ignored.
            if (trigger == DataChangeTrigger.Status)
            {
                return false;
            }

            // check if reference to same object.
            if (!Equals(lastValue.Value, value.Value, deadbandType, deadband, range))
            {
                return true;
            }

            // must be equal.
            return false;
        }

        /// <summary>
        /// Checks if the two values are equal.
        /// </summary>
        protected static bool Equals(object value1, object value2, DeadbandType deadbandType, double deadband, double range)
        {
            // check if reference to same object.
            if (Object.ReferenceEquals(value1, value2))
            {
                return true;
            }

            // check for invalid values.
            if (value1 == null || value2 == null)
            {
                return value1 == value2;
            }

            // check for type change.
            if (value1.GetType() != value2.GetType())
            {
                return false;
            }

            // special case NaN is always not equal
            if (value1.Equals(float.NaN) ||
                value1.Equals(double.NaN) ||
                value2.Equals(float.NaN) ||
                value2.Equals(double.NaN))
            {
                return false;
            }

            // check if values are equal.
            if (value1.Equals(value2))
            {
                return true;
            }

            // check for arrays.
            Array array1 = value1 as Array;
            Array array2 = value2 as Array;

            if (array1 == null || array2 == null)
            {

                XmlElement xmlElement1 = value1 as XmlElement;
                XmlElement xmlElement2 = value2 as XmlElement;

                if (xmlElement1 != null && xmlElement2 != null)
                {
                    return xmlElement1.OuterXml.Equals(xmlElement2.OuterXml);
                }

                // nothing more to do if no deadband.
                if (deadbandType == DeadbandType.None)
                {
                    return false;
                }

                // check deadband.
                return !ExceedsDeadband(value1, value2, deadbandType, deadband, range);
            }

            // compare lengths.
            if (array1.Length != array2.Length)
            {
                return false;
            }

            // compare each element.
            bool isVariant = array1.GetType().GetElementType() == typeof(Variant);

            for (int ii = 0; ii < array1.Length; ii++)
            {
                object element1 = array1.GetValue(ii);
                object element2 = array2.GetValue(ii);

                if (isVariant)
                {
                    element1 = ((Variant)element1).Value;
                    element2 = ((Variant)element2).Value;
                }

                if (!Equals(element1, element2, deadbandType, deadband, range))
                {
                    return false;
                }
            }

            // must be equal.
            return true;
        }

        /// <summary>
        /// Returns true if the deadband was exceeded.
        /// </summary>
        protected static bool ExceedsDeadband(object value1, object value2, DeadbandType deadbandType, double deadband, double range)
        {
            // cannot convert doubles safely to decimals.
            if (value1 is double d)
            {
                return ExceedsDeadband(d, (double)value2, deadbandType, deadband, range);
            }

            try
            {
                decimal decimal1 = Convert.ToDecimal(value1, CultureInfo.InvariantCulture);
                decimal decimal2 = Convert.ToDecimal(value2, CultureInfo.InvariantCulture);
                decimal baseline = 1;

                if (deadbandType == DeadbandType.Percent)
                {
                    baseline = ((decimal)range) / 100;
                }

                if (baseline > 0)
                {
                    if (Math.Abs((decimal1 - decimal2) / baseline) <= (decimal)deadband)
                    {
                        return false;
                    }
                }
            }
            catch
            {
                // treat all conversion errors as evidence that the deadband was exceeded.
            }

            return true;
        }

        /// <summary>
        /// Returns true if the deadband was exceeded.
        /// </summary>
        private static bool ExceedsDeadband(double value1, double value2, DeadbandType deadbandType, double deadband, double range)
        {
            double baseline = 1;

            if (deadbandType == DeadbandType.Percent)
            {
                baseline = range / 100;
            }

            if (baseline > 0)
            {
                if (Math.Abs((value1 - value2) / baseline) <= deadband)
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Clears and re-initializes the queue if the monitoring parameters changed.
        /// </summary>
        protected void InitializeQueue()
        {
            switch (m_monitoringMode)
            {
                default:
                case MonitoringMode.Disabled:
                {
                    m_queue = null;
                    m_events = null;
                    break;
                }

                case MonitoringMode.Reporting:
                case MonitoringMode.Sampling:
                {
                    // check if queuing is disabled.
                    if (m_queueSize == 0)
                    {
                        if (m_typeMask == MonitoredItemTypeMask.DataChange)
                        {
                            m_queueSize = 1;
                        }

                        if ((m_typeMask & MonitoredItemTypeMask.Events) != 0)
                        {
                            m_queueSize = 1000;
                        }
                    }

                    // create data queue.
                    if (m_typeMask == MonitoredItemTypeMask.DataChange)
                    {
                        if (m_queueSize <= 1)
                        {
                            m_queue = null;
                            break; // queueing is disabled
                        }

                        bool queueLastValue = false;

                        if (m_queue == null)
                        {
                            m_queue = new MonitoredItemQueue(m_id, QueueOverflowHandler);
                            queueLastValue = true;
                        }

                        m_queue.SetQueueSize(m_queueSize, m_discardOldest, m_diagnosticsMasks);
                        m_queue.SetSamplingInterval(m_samplingInterval);

                        if (queueLastValue && m_lastValue != null)
                        {
                            m_queue.QueueValue(m_lastValue, m_lastError);
                        }
                    }
                    else // create event queue.
                    {
                        if (m_events == null)
                        {
                            m_events = new List<EventFieldList>();
                        }

                        // check if existing queue entries must be discarded;
                        if (m_events.Count > m_queueSize)
                        {
                            int queueSize = (int)m_queueSize;

                            if (m_discardOldest)
                            {
                                m_events.RemoveRange(0, m_events.Count - queueSize);
                            }
                            else
                            {
                                m_events.RemoveRange(queueSize, m_events.Count - queueSize);
                            }
                        }
                    }

                    break;
                }
            }
        }

        /// <summary>
        /// Update the overflow count.
        /// </summary>
        private void QueueOverflowHandler()
        {
            m_subscription?.QueueOverflowHandler();
        }
        #endregion

        #region Private Members
        private object m_lock = new object();
        private IServerInternal m_server;
        private INodeManager m_nodeManager;
        private object m_managerHandle;
        private uint m_subscriptionId;
        private uint m_id;
        private int m_typeMask;
        private Session m_session;
        private NodeId m_nodeId;
        private uint m_attributeId;
        private string m_indexRange;
        private NumericRange m_parsedIndexRange;
        private QualifiedName m_encoding;
        private DiagnosticsMasks m_diagnosticsMasks;
        private TimestampsToReturn m_timestampsToReturn;
        private uint m_clientHandle;
        private MonitoringMode m_monitoringMode;
        private MonitoringFilter m_originalFilter;
        private MonitoringFilter m_filterToUse;
        private double m_range;
        private double m_samplingInterval;
        private uint m_queueSize;
        private bool m_discardOldest;
        private int m_sourceSamplingInterval;
        private bool m_alwaysReportUpdates;

        private DataValue m_lastValue;
        private ServiceResult m_lastError;
        private long m_nextSamplingTime;
        private List<EventFieldList> m_events;
        private MonitoredItemQueue m_queue;
        private bool m_overflow;
        private bool m_readyToPublish;
        private bool m_readyToTrigger;
        private bool m_semanticsChanged;
        private bool m_structureChanged;
        private ISubscription m_subscription;
        private ServiceResult m_samplingError;
        private IAggregateCalculator m_calculator;
        private bool m_triggered;
        #endregion
    }
}

---- Transformed Tree ----
-
---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----

######################################################################


######################################################################
Nr: 11 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Configuration\ApplicationConfiguration.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
	/// Loads the configuration section for an application.
	/// </summary>
	public class ApplicationConfigurationSection
    {
        #region IConfigurationSectionHandler Members	
        /// <summary>
        /// Creates the configuration object from the configuration section.
        /// </summary>
        /// <param name="parent">The parent object.</param>
        /// <param name="configContext">The configuration context object.</param>
        /// <param name="section">The section as XML node.</param>
        /// <returns>The created section handler object.</returns>
        public object Create(object parent, object configContext, System.Xml.XmlNode section)
        {
            if (section == null)
            {
                throw new ArgumentNullException(nameof(section));
            }

            XmlNode element = section.FirstChild;

            while (element != null && typeof(XmlElement) != element.GetType())
            {
                element = element.NextSibling;
            }

            XmlReader reader = XmlReader.Create(new StringReader(element.OuterXml));

            try
            {
                DataContractSerializer serializer = new DataContractSerializer(typeof(ConfigurationLocation));
                ConfigurationLocation configuration = serializer.ReadObject(reader) as ConfigurationLocation;
                return configuration;
            }
            finally
            {
                reader.Dispose();
            }
        }
        #endregion
    }
    /// <summary>
    /// Represents the location of a configuration file.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaConfig)]
    public class ConfigurationLocation
    {
        #region Persistent Properties
        /// <summary>
        /// Gets or sets the relative or absolute path to the configuration file.
        /// </summary>
        /// <value>The file path.</value>
        [DataMember(IsRequired = true, Order = 0)]
        public string FilePath
        {
            get { return m_filePath; }
            set { m_filePath = value; }
        }
        #endregion

        #region Private Fields
        private string m_filePath;
        #endregion
    }

    /// <summary>
    /// Stores the configurable configuration information for a UA application.
    /// </summary>
    public partial class ApplicationConfiguration
    {
        #region Public Methods
        /// <summary>
        /// Gets the file that was used to load the configuration.
        /// </summary>
        /// <value>The source file path.</value>
        public string SourceFilePath => m_sourceFilePath;

        /// <summary>
        /// Gets or sets the certificate validator which is configured to use.
        /// </summary>
        public CertificateValidator CertificateValidator
        {
            get { return m_certificateValidator; }
            set { m_certificateValidator = value; }
        }

        /// <summary>
        /// Returns the domain names which the server is configured to use.
        /// </summary>
        /// <returns>A list of domain names.</returns>
        public IList<string> GetServerDomainNames()
        {
            StringCollection baseAddresses = new StringCollection();

            if (this.ServerConfiguration != null)
            {
                if (this.ServerConfiguration.BaseAddresses != null)
                {
                    baseAddresses.AddRange(this.ServerConfiguration.BaseAddresses);
                }

                if (this.ServerConfiguration.AlternateBaseAddresses != null)
                {
                    baseAddresses.AddRange(this.ServerConfiguration.AlternateBaseAddresses);
                }
            }

            if (this.DiscoveryServerConfiguration != null)
            {
                if (this.DiscoveryServerConfiguration.BaseAddresses != null)
                {
                    baseAddresses.AddRange(this.DiscoveryServerConfiguration.BaseAddresses);
                }

                if (this.DiscoveryServerConfiguration.AlternateBaseAddresses != null)
                {
                    baseAddresses.AddRange(this.DiscoveryServerConfiguration.AlternateBaseAddresses);
                }
            }

            var domainNames = new List<string>();
            for (int ii = 0; ii < baseAddresses.Count; ii++)
            {
                Uri url = Utils.ParseUri(baseAddresses[ii]);

                if (url == null)
                {
                    continue;
                }

                string domainName = url.DnsSafeHost;

                if (url.HostNameType == UriHostNameType.Dns)
                {
                    domainName = Utils.ReplaceLocalhost(domainName);
                }
                else // IPv4/IPv6 address
                {
                    domainName = Utils.NormalizedIPAddress(domainName);
                }

                if (!Utils.FindStringIgnoreCase(domainNames, domainName))
                {
                    domainNames.Add(domainName);
                }
            }

            return domainNames;
        }

        /// <summary>
        /// Creates the message context from the configuration.
        /// </summary>
        /// <returns>A new instance of a ServiceMessageContext object.</returns>
        public ServiceMessageContext CreateMessageContext(bool clonedFactory = false)
        {
            ServiceMessageContext messageContext = new ServiceMessageContext();

            if (m_transportQuotas != null)
            {
                messageContext.MaxArrayLength = m_transportQuotas.MaxArrayLength;
                messageContext.MaxByteStringLength = m_transportQuotas.MaxByteStringLength;
                messageContext.MaxStringLength = m_transportQuotas.MaxStringLength;
                messageContext.MaxMessageSize = m_transportQuotas.MaxMessageSize;
            }

            messageContext.NamespaceUris = new NamespaceTable();
            messageContext.ServerUris = new StringTable();
            if (clonedFactory)
            {
                messageContext.Factory = new EncodeableFactory(EncodeableFactory.GlobalFactory);
            }
            return messageContext;
        }

        /// <summary>
        /// Creates the message context from the configuration.
        /// </summary>
        /// <value>A new instance of a ServiceMessageContext object.</value>
        [Obsolete("Warning: Behavior changed return a copy instead of a reference. Should call CreateMessageContext() instead.")]
        public ServiceMessageContext MessageContext
        {
            get
            {
                if (m_messageContext == null)
                {
                    m_messageContext = CreateMessageContext();
                }

                return m_messageContext;
            }
        }

        /// <summary>
        /// Loads and validates the application configuration from a configuration section.
        /// </summary>
        /// <param name="sectionName">Name of configuration section for the current application's default configuration containing <see cref="ConfigurationLocation"/>.</param>
        /// <param name="applicationType">Type of the application.</param>
        /// <returns>Application configuration</returns>
        public static Task<ApplicationConfiguration> Load(string sectionName, ApplicationType applicationType) =>
            Load(sectionName, applicationType, typeof(ApplicationConfiguration));

        /// <summary>
        /// Loads and validates the application configuration from a configuration section.
        /// </summary>
        /// <param name="sectionName">Name of configuration section for the current application's default configuration containing <see cref="ConfigurationLocation"/>.</param>
        /// <param name="applicationType">A description for the ApplicationType DataType.</param>
        /// <param name="systemType">A user type of the configuration instance.</param>
        /// <returns>Application configuration</returns>
        public static Task<ApplicationConfiguration> Load(string sectionName, ApplicationType applicationType, Type systemType)
        {
            string filePath = GetFilePathFromAppConfig(sectionName);

            FileInfo file = new FileInfo(filePath);

            if (!file.Exists)
            {
                var message = new StringBuilder();
                message.AppendFormat("Configuration file does not exist: {0}", filePath);
                message.AppendLine();
                message.AppendFormat("Current directory is: {1}", Directory.GetCurrentDirectory());
                throw ServiceResultException.Create(
                    StatusCodes.BadConfigurationError, message.ToString());
            }

            return Load(file, applicationType, systemType);
        }

        /// <summary>
        /// Loads but does not validate the application configuration from a configuration section.
        /// </summary>
        /// <param name="file">The file.</param>
        /// <param name="systemType">Type of the system.</param>
        /// <returns>Application configuration</returns>
        /// <remarks>Use this method to ensure the configuration is not changed during loading.</remarks>
        public static ApplicationConfiguration LoadWithNoValidation(FileInfo file, Type systemType)
        {
            using (var stream = new FileStream(file.FullName, FileMode.Open, FileAccess.Read))
            {
                try
                {
                    DataContractSerializer serializer = new DataContractSerializer(systemType);

                    ApplicationConfiguration configuration = serializer.ReadObject(stream) as ApplicationConfiguration;

                    if (configuration != null)
                    {
                        configuration.m_sourceFilePath = file.FullName;
                    }

                    return configuration;
                }
                catch (Exception e)
                {
                    var message = new StringBuilder();
                    message.AppendFormat("Configuration file could not be loaded: {0}", file.FullName);
                    message.AppendLine();
                    message.AppendFormat("Error is: {1}", e.Message);
                    throw ServiceResultException.Create(
                        StatusCodes.BadConfigurationError, e, message.ToString());
                }
            }
        }

        /// <summary>
        /// Loads and validates the application configuration from a configuration section.
        /// </summary>
        /// <param name="file">The file.</param>
        /// <param name="applicationType">Type of the application.</param>
        /// <param name="systemType">Type of the system.</param>
        /// <returns>Application configuration</returns>
        public static Task<ApplicationConfiguration> Load(FileInfo file, ApplicationType applicationType, Type systemType) =>
            ApplicationConfiguration.Load(file, applicationType, systemType, true);

        /// <summary>
        /// Loads and validates the application configuration from a configuration section.
        /// </summary>
        /// <param name="file">The file.</param>
        /// <param name="applicationType">Type of the application.</param>
        /// <param name="systemType">Type of the system.</param>
        /// <param name="applyTraceSettings">if set to <c>true</c> apply trace settings after validation.</param>
        /// <param name="certificatePasswordProvider">The certificate password provider.</param>
        /// <returns>Application configuration</returns>
        public static async Task<ApplicationConfiguration> Load(
            FileInfo file,
            ApplicationType applicationType,
            Type systemType,
            bool applyTraceSettings,
            ICertificatePasswordProvider certificatePasswordProvider = null)
        {
            ApplicationConfiguration configuration = null;
            systemType = systemType ?? typeof(ApplicationConfiguration);

            using (FileStream stream = new FileStream(file.FullName, FileMode.Open, FileAccess.Read))
            {
                try
                {
                    DataContractSerializer serializer = new DataContractSerializer(systemType);
                    configuration = (ApplicationConfiguration)serializer.ReadObject(stream);
                }
                catch (Exception e)
                {
                    var message = new StringBuilder();
                    message.AppendFormat("Configuration file could not be loaded: {0}", file.FullName);
                    message.AppendLine();
                    message.AppendFormat("Error is: {0}", e.Message);
                    throw ServiceResultException.Create(
                        StatusCodes.BadConfigurationError, e, message.ToString());
                }
            }

            if (configuration != null)
            {
                // should not be here but need to preserve old behavior.
                if (applyTraceSettings && configuration.TraceConfiguration != null)
                {
                    configuration.TraceConfiguration.ApplySettings();
                }

                configuration.SecurityConfiguration.CertificatePasswordProvider = certificatePasswordProvider;

                await configuration.Validate(applicationType);

                configuration.m_sourceFilePath = file.FullName;
            }

            return configuration;
        }

        /// <summary>
        /// Reads the file path from the application configuration file.
        /// </summary>
	    /// <param name="sectionName">Name of configuration section for the current application's default configuration containing <see cref="ConfigurationLocation"/>.
	    /// </param>
        /// <returns>File path from the application configuration file.</returns>
        public static string GetFilePathFromAppConfig(string sectionName)
        {
            // convert to absolute file path (expands environment strings).
            string absolutePath = Utils.GetAbsoluteFilePath(sectionName + ".Config.xml", true, false, false);
            return (absolutePath != null) ? absolutePath : sectionName + ".Config.xml";
        }

        /// <summary>
        /// Saves the configuration file.
        /// </summary>
        /// <param name="filePath">The file path.</param>
        /// <remarks>Calls GetType() on the current instance and passes that to the DataContractSerializer.</remarks>
        public void SaveToFile(string filePath)
        {
            XmlWriterSettings settings = new XmlWriterSettings() {
                Encoding = Encoding.UTF8,
                Indent = true,
                CloseOutput = true
            };

            using (Stream ostrm = File.Open(filePath, FileMode.Create, FileAccess.ReadWrite))
            using (XmlWriter writer = XmlDictionaryWriter.Create(ostrm, settings))
            {
                DataContractSerializer serializer = new DataContractSerializer(GetType());
                serializer.WriteObject(writer, this);
            }
        }

        /// <summary>
        /// Ensures that the application configuration is valid.
        /// </summary>
        /// <param name="applicationType">Type of the application.</param>
        public virtual async Task Validate(ApplicationType applicationType)
        {
            if (String.IsNullOrEmpty(ApplicationName))
            {
                throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "ApplicationName must be specified.");
            }

            if (SecurityConfiguration == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "SecurityConfiguration must be specified.");
            }

            SecurityConfiguration.Validate();

            // load private key
            await SecurityConfiguration.ApplicationCertificate.LoadPrivateKeyEx(SecurityConfiguration.CertificatePasswordProvider);

            Func<string> generateDefaultUri = () => {
                var sb = new StringBuilder();
                sb.Append("urn:");
                sb.Append(Utils.GetHostName());
                sb.Append(":");
                sb.Append(ApplicationName);
                return sb.ToString();
            };

            if (String.IsNullOrEmpty(ApplicationUri)) m_applicationUri = generateDefaultUri();

            if (applicationType == ApplicationType.Client || applicationType == ApplicationType.ClientAndServer)
            {
                if (ClientConfiguration == null)
                {
                    throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "ClientConfiguration must be specified.");
                }

                ClientConfiguration.Validate();
            }

            if (applicationType == ApplicationType.Server || applicationType == ApplicationType.ClientAndServer)
            {
                if (ServerConfiguration == null)
                {
                    throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "ServerConfiguration must be specified.");
                }

                ServerConfiguration.Validate();
            }

            if (applicationType == ApplicationType.DiscoveryServer)
            {
                if (DiscoveryServerConfiguration == null)
                {
                    throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "DiscoveryServerConfiguration must be specified.");
                }

                DiscoveryServerConfiguration.Validate();
            }

            // toggle the state of the hi-res clock.
            HiResClock.Disabled = m_disableHiResClock;

            if (m_disableHiResClock)
            {
                if (m_serverConfiguration != null)
                {
                    if (m_serverConfiguration.PublishingResolution < 50)
                    {
                        m_serverConfiguration.PublishingResolution = 50;
                    }
                }
            }

            await m_certificateValidator.Update(this.SecurityConfiguration);
        }

        /// <summary>
        /// Loads the endpoints cached on disk.
        /// </summary>
        /// <param name="createAlways">if set to <c>true</c> ConfiguredEndpointCollection is always returned,
        ///	even if loading from disk fails</param>
        /// <returns>Colection of configured endpoints from the disk.</returns>
        public ConfiguredEndpointCollection LoadCachedEndpoints(bool createAlways) => LoadCachedEndpoints(createAlways, false);

        /// <summary>
        /// Loads the endpoints cached on disk.
        /// </summary>
        /// <param name="createAlways">if set to <c>true</c> ConfiguredEndpointCollection is always returned,
        /// even if loading from disk fails</param>
        /// <param name="overrideConfiguration">if set to <c>true</c> overrides the configuration.</param>
        /// <returns>
        /// Colection of configured endpoints from the disk.
        /// </returns>
        public ConfiguredEndpointCollection LoadCachedEndpoints(bool createAlways, bool overrideConfiguration)
        {
            if (m_clientConfiguration == null) throw new InvalidOperationException("Only valid for client configurations.");

            string filePath = Utils.GetAbsoluteFilePath(m_clientConfiguration.EndpointCacheFilePath, true, false, false, false);

            if (filePath == null)
            {
                filePath = m_clientConfiguration.EndpointCacheFilePath;

                if (!Utils.IsPathRooted(filePath))
                {
                    FileInfo sourceFile = new FileInfo(this.SourceFilePath);
                    filePath = Utils.Format("{0}{1}{2}", sourceFile.DirectoryName, Path.DirectorySeparatorChar, filePath);
                }
            }

            if (!createAlways)
            {
                return ConfiguredEndpointCollection.Load(this, filePath, overrideConfiguration);
            }

            ConfiguredEndpointCollection endpoints = new ConfiguredEndpointCollection(this);
            try
            {
                endpoints = ConfiguredEndpointCollection.Load(this, filePath, overrideConfiguration);
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Could not load configuration from file: {0}", filePath);
            }
            finally
            {
                string localFilePath = Utils.GetAbsoluteFilePath(m_clientConfiguration.EndpointCacheFilePath, true, false, true, true);
                if (localFilePath != filePath)
                {
                    endpoints.Save(localFilePath);
                }
            }

            return endpoints;
        }

        /// <summary>
        /// Looks for an extension with the specified type and uses the DataContractSerializer to parse it.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns>
        /// The deserialized extension. Null if an error occurs.
        /// </returns>
        /// <remarks>
        /// The containing element must use the name and namespace uri specified by the DataContractAttribute for the type.
        /// </remarks>
        public T ParseExtension<T>() => ParseExtension<T>(null);

        /// <summary>
        /// Looks for an extension with the specified type and uses the DataContractSerializer to parse it.
        /// </summary>
        /// <typeparam name="T">The type of extension.</typeparam>
        /// <param name="elementName">Name of the element (null means use type name).</param>
        /// <returns>The extension if found. Null otherwise.</returns>
        public T ParseExtension<T>(XmlQualifiedName elementName) => Utils.ParseExtension<T>(m_extensions, elementName);

        /// <summary>
        /// Updates the extension.
        /// </summary>
        /// <typeparam name="T">The type of extension.</typeparam>
        /// <param name="elementName">Name of the element (null means use type name).</param>
        /// <param name="value">The value.</param>
        public void UpdateExtension<T>(XmlQualifiedName elementName, object value) =>
            Utils.UpdateExtension<T>(ref m_extensions, elementName, value);

        /// <summary>
        /// Updates the extension.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="value">The value.</param>
        [Obsolete("Not non-functional. Replaced by a template version UpdateExtension<T>")]
        public void UpdateExtension(Type type, object value)
        {
        }
        #endregion
    }

    #region TraceConfiguration Class
    /// <summary>
    /// Specifies parameters used for tracing.
    /// </summary>
    public partial class TraceConfiguration
    {
        #region Public Methods
        /// <summary>
        /// Applies the trace settings to the current process.
        /// </summary>
        public void ApplySettings()
        {
            Utils.SetTraceLog(m_outputFilePath, m_deleteOnLoad);
            Utils.SetTraceMask(m_traceMasks);

            if (m_traceMasks == 0)
            {
                Utils.SetTraceOutput(Utils.TraceOutput.Off);
            }
            else
            {
                Utils.SetTraceOutput(Utils.TraceOutput.DebugAndFile);
            }
        }
        #endregion
    }
    #endregion

    #region ServerBaseConfiguration Class
    /// <summary>
    /// Specifies the configuration for a server application.
    /// </summary>
    public partial class ServerBaseConfiguration
    {
        #region Public Methods
        /// <summary>
        /// Validates the configuration.
        /// </summary>
        public virtual void Validate()
        {
            if (m_securityPolicies.Count == 0)
            {
                m_securityPolicies.Add(new ServerSecurityPolicy());
            }
        }
        #endregion
    }
    #endregion

    #region ServerConfiguration Class
    /// <summary>
    /// Specifies the configuration for a server application.
    /// </summary>
    public partial class ServerConfiguration : ServerBaseConfiguration
    {
        #region Public Methods
        /// <summary>
        /// Validates the configuration.
        /// </summary>
        public override void Validate()
        {
            base.Validate();

            if (m_userTokenPolicies.Count == 0)
            {
                m_userTokenPolicies.Add(new UserTokenPolicy());
            }
        }
        #endregion
    }
    #endregion

    #region ClientConfiguration Class
    /// <summary>
    /// The configuration for a client application.
    /// </summary>
    public partial class ClientConfiguration
    {
        #region Public Methods
        /// <summary>
        /// Validates the configuration.
        /// </summary>
        public void Validate()
        {
            if (WellKnownDiscoveryUrls.Count == 0)
            {
                WellKnownDiscoveryUrls.AddRange(Utils.DiscoveryUrls);
            }
        }
        #endregion
    }
    #endregion
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
	/// Loads the configuration section for an application.
	/// </summary>
	public class ApplicationConfigurationSection
    {
        #region IConfigurationSectionHandler Members	
        /// <summary>
        /// Creates the configuration object from the configuration section.
        /// </summary>
        /// <param name="parent">The parent object.</param>
        /// <param name="configContext">The configuration context object.</param>
        /// <param name="section">The section as XML node.</param>
        /// <returns>The created section handler object.</returns>
        public object Create(object parent, object configContext, System.Xml.XmlNode section)
        {
            if (section == null)
            {
                throw new ArgumentNullException(nameof(section));
            }

            XmlNode element = section.FirstChild;

            while (element != null && typeof(XmlElement) != element.GetType())
            {
                element = element.NextSibling;
            }

            XmlReader reader = XmlReader.Create(new StringReader(element.OuterXml));

            try
            {
                DataContractSerializer serializer = new DataContractSerializer(typeof(ConfigurationLocation));
                ConfigurationLocation configuration = serializer.ReadObject(reader) as ConfigurationLocation;
                return configuration;
            }
            finally
            {
                reader.Dispose();
            }
        }
        #endregion
    }
    /// <summary>
    /// Represents the location of a configuration file.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaConfig)]
    public class ConfigurationLocation
    {
        #region Persistent Properties
        /// <summary>
        /// Gets or sets the relative or absolute path to the configuration file.
        /// </summary>
        /// <value>The file path.</value>
        [DataMember(IsRequired = true, Order = 0)]
        public string FilePath
        {
            get { return m_filePath; }
            set { m_filePath = value; }
        }
        #endregion

        #region Private Fields
        private string m_filePath;
        #endregion
    }

    /// <summary>
    /// Stores the configurable configuration information for a UA application.
    /// </summary>
    public partial class ApplicationConfiguration
    {
        #region Public Methods
        /// <summary>
        /// Gets the file that was used to load the configuration.
        /// </summary>
        /// <value>The source file path.</value>
        public string SourceFilePath => m_sourceFilePath;

        /// <summary>
        /// Gets or sets the certificate validator which is configured to use.
        /// </summary>
        public CertificateValidator CertificateValidator
        {
            get { return m_certificateValidator; }
            set { m_certificateValidator = value; }
        }

        /// <summary>
        /// Returns the domain names which the server is configured to use.
        /// </summary>
        /// <returns>A list of domain names.</returns>
        public IList<string> GetServerDomainNames()
        {
            StringCollection baseAddresses = new StringCollection();

            if (this.ServerConfiguration != null)
            {
                if (this.ServerConfiguration.BaseAddresses != null)
                {
                    baseAddresses.AddRange(this.ServerConfiguration.BaseAddresses);
                }

                if (this.ServerConfiguration.AlternateBaseAddresses != null)
                {
                    baseAddresses.AddRange(this.ServerConfiguration.AlternateBaseAddresses);
                }
            }

            if (this.DiscoveryServerConfiguration != null)
            {
                if (this.DiscoveryServerConfiguration.BaseAddresses != null)
                {
                    baseAddresses.AddRange(this.DiscoveryServerConfiguration.BaseAddresses);
                }

                if (this.DiscoveryServerConfiguration.AlternateBaseAddresses != null)
                {
                    baseAddresses.AddRange(this.DiscoveryServerConfiguration.AlternateBaseAddresses);
                }
            }

            var domainNames = new List<string>();
            for (int ii = 0; ii < baseAddresses.Count; ii++)
            {
                Uri url = Utils.ParseUri(baseAddresses[ii]);

                if (url == null)
                {
                    continue;
                }

                string domainName = url.DnsSafeHost;

                if (url.HostNameType == UriHostNameType.Dns)
                {
                    domainName = Utils.ReplaceLocalhost(domainName);
                }
                else // IPv4/IPv6 address
                {
                    domainName = Utils.NormalizedIPAddress(domainName);
                }

                if (!Utils.FindStringIgnoreCase(domainNames, domainName))
                {
                    domainNames.Add(domainName);
                }
            }

            return domainNames;
        }

        /// <summary>
        /// Creates the message context from the configuration.
        /// </summary>
        /// <returns>A new instance of a ServiceMessageContext object.</returns>
        public ServiceMessageContext CreateMessageContext(bool clonedFactory = false)
        {
            ServiceMessageContext messageContext = new ServiceMessageContext();

            if (m_transportQuotas != null)
            {
                messageContext.MaxArrayLength = m_transportQuotas.MaxArrayLength;
                messageContext.MaxByteStringLength = m_transportQuotas.MaxByteStringLength;
                messageContext.MaxStringLength = m_transportQuotas.MaxStringLength;
                messageContext.MaxMessageSize = m_transportQuotas.MaxMessageSize;
            }

            messageContext.NamespaceUris = new NamespaceTable();
            messageContext.ServerUris = new StringTable();
            if (clonedFactory)
            {
                messageContext.Factory = new EncodeableFactory(EncodeableFactory.GlobalFactory);
            }
            return messageContext;
        }

        /// <summary>
        /// Creates the message context from the configuration.
        /// </summary>
        /// <value>A new instance of a ServiceMessageContext object.</value>
        [Obsolete("Warning: Behavior changed return a copy instead of a reference. Should call CreateMessageContext() instead.")]
        public ServiceMessageContext MessageContext
        {
            get
            {
                if (m_messageContext == null)
                {
                    m_messageContext = CreateMessageContext();
                }

                return m_messageContext;
            }
        }

        /// <summary>
        /// Loads and validates the application configuration from a configuration section.
        /// </summary>
        /// <param name="sectionName">Name of configuration section for the current application's default configuration containing <see cref="ConfigurationLocation"/>.</param>
        /// <param name="applicationType">Type of the application.</param>
        /// <returns>Application configuration</returns>
        public static Task<ApplicationConfiguration> Load(string sectionName, ApplicationType applicationType) =>
            Load(sectionName, applicationType, typeof(ApplicationConfiguration));

        /// <summary>
        /// Loads and validates the application configuration from a configuration section.
        /// </summary>
        /// <param name="sectionName">Name of configuration section for the current application's default configuration containing <see cref="ConfigurationLocation"/>.</param>
        /// <param name="applicationType">A description for the ApplicationType DataType.</param>
        /// <param name="systemType">A user type of the configuration instance.</param>
        /// <returns>Application configuration</returns>
        public static Task<ApplicationConfiguration> Load(string sectionName, ApplicationType applicationType, Type systemType)
        {
            string filePath = GetFilePathFromAppConfig(sectionName);

            FileInfo file = new FileInfo(filePath);

            if (!file.Exists)
            {
                var message = new StringBuilder();
                message.AppendFormat("Configuration file does not exist: {0}", filePath);
                message.AppendLine();
                message.AppendFormat("Current directory is: {1}", Directory.GetCurrentDirectory());
                throw ServiceResultException.Create(
                    StatusCodes.BadConfigurationError, message.ToString());
            }

            return Load(file, applicationType, systemType);
        }

        /// <summary>
        /// Loads but does not validate the application configuration from a configuration section.
        /// </summary>
        /// <param name="file">The file.</param>
        /// <param name="systemType">Type of the system.</param>
        /// <returns>Application configuration</returns>
        /// <remarks>Use this method to ensure the configuration is not changed during loading.</remarks>
        public static ApplicationConfiguration LoadWithNoValidation(FileInfo file, Type systemType)
        {
            using (var stream = new FileStream(file.FullName, FileMode.Open, FileAccess.Read))
            {
                try
                {
                    DataContractSerializer serializer = new DataContractSerializer(systemType);

                    if (serializer.ReadObject(stream) is ApplicationConfiguration configuration)
                    {
                        configuration.m_sourceFilePath = file.FullName;
                    }

                    return configuration;
                }
                catch (Exception e)
                {
                    var message = new StringBuilder();
                    message.AppendFormat("Configuration file could not be loaded: {0}", file.FullName);
                    message.AppendLine();
                    message.AppendFormat("Error is: {1}", e.Message);
                    throw ServiceResultException.Create(
                        StatusCodes.BadConfigurationError, e, message.ToString());
                }
            }
        }

        /// <summary>
        /// Loads and validates the application configuration from a configuration section.
        /// </summary>
        /// <param name="file">The file.</param>
        /// <param name="applicationType">Type of the application.</param>
        /// <param name="systemType">Type of the system.</param>
        /// <returns>Application configuration</returns>
        public static Task<ApplicationConfiguration> Load(FileInfo file, ApplicationType applicationType, Type systemType) =>
            ApplicationConfiguration.Load(file, applicationType, systemType, true);

        /// <summary>
        /// Loads and validates the application configuration from a configuration section.
        /// </summary>
        /// <param name="file">The file.</param>
        /// <param name="applicationType">Type of the application.</param>
        /// <param name="systemType">Type of the system.</param>
        /// <param name="applyTraceSettings">if set to <c>true</c> apply trace settings after validation.</param>
        /// <param name="certificatePasswordProvider">The certificate password provider.</param>
        /// <returns>Application configuration</returns>
        public static async Task<ApplicationConfiguration> Load(
            FileInfo file,
            ApplicationType applicationType,
            Type systemType,
            bool applyTraceSettings,
            ICertificatePasswordProvider certificatePasswordProvider = null)
        {
            ApplicationConfiguration configuration = null;
            systemType = systemType ?? typeof(ApplicationConfiguration);

            using (FileStream stream = new FileStream(file.FullName, FileMode.Open, FileAccess.Read))
            {
                try
                {
                    DataContractSerializer serializer = new DataContractSerializer(systemType);
                    configuration = (ApplicationConfiguration)serializer.ReadObject(stream);
                }
                catch (Exception e)
                {
                    var message = new StringBuilder();
                    message.AppendFormat("Configuration file could not be loaded: {0}", file.FullName);
                    message.AppendLine();
                    message.AppendFormat("Error is: {0}", e.Message);
                    throw ServiceResultException.Create(
                        StatusCodes.BadConfigurationError, e, message.ToString());
                }
            }

            if (configuration != null)
            {
                // should not be here but need to preserve old behavior.
                if (applyTraceSettings && configuration.TraceConfiguration != null)
                {
                    configuration.TraceConfiguration.ApplySettings();
                }

                configuration.SecurityConfiguration.CertificatePasswordProvider = certificatePasswordProvider;

                await configuration.Validate(applicationType);

                configuration.m_sourceFilePath = file.FullName;
            }

            return configuration;
        }

        /// <summary>
        /// Reads the file path from the application configuration file.
        /// </summary>
	    /// <param name="sectionName">Name of configuration section for the current application's default configuration containing <see cref="ConfigurationLocation"/>.
	    /// </param>
        /// <returns>File path from the application configuration file.</returns>
        public static string GetFilePathFromAppConfig(string sectionName)
        {
            // convert to absolute file path (expands environment strings).
            string absolutePath = Utils.GetAbsoluteFilePath(sectionName + ".Config.xml", true, false, false);
            return (absolutePath != null) ? absolutePath : sectionName + ".Config.xml";
        }

        /// <summary>
        /// Saves the configuration file.
        /// </summary>
        /// <param name="filePath">The file path.</param>
        /// <remarks>Calls GetType() on the current instance and passes that to the DataContractSerializer.</remarks>
        public void SaveToFile(string filePath)
        {
            XmlWriterSettings settings = new XmlWriterSettings() {
                Encoding = Encoding.UTF8,
                Indent = true,
                CloseOutput = true
            };

            using (Stream ostrm = File.Open(filePath, FileMode.Create, FileAccess.ReadWrite))
            using (XmlWriter writer = XmlDictionaryWriter.Create(ostrm, settings))
            {
                DataContractSerializer serializer = new DataContractSerializer(GetType());
                serializer.WriteObject(writer, this);
            }
        }

        /// <summary>
        /// Ensures that the application configuration is valid.
        /// </summary>
        /// <param name="applicationType">Type of the application.</param>
        public virtual async Task Validate(ApplicationType applicationType)
        {
            if (String.IsNullOrEmpty(ApplicationName))
            {
                throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "ApplicationName must be specified.");
            }

            if (SecurityConfiguration == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "SecurityConfiguration must be specified.");
            }

            SecurityConfiguration.Validate();

            // load private key
            await SecurityConfiguration.ApplicationCertificate.LoadPrivateKeyEx(SecurityConfiguration.CertificatePasswordProvider);

            Func<string> generateDefaultUri = () => {
                var sb = new StringBuilder();
                sb.Append("urn:");
                sb.Append(Utils.GetHostName());
                sb.Append(":");
                sb.Append(ApplicationName);
                return sb.ToString();
            };

            if (String.IsNullOrEmpty(ApplicationUri)) m_applicationUri = generateDefaultUri();

            if (applicationType == ApplicationType.Client || applicationType == ApplicationType.ClientAndServer)
            {
                if (ClientConfiguration == null)
                {
                    throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "ClientConfiguration must be specified.");
                }

                ClientConfiguration.Validate();
            }

            if (applicationType == ApplicationType.Server || applicationType == ApplicationType.ClientAndServer)
            {
                if (ServerConfiguration == null)
                {
                    throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "ServerConfiguration must be specified.");
                }

                ServerConfiguration.Validate();
            }

            if (applicationType == ApplicationType.DiscoveryServer)
            {
                if (DiscoveryServerConfiguration == null)
                {
                    throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "DiscoveryServerConfiguration must be specified.");
                }

                DiscoveryServerConfiguration.Validate();
            }

            // toggle the state of the hi-res clock.
            HiResClock.Disabled = m_disableHiResClock;

            if (m_disableHiResClock)
            {
                if (m_serverConfiguration != null)
                {
                    if (m_serverConfiguration.PublishingResolution < 50)
                    {
                        m_serverConfiguration.PublishingResolution = 50;
                    }
                }
            }

            await m_certificateValidator.Update(this.SecurityConfiguration);
        }

        /// <summary>
        /// Loads the endpoints cached on disk.
        /// </summary>
        /// <param name="createAlways">if set to <c>true</c> ConfiguredEndpointCollection is always returned,
        ///	even if loading from disk fails</param>
        /// <returns>Colection of configured endpoints from the disk.</returns>
        public ConfiguredEndpointCollection LoadCachedEndpoints(bool createAlways) => LoadCachedEndpoints(createAlways, false);

        /// <summary>
        /// Loads the endpoints cached on disk.
        /// </summary>
        /// <param name="createAlways">if set to <c>true</c> ConfiguredEndpointCollection is always returned,
        /// even if loading from disk fails</param>
        /// <param name="overrideConfiguration">if set to <c>true</c> overrides the configuration.</param>
        /// <returns>
        /// Colection of configured endpoints from the disk.
        /// </returns>
        public ConfiguredEndpointCollection LoadCachedEndpoints(bool createAlways, bool overrideConfiguration)
        {
            if (m_clientConfiguration == null) throw new InvalidOperationException("Only valid for client configurations.");

            string filePath = Utils.GetAbsoluteFilePath(m_clientConfiguration.EndpointCacheFilePath, true, false, false, false);

            if (filePath == null)
            {
                filePath = m_clientConfiguration.EndpointCacheFilePath;

                if (!Utils.IsPathRooted(filePath))
                {
                    FileInfo sourceFile = new FileInfo(this.SourceFilePath);
                    filePath = Utils.Format("{0}{1}{2}", sourceFile.DirectoryName, Path.DirectorySeparatorChar, filePath);
                }
            }

            if (!createAlways)
            {
                return ConfiguredEndpointCollection.Load(this, filePath, overrideConfiguration);
            }

            ConfiguredEndpointCollection endpoints = new ConfiguredEndpointCollection(this);
            try
            {
                endpoints = ConfiguredEndpointCollection.Load(this, filePath, overrideConfiguration);
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Could not load configuration from file: {0}", filePath);
            }
            finally
            {
                string localFilePath = Utils.GetAbsoluteFilePath(m_clientConfiguration.EndpointCacheFilePath, true, false, true, true);
                if (localFilePath != filePath)
                {
                    endpoints.Save(localFilePath);
                }
            }

            return endpoints;
        }

        /// <summary>
        /// Looks for an extension with the specified type and uses the DataContractSerializer to parse it.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns>
        /// The deserialized extension. Null if an error occurs.
        /// </returns>
        /// <remarks>
        /// The containing element must use the name and namespace uri specified by the DataContractAttribute for the type.
        /// </remarks>
        public T ParseExtension<T>() => ParseExtension<T>(null);

        /// <summary>
        /// Looks for an extension with the specified type and uses the DataContractSerializer to parse it.
        /// </summary>
        /// <typeparam name="T">The type of extension.</typeparam>
        /// <param name="elementName">Name of the element (null means use type name).</param>
        /// <returns>The extension if found. Null otherwise.</returns>
        public T ParseExtension<T>(XmlQualifiedName elementName) => Utils.ParseExtension<T>(m_extensions, elementName);

        /// <summary>
        /// Updates the extension.
        /// </summary>
        /// <typeparam name="T">The type of extension.</typeparam>
        /// <param name="elementName">Name of the element (null means use type name).</param>
        /// <param name="value">The value.</param>
        public void UpdateExtension<T>(XmlQualifiedName elementName, object value) =>
            Utils.UpdateExtension<T>(ref m_extensions, elementName, value);

        /// <summary>
        /// Updates the extension.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <param name="value">The value.</param>
        [Obsolete("Not non-functional. Replaced by a template version UpdateExtension<T>")]
        public void UpdateExtension(Type type, object value)
        {
        }
        #endregion
    }

    #region TraceConfiguration Class
    /// <summary>
    /// Specifies parameters used for tracing.
    /// </summary>
    public partial class TraceConfiguration
    {
        #region Public Methods
        /// <summary>
        /// Applies the trace settings to the current process.
        /// </summary>
        public void ApplySettings()
        {
            Utils.SetTraceLog(m_outputFilePath, m_deleteOnLoad);
            Utils.SetTraceMask(m_traceMasks);

            if (m_traceMasks == 0)
            {
                Utils.SetTraceOutput(Utils.TraceOutput.Off);
            }
            else
            {
                Utils.SetTraceOutput(Utils.TraceOutput.DebugAndFile);
            }
        }
        #endregion
    }
    #endregion

    #region ServerBaseConfiguration Class
    /// <summary>
    /// Specifies the configuration for a server application.
    /// </summary>
    public partial class ServerBaseConfiguration
    {
        #region Public Methods
        /// <summary>
        /// Validates the configuration.
        /// </summary>
        public virtual void Validate()
        {
            if (m_securityPolicies.Count == 0)
            {
                m_securityPolicies.Add(new ServerSecurityPolicy());
            }
        }
        #endregion
    }
    #endregion

    #region ServerConfiguration Class
    /// <summary>
    /// Specifies the configuration for a server application.
    /// </summary>
    public partial class ServerConfiguration : ServerBaseConfiguration
    {
        #region Public Methods
        /// <summary>
        /// Validates the configuration.
        /// </summary>
        public override void Validate()
        {
            base.Validate();

            if (m_userTokenPolicies.Count == 0)
            {
                m_userTokenPolicies.Add(new UserTokenPolicy());
            }
        }
        #endregion
    }
    #endregion

    #region ClientConfiguration Class
    /// <summary>
    /// The configuration for a client application.
    /// </summary>
    public partial class ClientConfiguration
    {
        #region Public Methods
        /// <summary>
        /// Validates the configuration.
        /// </summary>
        public void Validate()
        {
            if (WellKnownDiscoveryUrls.Count == 0)
            {
                WellKnownDiscoveryUrls.AddRange(Utils.DiscoveryUrls);
            }
        }
        #endregion
    }
    #endregion
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\Configuration\ApplicationConfiguration.cs(16,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\Configuration\ApplicationConfiguration.cs(273,28): error CS0165: Use of unassigned local variable 'configuration',D:\a\1\s\Stack\Opc.Ua.Core\Stack\Configuration\ApplicationConfiguration.cs(16,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 12 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Configuration\ConfiguredEndpoints.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Runtime.Serialization;
using System.Threading.Tasks;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// Stores a list of cached enpoints.
    /// </summary>
    public partial class ConfiguredEndpointCollection
    {
        #region Constructors
        /// <summary>
        /// Initializes the object with its default endpoint configuration.
        /// </summary>
        public ConfiguredEndpointCollection(EndpointConfiguration configuration)
        {
            Initialize();

            m_defaultConfiguration = (EndpointConfiguration)configuration.MemberwiseClone();
        }

        /// <summary>
        /// Initializes the object from an application configuration.
        /// </summary>
        public ConfiguredEndpointCollection(ApplicationConfiguration configuration)
        {
            Initialize();

            m_defaultConfiguration = EndpointConfiguration.Create(configuration);

            if (configuration.ClientConfiguration != null)
            {
                m_discoveryUrls = new StringCollection(configuration.ClientConfiguration.WellKnownDiscoveryUrls);
            }
        }
        #endregion

        #region Static Methods
        /// <summary>
        /// Loads a collection of endpoints from a file and overrides the endpoint configuration.
        /// </summary>
        public static ConfiguredEndpointCollection Load(ApplicationConfiguration configuration, string filePath)
        {
            return Load(configuration, filePath, false);
        }

        /// <summary>
        /// Loads a collection of endpoints from a file and overrides the endpoint configuration.
        /// </summary>
        public static ConfiguredEndpointCollection Load(ApplicationConfiguration configuration, string filePath, bool overrideConfiguration)
        {
            ConfiguredEndpointCollection endpoints = Load(filePath);

            endpoints.m_defaultConfiguration = EndpointConfiguration.Create(configuration);

            // override the settings in the configuration.
            foreach (ConfiguredEndpoint endpoint in endpoints.Endpoints)
            {
                if (endpoint.Configuration == null || overrideConfiguration)
                {
                    endpoint.Update(endpoints.DefaultConfiguration);
                }
            }

            return endpoints;
        }

        /// <summary>
        /// Loads a collection of endpoints from a file.
        /// </summary>
        public static ConfiguredEndpointCollection Load(string filePath)
        {
            // load from file.
            ConfiguredEndpointCollection endpoints;
            using (Stream stream = File.OpenRead(filePath))
            {
                endpoints = Load(stream);
            }
            endpoints.m_filepath = filePath;

            // remove invalid endpoints and ensure server descriptions are consistent.
            List<ConfiguredEndpoint> endpointsToRemove = new List<ConfiguredEndpoint>();
            Dictionary<string, ApplicationDescription> servers = new Dictionary<string, ApplicationDescription>();

            foreach (ConfiguredEndpoint endpoint in endpoints.m_endpoints)
            {
                if (endpoint.Description == null)
                {
                    endpointsToRemove.Add(endpoint);
                    continue;
                }

                // set a default value for the server.
                if (endpoint.Description.Server == null)
                {
                    endpoint.Description.Server = new ApplicationDescription();
                    endpoint.Description.Server.ApplicationType = ApplicationType.Server;
                }

                // set a default for application uri.
                if (String.IsNullOrEmpty(endpoint.Description.Server.ApplicationUri))
                {
                    endpoint.Description.Server.ApplicationUri = endpoint.Description.EndpointUrl;
                }

                if (endpoint.Description.Server.DiscoveryUrls == null)
                {
                    endpoint.Description.Server.DiscoveryUrls = new StringCollection();
                }

                if (endpoint.Description.Server.DiscoveryUrls.Count == 0)
                {
                    string discoveryUrl = endpoint.Description.EndpointUrl;

                    if (!discoveryUrl.StartsWith(Utils.UriSchemeOpcTcp))
                    {
                        discoveryUrl += "/discovery";
                    }

                    endpoint.Description.Server.DiscoveryUrls.Add(discoveryUrl);
                }

                // normalize transport profile uri.
                if (endpoint.Description.TransportProfileUri != null)
                {
                    endpoint.Description.TransportProfileUri = Profiles.NormalizeUri(endpoint.Description.TransportProfileUri);
                }

                ApplicationDescription server = null;

                if (!servers.TryGetValue(endpoint.Description.Server.ApplicationUri, out server))
                {
                    // use the first description in the file as the correct master.
                    server = endpoint.Description.Server;

                    servers[server.ApplicationUri] = server;

                    // check if the server uri needs to be made globally unique.
                    server.ApplicationUri = Utils.UpdateInstanceUri(server.ApplicationUri);
                    servers[server.ApplicationUri] = server;
                    continue;
                }

                endpoint.Description.Server = (ApplicationDescription)server.MemberwiseClone();


            }

            // remove invalid endpoints.
            foreach (ConfiguredEndpoint endpoint in endpointsToRemove)
            {
                endpoints.Remove(endpoint);
            }

            // return processed collection.
            return endpoints;
        }

        /// <summary>
        /// Loads a collection of endpoints from a stream.
        /// </summary>
        public static ConfiguredEndpointCollection Load(Stream istrm)
        {
            try
            {
                DataContractSerializer serializer = new DataContractSerializer(typeof(ConfiguredEndpointCollection));
                ConfiguredEndpointCollection endpoints = serializer.ReadObject(istrm) as ConfiguredEndpointCollection;

                if (endpoints != null)
                {
                    foreach (ConfiguredEndpoint endpoint in endpoints)
                    {
                        if (endpoint.Description != null)
                        {
                            endpoint.Description.TransportProfileUri = Profiles.NormalizeUri(endpoint.Description.TransportProfileUri);
                        }
                    }
                }

                return endpoints;
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Unexpected error loading ConfiguredEnpoints.");
                throw;
            }
        }

        /// <summary>
        /// Saves a collection of endpoints the file that it was loaded from.
        /// </summary>
        public void Save()
        {
            Save(m_filepath);
        }

        /// <summary>
        /// Saves a collection of endpoints to a file.
        /// </summary>
        public void Save(string filePath)
        {
            using (Stream stream = File.Open(filePath, FileMode.Create))
            {
                Save(stream);
            }
            m_filepath = filePath;
        }

        /// <summary>
        /// Saves a collection of endpoints to a stream.
        /// </summary>
        public void Save(Stream ostrm)
        {
            DataContractSerializer serializer = new DataContractSerializer(typeof(ConfiguredEndpointCollection));
            serializer.WriteObject(ostrm, this);
        }

        /// <summary>
        /// Returns a deep copy of the collection.
        /// </summary>
        public new object MemberwiseClone()
        {
            ConfiguredEndpointCollection clone = new ConfiguredEndpointCollection();

            clone.m_filepath = m_filepath;
            clone.m_knownHosts = new StringCollection(m_knownHosts);
            clone.m_defaultConfiguration = (EndpointConfiguration)m_defaultConfiguration.MemberwiseClone();

            foreach (ConfiguredEndpoint endpoint in m_endpoints)
            {
                ConfiguredEndpoint clonedEndpoint = (ConfiguredEndpoint)endpoint.MemberwiseClone();
                clonedEndpoint.Collection = clone;
                clone.m_endpoints.Add(clonedEndpoint);
            }

            return clone;
        }

        #region IList<ConfiguredEndpoint> Members
        /// <summary>
        /// Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
        /// </summary>
        /// <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        /// <returns>
        /// The index of <paramref name="item"/> if found in the list; otherwise, -1.
        /// </returns>
        public int IndexOf(ConfiguredEndpoint item)
        {
            for (int ii = 0; ii < m_endpoints.Count; ii++)
            {
                if (object.ReferenceEquals(item, m_endpoints[ii]))
                {
                    return ii;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
        /// <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// 	<paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception>
        /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        public void Insert(int index, ConfiguredEndpoint item)
        {
            Insert(item, index);
        }

        /// <summary>
        /// Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the item to remove.</param>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// 	<paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception>
        /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        public void RemoveAt(int index)
        {
            if (index < 0 || index >= m_endpoints.Count) throw new ArgumentOutOfRangeException(nameof(index));
            Remove(m_endpoints[index]);
        }

        /// <summary>
        /// Gets or sets the <see cref="Opc.Ua.ConfiguredEndpoint"/> at the specified index.
        /// </summary>
        /// <value>The <see cref="Opc.Ua.ConfiguredEndpoint"/> at the index</value>
        public ConfiguredEndpoint this[int index]
        {
            get
            {
                return m_endpoints[index];
            }

            set
            {
                throw new NotImplementedException();
            }
        }
        #endregion

        #region ICollection<ConfiguredEndpoint> Members
        /// <summary>
        /// Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. </exception>
        public void Clear()
        {
            this.m_endpoints.Clear();
        }

        /// <summary>
        /// Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
        /// </summary>
        /// <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        /// <returns>
        /// true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
        /// </returns>
        public bool Contains(ConfiguredEndpoint item)
        {
            for (int ii = 0; ii < m_endpoints.Count; ii++)
            {
                if (object.ReferenceEquals(item, m_endpoints[ii]))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// 	<paramref name="array"/> is null.</exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// 	<paramref name="arrayIndex"/> is less than 0.</exception>
        /// <exception cref="T:System.ArgumentException">
        /// 	<paramref name="array"/> is multidimensional.-or-<paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>./>.</exception>
        public void CopyTo(ConfiguredEndpoint[] array, int arrayIndex)
        {
            m_endpoints.CopyTo(array, arrayIndex);
        }

        /// <summary>
        /// Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
        public int Count => m_endpoints.Count;

        /// <summary>
        /// Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
        /// </summary>
        /// <value></value>
        /// <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.</returns>
        public bool IsReadOnly => false;
        #endregion

        #region IEnumerable<ConfiguredEndpoint> Members
        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<ConfiguredEndpoint> GetEnumerator()
        {
            return m_endpoints.GetEnumerator();
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Add the endpoint description to the cache.
        /// </summary>
        public ConfiguredEndpoint Add(EndpointDescription endpoint)
        {
            return Add(endpoint, null);
        }

        /// <summary>
        /// Add the endpoint description and configuration to the cache.
        /// </summary>
        public ConfiguredEndpoint Add(EndpointDescription endpoint, EndpointConfiguration configuration)
        {
            ValidateEndpoint(endpoint);

            foreach (ConfiguredEndpoint item in m_endpoints)
            {
                if (Object.ReferenceEquals(item.Description, endpoint))
                {
                    throw new ArgumentException("Endpoint already exists in the collection.");
                }
            }

            ConfiguredEndpoint configuredEndpoint = new ConfiguredEndpoint(this, endpoint, configuration);
            m_endpoints.Add(configuredEndpoint);
            return configuredEndpoint;
        }

        /// <summary>
        /// Adds a previous created endpoint to the collection.
        /// </summary>
        public void Add(ConfiguredEndpoint item)
        {
            Insert(item, -1);
        }

        /// <summary>
        /// Adds a previous created endpoint to the collection.
        /// </summary>
        private void Insert(ConfiguredEndpoint endpoint, int index)
        {
            if (endpoint == null) throw new ArgumentNullException(nameof(endpoint));

            ValidateEndpoint(endpoint.Description);

            // update collection.
            if (endpoint.Collection != null)
            {
                endpoint.Collection.Remove(endpoint);
            }

            endpoint.Collection = this;

            if (!Object.ReferenceEquals(endpoint.Collection, this))
            {
                throw new ArgumentException("Cannot add an endpoint from another collection.");
            }

            if (m_endpoints.Contains(endpoint))
            {
                throw new ArgumentException("Endpoint already belongs to the collection.");
            }

            if (index < 0)
            {
                m_endpoints.Add(endpoint);
            }
            else
            {
                m_endpoints.Insert(index, endpoint);
            }
        }

        /// <summary>
        /// Removes the configured endpoint.
        /// </summary>
        public bool Remove(ConfiguredEndpoint item)
        {
            if (item == null) throw new ArgumentNullException(nameof(item));
            return m_endpoints.Remove(item);
        }

        /// <summary>
        /// Removes all endpoints for the specified server.
        /// </summary>
        public void RemoveServer(string serverUri)
        {
            if (serverUri == null) throw new ArgumentNullException(nameof(serverUri));

            foreach (ConfiguredEndpoint endpointToRemove in GetEndpoints(serverUri))
            {
                Remove(endpointToRemove);
            }
        }

        /// <summary>
        /// Updates the server descrption for the endpoints.
        /// </summary>
        public void SetApplicationDescription(string serverUri, ApplicationDescription server)
        {
            if (server == null) throw new ArgumentNullException(nameof(server));

            if (String.IsNullOrEmpty(server.ApplicationUri))
            {
                throw new ArgumentException("A ServerUri must provided.", nameof(server));
            }

            if (server.DiscoveryUrls.Count == 0)
            {
                throw new ArgumentException("At least one DiscoveryUrl must be provided.", nameof(server));
            }

            List<ConfiguredEndpoint> endpoints = GetEndpoints(server.ApplicationUri);

            // create a placeholder endpoint for the server description.
            if (endpoints.Count == 0)
            {
                string endpointUrl = null;

                for (int ii = 0; ii < server.DiscoveryUrls.Count; ii++)
                {
                    if (!String.IsNullOrEmpty(server.DiscoveryUrls[ii]))
                    {
                        endpointUrl = server.DiscoveryUrls[ii];
                        break;
                    }
                }

                if (endpointUrl != null && endpointUrl.EndsWith("/discovery", StringComparison.Ordinal))
                {
                    endpointUrl = endpointUrl.Substring(0, endpointUrl.Length - "/discovery".Length);
                }

                if (endpointUrl != null)
                {
                    ConfiguredEndpoint endpoint = Create(endpointUrl);
                    endpoint.Description.Server = (ApplicationDescription)server.MemberwiseClone();
                    Add(endpoint);
                }
            }

            // update all endpoints with the same server uri.
            else
            {
                foreach (ConfiguredEndpoint endpointToUpdate in GetEndpoints(serverUri))
                {
                    endpointToUpdate.Description.Server = (ApplicationDescription)server.MemberwiseClone();
                }
            }
        }

        /// <summary>
        /// Creates a new endpoint from a url that is not part of the collection.
        /// </summary>
        /// <remarks>
        /// Call the Add() method to add it to the collection.
        /// </remarks>
        public ConfiguredEndpoint Create(string url)
        {
            // check for security parameters appended to the URL
            string parameters = null;

            int index = url.IndexOf("- [", StringComparison.Ordinal);

            if (index != -1)
            {
                parameters = url.Substring(index + 3);
                url = url.Substring(0, index).Trim();
            }

            MessageSecurityMode securityMode = MessageSecurityMode.SignAndEncrypt;
            string securityPolicyUri = SecurityPolicies.Basic256Sha256;
            bool useBinaryEncoding = true;

            if (!String.IsNullOrEmpty(parameters))
            {
                string[] fields = parameters.Split(new char[] { '-', '[', ':', ']' }, StringSplitOptions.RemoveEmptyEntries);

                try
                {
                    if (fields.Length > 0)
                    {
                        securityMode = (MessageSecurityMode)Enum.Parse(typeof(MessageSecurityMode), fields[0], false);
                    }
                    else
                    {
                        securityMode = MessageSecurityMode.None;
                    }
                }
                catch
                {
                    securityMode = MessageSecurityMode.None;
                }

                try
                {
                    if (fields.Length > 1)
                    {
                        securityPolicyUri = SecurityPolicies.GetUri(fields[1]);
                    }
                    else
                    {
                        securityPolicyUri = SecurityPolicies.None;
                    }
                }
                catch
                {
                    securityPolicyUri = SecurityPolicies.None;
                }

                try
                {
                    if (fields.Length > 2)
                    {
                        useBinaryEncoding = fields[2] == "Binary";
                    }
                    else
                    {
                        useBinaryEncoding = false;
                    }
                }
                catch
                {
                    useBinaryEncoding = false;
                }
            }

            Uri uri = new Uri(url);

            EndpointDescription description = new EndpointDescription();

            description.EndpointUrl = uri.ToString();
            description.SecurityMode = securityMode;
            description.SecurityPolicyUri = securityPolicyUri;
            description.Server.ApplicationUri = Utils.UpdateInstanceUri(uri.ToString());
            description.Server.ApplicationName = uri.AbsolutePath;

            if (description.EndpointUrl.StartsWith(Utils.UriSchemeOpcTcp, StringComparison.Ordinal))
            {
                description.TransportProfileUri = Profiles.UaTcpTransport;
                description.Server.DiscoveryUrls.Add(description.EndpointUrl);
            }
            else if (description.EndpointUrl.StartsWith(Utils.UriSchemeHttps, StringComparison.Ordinal))
            {
                description.TransportProfileUri = Profiles.HttpsBinaryTransport;
                description.Server.DiscoveryUrls.Add(description.EndpointUrl);
            }

            ConfiguredEndpoint endpoint = new ConfiguredEndpoint(this, description, null);
            endpoint.Configuration.UseBinaryEncoding = useBinaryEncoding;
            endpoint.UpdateBeforeConnect = true;
            return endpoint;
        }

        /// <summary>
        /// Returns the configured endpoints for the server uri.
        /// </summary>
        public List<ConfiguredEndpoint> GetEndpoints(string serverUri)
        {
            List<ConfiguredEndpoint> endpoints = new List<ConfiguredEndpoint>();

            foreach (ConfiguredEndpoint endpoint in m_endpoints)
            {
                if (endpoint.Description.Server.ApplicationUri == serverUri)
                {
                    endpoints.Add(endpoint);
                }
            }

            return endpoints;
        }

        /// <summary>
        /// Returns the servers that are part of the collection.
        /// </summary>
        public ApplicationDescriptionCollection GetServers()
        {
            Dictionary<string, ApplicationDescription> servers = new Dictionary<string, ApplicationDescription>();

            foreach (ConfiguredEndpoint endpoint in m_endpoints)
            {
                ApplicationDescription server = endpoint.Description.Server;

                if (!String.IsNullOrEmpty(server.ApplicationUri))
                {
                    if (!servers.ContainsKey(server.ApplicationUri))
                    {
                        servers.Add(server.ApplicationUri, server);
                    }
                }
            }

            return new ApplicationDescriptionCollection(servers.Values);
        }

        /// <summary>
        /// Copies the endpoints.
        /// </summary>
        /// <param name="serverUri">The server URI.</param>
        /// <returns></returns>
        [Obsolete("Non-functional - replaced with GetEndpoints()")]
        public List<ConfiguredEndpoint> CopyEndpoints(string serverUri)
        {
            return null;
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        [Obsolete("Non-functional - method not used - updates should be done with ConfiguredEndpoint.UpdateFromServer()")]
        public void UpdateEndpointsForServer(string serverUri)
        {
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// A list of well known urls that can be used for discovery.
        /// </summary>
        public StringCollection DiscoveryUrls
        {
            get
            {
                return m_discoveryUrls;
            }

            set
            {
                if (value == null)
                {
                    m_discoveryUrls = new StringCollection(Utils.DiscoveryUrls);
                }
                else
                {
                    m_discoveryUrls = value;
                }
            }
        }

        /// <summary>
        /// The default configuration for new ConfiguredEndpoints.
        /// </summary>
        public EndpointConfiguration DefaultConfiguration => m_defaultConfiguration;
        #endregion

        #region Private Methods
        /// <summary>
        /// Throws exceptions if the endpoint is not valid.
        /// </summary>
        private static void ValidateEndpoint(EndpointDescription endpoint)
        {
            if (endpoint == null)
            {
                throw new ArgumentException("Endpoint must not be null.");
            }

            if (String.IsNullOrEmpty(endpoint.EndpointUrl))
            {
                throw new ArgumentException("Endpoint must have a valid URL.");
            }

            if (endpoint.Server == null)
            {
                endpoint.Server = new ApplicationDescription();
                endpoint.Server.ApplicationType = ApplicationType.Server;
            }

            if (String.IsNullOrEmpty(endpoint.Server.ApplicationUri))
            {
                endpoint.Server.ApplicationUri = endpoint.EndpointUrl;
            }
        }
        #endregion
    }

    #region ConfiguredEndpoint Class
    /// <summary>
    /// Stores the configuration information for an endpoint.
    /// </summary>
    public partial class ConfiguredEndpoint : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Creates a configured endpoint from the server description.
        /// </summary>
        public ConfiguredEndpoint(
            ApplicationDescription server,
            EndpointConfiguration configuration)
        {
            if (server == null) throw new ArgumentNullException(nameof(server));

            m_description = new EndpointDescription();
            m_updateBeforeConnect = true;

            m_description.Server = server;

            foreach (string discoveryUrl in server.DiscoveryUrls)
            {
                string baseUrl = discoveryUrl;

                if (baseUrl != null)
                {
                    if (baseUrl.EndsWith("/discovery", StringComparison.Ordinal))
                    {
                        baseUrl = baseUrl.Substring(0, baseUrl.Length - "/discovery".Length);
                    }
                }

                Uri url = Utils.ParseUri(baseUrl);

                if (url != null)
                {
                    m_description.EndpointUrl = url.ToString();
                    m_description.SecurityMode = MessageSecurityMode.SignAndEncrypt;
                    m_description.SecurityPolicyUri = SecurityPolicies.Basic256Sha256;
                    m_description.UserIdentityTokens.Add(new UserTokenPolicy(UserTokenType.Anonymous));

                    if (url.Scheme == Utils.UriSchemeHttps)
                    {
                        m_description.TransportProfileUri = Profiles.HttpsBinaryTransport;
                    }

                    if (url.Scheme == Utils.UriSchemeOpcTcp)
                    {
                        m_description.TransportProfileUri = Profiles.UaTcpTransport;
                    }

                    break;
                }
            }

            // ensure a default configuration.
            if (configuration == null)
            {
                configuration = EndpointConfiguration.Create();
            }

            Update(configuration);
        }

        /// <summary>
        /// The default constructor.
        /// </summary>
        public ConfiguredEndpoint(
            ConfiguredEndpointCollection collection,
            EndpointDescription description)
        :
            this(collection, description, null)
        {
        }

        /// <summary>
        /// The default constructor.
        /// </summary>
        public ConfiguredEndpoint(
            ConfiguredEndpointCollection collection,
            EndpointDescription description,
            EndpointConfiguration configuration)
        {
            if (description == null) throw new ArgumentNullException(nameof(description));

            m_collection = collection;
            m_description = description;
            m_updateBeforeConnect = true;

            // ensure a default configuration.
            if (configuration == null)
            {
                if (collection != null)
                {
                    configuration = collection.DefaultConfiguration;
                }
                else
                {
                    configuration = EndpointConfiguration.Create();
                }
            }

            Update(configuration);
        }
        #endregion

        /// <summary>
        /// Returns a deep copy of the endpoint.
        /// </summary>
        public new object MemberwiseClone()
        {
            ConfiguredEndpoint clone = new ConfiguredEndpoint();
            clone.Collection = this.Collection;
            clone.Update(this);
            return clone;
        }

        #region Overridden Methods
        /// <summary>
        /// Returns the string representation of the object.
        /// </summary>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        #region IFormattable Members
        /// <summary>
        /// Returns the string representation of the object.
        /// </summary>
        /// <param name="format">(Unused). Always pass NULL/NOTHING</param>
        /// <param name="formatProvider">(Unused). Always pass NULL/NOTHING</param>
        /// <exception cref="FormatException">Thrown if non-null parameters are used</exception>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                return Utils.Format(
                    "{0} - [{1}:{2}:{3}]",
                    m_description.EndpointUrl,
                    m_description.SecurityMode,
                    SecurityPolicies.GetDisplayName(m_description.SecurityPolicyUri),
                    (m_configuration != null && m_configuration.UseBinaryEncoding) ? "Binary" : "XML");
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Determine if an update of the endpoint from the server is needed.
        /// </summary>
        public bool NeedUpdateFromServer()
        {
            bool hasCertificate = (Description.ServerCertificate != null && Description.ServerCertificate.Length > 0);
            bool usingUserTokenSecurity =
                (SelectedUserTokenPolicy.TokenType != UserTokenType.Anonymous) &&
                (SelectedUserTokenPolicy.SecurityPolicyUri ?? SecurityPolicies.None) != SecurityPolicies.None;
            bool usingTransportSecurity = Description.SecurityPolicyUri != SecurityPolicies.None;
            return (usingUserTokenSecurity || usingTransportSecurity) && !hasCertificate;
        }

        /// <summary>
        /// Updates the endpoint description.
        /// </summary>
        public void Update(ConfiguredEndpoint endpoint)
        {
            if (endpoint == null) throw new ArgumentNullException(nameof(endpoint));

            m_description = (EndpointDescription)endpoint.Description.MemberwiseClone();
            m_configuration = (EndpointConfiguration)endpoint.Configuration.MemberwiseClone();

            // normalize transport profile uri.
            if (m_description.TransportProfileUri != null)
            {
                m_description.TransportProfileUri = Profiles.NormalizeUri(m_description.TransportProfileUri);
            }

            m_updateBeforeConnect = endpoint.m_updateBeforeConnect;
            m_selectedUserTokenPolicyIndex = endpoint.m_selectedUserTokenPolicyIndex;
            m_binaryEncodingSupport = endpoint.m_binaryEncodingSupport;

            if (endpoint.m_userIdentity != null)
            {
                m_userIdentity = (UserIdentityToken)endpoint.m_userIdentity.MemberwiseClone();
            }
        }

        /// <summary>
        /// Updates the endpoint description.
        /// </summary>
        public void Update(EndpointDescription description)
        {
            if (description == null) throw new ArgumentNullException(nameof(description));

            m_description = (EndpointDescription)description.MemberwiseClone();

            // normalize transport profile uri.
            if (m_description.TransportProfileUri != null)
            {
                m_description.TransportProfileUri = Profiles.NormalizeUri(m_description.TransportProfileUri);
            }

            // set the proxy url.
            if (m_collection != null && m_description.EndpointUrl != null)
            {
                if (m_description.EndpointUrl.StartsWith(Utils.UriSchemeOpcTcp, StringComparison.Ordinal))
                {
                    m_description.ProxyUrl = m_collection.TcpProxyUrl;
                }
            }
        }

        /// <summary>
        /// Updates the endpoint configuration.
        /// </summary>
        public void Update(EndpointConfiguration configuration)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));

            m_configuration = (EndpointConfiguration)configuration.MemberwiseClone();

            BinaryEncodingSupport binaryEncodingSupport = m_description.EncodingSupport;

            // check if the configuration restricts the encoding if the endpoint supports both.
            if (binaryEncodingSupport == BinaryEncodingSupport.Optional)
            {
                binaryEncodingSupport = m_binaryEncodingSupport;
            }

            if (binaryEncodingSupport == BinaryEncodingSupport.None)
            {
                m_configuration.UseBinaryEncoding = false;
            }

            if (binaryEncodingSupport == BinaryEncodingSupport.Required)
            {
                m_configuration.UseBinaryEncoding = true;
            }
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public void UpdateFromServer()
        {
            UpdateFromServer(EndpointUrl, m_description.SecurityMode, m_description.SecurityPolicyUri);
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public void UpdateFromServer(
            Uri endpointUrl,
            MessageSecurityMode securityMode,
            string securityPolicyUri)
        {
            UpdateFromServer(endpointUrl, null, securityMode, securityPolicyUri);
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public void UpdateFromServer(
            Uri endpointUrl,
            ITransportWaitingConnection connection,
            MessageSecurityMode securityMode,
            string securityPolicyUri)
        {
            // get the a discovery url.
            Uri discoveryUrl = GetDiscoveryUrl(endpointUrl);

            // create the discovery client.
            DiscoveryClient client;
            if (connection != null)
            {
                client = DiscoveryClient.Create(connection, m_configuration);
            }
            else
            {
                client = DiscoveryClient.Create(discoveryUrl, m_configuration);
            }

            try
            {
                // get the endpoints.
                EndpointDescriptionCollection collection = client.GetEndpoints(null);

                // find list of matching endpoints.
                var matches = MatchEndpoints(
                    collection,
                    endpointUrl,
                    securityMode,
                    securityPolicyUri
                    );

                // select best match
                var match = SelectBestMatch(matches, discoveryUrl);

                // update the endpoint.                        
                Update(match);
            }
            finally
            {
                client.Close();
            }
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public Task UpdateFromServerAsync()
        {
            return UpdateFromServerAsync(EndpointUrl, m_description.SecurityMode, m_description.SecurityPolicyUri);
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public Task UpdateFromServerAsync(
            Uri endpointUrl,
            MessageSecurityMode securityMode,
            string securityPolicyUri)
        {
            return UpdateFromServerAsync(endpointUrl, null, securityMode, securityPolicyUri);
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public async Task UpdateFromServerAsync(
            Uri endpointUrl,
            ITransportWaitingConnection connection,
            MessageSecurityMode securityMode,
            string securityPolicyUri)
        {
            // get the a discovery url.
            Uri discoveryUrl = GetDiscoveryUrl(endpointUrl);

            // create the discovery client.
            DiscoveryClient client;
            if (connection != null)
            {
                client = DiscoveryClient.Create(connection, m_configuration);
            }
            else
            {
                client = DiscoveryClient.Create(discoveryUrl, m_configuration);
            }

            try
            {
                // get the endpoints.
                EndpointDescriptionCollection collection = await client.GetEndpointsAsync(null);

                // find list of matching endpoints.
                var matches = MatchEndpoints(
                    collection,
                    endpointUrl,
                    securityMode,
                    securityPolicyUri
                    );

                // select best match
                var match = SelectBestMatch(matches, discoveryUrl);

                // update the endpoint.                        
                Update(match);
            }
            finally
            {
                client.Close();
            }
        }

        /// <summary>
        /// Returns a discovery url that can be used to update the endpoint description.
        /// </summary>
        public Uri GetDiscoveryUrl(Uri endpointUrl)
        {
            // update the endpoint description.
            if (endpointUrl != null)
            {
                m_description.EndpointUrl = endpointUrl.ToString();
            }
            else
            {
                endpointUrl = Utils.ParseUri(m_description.EndpointUrl);
            }

            // get the know discovery URLs.
            StringCollection discoveryUrls = null;

            if (m_description.Server != null)
            {
                discoveryUrls = m_description.Server.DiscoveryUrls;
            }

            // attempt to construct a discovery url by appending 'discovery' to the endpoint.
            if (discoveryUrls == null || discoveryUrls.Count == 0)
            {
                if (endpointUrl.Scheme != Utils.UriSchemeOpcTcp)
                {
                    return new Uri(String.Format(CultureInfo.InvariantCulture, "{0}/discovery", endpointUrl));
                }
                else
                {
                    return endpointUrl;
                }
            }

            // choose the URL that uses the same protocol if one exists.
            for (int ii = 1; ii < discoveryUrls.Count; ii++)
            {
                if (discoveryUrls[ii].StartsWith(endpointUrl.Scheme, StringComparison.Ordinal))
                {
                    return Utils.ParseUri(discoveryUrls[ii]);
                }
            }

            // return the first in the list.
            return Utils.ParseUri(discoveryUrls[0]);
        }

        /// <summary>
        /// Parses the extension.
        /// </summary>
        /// <typeparam name="T">The type of extension.</typeparam>
        /// <param name="elementName">Name of the element (null means use type name).</param>
        /// <returns>The extension if found. Null otherwise.</returns>
        public T ParseExtension<T>(XmlQualifiedName elementName)
        {
            return Utils.ParseExtension<T>(m_extensions, elementName);
        }

        /// <summary>
        /// Updates the extension.
        /// </summary>
        /// <typeparam name="T">The type of extension.</typeparam>
        /// <param name="elementName">Name of the element (null means use type name).</param>
        /// <param name="value">The value.</param>
        public void UpdateExtension<T>(XmlQualifiedName elementName, object value)
        {
            Utils.UpdateExtension<T>(ref m_extensions, elementName, value);
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// The collection that the endpoint belongs to. 
        /// </summary>
        public ConfiguredEndpointCollection Collection
        {
            get
            {
                return m_collection;
            }

            internal set
            {
                if (value == null) throw new ArgumentNullException(nameof(value));
                m_collection = value;
            }
        }

        /// <summary>
        /// The URL used to create a sessions.
        /// </summary>
        public Uri EndpointUrl
        {
            get
            {
                if (String.IsNullOrEmpty(m_description.EndpointUrl))
                {
                    return null;
                }

                return Utils.ParseUri(m_description.EndpointUrl);
            }

            set
            {
                if (value == null)
                {
                    m_description.EndpointUrl = null;
                }

                m_description.EndpointUrl = String.Format(CultureInfo.InvariantCulture, "{0}", value);
            }
        }

        /// <summary>
        /// The user identity to use when connecting to the endpoint.
        /// </summary>
        public UserTokenPolicy SelectedUserTokenPolicy
        {
            get
            {
                if (m_description != null && m_description.UserIdentityTokens != null)
                {
                    UserTokenPolicyCollection policies = m_description.UserIdentityTokens;

                    if (m_selectedUserTokenPolicyIndex >= 0 && policies.Count > m_selectedUserTokenPolicyIndex)
                    {
                        return policies[m_selectedUserTokenPolicyIndex];
                    }
                }

                return null;
            }

            set
            {
                if (m_description != null && m_description.UserIdentityTokens != null)
                {
                    UserTokenPolicyCollection policies = m_description.UserIdentityTokens;

                    for (int ii = 0; ii < policies.Count; ii++)
                    {
                        if (Object.ReferenceEquals(policies[ii], value))
                        {
                            m_selectedUserTokenPolicyIndex = ii;
                            break;
                        }
                    }
                }

                m_selectedUserTokenPolicyIndex = -1;
            }
        }
        #endregion

        #region Private Methods
        private EndpointDescriptionCollection MatchEndpoints(
            EndpointDescriptionCollection collection,
            Uri endpointUrl,
            MessageSecurityMode securityMode,
            string securityPolicyUri)
        {
            if (collection == null || collection.Count == 0)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadUnknownResponse,
                    "Server does not have any endpoints defined.");
            }

            // find list of matching endpoints.
            EndpointDescriptionCollection matches = new EndpointDescriptionCollection();

            // first pass - match on the requested security parameters.
            foreach (EndpointDescription description in collection)
            {
                // check for match on security policy.
                if (!String.IsNullOrEmpty(securityPolicyUri))
                {
                    if (securityPolicyUri != description.SecurityPolicyUri)
                    {
                        continue;
                    }
                }

                // check for match on security mode.
                if (securityMode != MessageSecurityMode.Invalid)
                {
                    if (securityMode != description.SecurityMode)
                    {
                        continue;
                    }
                }

                // add to list of matches.
                matches.Add(description);
            }

            // no matches (security parameters may have changed).
            if (matches.Count == 0)
            {
                matches = collection;
            }

            // check if list has to be narrowed down further.
            if (matches.Count > 1)
            {
                collection = matches;
                matches = new EndpointDescriptionCollection();

                // second pass - match on the url scheme.
                foreach (EndpointDescription description in collection)
                {
                    // parse the endpoint url.
                    Uri sessionUrl = Utils.ParseUri(description.EndpointUrl);

                    if (sessionUrl == null)
                    {
                        continue;
                    }

                    // check for matching protocol.
                    if (sessionUrl.Scheme != endpointUrl.Scheme)
                    {
                        continue;
                    }

                    matches.Add(description);
                }
            }

            // no matches (protocol may not be supported).
            if (matches.Count == 0)
            {
                matches = collection;
            }

            return matches;
        }

        /// <summary>
        /// Select the best match from a security description.
        /// </summary>
        private EndpointDescription SelectBestMatch(
            EndpointDescriptionCollection matches,
            Uri discoveryUrl
            )
        {
            // choose first in list by default.
            EndpointDescription match = matches[0];

            // check if list has to be narrowed down further.
            if (matches.Count > 1)
            {
                // third pass - match based on security level.
                foreach (EndpointDescription description in matches)
                {
                    if (description.SecurityLevel > match.SecurityLevel)
                    {
                        match = description;
                    }
                }
            }

            // check if the endpoint url matches the endpoint used in the request.
            if (discoveryUrl != null)
            {
                Uri matchUrl = Utils.ParseUri(match.EndpointUrl);
                if (matchUrl == null || String.Compare(discoveryUrl.DnsSafeHost, matchUrl.DnsSafeHost, StringComparison.OrdinalIgnoreCase) != 0)
                {
                    UriBuilder uri = new UriBuilder(matchUrl);
                    uri.Host = discoveryUrl.DnsSafeHost;
                    uri.Port = discoveryUrl.Port;
                    match.EndpointUrl = uri.ToString();

                    // need to update the discovery urls.
                    match.Server.DiscoveryUrls.Clear();
                    match.Server.DiscoveryUrls.Add(discoveryUrl.ToString());
                }
            }

            return match;
        }
        #endregion
    }
    #endregion
}
#endregion

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Runtime.Serialization;
using System.Threading.Tasks;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// Stores a list of cached enpoints.
    /// </summary>
    public partial class ConfiguredEndpointCollection
    {
        #region Constructors
        /// <summary>
        /// Initializes the object with its default endpoint configuration.
        /// </summary>
        public ConfiguredEndpointCollection(EndpointConfiguration configuration)
        {
            Initialize();

            m_defaultConfiguration = (EndpointConfiguration)configuration.MemberwiseClone();
        }

        /// <summary>
        /// Initializes the object from an application configuration.
        /// </summary>
        public ConfiguredEndpointCollection(ApplicationConfiguration configuration)
        {
            Initialize();

            m_defaultConfiguration = EndpointConfiguration.Create(configuration);

            if (configuration.ClientConfiguration != null)
            {
                m_discoveryUrls = new StringCollection(configuration.ClientConfiguration.WellKnownDiscoveryUrls);
            }
        }
        #endregion

        #region Static Methods
        /// <summary>
        /// Loads a collection of endpoints from a file and overrides the endpoint configuration.
        /// </summary>
        public static ConfiguredEndpointCollection Load(ApplicationConfiguration configuration, string filePath)
        {
            return Load(configuration, filePath, false);
        }

        /// <summary>
        /// Loads a collection of endpoints from a file and overrides the endpoint configuration.
        /// </summary>
        public static ConfiguredEndpointCollection Load(ApplicationConfiguration configuration, string filePath, bool overrideConfiguration)
        {
            ConfiguredEndpointCollection endpoints = Load(filePath);

            endpoints.m_defaultConfiguration = EndpointConfiguration.Create(configuration);

            // override the settings in the configuration.
            foreach (ConfiguredEndpoint endpoint in endpoints.Endpoints)
            {
                if (endpoint.Configuration == null || overrideConfiguration)
                {
                    endpoint.Update(endpoints.DefaultConfiguration);
                }
            }

            return endpoints;
        }

        /// <summary>
        /// Loads a collection of endpoints from a file.
        /// </summary>
        public static ConfiguredEndpointCollection Load(string filePath)
        {
            // load from file.
            ConfiguredEndpointCollection endpoints;
            using (Stream stream = File.OpenRead(filePath))
            {
                endpoints = Load(stream);
            }
            endpoints.m_filepath = filePath;

            // remove invalid endpoints and ensure server descriptions are consistent.
            List<ConfiguredEndpoint> endpointsToRemove = new List<ConfiguredEndpoint>();
            Dictionary<string, ApplicationDescription> servers = new Dictionary<string, ApplicationDescription>();

            foreach (ConfiguredEndpoint endpoint in endpoints.m_endpoints)
            {
                if (endpoint.Description == null)
                {
                    endpointsToRemove.Add(endpoint);
                    continue;
                }

                // set a default value for the server.
                if (endpoint.Description.Server == null)
                {
                    endpoint.Description.Server = new ApplicationDescription();
                    endpoint.Description.Server.ApplicationType = ApplicationType.Server;
                }

                // set a default for application uri.
                if (String.IsNullOrEmpty(endpoint.Description.Server.ApplicationUri))
                {
                    endpoint.Description.Server.ApplicationUri = endpoint.Description.EndpointUrl;
                }

                if (endpoint.Description.Server.DiscoveryUrls == null)
                {
                    endpoint.Description.Server.DiscoveryUrls = new StringCollection();
                }

                if (endpoint.Description.Server.DiscoveryUrls.Count == 0)
                {
                    string discoveryUrl = endpoint.Description.EndpointUrl;

                    if (!discoveryUrl.StartsWith(Utils.UriSchemeOpcTcp))
                    {
                        discoveryUrl += "/discovery";
                    }

                    endpoint.Description.Server.DiscoveryUrls.Add(discoveryUrl);
                }

                // normalize transport profile uri.
                if (endpoint.Description.TransportProfileUri != null)
                {
                    endpoint.Description.TransportProfileUri = Profiles.NormalizeUri(endpoint.Description.TransportProfileUri);
                }

                ApplicationDescription server = null;

                if (!servers.TryGetValue(endpoint.Description.Server.ApplicationUri, out server))
                {
                    // use the first description in the file as the correct master.
                    server = endpoint.Description.Server;

                    servers[server.ApplicationUri] = server;

                    // check if the server uri needs to be made globally unique.
                    server.ApplicationUri = Utils.UpdateInstanceUri(server.ApplicationUri);
                    servers[server.ApplicationUri] = server;
                    continue;
                }

                endpoint.Description.Server = (ApplicationDescription)server.MemberwiseClone();


            }

            // remove invalid endpoints.
            foreach (ConfiguredEndpoint endpoint in endpointsToRemove)
            {
                endpoints.Remove(endpoint);
            }

            // return processed collection.
            return endpoints;
        }

        /// <summary>
        /// Loads a collection of endpoints from a stream.
        /// </summary>
        public static ConfiguredEndpointCollection Load(Stream istrm)
        {
            try
            {
                DataContractSerializer serializer = new DataContractSerializer(typeof(ConfiguredEndpointCollection));

                if (serializer.ReadObject(istrm) is ConfiguredEndpointCollection endpoints)
                {
                    foreach (ConfiguredEndpoint endpoint in endpoints)
                    {
                        if (endpoint.Description != null)
                        {
                            endpoint.Description.TransportProfileUri = Profiles.NormalizeUri(endpoint.Description.TransportProfileUri);
                        }
                    }
                }

                return endpoints;
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Unexpected error loading ConfiguredEnpoints.");
                throw;
            }
        }

        /// <summary>
        /// Saves a collection of endpoints the file that it was loaded from.
        /// </summary>
        public void Save()
        {
            Save(m_filepath);
        }

        /// <summary>
        /// Saves a collection of endpoints to a file.
        /// </summary>
        public void Save(string filePath)
        {
            using (Stream stream = File.Open(filePath, FileMode.Create))
            {
                Save(stream);
            }
            m_filepath = filePath;
        }

        /// <summary>
        /// Saves a collection of endpoints to a stream.
        /// </summary>
        public void Save(Stream ostrm)
        {
            DataContractSerializer serializer = new DataContractSerializer(typeof(ConfiguredEndpointCollection));
            serializer.WriteObject(ostrm, this);
        }

        /// <summary>
        /// Returns a deep copy of the collection.
        /// </summary>
        public new object MemberwiseClone()
        {
            ConfiguredEndpointCollection clone = new ConfiguredEndpointCollection();

            clone.m_filepath = m_filepath;
            clone.m_knownHosts = new StringCollection(m_knownHosts);
            clone.m_defaultConfiguration = (EndpointConfiguration)m_defaultConfiguration.MemberwiseClone();

            foreach (ConfiguredEndpoint endpoint in m_endpoints)
            {
                ConfiguredEndpoint clonedEndpoint = (ConfiguredEndpoint)endpoint.MemberwiseClone();
                clonedEndpoint.Collection = clone;
                clone.m_endpoints.Add(clonedEndpoint);
            }

            return clone;
        }

        #region IList<ConfiguredEndpoint> Members
        /// <summary>
        /// Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
        /// </summary>
        /// <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        /// <returns>
        /// The index of <paramref name="item"/> if found in the list; otherwise, -1.
        /// </returns>
        public int IndexOf(ConfiguredEndpoint item)
        {
            for (int ii = 0; ii < m_endpoints.Count; ii++)
            {
                if (object.ReferenceEquals(item, m_endpoints[ii]))
                {
                    return ii;
                }
            }

            return -1;
        }

        /// <summary>
        /// Inserts an item to the <see cref="T:System.Collections.Generic.IList`1"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
        /// <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// 	<paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception>
        /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        public void Insert(int index, ConfiguredEndpoint item)
        {
            Insert(item, index);
        }

        /// <summary>
        /// Removes the <see cref="T:System.Collections.Generic.IList`1"/> item at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the item to remove.</param>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// 	<paramref name="index"/> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception>
        /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        public void RemoveAt(int index)
        {
            if (index < 0 || index >= m_endpoints.Count) throw new ArgumentOutOfRangeException(nameof(index));
            Remove(m_endpoints[index]);
        }

        /// <summary>
        /// Gets or sets the <see cref="Opc.Ua.ConfiguredEndpoint"/> at the specified index.
        /// </summary>
        /// <value>The <see cref="Opc.Ua.ConfiguredEndpoint"/> at the index</value>
        public ConfiguredEndpoint this[int index]
        {
            get
            {
                return m_endpoints[index];
            }

            set
            {
                throw new NotImplementedException();
            }
        }
        #endregion

        #region ICollection<ConfiguredEndpoint> Members
        /// <summary>
        /// Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only. </exception>
        public void Clear()
        {
            this.m_endpoints.Clear();
        }

        /// <summary>
        /// Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
        /// </summary>
        /// <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        /// <returns>
        /// true if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
        /// </returns>
        public bool Contains(ConfiguredEndpoint item)
        {
            for (int ii = 0; ii < m_endpoints.Count; ii++)
            {
                if (object.ReferenceEquals(item, m_endpoints[ii]))
                {
                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// 	<paramref name="array"/> is null.</exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// 	<paramref name="arrayIndex"/> is less than 0.</exception>
        /// <exception cref="T:System.ArgumentException">
        /// 	<paramref name="array"/> is multidimensional.-or-<paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination <paramref name="array"/>./>.</exception>
        public void CopyTo(ConfiguredEndpoint[] array, int arrayIndex)
        {
            m_endpoints.CopyTo(array, arrayIndex);
        }

        /// <summary>
        /// Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
        /// </summary>
        /// <returns>The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
        public int Count => m_endpoints.Count;

        /// <summary>
        /// Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only.
        /// </summary>
        /// <value></value>
        /// <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1"/> is read-only; otherwise, false.</returns>
        public bool IsReadOnly => false;
        #endregion

        #region IEnumerable<ConfiguredEndpoint> Members
        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
        /// </returns>
        public IEnumerator<ConfiguredEndpoint> GetEnumerator()
        {
            return m_endpoints.GetEnumerator();
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Add the endpoint description to the cache.
        /// </summary>
        public ConfiguredEndpoint Add(EndpointDescription endpoint)
        {
            return Add(endpoint, null);
        }

        /// <summary>
        /// Add the endpoint description and configuration to the cache.
        /// </summary>
        public ConfiguredEndpoint Add(EndpointDescription endpoint, EndpointConfiguration configuration)
        {
            ValidateEndpoint(endpoint);

            foreach (ConfiguredEndpoint item in m_endpoints)
            {
                if (Object.ReferenceEquals(item.Description, endpoint))
                {
                    throw new ArgumentException("Endpoint already exists in the collection.");
                }
            }

            ConfiguredEndpoint configuredEndpoint = new ConfiguredEndpoint(this, endpoint, configuration);
            m_endpoints.Add(configuredEndpoint);
            return configuredEndpoint;
        }

        /// <summary>
        /// Adds a previous created endpoint to the collection.
        /// </summary>
        public void Add(ConfiguredEndpoint item)
        {
            Insert(item, -1);
        }

        /// <summary>
        /// Adds a previous created endpoint to the collection.
        /// </summary>
        private void Insert(ConfiguredEndpoint endpoint, int index)
        {
            if (endpoint == null) throw new ArgumentNullException(nameof(endpoint));

            ValidateEndpoint(endpoint.Description);

            // update collection.
            if (endpoint.Collection != null)
            {
                endpoint.Collection.Remove(endpoint);
            }

            endpoint.Collection = this;

            if (!Object.ReferenceEquals(endpoint.Collection, this))
            {
                throw new ArgumentException("Cannot add an endpoint from another collection.");
            }

            if (m_endpoints.Contains(endpoint))
            {
                throw new ArgumentException("Endpoint already belongs to the collection.");
            }

            if (index < 0)
            {
                m_endpoints.Add(endpoint);
            }
            else
            {
                m_endpoints.Insert(index, endpoint);
            }
        }

        /// <summary>
        /// Removes the configured endpoint.
        /// </summary>
        public bool Remove(ConfiguredEndpoint item)
        {
            if (item == null) throw new ArgumentNullException(nameof(item));
            return m_endpoints.Remove(item);
        }

        /// <summary>
        /// Removes all endpoints for the specified server.
        /// </summary>
        public void RemoveServer(string serverUri)
        {
            if (serverUri == null) throw new ArgumentNullException(nameof(serverUri));

            foreach (ConfiguredEndpoint endpointToRemove in GetEndpoints(serverUri))
            {
                Remove(endpointToRemove);
            }
        }

        /// <summary>
        /// Updates the server descrption for the endpoints.
        /// </summary>
        public void SetApplicationDescription(string serverUri, ApplicationDescription server)
        {
            if (server == null) throw new ArgumentNullException(nameof(server));

            if (String.IsNullOrEmpty(server.ApplicationUri))
            {
                throw new ArgumentException("A ServerUri must provided.", nameof(server));
            }

            if (server.DiscoveryUrls.Count == 0)
            {
                throw new ArgumentException("At least one DiscoveryUrl must be provided.", nameof(server));
            }

            List<ConfiguredEndpoint> endpoints = GetEndpoints(server.ApplicationUri);

            // create a placeholder endpoint for the server description.
            if (endpoints.Count == 0)
            {
                string endpointUrl = null;

                for (int ii = 0; ii < server.DiscoveryUrls.Count; ii++)
                {
                    if (!String.IsNullOrEmpty(server.DiscoveryUrls[ii]))
                    {
                        endpointUrl = server.DiscoveryUrls[ii];
                        break;
                    }
                }

                if (endpointUrl != null && endpointUrl.EndsWith("/discovery", StringComparison.Ordinal))
                {
                    endpointUrl = endpointUrl.Substring(0, endpointUrl.Length - "/discovery".Length);
                }

                if (endpointUrl != null)
                {
                    ConfiguredEndpoint endpoint = Create(endpointUrl);
                    endpoint.Description.Server = (ApplicationDescription)server.MemberwiseClone();
                    Add(endpoint);
                }
            }

            // update all endpoints with the same server uri.
            else
            {
                foreach (ConfiguredEndpoint endpointToUpdate in GetEndpoints(serverUri))
                {
                    endpointToUpdate.Description.Server = (ApplicationDescription)server.MemberwiseClone();
                }
            }
        }

        /// <summary>
        /// Creates a new endpoint from a url that is not part of the collection.
        /// </summary>
        /// <remarks>
        /// Call the Add() method to add it to the collection.
        /// </remarks>
        public ConfiguredEndpoint Create(string url)
        {
            // check for security parameters appended to the URL
            string parameters = null;

            int index = url.IndexOf("- [", StringComparison.Ordinal);

            if (index != -1)
            {
                parameters = url.Substring(index + 3);
                url = url.Substring(0, index).Trim();
            }

            MessageSecurityMode securityMode = MessageSecurityMode.SignAndEncrypt;
            string securityPolicyUri = SecurityPolicies.Basic256Sha256;
            bool useBinaryEncoding = true;

            if (!String.IsNullOrEmpty(parameters))
            {
                string[] fields = parameters.Split(new char[] { '-', '[', ':', ']' }, StringSplitOptions.RemoveEmptyEntries);

                try
                {
                    if (fields.Length > 0)
                    {
                        securityMode = (MessageSecurityMode)Enum.Parse(typeof(MessageSecurityMode), fields[0], false);
                    }
                    else
                    {
                        securityMode = MessageSecurityMode.None;
                    }
                }
                catch
                {
                    securityMode = MessageSecurityMode.None;
                }

                try
                {
                    if (fields.Length > 1)
                    {
                        securityPolicyUri = SecurityPolicies.GetUri(fields[1]);
                    }
                    else
                    {
                        securityPolicyUri = SecurityPolicies.None;
                    }
                }
                catch
                {
                    securityPolicyUri = SecurityPolicies.None;
                }

                try
                {
                    if (fields.Length > 2)
                    {
                        useBinaryEncoding = fields[2] == "Binary";
                    }
                    else
                    {
                        useBinaryEncoding = false;
                    }
                }
                catch
                {
                    useBinaryEncoding = false;
                }
            }

            Uri uri = new Uri(url);

            EndpointDescription description = new EndpointDescription();

            description.EndpointUrl = uri.ToString();
            description.SecurityMode = securityMode;
            description.SecurityPolicyUri = securityPolicyUri;
            description.Server.ApplicationUri = Utils.UpdateInstanceUri(uri.ToString());
            description.Server.ApplicationName = uri.AbsolutePath;

            if (description.EndpointUrl.StartsWith(Utils.UriSchemeOpcTcp, StringComparison.Ordinal))
            {
                description.TransportProfileUri = Profiles.UaTcpTransport;
                description.Server.DiscoveryUrls.Add(description.EndpointUrl);
            }
            else if (description.EndpointUrl.StartsWith(Utils.UriSchemeHttps, StringComparison.Ordinal))
            {
                description.TransportProfileUri = Profiles.HttpsBinaryTransport;
                description.Server.DiscoveryUrls.Add(description.EndpointUrl);
            }

            ConfiguredEndpoint endpoint = new ConfiguredEndpoint(this, description, null);
            endpoint.Configuration.UseBinaryEncoding = useBinaryEncoding;
            endpoint.UpdateBeforeConnect = true;
            return endpoint;
        }

        /// <summary>
        /// Returns the configured endpoints for the server uri.
        /// </summary>
        public List<ConfiguredEndpoint> GetEndpoints(string serverUri)
        {
            List<ConfiguredEndpoint> endpoints = new List<ConfiguredEndpoint>();

            foreach (ConfiguredEndpoint endpoint in m_endpoints)
            {
                if (endpoint.Description.Server.ApplicationUri == serverUri)
                {
                    endpoints.Add(endpoint);
                }
            }

            return endpoints;
        }

        /// <summary>
        /// Returns the servers that are part of the collection.
        /// </summary>
        public ApplicationDescriptionCollection GetServers()
        {
            Dictionary<string, ApplicationDescription> servers = new Dictionary<string, ApplicationDescription>();

            foreach (ConfiguredEndpoint endpoint in m_endpoints)
            {
                ApplicationDescription server = endpoint.Description.Server;

                if (!String.IsNullOrEmpty(server.ApplicationUri))
                {
                    if (!servers.ContainsKey(server.ApplicationUri))
                    {
                        servers.Add(server.ApplicationUri, server);
                    }
                }
            }

            return new ApplicationDescriptionCollection(servers.Values);
        }

        /// <summary>
        /// Copies the endpoints.
        /// </summary>
        /// <param name="serverUri">The server URI.</param>
        /// <returns></returns>
        [Obsolete("Non-functional - replaced with GetEndpoints()")]
        public List<ConfiguredEndpoint> CopyEndpoints(string serverUri)
        {
            return null;
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        [Obsolete("Non-functional - method not used - updates should be done with ConfiguredEndpoint.UpdateFromServer()")]
        public void UpdateEndpointsForServer(string serverUri)
        {
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// A list of well known urls that can be used for discovery.
        /// </summary>
        public StringCollection DiscoveryUrls
        {
            get
            {
                return m_discoveryUrls;
            }

            set
            {
                if (value == null)
                {
                    m_discoveryUrls = new StringCollection(Utils.DiscoveryUrls);
                }
                else
                {
                    m_discoveryUrls = value;
                }
            }
        }

        /// <summary>
        /// The default configuration for new ConfiguredEndpoints.
        /// </summary>
        public EndpointConfiguration DefaultConfiguration => m_defaultConfiguration;
        #endregion

        #region Private Methods
        /// <summary>
        /// Throws exceptions if the endpoint is not valid.
        /// </summary>
        private static void ValidateEndpoint(EndpointDescription endpoint)
        {
            if (endpoint == null)
            {
                throw new ArgumentException("Endpoint must not be null.");
            }

            if (String.IsNullOrEmpty(endpoint.EndpointUrl))
            {
                throw new ArgumentException("Endpoint must have a valid URL.");
            }

            if (endpoint.Server == null)
            {
                endpoint.Server = new ApplicationDescription();
                endpoint.Server.ApplicationType = ApplicationType.Server;
            }

            if (String.IsNullOrEmpty(endpoint.Server.ApplicationUri))
            {
                endpoint.Server.ApplicationUri = endpoint.EndpointUrl;
            }
        }
        #endregion
    }

    #region ConfiguredEndpoint Class
    /// <summary>
    /// Stores the configuration information for an endpoint.
    /// </summary>
    public partial class ConfiguredEndpoint : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Creates a configured endpoint from the server description.
        /// </summary>
        public ConfiguredEndpoint(
            ApplicationDescription server,
            EndpointConfiguration configuration)
        {
            if (server == null) throw new ArgumentNullException(nameof(server));

            m_description = new EndpointDescription();
            m_updateBeforeConnect = true;

            m_description.Server = server;

            foreach (string discoveryUrl in server.DiscoveryUrls)
            {
                string baseUrl = discoveryUrl;

                if (baseUrl != null)
                {
                    if (baseUrl.EndsWith("/discovery", StringComparison.Ordinal))
                    {
                        baseUrl = baseUrl.Substring(0, baseUrl.Length - "/discovery".Length);
                    }
                }

                Uri url = Utils.ParseUri(baseUrl);

                if (url != null)
                {
                    m_description.EndpointUrl = url.ToString();
                    m_description.SecurityMode = MessageSecurityMode.SignAndEncrypt;
                    m_description.SecurityPolicyUri = SecurityPolicies.Basic256Sha256;
                    m_description.UserIdentityTokens.Add(new UserTokenPolicy(UserTokenType.Anonymous));

                    if (url.Scheme == Utils.UriSchemeHttps)
                    {
                        m_description.TransportProfileUri = Profiles.HttpsBinaryTransport;
                    }

                    if (url.Scheme == Utils.UriSchemeOpcTcp)
                    {
                        m_description.TransportProfileUri = Profiles.UaTcpTransport;
                    }

                    break;
                }
            }

            // ensure a default configuration.
            if (configuration == null)
            {
                configuration = EndpointConfiguration.Create();
            }

            Update(configuration);
        }

        /// <summary>
        /// The default constructor.
        /// </summary>
        public ConfiguredEndpoint(
            ConfiguredEndpointCollection collection,
            EndpointDescription description)
        :
            this(collection, description, null)
        {
        }

        /// <summary>
        /// The default constructor.
        /// </summary>
        public ConfiguredEndpoint(
            ConfiguredEndpointCollection collection,
            EndpointDescription description,
            EndpointConfiguration configuration)
        {
            if (description == null) throw new ArgumentNullException(nameof(description));

            m_collection = collection;
            m_description = description;
            m_updateBeforeConnect = true;

            // ensure a default configuration.
            if (configuration == null)
            {
                if (collection != null)
                {
                    configuration = collection.DefaultConfiguration;
                }
                else
                {
                    configuration = EndpointConfiguration.Create();
                }
            }

            Update(configuration);
        }
        #endregion

        /// <summary>
        /// Returns a deep copy of the endpoint.
        /// </summary>
        public new object MemberwiseClone()
        {
            ConfiguredEndpoint clone = new ConfiguredEndpoint();
            clone.Collection = this.Collection;
            clone.Update(this);
            return clone;
        }

        #region Overridden Methods
        /// <summary>
        /// Returns the string representation of the object.
        /// </summary>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        #region IFormattable Members
        /// <summary>
        /// Returns the string representation of the object.
        /// </summary>
        /// <param name="format">(Unused). Always pass NULL/NOTHING</param>
        /// <param name="formatProvider">(Unused). Always pass NULL/NOTHING</param>
        /// <exception cref="FormatException">Thrown if non-null parameters are used</exception>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                return Utils.Format(
                    "{0} - [{1}:{2}:{3}]",
                    m_description.EndpointUrl,
                    m_description.SecurityMode,
                    SecurityPolicies.GetDisplayName(m_description.SecurityPolicyUri),
                    (m_configuration != null && m_configuration.UseBinaryEncoding) ? "Binary" : "XML");
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Determine if an update of the endpoint from the server is needed.
        /// </summary>
        public bool NeedUpdateFromServer()
        {
            bool hasCertificate = (Description.ServerCertificate != null && Description.ServerCertificate.Length > 0);
            bool usingUserTokenSecurity =
                (SelectedUserTokenPolicy.TokenType != UserTokenType.Anonymous) &&
                (SelectedUserTokenPolicy.SecurityPolicyUri ?? SecurityPolicies.None) != SecurityPolicies.None;
            bool usingTransportSecurity = Description.SecurityPolicyUri != SecurityPolicies.None;
            return (usingUserTokenSecurity || usingTransportSecurity) && !hasCertificate;
        }

        /// <summary>
        /// Updates the endpoint description.
        /// </summary>
        public void Update(ConfiguredEndpoint endpoint)
        {
            if (endpoint == null) throw new ArgumentNullException(nameof(endpoint));

            m_description = (EndpointDescription)endpoint.Description.MemberwiseClone();
            m_configuration = (EndpointConfiguration)endpoint.Configuration.MemberwiseClone();

            // normalize transport profile uri.
            if (m_description.TransportProfileUri != null)
            {
                m_description.TransportProfileUri = Profiles.NormalizeUri(m_description.TransportProfileUri);
            }

            m_updateBeforeConnect = endpoint.m_updateBeforeConnect;
            m_selectedUserTokenPolicyIndex = endpoint.m_selectedUserTokenPolicyIndex;
            m_binaryEncodingSupport = endpoint.m_binaryEncodingSupport;

            if (endpoint.m_userIdentity != null)
            {
                m_userIdentity = (UserIdentityToken)endpoint.m_userIdentity.MemberwiseClone();
            }
        }

        /// <summary>
        /// Updates the endpoint description.
        /// </summary>
        public void Update(EndpointDescription description)
        {
            if (description == null) throw new ArgumentNullException(nameof(description));

            m_description = (EndpointDescription)description.MemberwiseClone();

            // normalize transport profile uri.
            if (m_description.TransportProfileUri != null)
            {
                m_description.TransportProfileUri = Profiles.NormalizeUri(m_description.TransportProfileUri);
            }

            // set the proxy url.
            if (m_collection != null && m_description.EndpointUrl != null)
            {
                if (m_description.EndpointUrl.StartsWith(Utils.UriSchemeOpcTcp, StringComparison.Ordinal))
                {
                    m_description.ProxyUrl = m_collection.TcpProxyUrl;
                }
            }
        }

        /// <summary>
        /// Updates the endpoint configuration.
        /// </summary>
        public void Update(EndpointConfiguration configuration)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));

            m_configuration = (EndpointConfiguration)configuration.MemberwiseClone();

            BinaryEncodingSupport binaryEncodingSupport = m_description.EncodingSupport;

            // check if the configuration restricts the encoding if the endpoint supports both.
            if (binaryEncodingSupport == BinaryEncodingSupport.Optional)
            {
                binaryEncodingSupport = m_binaryEncodingSupport;
            }

            if (binaryEncodingSupport == BinaryEncodingSupport.None)
            {
                m_configuration.UseBinaryEncoding = false;
            }

            if (binaryEncodingSupport == BinaryEncodingSupport.Required)
            {
                m_configuration.UseBinaryEncoding = true;
            }
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public void UpdateFromServer()
        {
            UpdateFromServer(EndpointUrl, m_description.SecurityMode, m_description.SecurityPolicyUri);
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public void UpdateFromServer(
            Uri endpointUrl,
            MessageSecurityMode securityMode,
            string securityPolicyUri)
        {
            UpdateFromServer(endpointUrl, null, securityMode, securityPolicyUri);
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public void UpdateFromServer(
            Uri endpointUrl,
            ITransportWaitingConnection connection,
            MessageSecurityMode securityMode,
            string securityPolicyUri)
        {
            // get the a discovery url.
            Uri discoveryUrl = GetDiscoveryUrl(endpointUrl);

            // create the discovery client.
            DiscoveryClient client;
            if (connection != null)
            {
                client = DiscoveryClient.Create(connection, m_configuration);
            }
            else
            {
                client = DiscoveryClient.Create(discoveryUrl, m_configuration);
            }

            try
            {
                // get the endpoints.
                EndpointDescriptionCollection collection = client.GetEndpoints(null);

                // find list of matching endpoints.
                var matches = MatchEndpoints(
                    collection,
                    endpointUrl,
                    securityMode,
                    securityPolicyUri
                    );

                // select best match
                var match = SelectBestMatch(matches, discoveryUrl);

                // update the endpoint.                        
                Update(match);
            }
            finally
            {
                client.Close();
            }
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public Task UpdateFromServerAsync()
        {
            return UpdateFromServerAsync(EndpointUrl, m_description.SecurityMode, m_description.SecurityPolicyUri);
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public Task UpdateFromServerAsync(
            Uri endpointUrl,
            MessageSecurityMode securityMode,
            string securityPolicyUri)
        {
            return UpdateFromServerAsync(endpointUrl, null, securityMode, securityPolicyUri);
        }

        /// <summary>
        /// Updates an endpoint with information from the server's discovery endpoint.
        /// </summary>
        public async Task UpdateFromServerAsync(
            Uri endpointUrl,
            ITransportWaitingConnection connection,
            MessageSecurityMode securityMode,
            string securityPolicyUri)
        {
            // get the a discovery url.
            Uri discoveryUrl = GetDiscoveryUrl(endpointUrl);

            // create the discovery client.
            DiscoveryClient client;
            if (connection != null)
            {
                client = DiscoveryClient.Create(connection, m_configuration);
            }
            else
            {
                client = DiscoveryClient.Create(discoveryUrl, m_configuration);
            }

            try
            {
                // get the endpoints.
                EndpointDescriptionCollection collection = await client.GetEndpointsAsync(null);

                // find list of matching endpoints.
                var matches = MatchEndpoints(
                    collection,
                    endpointUrl,
                    securityMode,
                    securityPolicyUri
                    );

                // select best match
                var match = SelectBestMatch(matches, discoveryUrl);

                // update the endpoint.                        
                Update(match);
            }
            finally
            {
                client.Close();
            }
        }

        /// <summary>
        /// Returns a discovery url that can be used to update the endpoint description.
        /// </summary>
        public Uri GetDiscoveryUrl(Uri endpointUrl)
        {
            // update the endpoint description.
            if (endpointUrl != null)
            {
                m_description.EndpointUrl = endpointUrl.ToString();
            }
            else
            {
                endpointUrl = Utils.ParseUri(m_description.EndpointUrl);
            }

            // get the know discovery URLs.
            StringCollection discoveryUrls = null;

            if (m_description.Server != null)
            {
                discoveryUrls = m_description.Server.DiscoveryUrls;
            }

            // attempt to construct a discovery url by appending 'discovery' to the endpoint.
            if (discoveryUrls == null || discoveryUrls.Count == 0)
            {
                if (endpointUrl.Scheme != Utils.UriSchemeOpcTcp)
                {
                    return new Uri(String.Format(CultureInfo.InvariantCulture, "{0}/discovery", endpointUrl));
                }
                else
                {
                    return endpointUrl;
                }
            }

            // choose the URL that uses the same protocol if one exists.
            for (int ii = 1; ii < discoveryUrls.Count; ii++)
            {
                if (discoveryUrls[ii].StartsWith(endpointUrl.Scheme, StringComparison.Ordinal))
                {
                    return Utils.ParseUri(discoveryUrls[ii]);
                }
            }

            // return the first in the list.
            return Utils.ParseUri(discoveryUrls[0]);
        }

        /// <summary>
        /// Parses the extension.
        /// </summary>
        /// <typeparam name="T">The type of extension.</typeparam>
        /// <param name="elementName">Name of the element (null means use type name).</param>
        /// <returns>The extension if found. Null otherwise.</returns>
        public T ParseExtension<T>(XmlQualifiedName elementName)
        {
            return Utils.ParseExtension<T>(m_extensions, elementName);
        }

        /// <summary>
        /// Updates the extension.
        /// </summary>
        /// <typeparam name="T">The type of extension.</typeparam>
        /// <param name="elementName">Name of the element (null means use type name).</param>
        /// <param name="value">The value.</param>
        public void UpdateExtension<T>(XmlQualifiedName elementName, object value)
        {
            Utils.UpdateExtension<T>(ref m_extensions, elementName, value);
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// The collection that the endpoint belongs to. 
        /// </summary>
        public ConfiguredEndpointCollection Collection
        {
            get
            {
                return m_collection;
            }

            internal set
            {
                if (value == null) throw new ArgumentNullException(nameof(value));
                m_collection = value;
            }
        }

        /// <summary>
        /// The URL used to create a sessions.
        /// </summary>
        public Uri EndpointUrl
        {
            get
            {
                if (String.IsNullOrEmpty(m_description.EndpointUrl))
                {
                    return null;
                }

                return Utils.ParseUri(m_description.EndpointUrl);
            }

            set
            {
                if (value == null)
                {
                    m_description.EndpointUrl = null;
                }

                m_description.EndpointUrl = String.Format(CultureInfo.InvariantCulture, "{0}", value);
            }
        }

        /// <summary>
        /// The user identity to use when connecting to the endpoint.
        /// </summary>
        public UserTokenPolicy SelectedUserTokenPolicy
        {
            get
            {
                if (m_description != null && m_description.UserIdentityTokens != null)
                {
                    UserTokenPolicyCollection policies = m_description.UserIdentityTokens;

                    if (m_selectedUserTokenPolicyIndex >= 0 && policies.Count > m_selectedUserTokenPolicyIndex)
                    {
                        return policies[m_selectedUserTokenPolicyIndex];
                    }
                }

                return null;
            }

            set
            {
                if (m_description != null && m_description.UserIdentityTokens != null)
                {
                    UserTokenPolicyCollection policies = m_description.UserIdentityTokens;

                    for (int ii = 0; ii < policies.Count; ii++)
                    {
                        if (Object.ReferenceEquals(policies[ii], value))
                        {
                            m_selectedUserTokenPolicyIndex = ii;
                            break;
                        }
                    }
                }

                m_selectedUserTokenPolicyIndex = -1;
            }
        }
        #endregion

        #region Private Methods
        private EndpointDescriptionCollection MatchEndpoints(
            EndpointDescriptionCollection collection,
            Uri endpointUrl,
            MessageSecurityMode securityMode,
            string securityPolicyUri)
        {
            if (collection == null || collection.Count == 0)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadUnknownResponse,
                    "Server does not have any endpoints defined.");
            }

            // find list of matching endpoints.
            EndpointDescriptionCollection matches = new EndpointDescriptionCollection();

            // first pass - match on the requested security parameters.
            foreach (EndpointDescription description in collection)
            {
                // check for match on security policy.
                if (!String.IsNullOrEmpty(securityPolicyUri))
                {
                    if (securityPolicyUri != description.SecurityPolicyUri)
                    {
                        continue;
                    }
                }

                // check for match on security mode.
                if (securityMode != MessageSecurityMode.Invalid)
                {
                    if (securityMode != description.SecurityMode)
                    {
                        continue;
                    }
                }

                // add to list of matches.
                matches.Add(description);
            }

            // no matches (security parameters may have changed).
            if (matches.Count == 0)
            {
                matches = collection;
            }

            // check if list has to be narrowed down further.
            if (matches.Count > 1)
            {
                collection = matches;
                matches = new EndpointDescriptionCollection();

                // second pass - match on the url scheme.
                foreach (EndpointDescription description in collection)
                {
                    // parse the endpoint url.
                    Uri sessionUrl = Utils.ParseUri(description.EndpointUrl);

                    if (sessionUrl == null)
                    {
                        continue;
                    }

                    // check for matching protocol.
                    if (sessionUrl.Scheme != endpointUrl.Scheme)
                    {
                        continue;
                    }

                    matches.Add(description);
                }
            }

            // no matches (protocol may not be supported).
            if (matches.Count == 0)
            {
                matches = collection;
            }

            return matches;
        }

        /// <summary>
        /// Select the best match from a security description.
        /// </summary>
        private EndpointDescription SelectBestMatch(
            EndpointDescriptionCollection matches,
            Uri discoveryUrl
            )
        {
            // choose first in list by default.
            EndpointDescription match = matches[0];

            // check if list has to be narrowed down further.
            if (matches.Count > 1)
            {
                // third pass - match based on security level.
                foreach (EndpointDescription description in matches)
                {
                    if (description.SecurityLevel > match.SecurityLevel)
                    {
                        match = description;
                    }
                }
            }

            // check if the endpoint url matches the endpoint used in the request.
            if (discoveryUrl != null)
            {
                Uri matchUrl = Utils.ParseUri(match.EndpointUrl);
                if (matchUrl == null || String.Compare(discoveryUrl.DnsSafeHost, matchUrl.DnsSafeHost, StringComparison.OrdinalIgnoreCase) != 0)
                {
                    UriBuilder uri = new UriBuilder(matchUrl);
                    uri.Host = discoveryUrl.DnsSafeHost;
                    uri.Port = discoveryUrl.Port;
                    match.EndpointUrl = uri.ToString();

                    // need to update the discovery urls.
                    match.Server.DiscoveryUrls.Clear();
                    match.Server.DiscoveryUrls.Add(discoveryUrl.ToString());
                }
            }

            return match;
        }
        #endregion
    }
    #endregion
}
#endregion

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\Configuration\ConfiguredEndpoints.cs(196,24): error CS0165: Use of unassigned local variable 'endpoints'
######################################################################


######################################################################
Nr: 13 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\ContentFilter.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua
{
    #region ContentFilter Class
    public partial class ContentFilter: IFormattable
    {
        #region IFormattable Members
        /// <summary>
        /// Formats the value of the current instance using the specified format.
        /// </summary>
        /// <param name="format">The <see cref="T:System.String"/> specifying the format to use.
        /// -or-
        /// null to use the default format defined for the type of the <see cref="T:System.IFormattable"/> implementation.</param>
        /// <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.
        /// -or-
        /// null to obtain the numeric format information from the current locale setting of the operating system.</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                StringBuilder buffer = new StringBuilder();

                for (int ii = 0; ii < this.Elements.Count; ii++)
                {
                    buffer.AppendFormat(formatProvider, "[{0}:{1}]", ii, this.Elements[ii]);
                }

                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion
    
        /// <summary>
        /// Validates the ContentFilter.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <returns>The result of validation.</returns>
        public Result Validate(FilterContext context)
        {
            Result result = new Result(null);
            
            // check for empty filter.
            if (m_elements == null || m_elements.Count == 0)
            {
                return result;
            }            

            bool error = false;

            for (int ii = 0; ii < m_elements.Count; ii++)
            {
                ContentFilterElement element = m_elements[ii];
                
                // check for null.
                if (element == null)
                {
                    ServiceResult nullResult = ServiceResult.Create(
                        StatusCodes.BadStructureMissing, 
                        "ContentFilterElement is null (Index={0}).",
                        ii);

                    result.ElementResults.Add(new ElementResult(nullResult));
                    error = true;
                    continue;
                }
                
                element.Parent = this;

                // validate element.
                ElementResult elementResult = element.Validate(context, ii);

                if (ServiceResult.IsBad(elementResult.Status))
                {
                    result.ElementResults.Add(elementResult);
                    error = true;
                    continue;
                }

                result.ElementResults.Add(null);
            }
            
            // ensure the global error code.
            if (error)
            {
                result.Status = StatusCodes.BadContentFilterInvalid;
            }
            else
            {
                result.ElementResults.Clear();
            }

            return result;
        }
        
        /// <summary>
        /// Pushes a new element onto the stack.
        /// </summary>
        /// <param name="op">The filter operator.</param>
        /// <param name="operands">The operands.</param>
        /// <returns></returns>
        public ContentFilterElement Push(FilterOperator op, params object[] operands)
        { 
            // check if nothing more to do.
            if (operands == null || operands.Length == 0)
            {                        
                throw ServiceResultException.Create(StatusCodes.BadInvalidArgument, "ContentFilterElement does not have an operands.");
            }
            
            // create the element and set the operator.
            ContentFilterElement element = new ContentFilterElement();            
            element.FilterOperator = op;
            
            for (int ii = 0; ii < operands.Length; ii++)
            {
                // check if a FilterOperand was provided.
                FilterOperand filterOperand = operands[ii] as FilterOperand;
                
                if (filterOperand != null)
                {
                    element.FilterOperands.Add(new ExtensionObject(filterOperand));
                    continue;
                }
                
                // check for reference to another ContentFilterElement.
                ContentFilterElement existingElement = operands[ii] as ContentFilterElement;

                if (existingElement != null)
                {
                    int index = FindElementIndex(existingElement);

                    if (index == -1)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadInvalidArgument, "ContentFilterElement is not part of the ContentFilter.");
                    }

                    ElementOperand operand = new ElementOperand();
                    operand.Index = (uint)index;

                    element.FilterOperands.Add(new ExtensionObject(operand));
                    continue;
                }

                // assume a literal operand.
                LiteralOperand literalOperand = new LiteralOperand();
                literalOperand.Value = new Variant(operands[ii]);
                element.FilterOperands.Add(new ExtensionObject(literalOperand));
            }

            // insert the new element at the begining of the list.
            m_elements.Insert(0, element);

            // re-number ElementOperands since all element were shifted up.
            for (int ii = 0; ii < m_elements.Count; ii++)
            {
                foreach (ExtensionObject extension in m_elements[ii].FilterOperands)
                {
                    if (extension != null)
                    {
                        ElementOperand operand = extension.Body as ElementOperand;

                        if (operand != null)
                        {
                            operand.Index++;
                        }
                    }                
                }
            }

            // return new element.
            return element;
        }

        /// <summary>
        /// Finds the index of the specified element.
        /// </summary>
        /// <param name="target">The targetto be found.</param>
        /// <returns>The index of the specified element.</returns>
        private int FindElementIndex(ContentFilterElement target)
        {
            for (int ii = 0; ii < m_elements.Count; ii++)
            {
                if (Object.ReferenceEquals(target, m_elements[ii]))
                {
                    return ii;
                }
            }

            return -1;
        }
        
        #region Result Class
        /// <summary>
        /// Stores the validation results for a ContentFilterElement.
        /// </summary>
        public class Result
        {
            #region Public Interface
            /// <summary>
            /// Initializes the object with a result code.
            /// </summary>
            /// <param name="status">The status.</param>
            public Result(ServiceResult status)
            {
                m_status = status;
            }

            /// <summary>
            /// Casts ServiceResult to an ElementResult.
            /// </summary>
            /// <param name="status">The status.</param>
            /// <returns>The result of the conversion.</returns>
            public static implicit operator Result(ServiceResult status)
            {
                return new Result(status);
            }
            
            /// <summary>
            /// The result for the entire filter.
            /// </summary>
            /// <value>The status.</value>
            public ServiceResult Status
            {
                get { return m_status;  }
                set { m_status = value; }
            }
                     
            /// <summary>
            /// The result for each element.
            /// </summary>
            /// <value>The element results.</value>
            public List<ElementResult> ElementResults
            {
                get
                {
                    if (m_elementResults == null)
                    {
                        m_elementResults = new List<ElementResult>();
                    }

                    return m_elementResults;
                }
            }

            /// <summary>
            /// Converts the object to an ContentFilterResult.
            /// </summary>
            /// <param name="diagnosticsMasks">The diagnostics masks.</param>
            /// <param name="stringTable">The string table.</param>
            /// <returns></returns>
            public ContentFilterResult ToContextFilterResult(DiagnosticsMasks diagnosticsMasks, StringTable stringTable)
            {
                ContentFilterResult result = new ContentFilterResult();

                if (m_elementResults == null || m_elementResults.Count == 0)
                {
                    return result;
                }

                bool error = false;

                foreach (ElementResult elementResult in m_elementResults)
                {
                    ContentFilterElementResult elementResult2 = null;
                                        
                    if (elementResult == null || ServiceResult.IsGood(elementResult.Status))
                    {
                        elementResult2 = new ContentFilterElementResult();
                        elementResult2.StatusCode = StatusCodes.Good;

                        result.ElementResults.Add(elementResult2);
                        result.ElementDiagnosticInfos.Add(null);
                        continue;
                    }

                    error = true;
                                        
                    elementResult2 = elementResult.ToContentFilterElementResult(diagnosticsMasks, stringTable);
                    result.ElementResults.Add(elementResult2);
                    result.ElementDiagnosticInfos.Add(new DiagnosticInfo(elementResult.Status, diagnosticsMasks, false, stringTable));
                }

                if (!error)
                {
                    result.ElementResults.Clear();
                    result.ElementDiagnosticInfos.Clear();
                }
                    
                return result;
            }
            #endregion
            
            #region Private Fields
            private ServiceResult m_status;
            private List<ElementResult> m_elementResults;
            #endregion
        }
        #endregion
        
        #region ElementResult Class
        /// <summary>
        /// Stores the validation results for a ContentFilterElement.
        /// </summary>
        public class ElementResult
        {
            #region Public Interface
            /// <summary>
            /// Initializes the object with a result code.
            /// </summary>
            /// <param name="status">The status.</param>
            public ElementResult(ServiceResult status)
            {
                m_status = status;
            }

            /// <summary>
            /// Casts ServiceResult to an ElementResult.
            /// </summary>
            /// <param name="status">The status.</param>
            /// <returns>The result of the conversion.</returns>
            public static implicit operator ElementResult(ServiceResult status)
            {
                return new ElementResult(status);
            }
            
            /// <summary>
            /// The result for the entire element.
            /// </summary>
            /// <value>The status.</value>
            public ServiceResult Status
            {
                get { return m_status;  }
                set { m_status = value; }
            }
                     
            /// <summary>
            /// The result for each operand.
            /// </summary>
            /// <value>The operand results.</value>
            public List<ServiceResult> OperandResults
            {
                get
                {
                    if (m_operandResults == null)
                    {
                        m_operandResults = new List<ServiceResult>();
                    }

                    return m_operandResults;
                }
            }
            
            /// <summary>
            /// Converts the object to an ContentFilterElementResult.
            /// </summary>
            /// <param name="diagnosticsMasks">The diagnostics masks.</param>
            /// <param name="stringTable">The string table.</param>
            /// <returns></returns>
            public ContentFilterElementResult ToContentFilterElementResult(DiagnosticsMasks diagnosticsMasks, StringTable stringTable)
            {
                ContentFilterElementResult result = new ContentFilterElementResult();

                if (ServiceResult.IsGood(m_status))
                {
                    result.StatusCode = StatusCodes.Good;
                    return result;
                }
                
                result.StatusCode = m_status.StatusCode;

                if (m_operandResults.Count == 0)
                {
                    return result;
                }

                foreach (ServiceResult operandResult in m_operandResults)
                {
                    if (ServiceResult.IsGood(operandResult))
                    {
                        result.OperandStatusCodes.Add(StatusCodes.Good);
                        result.OperandDiagnosticInfos.Add(null);
                    }
                    else
                    { 
                        result.OperandStatusCodes.Add(operandResult.StatusCode);                                    
                        result.OperandDiagnosticInfos.Add(new DiagnosticInfo(operandResult, diagnosticsMasks, false, stringTable));

                    }                                        
                }

                return result;
            }
            #endregion
            
            #region Private Fields
            private ServiceResult m_status;
            private List<ServiceResult> m_operandResults;
            #endregion
        }
        #endregion
    }
    #endregion

    #region ContentFilterElement Class
    public partial class ContentFilterElement : IFormattable
    {
        #region IFormattable Members
        /// <summary>
        /// Formats the value of the current instance using the specified format.
        /// </summary>
        /// <param name="format">The <see cref="T:System.String"/> specifying the format to use.
        /// -or-
        /// null to use the default format defined for the type of the <see cref="T:System.IFormattable"/> implementation.</param>
        /// <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.
        /// -or-
        /// null to obtain the numeric format information from the current locale setting of the operating system.</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                StringBuilder buffer = new StringBuilder();

                buffer.AppendFormat(formatProvider, "<{0}", this.FilterOperator);

                for (int ii = 0; ii < this.FilterOperands.Count; ii++)
                {
                    if (this.FilterOperands[ii] != null)
                    {
                        buffer.AppendFormat(formatProvider, ", {0}", this.FilterOperands[ii].Body);
                    }
                    else
                    {
                        buffer.AppendFormat(formatProvider, ", (null)");
                    }
                }

                buffer.AppendFormat(formatProvider, ">");

                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The ContentFilter that this Element is part of.
        /// </summary>
        /// <value>The parent.</value>
        public ContentFilter Parent
        {
            get { return m_parent; }
            internal set { this.m_parent = value; }
        } 

        /// <summary>
        /// Validates the content filter element.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="index">The index.</param>
        /// <returns>The results of the validation.</returns>
        public virtual ContentFilter.ElementResult Validate(FilterContext context, int index)
        {
            ContentFilter.ElementResult result = new ContentFilter.ElementResult(null);

            // check the number of operands.
            int operandCount = -1;

            switch (m_filterOperator)
            {
                case FilterOperator.Not:
                case FilterOperator.IsNull:
                case FilterOperator.InView:
                case FilterOperator.OfType:
                {
                    operandCount = 1;
                    break;
                }

                case FilterOperator.And:
                case FilterOperator.Or:
                case FilterOperator.Equals:
                case FilterOperator.GreaterThan:
                case FilterOperator.GreaterThanOrEqual:
                case FilterOperator.LessThan:
                case FilterOperator.LessThanOrEqual:
                case FilterOperator.Like:
                case FilterOperator.Cast:
                {
                    operandCount = 2;
                    break;
                }

                case FilterOperator.Between:
                {
                    operandCount = 3;
                    break;
                }

                case FilterOperator.RelatedTo:
                {
                    operandCount = 6;
                    break;
                }

                case FilterOperator.InList:
                {
                    operandCount = -1;
                    break;
                }

                default:
                {
                    break;
                }
            }

            if (operandCount != -1)
            {
                if (operandCount != m_filterOperands.Count)
                {                    
                    result.Status = ServiceResult.Create(
                        StatusCodes.BadEventFilterInvalid, 
                        "ContentFilterElement does not have the correct number of operands (Operator={0} OperandCount={1}).", 
                        m_filterOperator,
                        operandCount);

                    return result;
                }
            }
            else
            {
                if (m_filterOperands.Count < 2)
                {                    
                    result.Status = ServiceResult.Create(
                        StatusCodes.BadEventFilterInvalid, 
                        "ContentFilterElement does not have the correct number of operands (Operator={0} OperandCount={1}).", 
                        m_filterOperator,
                        m_filterOperands.Count);

                    return result;
                }
            }

            // validate the operands.
            bool error = false;

            for (int ii = 0; ii < m_filterOperands.Count; ii++)
            {
                ServiceResult operandResult = null;

                ExtensionObject operand = m_filterOperands[ii];
                
                // check for null.
                if (ExtensionObject.IsNull(operand))
                {
                    operandResult = ServiceResult.Create(
                        StatusCodes.BadEventFilterInvalid,
                        "The FilterOperand cannot be Null.");
                
                    result.OperandResults.Add(operandResult);
                    error = true;
                    continue;
                }            
                
                // check that the extension object contains a filter operand.
                FilterOperand filterOperand = operand.Body  as FilterOperand;

                if (filterOperand == null)
                {
                    operandResult = ServiceResult.Create(
                        StatusCodes.BadEventFilterInvalid,
                        "The FilterOperand is not a supported type ({0}).",
                        operand.Body.GetType());

                    result.OperandResults.Add(operandResult);
                    error = true;
                    continue;
                }

                // validate the operand.
                filterOperand.Parent = this;
                operandResult = filterOperand.Validate(context, index);

                if (ServiceResult.IsBad(operandResult))
                {
                    result.OperandResults.Add(operandResult);
                    error = true;
                    continue;
                }

                result.OperandResults.Add(null);
            }
            
            // ensure the global error code.
            if (error)
            {
                result.Status = StatusCodes.BadContentFilterInvalid;
            }
            else
            {
                result.OperandResults.Clear();
            }

            return result;
        }

        /// <summary>
        /// Returns the operands for the element.
        /// </summary>
        /// <returns>The list of operands for the element.</returns>
        public List<FilterOperand> GetOperands()
        {
            List<FilterOperand> operands = new List<FilterOperand>(FilterOperands.Count); 

            foreach (ExtensionObject extension in FilterOperands)
            {
                if (ExtensionObject.IsNull(extension))
                {
                    continue;
                }

                FilterOperand operand = extension.Body as FilterOperand;

                if (operand == null)
                {
                    continue;
                }
               
                operands.Add(operand);
            }

            return operands;
        }
        
        /// <summary>
        /// Sets the operands for the element.
        /// </summary>
        /// <param name="operands">The list of the operands.</param>
        public void SetOperands(IEnumerable<FilterOperand> operands)
        {
            FilterOperands.Clear();

            if (operands == null)
            {
                return;
            }

            foreach (FilterOperand operand in operands)
            {
                if (operand == null)
                {
                    continue;
                }

                FilterOperands.Add(new ExtensionObject(operand));
            }
        }

        /// <summary>
        /// Converts an ContentFilterElement to a displayable string.
        /// </summary>
        /// <param name="nodeTable">The node table.</param>
        /// <returns>ContentFilterElement as a displayable string.</returns>
        public virtual string ToString(INodeTable nodeTable)
        {
            List<FilterOperand> operands = GetOperands();

            string operand1 = (operands.Count > 0)?operands[0].ToString(nodeTable):null;
            string operand2 = (operands.Count > 1)?operands[1].ToString(nodeTable):null;
            string operand3 = (operands.Count > 2)?operands[2].ToString(nodeTable):null;

            StringBuilder buffer = new StringBuilder();

            switch (FilterOperator)
            {
                case FilterOperator.OfType:
                case FilterOperator.InView:
                case FilterOperator.IsNull:
                case FilterOperator.Not:
                {
                    buffer.AppendFormat("{0} '{1}'", FilterOperator, operand1);
                    break;
                }
                    
                case FilterOperator.And:
                case FilterOperator.Equals:
                case FilterOperator.GreaterThan:
                case FilterOperator.GreaterThanOrEqual:
                case FilterOperator.LessThan:
                case FilterOperator.LessThanOrEqual:
                case FilterOperator.Like:
                case FilterOperator.Or:
                {
                    buffer.AppendFormat("'{1}' {0} '{2}'", FilterOperator, operand1, operand2);
                    break;
                }
                    
                case FilterOperator.Between:
                {
                    buffer.AppendFormat("'{1}' <= '{0}' <= '{2}'", operand1, operand2, operand3);
                    break;
                }
                    
                case FilterOperator.Cast:
                {
                    buffer.AppendFormat("({1}){0}", operand1, operand2);
                    break;
                }
                    
                case FilterOperator.InList:
                {
                    buffer.AppendFormat("'{0}' in {", operand1);

                    for (int ii = 1; ii < operands.Count; ii++)
                    {
                        if (ii < operands.Count-1)
                        {
                            buffer.Append(", ");
                        }

                        buffer.AppendFormat("'{0}'", operands[ii].ToString());
                    }
                            
                    buffer.Append("}");
                    break;
                }
                    
                case FilterOperator.RelatedTo:
                {
                    buffer.AppendFormat("'{0}' ", operand1);
                    
                    string referenceType = operand2;

                    if (operands.Count > 1)
                    {
                        LiteralOperand literalOperand = operands[1] as LiteralOperand;

                        if (literalOperand != null)
                        {
                            INode node = nodeTable.Find(literalOperand.Value.Value as NodeId);

                            if (node != null)
                            {
                                referenceType = Utils.Format("{0}", node);
                            }
                        }
                    }
                    
                    buffer.AppendFormat("{0} '{1}'", referenceType, operand2);

                    if (operand3 != null)
                    {
                        buffer.AppendFormat("Hops='{0}'", operand3);
                    }

                    break;
                }
            }

            return buffer.ToString();
        }
        #endregion

        #region Private Fields
        private ContentFilter m_parent;
        #endregion
    }
    #endregion

    #region FilterOperand Class
    public partial class FilterOperand
    {
        #region Public Interface
        /// <summary>
        /// The ContentFilterElement this FilterOperand is contained in.
        /// The ContentFilterElement contains the operator and the operands
        /// so it defines the expression to be evaluated.
        /// </summary>
        /// <value>The parent element.</value>
        public ContentFilterElement Parent
        {
            get { return this.m_parent; }
            internal set { this.m_parent = value; }
        }

        /// <summary>
        /// Validates the operand.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="index">The index.</param>
        /// <returns>the result of the validation</returns>
        public virtual ServiceResult Validate(FilterContext context, int index)
        {
            return ServiceResult.Create(StatusCodes.BadEventFilterInvalid, "A sub-class of FilterOperand must be specified.");
        }

        /// <summary>
        /// Converts an FilterOperand to a displayable string.
        /// </summary>
        /// <param name="nodeTable">The node table.</param>
        /// <returns>ContentFilterElement as a displayable string.</returns>
        public virtual string ToString(INodeTable nodeTable)
        {
            return Utils.Format("{0}", this);
        }
        #endregion
        
        #region Private Fields
        private ContentFilterElement m_parent;
        #endregion
    }
    #endregion

    #region AttributeOperand Class
    public partial class AttributeOperand : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Constructs an operand from a value.
        /// </summary>
        /// <param name="nodeId">The node identifier.</param>
        /// <param name="browsePath">The browse path.</param>
        public AttributeOperand(
            NodeId nodeId,
            QualifiedName browsePath)
        {
            m_nodeId = nodeId;
            m_attributeId = Attributes.Value;

            m_browsePath = new RelativePath();

            RelativePathElement element = new RelativePathElement();

            element.ReferenceTypeId = ReferenceTypeIds.Aggregates;
            element.IsInverse = false;
            element.IncludeSubtypes = true;
            element.TargetName = browsePath;

            m_browsePath.Elements.Add(element);
        }

        /// <summary>
        /// Constructs an operand from a value.
        /// </summary>
        /// <param name="nodeId">The node identifier.</param>
        /// <param name="browsePaths">The browse paths.</param>
        public AttributeOperand(
            NodeId nodeId,
            IList<QualifiedName> browsePaths)
        {
            m_nodeId = nodeId;
            m_attributeId = Attributes.Value;
            m_browsePath = new RelativePath();

            for (int ii = 0; ii < browsePaths.Count; ii++)
            {
                RelativePathElement element = new RelativePathElement();

                element.ReferenceTypeId = ReferenceTypeIds.Aggregates;
                element.IsInverse = false;
                element.IncludeSubtypes = true;
                element.TargetName = browsePaths[ii];

                m_browsePath.Elements.Add(element);
            }
        }

        /// <summary>
        /// Creates an operand that references a component/property of a type.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="nodeId">The node identifier.</param>
        /// <param name="relativePath">The relative path.</param>
        public AttributeOperand(
            FilterContext  context, 
            ExpandedNodeId nodeId,
            RelativePath   relativePath)
        {
            m_nodeId      = ExpandedNodeId.ToNodeId(nodeId, context.NamespaceUris);
            m_browsePath  = relativePath;
            m_attributeId = Attributes.Value;
            m_indexRange  = null;
            m_alias       = null;
        }
        
        /// <summary>
        /// Creates an operand that references a component/property of a type.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="typeDefinitionId">The type definition identifier.</param>
        /// <param name="browsePath">The browse path.</param>
        /// <param name="attributeId">The attribute identifier.</param>
        /// <param name="indexRange">The index range.</param>
        public AttributeOperand(
            FilterContext  context, 
            ExpandedNodeId typeDefinitionId,
            string         browsePath,
            uint           attributeId,
            string         indexRange)
        {
            m_nodeId      = ExpandedNodeId.ToNodeId(typeDefinitionId, context.NamespaceUris);
            m_browsePath  = RelativePath.Parse(browsePath, context.TypeTree);
            m_attributeId = attributeId;
            m_indexRange  = indexRange;
            m_alias       = null;                        
        }
        #endregion
        
        #region IFormattable Members
        /// <summary>
        /// Formats the value of the current instance using the specified format.
        /// </summary>
        /// <param name="format">The <see cref="T:System.String"/> specifying the format to use.
        /// -or-
        /// null to use the default format defined for the type of the <see cref="T:System.IFormattable"/> implementation.</param>
        /// <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.
        /// -or-
        /// null to obtain the numeric format information from the current locale setting of the operating system.</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                StringBuilder buffer = new StringBuilder();

                for (int ii = 0; ii < m_browsePath.Elements.Count; ii++)
                {
                    buffer.AppendFormat(formatProvider, "/{0}", m_browsePath.Elements[ii].TargetName);
                }

                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion
        
        #region Overridden Methods
        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Whether the operand has been validated.
        /// </summary>
        /// <value><c>true</c> if validated; otherwise, <c>false</c>.</value>
        /// <remarks>
        /// Set when Validate() is called.
        /// </remarks>
        public bool Validated
        {
            get { return m_validated; }
        }

        /// <summary>
        /// Stores the parsed form of the IndexRange parameter.
        /// </summary>
        /// <value>The parsed index range.</value>
        /// <remarks>
        /// Set when Validate() is called.
        /// </remarks>
        public NumericRange ParsedIndexRange
        {
            get { return m_parsedIndexRange; }
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Validates the operand (sets the ParsedBrowsePath and ParsedIndexRange properties).
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="index">The index.</param>
        /// <returns>The result of the validation.</returns>
        public override ServiceResult Validate(FilterContext context, int index)
        {
            m_validated = false;

            // verify that the operand refers to a node in the type model.
            if (!context.TypeTree.IsKnown(m_nodeId))
            {                
                return ServiceResult.Create(
                    StatusCodes.BadTypeDefinitionInvalid, 
                    "AttributeOperand does not have a known TypeDefinitionId ({0}).", 
                    m_nodeId);
            }

            // verify attribute id.
            if (!Attributes.IsValid(m_attributeId))
            {
                return ServiceResult.Create(
                    StatusCodes.BadAttributeIdInvalid, 
                    "AttributeOperand does not specify a valid AttributeId ({0}).", 
                    m_attributeId);
            }

            // initialize as empty.
            m_parsedIndexRange = NumericRange.Empty;

            // parse the index range.
            if (!String.IsNullOrEmpty(m_indexRange))
            {
                try
                {
                    m_parsedIndexRange = NumericRange.Parse(m_indexRange);
                }
                catch (Exception e)
                {
                    return ServiceResult.Create(
                        e,
                        StatusCodes.BadIndexRangeInvalid, 
                        "AttributeOperand does not specify a valid BrowsePath ({0}).", 
                        m_indexRange);
                }

                if (m_attributeId != Attributes.Value)
                {
                    return ServiceResult.Create(
                        StatusCodes.BadIndexRangeInvalid, 
                        "AttributeOperand specifies an IndexRange for an Attribute other than Value ({0}).", 
                        m_attributeId);
                }
            }

            m_validated = true;

            return ServiceResult.Good;
        }

        /// <summary>
        /// Converts an AttributeOperand to a displayable string.
        /// </summary>
        /// <param name="nodeTable">The node table.</param>
        /// <returns>AttributeOperand as a displayable string.</returns>
        public override string ToString(INodeTable nodeTable)
        {
            StringBuilder buffer = new StringBuilder();

            INode node = nodeTable.Find(m_nodeId);

            if (node != null)
            {
                buffer.AppendFormat("{0}", NodeId);
            }
            else
            {
                buffer.AppendFormat("{0}", NodeId);
            }
             
            if (!RelativePath.IsEmpty(BrowsePath))
            {
                buffer.AppendFormat("/{0}", BrowsePath.Format(nodeTable.TypeTree));
            }

            if (!String.IsNullOrEmpty(IndexRange))
            {
                buffer.AppendFormat("[{0}]", NumericRange.Parse(IndexRange));
            }

            if (!String.IsNullOrEmpty(Alias))
            {
                buffer.AppendFormat("- '{0}'", Alias);
            }
            
            return buffer.ToString();
        }
        #endregion
        
        #region Private Fields
        private bool m_validated;
        private NumericRange m_parsedIndexRange;
        #endregion
    }
    #endregion

    #region ElementOperand Class
    public partial class ElementOperand : IFormattable
    {
        /// <summary>
        /// Constructs an operand from a value.
        /// </summary>
        /// <param name="index">The index.</param>
        public ElementOperand(uint index)
        {
            m_index = index;
        }

        #region IFormattable Members
        /// <summary>
        /// Formats the value of the current instance using the specified format.
        /// </summary>
        /// <param name="format">The <see cref="T:System.String"/> specifying the format to use.
        /// -or-
        /// null to use the default format defined for the type of the <see cref="T:System.IFormattable"/> implementation.</param>
        /// <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.
        /// -or-
        /// null to obtain the numeric format information from the current locale setting of the operating system.</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                return String.Format("[{0}]", m_index);
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion
        
        #region Overridden Methods
        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        /// <summary>
        /// Validates the operand.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="index">The index.</param>
        /// <returns>The result of the validation</returns>
        public override ServiceResult Validate(FilterContext context, int index)
        {
            if (m_index < 0)
            {
                return ServiceResult.Create(
                    StatusCodes.BadFilterOperandInvalid, 
                    "ElementOperand specifies an Index that is less than zero ({0}).", 
                    m_index);
            }

            if (m_index <= index)
            {
                return ServiceResult.Create(
                    StatusCodes.BadFilterOperandInvalid, 
                    "ElementOperand references an element that precedes it in the ContentFilter.", 
                    m_index);
            }

            if (m_index >= Parent.Parent.Elements.Count)
            {
                return ServiceResult.Create(
                    StatusCodes.BadFilterOperandInvalid, 
                    "ElementOperand references an element that does not exist.", 
                    m_index);
            }

            return ServiceResult.Good;
        }

        /// <summary>
        /// Converts an ElementOperand to a displayable string.
        /// </summary>
        /// <param name="table">The table.</param>
        /// <returns>ElementOperand as a displayable string.</returns>
        public override string ToString(INodeTable table)
        {
            return Utils.Format("Element[{0}]", Index);
        }
    }
    #endregion

    #region LiteralOperand Class
    public partial class LiteralOperand : IFormattable
    {
        /// <summary>
        /// Constructs an operand from a value.
        /// </summary>
        /// <param name="value">The value.</param>
        public LiteralOperand(object value)
        {
            m_value = new Variant(value);
        }

        #region IFormattable Members
        /// <summary>
        /// Formats the value of the current instance using the specified format.
        /// </summary>
        /// <param name="format">The <see cref="T:System.String"/> specifying the format to use.
        /// -or-
        /// null to use the default format defined for the type of the <see cref="T:System.IFormattable"/> implementation.</param>
        /// <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.
        /// -or-
        /// null to obtain the numeric format information from the current locale setting of the operating system.</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                return String.Format("{0}", m_value);
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion
        
        #region Overridden Methods
        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        /// <summary>
        /// Validates the operand.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="index">The index.</param>
        /// <returns>The result of the validation</returns>
        public override ServiceResult Validate(FilterContext context, int index)
        {
            if (m_value.Value == null)
            {
                return ServiceResult.Create(
                    StatusCodes.BadEventFilterInvalid, 
                    "LiteralOperand specifies a null Value.");
            }

            return ServiceResult.Good;
        }

        /// <summary>
        /// Converts an LiteralOperand to a displayable string.
        /// </summary>
        /// <param name="table">The table.</param>
        /// <returns>LiteralOperand as a displayable string.</returns>
        public override string ToString(INodeTable table)
        {
            ExpandedNodeId nodeId = Value.Value as ExpandedNodeId;
            
            if (nodeId == null)
            {
                nodeId = Value.Value as NodeId; 
            }

            if (nodeId != null)
            {
                INode node = table.Find(nodeId);

                if (node != null)
                {
                    return Utils.Format("{0} ({1})", node, nodeId);
                }
            }

            return Utils.Format("{0}", Value);
        }
    }
    #endregion
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua
{
    #region ContentFilter Class
    public partial class ContentFilter: IFormattable
    {
        #region IFormattable Members
        /// <summary>
        /// Formats the value of the current instance using the specified format.
        /// </summary>
        /// <param name="format">The <see cref="T:System.String"/> specifying the format to use.
        /// -or-
        /// null to use the default format defined for the type of the <see cref="T:System.IFormattable"/> implementation.</param>
        /// <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.
        /// -or-
        /// null to obtain the numeric format information from the current locale setting of the operating system.</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                StringBuilder buffer = new StringBuilder();

                for (int ii = 0; ii < this.Elements.Count; ii++)
                {
                    buffer.AppendFormat(formatProvider, "[{0}:{1}]", ii, this.Elements[ii]);
                }

                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion
    
        /// <summary>
        /// Validates the ContentFilter.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <returns>The result of validation.</returns>
        public Result Validate(FilterContext context)
        {
            Result result = new Result(null);
            
            // check for empty filter.
            if (m_elements == null || m_elements.Count == 0)
            {
                return result;
            }            

            bool error = false;

            for (int ii = 0; ii < m_elements.Count; ii++)
            {
                ContentFilterElement element = m_elements[ii];
                
                // check for null.
                if (element == null)
                {
                    ServiceResult nullResult = ServiceResult.Create(
                        StatusCodes.BadStructureMissing, 
                        "ContentFilterElement is null (Index={0}).",
                        ii);

                    result.ElementResults.Add(new ElementResult(nullResult));
                    error = true;
                    continue;
                }
                
                element.Parent = this;

                // validate element.
                ElementResult elementResult = element.Validate(context, ii);

                if (ServiceResult.IsBad(elementResult.Status))
                {
                    result.ElementResults.Add(elementResult);
                    error = true;
                    continue;
                }

                result.ElementResults.Add(null);
            }
            
            // ensure the global error code.
            if (error)
            {
                result.Status = StatusCodes.BadContentFilterInvalid;
            }
            else
            {
                result.ElementResults.Clear();
            }

            return result;
        }
        
        /// <summary>
        /// Pushes a new element onto the stack.
        /// </summary>
        /// <param name="op">The filter operator.</param>
        /// <param name="operands">The operands.</param>
        /// <returns></returns>
        public ContentFilterElement Push(FilterOperator op, params object[] operands)
        { 
            // check if nothing more to do.
            if (operands == null || operands.Length == 0)
            {                        
                throw ServiceResultException.Create(StatusCodes.BadInvalidArgument, "ContentFilterElement does not have an operands.");
            }
            
            // create the element and set the operator.
            ContentFilterElement element = new ContentFilterElement();            
            element.FilterOperator = op;
            
            for (int ii = 0; ii < operands.Length; ii++)
            {
                // check if a FilterOperand was provided.
                
                if (operands[ii] is FilterOperand filterOperand)
                {
                    element.FilterOperands.Add(new ExtensionObject(filterOperand));
                    continue;
                }

                // check for reference to another ContentFilterElement.

                if (operands[ii] is ContentFilterElement existingElement)
                {
                    int index = FindElementIndex(existingElement);

                    if (index == -1)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadInvalidArgument, "ContentFilterElement is not part of the ContentFilter.");
                    }

                    ElementOperand operand = new ElementOperand();
                    operand.Index = (uint)index;

                    element.FilterOperands.Add(new ExtensionObject(operand));
                    continue;
                }

                // assume a literal operand.
                LiteralOperand literalOperand = new LiteralOperand();
                literalOperand.Value = new Variant(operands[ii]);
                element.FilterOperands.Add(new ExtensionObject(literalOperand));
            }

            // insert the new element at the begining of the list.
            m_elements.Insert(0, element);

            // re-number ElementOperands since all element were shifted up.
            for (int ii = 0; ii < m_elements.Count; ii++)
            {
                foreach (ExtensionObject extension in m_elements[ii].FilterOperands)
                {
                    if (extension != null)
                    {
                        if (extension.Body is ElementOperand operand)
                        {
                            operand.Index++;
                        }
                    }                
                }
            }

            // return new element.
            return element;
        }

        /// <summary>
        /// Finds the index of the specified element.
        /// </summary>
        /// <param name="target">The targetto be found.</param>
        /// <returns>The index of the specified element.</returns>
        private int FindElementIndex(ContentFilterElement target)
        {
            for (int ii = 0; ii < m_elements.Count; ii++)
            {
                if (Object.ReferenceEquals(target, m_elements[ii]))
                {
                    return ii;
                }
            }

            return -1;
        }
        
        #region Result Class
        /// <summary>
        /// Stores the validation results for a ContentFilterElement.
        /// </summary>
        public class Result
        {
            #region Public Interface
            /// <summary>
            /// Initializes the object with a result code.
            /// </summary>
            /// <param name="status">The status.</param>
            public Result(ServiceResult status)
            {
                m_status = status;
            }

            /// <summary>
            /// Casts ServiceResult to an ElementResult.
            /// </summary>
            /// <param name="status">The status.</param>
            /// <returns>The result of the conversion.</returns>
            public static implicit operator Result(ServiceResult status)
            {
                return new Result(status);
            }
            
            /// <summary>
            /// The result for the entire filter.
            /// </summary>
            /// <value>The status.</value>
            public ServiceResult Status
            {
                get { return m_status;  }
                set { m_status = value; }
            }
                     
            /// <summary>
            /// The result for each element.
            /// </summary>
            /// <value>The element results.</value>
            public List<ElementResult> ElementResults
            {
                get
                {
                    if (m_elementResults == null)
                    {
                        m_elementResults = new List<ElementResult>();
                    }

                    return m_elementResults;
                }
            }

            /// <summary>
            /// Converts the object to an ContentFilterResult.
            /// </summary>
            /// <param name="diagnosticsMasks">The diagnostics masks.</param>
            /// <param name="stringTable">The string table.</param>
            /// <returns></returns>
            public ContentFilterResult ToContextFilterResult(DiagnosticsMasks diagnosticsMasks, StringTable stringTable)
            {
                ContentFilterResult result = new ContentFilterResult();

                if (m_elementResults == null || m_elementResults.Count == 0)
                {
                    return result;
                }

                bool error = false;

                foreach (ElementResult elementResult in m_elementResults)
                {
                    ContentFilterElementResult elementResult2 = null;
                                        
                    if (elementResult == null || ServiceResult.IsGood(elementResult.Status))
                    {
                        elementResult2 = new ContentFilterElementResult();
                        elementResult2.StatusCode = StatusCodes.Good;

                        result.ElementResults.Add(elementResult2);
                        result.ElementDiagnosticInfos.Add(null);
                        continue;
                    }

                    error = true;
                                        
                    elementResult2 = elementResult.ToContentFilterElementResult(diagnosticsMasks, stringTable);
                    result.ElementResults.Add(elementResult2);
                    result.ElementDiagnosticInfos.Add(new DiagnosticInfo(elementResult.Status, diagnosticsMasks, false, stringTable));
                }

                if (!error)
                {
                    result.ElementResults.Clear();
                    result.ElementDiagnosticInfos.Clear();
                }
                    
                return result;
            }
            #endregion
            
            #region Private Fields
            private ServiceResult m_status;
            private List<ElementResult> m_elementResults;
            #endregion
        }
        #endregion
        
        #region ElementResult Class
        /// <summary>
        /// Stores the validation results for a ContentFilterElement.
        /// </summary>
        public class ElementResult
        {
            #region Public Interface
            /// <summary>
            /// Initializes the object with a result code.
            /// </summary>
            /// <param name="status">The status.</param>
            public ElementResult(ServiceResult status)
            {
                m_status = status;
            }

            /// <summary>
            /// Casts ServiceResult to an ElementResult.
            /// </summary>
            /// <param name="status">The status.</param>
            /// <returns>The result of the conversion.</returns>
            public static implicit operator ElementResult(ServiceResult status)
            {
                return new ElementResult(status);
            }
            
            /// <summary>
            /// The result for the entire element.
            /// </summary>
            /// <value>The status.</value>
            public ServiceResult Status
            {
                get { return m_status;  }
                set { m_status = value; }
            }
                     
            /// <summary>
            /// The result for each operand.
            /// </summary>
            /// <value>The operand results.</value>
            public List<ServiceResult> OperandResults
            {
                get
                {
                    if (m_operandResults == null)
                    {
                        m_operandResults = new List<ServiceResult>();
                    }

                    return m_operandResults;
                }
            }
            
            /// <summary>
            /// Converts the object to an ContentFilterElementResult.
            /// </summary>
            /// <param name="diagnosticsMasks">The diagnostics masks.</param>
            /// <param name="stringTable">The string table.</param>
            /// <returns></returns>
            public ContentFilterElementResult ToContentFilterElementResult(DiagnosticsMasks diagnosticsMasks, StringTable stringTable)
            {
                ContentFilterElementResult result = new ContentFilterElementResult();

                if (ServiceResult.IsGood(m_status))
                {
                    result.StatusCode = StatusCodes.Good;
                    return result;
                }
                
                result.StatusCode = m_status.StatusCode;

                if (m_operandResults.Count == 0)
                {
                    return result;
                }

                foreach (ServiceResult operandResult in m_operandResults)
                {
                    if (ServiceResult.IsGood(operandResult))
                    {
                        result.OperandStatusCodes.Add(StatusCodes.Good);
                        result.OperandDiagnosticInfos.Add(null);
                    }
                    else
                    { 
                        result.OperandStatusCodes.Add(operandResult.StatusCode);                                    
                        result.OperandDiagnosticInfos.Add(new DiagnosticInfo(operandResult, diagnosticsMasks, false, stringTable));

                    }                                        
                }

                return result;
            }
            #endregion
            
            #region Private Fields
            private ServiceResult m_status;
            private List<ServiceResult> m_operandResults;
            #endregion
        }
        #endregion
    }
    #endregion

    #region ContentFilterElement Class
    public partial class ContentFilterElement : IFormattable
    {
        #region IFormattable Members
        /// <summary>
        /// Formats the value of the current instance using the specified format.
        /// </summary>
        /// <param name="format">The <see cref="T:System.String"/> specifying the format to use.
        /// -or-
        /// null to use the default format defined for the type of the <see cref="T:System.IFormattable"/> implementation.</param>
        /// <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.
        /// -or-
        /// null to obtain the numeric format information from the current locale setting of the operating system.</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                StringBuilder buffer = new StringBuilder();

                buffer.AppendFormat(formatProvider, "<{0}", this.FilterOperator);

                for (int ii = 0; ii < this.FilterOperands.Count; ii++)
                {
                    if (this.FilterOperands[ii] != null)
                    {
                        buffer.AppendFormat(formatProvider, ", {0}", this.FilterOperands[ii].Body);
                    }
                    else
                    {
                        buffer.AppendFormat(formatProvider, ", (null)");
                    }
                }

                buffer.AppendFormat(formatProvider, ">");

                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The ContentFilter that this Element is part of.
        /// </summary>
        /// <value>The parent.</value>
        public ContentFilter Parent
        {
            get { return m_parent; }
            internal set { this.m_parent = value; }
        } 

        /// <summary>
        /// Validates the content filter element.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="index">The index.</param>
        /// <returns>The results of the validation.</returns>
        public virtual ContentFilter.ElementResult Validate(FilterContext context, int index)
        {
            ContentFilter.ElementResult result = new ContentFilter.ElementResult(null);

            // check the number of operands.
            int operandCount = -1;

            switch (m_filterOperator)
            {
                case FilterOperator.Not:
                case FilterOperator.IsNull:
                case FilterOperator.InView:
                case FilterOperator.OfType:
                {
                    operandCount = 1;
                    break;
                }

                case FilterOperator.And:
                case FilterOperator.Or:
                case FilterOperator.Equals:
                case FilterOperator.GreaterThan:
                case FilterOperator.GreaterThanOrEqual:
                case FilterOperator.LessThan:
                case FilterOperator.LessThanOrEqual:
                case FilterOperator.Like:
                case FilterOperator.Cast:
                {
                    operandCount = 2;
                    break;
                }

                case FilterOperator.Between:
                {
                    operandCount = 3;
                    break;
                }

                case FilterOperator.RelatedTo:
                {
                    operandCount = 6;
                    break;
                }

                case FilterOperator.InList:
                {
                    operandCount = -1;
                    break;
                }

                default:
                {
                    break;
                }
            }

            if (operandCount != -1)
            {
                if (operandCount != m_filterOperands.Count)
                {                    
                    result.Status = ServiceResult.Create(
                        StatusCodes.BadEventFilterInvalid, 
                        "ContentFilterElement does not have the correct number of operands (Operator={0} OperandCount={1}).", 
                        m_filterOperator,
                        operandCount);

                    return result;
                }
            }
            else
            {
                if (m_filterOperands.Count < 2)
                {                    
                    result.Status = ServiceResult.Create(
                        StatusCodes.BadEventFilterInvalid, 
                        "ContentFilterElement does not have the correct number of operands (Operator={0} OperandCount={1}).", 
                        m_filterOperator,
                        m_filterOperands.Count);

                    return result;
                }
            }

            // validate the operands.
            bool error = false;

            for (int ii = 0; ii < m_filterOperands.Count; ii++)
            {
                ServiceResult operandResult = null;

                ExtensionObject operand = m_filterOperands[ii];
                
                // check for null.
                if (ExtensionObject.IsNull(operand))
                {
                    operandResult = ServiceResult.Create(
                        StatusCodes.BadEventFilterInvalid,
                        "The FilterOperand cannot be Null.");
                
                    result.OperandResults.Add(operandResult);
                    error = true;
                    continue;
                }            
                
                // check that the extension object contains a filter operand.
                FilterOperand filterOperand = operand.Body  as FilterOperand;

                if (filterOperand == null)
                {
                    operandResult = ServiceResult.Create(
                        StatusCodes.BadEventFilterInvalid,
                        "The FilterOperand is not a supported type ({0}).",
                        operand.Body.GetType());

                    result.OperandResults.Add(operandResult);
                    error = true;
                    continue;
                }

                // validate the operand.
                filterOperand.Parent = this;
                operandResult = filterOperand.Validate(context, index);

                if (ServiceResult.IsBad(operandResult))
                {
                    result.OperandResults.Add(operandResult);
                    error = true;
                    continue;
                }

                result.OperandResults.Add(null);
            }
            
            // ensure the global error code.
            if (error)
            {
                result.Status = StatusCodes.BadContentFilterInvalid;
            }
            else
            {
                result.OperandResults.Clear();
            }

            return result;
        }

        /// <summary>
        /// Returns the operands for the element.
        /// </summary>
        /// <returns>The list of operands for the element.</returns>
        public List<FilterOperand> GetOperands()
        {
            List<FilterOperand> operands = new List<FilterOperand>(FilterOperands.Count); 

            foreach (ExtensionObject extension in FilterOperands)
            {
                if (ExtensionObject.IsNull(extension))
                {
                    continue;
                }

                FilterOperand operand = extension.Body as FilterOperand;

                if (operand == null)
                {
                    continue;
                }
               
                operands.Add(operand);
            }

            return operands;
        }
        
        /// <summary>
        /// Sets the operands for the element.
        /// </summary>
        /// <param name="operands">The list of the operands.</param>
        public void SetOperands(IEnumerable<FilterOperand> operands)
        {
            FilterOperands.Clear();

            if (operands == null)
            {
                return;
            }

            foreach (FilterOperand operand in operands)
            {
                if (operand == null)
                {
                    continue;
                }

                FilterOperands.Add(new ExtensionObject(operand));
            }
        }

        /// <summary>
        /// Converts an ContentFilterElement to a displayable string.
        /// </summary>
        /// <param name="nodeTable">The node table.</param>
        /// <returns>ContentFilterElement as a displayable string.</returns>
        public virtual string ToString(INodeTable nodeTable)
        {
            List<FilterOperand> operands = GetOperands();

            string operand1 = (operands.Count > 0)?operands[0].ToString(nodeTable):null;
            string operand2 = (operands.Count > 1)?operands[1].ToString(nodeTable):null;
            string operand3 = (operands.Count > 2)?operands[2].ToString(nodeTable):null;

            StringBuilder buffer = new StringBuilder();

            switch (FilterOperator)
            {
                case FilterOperator.OfType:
                case FilterOperator.InView:
                case FilterOperator.IsNull:
                case FilterOperator.Not:
                {
                    buffer.AppendFormat("{0} '{1}'", FilterOperator, operand1);
                    break;
                }
                    
                case FilterOperator.And:
                case FilterOperator.Equals:
                case FilterOperator.GreaterThan:
                case FilterOperator.GreaterThanOrEqual:
                case FilterOperator.LessThan:
                case FilterOperator.LessThanOrEqual:
                case FilterOperator.Like:
                case FilterOperator.Or:
                {
                    buffer.AppendFormat("'{1}' {0} '{2}'", FilterOperator, operand1, operand2);
                    break;
                }
                    
                case FilterOperator.Between:
                {
                    buffer.AppendFormat("'{1}' <= '{0}' <= '{2}'", operand1, operand2, operand3);
                    break;
                }
                    
                case FilterOperator.Cast:
                {
                    buffer.AppendFormat("({1}){0}", operand1, operand2);
                    break;
                }
                    
                case FilterOperator.InList:
                {
                    buffer.AppendFormat("'{0}' in {", operand1);

                    for (int ii = 1; ii < operands.Count; ii++)
                    {
                        if (ii < operands.Count-1)
                        {
                            buffer.Append(", ");
                        }

                        buffer.AppendFormat("'{0}'", operands[ii].ToString());
                    }
                            
                    buffer.Append("}");
                    break;
                }
                    
                case FilterOperator.RelatedTo:
                {
                    buffer.AppendFormat("'{0}' ", operand1);
                    
                    string referenceType = operand2;

                    if (operands.Count > 1)
                    {
                        if (operands[1] is LiteralOperand literalOperand)
                        {
                            INode node = nodeTable.Find(literalOperand.Value.Value as NodeId);

                            if (node != null)
                            {
                                referenceType = Utils.Format("{0}", node);
                            }
                        }
                    }
                    
                    buffer.AppendFormat("{0} '{1}'", referenceType, operand2);

                    if (operand3 != null)
                    {
                        buffer.AppendFormat("Hops='{0}'", operand3);
                    }

                    break;
                }
            }

            return buffer.ToString();
        }
        #endregion

        #region Private Fields
        private ContentFilter m_parent;
        #endregion
    }
    #endregion

    #region FilterOperand Class
    public partial class FilterOperand
    {
        #region Public Interface
        /// <summary>
        /// The ContentFilterElement this FilterOperand is contained in.
        /// The ContentFilterElement contains the operator and the operands
        /// so it defines the expression to be evaluated.
        /// </summary>
        /// <value>The parent element.</value>
        public ContentFilterElement Parent
        {
            get { return this.m_parent; }
            internal set { this.m_parent = value; }
        }

        /// <summary>
        /// Validates the operand.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="index">The index.</param>
        /// <returns>the result of the validation</returns>
        public virtual ServiceResult Validate(FilterContext context, int index)
        {
            return ServiceResult.Create(StatusCodes.BadEventFilterInvalid, "A sub-class of FilterOperand must be specified.");
        }

        /// <summary>
        /// Converts an FilterOperand to a displayable string.
        /// </summary>
        /// <param name="nodeTable">The node table.</param>
        /// <returns>ContentFilterElement as a displayable string.</returns>
        public virtual string ToString(INodeTable nodeTable)
        {
            return Utils.Format("{0}", this);
        }
        #endregion
        
        #region Private Fields
        private ContentFilterElement m_parent;
        #endregion
    }
    #endregion

    #region AttributeOperand Class
    public partial class AttributeOperand : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Constructs an operand from a value.
        /// </summary>
        /// <param name="nodeId">The node identifier.</param>
        /// <param name="browsePath">The browse path.</param>
        public AttributeOperand(
            NodeId nodeId,
            QualifiedName browsePath)
        {
            m_nodeId = nodeId;
            m_attributeId = Attributes.Value;

            m_browsePath = new RelativePath();

            RelativePathElement element = new RelativePathElement();

            element.ReferenceTypeId = ReferenceTypeIds.Aggregates;
            element.IsInverse = false;
            element.IncludeSubtypes = true;
            element.TargetName = browsePath;

            m_browsePath.Elements.Add(element);
        }

        /// <summary>
        /// Constructs an operand from a value.
        /// </summary>
        /// <param name="nodeId">The node identifier.</param>
        /// <param name="browsePaths">The browse paths.</param>
        public AttributeOperand(
            NodeId nodeId,
            IList<QualifiedName> browsePaths)
        {
            m_nodeId = nodeId;
            m_attributeId = Attributes.Value;
            m_browsePath = new RelativePath();

            for (int ii = 0; ii < browsePaths.Count; ii++)
            {
                RelativePathElement element = new RelativePathElement();

                element.ReferenceTypeId = ReferenceTypeIds.Aggregates;
                element.IsInverse = false;
                element.IncludeSubtypes = true;
                element.TargetName = browsePaths[ii];

                m_browsePath.Elements.Add(element);
            }
        }

        /// <summary>
        /// Creates an operand that references a component/property of a type.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="nodeId">The node identifier.</param>
        /// <param name="relativePath">The relative path.</param>
        public AttributeOperand(
            FilterContext  context, 
            ExpandedNodeId nodeId,
            RelativePath   relativePath)
        {
            m_nodeId      = ExpandedNodeId.ToNodeId(nodeId, context.NamespaceUris);
            m_browsePath  = relativePath;
            m_attributeId = Attributes.Value;
            m_indexRange  = null;
            m_alias       = null;
        }
        
        /// <summary>
        /// Creates an operand that references a component/property of a type.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="typeDefinitionId">The type definition identifier.</param>
        /// <param name="browsePath">The browse path.</param>
        /// <param name="attributeId">The attribute identifier.</param>
        /// <param name="indexRange">The index range.</param>
        public AttributeOperand(
            FilterContext  context, 
            ExpandedNodeId typeDefinitionId,
            string         browsePath,
            uint           attributeId,
            string         indexRange)
        {
            m_nodeId      = ExpandedNodeId.ToNodeId(typeDefinitionId, context.NamespaceUris);
            m_browsePath  = RelativePath.Parse(browsePath, context.TypeTree);
            m_attributeId = attributeId;
            m_indexRange  = indexRange;
            m_alias       = null;                        
        }
        #endregion
        
        #region IFormattable Members
        /// <summary>
        /// Formats the value of the current instance using the specified format.
        /// </summary>
        /// <param name="format">The <see cref="T:System.String"/> specifying the format to use.
        /// -or-
        /// null to use the default format defined for the type of the <see cref="T:System.IFormattable"/> implementation.</param>
        /// <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.
        /// -or-
        /// null to obtain the numeric format information from the current locale setting of the operating system.</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                StringBuilder buffer = new StringBuilder();

                for (int ii = 0; ii < m_browsePath.Elements.Count; ii++)
                {
                    buffer.AppendFormat(formatProvider, "/{0}", m_browsePath.Elements[ii].TargetName);
                }

                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion
        
        #region Overridden Methods
        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Whether the operand has been validated.
        /// </summary>
        /// <value><c>true</c> if validated; otherwise, <c>false</c>.</value>
        /// <remarks>
        /// Set when Validate() is called.
        /// </remarks>
        public bool Validated
        {
            get { return m_validated; }
        }

        /// <summary>
        /// Stores the parsed form of the IndexRange parameter.
        /// </summary>
        /// <value>The parsed index range.</value>
        /// <remarks>
        /// Set when Validate() is called.
        /// </remarks>
        public NumericRange ParsedIndexRange
        {
            get { return m_parsedIndexRange; }
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Validates the operand (sets the ParsedBrowsePath and ParsedIndexRange properties).
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="index">The index.</param>
        /// <returns>The result of the validation.</returns>
        public override ServiceResult Validate(FilterContext context, int index)
        {
            m_validated = false;

            // verify that the operand refers to a node in the type model.
            if (!context.TypeTree.IsKnown(m_nodeId))
            {                
                return ServiceResult.Create(
                    StatusCodes.BadTypeDefinitionInvalid, 
                    "AttributeOperand does not have a known TypeDefinitionId ({0}).", 
                    m_nodeId);
            }

            // verify attribute id.
            if (!Attributes.IsValid(m_attributeId))
            {
                return ServiceResult.Create(
                    StatusCodes.BadAttributeIdInvalid, 
                    "AttributeOperand does not specify a valid AttributeId ({0}).", 
                    m_attributeId);
            }

            // initialize as empty.
            m_parsedIndexRange = NumericRange.Empty;

            // parse the index range.
            if (!String.IsNullOrEmpty(m_indexRange))
            {
                try
                {
                    m_parsedIndexRange = NumericRange.Parse(m_indexRange);
                }
                catch (Exception e)
                {
                    return ServiceResult.Create(
                        e,
                        StatusCodes.BadIndexRangeInvalid, 
                        "AttributeOperand does not specify a valid BrowsePath ({0}).", 
                        m_indexRange);
                }

                if (m_attributeId != Attributes.Value)
                {
                    return ServiceResult.Create(
                        StatusCodes.BadIndexRangeInvalid, 
                        "AttributeOperand specifies an IndexRange for an Attribute other than Value ({0}).", 
                        m_attributeId);
                }
            }

            m_validated = true;

            return ServiceResult.Good;
        }

        /// <summary>
        /// Converts an AttributeOperand to a displayable string.
        /// </summary>
        /// <param name="nodeTable">The node table.</param>
        /// <returns>AttributeOperand as a displayable string.</returns>
        public override string ToString(INodeTable nodeTable)
        {
            StringBuilder buffer = new StringBuilder();

            INode node = nodeTable.Find(m_nodeId);

            if (node != null)
            {
                buffer.AppendFormat("{0}", NodeId);
            }
            else
            {
                buffer.AppendFormat("{0}", NodeId);
            }
             
            if (!RelativePath.IsEmpty(BrowsePath))
            {
                buffer.AppendFormat("/{0}", BrowsePath.Format(nodeTable.TypeTree));
            }

            if (!String.IsNullOrEmpty(IndexRange))
            {
                buffer.AppendFormat("[{0}]", NumericRange.Parse(IndexRange));
            }

            if (!String.IsNullOrEmpty(Alias))
            {
                buffer.AppendFormat("- '{0}'", Alias);
            }
            
            return buffer.ToString();
        }
        #endregion
        
        #region Private Fields
        private bool m_validated;
        private NumericRange m_parsedIndexRange;
        #endregion
    }
    #endregion

    #region ElementOperand Class
    public partial class ElementOperand : IFormattable
    {
        /// <summary>
        /// Constructs an operand from a value.
        /// </summary>
        /// <param name="index">The index.</param>
        public ElementOperand(uint index)
        {
            m_index = index;
        }

        #region IFormattable Members
        /// <summary>
        /// Formats the value of the current instance using the specified format.
        /// </summary>
        /// <param name="format">The <see cref="T:System.String"/> specifying the format to use.
        /// -or-
        /// null to use the default format defined for the type of the <see cref="T:System.IFormattable"/> implementation.</param>
        /// <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.
        /// -or-
        /// null to obtain the numeric format information from the current locale setting of the operating system.</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                return String.Format("[{0}]", m_index);
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion
        
        #region Overridden Methods
        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        /// <summary>
        /// Validates the operand.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="index">The index.</param>
        /// <returns>The result of the validation</returns>
        public override ServiceResult Validate(FilterContext context, int index)
        {
            if (m_index < 0)
            {
                return ServiceResult.Create(
                    StatusCodes.BadFilterOperandInvalid, 
                    "ElementOperand specifies an Index that is less than zero ({0}).", 
                    m_index);
            }

            if (m_index <= index)
            {
                return ServiceResult.Create(
                    StatusCodes.BadFilterOperandInvalid, 
                    "ElementOperand references an element that precedes it in the ContentFilter.", 
                    m_index);
            }

            if (m_index >= Parent.Parent.Elements.Count)
            {
                return ServiceResult.Create(
                    StatusCodes.BadFilterOperandInvalid, 
                    "ElementOperand references an element that does not exist.", 
                    m_index);
            }

            return ServiceResult.Good;
        }

        /// <summary>
        /// Converts an ElementOperand to a displayable string.
        /// </summary>
        /// <param name="table">The table.</param>
        /// <returns>ElementOperand as a displayable string.</returns>
        public override string ToString(INodeTable table)
        {
            return Utils.Format("Element[{0}]", Index);
        }
    }
    #endregion

    #region LiteralOperand Class
    public partial class LiteralOperand : IFormattable
    {
        /// <summary>
        /// Constructs an operand from a value.
        /// </summary>
        /// <param name="value">The value.</param>
        public LiteralOperand(object value)
        {
            m_value = new Variant(value);
        }

        #region IFormattable Members
        /// <summary>
        /// Formats the value of the current instance using the specified format.
        /// </summary>
        /// <param name="format">The <see cref="T:System.String"/> specifying the format to use.
        /// -or-
        /// null to use the default format defined for the type of the <see cref="T:System.IFormattable"/> implementation.</param>
        /// <param name="formatProvider">The <see cref="T:System.IFormatProvider"/> to use to format the value.
        /// -or-
        /// null to obtain the numeric format information from the current locale setting of the operating system.</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                return String.Format("{0}", m_value);
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion
        
        #region Overridden Methods
        /// <summary>
        /// Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </summary>
        /// <returns>
        /// A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
        /// </returns>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        /// <summary>
        /// Validates the operand.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="index">The index.</param>
        /// <returns>The result of the validation</returns>
        public override ServiceResult Validate(FilterContext context, int index)
        {
            if (m_value.Value == null)
            {
                return ServiceResult.Create(
                    StatusCodes.BadEventFilterInvalid, 
                    "LiteralOperand specifies a null Value.");
            }

            return ServiceResult.Good;
        }

        /// <summary>
        /// Converts an LiteralOperand to a displayable string.
        /// </summary>
        /// <param name="table">The table.</param>
        /// <returns>LiteralOperand as a displayable string.</returns>
        public override string ToString(INodeTable table)
        {
            
            if (nodeId == null)
            {
                nodeId = Value.Value as NodeId; 
            }

            if (Value.Value is ExpandedNodeId nodeId)
            {
                INode node = table.Find(nodeId);

                if (node != null)
                {
                    return Utils.Format("{0} ({1})", node, nodeId);
                }
            }

            return Utils.Format("{0}", Value);
        }
    }
    #endregion
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\ContentFilter.cs(1302,17): error CS0841: Cannot use local variable 'nodeId' before it is declared,D:\a\1\s\Stack\Opc.Ua.Core\Stack\Nodes\ContentFilter.cs(1304,17): error CS0841: Cannot use local variable 'nodeId' before it is declared
######################################################################


######################################################################
Nr: 14 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.IO;
using System.Runtime.Serialization;
using System.Reflection;
using System.Threading;

namespace Opc.Ua
{       
    /// <summary> 
    /// The base class for all instance nodes.
    /// </summary>
    public class BaseInstanceState : NodeState, IFilterTarget
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        protected BaseInstanceState(NodeClass nodeClass, NodeState parent) : base(nodeClass)
        {
            m_parent = parent;
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance from another instance.
        /// </summary>
        protected override void Initialize(ISystemContext context, NodeState source)
        {
            BaseInstanceState instance = source as BaseInstanceState;

            if (instance != null)
            {
                m_referenceTypeId = instance.m_referenceTypeId;
                m_typeDefinitionId = instance.m_typeDefinitionId;
                m_modellingRuleId = instance.m_modellingRuleId;
                m_numericId = instance.m_numericId;
            }

            base.Initialize(context, source);
        }

        /// <summary>
        /// Returns the id of the default type definition node for the instance.
        /// </summary>
        /// <param name="namespaceUris">The namespace uris.</param>
        /// <returns></returns>
        protected virtual NodeId GetDefaultTypeDefinitionId(NamespaceTable namespaceUris)
        {
            return null;
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The parent node.
        /// </summary>
        public NodeState Parent
        {
            get { return m_parent; }
            internal set { m_parent = value; }
        }

        /// <summary>
        /// Makes a copy of the node and all children.
        /// </summary>
        /// <returns>
        /// A new object that is a copy of this instance.
        /// </returns>
        public new object MemberwiseClone()
        {
            BaseInstanceState clone = new BaseInstanceState(this.NodeClass, this.Parent);

            if (m_children != null)
            {
                clone.m_children = new List<BaseInstanceState>(m_children.Count);

                for (int ii = 0; ii < m_children.Count; ii++)
                {
                    BaseInstanceState child = (BaseInstanceState)m_children[ii].MemberwiseClone();
                    clone.m_children.Add(child);
                }
            }

            clone.m_changeMasks = NodeStateChangeMasks.None;

            return clone;
        }

        /// <summary>
        /// Returns the id of the default type definition node for the instance.
        /// </summary>
        /// <returns>The type definition id.</returns>
        public virtual NodeId GetDefaultTypeDefinitionId(ISystemContext context)
        {
            return GetDefaultTypeDefinitionId(context.NamespaceUris);
        }

        /// <summary>
        /// Gets a display path for the node.
        /// </summary>
        public string GetDisplayPath()
        {
            return GetDisplayPath(0, '.');
        }

        /// <summary>
        /// Gets a display text for the node.
        /// </summary>
        public string GetDisplayText()
        {
            return GetNonNullText(this);
        }

        /// <summary>
        /// Gets a display path for the node.
        /// </summary>
        public string GetDisplayPath(int maxLength, char seperator)
        {
            string name = GetNonNullText(this);
            
            if (m_parent == null)
            {
                return name;
            }
            
            StringBuilder buffer = new StringBuilder();
              
            if (maxLength > 2)
            {
                NodeState parent = m_parent;
                List<string> names = new List<string>();
                
                while (parent != null)
                {
                    BaseInstanceState instance = parent as BaseInstanceState;

                    if (instance == null)
                    {
                        break;
                    }
                   
                    parent = instance.Parent;
                    
                    string parentName = GetNonNullText(parent);
                    names.Add(parentName);

                    if (names.Count == maxLength-2)
                    {
                        break;
                    }
                }
                 
                for (int ii = names.Count-1; ii >= 0; ii--)
                {
                    buffer.Append(names[ii]);
                    buffer.Append(seperator);
                }
            }
            
            buffer.Append(GetNonNullText(m_parent));
            buffer.Append(seperator);
            buffer.Append(name);

            return buffer.ToString();
        }

        /// <summary>
        /// Returns non-null text for the node.
        /// </summary>
        private string GetNonNullText(NodeState node)
        {
            if (node == null)
            {
                return "(null)";
            }

            if (node.DisplayName == null)
            {
                if (node.BrowseName != null)
                {
                    return node.BrowseName.Name;
                }
                else
                {
                    return node.NodeClass.ToString();
                }
            }
                
            return node.DisplayName.Text;
        }

        /// <summary>
        /// A numeric identifier for the instance that is unique within the parent.
        /// </summary>
        public uint NumericId
        {
            get { return m_numericId; }
            set { m_numericId = value; }
        }     

        /// <summary>
        /// The type of reference from the parent node to the instance.
        /// </summary>
        public NodeId ReferenceTypeId
        {
            get
            { 
                return m_referenceTypeId;  
            }
            
            set
            {
                if (!Object.ReferenceEquals(m_referenceTypeId, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.References;
                }

                m_referenceTypeId = value;
            }
        }

        /// <summary>
        /// The identifier for the type definition node.
        /// </summary>
        public NodeId TypeDefinitionId
        {
            get
            { 
                return m_typeDefinitionId;  
            }
            
            set
            {
                if (!Object.ReferenceEquals(m_typeDefinitionId, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.References;
                }

                m_typeDefinitionId = value;
            }
        }

        /// <summary>
        /// The modelling rule assigned to the instance.
        /// </summary>
        public NodeId ModellingRuleId
        {
            get
            { 
                return m_modellingRuleId;  
            }
            
            set
            {
                if (!Object.ReferenceEquals(m_modellingRuleId, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.References;
                }

                m_modellingRuleId = value;
            }
        }

        /// <summary>
        /// Sets the flag which indicates whether event are being monitored for the instance and its children.
        /// </summary>
        /// <param name="context">The system context.</param>
        /// <param name="e">The event to report.</param>
        public override void ReportEvent(ISystemContext context, IFilterTarget e)
        {
            base.ReportEvent(context, e);

            // recusively notify the parent.
            m_parent?.ReportEvent(context, e);
        }

        /// <summary>
        /// Initializes the instance from an event notification.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="fields">The fields selected for the event notification.</param>
        /// <param name="e">The event notification.</param>
        /// <remarks>
        /// This method creates components based on the browse paths in the event field and sets
        /// the NodeId or Value based on values in the event notification.
        /// </remarks>  
        public void Update(
            ISystemContext context,
            SimpleAttributeOperandCollection fields,
            EventFieldList e)
        {
            for (int ii = 0; ii < fields.Count; ii++)
            {
                SimpleAttributeOperand field = fields[ii];
                object value = e.EventFields[ii].Value;

                // check if value provided.
                if (value == null)
                {
                    continue;
                }

                // extract the NodeId for the event.
                if (field.BrowsePath.Count == 0)
                {
                    if (field.AttributeId == Attributes.NodeId)
                    {
                        this.NodeId = value as NodeId;
                        continue;
                    }
                }

                // extract the type definition for the event.
                if (field.BrowsePath.Count == 1)
                {
                    if (field.AttributeId == Attributes.Value)
                    {
                        if (field.BrowsePath[0] == BrowseNames.EventType)
                        {
                            m_typeDefinitionId = value as NodeId;
                            continue;
                        }
                    }
                }

                // save value for child node.
                NodeState parent = this;

                for (int jj = 0; jj < field.BrowsePath.Count; jj++)
                {
                    // find a predefined child identified by the browse name.
                    BaseInstanceState child = parent.CreateChild(context, field.BrowsePath[jj]);

                    // create a placeholder for unknown children.
                    if (child == null)
                    {
                        if (field.AttributeId == Attributes.Value)
                        {
                            child = new BaseDataVariableState(parent);
                        }
                        else
                        {
                            child = new BaseObjectState(parent);
                        }

                        parent.AddChild(child);
                    }

                    // ensure the browse name is set.
                    if (QualifiedName.IsNull(child.BrowseName))
                    {
                        child.BrowseName = field.BrowsePath[jj];
                    }

                    // ensure the display name is set.
                    if (LocalizedText.IsNullOrEmpty(child.DisplayName))
                    {
                        child.DisplayName = child.BrowseName.Name;
                    }

                    // process next element in path.
                    if (jj < field.BrowsePath.Count-1)
                    {
                        parent = child;
                        continue;
                    }

                    // save the variable value.
                    if (field.AttributeId == Attributes.Value)
                    {
                        BaseVariableState variable = child as BaseVariableState;

                        if (variable != null && field.AttributeId == Attributes.Value)
                        {
                            try
                            {
                                variable.WrappedValue = e.EventFields[ii];
                            }
                            catch (Exception)
                            {
                                variable.Value = null;
                            }
                        }

                        break;
                    }

                    // save the node id.
                    child.NodeId = value as NodeId;
                }
            }
        }

        /// <summary>
        /// Sets the minimum sampling interval for the node an all of its child variables..
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="minimumSamplingInterval">The minimum sampling interval.</param>
        public void SetMinimumSamplingInterval(ISystemContext context, double minimumSamplingInterval)
        {
            BaseVariableState variable = this as BaseVariableState;

            if (variable != null)
            {
                variable.MinimumSamplingInterval = minimumSamplingInterval;
            }

            List<BaseInstanceState> children = new List<BaseInstanceState>();
            GetChildren(context, children);

            for (int ii = 0; ii < children.Count; ii++)
            {
                variable = children[ii] as BaseVariableState;

                if (variable != null)
                {
                    variable.MinimumSamplingInterval = minimumSamplingInterval;
                }

                children[ii].SetMinimumSamplingInterval(context, minimumSamplingInterval);
            }
        }
        #endregion 

        #region IFilterTarget Members
        /// <summary cref="IFilterTarget.IsTypeOf" />
        public virtual bool IsTypeOf(FilterContext context, NodeId typeDefinitionId)
        {
            if (!NodeId.IsNull(typeDefinitionId))
            {
                if (!context.TypeTree.IsTypeOf(TypeDefinitionId, typeDefinitionId))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary cref="IFilterTarget.GetAttributeValue" />
        public virtual object GetAttributeValue(
            FilterContext context, 
            NodeId typeDefinitionId, 
            IList<QualifiedName> relativePath, 
            uint attributeId, 
            NumericRange indexRange)
        {
            // check the type definition.
            if (!NodeId.IsNull(typeDefinitionId) && typeDefinitionId != ObjectTypes.BaseEventType)
            {
                if (!context.TypeTree.IsTypeOf(TypeDefinitionId, typeDefinitionId))
                {
                    return null;
                }
            }

            // read the child attribute.
            DataValue dataValue = new DataValue();   

            ServiceResult result = ReadChildAttribute(
                null,
                relativePath,
                0,
                attributeId,
                dataValue);
            
            if (ServiceResult.IsBad(result))
            {
                return null;
            }

            // apply any index range.
            object value = dataValue.Value;

            if (value != null)
            {
                result = indexRange.ApplyRange(ref value);
                
                if (ServiceResult.IsBad(result))
                {
                    return null;
                }
            }

            // return the result.
            return value;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Exports a copy of the node to a node table.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="node">The node to update with the values from the instance.</param>
        protected override void Export(ISystemContext context, Node node)
        {
            base.Export(context, node);

            if (this.Parent != null)
            {
                NodeId referenceTypeId = this.ReferenceTypeId;
                
                if (NodeId.IsNull(referenceTypeId))
                {
                    referenceTypeId = ReferenceTypeIds.HasComponent;
                }

                node.ReferenceTable.Add(referenceTypeId, true, this.Parent.NodeId);
            }

            if (!NodeId.IsNull(this.TypeDefinitionId))
            {
                node.ReferenceTable.Add(ReferenceTypeIds.HasTypeDefinition, false, this.TypeDefinitionId);
            }

            if (!NodeId.IsNull(this.ModellingRuleId))
            {
                node.ReferenceTable.Add(ReferenceTypeIds.HasModellingRule, false, this.ModellingRuleId);
            }            
        }

        /// <summary>
        /// Saves the attributes from the stream.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="encoder">The encoder wrapping the stream to write.</param>
        public override void Save(ISystemContext context, XmlEncoder encoder)
        {
            base.Save(context, encoder);

            encoder.PushNamespace(Namespaces.OpcUaXsd);

            if (!NodeId.IsNull(m_referenceTypeId))
            {
                encoder.WriteNodeId("ReferenceTypeId", m_referenceTypeId);
            }

            if (!NodeId.IsNull(m_typeDefinitionId))
            {
                encoder.WriteNodeId("TypeDefinitionId", m_typeDefinitionId);
            }

            if (!NodeId.IsNull(m_modellingRuleId))
            {
                encoder.WriteNodeId("ModellingRuleId", m_modellingRuleId);
            }

            if (m_numericId != 0)
            {
                encoder.WriteUInt32("NumericId", m_numericId);
            }

            encoder.PopNamespace();
        }
        
        /// <summary>
        /// Returns a mask which indicates which attributes have non-default value.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <returns>A mask the specifies the available attributes.</returns>
        public override AttributesToSave GetAttributesToSave(ISystemContext context)
        {
            AttributesToSave attributesToSave = base.GetAttributesToSave(context);

            if (!NodeId.IsNull(m_referenceTypeId))
            {
                attributesToSave |= AttributesToSave.ReferenceTypeId;
            }

            if (!NodeId.IsNull(m_typeDefinitionId))
            {
                attributesToSave |= AttributesToSave.TypeDefinitionId;
            }

            if (!NodeId.IsNull(m_modellingRuleId))
            {
                attributesToSave |= AttributesToSave.ModellingRuleId;
            }

            if (m_numericId != 0)
            {
                attributesToSave |= AttributesToSave.NumericId;
            }
            
            return attributesToSave;
        }

        /// <summary>
        /// Saves object in an binary stream.
        /// </summary>
        /// <param name="context">The context user.</param>
        /// <param name="encoder">The encoder to write to.</param>
        /// <param name="attributesToSave">The masks indicating what attributes to write.</param>
        public override void Save(ISystemContext context, BinaryEncoder encoder, AttributesToSave attributesToSave)
        {
            base.Save(context, encoder, attributesToSave);

            if ((attributesToSave & AttributesToSave.ReferenceTypeId) != 0)
            {
                encoder.WriteNodeId(null, m_referenceTypeId);
            }

            if ((attributesToSave & AttributesToSave.TypeDefinitionId) != 0)
            {
                encoder.WriteNodeId(null, m_typeDefinitionId);
            }

            if ((attributesToSave & AttributesToSave.ModellingRuleId) != 0)
            {
                encoder.WriteNodeId(null, m_modellingRuleId);
            }

            if ((attributesToSave & AttributesToSave.NumericId) != 0)
            {
                encoder.WriteUInt32(null, m_numericId);
            }
        }

        /// <summary>
        /// Updates the specified context.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="decoder">The decoder.</param>
        /// <param name="attibutesToLoad">The attributes to load.</param>
        public override void Update(ISystemContext context, BinaryDecoder decoder, AttributesToSave attibutesToLoad)
        {
            base.Update(context, decoder, attibutesToLoad);

            if ((attibutesToLoad & AttributesToSave.ReferenceTypeId) != 0)
            {
                m_referenceTypeId = decoder.ReadNodeId(null);
            }

            if ((attibutesToLoad & AttributesToSave.TypeDefinitionId) != 0)
            {
                m_typeDefinitionId = decoder.ReadNodeId(null);
            }

            if ((attibutesToLoad & AttributesToSave.ModellingRuleId) != 0)
            {
                m_modellingRuleId = decoder.ReadNodeId(null);
            }

            if ((attibutesToLoad & AttributesToSave.NumericId) != 0)
            {
                m_numericId = decoder.ReadUInt32(null);
            }
        }

        /// <summary>
        /// Updates the attributes from the stream.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="decoder">The decoder wrapping the stream to read.</param>
        public override void Update(ISystemContext context, XmlDecoder decoder)
        {
            base.Update(context, decoder);

            decoder.PushNamespace(Namespaces.OpcUaXsd);

            if (decoder.Peek("ReferenceTypeId"))
            {
                ReferenceTypeId = decoder.ReadNodeId("ReferenceTypeId");
            }

            if (decoder.Peek("TypeDefinitionId"))
            {
               TypeDefinitionId = decoder.ReadNodeId("TypeDefinitionId");
            }

            if (decoder.Peek("ModellingRuleId"))
            {
                ModellingRuleId = decoder.ReadNodeId("ModellingRuleId");
            }

            if (decoder.Peek("NumericId"))
            {
                NumericId = decoder.ReadUInt32("NumericId");
            }

            decoder.PopNamespace();
        }

        /// <summary>
        /// Populates the browser with references that meet the criteria.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="browser">The browser to populate.</param>
        protected override void PopulateBrowser(ISystemContext context, NodeBrowser browser)
        {
            base.PopulateBrowser(context, browser);

            if (!NodeId.IsNull(m_typeDefinitionId))
            {
                if (browser.IsRequired(ReferenceTypeIds.HasTypeDefinition, false))
                {
                    browser.Add(ReferenceTypeIds.HasTypeDefinition, false, m_typeDefinitionId);
                }
            }

            if (!NodeId.IsNull(m_modellingRuleId))
            {
                if (browser.IsRequired(ReferenceTypeIds.HasModellingRule, false))
                {
                    browser.Add(ReferenceTypeIds.HasModellingRule, false, m_modellingRuleId);
                }
            }

            if (m_parent != null)
            {
                if (!NodeId.IsNull(m_referenceTypeId))
                {
                    if (browser.IsRequired(m_referenceTypeId, true))
                    {
                        browser.Add(m_referenceTypeId, true, m_parent);
                    }
                }
            }
        }
        #endregion
        
        #region Private Fields
        private NodeState m_parent;
        private NodeId m_referenceTypeId;
        private NodeId m_typeDefinitionId;
        private NodeId m_modellingRuleId;
        private uint m_numericId;
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.IO;
using System.Runtime.Serialization;
using System.Reflection;
using System.Threading;

namespace Opc.Ua
{       
    /// <summary> 
    /// The base class for all instance nodes.
    /// </summary>
    public class BaseInstanceState : NodeState, IFilterTarget
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        protected BaseInstanceState(NodeClass nodeClass, NodeState parent) : base(nodeClass)
        {
            m_parent = parent;
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance from another instance.
        /// </summary>
        protected override void Initialize(ISystemContext context, NodeState source)
        {
            if (source is BaseInstanceState instance)
            {
                m_referenceTypeId = instance.m_referenceTypeId;
                m_typeDefinitionId = instance.m_typeDefinitionId;
                m_modellingRuleId = instance.m_modellingRuleId;
                m_numericId = instance.m_numericId;
            }

            base.Initialize(context, source);
        }

        /// <summary>
        /// Returns the id of the default type definition node for the instance.
        /// </summary>
        /// <param name="namespaceUris">The namespace uris.</param>
        /// <returns></returns>
        protected virtual NodeId GetDefaultTypeDefinitionId(NamespaceTable namespaceUris)
        {
            return null;
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The parent node.
        /// </summary>
        public NodeState Parent
        {
            get { return m_parent; }
            internal set { m_parent = value; }
        }

        /// <summary>
        /// Makes a copy of the node and all children.
        /// </summary>
        /// <returns>
        /// A new object that is a copy of this instance.
        /// </returns>
        public new object MemberwiseClone()
        {
            BaseInstanceState clone = new BaseInstanceState(this.NodeClass, this.Parent);

            if (m_children != null)
            {
                clone.m_children = new List<BaseInstanceState>(m_children.Count);

                for (int ii = 0; ii < m_children.Count; ii++)
                {
                    BaseInstanceState child = (BaseInstanceState)m_children[ii].MemberwiseClone();
                    clone.m_children.Add(child);
                }
            }

            clone.m_changeMasks = NodeStateChangeMasks.None;

            return clone;
        }

        /// <summary>
        /// Returns the id of the default type definition node for the instance.
        /// </summary>
        /// <returns>The type definition id.</returns>
        public virtual NodeId GetDefaultTypeDefinitionId(ISystemContext context)
        {
            return GetDefaultTypeDefinitionId(context.NamespaceUris);
        }

        /// <summary>
        /// Gets a display path for the node.
        /// </summary>
        public string GetDisplayPath()
        {
            return GetDisplayPath(0, '.');
        }

        /// <summary>
        /// Gets a display text for the node.
        /// </summary>
        public string GetDisplayText()
        {
            return GetNonNullText(this);
        }

        /// <summary>
        /// Gets a display path for the node.
        /// </summary>
        public string GetDisplayPath(int maxLength, char seperator)
        {
            string name = GetNonNullText(this);
            
            if (m_parent == null)
            {
                return name;
            }
            
            StringBuilder buffer = new StringBuilder();
              
            if (maxLength > 2)
            {
                NodeState parent = m_parent;
                List<string> names = new List<string>();
                
                while (parent != null)
                {
                    BaseInstanceState instance = parent as BaseInstanceState;

                    if (instance == null)
                    {
                        break;
                    }
                   
                    parent = instance.Parent;
                    
                    string parentName = GetNonNullText(parent);
                    names.Add(parentName);

                    if (names.Count == maxLength-2)
                    {
                        break;
                    }
                }
                 
                for (int ii = names.Count-1; ii >= 0; ii--)
                {
                    buffer.Append(names[ii]);
                    buffer.Append(seperator);
                }
            }
            
            buffer.Append(GetNonNullText(m_parent));
            buffer.Append(seperator);
            buffer.Append(name);

            return buffer.ToString();
        }

        /// <summary>
        /// Returns non-null text for the node.
        /// </summary>
        private string GetNonNullText(NodeState node)
        {
            if (node == null)
            {
                return "(null)";
            }

            if (node.DisplayName == null)
            {
                if (node.BrowseName != null)
                {
                    return node.BrowseName.Name;
                }
                else
                {
                    return node.NodeClass.ToString();
                }
            }
                
            return node.DisplayName.Text;
        }

        /// <summary>
        /// A numeric identifier for the instance that is unique within the parent.
        /// </summary>
        public uint NumericId
        {
            get { return m_numericId; }
            set { m_numericId = value; }
        }     

        /// <summary>
        /// The type of reference from the parent node to the instance.
        /// </summary>
        public NodeId ReferenceTypeId
        {
            get
            { 
                return m_referenceTypeId;  
            }
            
            set
            {
                if (!Object.ReferenceEquals(m_referenceTypeId, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.References;
                }

                m_referenceTypeId = value;
            }
        }

        /// <summary>
        /// The identifier for the type definition node.
        /// </summary>
        public NodeId TypeDefinitionId
        {
            get
            { 
                return m_typeDefinitionId;  
            }
            
            set
            {
                if (!Object.ReferenceEquals(m_typeDefinitionId, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.References;
                }

                m_typeDefinitionId = value;
            }
        }

        /// <summary>
        /// The modelling rule assigned to the instance.
        /// </summary>
        public NodeId ModellingRuleId
        {
            get
            { 
                return m_modellingRuleId;  
            }
            
            set
            {
                if (!Object.ReferenceEquals(m_modellingRuleId, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.References;
                }

                m_modellingRuleId = value;
            }
        }

        /// <summary>
        /// Sets the flag which indicates whether event are being monitored for the instance and its children.
        /// </summary>
        /// <param name="context">The system context.</param>
        /// <param name="e">The event to report.</param>
        public override void ReportEvent(ISystemContext context, IFilterTarget e)
        {
            base.ReportEvent(context, e);

            // recusively notify the parent.
            m_parent?.ReportEvent(context, e);
        }

        /// <summary>
        /// Initializes the instance from an event notification.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="fields">The fields selected for the event notification.</param>
        /// <param name="e">The event notification.</param>
        /// <remarks>
        /// This method creates components based on the browse paths in the event field and sets
        /// the NodeId or Value based on values in the event notification.
        /// </remarks>  
        public void Update(
            ISystemContext context,
            SimpleAttributeOperandCollection fields,
            EventFieldList e)
        {
            for (int ii = 0; ii < fields.Count; ii++)
            {
                SimpleAttributeOperand field = fields[ii];
                object value = e.EventFields[ii].Value;

                // check if value provided.
                if (value == null)
                {
                    continue;
                }

                // extract the NodeId for the event.
                if (field.BrowsePath.Count == 0)
                {
                    if (field.AttributeId == Attributes.NodeId)
                    {
                        this.NodeId = value as NodeId;
                        continue;
                    }
                }

                // extract the type definition for the event.
                if (field.BrowsePath.Count == 1)
                {
                    if (field.AttributeId == Attributes.Value)
                    {
                        if (field.BrowsePath[0] == BrowseNames.EventType)
                        {
                            m_typeDefinitionId = value as NodeId;
                            continue;
                        }
                    }
                }

                // save value for child node.
                NodeState parent = this;

                for (int jj = 0; jj < field.BrowsePath.Count; jj++)
                {
                    // find a predefined child identified by the browse name.
                    BaseInstanceState child = parent.CreateChild(context, field.BrowsePath[jj]);

                    // create a placeholder for unknown children.
                    if (child == null)
                    {
                        if (field.AttributeId == Attributes.Value)
                        {
                            child = new BaseDataVariableState(parent);
                        }
                        else
                        {
                            child = new BaseObjectState(parent);
                        }

                        parent.AddChild(child);
                    }

                    // ensure the browse name is set.
                    if (QualifiedName.IsNull(child.BrowseName))
                    {
                        child.BrowseName = field.BrowsePath[jj];
                    }

                    // ensure the display name is set.
                    if (LocalizedText.IsNullOrEmpty(child.DisplayName))
                    {
                        child.DisplayName = child.BrowseName.Name;
                    }

                    // process next element in path.
                    if (jj < field.BrowsePath.Count-1)
                    {
                        parent = child;
                        continue;
                    }

                    // save the variable value.
                    if (field.AttributeId == Attributes.Value)
                    {
                        if (child is BaseVariableState variable && field.AttributeId == Attributes.Value)
                        {
                            try
                            {
                                variable.WrappedValue = e.EventFields[ii];
                            }
                            catch (Exception)
                            {
                                variable.Value = null;
                            }
                        }

                        break;
                    }

                    // save the node id.
                    child.NodeId = value as NodeId;
                }
            }
        }

        /// <summary>
        /// Sets the minimum sampling interval for the node an all of its child variables..
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="minimumSamplingInterval">The minimum sampling interval.</param>
        public void SetMinimumSamplingInterval(ISystemContext context, double minimumSamplingInterval)
        {
            if (this is BaseVariableState variable)
            {
                variable.MinimumSamplingInterval = minimumSamplingInterval;
            }

            List<BaseInstanceState> children = new List<BaseInstanceState>();
            GetChildren(context, children);

            for (int ii = 0; ii < children.Count; ii++)
            {
                variable = children[ii] as BaseVariableState;

                if (this is BaseVariableState variable)
                {
                    variable.MinimumSamplingInterval = minimumSamplingInterval;
                }

                children[ii].SetMinimumSamplingInterval(context, minimumSamplingInterval);
            }
        }
        #endregion 

        #region IFilterTarget Members
        /// <summary cref="IFilterTarget.IsTypeOf" />
        public virtual bool IsTypeOf(FilterContext context, NodeId typeDefinitionId)
        {
            if (!NodeId.IsNull(typeDefinitionId))
            {
                if (!context.TypeTree.IsTypeOf(TypeDefinitionId, typeDefinitionId))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary cref="IFilterTarget.GetAttributeValue" />
        public virtual object GetAttributeValue(
            FilterContext context, 
            NodeId typeDefinitionId, 
            IList<QualifiedName> relativePath, 
            uint attributeId, 
            NumericRange indexRange)
        {
            // check the type definition.
            if (!NodeId.IsNull(typeDefinitionId) && typeDefinitionId != ObjectTypes.BaseEventType)
            {
                if (!context.TypeTree.IsTypeOf(TypeDefinitionId, typeDefinitionId))
                {
                    return null;
                }
            }

            // read the child attribute.
            DataValue dataValue = new DataValue();   

            ServiceResult result = ReadChildAttribute(
                null,
                relativePath,
                0,
                attributeId,
                dataValue);
            
            if (ServiceResult.IsBad(result))
            {
                return null;
            }

            // apply any index range.
            object value = dataValue.Value;

            if (value != null)
            {
                result = indexRange.ApplyRange(ref value);
                
                if (ServiceResult.IsBad(result))
                {
                    return null;
                }
            }

            // return the result.
            return value;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Exports a copy of the node to a node table.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="node">The node to update with the values from the instance.</param>
        protected override void Export(ISystemContext context, Node node)
        {
            base.Export(context, node);

            if (this.Parent != null)
            {
                NodeId referenceTypeId = this.ReferenceTypeId;
                
                if (NodeId.IsNull(referenceTypeId))
                {
                    referenceTypeId = ReferenceTypeIds.HasComponent;
                }

                node.ReferenceTable.Add(referenceTypeId, true, this.Parent.NodeId);
            }

            if (!NodeId.IsNull(this.TypeDefinitionId))
            {
                node.ReferenceTable.Add(ReferenceTypeIds.HasTypeDefinition, false, this.TypeDefinitionId);
            }

            if (!NodeId.IsNull(this.ModellingRuleId))
            {
                node.ReferenceTable.Add(ReferenceTypeIds.HasModellingRule, false, this.ModellingRuleId);
            }            
        }

        /// <summary>
        /// Saves the attributes from the stream.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="encoder">The encoder wrapping the stream to write.</param>
        public override void Save(ISystemContext context, XmlEncoder encoder)
        {
            base.Save(context, encoder);

            encoder.PushNamespace(Namespaces.OpcUaXsd);

            if (!NodeId.IsNull(m_referenceTypeId))
            {
                encoder.WriteNodeId("ReferenceTypeId", m_referenceTypeId);
            }

            if (!NodeId.IsNull(m_typeDefinitionId))
            {
                encoder.WriteNodeId("TypeDefinitionId", m_typeDefinitionId);
            }

            if (!NodeId.IsNull(m_modellingRuleId))
            {
                encoder.WriteNodeId("ModellingRuleId", m_modellingRuleId);
            }

            if (m_numericId != 0)
            {
                encoder.WriteUInt32("NumericId", m_numericId);
            }

            encoder.PopNamespace();
        }
        
        /// <summary>
        /// Returns a mask which indicates which attributes have non-default value.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <returns>A mask the specifies the available attributes.</returns>
        public override AttributesToSave GetAttributesToSave(ISystemContext context)
        {
            AttributesToSave attributesToSave = base.GetAttributesToSave(context);

            if (!NodeId.IsNull(m_referenceTypeId))
            {
                attributesToSave |= AttributesToSave.ReferenceTypeId;
            }

            if (!NodeId.IsNull(m_typeDefinitionId))
            {
                attributesToSave |= AttributesToSave.TypeDefinitionId;
            }

            if (!NodeId.IsNull(m_modellingRuleId))
            {
                attributesToSave |= AttributesToSave.ModellingRuleId;
            }

            if (m_numericId != 0)
            {
                attributesToSave |= AttributesToSave.NumericId;
            }
            
            return attributesToSave;
        }

        /// <summary>
        /// Saves object in an binary stream.
        /// </summary>
        /// <param name="context">The context user.</param>
        /// <param name="encoder">The encoder to write to.</param>
        /// <param name="attributesToSave">The masks indicating what attributes to write.</param>
        public override void Save(ISystemContext context, BinaryEncoder encoder, AttributesToSave attributesToSave)
        {
            base.Save(context, encoder, attributesToSave);

            if ((attributesToSave & AttributesToSave.ReferenceTypeId) != 0)
            {
                encoder.WriteNodeId(null, m_referenceTypeId);
            }

            if ((attributesToSave & AttributesToSave.TypeDefinitionId) != 0)
            {
                encoder.WriteNodeId(null, m_typeDefinitionId);
            }

            if ((attributesToSave & AttributesToSave.ModellingRuleId) != 0)
            {
                encoder.WriteNodeId(null, m_modellingRuleId);
            }

            if ((attributesToSave & AttributesToSave.NumericId) != 0)
            {
                encoder.WriteUInt32(null, m_numericId);
            }
        }

        /// <summary>
        /// Updates the specified context.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="decoder">The decoder.</param>
        /// <param name="attibutesToLoad">The attributes to load.</param>
        public override void Update(ISystemContext context, BinaryDecoder decoder, AttributesToSave attibutesToLoad)
        {
            base.Update(context, decoder, attibutesToLoad);

            if ((attibutesToLoad & AttributesToSave.ReferenceTypeId) != 0)
            {
                m_referenceTypeId = decoder.ReadNodeId(null);
            }

            if ((attibutesToLoad & AttributesToSave.TypeDefinitionId) != 0)
            {
                m_typeDefinitionId = decoder.ReadNodeId(null);
            }

            if ((attibutesToLoad & AttributesToSave.ModellingRuleId) != 0)
            {
                m_modellingRuleId = decoder.ReadNodeId(null);
            }

            if ((attibutesToLoad & AttributesToSave.NumericId) != 0)
            {
                m_numericId = decoder.ReadUInt32(null);
            }
        }

        /// <summary>
        /// Updates the attributes from the stream.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="decoder">The decoder wrapping the stream to read.</param>
        public override void Update(ISystemContext context, XmlDecoder decoder)
        {
            base.Update(context, decoder);

            decoder.PushNamespace(Namespaces.OpcUaXsd);

            if (decoder.Peek("ReferenceTypeId"))
            {
                ReferenceTypeId = decoder.ReadNodeId("ReferenceTypeId");
            }

            if (decoder.Peek("TypeDefinitionId"))
            {
               TypeDefinitionId = decoder.ReadNodeId("TypeDefinitionId");
            }

            if (decoder.Peek("ModellingRuleId"))
            {
                ModellingRuleId = decoder.ReadNodeId("ModellingRuleId");
            }

            if (decoder.Peek("NumericId"))
            {
                NumericId = decoder.ReadUInt32("NumericId");
            }

            decoder.PopNamespace();
        }

        /// <summary>
        /// Populates the browser with references that meet the criteria.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="browser">The browser to populate.</param>
        protected override void PopulateBrowser(ISystemContext context, NodeBrowser browser)
        {
            base.PopulateBrowser(context, browser);

            if (!NodeId.IsNull(m_typeDefinitionId))
            {
                if (browser.IsRequired(ReferenceTypeIds.HasTypeDefinition, false))
                {
                    browser.Add(ReferenceTypeIds.HasTypeDefinition, false, m_typeDefinitionId);
                }
            }

            if (!NodeId.IsNull(m_modellingRuleId))
            {
                if (browser.IsRequired(ReferenceTypeIds.HasModellingRule, false))
                {
                    browser.Add(ReferenceTypeIds.HasModellingRule, false, m_modellingRuleId);
                }
            }

            if (m_parent != null)
            {
                if (!NodeId.IsNull(m_referenceTypeId))
                {
                    if (browser.IsRequired(m_referenceTypeId, true))
                    {
                        browser.Add(m_referenceTypeId, true, m_parent);
                    }
                }
            }
        }
        #endregion
        
        #region Private Fields
        private NodeState m_parent;
        private NodeId m_referenceTypeId;
        private NodeId m_typeDefinitionId;
        private NodeId m_modellingRuleId;
        private uint m_numericId;
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(19,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(17,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(18,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(20,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(14,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(424,17): error CS0841: Cannot use local variable 'variable' before it is declared,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(426,47): error CS0136: A local or parameter named 'variable' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(20,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(14,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(19,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(17,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseInstanceState.cs(18,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 15 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableState.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.IO;
using System.Runtime.Serialization;
using System.Reflection;
using System.Threading;

namespace Opc.Ua
{
    /// <summary> 
    /// The base class for all variable nodes.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public abstract class BaseVariableState : BaseInstanceState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        /// <param name="parent">The parent node.</param>
        public BaseVariableState(NodeState parent) : base(NodeClass.Variable, parent)
        {
            m_timestamp = DateTime.MinValue;
            m_accessLevel = m_userAccessLevel = AccessLevels.CurrentRead;
            m_copyPolicy = VariableCopyPolicy.CopyOnRead;
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance from another instance.
        /// </summary>
        /// <param name="context">The description how access the system containing the data.</param>
        /// <param name="source">A source node to be copied to this instance.</param>
        protected override void Initialize(ISystemContext context, NodeState source)
        {
            BaseVariableState instance = source as BaseVariableState;

            if (instance != null)
            {
                m_value = ExtractValueFromVariant(context, instance.m_value, false);
                m_timestamp = instance.m_timestamp;
                m_statusCode = instance.m_statusCode;
                m_dataType = instance.m_dataType;
                m_valueRank = instance.m_valueRank;
                m_arrayDimensions = null;
                m_accessLevel = instance.m_accessLevel;
                m_userAccessLevel = instance.m_userAccessLevel;
                m_minimumSamplingInterval = instance.m_minimumSamplingInterval;
                m_historizing = instance.m_historizing;

                if (instance.m_arrayDimensions != null)
                {
                    m_arrayDimensions = new ReadOnlyList<uint>(instance.m_arrayDimensions, true);
                }

                m_value = ExtractValueFromVariant(context, m_value, false);
            }

            base.Initialize(context, source);
        }

        /// <summary>
        /// If overridden returns the id of the default type definition node for the instance.
        /// </summary>
        /// <param name="namespaceUris">The namespace uris.</param>
        /// <returns>Returns the id of the default type definition or <see cref="VariableTypes.BaseVariableType"/></returns> if not overridden
        protected override NodeId GetDefaultTypeDefinitionId(NamespaceTable namespaceUris)
        {
            return VariableTypes.BaseVariableType;
        }

        /// <summary>
        /// If overridden returns the id of the default data type node for the instance.
        /// </summary>
        /// <param name="namespaceUris">The namespace uris.</param>
        /// <returns>
        /// The id <see cref="NodeId"/> of the default data type node for the instance or <see cref="DataTypes.BaseDataType"/> if not overridden.
        /// </returns>
        protected virtual NodeId GetDefaultDataTypeId(NamespaceTable namespaceUris)
        {
            return DataTypes.BaseDataType;
        }

        /// <summary>
        /// If overridden returns the id of the default value rank for the instance.
        /// </summary>
        /// <returns>
        /// The id of the default value rank or <see cref="ValueRanks.Any"/> if not overridden.
        /// </returns>
        protected virtual int GetDefaultValueRank()
        {
            return ValueRanks.Any;
        }

        /// <summary>
        /// Converts a values contained in a variant to the value defined for the variable.
        /// </summary>
        [Obsolete("Should use the version that takes a ISystemContext (pass null if ISystemContext is not available).")]
        protected virtual object ExtractValueFromVariant(object value, bool throwOnError)
        {
            return ExtractValueFromVariant(null, value, throwOnError);
        }

        /// <summary>
        /// Converts a values contained in a variant to the value defined for the variable.
        /// </summary>
        /// <param name="context">The system context.</param>
        /// <param name="value">The value.</param>
        /// <param name="throwOnError">if set to <c>true</c> throw an exception on error.</param>
        /// <returns>If not overridden returns <paramref name="value"/>.</returns>
        protected virtual object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return value;
        }

        /// <summary>
        /// Returns the value after checking if the variable is null.
        /// </summary>
        /// <typeparam name="T">The framework type of value contained in the <paramref name="variable"/>.</typeparam>
        /// <param name="variable">The variable.</param>
        /// <returns>
        /// The value contained by the <paramref name="variable"/> or the default value for the datatype if the variable is null.
        /// </returns>
        public static T GetValue<T>(BaseDataVariableState<T> variable)
        {
            if (variable == null)
            {
                return default(T);
            }

            return variable.Value;
        }

        /// <summary>
        /// Returns the value after checking if the property is null.
        /// </summary>
        /// <typeparam name="T">The type of value contained in the property.</typeparam>
        /// <param name="property">The property.</param>
        /// <returns>
        /// The value. The default value for the datatype if the property is null.
        /// </returns>
        public static T GetValue<T>(PropertyState<T> property)
        {
            if (property == null)
            {
                return default(T);
            }

            return property.Value;
        }

        /// <summary>
        /// Converts a values contained in a variant to the value defined for the variable.
        /// </summary>
        [Obsolete("Should use the version that takes a ISystemContext (pass null if ISystemContext is not available).")]
        public static object ExtractValueFromVariant<T>(object value, bool throwOnError)
        {
            return ExtractValueFromVariant<T>(null, value, throwOnError);
        }

        /// <summary>
        /// Converts a values contained in a variant to the value defined for the variable.
        /// </summary>
        /// <typeparam name="T">The framework type of value contained in this instance.</typeparam>
        /// <param name="context">The context.</param>
        /// <param name="value">The value.</param>
        /// <param name="throwOnError">if set to <c>true</c> throws the <see cref="ServiceResultException"/> on error, otherwise default value for <typeparamref name="T"/> is returned .</param>
        /// <returns>
        /// The value of the <typeparamref name="T"/> type.
        /// </returns>
        /// <remarks>
        /// If throwOnError is <c>false</c> the default value for the type is returned if the value is not valid.
        /// </remarks>
        /// <exception cref="ServiceResultException">If cannot convert <paramref name="value"/>.</exception>
        public static object ExtractValueFromVariant<T>(ISystemContext context, object value, bool throwOnError)
        {
            if (value == null)
            {
                return default(T);
            }

            if (typeof(T).IsInstanceOfType(value))
            {
                return value;
            }

            ExtensionObject extension = value as ExtensionObject;

            if (extension != null)
            {
                if (typeof(T).IsInstanceOfType(extension.Body))
                {
                    return extension.Body;
                }

                if (typeof(IEncodeable).GetTypeInfo().IsAssignableFrom(typeof(T).GetTypeInfo()))
                {
                    return DecodeExtensionObject(context, typeof(T), extension, throwOnError);
                }

                if (throwOnError)
                {
                    throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert {0} to {1}.", value.GetType().Name, typeof(T).Name);
                }

                return default(T);
            }

            Type elementType = typeof(T).GetElementType();

            if (elementType != null)
            {
                // check for array of extensions.
                IList<ExtensionObject> extensions = value as IList<ExtensionObject>;

                if (extensions != null && typeof(IEncodeable).GetTypeInfo().IsAssignableFrom(elementType.GetTypeInfo()))
                {
                    Array encodeables = Array.CreateInstance(elementType, extensions.Count);

                    for (int ii = 0; ii < extensions.Count; ii++)
                    {
                        if (ExtensionObject.IsNull(extensions[ii]))
                        {
                            encodeables.SetValue(null, ii);
                            continue;
                        }

                        if (elementType.IsInstanceOfType(extensions[ii].Body))
                        {
                            encodeables.SetValue(extensions[ii].Body, ii);
                            continue;
                        }

                        object element = DecodeExtensionObject(context, elementType, extensions[ii], throwOnError);

                        if (element != null)
                        {
                            encodeables.SetValue(element, ii);
                            continue;
                        }

                        if (throwOnError)
                        {
                            throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert ExtensionObject to {0}. Index = {1}", elementType.Name, ii);
                        }
                    }

                    return encodeables;
                }

                // check for array of variants.
                IList<Variant> variants = value as IList<Variant>;

                if (variants != null)
                {
                    // only support conversions to object[].
                    if (elementType != typeof(object))
                    {
                        if (throwOnError)
                        {
                            throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert {0} to {1}.", value.GetType().Name, typeof(T).Name);
                        }
                    }

                    // allocate and copy.
                    object[] objects = new object[variants.Count];

                    for (int ii = 0; ii < variants.Count; ii++)
                    {
                        objects[ii] = variants[ii].Value;
                    }

                    return objects;
                }

                // check for array of uuids.
                if (typeof(Guid).GetTypeInfo().IsAssignableFrom(elementType.GetTypeInfo()))
                {
                    IList<Uuid> uuids = value as IList<Uuid>;

                    if (uuids != null)
                    {
                        Guid[] guids = new Guid[uuids.Count];

                        for (int ii = 0; ii < uuids.Count; ii++)
                        {
                            guids[ii] = (Guid)uuids[ii];
                        }

                        return guids;
                    }
                }

                // check for array of enumeration.
                if (typeof(Enum).GetTypeInfo().IsAssignableFrom(elementType.GetTypeInfo()))
                {
                    IList<int> values = value as IList<int>;

                    if (values != null)
                    {
                        Array enums = Array.CreateInstance(elementType, values.Count);

                        for (int ii = 0; ii < values.Count; ii++)
                        {
                            enums.SetValue(values[ii], ii);
                        }

                        return enums;
                    }
                }
            }

            if (typeof(Guid).GetTypeInfo().IsAssignableFrom(typeof(T).GetTypeInfo()))
            {
                Uuid? uuid = value as Uuid?;

                if (uuid != null)
                {
                    return (Guid)uuid.Value;
                }
            } 
            
            if (typeof(Enum).GetTypeInfo().IsAssignableFrom(typeof(T).GetTypeInfo()))
            {
                int? number = value as int?;

                if (number != null)
                {
                    return (T)(object)number.Value;
                }
            }

            if (throwOnError)
            {
                throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert {0} to {1}.", value.GetType().Name, typeof(T).Name);
            }

            return default(T);
        }

        /// <summary>
        /// Decodes the contents of an extension object.
        /// </summary>
        /// <param name="context">The context (uses ServiceMessageContext.GlobalContext if null).</param>
        /// <param name="targetType">The type that the ExtensionObject must be converted to.</param>
        /// <param name="extension">The ExtensionObject to convert.</param>
        /// <param name="throwOnError">Whether to throw an exception on error.</param>
        /// <returns>The decoded instance. Null on error.</returns>
        public static object DecodeExtensionObject(ISystemContext context, Type targetType, ExtensionObject extension, bool throwOnError)
        {
            if (targetType.IsInstanceOfType(extension.Body))
            {
                return extension.Body;
            }

            IEncodeable instance = Activator.CreateInstance(targetType) as IEncodeable;

            if (instance != null)
            {
                IDecoder decoder = null;

                ServiceMessageContext messageContext = ServiceMessageContext.GlobalContext;

                if (context != null)
                {
                    messageContext = new ServiceMessageContext();
                    messageContext.NamespaceUris = context.NamespaceUris;
                    messageContext.ServerUris = context.ServerUris;
                    messageContext.Factory = context.EncodeableFactory;
                }

                if (extension.Encoding == ExtensionObjectEncoding.Binary)
                {
                    decoder = new BinaryDecoder(extension.Body as byte[], messageContext);
                }

                else if (extension.Encoding == ExtensionObjectEncoding.Xml)
                {
                    decoder = new XmlDecoder(extension.Body as XmlElement, messageContext);
                }

                if (decoder != null)
                {
                    try
                    {
                        instance.Decode(decoder);
                        return instance;
                    }
                    catch (Exception e)
                    {
                        if (throwOnError)
                        {
                            throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert ExtensionObject to {0}. Error = {1}", targetType.Name, e.Message);
                        }
                    }
                }
            }

            if (throwOnError)
            {
                throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert ExtensionObject to {0}.", targetType.Name);
            }

            return null;
        }

        /// <summary>
        /// Checks the data type of a value before casting it to the type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The framework type of value contained in the variable.</typeparam>
        /// <param name="value">The value.</param>
        /// <param name="throwOnError">if set to <c>true</c> <see cref="ServiceResultException"/> is thrown on error.</param>
        /// <returns>Returns <paramref name="value"/> or default for <typeparamref name="T"/></returns>
        /// <exception cref="ServiceResultException"> if it is impossible to cast the value or the value is null and <see cref="IsValueType"/> for the type <typeparamref name="T"/> returns true. </exception>
        public static T CheckTypeBeforeCast<T>(object value, bool throwOnError)
        {
            if ((value == null && typeof(T).GetTypeInfo().IsValueType) || (value != null && !typeof(T).IsInstanceOfType(value)))
            {
                if (throwOnError)
                {
                    throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert '{0}' to a {1}.", value, typeof(T).Name);
                }

                return default(T);
            }

            return (T)value;
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public object Value
        {
            get
            {
                return m_value;
            }

            set
            {
                if (value == null && IsValueType)
                {
                    value = ExtractValueFromVariant(null, value, false);
                }

                if (!Object.ReferenceEquals(m_value, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.Value;
                }

                m_value = value;
            }
        }

        /// <summary>
        /// Whether the value can be set to null.
        /// </summary>
        public bool IsValueType
        {
            get { return m_isValueType; }
            set { m_isValueType = value; }
        }

        /// <summary>
        /// The value of the variable as a Variant.
        /// </summary>
        /// <value>The wrapped value as a Variant.</value>
        [DataMember(Name = "Value", Order = 0, IsRequired = false, EmitDefaultValue = false)]
        public Variant WrappedValue
        {
            get
            {
                return new Variant(m_value);
            }

            set
            {
                Value = ExtractValueFromVariant(null, value.Value, false);
            }
        }

        /// <summary>
        /// The timestamp associated with the variable value.
        /// </summary>
        /// <value>The timestamp.</value>
        public DateTime Timestamp
        {
            get
            {
                return m_timestamp;
            }

            set
            {
                if (m_timestamp != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.Value;
                }

                m_timestamp = value;
            }
        }

        /// <summary>
        /// The status code associated with the variable value.
        /// </summary>
        /// <value>The status code.</value>
        public StatusCode StatusCode
        {
            get
            {
                return m_statusCode;
            }

            set
            {
                if (m_statusCode != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.Value;
                }

                m_statusCode = value;
            }
        }

        /// <summary>
        /// The behavior to use when reading or writing all or part of the object.
        /// </summary>
        /// <value>The copy policy that specifies the policies to use when handling reads and write to value.</value>
        /// <remarks>
        /// This value is ignored if the OnReadValue or OnWriteValue event handlers are provided.
        /// </remarks>
        public VariableCopyPolicy CopyPolicy
        {
            get { return m_copyPolicy; }
            set { m_copyPolicy = value; }
        }

        /// <summary>
        /// The data type for the variable value.
        /// </summary>
        /// <value>The type of the data <see cref="NodeId"/>.</value>
        [DataMember(Name = "DataType", Order = 1, IsRequired = false, EmitDefaultValue = false)]
        public NodeId DataType
        {
            get
            {
                return m_dataType;
            }

            set
            {
                if (!Object.ReferenceEquals(m_dataType, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_dataType = value;
            }
        }

        /// <summary>
        /// The number of array dimensions permitted for the variable value.
        /// </summary>
        /// <value>The value rank. </value>
        /// <remarks>Indicates whether the DataType is an array and how many dimensions the array has.</remarks>
        [DataMember(Name = "ValueRank", Order = 2, IsRequired = false, EmitDefaultValue = false)]
        public int ValueRank
        {
            get
            {
                return m_valueRank;
            }

            set
            {
                if (m_valueRank != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_valueRank = value;
            }
        }

        /// <summary>
        /// The number of dimensions for an array values with one or more fixed dimensions.
        /// </summary>
        /// <value>The array dimensions.</value>
        /// <remarks>
        /// If the Value Rank does not identify an array of a specific dimension (i.e. ValueRank &lt;= 0)
        /// the Array Dimensions attribute can either be set to null or the attribute is missing. This behaviour is vendor-specific.
        /// If the Value Rank attribute specifies an array of a specific dimension (i.e. ValueRank &gt; 0) then the Array Dimensions
        /// attribute shall be specified in the table defining the Variable.
        /// </remarks>
        public ReadOnlyList<uint> ArrayDimensions
        {
            get
            {
                return m_arrayDimensions;
            }

            set
            {
                if (!Object.ReferenceEquals(m_arrayDimensions, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_arrayDimensions = value;
            }
        }

        /// <summary>
        /// The type of access available for the variable.
        /// </summary>
        /// <value>The access level.</value>
        [DataMember(Name = "AccessLevel", Order = 4, IsRequired = false, EmitDefaultValue = false)]
        public byte AccessLevel
        {
            get
            {
                return (byte)(m_accessLevel & 0xFF);
            }

            set
            {
                if (AccessLevel != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                // set first 8 bits of AccessLevelEx
                m_accessLevel = (m_accessLevel & 0xFFFFFF00) | value;
            }
        }

        /// <summary>
        /// The type of access granted to the current user.
        /// </summary>
        /// <value>The user access level.</value>
        [DataMember(Name = "UserAccessLevel", Order = 5, IsRequired = false, EmitDefaultValue = false)]
        public byte UserAccessLevel
        {
            get
            {
                return m_userAccessLevel;
            }

            set
            {
                if (m_userAccessLevel != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_userAccessLevel = value;
            }
        }

        /// <summary>
        /// The minimum sampling interval supported by the variable.
        /// </summary>
        /// <value>The minimum sampling interval.</value>
        [DataMember(Name = "MinimumSamplingInterval", Order = 6, IsRequired = false, EmitDefaultValue = false)]
        public double MinimumSamplingInterval
        {
            get
            {
                return m_minimumSamplingInterval;
            }

            set
            {
                if (m_minimumSamplingInterval != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_minimumSamplingInterval = value;
            }
        }

        /// <summary>
        /// Whether the server is archiving the value of the variable.
        /// </summary>
        /// <value><c>true</c> if historizing; otherwise, <c>false</c>.</value>
        [DataMember(Name = "Historizing", Order = 7, IsRequired = false, EmitDefaultValue = false)]
        public bool Historizing
        {
            get
            {
                return m_historizing;
            }

            set
            {
                if (m_historizing != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_historizing = value;
            }
        }

        /// <summary>
        /// A bit mask specifying how the value may be accessed.
        /// </summary>
        /// <value>The extended access level.</value>
        [DataMember(Name = "AccessLevelEx", Order = 8, IsRequired = false, EmitDefaultValue = false)]
        public uint AccessLevelEx
        {
            get
            {
                return m_accessLevel;
            }

            set
            {
                if (m_accessLevel != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_accessLevel = value;
            }
        }
        #endregion

        #region Event Callbacks
        /// <summary>
        /// Raised when the Value attribute is read.
        /// </summary>
        public NodeValueSimpleEventHandler OnSimpleReadValue;

        /// <summary>
        /// Raised when the Value attribute is written.
        /// </summary>
        public NodeValueSimpleEventHandler OnSimpleWriteValue;

        /// <summary>
        /// Raised when the Value attribute is read.
        /// </summary>
        public NodeValueEventHandler OnReadValue;

        /// <summary>
        /// Raised when the Value attribute is written.
        /// </summary>
        public NodeValueEventHandler OnWriteValue;

        /// <summary>
        /// Raised when the DataType attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<NodeId> OnReadDataType;

        /// <summary>
        /// Raised when the DataType attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<NodeId> OnWriteDataType;

        /// <summary>
        /// Raised when the ValueRank attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<int> OnReadValueRank;

        /// <summary>
        /// Raised when the ValueRank attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<int> OnWriteValueRank;

        /// <summary>
        /// Raised when the ArrayDimensions attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<IList<uint>> OnReadArrayDimensions;

        /// <summary>
        /// Raised when the ArrayDimensions attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<IList<uint>> OnWriteArrayDimensions;

        /// <summary>
        /// Raised when the AccessLevel attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<byte> OnReadAccessLevel;

        /// <summary>
        /// Raised when the AccessLevel attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<byte> OnWriteAccessLevel;

        /// <summary>
        /// Raised when the UserAccessLevel attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<byte> OnReadUserAccessLevel;

        /// <summary>
        /// Raised when the UserAccessLevel attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<byte> OnWriteUserAccessLevel;

        /// <summary>
        /// Raised when the MinimumSamplingInterval attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<double> OnReadMinimumSamplingInterval;

        /// <summary>
        /// Raised when the MinimumSamplingInterval attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<double> OnWriteMinimumSamplingInterval;

        /// <summary>
        /// Raised when the Historizing attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<bool> OnReadHistorizing;

        /// <summary>
        /// Raised when the Historizing attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<bool> OnWriteHistorizing;

        /// <summary>
        /// Raised when the AccessLevelEx attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<uint> OnReadAccessLevelEx;

        /// <summary>
        /// Raised when the AccessLevelEx attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<uint> OnWriteAccessLevelEx;
        #endregion

        #region Serialization Functions
        /// <summary>
        /// Exports a copy of the node to a <paramref name="node"/> node provided the <paramref name="node"/> type is compatible with <see cref="VariableNode"/>.
        /// </summary>
        /// <param name="context">The context that describes how access the system containing the data.</param>
        /// <param name="node">The node to be a copy of this instance.</param>
        protected override void Export(ISystemContext context, Node node)
        {
            base.Export(context, node);

            VariableNode variableNode = node as VariableNode;

            if (variableNode != null)
            {
                try
                {
                    variableNode.Value = new Variant(Utils.Clone(this.Value));
                
                    variableNode.DataType = this.DataType;
                    variableNode.ValueRank = this.ValueRank;
                    variableNode.ArrayDimensions = null;

                    if (this.ArrayDimensions != null)
                    {
                        variableNode.ArrayDimensions = new UInt32Collection(this.ArrayDimensions);
                    }

                    variableNode.AccessLevel = this.AccessLevel;
                    variableNode.UserAccessLevel = this.UserAccessLevel;
                    variableNode.MinimumSamplingInterval = this.MinimumSamplingInterval;
                    variableNode.Historizing = this.Historizing;
                }
                catch (Exception e)
                {
                    Utils.Trace(e, "Unexpected error exporting node:" + e.Message);
                }
            }
        }

        /// <summary>
        /// Saves the attributes from this instance to the <paramref name="encoder"/>.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="encoder">The encoder wrapping the stream to write.</param>
        public override void Save(ISystemContext context, XmlEncoder encoder)
        {
            base.Save(context, encoder);

            encoder.PushNamespace(Namespaces.OpcUaXsd);

            if (m_value != null)
            {
                encoder.WriteVariant("Value", WrappedValue);
            }

            if (StatusCode != StatusCodes.Good)
            {
                encoder.WriteStatusCode("StatusCode", StatusCode);
            }

            if (!NodeId.IsNull(DataType))
            {
                encoder.WriteNodeId("DataType", DataType);
            }

            if (ValueRank != ValueRanks.Any)
            {
                encoder.WriteInt32("ValueRank", ValueRank);
            }

            if (ArrayDimensions != null)
            {
                encoder.WriteString("ArrayDimensions", ArrayDimensionsToXml(ArrayDimensions));
            }

            if (AccessLevel != 0)
            {
                encoder.WriteByte("AccessLevel", AccessLevel);
            }

            if (UserAccessLevel != 0)
            {
                encoder.WriteByte("UserAccessLevel", UserAccessLevel);
            }

            if (MinimumSamplingInterval != 0)
            {
                encoder.WriteDouble("MinimumSamplingInterval", MinimumSamplingInterval);
            }

            if (Historizing)
            {
                encoder.WriteBoolean("Historizing", Historizing);
            }

            encoder.PopNamespace();
        }

        /// <summary>
        /// Updates the attributes from the <paramref name="decoder"/>.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="decoder">The decoder wrapping the stream to read.</param>
        public override void Update(ISystemContext context, XmlDecoder decoder)
        {
            base.Update(context, decoder);

            decoder.PushNamespace(Namespaces.OpcUaXsd);

            if (decoder.Peek("Value"))
            {
                WrappedValue = decoder.ReadVariant("Value");
            }

            if (decoder.Peek("Timestamp"))
            {
                Timestamp = decoder.ReadDateTime("Timestamp");
            }

            if (decoder.Peek("StatusCode"))
            {
                StatusCode = decoder.ReadStatusCode("StatusCode");
            }
            else
            {
                StatusCode = StatusCodes.Good;
            }

            if (decoder.Peek("DataType"))
            {
                DataType = decoder.ReadNodeId("DataType");
            }

            if (decoder.Peek("ValueRank"))
            {
                ValueRank = decoder.ReadInt32("ValueRank");
            }

            // ensure the value has a suitable default value.
            if (m_value == null && m_valueRank == ValueRanks.Scalar)
            {
                bool isValueType = IsValueType;

                if (!isValueType)
                {
                    BuiltInType builtInType = DataTypes.GetBuiltInType(m_dataType, context.TypeTable);

                    if (TypeInfo.IsValueType(builtInType))
                    {
                        isValueType = true;
                    }
                }

                if (isValueType)
                {
                    m_value = TypeInfo.GetDefaultValue(m_dataType, m_valueRank, context.TypeTable);
                }
            }

            if (decoder.Peek("ArrayDimensions"))
            {
                ArrayDimensions = ArrayDimensionsFromXml(decoder.ReadString("ArrayDimensions"));
            }

            if (decoder.Peek("AccessLevel"))
            {
                AccessLevel = decoder.ReadByte("AccessLevel");
            }

            if (decoder.Peek("UserAccessLevel"))
            {
                UserAccessLevel = decoder.ReadByte("UserAccessLevel");
            }

            if (decoder.Peek("MinimumSamplingInterval"))
            {
                MinimumSamplingInterval = decoder.ReadDouble("MinimumSamplingInterval");
            }

            if (decoder.Peek("Historizing"))
            {
                Historizing = decoder.ReadBoolean("Historizing");
            }

            decoder.PopNamespace();
        }

        /// <summary>
        /// Returns a mask which indicates which attributes have non-default value.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <returns>
        /// A mask that specifies the available attributes.
        /// </returns>
        public override AttributesToSave GetAttributesToSave(ISystemContext context)
        {
            AttributesToSave attributesToSave = base.GetAttributesToSave(context);

            if (m_value != null)
            {
                attributesToSave |= AttributesToSave.Value;
            }

            if (m_statusCode != StatusCodes.Good)
            {
                attributesToSave |= AttributesToSave.StatusCode;
            }

            if (!NodeId.IsNull(m_dataType))
            {
                attributesToSave |= AttributesToSave.DataType;
            }

            if (m_valueRank != ValueRanks.Any)
            {
                attributesToSave |= AttributesToSave.ValueRank;
            }

            if (m_arrayDimensions != null)
            {
                attributesToSave |= AttributesToSave.ArrayDimensions;
            }

            if (m_accessLevel != 0)
            {
                attributesToSave |= AttributesToSave.AccessLevel;
            }

            if (m_userAccessLevel != 0)
            {
                attributesToSave |= AttributesToSave.UserAccessLevel;
            }

            if (m_minimumSamplingInterval != 0)
            {
                attributesToSave |= AttributesToSave.MinimumSamplingInterval;
            }

            if (m_historizing)
            {
                attributesToSave |= AttributesToSave.Historizing;
            }
            
            return attributesToSave;
        }

        /// <summary>
        /// Saves object in an binary stream.
        /// </summary>
        /// <param name="context">The context that describes how access the system containing the data..</param>
        /// <param name="encoder">The encoder to write to.</param>
        /// <param name="attributesToSave">The masks indicating what attributes to write.</param>
        public override void Save(ISystemContext context, BinaryEncoder encoder, AttributesToSave attributesToSave)
        {
            base.Save(context, encoder, attributesToSave);

            if ((attributesToSave & AttributesToSave.Value) != 0)
            {
                encoder.WriteVariant(null, WrappedValue);
            }

            if ((attributesToSave & AttributesToSave.StatusCode) != 0)
            {
                encoder.WriteStatusCode(null, m_statusCode);
            }

            if ((attributesToSave & AttributesToSave.DataType) != 0)
            {
                encoder.WriteNodeId(null, m_dataType);
            }

            if ((attributesToSave & AttributesToSave.ValueRank) != 0)
            {
                encoder.WriteInt32(null, m_valueRank);
            }

            if ((attributesToSave & AttributesToSave.ArrayDimensions) != 0)
            {
                encoder.WriteUInt32Array(null, m_arrayDimensions);
            }

            if ((attributesToSave & AttributesToSave.AccessLevel) != 0)
            {
                encoder.WriteByte(null, AccessLevel);
            }

            if ((attributesToSave & AttributesToSave.UserAccessLevel) != 0)
            {
                encoder.WriteByte(null, m_userAccessLevel);
            }

            if ((attributesToSave & AttributesToSave.MinimumSamplingInterval) != 0)
            {
                encoder.WriteDouble(null, m_minimumSamplingInterval);
            }

            if ((attributesToSave & AttributesToSave.Historizing) != 0)
            {
                encoder.WriteBoolean(null, m_historizing);
            }
        }

        /// <summary>
        /// Updates the attributes of this instance from the <paramref name="decoder"/>.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="decoder">The decoder.</param>
        /// <param name="attibutesToLoad">The attributes to load.</param>
        public override void Update(ISystemContext context, BinaryDecoder decoder, AttributesToSave attibutesToLoad)
        {
            base.Update(context, decoder, attibutesToLoad);

            if ((attibutesToLoad & AttributesToSave.Value) != 0)
            {
                WrappedValue = decoder.ReadVariant(null);
            }

            if ((attibutesToLoad & AttributesToSave.StatusCode) != 0)
            {
                m_statusCode = decoder.ReadStatusCode(null);
            }

            if ((attibutesToLoad & AttributesToSave.DataType) != 0)
            {
                m_dataType = decoder.ReadNodeId(null);
            }

            if ((attibutesToLoad & AttributesToSave.ValueRank) != 0)
            {
                m_valueRank = decoder.ReadInt32(null);
            }

            if ((attibutesToLoad & AttributesToSave.ArrayDimensions) != 0)
            {
                UInt32Collection arrayDimensions = decoder.ReadUInt32Array(null);

                if (arrayDimensions != null && arrayDimensions.Count > 0)
                {
                    m_arrayDimensions = new ReadOnlyList<uint>(arrayDimensions);
                }
                else
                {
                    m_arrayDimensions = null;
                }
            }

            if ((attibutesToLoad & AttributesToSave.AccessLevel) != 0)
            {
                AccessLevel = decoder.ReadByte(null);
            }

            if ((attibutesToLoad & AttributesToSave.UserAccessLevel) != 0)
            {
                m_userAccessLevel = decoder.ReadByte(null);
            }

            if ((attibutesToLoad & AttributesToSave.MinimumSamplingInterval) != 0)
            {
                m_minimumSamplingInterval = decoder.ReadDouble(null);
            }

            if ((attibutesToLoad & AttributesToSave.Historizing) != 0)
            {
                m_historizing = decoder.ReadBoolean(null);
            }        
        }

        /// <summary>
        /// Converts the array dimensions to an XML string.
        /// </summary>
        /// <param name="arrayDimensions">The array dimensions.</param>
        /// <returns>The XML string value.</returns>
        internal static string ArrayDimensionsToXml(IList<uint> arrayDimensions)
        {
            if (arrayDimensions == null)
            {
                return null;
            }

            StringBuilder buffer = new StringBuilder();

            for (int ii = 0; ii < arrayDimensions.Count; ii++)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(',');
                }

                buffer.Append(arrayDimensions[ii]);
            }

            return buffer.ToString();
        }

        /// <summary>
        /// Returns a list of the array dimensions.
        /// </summary>
        /// <param name="value">The XML string value.</param>
        /// <returns>The array dimensions list.</returns>
        internal static ReadOnlyList<uint> ArrayDimensionsFromXml(string value)
        {
            if (String.IsNullOrEmpty(value))
            {
                return null;
            }

            string[] fields = value.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

            if (fields == null || fields.Length == 0)
            {
                return null;
            }

            uint[] arrayDimensions = new uint[fields.Length];

            for (int ii = 0; ii < arrayDimensions.Length; ii++)
            {
                try
                {
                    arrayDimensions[ii] = Convert.ToUInt32(fields[ii]);
                }
                catch
                {
                    arrayDimensions[ii] = 0;
                }
            }

            return new ReadOnlyList<uint>(arrayDimensions);
        }
        #endregion
        
        #region Overrridden Methods
        /// <summary>
        /// Recusively sets the status code and timestamp for the node and all child variables.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="statusCode">The status code.</param>
        /// <param name="timestamp">The timestamp. Not updated if set to DateTime.Min</param>
        public override void SetStatusCode(ISystemContext context, StatusCode statusCode, DateTime timestamp)
        {
            base.SetStatusCode(context, statusCode, timestamp);

            StatusCode = statusCode;

            if (timestamp != DateTime.MinValue)
            {
                Timestamp = timestamp;
            }
        }
        #endregion

        #region Read Support Functions

        /// <summary>
        /// Reads the value for any non-value attribute.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="attributeId">The attribute idetifier <see cref="Attributes"/>.</param>
        /// <param name="value">The returned value.</param>
        /// <returns>
        /// An instance of the <see cref="ServiceResult"/> containing the status code and diagnostic info for the operation.
        /// ServiceResult.Good if successful. Detailed error information otherwise.
        /// </returns>
        protected override ServiceResult ReadNonValueAttribute(
            ISystemContext context,
            uint attributeId,
            ref object value)
        {
            ServiceResult result = null;

            switch (attributeId)
            {
                case Attributes.DataType:
                {
                    NodeId dataType = m_dataType;

                    if (OnReadDataType != null)
                    {
                        result = OnReadDataType(context, this, ref dataType);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = dataType;
                    }

                    return result;
                }

                case Attributes.ValueRank:
                {
                    int valueRank = m_valueRank;

                    if (OnReadValueRank != null)
                    {
                        result = OnReadValueRank(context, this, ref valueRank);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = valueRank;
                    }

                    return result;
                }
                
                case Attributes.ArrayDimensions:
                {
                    IList<uint> arrayDimensions = m_arrayDimensions;

                    if (OnReadArrayDimensions != null)
                    {
                        result = OnReadArrayDimensions(context, this, ref arrayDimensions);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = arrayDimensions;
                    }

                    return result;
                }

                case Attributes.AccessLevel:
                {
                    byte accessLevel = AccessLevel;

                    if (OnReadAccessLevel != null)
                    {
                        result = OnReadAccessLevel(context, this, ref accessLevel);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = accessLevel;
                    }

                    return result;
                }

                case Attributes.AccessLevelEx:
                {
                    uint accessLevelEx = m_accessLevel;

                    if (OnReadAccessLevelEx != null)
                    {
                        result = OnReadAccessLevelEx(context, this, ref accessLevelEx);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = accessLevelEx;
                    }

                    return result;
                }

                case Attributes.UserAccessLevel:
                {
                    byte userAccessLevel = m_userAccessLevel;

                    if (OnReadUserAccessLevel != null)
                    {
                        result = OnReadUserAccessLevel(context, this, ref userAccessLevel);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = userAccessLevel;
                    }

                    return result;
                }

                case Attributes.MinimumSamplingInterval:
                {
                    double minimumSamplingInterval = m_minimumSamplingInterval;

                    if (OnReadMinimumSamplingInterval != null)
                    {
                        result = OnReadMinimumSamplingInterval(context, this, ref minimumSamplingInterval);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = minimumSamplingInterval;
                    }

                    return result;
                }

                case Attributes.Historizing:
                {
                    bool historizing = m_historizing;

                    if (OnReadHistorizing != null)
                    {
                        result = OnReadHistorizing(context, this, ref historizing);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = historizing;
                    }

                    return result;
                }
            }

            return base.ReadNonValueAttribute(context, attributeId, ref value);
        }

        /// <summary>
        /// Reads the value for the value attribute.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="indexRange">The index range.</param>
        /// <param name="dataEncoding">The data encoding.</param>
        /// <param name="value">The value to be returned.</param>
        /// <param name="sourceTimestamp">The source timestamp.</param>
        /// <returns>
        /// An instance of the <see cref="ServiceResult"/> containing the status code and diagnostic info for the operation.
        /// ServiceResult.Good if successful. Detailed error information otherwise.
        /// </returns>
        protected override ServiceResult ReadValueAttribute(
            ISystemContext context,
            NumericRange indexRange,
            QualifiedName dataEncoding,
            ref object value,
            ref DateTime sourceTimestamp)
        {
            // check the access level for the variable.
            if ((m_accessLevel & AccessLevels.CurrentRead) == 0)
            {
                return StatusCodes.BadNotReadable;
            }

            if ((m_userAccessLevel & AccessLevels.CurrentRead) == 0)
            {
                return StatusCodes.BadUserAccessDenied;
            }

            // ensure a value timestamp exists.
            if (m_timestamp == DateTime.MinValue)
            {
                m_timestamp = DateTime.UtcNow;
            }

            value = m_value;
            sourceTimestamp = m_timestamp;
            StatusCode statusCode = m_statusCode;

            ServiceResult result = null;

            // check if the read behavior has been overridden.
            if (OnReadValue != null)
            {
                result = OnReadValue(
                    context,
                    this,
                    indexRange,
                    dataEncoding,
                    ref value,
                    ref statusCode,
                    ref sourceTimestamp);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }

                // return the correct status code if no errors.
                if (ServiceResult.IsGood(result) && statusCode != StatusCodes.Good)
                {
                    result = statusCode;
                }

                return result;
            }

            // use default behavior.
            if (OnSimpleReadValue != null)
            {
                result = OnSimpleReadValue(
                    context,
                    this,
                    ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
            }
            
            // apply the index range and encoding.
            result = ApplyIndexRangeAndDataEncoding(context, indexRange, dataEncoding, ref value);

            if (ServiceResult.IsBad(result))
            {
                return result;
            }

            // copy returned value.
            if (m_copyPolicy == VariableCopyPolicy.CopyOnRead || m_copyPolicy == VariableCopyPolicy.Always)
            {
                value = Utils.Clone(value);
            }

            // return the correct status code if no errors.
            if (ServiceResult.IsGood(result) && statusCode != StatusCodes.Good)
            {
                result = statusCode;
            }

            return result;
        }

        /// <summary>
        /// Applys the index range and the data encoding to the value.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="indexRange">The index range.</param>
        /// <param name="dataEncoding">The data encoding.</param>
        /// <param name="value">The value.</param>
        /// <returns></returns>
        public static ServiceResult ApplyIndexRangeAndDataEncoding(
            ISystemContext context,
            NumericRange indexRange,
            QualifiedName dataEncoding,
            ref object value)
        {
            ServiceResult result = null;

            // apply index range.
            if (indexRange != NumericRange.Empty)
            {
                result = indexRange.ApplyRange(ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
            }

            // apply data encoding.
            if (!QualifiedName.IsNull(dataEncoding))
            {
                ServiceMessageContext messageContext = new ServiceMessageContext();

                messageContext.NamespaceUris = context.NamespaceUris;
                messageContext.ServerUris = context.ServerUris;
                messageContext.Factory = context.EncodeableFactory;

                result = EncodeableObject.ApplyDataEncoding(messageContext, dataEncoding, ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
            }

            return ServiceResult.Good;
        }

        #endregion
        
        #region Write Support Functions
        /// <summary>
        /// Write the value for any non-value attribute.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="attributeId">The attribute id.</param>
        /// <param name="value">The value.</param>
        /// <returns>
        /// An instance of the <see cref="ServiceResult"/> containing the status code and diagnostic info for the operation.
        /// ServiceResult.Good if successful. Detailed error information otherwise.
        /// </returns>
        protected override ServiceResult WriteNonValueAttribute(
            ISystemContext context,
            uint attributeId,
            object value)
        {
            ServiceResult result = null;

            switch (attributeId)
            {
                case Attributes.DataType:
                {
                    NodeId dataType = value as NodeId;

                    if (dataType == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.DataType) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    if (OnWriteDataType != null)
                    {
                        result = OnWriteDataType(context, this, ref dataType);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        DataType = dataType;
                    }

                    return result;
                }

                case Attributes.ValueRank:
                {
                    int? valueRankRef = value as int?;

                    if (valueRankRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.ValueRank) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    int valueRank = valueRankRef.Value;

                    if (OnWriteValueRank != null)
                    {
                        result = OnWriteValueRank(context, this, ref valueRank);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        ValueRank = valueRank;
                    }

                    return result;
                }

                case Attributes.ArrayDimensions:
                {
                    IList<uint> arrayDimensions = value as IList<uint>;

                    if ((WriteMask & AttributeWriteMask.ArrayDimensions) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    if (OnWriteArrayDimensions != null)
                    {
                        result = OnWriteArrayDimensions(context, this, ref arrayDimensions);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        if (arrayDimensions != null)
                        {
                            ArrayDimensions = new ReadOnlyList<uint>(arrayDimensions);
                        }
                        else
                        {
                            ArrayDimensions = null;
                        }
                    }

                    return result;
                }

                case Attributes.AccessLevel:
                {
                    byte? accessLevelRef = value as byte?;

                    if (accessLevelRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.AccessLevel) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    byte accessLevel = accessLevelRef.Value;

                    if (OnWriteAccessLevel != null)
                    {
                        result = OnWriteAccessLevel(context, this, ref accessLevel);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        AccessLevel = accessLevel;
                    }

                    return result;
                }

                case Attributes.UserAccessLevel:
                {
                    byte? userAccessLevelRef = value as byte?;

                    if (userAccessLevelRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.UserAccessLevel) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    byte userAccessLevel = userAccessLevelRef.Value;

                    if (OnWriteUserAccessLevel != null)
                    {
                        result = OnWriteUserAccessLevel(context, this, ref userAccessLevel);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        UserAccessLevel = userAccessLevel;
                    }

                    return result;
                }

                case Attributes.MinimumSamplingInterval:
                {
                    double? minimumSamplingIntervalRef = value as double?;

                    if (minimumSamplingIntervalRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.MinimumSamplingInterval) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    double minimumSamplingInterval = minimumSamplingIntervalRef.Value;

                    if (OnWriteMinimumSamplingInterval != null)
                    {
                        result = OnWriteMinimumSamplingInterval(context, this, ref minimumSamplingInterval);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        MinimumSamplingInterval = minimumSamplingInterval;
                    }

                    return result;
                }

                case Attributes.Historizing:
                {
                    bool? historizingRef = value as bool?;

                    if (historizingRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.Historizing) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    bool historizing = historizingRef.Value;

                    if (OnWriteHistorizing != null)
                    {
                        result = OnWriteHistorizing(context, this, ref historizing);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        Historizing = historizing;
                    }

                    return result;
                }
            }
            
            return base.WriteNonValueAttribute(context, attributeId, value);
        }

        /// <summary>
        /// Write the value for the value attribute.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="indexRange">The index range.</param>
        /// <param name="value">The value.</param>
        /// <param name="statusCode">The status code.</param>
        /// <param name="sourceTimestamp">The source timestamp.</param>
        /// <returns>
        /// An instance of the <see cref="ServiceResult"/> containing the status code and diagnostic info for the operation.
        /// ServiceResult.Good if successful. Detailed error information otherwise.
        /// </returns>
        protected override ServiceResult WriteValueAttribute(
            ISystemContext context,
            NumericRange indexRange,
            object value,
            StatusCode statusCode,
            DateTime sourceTimestamp)
        {
            ServiceResult result = null;

            // check the access level for the variable.
            if ((m_accessLevel & AccessLevels.CurrentWrite) == 0)
            {
                return StatusCodes.BadNotWritable;
            }

            if ((m_userAccessLevel & AccessLevels.CurrentWrite) == 0)
            {
                return StatusCodes.BadUserAccessDenied;
            }

            // check if the write behavior has been overridden.
            if (OnWriteValue != null)
            {
                result = OnWriteValue(
                    context,
                    this,
                    indexRange,
                    null,
                    ref value,
                    ref statusCode,
                    ref sourceTimestamp);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
                
                m_value = value;
                m_statusCode = statusCode;
                m_timestamp = sourceTimestamp;

                // update timestamp if not set by function.
                if (sourceTimestamp == DateTime.MinValue)
                {
                    m_timestamp = DateTime.UtcNow;
                }

                ChangeMasks |= NodeStateChangeMasks.Value;

                return result;
            }

            // ensure the source timestamp has a valid value.
            if (sourceTimestamp == DateTime.MinValue)
            {
                sourceTimestamp = DateTime.UtcNow;
            }
            
            // verify data type.
            TypeInfo typeInfo = TypeInfo.IsInstanceOfDataType(
                value,
                m_dataType,
                m_valueRank,
                context.NamespaceUris,
                context.TypeTable);

            if (typeInfo == null || typeInfo == TypeInfo.Unknown)
            {
                //if xml element data decoding error appeared : a value of type status code is received with the error code
                if (DataTypeIds.XmlElement == m_dataType)
                {
                    TypeInfo statusCodeTypeInfo = TypeInfo.IsInstanceOfDataType(value,DataTypeIds.UInt32,-1,context.NamespaceUris,context.TypeTable);
                    if (statusCodeTypeInfo != null)
                    {
                        //the error code
                        return (StatusCode)(uint)value;
                    }
                }
                // test for special case Null type
                if (!(m_dataType.IsNullNodeId && value == null))
                {
                    return StatusCodes.BadTypeMismatch;
                }
            }

            value = ExtractValueFromVariant(context, value, true);

            // copy passed in value.
            if (m_copyPolicy == VariableCopyPolicy.CopyOnWrite || m_copyPolicy == VariableCopyPolicy.Always)
            {
                value = Utils.Clone(value);
            }

            // check for simple write value handler.
            if (OnSimpleWriteValue != null)
            {
                // index range writes not supported.
                if (indexRange != NumericRange.Empty)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                result = OnSimpleWriteValue(
                    context,
                    this,
                    ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
            }
            else
            {
                // apply the index range.
                if (indexRange != NumericRange.Empty)
                {
                    object target = m_value;
                    result = indexRange.UpdateRange(ref target, value);

                    if (ServiceResult.IsBad(result))
                    {
                        return result;
                    }

                    value = target;
                }
            }
            
            // update cached values.
            m_value = value;
            m_statusCode = statusCode;
            m_timestamp = sourceTimestamp;

            ChangeMasks |= NodeStateChangeMasks.Value;

            return ServiceResult.Good;
        }
        #endregion

        #region Private Fields
        private object m_value;
        private bool m_isValueType;
        private DateTime m_timestamp;
        private StatusCode m_statusCode;
        private NodeId m_dataType;
        private int m_valueRank;
        private ReadOnlyList<uint> m_arrayDimensions;
        private uint m_accessLevel;
        private byte m_userAccessLevel;
        private double m_minimumSamplingInterval;
        private bool m_historizing;
        private VariableCopyPolicy m_copyPolicy;
        #endregion
    }
    
    /// <summary> 
    /// A typed base class for all data variable nodes.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class PropertyState : BaseVariableState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        public PropertyState(NodeState parent) : base(parent)
        {
        }

        /// <summary>
        /// Constructs an instance of a node.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <returns>The new node.</returns>
        public static NodeState Construct(NodeState parent)
        {
            return new PropertyState(parent);
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            SymbolicName = Utils.Format("{0}_Instance1", Opc.Ua.BrowseNames.PropertyType);
            NodeId = null;
            BrowseName = new QualifiedName(SymbolicName, 1);
            DisplayName = SymbolicName;
            Description = null;
            WriteMask = AttributeWriteMask.None;
            UserWriteMask = AttributeWriteMask.None;
            ReferenceTypeId = Opc.Ua.ReferenceTypeIds.HasProperty;
            TypeDefinitionId = GetDefaultTypeDefinitionId(context.NamespaceUris);
            NumericId = Opc.Ua.VariableTypes.PropertyType;
            Value = null;
            DataType = GetDefaultDataTypeId(context.NamespaceUris);
            ValueRank = GetDefaultValueRank();
            ArrayDimensions = null;
            AccessLevel = AccessLevels.CurrentReadOrWrite;
            UserAccessLevel = AccessLevels.CurrentReadOrWrite;
            MinimumSamplingInterval = MinimumSamplingIntervals.Continuous;
            Historizing = false;
        }

        /// <summary>
        /// Returns the id of the default type definition node for the instance.
        /// </summary>
        protected override NodeId GetDefaultTypeDefinitionId(NamespaceTable namespaceUris)
        {
            return VariableTypes.PropertyType;
        }
        #endregion
    }

    /// <summary> 
    /// A typed base class for all data variable nodes.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class PropertyState<T> : PropertyState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        public PropertyState(NodeState parent) : base(parent)
        {
            Value = default(T);
            IsValueType = !typeof(T).GetTypeInfo().IsValueType;
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            base.Initialize(context);

            Value = default(T);
            DataType = TypeInfo.GetDataTypeId(typeof(T));
            ValueRank = TypeInfo.GetValueRank(typeof(T));
        }

        /// <summary>
        /// Sets the value to its default value if it is not valid.
        /// </summary>
        protected override object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return ExtractValueFromVariant<T>(context, value, throwOnError);
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public new T Value
        {
            get
            {
                return CheckTypeBeforeCast<T>(base.Value, true);
            }

            set
            {
                base.Value = value;
            }
        }
        #endregion
    }
    
    /// <summary> 
    /// A typed base class for all data variable nodes.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class BaseDataVariableState : BaseVariableState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        public BaseDataVariableState(NodeState parent) : base(parent)
        {
            if (parent != null)
            {
                ReferenceTypeId = Opc.Ua.ReferenceTypeIds.HasComponent;
            }
        }

        /// <summary>
        /// Constructs an instance of a node.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <returns>The new node.</returns>
        public static NodeState Construct(NodeState parent)
        {
            return new BaseDataVariableState(parent);
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            SymbolicName = Utils.Format("{0}_Instance1", Opc.Ua.BrowseNames.BaseDataVariableType);
            NodeId = null;
            BrowseName = new QualifiedName(SymbolicName, 1);
            DisplayName = SymbolicName;
            Description = null;
            WriteMask = AttributeWriteMask.None;
            UserWriteMask = AttributeWriteMask.None;
            ReferenceTypeId = Opc.Ua.ReferenceTypeIds.HasComponent;
            TypeDefinitionId = GetDefaultTypeDefinitionId(context.NamespaceUris);
            NumericId = Opc.Ua.VariableTypes.BaseDataVariableType;
            Value = null;
            DataType = GetDefaultDataTypeId(context.NamespaceUris);
            ValueRank = GetDefaultValueRank();
            ArrayDimensions = null;
            AccessLevel = AccessLevels.CurrentReadOrWrite;
            UserAccessLevel = AccessLevels.CurrentReadOrWrite;
            MinimumSamplingInterval = MinimumSamplingIntervals.Continuous;
            Historizing = false;
        }

        /// <summary>
        /// Returns the id of the default type definition node for the instance.
        /// </summary>
        protected override NodeId GetDefaultTypeDefinitionId(NamespaceTable namespaceUris)
        {
            return VariableTypes.BaseDataVariableType;
        }
        #endregion
        
        #region Public Properties
        /// <summary>
        /// The strings that describe the values for an enumeration.
        /// </summary>
        public PropertyState<LocalizedText[]> EnumStrings
        {
            get
            { 
                return m_enumStrings;  
            }
            
            set
            {
                if (!Object.ReferenceEquals(m_enumStrings, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.Children;
                }

                m_enumStrings = value;
            }
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Populates a list with the children that belong to the node.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="children">The list of children to populate.</param>
        public override void GetChildren(
            ISystemContext context, 
            IList<BaseInstanceState> children)
        {
            if (m_enumStrings != null)
            {
                children.Add(m_enumStrings);
            }

            base.GetChildren(context, children);
        }

        /// <summary>
        /// Finds the child with the specified browse name.
        /// </summary>
        protected override BaseInstanceState FindChild(
            ISystemContext context,
            QualifiedName browseName,
            bool createOrReplace,
            BaseInstanceState replacement)
        {
            if (QualifiedName.IsNull(browseName))
            {
                return null;
            }

            BaseInstanceState instance = null;

            switch (browseName.Name)
            {
                case BrowseNames.EnumStrings:
                {
                    if (createOrReplace)
                    {
                        if (EnumStrings == null)
                        {
                            if (replacement == null)
                            {
                                EnumStrings = new PropertyState<LocalizedText[]>(this);
                            }
                            else
                            {
                                EnumStrings = (PropertyState<LocalizedText[]>)replacement;
                            }
                        }
                    }

                    instance = EnumStrings;
                    break;
                }
            }

            if (instance != null)
            {
                return instance;
            }

            return base.FindChild(context, browseName, createOrReplace, replacement);
        }
        #endregion

        #region Private Fields
        private PropertyState<LocalizedText[]> m_enumStrings;
        #endregion
    }

    /// <summary> 
    /// A typed base class for all data variable nodes.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class BaseDataVariableState<T> : BaseDataVariableState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        public BaseDataVariableState(NodeState parent) : base(parent)
        {
            Value = default(T);
            IsValueType = !typeof(T).GetTypeInfo().IsValueType;
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        /// <param name="context">An object that describes how access the system containing the data. </param>
        protected override void Initialize(ISystemContext context)
        {
            base.Initialize(context);

            Value = default(T);
            DataType = TypeInfo.GetDataTypeId(typeof(T));
            ValueRank = TypeInfo.GetValueRank(typeof(T));
        }

        /// <summary>
        /// Extracts a value of the specified type from a value stored in a variant.
        /// </summary>
        [Obsolete("Should use the version that takes a ISystemContext (pass null if ISystemContext is not available).")]
        protected override object ExtractValueFromVariant(object value, bool throwOnError)
        {
            return ExtractValueFromVariant<T>(null, value, throwOnError);
        }

        /// <summary>
        /// Extracts a value of the specified type from a value stored in a variant.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="value">The value.</param>
        /// <param name="throwOnError">if set to <c>true</c> throw an exception on error.</param>
        /// <remarks>
        /// If throwOnError is false the default value for the type is returned if the value is not valid.
        /// </remarks>
        /// <returns>Returns value of the <c>T</c> type</returns>
        protected override object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return ExtractValueFromVariant<T>(context, value, throwOnError);
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public new T Value
        {
            get
            {
                return CheckTypeBeforeCast<T>(base.Value, true);
            }
            
            set 
            { 
                base.Value = value; 
            }
        }
        #endregion
    }

    #region BaseVariableValue Class
    /// <summary>
    /// A thread safe object that can be used to access the value of a structure variable.
    /// </summary>
    public class BaseVariableValue
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with a synchronization object.
        /// </summary>
        public BaseVariableValue(object dataLock)
        {
            m_lock = dataLock;
            m_copyPolicy = VariableCopyPolicy.CopyOnRead;

            if (m_lock == null)
            {
                m_lock = new object();
            }
        }
        #endregion

        #region Public Members
        /// <summary>
        /// An object used to synchronize access to the value.
        /// </summary>
        public object Lock
        {
            get { return m_lock; }
        }

        /// <summary>
        /// The behavior to use when reading or writing all or part of the object.
        /// </summary>
        public VariableCopyPolicy CopyPolicy
        {
            get { return m_copyPolicy; }
            set { m_copyPolicy = value; }
        }

        /// <summary>
        /// Gets or sets the current error state.
        /// </summary>
        public ServiceResult Error
        {
            get { return m_error; }
            set { m_error = value; }
        }

        /// <summary>
        /// Gets or sets the timestamp associated with the value.
        /// </summary>
        public DateTime Timestamp
        {
            get { return m_timestamp; }
            set { m_timestamp = value; }
        }

        /// <summary>
        /// Clears the change masks for all nodes in the update list.
        /// </summary>
        public void ChangesComplete(ISystemContext context)
        {
            lock (m_lock)
            {
                if (m_updateList != null)
                {
                    for (int ii = 0; ii < m_updateList.Length; ii++)
                    {
                        BaseInstanceState instance = m_updateList[ii];

                        if (instance != null)
                        {
                            instance.UpdateChangeMasks(NodeStateChangeMasks.Value);
                            instance.ClearChangeMasks(context, false);
                        }
                    }
                }
            }
        }
        #endregion
        
        #region Event Callbacks
        /// <summary>
        /// Raised before the value is read.
        /// </summary>
        public VariableValueEventHandler OnBeforeRead;

        /// <summary>
        /// Raised after the value is written.
        /// </summary>
        public VariableValueEventHandler OnAfterWrite;
        #endregion

        #region Protected Methods
        /// <summary>
        /// Does any processing before a read operation takes place.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="node">The node.</param>
        protected void DoBeforeReadProcessing(
            ISystemContext context,
            NodeState node)
        {
            if (OnBeforeRead != null)
            {
                OnBeforeRead(context, this, node);
            }
        }

        /// <summary>
        /// Reads the value or a component of the value.
        /// </summary>
        protected ServiceResult Read(
            ISystemContext context,
            NodeState node,
            NumericRange indexRange,
            QualifiedName dataEncoding,
            ref object value,
            ref StatusCode statusCode,
            ref DateTime timestamp)
        {
            lock (m_lock)
            {
                // ensure a value timestamp exists.
                if (m_timestamp == DateTime.MinValue)
                {
                    m_timestamp = DateTime.UtcNow;
                }
                   
                timestamp = m_timestamp;

                // check for errors.
                if (ServiceResult.IsBad(m_error))
                {
                    value = null;
                    statusCode = m_error.StatusCode;
                    return m_error;
                }

                // apply the index range and encoding.
                ServiceResult result = BaseVariableState.ApplyIndexRangeAndDataEncoding(
                    context, 
                    indexRange, 
                    dataEncoding, 
                    ref value);

                if (ServiceResult.IsBad(result))
                {
                    statusCode = result.StatusCode;
                    return result;
                }
                
                // apply copy policy
                if ((m_copyPolicy & VariableCopyPolicy.CopyOnRead) != 0)
                {
                    value = Utils.Clone(value);
                }                       
                
                statusCode = StatusCodes.Good;

                return ServiceResult.Good;
            }
        }

        /// <summary>
        /// Reads the current value.
        /// </summary>
        protected ServiceResult Read(object currentValue, ref object valueToRead)
        {
            lock (m_lock)
            {
                if (ServiceResult.IsBad(m_error))
                {
                    valueToRead = null;
                    return m_error;
                }
                
                if ((m_copyPolicy & VariableCopyPolicy.CopyOnRead) != 0)
                {
                    valueToRead = Utils.Clone(currentValue);
                }
                else
                {
                    valueToRead = currentValue;
                }

                return ServiceResult.Good;
            }
        }

        /// <summary>
        /// Writes the current value.
        /// </summary>
        protected object Write(object valueToWrite)
        {
            lock (m_lock)
            {
                if ((m_copyPolicy & VariableCopyPolicy.CopyOnWrite) != 0)
                {
                    return Utils.Clone(valueToWrite);
                }

                return valueToWrite;
            }
        }

        /// <summary>
        /// Sets the list of nodes which are updated when ClearChangeMasks is called.
        /// </summary>
        protected void SetUpdateList(IList<BaseInstanceState> updateList)
        {
            lock (m_lock)
            {
                m_updateList = null;

                if (updateList != null && updateList.Count > 0)
                {
                    m_updateList = new BaseInstanceState[updateList.Count];

                    for (int ii = 0; ii < m_updateList.Length; ii++)
                    {
                        m_updateList[ii] = updateList[ii];

                        // the copy copy is enforced by the value wrapper.
                        BaseVariableState variable = m_updateList[ii] as BaseVariableState;
                        
                        if (variable != null)
                        {
                            variable.CopyPolicy = VariableCopyPolicy.Never;
                        }
                    }
                }
            }
        }
        #endregion

        #region Private Fields
        private object m_lock;
        private VariableCopyPolicy m_copyPolicy;
        private BaseInstanceState[] m_updateList;
        private ServiceResult m_error;
        private DateTime m_timestamp;
        #endregion
    }
    #endregion
    
    /// <summary>
    /// Used to receive notifications when the value attribute is read or written.
    /// </summary>
    public delegate void VariableValueEventHandler(
        ISystemContext context,
        BaseVariableValue variable,
        NodeState component);

    /// <summary>
    /// Specifies the policies to use when handling reads and write to value.
    /// </summary>
    [Flags]
    public enum VariableCopyPolicy
    {
        /// <summary>
        /// The value is copied when is is read.
        /// </summary>
        CopyOnRead = 0x1,

        /// <summary>
        /// The value is copied before it is written.
        /// </summary>
        CopyOnWrite = 0x2,

        /// <summary>
        /// The value is never copied (only useful for value types that do not contain reference types).
        /// </summary>
        Never = 0x0,

        /// <summary>
        /// Data is copied when it is written and when it is read.
        /// </summary>
        Always = 0x3
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.IO;
using System.Runtime.Serialization;
using System.Reflection;
using System.Threading;

namespace Opc.Ua
{
    /// <summary> 
    /// The base class for all variable nodes.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public abstract class BaseVariableState : BaseInstanceState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        /// <param name="parent">The parent node.</param>
        public BaseVariableState(NodeState parent) : base(NodeClass.Variable, parent)
        {
            m_timestamp = DateTime.MinValue;
            m_accessLevel = m_userAccessLevel = AccessLevels.CurrentRead;
            m_copyPolicy = VariableCopyPolicy.CopyOnRead;
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance from another instance.
        /// </summary>
        /// <param name="context">The description how access the system containing the data.</param>
        /// <param name="source">A source node to be copied to this instance.</param>
        protected override void Initialize(ISystemContext context, NodeState source)
        {
            if (source is BaseVariableState instance)
            {
                m_value = ExtractValueFromVariant(context, instance.m_value, false);
                m_timestamp = instance.m_timestamp;
                m_statusCode = instance.m_statusCode;
                m_dataType = instance.m_dataType;
                m_valueRank = instance.m_valueRank;
                m_arrayDimensions = null;
                m_accessLevel = instance.m_accessLevel;
                m_userAccessLevel = instance.m_userAccessLevel;
                m_minimumSamplingInterval = instance.m_minimumSamplingInterval;
                m_historizing = instance.m_historizing;

                if (instance.m_arrayDimensions != null)
                {
                    m_arrayDimensions = new ReadOnlyList<uint>(instance.m_arrayDimensions, true);
                }

                m_value = ExtractValueFromVariant(context, m_value, false);
            }

            base.Initialize(context, source);
        }

        /// <summary>
        /// If overridden returns the id of the default type definition node for the instance.
        /// </summary>
        /// <param name="namespaceUris">The namespace uris.</param>
        /// <returns>Returns the id of the default type definition or <see cref="VariableTypes.BaseVariableType"/></returns> if not overridden
        protected override NodeId GetDefaultTypeDefinitionId(NamespaceTable namespaceUris)
        {
            return VariableTypes.BaseVariableType;
        }

        /// <summary>
        /// If overridden returns the id of the default data type node for the instance.
        /// </summary>
        /// <param name="namespaceUris">The namespace uris.</param>
        /// <returns>
        /// The id <see cref="NodeId"/> of the default data type node for the instance or <see cref="DataTypes.BaseDataType"/> if not overridden.
        /// </returns>
        protected virtual NodeId GetDefaultDataTypeId(NamespaceTable namespaceUris)
        {
            return DataTypes.BaseDataType;
        }

        /// <summary>
        /// If overridden returns the id of the default value rank for the instance.
        /// </summary>
        /// <returns>
        /// The id of the default value rank or <see cref="ValueRanks.Any"/> if not overridden.
        /// </returns>
        protected virtual int GetDefaultValueRank()
        {
            return ValueRanks.Any;
        }

        /// <summary>
        /// Converts a values contained in a variant to the value defined for the variable.
        /// </summary>
        [Obsolete("Should use the version that takes a ISystemContext (pass null if ISystemContext is not available).")]
        protected virtual object ExtractValueFromVariant(object value, bool throwOnError)
        {
            return ExtractValueFromVariant(null, value, throwOnError);
        }

        /// <summary>
        /// Converts a values contained in a variant to the value defined for the variable.
        /// </summary>
        /// <param name="context">The system context.</param>
        /// <param name="value">The value.</param>
        /// <param name="throwOnError">if set to <c>true</c> throw an exception on error.</param>
        /// <returns>If not overridden returns <paramref name="value"/>.</returns>
        protected virtual object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return value;
        }

        /// <summary>
        /// Returns the value after checking if the variable is null.
        /// </summary>
        /// <typeparam name="T">The framework type of value contained in the <paramref name="variable"/>.</typeparam>
        /// <param name="variable">The variable.</param>
        /// <returns>
        /// The value contained by the <paramref name="variable"/> or the default value for the datatype if the variable is null.
        /// </returns>
        public static T GetValue<T>(BaseDataVariableState<T> variable)
        {
            if (variable == null)
            {
                return default(T);
            }

            return variable.Value;
        }

        /// <summary>
        /// Returns the value after checking if the property is null.
        /// </summary>
        /// <typeparam name="T">The type of value contained in the property.</typeparam>
        /// <param name="property">The property.</param>
        /// <returns>
        /// The value. The default value for the datatype if the property is null.
        /// </returns>
        public static T GetValue<T>(PropertyState<T> property)
        {
            if (property == null)
            {
                return default(T);
            }

            return property.Value;
        }

        /// <summary>
        /// Converts a values contained in a variant to the value defined for the variable.
        /// </summary>
        [Obsolete("Should use the version that takes a ISystemContext (pass null if ISystemContext is not available).")]
        public static object ExtractValueFromVariant<T>(object value, bool throwOnError)
        {
            return ExtractValueFromVariant<T>(null, value, throwOnError);
        }

        /// <summary>
        /// Converts a values contained in a variant to the value defined for the variable.
        /// </summary>
        /// <typeparam name="T">The framework type of value contained in this instance.</typeparam>
        /// <param name="context">The context.</param>
        /// <param name="value">The value.</param>
        /// <param name="throwOnError">if set to <c>true</c> throws the <see cref="ServiceResultException"/> on error, otherwise default value for <typeparamref name="T"/> is returned .</param>
        /// <returns>
        /// The value of the <typeparamref name="T"/> type.
        /// </returns>
        /// <remarks>
        /// If throwOnError is <c>false</c> the default value for the type is returned if the value is not valid.
        /// </remarks>
        /// <exception cref="ServiceResultException">If cannot convert <paramref name="value"/>.</exception>
        public static object ExtractValueFromVariant<T>(ISystemContext context, object value, bool throwOnError)
        {
            if (value == null)
            {
                return default(T);
            }

            if (typeof(T).IsInstanceOfType(value))
            {
                return value;
            }

            if (value is ExtensionObject extension)
            {
                if (typeof(T).IsInstanceOfType(extension.Body))
                {
                    return extension.Body;
                }

                if (typeof(IEncodeable).GetTypeInfo().IsAssignableFrom(typeof(T).GetTypeInfo()))
                {
                    return DecodeExtensionObject(context, typeof(T), extension, throwOnError);
                }

                if (throwOnError)
                {
                    throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert {0} to {1}.", value.GetType().Name, typeof(T).Name);
                }

                return default(T);
            }

            Type elementType = typeof(T).GetElementType();

            if (elementType != null)
            {
                // check for array of extensions.

                if (value is IList<ExtensionObject> extensions && typeof(IEncodeable).GetTypeInfo().IsAssignableFrom(elementType.GetTypeInfo()))
                {
                    Array encodeables = Array.CreateInstance(elementType, extensions.Count);

                    for (int ii = 0; ii < extensions.Count; ii++)
                    {
                        if (ExtensionObject.IsNull(extensions[ii]))
                        {
                            encodeables.SetValue(null, ii);
                            continue;
                        }

                        if (elementType.IsInstanceOfType(extensions[ii].Body))
                        {
                            encodeables.SetValue(extensions[ii].Body, ii);
                            continue;
                        }

                        object element = DecodeExtensionObject(context, elementType, extensions[ii], throwOnError);

                        if (element != null)
                        {
                            encodeables.SetValue(element, ii);
                            continue;
                        }

                        if (throwOnError)
                        {
                            throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert ExtensionObject to {0}. Index = {1}", elementType.Name, ii);
                        }
                    }

                    return encodeables;
                }

                // check for array of variants.

                if (value is IList<Variant> variants)
                {
                    // only support conversions to object[].
                    if (elementType != typeof(object))
                    {
                        if (throwOnError)
                        {
                            throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert {0} to {1}.", value.GetType().Name, typeof(T).Name);
                        }
                    }

                    // allocate and copy.
                    object[] objects = new object[variants.Count];

                    for (int ii = 0; ii < variants.Count; ii++)
                    {
                        objects[ii] = variants[ii].Value;
                    }

                    return objects;
                }

                // check for array of uuids.
                if (typeof(Guid).GetTypeInfo().IsAssignableFrom(elementType.GetTypeInfo()))
                {
                    if (value is IList<Uuid> uuids)
                    {
                        Guid[] guids = new Guid[uuids.Count];

                        for (int ii = 0; ii < uuids.Count; ii++)
                        {
                            guids[ii] = (Guid)uuids[ii];
                        }

                        return guids;
                    }
                }

                // check for array of enumeration.
                if (typeof(Enum).GetTypeInfo().IsAssignableFrom(elementType.GetTypeInfo()))
                {
                    if (value is IList<int> values)
                    {
                        Array enums = Array.CreateInstance(elementType, values.Count);

                        for (int ii = 0; ii < values.Count; ii++)
                        {
                            enums.SetValue(values[ii], ii);
                        }

                        return enums;
                    }
                }
            }

            if (typeof(Guid).GetTypeInfo().IsAssignableFrom(typeof(T).GetTypeInfo()))
            {
                if (value is Uuid? uuid)
                {
                    return (Guid)uuid.Value;
                }
            } 
            
            if (typeof(Enum).GetTypeInfo().IsAssignableFrom(typeof(T).GetTypeInfo()))
            {
                if (value is int? number)
                {
                    return (T)(object)number.Value;
                }
            }

            if (throwOnError)
            {
                throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert {0} to {1}.", value.GetType().Name, typeof(T).Name);
            }

            return default(T);
        }

        /// <summary>
        /// Decodes the contents of an extension object.
        /// </summary>
        /// <param name="context">The context (uses ServiceMessageContext.GlobalContext if null).</param>
        /// <param name="targetType">The type that the ExtensionObject must be converted to.</param>
        /// <param name="extension">The ExtensionObject to convert.</param>
        /// <param name="throwOnError">Whether to throw an exception on error.</param>
        /// <returns>The decoded instance. Null on error.</returns>
        public static object DecodeExtensionObject(ISystemContext context, Type targetType, ExtensionObject extension, bool throwOnError)
        {
            if (targetType.IsInstanceOfType(extension.Body))
            {
                return extension.Body;
            }

            if (Activator.CreateInstance(targetType) is IEncodeable instance)
            {
                IDecoder decoder = null;

                ServiceMessageContext messageContext = ServiceMessageContext.GlobalContext;

                if (context != null)
                {
                    messageContext = new ServiceMessageContext();
                    messageContext.NamespaceUris = context.NamespaceUris;
                    messageContext.ServerUris = context.ServerUris;
                    messageContext.Factory = context.EncodeableFactory;
                }

                if (extension.Encoding == ExtensionObjectEncoding.Binary)
                {
                    decoder = new BinaryDecoder(extension.Body as byte[], messageContext);
                }

                else if (extension.Encoding == ExtensionObjectEncoding.Xml)
                {
                    decoder = new XmlDecoder(extension.Body as XmlElement, messageContext);
                }

                if (decoder != null)
                {
                    try
                    {
                        instance.Decode(decoder);
                        return instance;
                    }
                    catch (Exception e)
                    {
                        if (throwOnError)
                        {
                            throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert ExtensionObject to {0}. Error = {1}", targetType.Name, e.Message);
                        }
                    }
                }
            }

            if (throwOnError)
            {
                throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert ExtensionObject to {0}.", targetType.Name);
            }

            return null;
        }

        /// <summary>
        /// Checks the data type of a value before casting it to the type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The framework type of value contained in the variable.</typeparam>
        /// <param name="value">The value.</param>
        /// <param name="throwOnError">if set to <c>true</c> <see cref="ServiceResultException"/> is thrown on error.</param>
        /// <returns>Returns <paramref name="value"/> or default for <typeparamref name="T"/></returns>
        /// <exception cref="ServiceResultException"> if it is impossible to cast the value or the value is null and <see cref="IsValueType"/> for the type <typeparamref name="T"/> returns true. </exception>
        public static T CheckTypeBeforeCast<T>(object value, bool throwOnError)
        {
            if ((value == null && typeof(T).GetTypeInfo().IsValueType) || (value != null && !typeof(T).IsInstanceOfType(value)))
            {
                if (throwOnError)
                {
                    throw ServiceResultException.Create(StatusCodes.BadTypeMismatch, "Cannot convert '{0}' to a {1}.", value, typeof(T).Name);
                }

                return default(T);
            }

            return (T)value;
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public object Value
        {
            get
            {
                return m_value;
            }

            set
            {
                if (value == null && IsValueType)
                {
                    value = ExtractValueFromVariant(null, value, false);
                }

                if (!Object.ReferenceEquals(m_value, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.Value;
                }

                m_value = value;
            }
        }

        /// <summary>
        /// Whether the value can be set to null.
        /// </summary>
        public bool IsValueType
        {
            get { return m_isValueType; }
            set { m_isValueType = value; }
        }

        /// <summary>
        /// The value of the variable as a Variant.
        /// </summary>
        /// <value>The wrapped value as a Variant.</value>
        [DataMember(Name = "Value", Order = 0, IsRequired = false, EmitDefaultValue = false)]
        public Variant WrappedValue
        {
            get
            {
                return new Variant(m_value);
            }

            set
            {
                Value = ExtractValueFromVariant(null, value.Value, false);
            }
        }

        /// <summary>
        /// The timestamp associated with the variable value.
        /// </summary>
        /// <value>The timestamp.</value>
        public DateTime Timestamp
        {
            get
            {
                return m_timestamp;
            }

            set
            {
                if (m_timestamp != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.Value;
                }

                m_timestamp = value;
            }
        }

        /// <summary>
        /// The status code associated with the variable value.
        /// </summary>
        /// <value>The status code.</value>
        public StatusCode StatusCode
        {
            get
            {
                return m_statusCode;
            }

            set
            {
                if (m_statusCode != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.Value;
                }

                m_statusCode = value;
            }
        }

        /// <summary>
        /// The behavior to use when reading or writing all or part of the object.
        /// </summary>
        /// <value>The copy policy that specifies the policies to use when handling reads and write to value.</value>
        /// <remarks>
        /// This value is ignored if the OnReadValue or OnWriteValue event handlers are provided.
        /// </remarks>
        public VariableCopyPolicy CopyPolicy
        {
            get { return m_copyPolicy; }
            set { m_copyPolicy = value; }
        }

        /// <summary>
        /// The data type for the variable value.
        /// </summary>
        /// <value>The type of the data <see cref="NodeId"/>.</value>
        [DataMember(Name = "DataType", Order = 1, IsRequired = false, EmitDefaultValue = false)]
        public NodeId DataType
        {
            get
            {
                return m_dataType;
            }

            set
            {
                if (!Object.ReferenceEquals(m_dataType, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_dataType = value;
            }
        }

        /// <summary>
        /// The number of array dimensions permitted for the variable value.
        /// </summary>
        /// <value>The value rank. </value>
        /// <remarks>Indicates whether the DataType is an array and how many dimensions the array has.</remarks>
        [DataMember(Name = "ValueRank", Order = 2, IsRequired = false, EmitDefaultValue = false)]
        public int ValueRank
        {
            get
            {
                return m_valueRank;
            }

            set
            {
                if (m_valueRank != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_valueRank = value;
            }
        }

        /// <summary>
        /// The number of dimensions for an array values with one or more fixed dimensions.
        /// </summary>
        /// <value>The array dimensions.</value>
        /// <remarks>
        /// If the Value Rank does not identify an array of a specific dimension (i.e. ValueRank &lt;= 0)
        /// the Array Dimensions attribute can either be set to null or the attribute is missing. This behaviour is vendor-specific.
        /// If the Value Rank attribute specifies an array of a specific dimension (i.e. ValueRank &gt; 0) then the Array Dimensions
        /// attribute shall be specified in the table defining the Variable.
        /// </remarks>
        public ReadOnlyList<uint> ArrayDimensions
        {
            get
            {
                return m_arrayDimensions;
            }

            set
            {
                if (!Object.ReferenceEquals(m_arrayDimensions, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_arrayDimensions = value;
            }
        }

        /// <summary>
        /// The type of access available for the variable.
        /// </summary>
        /// <value>The access level.</value>
        [DataMember(Name = "AccessLevel", Order = 4, IsRequired = false, EmitDefaultValue = false)]
        public byte AccessLevel
        {
            get
            {
                return (byte)(m_accessLevel & 0xFF);
            }

            set
            {
                if (AccessLevel != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                // set first 8 bits of AccessLevelEx
                m_accessLevel = (m_accessLevel & 0xFFFFFF00) | value;
            }
        }

        /// <summary>
        /// The type of access granted to the current user.
        /// </summary>
        /// <value>The user access level.</value>
        [DataMember(Name = "UserAccessLevel", Order = 5, IsRequired = false, EmitDefaultValue = false)]
        public byte UserAccessLevel
        {
            get
            {
                return m_userAccessLevel;
            }

            set
            {
                if (m_userAccessLevel != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_userAccessLevel = value;
            }
        }

        /// <summary>
        /// The minimum sampling interval supported by the variable.
        /// </summary>
        /// <value>The minimum sampling interval.</value>
        [DataMember(Name = "MinimumSamplingInterval", Order = 6, IsRequired = false, EmitDefaultValue = false)]
        public double MinimumSamplingInterval
        {
            get
            {
                return m_minimumSamplingInterval;
            }

            set
            {
                if (m_minimumSamplingInterval != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_minimumSamplingInterval = value;
            }
        }

        /// <summary>
        /// Whether the server is archiving the value of the variable.
        /// </summary>
        /// <value><c>true</c> if historizing; otherwise, <c>false</c>.</value>
        [DataMember(Name = "Historizing", Order = 7, IsRequired = false, EmitDefaultValue = false)]
        public bool Historizing
        {
            get
            {
                return m_historizing;
            }

            set
            {
                if (m_historizing != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_historizing = value;
            }
        }

        /// <summary>
        /// A bit mask specifying how the value may be accessed.
        /// </summary>
        /// <value>The extended access level.</value>
        [DataMember(Name = "AccessLevelEx", Order = 8, IsRequired = false, EmitDefaultValue = false)]
        public uint AccessLevelEx
        {
            get
            {
                return m_accessLevel;
            }

            set
            {
                if (m_accessLevel != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_accessLevel = value;
            }
        }
        #endregion

        #region Event Callbacks
        /// <summary>
        /// Raised when the Value attribute is read.
        /// </summary>
        public NodeValueSimpleEventHandler OnSimpleReadValue;

        /// <summary>
        /// Raised when the Value attribute is written.
        /// </summary>
        public NodeValueSimpleEventHandler OnSimpleWriteValue;

        /// <summary>
        /// Raised when the Value attribute is read.
        /// </summary>
        public NodeValueEventHandler OnReadValue;

        /// <summary>
        /// Raised when the Value attribute is written.
        /// </summary>
        public NodeValueEventHandler OnWriteValue;

        /// <summary>
        /// Raised when the DataType attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<NodeId> OnReadDataType;

        /// <summary>
        /// Raised when the DataType attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<NodeId> OnWriteDataType;

        /// <summary>
        /// Raised when the ValueRank attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<int> OnReadValueRank;

        /// <summary>
        /// Raised when the ValueRank attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<int> OnWriteValueRank;

        /// <summary>
        /// Raised when the ArrayDimensions attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<IList<uint>> OnReadArrayDimensions;

        /// <summary>
        /// Raised when the ArrayDimensions attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<IList<uint>> OnWriteArrayDimensions;

        /// <summary>
        /// Raised when the AccessLevel attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<byte> OnReadAccessLevel;

        /// <summary>
        /// Raised when the AccessLevel attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<byte> OnWriteAccessLevel;

        /// <summary>
        /// Raised when the UserAccessLevel attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<byte> OnReadUserAccessLevel;

        /// <summary>
        /// Raised when the UserAccessLevel attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<byte> OnWriteUserAccessLevel;

        /// <summary>
        /// Raised when the MinimumSamplingInterval attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<double> OnReadMinimumSamplingInterval;

        /// <summary>
        /// Raised when the MinimumSamplingInterval attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<double> OnWriteMinimumSamplingInterval;

        /// <summary>
        /// Raised when the Historizing attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<bool> OnReadHistorizing;

        /// <summary>
        /// Raised when the Historizing attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<bool> OnWriteHistorizing;

        /// <summary>
        /// Raised when the AccessLevelEx attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<uint> OnReadAccessLevelEx;

        /// <summary>
        /// Raised when the AccessLevelEx attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<uint> OnWriteAccessLevelEx;
        #endregion

        #region Serialization Functions
        /// <summary>
        /// Exports a copy of the node to a <paramref name="node"/> node provided the <paramref name="node"/> type is compatible with <see cref="VariableNode"/>.
        /// </summary>
        /// <param name="context">The context that describes how access the system containing the data.</param>
        /// <param name="node">The node to be a copy of this instance.</param>
        protected override void Export(ISystemContext context, Node node)
        {
            base.Export(context, node);

            if (node is VariableNode variableNode)
            {
                try
                {
                    variableNode.Value = new Variant(Utils.Clone(this.Value));
                
                    variableNode.DataType = this.DataType;
                    variableNode.ValueRank = this.ValueRank;
                    variableNode.ArrayDimensions = null;

                    if (this.ArrayDimensions != null)
                    {
                        variableNode.ArrayDimensions = new UInt32Collection(this.ArrayDimensions);
                    }

                    variableNode.AccessLevel = this.AccessLevel;
                    variableNode.UserAccessLevel = this.UserAccessLevel;
                    variableNode.MinimumSamplingInterval = this.MinimumSamplingInterval;
                    variableNode.Historizing = this.Historizing;
                }
                catch (Exception e)
                {
                    Utils.Trace(e, "Unexpected error exporting node:" + e.Message);
                }
            }
        }

        /// <summary>
        /// Saves the attributes from this instance to the <paramref name="encoder"/>.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="encoder">The encoder wrapping the stream to write.</param>
        public override void Save(ISystemContext context, XmlEncoder encoder)
        {
            base.Save(context, encoder);

            encoder.PushNamespace(Namespaces.OpcUaXsd);

            if (m_value != null)
            {
                encoder.WriteVariant("Value", WrappedValue);
            }

            if (StatusCode != StatusCodes.Good)
            {
                encoder.WriteStatusCode("StatusCode", StatusCode);
            }

            if (!NodeId.IsNull(DataType))
            {
                encoder.WriteNodeId("DataType", DataType);
            }

            if (ValueRank != ValueRanks.Any)
            {
                encoder.WriteInt32("ValueRank", ValueRank);
            }

            if (ArrayDimensions != null)
            {
                encoder.WriteString("ArrayDimensions", ArrayDimensionsToXml(ArrayDimensions));
            }

            if (AccessLevel != 0)
            {
                encoder.WriteByte("AccessLevel", AccessLevel);
            }

            if (UserAccessLevel != 0)
            {
                encoder.WriteByte("UserAccessLevel", UserAccessLevel);
            }

            if (MinimumSamplingInterval != 0)
            {
                encoder.WriteDouble("MinimumSamplingInterval", MinimumSamplingInterval);
            }

            if (Historizing)
            {
                encoder.WriteBoolean("Historizing", Historizing);
            }

            encoder.PopNamespace();
        }

        /// <summary>
        /// Updates the attributes from the <paramref name="decoder"/>.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="decoder">The decoder wrapping the stream to read.</param>
        public override void Update(ISystemContext context, XmlDecoder decoder)
        {
            base.Update(context, decoder);

            decoder.PushNamespace(Namespaces.OpcUaXsd);

            if (decoder.Peek("Value"))
            {
                WrappedValue = decoder.ReadVariant("Value");
            }

            if (decoder.Peek("Timestamp"))
            {
                Timestamp = decoder.ReadDateTime("Timestamp");
            }

            if (decoder.Peek("StatusCode"))
            {
                StatusCode = decoder.ReadStatusCode("StatusCode");
            }
            else
            {
                StatusCode = StatusCodes.Good;
            }

            if (decoder.Peek("DataType"))
            {
                DataType = decoder.ReadNodeId("DataType");
            }

            if (decoder.Peek("ValueRank"))
            {
                ValueRank = decoder.ReadInt32("ValueRank");
            }

            // ensure the value has a suitable default value.
            if (m_value == null && m_valueRank == ValueRanks.Scalar)
            {
                bool isValueType = IsValueType;

                if (!isValueType)
                {
                    BuiltInType builtInType = DataTypes.GetBuiltInType(m_dataType, context.TypeTable);

                    if (TypeInfo.IsValueType(builtInType))
                    {
                        isValueType = true;
                    }
                }

                if (isValueType)
                {
                    m_value = TypeInfo.GetDefaultValue(m_dataType, m_valueRank, context.TypeTable);
                }
            }

            if (decoder.Peek("ArrayDimensions"))
            {
                ArrayDimensions = ArrayDimensionsFromXml(decoder.ReadString("ArrayDimensions"));
            }

            if (decoder.Peek("AccessLevel"))
            {
                AccessLevel = decoder.ReadByte("AccessLevel");
            }

            if (decoder.Peek("UserAccessLevel"))
            {
                UserAccessLevel = decoder.ReadByte("UserAccessLevel");
            }

            if (decoder.Peek("MinimumSamplingInterval"))
            {
                MinimumSamplingInterval = decoder.ReadDouble("MinimumSamplingInterval");
            }

            if (decoder.Peek("Historizing"))
            {
                Historizing = decoder.ReadBoolean("Historizing");
            }

            decoder.PopNamespace();
        }

        /// <summary>
        /// Returns a mask which indicates which attributes have non-default value.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <returns>
        /// A mask that specifies the available attributes.
        /// </returns>
        public override AttributesToSave GetAttributesToSave(ISystemContext context)
        {
            AttributesToSave attributesToSave = base.GetAttributesToSave(context);

            if (m_value != null)
            {
                attributesToSave |= AttributesToSave.Value;
            }

            if (m_statusCode != StatusCodes.Good)
            {
                attributesToSave |= AttributesToSave.StatusCode;
            }

            if (!NodeId.IsNull(m_dataType))
            {
                attributesToSave |= AttributesToSave.DataType;
            }

            if (m_valueRank != ValueRanks.Any)
            {
                attributesToSave |= AttributesToSave.ValueRank;
            }

            if (m_arrayDimensions != null)
            {
                attributesToSave |= AttributesToSave.ArrayDimensions;
            }

            if (m_accessLevel != 0)
            {
                attributesToSave |= AttributesToSave.AccessLevel;
            }

            if (m_userAccessLevel != 0)
            {
                attributesToSave |= AttributesToSave.UserAccessLevel;
            }

            if (m_minimumSamplingInterval != 0)
            {
                attributesToSave |= AttributesToSave.MinimumSamplingInterval;
            }

            if (m_historizing)
            {
                attributesToSave |= AttributesToSave.Historizing;
            }
            
            return attributesToSave;
        }

        /// <summary>
        /// Saves object in an binary stream.
        /// </summary>
        /// <param name="context">The context that describes how access the system containing the data..</param>
        /// <param name="encoder">The encoder to write to.</param>
        /// <param name="attributesToSave">The masks indicating what attributes to write.</param>
        public override void Save(ISystemContext context, BinaryEncoder encoder, AttributesToSave attributesToSave)
        {
            base.Save(context, encoder, attributesToSave);

            if ((attributesToSave & AttributesToSave.Value) != 0)
            {
                encoder.WriteVariant(null, WrappedValue);
            }

            if ((attributesToSave & AttributesToSave.StatusCode) != 0)
            {
                encoder.WriteStatusCode(null, m_statusCode);
            }

            if ((attributesToSave & AttributesToSave.DataType) != 0)
            {
                encoder.WriteNodeId(null, m_dataType);
            }

            if ((attributesToSave & AttributesToSave.ValueRank) != 0)
            {
                encoder.WriteInt32(null, m_valueRank);
            }

            if ((attributesToSave & AttributesToSave.ArrayDimensions) != 0)
            {
                encoder.WriteUInt32Array(null, m_arrayDimensions);
            }

            if ((attributesToSave & AttributesToSave.AccessLevel) != 0)
            {
                encoder.WriteByte(null, AccessLevel);
            }

            if ((attributesToSave & AttributesToSave.UserAccessLevel) != 0)
            {
                encoder.WriteByte(null, m_userAccessLevel);
            }

            if ((attributesToSave & AttributesToSave.MinimumSamplingInterval) != 0)
            {
                encoder.WriteDouble(null, m_minimumSamplingInterval);
            }

            if ((attributesToSave & AttributesToSave.Historizing) != 0)
            {
                encoder.WriteBoolean(null, m_historizing);
            }
        }

        /// <summary>
        /// Updates the attributes of this instance from the <paramref name="decoder"/>.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="decoder">The decoder.</param>
        /// <param name="attibutesToLoad">The attributes to load.</param>
        public override void Update(ISystemContext context, BinaryDecoder decoder, AttributesToSave attibutesToLoad)
        {
            base.Update(context, decoder, attibutesToLoad);

            if ((attibutesToLoad & AttributesToSave.Value) != 0)
            {
                WrappedValue = decoder.ReadVariant(null);
            }

            if ((attibutesToLoad & AttributesToSave.StatusCode) != 0)
            {
                m_statusCode = decoder.ReadStatusCode(null);
            }

            if ((attibutesToLoad & AttributesToSave.DataType) != 0)
            {
                m_dataType = decoder.ReadNodeId(null);
            }

            if ((attibutesToLoad & AttributesToSave.ValueRank) != 0)
            {
                m_valueRank = decoder.ReadInt32(null);
            }

            if ((attibutesToLoad & AttributesToSave.ArrayDimensions) != 0)
            {
                UInt32Collection arrayDimensions = decoder.ReadUInt32Array(null);

                if (arrayDimensions != null && arrayDimensions.Count > 0)
                {
                    m_arrayDimensions = new ReadOnlyList<uint>(arrayDimensions);
                }
                else
                {
                    m_arrayDimensions = null;
                }
            }

            if ((attibutesToLoad & AttributesToSave.AccessLevel) != 0)
            {
                AccessLevel = decoder.ReadByte(null);
            }

            if ((attibutesToLoad & AttributesToSave.UserAccessLevel) != 0)
            {
                m_userAccessLevel = decoder.ReadByte(null);
            }

            if ((attibutesToLoad & AttributesToSave.MinimumSamplingInterval) != 0)
            {
                m_minimumSamplingInterval = decoder.ReadDouble(null);
            }

            if ((attibutesToLoad & AttributesToSave.Historizing) != 0)
            {
                m_historizing = decoder.ReadBoolean(null);
            }        
        }

        /// <summary>
        /// Converts the array dimensions to an XML string.
        /// </summary>
        /// <param name="arrayDimensions">The array dimensions.</param>
        /// <returns>The XML string value.</returns>
        internal static string ArrayDimensionsToXml(IList<uint> arrayDimensions)
        {
            if (arrayDimensions == null)
            {
                return null;
            }

            StringBuilder buffer = new StringBuilder();

            for (int ii = 0; ii < arrayDimensions.Count; ii++)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(',');
                }

                buffer.Append(arrayDimensions[ii]);
            }

            return buffer.ToString();
        }

        /// <summary>
        /// Returns a list of the array dimensions.
        /// </summary>
        /// <param name="value">The XML string value.</param>
        /// <returns>The array dimensions list.</returns>
        internal static ReadOnlyList<uint> ArrayDimensionsFromXml(string value)
        {
            if (String.IsNullOrEmpty(value))
            {
                return null;
            }

            string[] fields = value.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

            if (fields == null || fields.Length == 0)
            {
                return null;
            }

            uint[] arrayDimensions = new uint[fields.Length];

            for (int ii = 0; ii < arrayDimensions.Length; ii++)
            {
                try
                {
                    arrayDimensions[ii] = Convert.ToUInt32(fields[ii]);
                }
                catch
                {
                    arrayDimensions[ii] = 0;
                }
            }

            return new ReadOnlyList<uint>(arrayDimensions);
        }
        #endregion
        
        #region Overrridden Methods
        /// <summary>
        /// Recusively sets the status code and timestamp for the node and all child variables.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="statusCode">The status code.</param>
        /// <param name="timestamp">The timestamp. Not updated if set to DateTime.Min</param>
        public override void SetStatusCode(ISystemContext context, StatusCode statusCode, DateTime timestamp)
        {
            base.SetStatusCode(context, statusCode, timestamp);

            StatusCode = statusCode;

            if (timestamp != DateTime.MinValue)
            {
                Timestamp = timestamp;
            }
        }
        #endregion

        #region Read Support Functions

        /// <summary>
        /// Reads the value for any non-value attribute.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="attributeId">The attribute idetifier <see cref="Attributes"/>.</param>
        /// <param name="value">The returned value.</param>
        /// <returns>
        /// An instance of the <see cref="ServiceResult"/> containing the status code and diagnostic info for the operation.
        /// ServiceResult.Good if successful. Detailed error information otherwise.
        /// </returns>
        protected override ServiceResult ReadNonValueAttribute(
            ISystemContext context,
            uint attributeId,
            ref object value)
        {
            ServiceResult result = null;

            switch (attributeId)
            {
                case Attributes.DataType:
                {
                    NodeId dataType = m_dataType;

                    if (OnReadDataType != null)
                    {
                        result = OnReadDataType(context, this, ref dataType);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = dataType;
                    }

                    return result;
                }

                case Attributes.ValueRank:
                {
                    int valueRank = m_valueRank;

                    if (OnReadValueRank != null)
                    {
                        result = OnReadValueRank(context, this, ref valueRank);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = valueRank;
                    }

                    return result;
                }
                
                case Attributes.ArrayDimensions:
                {
                    IList<uint> arrayDimensions = m_arrayDimensions;

                    if (OnReadArrayDimensions != null)
                    {
                        result = OnReadArrayDimensions(context, this, ref arrayDimensions);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = arrayDimensions;
                    }

                    return result;
                }

                case Attributes.AccessLevel:
                {
                    byte accessLevel = AccessLevel;

                    if (OnReadAccessLevel != null)
                    {
                        result = OnReadAccessLevel(context, this, ref accessLevel);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = accessLevel;
                    }

                    return result;
                }

                case Attributes.AccessLevelEx:
                {
                    uint accessLevelEx = m_accessLevel;

                    if (OnReadAccessLevelEx != null)
                    {
                        result = OnReadAccessLevelEx(context, this, ref accessLevelEx);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = accessLevelEx;
                    }

                    return result;
                }

                case Attributes.UserAccessLevel:
                {
                    byte userAccessLevel = m_userAccessLevel;

                    if (OnReadUserAccessLevel != null)
                    {
                        result = OnReadUserAccessLevel(context, this, ref userAccessLevel);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = userAccessLevel;
                    }

                    return result;
                }

                case Attributes.MinimumSamplingInterval:
                {
                    double minimumSamplingInterval = m_minimumSamplingInterval;

                    if (OnReadMinimumSamplingInterval != null)
                    {
                        result = OnReadMinimumSamplingInterval(context, this, ref minimumSamplingInterval);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = minimumSamplingInterval;
                    }

                    return result;
                }

                case Attributes.Historizing:
                {
                    bool historizing = m_historizing;

                    if (OnReadHistorizing != null)
                    {
                        result = OnReadHistorizing(context, this, ref historizing);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = historizing;
                    }

                    return result;
                }
            }

            return base.ReadNonValueAttribute(context, attributeId, ref value);
        }

        /// <summary>
        /// Reads the value for the value attribute.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="indexRange">The index range.</param>
        /// <param name="dataEncoding">The data encoding.</param>
        /// <param name="value">The value to be returned.</param>
        /// <param name="sourceTimestamp">The source timestamp.</param>
        /// <returns>
        /// An instance of the <see cref="ServiceResult"/> containing the status code and diagnostic info for the operation.
        /// ServiceResult.Good if successful. Detailed error information otherwise.
        /// </returns>
        protected override ServiceResult ReadValueAttribute(
            ISystemContext context,
            NumericRange indexRange,
            QualifiedName dataEncoding,
            ref object value,
            ref DateTime sourceTimestamp)
        {
            // check the access level for the variable.
            if ((m_accessLevel & AccessLevels.CurrentRead) == 0)
            {
                return StatusCodes.BadNotReadable;
            }

            if ((m_userAccessLevel & AccessLevels.CurrentRead) == 0)
            {
                return StatusCodes.BadUserAccessDenied;
            }

            // ensure a value timestamp exists.
            if (m_timestamp == DateTime.MinValue)
            {
                m_timestamp = DateTime.UtcNow;
            }

            value = m_value;
            sourceTimestamp = m_timestamp;
            StatusCode statusCode = m_statusCode;

            ServiceResult result = null;

            // check if the read behavior has been overridden.
            if (OnReadValue != null)
            {
                result = OnReadValue(
                    context,
                    this,
                    indexRange,
                    dataEncoding,
                    ref value,
                    ref statusCode,
                    ref sourceTimestamp);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }

                // return the correct status code if no errors.
                if (ServiceResult.IsGood(result) && statusCode != StatusCodes.Good)
                {
                    result = statusCode;
                }

                return result;
            }

            // use default behavior.
            if (OnSimpleReadValue != null)
            {
                result = OnSimpleReadValue(
                    context,
                    this,
                    ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
            }
            
            // apply the index range and encoding.
            result = ApplyIndexRangeAndDataEncoding(context, indexRange, dataEncoding, ref value);

            if (ServiceResult.IsBad(result))
            {
                return result;
            }

            // copy returned value.
            if (m_copyPolicy == VariableCopyPolicy.CopyOnRead || m_copyPolicy == VariableCopyPolicy.Always)
            {
                value = Utils.Clone(value);
            }

            // return the correct status code if no errors.
            if (ServiceResult.IsGood(result) && statusCode != StatusCodes.Good)
            {
                result = statusCode;
            }

            return result;
        }

        /// <summary>
        /// Applys the index range and the data encoding to the value.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="indexRange">The index range.</param>
        /// <param name="dataEncoding">The data encoding.</param>
        /// <param name="value">The value.</param>
        /// <returns></returns>
        public static ServiceResult ApplyIndexRangeAndDataEncoding(
            ISystemContext context,
            NumericRange indexRange,
            QualifiedName dataEncoding,
            ref object value)
        {
            ServiceResult result = null;

            // apply index range.
            if (indexRange != NumericRange.Empty)
            {
                result = indexRange.ApplyRange(ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
            }

            // apply data encoding.
            if (!QualifiedName.IsNull(dataEncoding))
            {
                ServiceMessageContext messageContext = new ServiceMessageContext();

                messageContext.NamespaceUris = context.NamespaceUris;
                messageContext.ServerUris = context.ServerUris;
                messageContext.Factory = context.EncodeableFactory;

                result = EncodeableObject.ApplyDataEncoding(messageContext, dataEncoding, ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
            }

            return ServiceResult.Good;
        }

        #endregion
        
        #region Write Support Functions
        /// <summary>
        /// Write the value for any non-value attribute.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="attributeId">The attribute id.</param>
        /// <param name="value">The value.</param>
        /// <returns>
        /// An instance of the <see cref="ServiceResult"/> containing the status code and diagnostic info for the operation.
        /// ServiceResult.Good if successful. Detailed error information otherwise.
        /// </returns>
        protected override ServiceResult WriteNonValueAttribute(
            ISystemContext context,
            uint attributeId,
            object value)
        {
            ServiceResult result = null;

            switch (attributeId)
            {
                case Attributes.DataType:
                {
                    NodeId dataType = value as NodeId;

                    if (dataType == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.DataType) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    if (OnWriteDataType != null)
                    {
                        result = OnWriteDataType(context, this, ref dataType);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        DataType = dataType;
                    }

                    return result;
                }

                case Attributes.ValueRank:
                {
                    int? valueRankRef = value as int?;

                    if (valueRankRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.ValueRank) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    int valueRank = valueRankRef.Value;

                    if (OnWriteValueRank != null)
                    {
                        result = OnWriteValueRank(context, this, ref valueRank);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        ValueRank = valueRank;
                    }

                    return result;
                }

                case Attributes.ArrayDimensions:
                {

                    if ((WriteMask & AttributeWriteMask.ArrayDimensions) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    if (OnWriteArrayDimensions != null)
                    {
                        result = OnWriteArrayDimensions(context, this, ref arrayDimensions);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        if (value is IList<uint> arrayDimensions)
                        {
                            ArrayDimensions = new ReadOnlyList<uint>(arrayDimensions);
                        }
                        else
                        {
                            ArrayDimensions = null;
                        }
                    }

                    return result;
                }

                case Attributes.AccessLevel:
                {
                    byte? accessLevelRef = value as byte?;

                    if (accessLevelRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.AccessLevel) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    byte accessLevel = accessLevelRef.Value;

                    if (OnWriteAccessLevel != null)
                    {
                        result = OnWriteAccessLevel(context, this, ref accessLevel);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        AccessLevel = accessLevel;
                    }

                    return result;
                }

                case Attributes.UserAccessLevel:
                {
                    byte? userAccessLevelRef = value as byte?;

                    if (userAccessLevelRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.UserAccessLevel) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    byte userAccessLevel = userAccessLevelRef.Value;

                    if (OnWriteUserAccessLevel != null)
                    {
                        result = OnWriteUserAccessLevel(context, this, ref userAccessLevel);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        UserAccessLevel = userAccessLevel;
                    }

                    return result;
                }

                case Attributes.MinimumSamplingInterval:
                {
                    double? minimumSamplingIntervalRef = value as double?;

                    if (minimumSamplingIntervalRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.MinimumSamplingInterval) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    double minimumSamplingInterval = minimumSamplingIntervalRef.Value;

                    if (OnWriteMinimumSamplingInterval != null)
                    {
                        result = OnWriteMinimumSamplingInterval(context, this, ref minimumSamplingInterval);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        MinimumSamplingInterval = minimumSamplingInterval;
                    }

                    return result;
                }

                case Attributes.Historizing:
                {
                    bool? historizingRef = value as bool?;

                    if (historizingRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.Historizing) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    bool historizing = historizingRef.Value;

                    if (OnWriteHistorizing != null)
                    {
                        result = OnWriteHistorizing(context, this, ref historizing);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        Historizing = historizing;
                    }

                    return result;
                }
            }
            
            return base.WriteNonValueAttribute(context, attributeId, value);
        }

        /// <summary>
        /// Write the value for the value attribute.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="indexRange">The index range.</param>
        /// <param name="value">The value.</param>
        /// <param name="statusCode">The status code.</param>
        /// <param name="sourceTimestamp">The source timestamp.</param>
        /// <returns>
        /// An instance of the <see cref="ServiceResult"/> containing the status code and diagnostic info for the operation.
        /// ServiceResult.Good if successful. Detailed error information otherwise.
        /// </returns>
        protected override ServiceResult WriteValueAttribute(
            ISystemContext context,
            NumericRange indexRange,
            object value,
            StatusCode statusCode,
            DateTime sourceTimestamp)
        {
            ServiceResult result = null;

            // check the access level for the variable.
            if ((m_accessLevel & AccessLevels.CurrentWrite) == 0)
            {
                return StatusCodes.BadNotWritable;
            }

            if ((m_userAccessLevel & AccessLevels.CurrentWrite) == 0)
            {
                return StatusCodes.BadUserAccessDenied;
            }

            // check if the write behavior has been overridden.
            if (OnWriteValue != null)
            {
                result = OnWriteValue(
                    context,
                    this,
                    indexRange,
                    null,
                    ref value,
                    ref statusCode,
                    ref sourceTimestamp);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
                
                m_value = value;
                m_statusCode = statusCode;
                m_timestamp = sourceTimestamp;

                // update timestamp if not set by function.
                if (sourceTimestamp == DateTime.MinValue)
                {
                    m_timestamp = DateTime.UtcNow;
                }

                ChangeMasks |= NodeStateChangeMasks.Value;

                return result;
            }

            // ensure the source timestamp has a valid value.
            if (sourceTimestamp == DateTime.MinValue)
            {
                sourceTimestamp = DateTime.UtcNow;
            }
            
            // verify data type.
            TypeInfo typeInfo = TypeInfo.IsInstanceOfDataType(
                value,
                m_dataType,
                m_valueRank,
                context.NamespaceUris,
                context.TypeTable);

            if (typeInfo == null || typeInfo == TypeInfo.Unknown)
            {
                //if xml element data decoding error appeared : a value of type status code is received with the error code
                if (DataTypeIds.XmlElement == m_dataType)
                {
                    TypeInfo statusCodeTypeInfo = TypeInfo.IsInstanceOfDataType(value,DataTypeIds.UInt32,-1,context.NamespaceUris,context.TypeTable);
                    if (statusCodeTypeInfo != null)
                    {
                        //the error code
                        return (StatusCode)(uint)value;
                    }
                }
                // test for special case Null type
                if (!(m_dataType.IsNullNodeId && value == null))
                {
                    return StatusCodes.BadTypeMismatch;
                }
            }

            value = ExtractValueFromVariant(context, value, true);

            // copy passed in value.
            if (m_copyPolicy == VariableCopyPolicy.CopyOnWrite || m_copyPolicy == VariableCopyPolicy.Always)
            {
                value = Utils.Clone(value);
            }

            // check for simple write value handler.
            if (OnSimpleWriteValue != null)
            {
                // index range writes not supported.
                if (indexRange != NumericRange.Empty)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                result = OnSimpleWriteValue(
                    context,
                    this,
                    ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
            }
            else
            {
                // apply the index range.
                if (indexRange != NumericRange.Empty)
                {
                    object target = m_value;
                    result = indexRange.UpdateRange(ref target, value);

                    if (ServiceResult.IsBad(result))
                    {
                        return result;
                    }

                    value = target;
                }
            }
            
            // update cached values.
            m_value = value;
            m_statusCode = statusCode;
            m_timestamp = sourceTimestamp;

            ChangeMasks |= NodeStateChangeMasks.Value;

            return ServiceResult.Good;
        }
        #endregion

        #region Private Fields
        private object m_value;
        private bool m_isValueType;
        private DateTime m_timestamp;
        private StatusCode m_statusCode;
        private NodeId m_dataType;
        private int m_valueRank;
        private ReadOnlyList<uint> m_arrayDimensions;
        private uint m_accessLevel;
        private byte m_userAccessLevel;
        private double m_minimumSamplingInterval;
        private bool m_historizing;
        private VariableCopyPolicy m_copyPolicy;
        #endregion
    }
    
    /// <summary> 
    /// A typed base class for all data variable nodes.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class PropertyState : BaseVariableState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        public PropertyState(NodeState parent) : base(parent)
        {
        }

        /// <summary>
        /// Constructs an instance of a node.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <returns>The new node.</returns>
        public static NodeState Construct(NodeState parent)
        {
            return new PropertyState(parent);
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            SymbolicName = Utils.Format("{0}_Instance1", Opc.Ua.BrowseNames.PropertyType);
            NodeId = null;
            BrowseName = new QualifiedName(SymbolicName, 1);
            DisplayName = SymbolicName;
            Description = null;
            WriteMask = AttributeWriteMask.None;
            UserWriteMask = AttributeWriteMask.None;
            ReferenceTypeId = Opc.Ua.ReferenceTypeIds.HasProperty;
            TypeDefinitionId = GetDefaultTypeDefinitionId(context.NamespaceUris);
            NumericId = Opc.Ua.VariableTypes.PropertyType;
            Value = null;
            DataType = GetDefaultDataTypeId(context.NamespaceUris);
            ValueRank = GetDefaultValueRank();
            ArrayDimensions = null;
            AccessLevel = AccessLevels.CurrentReadOrWrite;
            UserAccessLevel = AccessLevels.CurrentReadOrWrite;
            MinimumSamplingInterval = MinimumSamplingIntervals.Continuous;
            Historizing = false;
        }

        /// <summary>
        /// Returns the id of the default type definition node for the instance.
        /// </summary>
        protected override NodeId GetDefaultTypeDefinitionId(NamespaceTable namespaceUris)
        {
            return VariableTypes.PropertyType;
        }
        #endregion
    }

    /// <summary> 
    /// A typed base class for all data variable nodes.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class PropertyState<T> : PropertyState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        public PropertyState(NodeState parent) : base(parent)
        {
            Value = default(T);
            IsValueType = !typeof(T).GetTypeInfo().IsValueType;
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            base.Initialize(context);

            Value = default(T);
            DataType = TypeInfo.GetDataTypeId(typeof(T));
            ValueRank = TypeInfo.GetValueRank(typeof(T));
        }

        /// <summary>
        /// Sets the value to its default value if it is not valid.
        /// </summary>
        protected override object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return ExtractValueFromVariant<T>(context, value, throwOnError);
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public new T Value
        {
            get
            {
                return CheckTypeBeforeCast<T>(base.Value, true);
            }

            set
            {
                base.Value = value;
            }
        }
        #endregion
    }
    
    /// <summary> 
    /// A typed base class for all data variable nodes.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class BaseDataVariableState : BaseVariableState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        public BaseDataVariableState(NodeState parent) : base(parent)
        {
            if (parent != null)
            {
                ReferenceTypeId = Opc.Ua.ReferenceTypeIds.HasComponent;
            }
        }

        /// <summary>
        /// Constructs an instance of a node.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <returns>The new node.</returns>
        public static NodeState Construct(NodeState parent)
        {
            return new BaseDataVariableState(parent);
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            SymbolicName = Utils.Format("{0}_Instance1", Opc.Ua.BrowseNames.BaseDataVariableType);
            NodeId = null;
            BrowseName = new QualifiedName(SymbolicName, 1);
            DisplayName = SymbolicName;
            Description = null;
            WriteMask = AttributeWriteMask.None;
            UserWriteMask = AttributeWriteMask.None;
            ReferenceTypeId = Opc.Ua.ReferenceTypeIds.HasComponent;
            TypeDefinitionId = GetDefaultTypeDefinitionId(context.NamespaceUris);
            NumericId = Opc.Ua.VariableTypes.BaseDataVariableType;
            Value = null;
            DataType = GetDefaultDataTypeId(context.NamespaceUris);
            ValueRank = GetDefaultValueRank();
            ArrayDimensions = null;
            AccessLevel = AccessLevels.CurrentReadOrWrite;
            UserAccessLevel = AccessLevels.CurrentReadOrWrite;
            MinimumSamplingInterval = MinimumSamplingIntervals.Continuous;
            Historizing = false;
        }

        /// <summary>
        /// Returns the id of the default type definition node for the instance.
        /// </summary>
        protected override NodeId GetDefaultTypeDefinitionId(NamespaceTable namespaceUris)
        {
            return VariableTypes.BaseDataVariableType;
        }
        #endregion
        
        #region Public Properties
        /// <summary>
        /// The strings that describe the values for an enumeration.
        /// </summary>
        public PropertyState<LocalizedText[]> EnumStrings
        {
            get
            { 
                return m_enumStrings;  
            }
            
            set
            {
                if (!Object.ReferenceEquals(m_enumStrings, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.Children;
                }

                m_enumStrings = value;
            }
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Populates a list with the children that belong to the node.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="children">The list of children to populate.</param>
        public override void GetChildren(
            ISystemContext context, 
            IList<BaseInstanceState> children)
        {
            if (m_enumStrings != null)
            {
                children.Add(m_enumStrings);
            }

            base.GetChildren(context, children);
        }

        /// <summary>
        /// Finds the child with the specified browse name.
        /// </summary>
        protected override BaseInstanceState FindChild(
            ISystemContext context,
            QualifiedName browseName,
            bool createOrReplace,
            BaseInstanceState replacement)
        {
            if (QualifiedName.IsNull(browseName))
            {
                return null;
            }

            BaseInstanceState instance = null;

            switch (browseName.Name)
            {
                case BrowseNames.EnumStrings:
                {
                    if (createOrReplace)
                    {
                        if (EnumStrings == null)
                        {
                            if (replacement == null)
                            {
                                EnumStrings = new PropertyState<LocalizedText[]>(this);
                            }
                            else
                            {
                                EnumStrings = (PropertyState<LocalizedText[]>)replacement;
                            }
                        }
                    }

                    instance = EnumStrings;
                    break;
                }
            }

            if (instance != null)
            {
                return instance;
            }

            return base.FindChild(context, browseName, createOrReplace, replacement);
        }
        #endregion

        #region Private Fields
        private PropertyState<LocalizedText[]> m_enumStrings;
        #endregion
    }

    /// <summary> 
    /// A typed base class for all data variable nodes.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class BaseDataVariableState<T> : BaseDataVariableState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        public BaseDataVariableState(NodeState parent) : base(parent)
        {
            Value = default(T);
            IsValueType = !typeof(T).GetTypeInfo().IsValueType;
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        /// <param name="context">An object that describes how access the system containing the data. </param>
        protected override void Initialize(ISystemContext context)
        {
            base.Initialize(context);

            Value = default(T);
            DataType = TypeInfo.GetDataTypeId(typeof(T));
            ValueRank = TypeInfo.GetValueRank(typeof(T));
        }

        /// <summary>
        /// Extracts a value of the specified type from a value stored in a variant.
        /// </summary>
        [Obsolete("Should use the version that takes a ISystemContext (pass null if ISystemContext is not available).")]
        protected override object ExtractValueFromVariant(object value, bool throwOnError)
        {
            return ExtractValueFromVariant<T>(null, value, throwOnError);
        }

        /// <summary>
        /// Extracts a value of the specified type from a value stored in a variant.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="value">The value.</param>
        /// <param name="throwOnError">if set to <c>true</c> throw an exception on error.</param>
        /// <remarks>
        /// If throwOnError is false the default value for the type is returned if the value is not valid.
        /// </remarks>
        /// <returns>Returns value of the <c>T</c> type</returns>
        protected override object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return ExtractValueFromVariant<T>(context, value, throwOnError);
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public new T Value
        {
            get
            {
                return CheckTypeBeforeCast<T>(base.Value, true);
            }
            
            set 
            { 
                base.Value = value; 
            }
        }
        #endregion
    }

    #region BaseVariableValue Class
    /// <summary>
    /// A thread safe object that can be used to access the value of a structure variable.
    /// </summary>
    public class BaseVariableValue
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with a synchronization object.
        /// </summary>
        public BaseVariableValue(object dataLock)
        {
            m_lock = dataLock;
            m_copyPolicy = VariableCopyPolicy.CopyOnRead;

            if (m_lock == null)
            {
                m_lock = new object();
            }
        }
        #endregion

        #region Public Members
        /// <summary>
        /// An object used to synchronize access to the value.
        /// </summary>
        public object Lock
        {
            get { return m_lock; }
        }

        /// <summary>
        /// The behavior to use when reading or writing all or part of the object.
        /// </summary>
        public VariableCopyPolicy CopyPolicy
        {
            get { return m_copyPolicy; }
            set { m_copyPolicy = value; }
        }

        /// <summary>
        /// Gets or sets the current error state.
        /// </summary>
        public ServiceResult Error
        {
            get { return m_error; }
            set { m_error = value; }
        }

        /// <summary>
        /// Gets or sets the timestamp associated with the value.
        /// </summary>
        public DateTime Timestamp
        {
            get { return m_timestamp; }
            set { m_timestamp = value; }
        }

        /// <summary>
        /// Clears the change masks for all nodes in the update list.
        /// </summary>
        public void ChangesComplete(ISystemContext context)
        {
            lock (m_lock)
            {
                if (m_updateList != null)
                {
                    for (int ii = 0; ii < m_updateList.Length; ii++)
                    {
                        BaseInstanceState instance = m_updateList[ii];

                        if (instance != null)
                        {
                            instance.UpdateChangeMasks(NodeStateChangeMasks.Value);
                            instance.ClearChangeMasks(context, false);
                        }
                    }
                }
            }
        }
        #endregion
        
        #region Event Callbacks
        /// <summary>
        /// Raised before the value is read.
        /// </summary>
        public VariableValueEventHandler OnBeforeRead;

        /// <summary>
        /// Raised after the value is written.
        /// </summary>
        public VariableValueEventHandler OnAfterWrite;
        #endregion

        #region Protected Methods
        /// <summary>
        /// Does any processing before a read operation takes place.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="node">The node.</param>
        protected void DoBeforeReadProcessing(
            ISystemContext context,
            NodeState node)
        {
            if (OnBeforeRead != null)
            {
                OnBeforeRead(context, this, node);
            }
        }

        /// <summary>
        /// Reads the value or a component of the value.
        /// </summary>
        protected ServiceResult Read(
            ISystemContext context,
            NodeState node,
            NumericRange indexRange,
            QualifiedName dataEncoding,
            ref object value,
            ref StatusCode statusCode,
            ref DateTime timestamp)
        {
            lock (m_lock)
            {
                // ensure a value timestamp exists.
                if (m_timestamp == DateTime.MinValue)
                {
                    m_timestamp = DateTime.UtcNow;
                }
                   
                timestamp = m_timestamp;

                // check for errors.
                if (ServiceResult.IsBad(m_error))
                {
                    value = null;
                    statusCode = m_error.StatusCode;
                    return m_error;
                }

                // apply the index range and encoding.
                ServiceResult result = BaseVariableState.ApplyIndexRangeAndDataEncoding(
                    context, 
                    indexRange, 
                    dataEncoding, 
                    ref value);

                if (ServiceResult.IsBad(result))
                {
                    statusCode = result.StatusCode;
                    return result;
                }
                
                // apply copy policy
                if ((m_copyPolicy & VariableCopyPolicy.CopyOnRead) != 0)
                {
                    value = Utils.Clone(value);
                }                       
                
                statusCode = StatusCodes.Good;

                return ServiceResult.Good;
            }
        }

        /// <summary>
        /// Reads the current value.
        /// </summary>
        protected ServiceResult Read(object currentValue, ref object valueToRead)
        {
            lock (m_lock)
            {
                if (ServiceResult.IsBad(m_error))
                {
                    valueToRead = null;
                    return m_error;
                }
                
                if ((m_copyPolicy & VariableCopyPolicy.CopyOnRead) != 0)
                {
                    valueToRead = Utils.Clone(currentValue);
                }
                else
                {
                    valueToRead = currentValue;
                }

                return ServiceResult.Good;
            }
        }

        /// <summary>
        /// Writes the current value.
        /// </summary>
        protected object Write(object valueToWrite)
        {
            lock (m_lock)
            {
                if ((m_copyPolicy & VariableCopyPolicy.CopyOnWrite) != 0)
                {
                    return Utils.Clone(valueToWrite);
                }

                return valueToWrite;
            }
        }

        /// <summary>
        /// Sets the list of nodes which are updated when ClearChangeMasks is called.
        /// </summary>
        protected void SetUpdateList(IList<BaseInstanceState> updateList)
        {
            lock (m_lock)
            {
                m_updateList = null;

                if (updateList != null && updateList.Count > 0)
                {
                    m_updateList = new BaseInstanceState[updateList.Count];

                    for (int ii = 0; ii < m_updateList.Length; ii++)
                    {
                        m_updateList[ii] = updateList[ii];

                        // the copy copy is enforced by the value wrapper.
                        
                        if (m_updateList[ii] is BaseVariableState variable)
                        {
                            variable.CopyPolicy = VariableCopyPolicy.Never;
                        }
                    }
                }
            }
        }
        #endregion

        #region Private Fields
        private object m_lock;
        private VariableCopyPolicy m_copyPolicy;
        private BaseInstanceState[] m_updateList;
        private ServiceResult m_error;
        private DateTime m_timestamp;
        #endregion
    }
    #endregion
    
    /// <summary>
    /// Used to receive notifications when the value attribute is read or written.
    /// </summary>
    public delegate void VariableValueEventHandler(
        ISystemContext context,
        BaseVariableValue variable,
        NodeState component);

    /// <summary>
    /// Specifies the policies to use when handling reads and write to value.
    /// </summary>
    [Flags]
    public enum VariableCopyPolicy
    {
        /// <summary>
        /// The value is copied when is is read.
        /// </summary>
        CopyOnRead = 0x1,

        /// <summary>
        /// The value is copied before it is written.
        /// </summary>
        CopyOnWrite = 0x2,

        /// <summary>
        /// The value is never copied (only useful for value types that do not contain reference types).
        /// </summary>
        Never = 0x0,

        /// <summary>
        /// Data is copied when it is written and when it is read.
        /// </summary>
        Always = 0x3
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableState.cs(14,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableState.cs(18,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableState.cs(21,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableState.cs(321,30): error CS8116: It is not legal to use nullable type 'Uuid?' in a pattern; use the underlying type 'Uuid' instead.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableState.cs(329,30): error CS8116: It is not legal to use nullable type 'int?' in a pattern; use the underlying type 'int' instead.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableState.cs(1686,76): error CS0103: The name 'arrayDimensions' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableState.cs(21,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableState.cs(14,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableState.cs(18,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 16 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableTypeState.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua
{
    /// <summary> 
    /// The base class for all variable type nodes.
    /// </summary>
    public abstract class BaseVariableTypeState : BaseTypeState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        protected BaseVariableTypeState() : base(NodeClass.VariableType)
        {
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance from another instance.
        /// </summary>
        protected override void Initialize(ISystemContext context, NodeState source)
        {
            BaseVariableTypeState type = source as BaseVariableTypeState;

            if (type != null)
            {
                m_value = Utils.Clone(type.m_value);
                m_dataType = type.m_dataType;
                m_valueRank = type.m_valueRank;
                m_arrayDimensions = null;

                if (type.m_arrayDimensions != null)
                {
                    m_arrayDimensions = new ReadOnlyList<uint>(type.m_arrayDimensions, true);
                }
            }

            m_value = ExtractValueFromVariant(context, m_value, false);

            base.Initialize(context, source);
        }

        /// <summary>
        /// Sets the value to its default value if it is not valid.
        /// </summary>
        protected virtual object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return value;
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public object Value
        {
            get
            {
                return m_value;
            }

            set
            {
                if (!Object.ReferenceEquals(m_value, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.Value;
                }

                m_value = value;
            }
        }

        /// <summary>
        /// The value of the variable as a Variant.
        /// </summary>
        public Variant WrappedValue
        {
            get 
            { 
                return new Variant(m_value); 
            }
            
            set
            {
                Value = ExtractValueFromVariant(null, value.Value, false);
            }
        }

        /// <summary>
        /// The data type for the variable value.
        /// </summary>
        public NodeId DataType
        {
            get
            {
                return m_dataType;
            }

            set
            {
                if (!Object.ReferenceEquals(m_dataType, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_dataType = value;
            }
        }

        /// <summary>
        /// The number of array dimensions permitted for the variable value.
        /// </summary>
        public int ValueRank
        {
            get
            {
                return m_valueRank;
            }

            set
            {
                if (m_valueRank != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_valueRank = value;
            }
        }

        /// <summary>
        /// The number of dimensions for an array values with one or more fixed dimensions.
        /// </summary>
        public ReadOnlyList<uint> ArrayDimensions
        {
            get
            {
                return m_arrayDimensions;
            }

            set
            {
                if (!Object.ReferenceEquals(m_arrayDimensions, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_arrayDimensions = value;
            }
        }
        #endregion

        #region Event Callbacks
        /// <summary>
        /// Raised when the Value attribute is read.
        /// </summary>
        public NodeValueSimpleEventHandler OnSimpleReadValue;

        /// <summary>
        /// Raised when the Value attribute is written.
        /// </summary>
        public NodeValueSimpleEventHandler OnSimpleWriteValue;

        /// <summary>
        /// Raised when the DataType attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<NodeId> OnReadDataType;

        /// <summary>
        /// Raised when the DataType attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<NodeId> OnWriteDataType;

        /// <summary>
        /// Raised when the ValueRank attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<int> OnReadValueRank;

        /// <summary>
        /// Raised when the ValueRank attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<int> OnWriteValueRank;

        /// <summary>
        /// Raised when the ArrayDimensions attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<IList<uint>> OnReadArrayDimensions;

        /// <summary>
        /// Raised when the ArrayDimensions attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<IList<uint>> OnWriteArrayDimensions;
        #endregion

        #region Serialization Functions
        /// <summary>
        /// Exports a copy of the node to a node table.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="node">The node.</param>
        protected override void Export(ISystemContext context, Node node)
        {
            base.Export(context, node);

            VariableTypeNode variableTypeNode = node as VariableTypeNode;

            if (variableTypeNode != null)
            {
                variableTypeNode.Value = new Variant(Utils.Clone(this.Value));
                variableTypeNode.DataType = this.DataType;
                variableTypeNode.ValueRank = this.ValueRank;
                variableTypeNode.ArrayDimensions = null;

                if (this.ArrayDimensions != null)
                {
                    variableTypeNode.ArrayDimensions = new UInt32Collection(this.ArrayDimensions);
                }
            }
        }

        /// <summary>
        /// Saves the attributes from the stream.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="encoder">The encoder wrapping the stream to write.</param>
        public override void Save(ISystemContext context, XmlEncoder encoder)
        {
            base.Save(context, encoder);

            encoder.PushNamespace(Namespaces.OpcUaXsd);

            if (m_value != null)
            {
                encoder.WriteVariant("Value", WrappedValue);
            }

            if (!NodeId.IsNull(DataType))
            {
                encoder.WriteNodeId("DataType", DataType);
            }

            if (ValueRank != ValueRanks.Any)
            {
                encoder.WriteInt32("ValueRank", ValueRank);
            }

            if (ArrayDimensions != null)
            {
                encoder.WriteString("ArrayDimensions", BaseVariableState.ArrayDimensionsToXml(ArrayDimensions));
            }

            encoder.PopNamespace();
        }

        /// <summary>
        /// Updates the attributes from the stream.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="decoder">The decoder wrapping the stream to read.</param>
        public override void Update(ISystemContext context, XmlDecoder decoder)
        {
            base.Update(context, decoder);

            decoder.PushNamespace(Namespaces.OpcUaXsd);

            if (decoder.Peek("Value"))
            {
                WrappedValue = decoder.ReadVariant("Value");
            }

            if (decoder.Peek("DataType"))
            {
                DataType = decoder.ReadNodeId("DataType");
            }

            if (decoder.Peek("ValueRank"))
            {
                ValueRank = decoder.ReadInt32("ValueRank");
            }

            if (decoder.Peek("ArrayDimensions"))
            {
                ArrayDimensions = BaseVariableState.ArrayDimensionsFromXml(decoder.ReadString("ArrayDimensions"));
            }

            decoder.PopNamespace();
        }

        /// <summary>
        /// Returns a mask which indicates which attributes have non-default value.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <returns>A mask the specifies the available attributes.</returns>
        public override AttributesToSave GetAttributesToSave(ISystemContext context)
        {
            AttributesToSave attributesToSave = base.GetAttributesToSave(context);

            if (WrappedValue != Variant.Null)
            {
                attributesToSave |= AttributesToSave.Value;
            }

            if (!NodeId.IsNull(m_dataType))
            {
                attributesToSave |= AttributesToSave.DataType;
            }

            if (m_valueRank != ValueRanks.Any)
            {
                attributesToSave |= AttributesToSave.ValueRank;
            }

            if (m_arrayDimensions != null)
            {
                attributesToSave |= AttributesToSave.ArrayDimensions;
            }

            return attributesToSave;
        }

        /// <summary>
        /// Saves object in an binary stream.
        /// </summary>
        /// <param name="context">The context user.</param>
        /// <param name="encoder">The encoder to write to.</param>
        /// <param name="attributesToSave">The masks indicating what attributes to write.</param>
        public override void Save(ISystemContext context, BinaryEncoder encoder, AttributesToSave attributesToSave)
        {
            base.Save(context, encoder, attributesToSave);

            if ((attributesToSave & AttributesToSave.Value) != 0)
            {
                encoder.WriteVariant(null, WrappedValue);
            }

            if ((attributesToSave & AttributesToSave.DataType) != 0)
            {
                encoder.WriteNodeId(null, m_dataType);
            }

            if ((attributesToSave & AttributesToSave.ValueRank) != 0)
            {
                encoder.WriteInt32(null, m_valueRank);
            }

            if ((attributesToSave & AttributesToSave.ArrayDimensions) != 0)
            {
                encoder.WriteUInt32Array(null, m_arrayDimensions);
            }
        }

        /// <summary>
        /// Updates the specified context.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="decoder">The decoder.</param>
        /// <param name="attibutesToLoad">The attributes to load.</param>
        public override void Update(ISystemContext context, BinaryDecoder decoder, AttributesToSave attibutesToLoad)
        {
            base.Update(context, decoder, attibutesToLoad);

            if ((attibutesToLoad & AttributesToSave.Value) != 0)
            {
                WrappedValue = decoder.ReadVariant(null);
            }

            if ((attibutesToLoad & AttributesToSave.DataType) != 0)
            {
                m_dataType = decoder.ReadNodeId(null);
            }

            if ((attibutesToLoad & AttributesToSave.ValueRank) != 0)
            {
                m_valueRank = decoder.ReadInt32(null);
            }

            if ((attibutesToLoad & AttributesToSave.ArrayDimensions) != 0)
            {
                UInt32Collection arrayDimensions = decoder.ReadUInt32Array(null);

                if (arrayDimensions != null && arrayDimensions.Count > 0)
                {
                    m_arrayDimensions = new ReadOnlyList<uint>(arrayDimensions);
                }
                else
                {
                    m_arrayDimensions = null;
                }
            }
        }
        #endregion

        #region Read Support Functions
        /// <summary>
        /// Reads the value for any non-value attribute.
        /// </summary>
        protected override ServiceResult ReadNonValueAttribute(
            ISystemContext context,
            uint attributeId,
            ref object value)
        {
            ServiceResult result = null;

            switch (attributeId)
            {
                case Attributes.DataType:
                {
                    NodeId dataType = m_dataType;

                    if (OnReadDataType != null)
                    {
                        result = OnReadDataType(context, this, ref dataType);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = dataType;
                    }

                    return result;
                }

                case Attributes.ValueRank:
                {
                    int valueRank = m_valueRank;

                    if (OnReadValueRank != null)
                    {
                        result = OnReadValueRank(context, this, ref valueRank);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = valueRank;
                    }

                    return result;
                }

                case Attributes.ArrayDimensions:
                {
                    IList<uint> arrayDimensions = m_arrayDimensions;

                    if (OnReadArrayDimensions != null)
                    {
                        result = OnReadArrayDimensions(context, this, ref arrayDimensions);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = arrayDimensions;
                    }

                    return result;
                }
            }

            return base.ReadNonValueAttribute(context, attributeId, ref value);
        }

        /// <summary>
        /// Reads the value for the value attribute.
        /// </summary>
        protected override ServiceResult ReadValueAttribute(
            ISystemContext context,
            NumericRange indexRange,
            QualifiedName dataEncoding,
            ref object value,
            ref DateTime sourceTimestamp)
        {  
            value = m_value;

            ServiceResult result = ServiceResult.Good;

            VariableCopyPolicy copyPolicy = VariableCopyPolicy.CopyOnRead;

            // use default behavior.
            if (OnSimpleReadValue != null)
            {
                result = OnSimpleReadValue(
                    context,
                    this,
                    ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }

                copyPolicy = VariableCopyPolicy.Never;
            }
            else
            {
                // check if a valid value exists.
                if (value == null)
                {
                    return StatusCodes.BadAttributeIdInvalid;
                }
            }
            
            // apply the index range and encoding.
            result = BaseVariableState.ApplyIndexRangeAndDataEncoding(context, indexRange, dataEncoding, ref value);

            if (ServiceResult.IsBad(result))
            {
                return result;
            }

            // copy returned value.
            if (copyPolicy == VariableCopyPolicy.CopyOnRead)
            {
                value = Utils.Clone(value);
            }

            return result;
        }
        #endregion

        #region Write Support Functions
        /// <summary>
        /// Write the value for any non-value attribute.
        /// </summary>
        protected override ServiceResult WriteNonValueAttribute(
            ISystemContext context,
            uint attributeId,
            object value)
        {
            ServiceResult result = null;

            switch (attributeId)
            {
                case Attributes.DataType:
                {
                    NodeId dataType = value as NodeId;

                    if (dataType == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.DataType) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    if (OnWriteDataType != null)
                    {
                        result = OnWriteDataType(context, this, ref dataType);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        DataType = dataType;
                    }

                    return result;
                }

                case Attributes.ValueRank:
                {
                    int? valueRankRef = value as int?;

                    if (valueRankRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.ValueRank) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    int valueRank = valueRankRef.Value;

                    if (OnWriteValueRank != null)
                    {
                        result = OnWriteValueRank(context, this, ref valueRank);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                       ValueRank = valueRank;
                    }

                    return result;
                }

                case Attributes.ArrayDimensions:
                {
                    IList<uint> arrayDimensions = value as IList<uint>;

                    if ((WriteMask & AttributeWriteMask.ArrayDimensions) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    if (OnWriteArrayDimensions != null)
                    {
                        result = OnWriteArrayDimensions(context, this, ref arrayDimensions);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        if (arrayDimensions != null)
                        {
                            m_arrayDimensions = new ReadOnlyList<uint>(arrayDimensions);
                        }
                        else
                        {
                            ArrayDimensions = null;
                        }
                    }

                    return result;
                }
            }

            return base.WriteNonValueAttribute(context, attributeId, value);
        }

        /// <summary>
        /// Write the value for the value attribute.
        /// </summary>
        protected override ServiceResult WriteValueAttribute(
            ISystemContext context,
            NumericRange indexRange,
            object value,
            StatusCode statusCode,
            DateTime sourceTimestamp)
        {
            ServiceResult result = null;

            if ((WriteMask & AttributeWriteMask.ValueForVariableType) == 0)
            {
                return StatusCodes.BadNotWritable;
            }

            // ensure the source timestamp has a valid value.
            if (sourceTimestamp == DateTime.MinValue)
            {
                sourceTimestamp = DateTime.UtcNow;
            }

            // index range writes not supported.
            if (indexRange != NumericRange.Empty)
            {
                return StatusCodes.BadIndexRangeInvalid;
            }

            // verify data type.
            TypeInfo typeInfo = TypeInfo.IsInstanceOfDataType(
                value,
                m_dataType,
                m_valueRank,
                context.NamespaceUris,
                context.TypeTable);

            if (typeInfo == null || typeInfo == TypeInfo.Unknown)
            {
                return StatusCodes.BadTypeMismatch;
            }

            // check for simple write value handler.
            if (OnSimpleWriteValue != null)
            {
                result = OnSimpleWriteValue(
                    context,
                    this,
                    ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
            }

            // update cached values.
            Value = value;

            return ServiceResult.Good;
        }
        #endregion
        
        #region Private Fields
        private object m_value;
        private NodeId m_dataType;
        private int m_valueRank;
        private ReadOnlyList<uint> m_arrayDimensions;
        #endregion
    }

    /// <summary> 
    /// A base class for all data variable type nodes.
    /// </summary>
    public class BaseDataVariableTypeState : BaseVariableTypeState
    {
        #region Constructors
        /// <summary>
        /// Initializes the type with its defalt attribute values.
        /// </summary>
        public BaseDataVariableTypeState()
        {
        }

        /// <summary>
        /// Constructs an instance of a node.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <returns>The new node.</returns>
        public static NodeState Construct(NodeState parent)
        {
            return new BaseDataVariableTypeState();
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            SuperTypeId = Opc.Ua.NodeId.Create(Opc.Ua.VariableTypes.BaseVariableType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            NodeId = Opc.Ua.NodeId.Create(Opc.Ua.VariableTypes.BaseDataVariableType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            BrowseName = Opc.Ua.QualifiedName.Create(Opc.Ua.BrowseNames.BaseDataVariableType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            DisplayName = new LocalizedText(Opc.Ua.BrowseNames.BaseDataVariableType, String.Empty, Opc.Ua.BrowseNames.BaseDataVariableType);
            Description = null;
            WriteMask = AttributeWriteMask.None;
            UserWriteMask = AttributeWriteMask.None;
            IsAbstract = false;
            Value = null;
            DataType = Opc.Ua.NodeId.Create(Opc.Ua.DataTypes.BaseDataType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            ValueRank = ValueRanks.Any;
            ArrayDimensions = null;
        }
        #endregion
    }

    /// <summary> 
    /// A typed base class for all data variable type nodes.
    /// </summary>
    public class BaseDataVariableTypeState<T> : BaseDataVariableTypeState
    {
        #region Constructors
        /// <summary>
        /// Initializes the type with its defalt attribute values.
        /// </summary>
        public BaseDataVariableTypeState()
        {
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            base.Initialize(context);

            Value = default(T);
            DataType = TypeInfo.GetDataTypeId(typeof(T));
            ValueRank = TypeInfo.GetValueRank(typeof(T));
        }

        /// <summary>
        /// Sets the value to its default value if it is not valid.
        /// </summary>
        protected override object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return BaseVariableState.ExtractValueFromVariant<T>(context, value, throwOnError);
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public new T Value
        {
            get
            {
                return BaseVariableState.CheckTypeBeforeCast<T>(base.Value, true);
            }

            set
            {
                base.Value = value;
            }
        }
        #endregion
    }

    /// <summary> 
    /// A base class for all property variable type nodes.
    /// </summary>
    public class PropertyTypeState : BaseVariableTypeState
    {
        #region Constructors
        /// <summary>
        /// Initializes the type with its defalt attribute values.
        /// </summary>
        public PropertyTypeState()
        {
        }

        /// <summary>
        /// Constructs an instance of a node.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <returns>The new node.</returns>
        public static NodeState Construct(NodeState parent)
        {
            return new PropertyTypeState();
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            SuperTypeId = Opc.Ua.NodeId.Create(Opc.Ua.VariableTypes.BaseVariableType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            NodeId = Opc.Ua.NodeId.Create(Opc.Ua.VariableTypes.PropertyType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            BrowseName = Opc.Ua.QualifiedName.Create(Opc.Ua.BrowseNames.PropertyType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            DisplayName = new LocalizedText(Opc.Ua.BrowseNames.PropertyType, String.Empty, Opc.Ua.BrowseNames.PropertyType);
            Description = null;
            WriteMask = AttributeWriteMask.None;
            UserWriteMask = AttributeWriteMask.None;
            IsAbstract = false;
            Value = null;
            DataType = Opc.Ua.NodeId.Create(Opc.Ua.DataTypes.BaseDataType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            ValueRank = ValueRanks.Any;
            ArrayDimensions = null;
        }
        #endregion
    }

    /// <summary> 
    /// A typed base class for all property variable type nodes.
    /// </summary>
    public class PropertyTypeState<T> : PropertyTypeState
    {
        #region Constructors
        /// <summary>
        /// Initializes the type with its defalt attribute values.
        /// </summary>
        public PropertyTypeState()
        {
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            base.Initialize(context);

            Value = default(T);
            DataType = TypeInfo.GetDataTypeId(typeof(T));
            ValueRank = TypeInfo.GetValueRank(typeof(T));
        }

        /// <summary>
        /// Sets the value to its default value if it is not valid.
        /// </summary>
        protected override object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return BaseVariableState.ExtractValueFromVariant<T>(context, value, throwOnError);
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public new T Value
        {
            get
            {
                return BaseVariableState.CheckTypeBeforeCast<T>(base.Value, true);
            }

            set
            {
                base.Value = value;
            }
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;

namespace Opc.Ua
{
    /// <summary> 
    /// The base class for all variable type nodes.
    /// </summary>
    public abstract class BaseVariableTypeState : BaseTypeState
    {
        #region Constructors
        /// <summary>
        /// Initializes the instance with its defalt attribute values.
        /// </summary>
        protected BaseVariableTypeState() : base(NodeClass.VariableType)
        {
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance from another instance.
        /// </summary>
        protected override void Initialize(ISystemContext context, NodeState source)
        {
            if (source is BaseVariableTypeState type)
            {
                m_value = Utils.Clone(type.m_value);
                m_dataType = type.m_dataType;
                m_valueRank = type.m_valueRank;
                m_arrayDimensions = null;

                if (type.m_arrayDimensions != null)
                {
                    m_arrayDimensions = new ReadOnlyList<uint>(type.m_arrayDimensions, true);
                }
            }

            m_value = ExtractValueFromVariant(context, m_value, false);

            base.Initialize(context, source);
        }

        /// <summary>
        /// Sets the value to its default value if it is not valid.
        /// </summary>
        protected virtual object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return value;
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public object Value
        {
            get
            {
                return m_value;
            }

            set
            {
                if (!Object.ReferenceEquals(m_value, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.Value;
                }

                m_value = value;
            }
        }

        /// <summary>
        /// The value of the variable as a Variant.
        /// </summary>
        public Variant WrappedValue
        {
            get 
            { 
                return new Variant(m_value); 
            }
            
            set
            {
                Value = ExtractValueFromVariant(null, value.Value, false);
            }
        }

        /// <summary>
        /// The data type for the variable value.
        /// </summary>
        public NodeId DataType
        {
            get
            {
                return m_dataType;
            }

            set
            {
                if (!Object.ReferenceEquals(m_dataType, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_dataType = value;
            }
        }

        /// <summary>
        /// The number of array dimensions permitted for the variable value.
        /// </summary>
        public int ValueRank
        {
            get
            {
                return m_valueRank;
            }

            set
            {
                if (m_valueRank != value)
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_valueRank = value;
            }
        }

        /// <summary>
        /// The number of dimensions for an array values with one or more fixed dimensions.
        /// </summary>
        public ReadOnlyList<uint> ArrayDimensions
        {
            get
            {
                return m_arrayDimensions;
            }

            set
            {
                if (!Object.ReferenceEquals(m_arrayDimensions, value))
                {
                    ChangeMasks |= NodeStateChangeMasks.NonValue;
                }

                m_arrayDimensions = value;
            }
        }
        #endregion

        #region Event Callbacks
        /// <summary>
        /// Raised when the Value attribute is read.
        /// </summary>
        public NodeValueSimpleEventHandler OnSimpleReadValue;

        /// <summary>
        /// Raised when the Value attribute is written.
        /// </summary>
        public NodeValueSimpleEventHandler OnSimpleWriteValue;

        /// <summary>
        /// Raised when the DataType attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<NodeId> OnReadDataType;

        /// <summary>
        /// Raised when the DataType attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<NodeId> OnWriteDataType;

        /// <summary>
        /// Raised when the ValueRank attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<int> OnReadValueRank;

        /// <summary>
        /// Raised when the ValueRank attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<int> OnWriteValueRank;

        /// <summary>
        /// Raised when the ArrayDimensions attribute is read.
        /// </summary>
        public NodeAttributeEventHandler<IList<uint>> OnReadArrayDimensions;

        /// <summary>
        /// Raised when the ArrayDimensions attribute is written.
        /// </summary>
        public NodeAttributeEventHandler<IList<uint>> OnWriteArrayDimensions;
        #endregion

        #region Serialization Functions
        /// <summary>
        /// Exports a copy of the node to a node table.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="node">The node.</param>
        protected override void Export(ISystemContext context, Node node)
        {
            base.Export(context, node);

            if (node is VariableTypeNode variableTypeNode)
            {
                variableTypeNode.Value = new Variant(Utils.Clone(this.Value));
                variableTypeNode.DataType = this.DataType;
                variableTypeNode.ValueRank = this.ValueRank;
                variableTypeNode.ArrayDimensions = null;

                if (this.ArrayDimensions != null)
                {
                    variableTypeNode.ArrayDimensions = new UInt32Collection(this.ArrayDimensions);
                }
            }
        }

        /// <summary>
        /// Saves the attributes from the stream.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="encoder">The encoder wrapping the stream to write.</param>
        public override void Save(ISystemContext context, XmlEncoder encoder)
        {
            base.Save(context, encoder);

            encoder.PushNamespace(Namespaces.OpcUaXsd);

            if (m_value != null)
            {
                encoder.WriteVariant("Value", WrappedValue);
            }

            if (!NodeId.IsNull(DataType))
            {
                encoder.WriteNodeId("DataType", DataType);
            }

            if (ValueRank != ValueRanks.Any)
            {
                encoder.WriteInt32("ValueRank", ValueRank);
            }

            if (ArrayDimensions != null)
            {
                encoder.WriteString("ArrayDimensions", BaseVariableState.ArrayDimensionsToXml(ArrayDimensions));
            }

            encoder.PopNamespace();
        }

        /// <summary>
        /// Updates the attributes from the stream.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <param name="decoder">The decoder wrapping the stream to read.</param>
        public override void Update(ISystemContext context, XmlDecoder decoder)
        {
            base.Update(context, decoder);

            decoder.PushNamespace(Namespaces.OpcUaXsd);

            if (decoder.Peek("Value"))
            {
                WrappedValue = decoder.ReadVariant("Value");
            }

            if (decoder.Peek("DataType"))
            {
                DataType = decoder.ReadNodeId("DataType");
            }

            if (decoder.Peek("ValueRank"))
            {
                ValueRank = decoder.ReadInt32("ValueRank");
            }

            if (decoder.Peek("ArrayDimensions"))
            {
                ArrayDimensions = BaseVariableState.ArrayDimensionsFromXml(decoder.ReadString("ArrayDimensions"));
            }

            decoder.PopNamespace();
        }

        /// <summary>
        /// Returns a mask which indicates which attributes have non-default value.
        /// </summary>
        /// <param name="context">The context for the system being accessed.</param>
        /// <returns>A mask the specifies the available attributes.</returns>
        public override AttributesToSave GetAttributesToSave(ISystemContext context)
        {
            AttributesToSave attributesToSave = base.GetAttributesToSave(context);

            if (WrappedValue != Variant.Null)
            {
                attributesToSave |= AttributesToSave.Value;
            }

            if (!NodeId.IsNull(m_dataType))
            {
                attributesToSave |= AttributesToSave.DataType;
            }

            if (m_valueRank != ValueRanks.Any)
            {
                attributesToSave |= AttributesToSave.ValueRank;
            }

            if (m_arrayDimensions != null)
            {
                attributesToSave |= AttributesToSave.ArrayDimensions;
            }

            return attributesToSave;
        }

        /// <summary>
        /// Saves object in an binary stream.
        /// </summary>
        /// <param name="context">The context user.</param>
        /// <param name="encoder">The encoder to write to.</param>
        /// <param name="attributesToSave">The masks indicating what attributes to write.</param>
        public override void Save(ISystemContext context, BinaryEncoder encoder, AttributesToSave attributesToSave)
        {
            base.Save(context, encoder, attributesToSave);

            if ((attributesToSave & AttributesToSave.Value) != 0)
            {
                encoder.WriteVariant(null, WrappedValue);
            }

            if ((attributesToSave & AttributesToSave.DataType) != 0)
            {
                encoder.WriteNodeId(null, m_dataType);
            }

            if ((attributesToSave & AttributesToSave.ValueRank) != 0)
            {
                encoder.WriteInt32(null, m_valueRank);
            }

            if ((attributesToSave & AttributesToSave.ArrayDimensions) != 0)
            {
                encoder.WriteUInt32Array(null, m_arrayDimensions);
            }
        }

        /// <summary>
        /// Updates the specified context.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <param name="decoder">The decoder.</param>
        /// <param name="attibutesToLoad">The attributes to load.</param>
        public override void Update(ISystemContext context, BinaryDecoder decoder, AttributesToSave attibutesToLoad)
        {
            base.Update(context, decoder, attibutesToLoad);

            if ((attibutesToLoad & AttributesToSave.Value) != 0)
            {
                WrappedValue = decoder.ReadVariant(null);
            }

            if ((attibutesToLoad & AttributesToSave.DataType) != 0)
            {
                m_dataType = decoder.ReadNodeId(null);
            }

            if ((attibutesToLoad & AttributesToSave.ValueRank) != 0)
            {
                m_valueRank = decoder.ReadInt32(null);
            }

            if ((attibutesToLoad & AttributesToSave.ArrayDimensions) != 0)
            {
                UInt32Collection arrayDimensions = decoder.ReadUInt32Array(null);

                if (arrayDimensions != null && arrayDimensions.Count > 0)
                {
                    m_arrayDimensions = new ReadOnlyList<uint>(arrayDimensions);
                }
                else
                {
                    m_arrayDimensions = null;
                }
            }
        }
        #endregion

        #region Read Support Functions
        /// <summary>
        /// Reads the value for any non-value attribute.
        /// </summary>
        protected override ServiceResult ReadNonValueAttribute(
            ISystemContext context,
            uint attributeId,
            ref object value)
        {
            ServiceResult result = null;

            switch (attributeId)
            {
                case Attributes.DataType:
                {
                    NodeId dataType = m_dataType;

                    if (OnReadDataType != null)
                    {
                        result = OnReadDataType(context, this, ref dataType);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = dataType;
                    }

                    return result;
                }

                case Attributes.ValueRank:
                {
                    int valueRank = m_valueRank;

                    if (OnReadValueRank != null)
                    {
                        result = OnReadValueRank(context, this, ref valueRank);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = valueRank;
                    }

                    return result;
                }

                case Attributes.ArrayDimensions:
                {
                    IList<uint> arrayDimensions = m_arrayDimensions;

                    if (OnReadArrayDimensions != null)
                    {
                        result = OnReadArrayDimensions(context, this, ref arrayDimensions);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        value = arrayDimensions;
                    }

                    return result;
                }
            }

            return base.ReadNonValueAttribute(context, attributeId, ref value);
        }

        /// <summary>
        /// Reads the value for the value attribute.
        /// </summary>
        protected override ServiceResult ReadValueAttribute(
            ISystemContext context,
            NumericRange indexRange,
            QualifiedName dataEncoding,
            ref object value,
            ref DateTime sourceTimestamp)
        {  
            value = m_value;

            ServiceResult result = ServiceResult.Good;

            VariableCopyPolicy copyPolicy = VariableCopyPolicy.CopyOnRead;

            // use default behavior.
            if (OnSimpleReadValue != null)
            {
                result = OnSimpleReadValue(
                    context,
                    this,
                    ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }

                copyPolicy = VariableCopyPolicy.Never;
            }
            else
            {
                // check if a valid value exists.
                if (value == null)
                {
                    return StatusCodes.BadAttributeIdInvalid;
                }
            }
            
            // apply the index range and encoding.
            result = BaseVariableState.ApplyIndexRangeAndDataEncoding(context, indexRange, dataEncoding, ref value);

            if (ServiceResult.IsBad(result))
            {
                return result;
            }

            // copy returned value.
            if (copyPolicy == VariableCopyPolicy.CopyOnRead)
            {
                value = Utils.Clone(value);
            }

            return result;
        }
        #endregion

        #region Write Support Functions
        /// <summary>
        /// Write the value for any non-value attribute.
        /// </summary>
        protected override ServiceResult WriteNonValueAttribute(
            ISystemContext context,
            uint attributeId,
            object value)
        {
            ServiceResult result = null;

            switch (attributeId)
            {
                case Attributes.DataType:
                {
                    NodeId dataType = value as NodeId;

                    if (dataType == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.DataType) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    if (OnWriteDataType != null)
                    {
                        result = OnWriteDataType(context, this, ref dataType);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        DataType = dataType;
                    }

                    return result;
                }

                case Attributes.ValueRank:
                {
                    int? valueRankRef = value as int?;

                    if (valueRankRef == null)
                    {
                        return StatusCodes.BadTypeMismatch;
                    }

                    if ((WriteMask & AttributeWriteMask.ValueRank) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    int valueRank = valueRankRef.Value;

                    if (OnWriteValueRank != null)
                    {
                        result = OnWriteValueRank(context, this, ref valueRank);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                       ValueRank = valueRank;
                    }

                    return result;
                }

                case Attributes.ArrayDimensions:
                {

                    if ((WriteMask & AttributeWriteMask.ArrayDimensions) == 0)
                    {
                        return StatusCodes.BadNotWritable;
                    }

                    if (OnWriteArrayDimensions != null)
                    {
                        result = OnWriteArrayDimensions(context, this, ref arrayDimensions);
                    }

                    if (ServiceResult.IsGood(result))
                    {
                        if (value is IList<uint> arrayDimensions)
                        {
                            m_arrayDimensions = new ReadOnlyList<uint>(arrayDimensions);
                        }
                        else
                        {
                            ArrayDimensions = null;
                        }
                    }

                    return result;
                }
            }

            return base.WriteNonValueAttribute(context, attributeId, value);
        }

        /// <summary>
        /// Write the value for the value attribute.
        /// </summary>
        protected override ServiceResult WriteValueAttribute(
            ISystemContext context,
            NumericRange indexRange,
            object value,
            StatusCode statusCode,
            DateTime sourceTimestamp)
        {
            ServiceResult result = null;

            if ((WriteMask & AttributeWriteMask.ValueForVariableType) == 0)
            {
                return StatusCodes.BadNotWritable;
            }

            // ensure the source timestamp has a valid value.
            if (sourceTimestamp == DateTime.MinValue)
            {
                sourceTimestamp = DateTime.UtcNow;
            }

            // index range writes not supported.
            if (indexRange != NumericRange.Empty)
            {
                return StatusCodes.BadIndexRangeInvalid;
            }

            // verify data type.
            TypeInfo typeInfo = TypeInfo.IsInstanceOfDataType(
                value,
                m_dataType,
                m_valueRank,
                context.NamespaceUris,
                context.TypeTable);

            if (typeInfo == null || typeInfo == TypeInfo.Unknown)
            {
                return StatusCodes.BadTypeMismatch;
            }

            // check for simple write value handler.
            if (OnSimpleWriteValue != null)
            {
                result = OnSimpleWriteValue(
                    context,
                    this,
                    ref value);

                if (ServiceResult.IsBad(result))
                {
                    return result;
                }
            }

            // update cached values.
            Value = value;

            return ServiceResult.Good;
        }
        #endregion
        
        #region Private Fields
        private object m_value;
        private NodeId m_dataType;
        private int m_valueRank;
        private ReadOnlyList<uint> m_arrayDimensions;
        #endregion
    }

    /// <summary> 
    /// A base class for all data variable type nodes.
    /// </summary>
    public class BaseDataVariableTypeState : BaseVariableTypeState
    {
        #region Constructors
        /// <summary>
        /// Initializes the type with its defalt attribute values.
        /// </summary>
        public BaseDataVariableTypeState()
        {
        }

        /// <summary>
        /// Constructs an instance of a node.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <returns>The new node.</returns>
        public static NodeState Construct(NodeState parent)
        {
            return new BaseDataVariableTypeState();
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            SuperTypeId = Opc.Ua.NodeId.Create(Opc.Ua.VariableTypes.BaseVariableType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            NodeId = Opc.Ua.NodeId.Create(Opc.Ua.VariableTypes.BaseDataVariableType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            BrowseName = Opc.Ua.QualifiedName.Create(Opc.Ua.BrowseNames.BaseDataVariableType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            DisplayName = new LocalizedText(Opc.Ua.BrowseNames.BaseDataVariableType, String.Empty, Opc.Ua.BrowseNames.BaseDataVariableType);
            Description = null;
            WriteMask = AttributeWriteMask.None;
            UserWriteMask = AttributeWriteMask.None;
            IsAbstract = false;
            Value = null;
            DataType = Opc.Ua.NodeId.Create(Opc.Ua.DataTypes.BaseDataType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            ValueRank = ValueRanks.Any;
            ArrayDimensions = null;
        }
        #endregion
    }

    /// <summary> 
    /// A typed base class for all data variable type nodes.
    /// </summary>
    public class BaseDataVariableTypeState<T> : BaseDataVariableTypeState
    {
        #region Constructors
        /// <summary>
        /// Initializes the type with its defalt attribute values.
        /// </summary>
        public BaseDataVariableTypeState()
        {
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            base.Initialize(context);

            Value = default(T);
            DataType = TypeInfo.GetDataTypeId(typeof(T));
            ValueRank = TypeInfo.GetValueRank(typeof(T));
        }

        /// <summary>
        /// Sets the value to its default value if it is not valid.
        /// </summary>
        protected override object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return BaseVariableState.ExtractValueFromVariant<T>(context, value, throwOnError);
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public new T Value
        {
            get
            {
                return BaseVariableState.CheckTypeBeforeCast<T>(base.Value, true);
            }

            set
            {
                base.Value = value;
            }
        }
        #endregion
    }

    /// <summary> 
    /// A base class for all property variable type nodes.
    /// </summary>
    public class PropertyTypeState : BaseVariableTypeState
    {
        #region Constructors
        /// <summary>
        /// Initializes the type with its defalt attribute values.
        /// </summary>
        public PropertyTypeState()
        {
        }

        /// <summary>
        /// Constructs an instance of a node.
        /// </summary>
        /// <param name="parent">The parent.</param>
        /// <returns>The new node.</returns>
        public static NodeState Construct(NodeState parent)
        {
            return new PropertyTypeState();
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            SuperTypeId = Opc.Ua.NodeId.Create(Opc.Ua.VariableTypes.BaseVariableType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            NodeId = Opc.Ua.NodeId.Create(Opc.Ua.VariableTypes.PropertyType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            BrowseName = Opc.Ua.QualifiedName.Create(Opc.Ua.BrowseNames.PropertyType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            DisplayName = new LocalizedText(Opc.Ua.BrowseNames.PropertyType, String.Empty, Opc.Ua.BrowseNames.PropertyType);
            Description = null;
            WriteMask = AttributeWriteMask.None;
            UserWriteMask = AttributeWriteMask.None;
            IsAbstract = false;
            Value = null;
            DataType = Opc.Ua.NodeId.Create(Opc.Ua.DataTypes.BaseDataType, Opc.Ua.Namespaces.OpcUa, context.NamespaceUris);
            ValueRank = ValueRanks.Any;
            ArrayDimensions = null;
        }
        #endregion
    }

    /// <summary> 
    /// A typed base class for all property variable type nodes.
    /// </summary>
    public class PropertyTypeState<T> : PropertyTypeState
    {
        #region Constructors
        /// <summary>
        /// Initializes the type with its defalt attribute values.
        /// </summary>
        public PropertyTypeState()
        {
        }
        #endregion

        #region Initialization
        /// <summary>
        /// Initializes the instance with the default values.
        /// </summary>
        protected override void Initialize(ISystemContext context)
        {
            base.Initialize(context);

            Value = default(T);
            DataType = TypeInfo.GetDataTypeId(typeof(T));
            ValueRank = TypeInfo.GetValueRank(typeof(T));
        }

        /// <summary>
        /// Sets the value to its default value if it is not valid.
        /// </summary>
        protected override object ExtractValueFromVariant(ISystemContext context, object value, bool throwOnError)
        {
            return BaseVariableState.ExtractValueFromVariant<T>(context, value, throwOnError);
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The value of the variable.
        /// </summary>
        public new T Value
        {
            get
            {
                return BaseVariableState.CheckTypeBeforeCast<T>(base.Value, true);
            }

            set
            {
                base.Value = value;
            }
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableTypeState.cs(15,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableTypeState.cs(611,76): error CS0103: The name 'arrayDimensions' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Stack\State\BaseVariableTypeState.cs(15,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 17 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\UaSCBinaryChannel.Symmetric.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Opc.Ua.Bindings
{
    public partial class UaSCUaBinaryChannel
    {
        #region Token Handling Members
        /// <summary>
        /// Returns the current security token.
        /// </summary>
        protected internal ChannelToken CurrentToken => m_currentToken;

        /// <summary>
        /// Returns the current security token.
        /// </summary>
        protected ChannelToken PreviousToken => m_previousToken;

        /// <summary>
        /// Returns the renewed but not yet activated token.
        /// </summary>
        protected ChannelToken RenewedToken => m_renewedToken;

        /// <summary>
        /// Creates a new token.
        /// </summary>
        protected ChannelToken CreateToken()
        {
            ChannelToken token = new ChannelToken();

            token.ChannelId = m_channelId;
            token.TokenId = 0;
            token.CreatedAt = DateTime.UtcNow;
            token.Lifetime = (int)Quotas.SecurityTokenLifetime;

            Utils.Trace("Token #{0} created. CreatedAt = {1:HH:mm:ss.fff} . Lifetime = {2}", token.TokenId, token.CreatedAt, token.Lifetime);

            return token;
        }

        /// <summary>
        /// Activates a new token.
        /// </summary>
        protected void ActivateToken(ChannelToken token)
        {
            // compute the keys for the token.
            ComputeKeys(token);

            m_previousToken = m_currentToken;
            m_currentToken = token;
            m_renewedToken = null;

            Utils.Trace("Token #{0} activated. CreatedAt = {1:HH:mm:ss.fff} . Lifetime = {2}", token.TokenId, token.CreatedAt, token.Lifetime);
        }

        /// <summary>
        /// Sets the renewed token
        /// </summary>
        protected void SetRenewedToken(ChannelToken token)
        {
            m_renewedToken = token;

            Utils.Trace("RenewedToken #{0} set. CreatedAt = {1:HH:mm:ss.fff} . Lifetime = {2}", token.TokenId, token.CreatedAt, token.Lifetime);
        }

        /// <summary>
        /// Discards the tokens.
        /// </summary>
        protected void DiscardTokens()
        {
            m_previousToken = null;
            m_currentToken = null;
        }
        #endregion

        #region Symmetric Cryptography Functions
        /// <summary>
        /// The byte length of the MAC (a.k.a signature) attached to each message.
        /// </summary>
        private int SymmetricSignatureSize => m_hmacHashSize;

        /// <summary>
        /// The byte length the encryption blocks.
        /// </summary>
        private int EncryptionBlockSize => m_encryptionBlockSize;

        /// <summary>
        /// Calculates the symmetric key sizes based on the current security policy.
        /// </summary>
        protected void CalculateSymmetricKeySizes()
        {
            switch (SecurityPolicyUri)
            {
                case SecurityPolicies.Basic128Rsa15:
                {
                    m_hmacHashSize = 20;
                    m_signatureKeySize = 16;
                    m_encryptionKeySize = 16;
                    m_encryptionBlockSize = 16;
                    break;
                }

                case SecurityPolicies.Basic256:
                {
                    m_hmacHashSize = 20;
                    m_signatureKeySize = 24;
                    m_encryptionKeySize = 32;
                    m_encryptionBlockSize = 16;
                    break;
                }

                case SecurityPolicies.Basic256Sha256:
                {
                    m_hmacHashSize = 32;
                    m_signatureKeySize = 32;
                    m_encryptionKeySize = 32;
                    m_encryptionBlockSize = 16;
                    break;
                }

                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                {
                    m_hmacHashSize = 32;
                    m_signatureKeySize = 32;
                    m_encryptionKeySize = 16;
                    m_encryptionBlockSize = 16;
                    break;
                }

                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    m_hmacHashSize = 32;
                    m_signatureKeySize = 32;
                    m_encryptionKeySize = 32;
                    m_encryptionBlockSize = 16;
                    break;
                }

                default:
                case SecurityPolicies.None:
                {
                    m_hmacHashSize = 0;
                    m_signatureKeySize = 0;
                    m_encryptionKeySize = 0;
                    m_encryptionBlockSize = 1;
                    break;
                }
            }
        }

        /// <summary>
        /// Computes the keys for a token.
        /// </summary>
        protected void ComputeKeys(ChannelToken token)
        {
            if (SecurityMode == MessageSecurityMode.None)
            {
                return;
            }

            if (SecurityPolicyUri == SecurityPolicies.Basic256Sha256 ||
                SecurityPolicyUri == SecurityPolicies.Aes128_Sha256_RsaOaep ||
                SecurityPolicyUri == SecurityPolicies.Aes256_Sha256_RsaPss)
            {
                token.ClientSigningKey = Utils.PSHA256(token.ServerNonce, null, token.ClientNonce, 0, m_signatureKeySize);
                token.ClientEncryptingKey = Utils.PSHA256(token.ServerNonce, null, token.ClientNonce, m_signatureKeySize, m_encryptionKeySize);
                token.ClientInitializationVector = Utils.PSHA256(token.ServerNonce, null, token.ClientNonce, m_signatureKeySize + m_encryptionKeySize, m_encryptionBlockSize);
                token.ServerSigningKey = Utils.PSHA256(token.ClientNonce, null, token.ServerNonce, 0, m_signatureKeySize);
                token.ServerEncryptingKey = Utils.PSHA256(token.ClientNonce, null, token.ServerNonce, m_signatureKeySize, m_encryptionKeySize);
                token.ServerInitializationVector = Utils.PSHA256(token.ClientNonce, null, token.ServerNonce, m_signatureKeySize + m_encryptionKeySize, m_encryptionBlockSize);
            }
            else
            {
                token.ClientSigningKey = Utils.PSHA1(token.ServerNonce, null, token.ClientNonce, 0, m_signatureKeySize);
                token.ClientEncryptingKey = Utils.PSHA1(token.ServerNonce, null, token.ClientNonce, m_signatureKeySize, m_encryptionKeySize);
                token.ClientInitializationVector = Utils.PSHA1(token.ServerNonce, null, token.ClientNonce, m_signatureKeySize + m_encryptionKeySize, m_encryptionBlockSize);
                token.ServerSigningKey = Utils.PSHA1(token.ClientNonce, null, token.ServerNonce, 0, m_signatureKeySize);
                token.ServerEncryptingKey = Utils.PSHA1(token.ClientNonce, null, token.ServerNonce, m_signatureKeySize, m_encryptionKeySize);
                token.ServerInitializationVector = Utils.PSHA1(token.ClientNonce, null, token.ServerNonce, m_signatureKeySize + m_encryptionKeySize, m_encryptionBlockSize);
            }

            switch (SecurityPolicyUri)
            {
                case SecurityPolicies.Basic128Rsa15:
                case SecurityPolicies.Basic256:
                case SecurityPolicies.Basic256Sha256:
                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    // create encryptors.
                    SymmetricAlgorithm AesCbcEncryptorProvider = Aes.Create();
                    AesCbcEncryptorProvider.Mode = CipherMode.CBC;
                    AesCbcEncryptorProvider.Padding = PaddingMode.None;
                    AesCbcEncryptorProvider.Key = token.ClientEncryptingKey;
                    AesCbcEncryptorProvider.IV = token.ClientInitializationVector;
                    token.ClientEncryptor = AesCbcEncryptorProvider;

                    SymmetricAlgorithm AesCbcDecryptorProvider = Aes.Create();
                    AesCbcDecryptorProvider.Mode = CipherMode.CBC;
                    AesCbcDecryptorProvider.Padding = PaddingMode.None;
                    AesCbcDecryptorProvider.Key = token.ServerEncryptingKey;
                    AesCbcDecryptorProvider.IV = token.ServerInitializationVector;
                    token.ServerEncryptor = AesCbcDecryptorProvider;

                    // create HMACs.
                    if (SecurityPolicyUri == SecurityPolicies.Basic256Sha256 ||
                        SecurityPolicyUri == SecurityPolicies.Aes128_Sha256_RsaOaep ||
                        SecurityPolicyUri == SecurityPolicies.Aes256_Sha256_RsaPss)
                    {
                        // SHA256
                        token.ServerHmac = new HMACSHA256(token.ServerSigningKey);
                        token.ClientHmac = new HMACSHA256(token.ClientSigningKey);
                    }
                    else
                    {   // SHA1
                        token.ServerHmac = new HMACSHA1(token.ServerSigningKey);
                        token.ClientHmac = new HMACSHA1(token.ClientSigningKey);
                    }
                    break;
                }

                default:
                case SecurityPolicies.None:
                {
                    break;
                }
            }
        }

        /// <summary>
        /// Secures the message using the security token.
        /// </summary>
        protected BufferCollection WriteSymmetricMessage(
            uint messageType,
            uint requestId,
            ChannelToken token,
            object messageBody,
            bool isRequest,
            out bool limitsExceeded)
        {
            limitsExceeded = false;
            bool success = false;
            BufferCollection chunksToProcess = null;

            try
            {
                // calculate chunk sizes.
                int maxCipherTextSize = SendBufferSize - TcpMessageLimits.SymmetricHeaderSize;
                int maxCipherBlocks = maxCipherTextSize / EncryptionBlockSize;
                int maxPlainTextSize = maxCipherBlocks * EncryptionBlockSize;
                int maxPayloadSize = maxPlainTextSize - SymmetricSignatureSize - 1 - TcpMessageLimits.SequenceHeaderSize;
                int headerSize = TcpMessageLimits.SymmetricHeaderSize + TcpMessageLimits.SequenceHeaderSize;

                // write the body to stream.
                ArraySegmentStream ostrm = new ArraySegmentStream(
                    BufferManager,
                    SendBufferSize,
                    headerSize,
                    maxPayloadSize);

                // check for encodeable body.
                IEncodeable encodeable = messageBody as IEncodeable;

                if (encodeable != null)
                {
                    // debug code used to verify that message aborts are handled correctly.
                    // int maxMessageSize = Quotas.MessageContext.MaxMessageSize;
                    // Quotas.MessageContext.MaxMessageSize = Int32.MaxValue;

                    BinaryEncoder.EncodeMessage(encodeable, ostrm, Quotas.MessageContext);

                    // Quotas.MessageContext.MaxMessageSize = maxMessageSize;
                }

                // check for raw bytes.
                ArraySegment<byte>? rawBytes = messageBody as ArraySegment<byte>?;

                if (rawBytes != null)
                {
                    BinaryEncoder encoder = new BinaryEncoder(ostrm, Quotas.MessageContext);
                    encoder.WriteRawBytes(rawBytes.Value.Array, rawBytes.Value.Offset, rawBytes.Value.Count);
                    encoder.Close();
                }

                chunksToProcess = ostrm.GetBuffers("WriteSymmetricMessage");

                // ensure there is at least one chunk.
                if (chunksToProcess.Count == 0)
                {
                    byte[] buffer = BufferManager.TakeBuffer(SendBufferSize, "WriteSymmetricMessage");
                    chunksToProcess.Add(new ArraySegment<byte>(buffer, 0, 0));
                }

                BufferCollection chunksToSend = new BufferCollection(chunksToProcess.Capacity);

                int messageSize = 0;

                for (int ii = 0; ii < chunksToProcess.Count; ii++)
                {
                    ArraySegment<byte> chunkToProcess = chunksToProcess[ii];

                    // nothing more to do if limits exceeded.
                    if (limitsExceeded)
                    {
                        BufferManager.ReturnBuffer(chunkToProcess.Array, "WriteSymmetricMessage");
                        continue;
                    }

                    MemoryStream strm = new MemoryStream(chunkToProcess.Array, 0, SendBufferSize);
                    BinaryEncoder encoder = new BinaryEncoder(strm, Quotas.MessageContext);

                    // check if the message needs to be aborted.
                    if (MessageLimitsExceeded(isRequest, messageSize + chunkToProcess.Count - headerSize, ii + 1))
                    {
                        encoder.WriteUInt32(null, messageType | TcpMessageType.Abort);

                        // replace the body in the chunk with an error message.
                        BinaryEncoder errorEncoder = new BinaryEncoder(
                            chunkToProcess.Array,
                            chunkToProcess.Offset,
                            chunkToProcess.Count,
                            Quotas.MessageContext);

                        WriteErrorMessageBody(errorEncoder, (isRequest) ? StatusCodes.BadRequestTooLarge : StatusCodes.BadResponseTooLarge);

                        int size = errorEncoder.Close();
                        chunkToProcess = new ArraySegment<byte>(chunkToProcess.Array, chunkToProcess.Offset, size);

                        limitsExceeded = true;
                    }

                    // check if the message is complete.
                    else if (ii == chunksToProcess.Count - 1)
                    {
                        encoder.WriteUInt32(null, messageType | TcpMessageType.Final);
                    }

                    // more chunks to follow.
                    else
                    {
                        encoder.WriteUInt32(null, messageType | TcpMessageType.Intermediate);
                    }

                    int count = 0;

                    count += TcpMessageLimits.SequenceHeaderSize;
                    count += chunkToProcess.Count;
                    count += SymmetricSignatureSize;

                    // calculate the padding.
                    int padding = 0;

                    if (SecurityMode == MessageSecurityMode.SignAndEncrypt)
                    {
                        // reserve one byte for the padding size.
                        count++;

                        if (count % EncryptionBlockSize != 0)
                        {
                            padding = EncryptionBlockSize - (count % EncryptionBlockSize);
                        }

                        count += padding;
                    }

                    count += TcpMessageLimits.SymmetricHeaderSize;

                    encoder.WriteUInt32(null, (uint)count);
                    encoder.WriteUInt32(null, ChannelId);
                    encoder.WriteUInt32(null, token.TokenId);

                    uint sequenceNumber = GetNewSequenceNumber();
                    encoder.WriteUInt32(null, sequenceNumber);

                    encoder.WriteUInt32(null, requestId);

                    // skip body.
                    strm.Seek(chunkToProcess.Count, SeekOrigin.Current);

                    // update message size count.
                    messageSize += chunkToProcess.Count;

                    // write padding.
                    if (SecurityMode == MessageSecurityMode.SignAndEncrypt)
                    {
                        for (int jj = 0; jj <= padding; jj++)
                        {
                            encoder.WriteByte(null, (byte)padding);
                        }
                    }

                    if (SecurityMode != MessageSecurityMode.None)
                    {
                        // calculate and write signature.
                        byte[] signature = Sign(token, new ArraySegment<byte>(chunkToProcess.Array, 0, encoder.Position), isRequest);

                        if (signature != null)
                        {
                            encoder.WriteRawBytes(signature, 0, signature.Length);
                        }
                    }

                    if (SecurityMode == MessageSecurityMode.SignAndEncrypt)
                    {
                        // encrypt the data.
                        ArraySegment<byte> dataToEncrypt = new ArraySegment<byte>(chunkToProcess.Array, TcpMessageLimits.SymmetricHeaderSize, encoder.Position - TcpMessageLimits.SymmetricHeaderSize);
                        Encrypt(token, dataToEncrypt, isRequest);
                    }

                    // add the header into chunk.
                    chunksToSend.Add(new ArraySegment<byte>(chunkToProcess.Array, 0, encoder.Position));
                }

                // ensure the buffers don't get cleaned up on exit.
                success = true;
                return chunksToSend;
            }
            finally
            {
                if (!success)
                {
                    chunksToProcess?.Release(BufferManager, "WriteSymmetricMessage");
                }
            }
        }

        /// <summary>
        /// Decrypts and verifies a message chunk.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "messageType"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "messageSize")]
        protected ArraySegment<byte> ReadSymmetricMessage(
            ArraySegment<byte> buffer,
            bool isRequest,
            out ChannelToken token,
            out uint requestId,
            out uint sequenceNumber)
        {
            BinaryDecoder decoder = new BinaryDecoder(buffer.Array, buffer.Offset, buffer.Count, Quotas.MessageContext);

            uint messageType = decoder.ReadUInt32(null);
            uint messageSize = decoder.ReadUInt32(null);
            uint channelId = decoder.ReadUInt32(null);
            uint tokenId = decoder.ReadUInt32(null);

            // ensure the channel is valid.
            if (channelId != ChannelId)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadTcpSecureChannelUnknown,
                    "SecureChannelId is not known. ChanneId={0}, CurrentChannelId={1}",
                    channelId,
                    ChannelId);
            }

            // check for a message secured with the new token.
            if (RenewedToken != null && RenewedToken.TokenId == tokenId)
            {
                ActivateToken(RenewedToken);
            }

            // check if activation of the new token should be forced.
            if (RenewedToken != null && CurrentToken.ActivationRequired)
            {
                ActivateToken(RenewedToken);

                Utils.Trace("Token #{0} activated forced.", CurrentToken.TokenId);
            }

            // check for valid token.
            ChannelToken currentToken = CurrentToken;

            if (currentToken == null)
            {
                throw new ServiceResultException(StatusCodes.BadSecureChannelClosed);
            }

            // find the token.
            if (currentToken.TokenId != tokenId && PreviousToken != null && PreviousToken.TokenId != tokenId)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadTcpSecureChannelUnknown,
                    "TokenId is not known. ChanneId={0}, TokenId={1}, CurrentTokenId={2}, PreviousTokenId={3}",
                    channelId,
                    tokenId,
                    currentToken.TokenId,
                    (PreviousToken != null) ? (int)PreviousToken.TokenId : -1);
            }

            token = currentToken;

            // check for a message secured with the token before it expired.
            if (PreviousToken != null && PreviousToken.TokenId == tokenId)
            {
                token = PreviousToken;
            }

            // check if token has expired.
            if (token.Expired)
            {
                throw ServiceResultException.Create(StatusCodes.BadTcpSecureChannelUnknown, "Token #{0} has expired. Lifetime={1:HH:mm:ss.fff}", token.TokenId, token.CreatedAt);
            }

            int headerSize = decoder.Position;

            if (SecurityMode == MessageSecurityMode.SignAndEncrypt)
            {
                // decrypt the message.
                Decrypt(token, new ArraySegment<byte>(buffer.Array, buffer.Offset + headerSize, buffer.Count - headerSize), isRequest);
            }

            if (SecurityMode != MessageSecurityMode.None)
            {
                // extract signature.
                byte[] signature = new byte[SymmetricSignatureSize];

                for (int ii = 0; ii < SymmetricSignatureSize; ii++)
                {
                    signature[ii] = buffer.Array[buffer.Offset + buffer.Count - SymmetricSignatureSize + ii];
                }

                // verify the signature.
                if (!Verify(token, signature, new ArraySegment<byte>(buffer.Array, buffer.Offset, buffer.Count - SymmetricSignatureSize), isRequest))
                {
                    Utils.Trace("Could not verify signature on message.");
                    throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Could not verify the signature on the message.");
                }
            }

            int paddingCount = 0;

            if (SecurityMode == MessageSecurityMode.SignAndEncrypt)
            {
                // verify padding.
                int paddingStart = buffer.Offset + buffer.Count - SymmetricSignatureSize - 1;
                paddingCount = buffer.Array[paddingStart];

                for (int ii = paddingStart - paddingCount; ii < paddingStart; ii++)
                {
                    if (buffer.Array[ii] != paddingCount)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Could not verify the padding in the message.");
                    }
                }

                // add byte for size.
                paddingCount++;
            }

            // extract request id and sequence number.
            sequenceNumber = decoder.ReadUInt32(null);
            requestId = decoder.ReadUInt32(null);

            // return an the data contained in the message.
            int startOfBody = buffer.Offset + TcpMessageLimits.SymmetricHeaderSize + TcpMessageLimits.SequenceHeaderSize;
            int sizeOfBody = buffer.Count - TcpMessageLimits.SymmetricHeaderSize - TcpMessageLimits.SequenceHeaderSize - paddingCount - SymmetricSignatureSize;

            return new ArraySegment<byte>(buffer.Array, startOfBody, sizeOfBody);
        }

        /// <summary>
        /// Returns the symmetric signature for the data.
        /// </summary>
        protected byte[] Sign(ChannelToken token, ArraySegment<byte> dataToSign, bool useClientKeys)
        {
            switch (SecurityPolicyUri)
            {
                default:
                case SecurityPolicies.None:
                {
                    return null;
                }

                case SecurityPolicies.Basic128Rsa15:
                case SecurityPolicies.Basic256:
                case SecurityPolicies.Basic256Sha256:
                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    return SymmetricSign(token, dataToSign, useClientKeys);
                }
            }
        }

        /// <summary>
        /// Returns the symmetric signature for the data.
        /// </summary>
        protected bool Verify(
            ChannelToken token,
            byte[] signature,
            ArraySegment<byte> dataToVerify,
            bool useClientKeys)
        {
            // verify signature.
            switch (SecurityPolicyUri)
            {
                case SecurityPolicies.None:
                {
                    return true;
                }

                case SecurityPolicies.Basic128Rsa15:
                case SecurityPolicies.Basic256:
                case SecurityPolicies.Basic256Sha256:
                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    return SymmetricVerify(token, signature, dataToVerify, useClientKeys);
                }

                default:
                {
                    return false;
                }
            }
        }

        /// <summary>
        /// Decrypts the data in a buffer using symmetric encryption.
        /// </summary>
        protected void Encrypt(ChannelToken token, ArraySegment<byte> dataToEncrypt, bool useClientKeys)
        {
            switch (SecurityPolicyUri)
            {
                default:
                case SecurityPolicies.None:
                {
                    break;
                }

                case SecurityPolicies.Basic256:
                case SecurityPolicies.Basic256Sha256:
                case SecurityPolicies.Basic128Rsa15:
                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    SymmetricEncrypt(token, dataToEncrypt, useClientKeys);
                    break;
                }
            }
        }

        /// <summary>
        /// Decrypts the data in a buffer using symmetric encryption.
        /// </summary>
        protected void Decrypt(ChannelToken token, ArraySegment<byte> dataToDecrypt, bool useClientKeys)
        {
            switch (SecurityPolicyUri)
            {
                default:
                case SecurityPolicies.None:
                {
                    break;
                }

                case SecurityPolicies.Basic256:
                case SecurityPolicies.Basic256Sha256:
                case SecurityPolicies.Basic128Rsa15:
                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    SymmetricDecrypt(token, dataToDecrypt, useClientKeys);
                    break;
                }
            }
        }


        /// <summary>
        /// Signs the message using SHA1 HMAC
        /// </summary>
        private static byte[] SymmetricSign(ChannelToken token, ArraySegment<byte> dataToSign, bool useClientKeys)
        {
            // get HMAC object.
            HMAC hmac = (useClientKeys) ? token.ClientHmac : token.ServerHmac;

            // compute hash.
            MemoryStream istrm = new MemoryStream(dataToSign.Array, dataToSign.Offset, dataToSign.Count, false);
            byte[] signature = hmac.ComputeHash(istrm);
            istrm.Dispose();

            // return signature.
            return signature;
        }

        /// <summary>
        /// Verifies a HMAC for a message.
        /// </summary>
        private static bool SymmetricVerify(
            ChannelToken token,
            byte[] signature,
            ArraySegment<byte> dataToVerify,
            bool useClientKeys)
        {
            // get HMAC object.
            HMAC hmac = (useClientKeys) ? token.ClientHmac : token.ServerHmac;

            // compute hash.
            MemoryStream istrm = new MemoryStream(dataToVerify.Array, dataToVerify.Offset, dataToVerify.Count, false);
            byte[] computedSignature = hmac.ComputeHash(istrm);
            istrm.Dispose();

            // compare signatures.
            for (int ii = 0; ii < signature.Length; ii++)
            {
                if (computedSignature[ii] != signature[ii])
                {
                    string messageType = new UTF8Encoding().GetString(dataToVerify.Array, dataToVerify.Offset, 4);
                    int messageLength = BitConverter.ToInt32(dataToVerify.Array, dataToVerify.Offset + 4);
                    string expectedSignature = Utils.ToHexString(computedSignature);
                    string actualSignature = Utils.ToHexString(signature);

                    var message = new StringBuilder();
                    message.AppendLine("Could not validate signature.");
                    message.AppendLine("ChannelId={0}, TokenId={1}, MessageType={2}, Length={3}");
                    message.AppendLine("ExpectedSignature={4}");
                    message.AppendLine("ActualSignature={5}");
                    Utils.Trace(message.ToString(), token.ChannelId, token.TokenId,
                        messageType, messageLength, expectedSignature, actualSignature);

                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Encrypts a message using a symmetric algorithm.
        /// </summary>
        private static void SymmetricEncrypt(
            ChannelToken token,
            ArraySegment<byte> dataToEncrypt,
            bool useClientKeys)
        {
            SymmetricAlgorithm encryptingKey = (useClientKeys) ? token.ClientEncryptor : token.ServerEncryptor;

            if (encryptingKey == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Token missing symmetric key object.");
            }

            using (ICryptoTransform encryptor = encryptingKey.CreateEncryptor())
            {
                byte[] blockToEncrypt = dataToEncrypt.Array;

                int start = dataToEncrypt.Offset;
                int count = dataToEncrypt.Count;

                if (count % encryptor.InputBlockSize != 0)
                {
                    throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Input data is not an even number of encryption blocks.");
                }

                encryptor.TransformBlock(blockToEncrypt, start, count, blockToEncrypt, start);
            }
        }

        /// <summary>
        /// Decrypts a message using a symmetric algorithm.
        /// </summary>
        private static void SymmetricDecrypt(
            ChannelToken token,
            ArraySegment<byte> dataToDecrypt,
            bool useClientKeys)
        {
            // get the decrypting key.
            SymmetricAlgorithm decryptingKey = (useClientKeys) ? token.ClientEncryptor : token.ServerEncryptor;

            if (decryptingKey == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Token missing symmetric key object.");
            }

            using (ICryptoTransform decryptor = decryptingKey.CreateDecryptor())
            {
                byte[] blockToDecrypt = dataToDecrypt.Array;

                int start = dataToDecrypt.Offset;
                int count = dataToDecrypt.Count;

                if (count % decryptor.InputBlockSize != 0)
                {
                    throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Input data is not an even number of encryption blocks.");
                }

                decryptor.TransformBlock(blockToDecrypt, start, count, blockToDecrypt, start);
            }
        }
        #endregion

        #region Private Fields
        private ChannelToken m_currentToken;
        private ChannelToken m_previousToken;
        private ChannelToken m_renewedToken;
        private int m_hmacHashSize;
        private int m_signatureKeySize;
        private int m_encryptionKeySize;
        private int m_encryptionBlockSize;
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Opc.Ua.Bindings
{
    public partial class UaSCUaBinaryChannel
    {
        #region Token Handling Members
        /// <summary>
        /// Returns the current security token.
        /// </summary>
        protected internal ChannelToken CurrentToken => m_currentToken;

        /// <summary>
        /// Returns the current security token.
        /// </summary>
        protected ChannelToken PreviousToken => m_previousToken;

        /// <summary>
        /// Returns the renewed but not yet activated token.
        /// </summary>
        protected ChannelToken RenewedToken => m_renewedToken;

        /// <summary>
        /// Creates a new token.
        /// </summary>
        protected ChannelToken CreateToken()
        {
            ChannelToken token = new ChannelToken();

            token.ChannelId = m_channelId;
            token.TokenId = 0;
            token.CreatedAt = DateTime.UtcNow;
            token.Lifetime = (int)Quotas.SecurityTokenLifetime;

            Utils.Trace("Token #{0} created. CreatedAt = {1:HH:mm:ss.fff} . Lifetime = {2}", token.TokenId, token.CreatedAt, token.Lifetime);

            return token;
        }

        /// <summary>
        /// Activates a new token.
        /// </summary>
        protected void ActivateToken(ChannelToken token)
        {
            // compute the keys for the token.
            ComputeKeys(token);

            m_previousToken = m_currentToken;
            m_currentToken = token;
            m_renewedToken = null;

            Utils.Trace("Token #{0} activated. CreatedAt = {1:HH:mm:ss.fff} . Lifetime = {2}", token.TokenId, token.CreatedAt, token.Lifetime);
        }

        /// <summary>
        /// Sets the renewed token
        /// </summary>
        protected void SetRenewedToken(ChannelToken token)
        {
            m_renewedToken = token;

            Utils.Trace("RenewedToken #{0} set. CreatedAt = {1:HH:mm:ss.fff} . Lifetime = {2}", token.TokenId, token.CreatedAt, token.Lifetime);
        }

        /// <summary>
        /// Discards the tokens.
        /// </summary>
        protected void DiscardTokens()
        {
            m_previousToken = null;
            m_currentToken = null;
        }
        #endregion

        #region Symmetric Cryptography Functions
        /// <summary>
        /// The byte length of the MAC (a.k.a signature) attached to each message.
        /// </summary>
        private int SymmetricSignatureSize => m_hmacHashSize;

        /// <summary>
        /// The byte length the encryption blocks.
        /// </summary>
        private int EncryptionBlockSize => m_encryptionBlockSize;

        /// <summary>
        /// Calculates the symmetric key sizes based on the current security policy.
        /// </summary>
        protected void CalculateSymmetricKeySizes()
        {
            switch (SecurityPolicyUri)
            {
                case SecurityPolicies.Basic128Rsa15:
                {
                    m_hmacHashSize = 20;
                    m_signatureKeySize = 16;
                    m_encryptionKeySize = 16;
                    m_encryptionBlockSize = 16;
                    break;
                }

                case SecurityPolicies.Basic256:
                {
                    m_hmacHashSize = 20;
                    m_signatureKeySize = 24;
                    m_encryptionKeySize = 32;
                    m_encryptionBlockSize = 16;
                    break;
                }

                case SecurityPolicies.Basic256Sha256:
                {
                    m_hmacHashSize = 32;
                    m_signatureKeySize = 32;
                    m_encryptionKeySize = 32;
                    m_encryptionBlockSize = 16;
                    break;
                }

                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                {
                    m_hmacHashSize = 32;
                    m_signatureKeySize = 32;
                    m_encryptionKeySize = 16;
                    m_encryptionBlockSize = 16;
                    break;
                }

                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    m_hmacHashSize = 32;
                    m_signatureKeySize = 32;
                    m_encryptionKeySize = 32;
                    m_encryptionBlockSize = 16;
                    break;
                }

                default:
                case SecurityPolicies.None:
                {
                    m_hmacHashSize = 0;
                    m_signatureKeySize = 0;
                    m_encryptionKeySize = 0;
                    m_encryptionBlockSize = 1;
                    break;
                }
            }
        }

        /// <summary>
        /// Computes the keys for a token.
        /// </summary>
        protected void ComputeKeys(ChannelToken token)
        {
            if (SecurityMode == MessageSecurityMode.None)
            {
                return;
            }

            if (SecurityPolicyUri == SecurityPolicies.Basic256Sha256 ||
                SecurityPolicyUri == SecurityPolicies.Aes128_Sha256_RsaOaep ||
                SecurityPolicyUri == SecurityPolicies.Aes256_Sha256_RsaPss)
            {
                token.ClientSigningKey = Utils.PSHA256(token.ServerNonce, null, token.ClientNonce, 0, m_signatureKeySize);
                token.ClientEncryptingKey = Utils.PSHA256(token.ServerNonce, null, token.ClientNonce, m_signatureKeySize, m_encryptionKeySize);
                token.ClientInitializationVector = Utils.PSHA256(token.ServerNonce, null, token.ClientNonce, m_signatureKeySize + m_encryptionKeySize, m_encryptionBlockSize);
                token.ServerSigningKey = Utils.PSHA256(token.ClientNonce, null, token.ServerNonce, 0, m_signatureKeySize);
                token.ServerEncryptingKey = Utils.PSHA256(token.ClientNonce, null, token.ServerNonce, m_signatureKeySize, m_encryptionKeySize);
                token.ServerInitializationVector = Utils.PSHA256(token.ClientNonce, null, token.ServerNonce, m_signatureKeySize + m_encryptionKeySize, m_encryptionBlockSize);
            }
            else
            {
                token.ClientSigningKey = Utils.PSHA1(token.ServerNonce, null, token.ClientNonce, 0, m_signatureKeySize);
                token.ClientEncryptingKey = Utils.PSHA1(token.ServerNonce, null, token.ClientNonce, m_signatureKeySize, m_encryptionKeySize);
                token.ClientInitializationVector = Utils.PSHA1(token.ServerNonce, null, token.ClientNonce, m_signatureKeySize + m_encryptionKeySize, m_encryptionBlockSize);
                token.ServerSigningKey = Utils.PSHA1(token.ClientNonce, null, token.ServerNonce, 0, m_signatureKeySize);
                token.ServerEncryptingKey = Utils.PSHA1(token.ClientNonce, null, token.ServerNonce, m_signatureKeySize, m_encryptionKeySize);
                token.ServerInitializationVector = Utils.PSHA1(token.ClientNonce, null, token.ServerNonce, m_signatureKeySize + m_encryptionKeySize, m_encryptionBlockSize);
            }

            switch (SecurityPolicyUri)
            {
                case SecurityPolicies.Basic128Rsa15:
                case SecurityPolicies.Basic256:
                case SecurityPolicies.Basic256Sha256:
                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    // create encryptors.
                    SymmetricAlgorithm AesCbcEncryptorProvider = Aes.Create();
                    AesCbcEncryptorProvider.Mode = CipherMode.CBC;
                    AesCbcEncryptorProvider.Padding = PaddingMode.None;
                    AesCbcEncryptorProvider.Key = token.ClientEncryptingKey;
                    AesCbcEncryptorProvider.IV = token.ClientInitializationVector;
                    token.ClientEncryptor = AesCbcEncryptorProvider;

                    SymmetricAlgorithm AesCbcDecryptorProvider = Aes.Create();
                    AesCbcDecryptorProvider.Mode = CipherMode.CBC;
                    AesCbcDecryptorProvider.Padding = PaddingMode.None;
                    AesCbcDecryptorProvider.Key = token.ServerEncryptingKey;
                    AesCbcDecryptorProvider.IV = token.ServerInitializationVector;
                    token.ServerEncryptor = AesCbcDecryptorProvider;

                    // create HMACs.
                    if (SecurityPolicyUri == SecurityPolicies.Basic256Sha256 ||
                        SecurityPolicyUri == SecurityPolicies.Aes128_Sha256_RsaOaep ||
                        SecurityPolicyUri == SecurityPolicies.Aes256_Sha256_RsaPss)
                    {
                        // SHA256
                        token.ServerHmac = new HMACSHA256(token.ServerSigningKey);
                        token.ClientHmac = new HMACSHA256(token.ClientSigningKey);
                    }
                    else
                    {   // SHA1
                        token.ServerHmac = new HMACSHA1(token.ServerSigningKey);
                        token.ClientHmac = new HMACSHA1(token.ClientSigningKey);
                    }
                    break;
                }

                default:
                case SecurityPolicies.None:
                {
                    break;
                }
            }
        }

        /// <summary>
        /// Secures the message using the security token.
        /// </summary>
        protected BufferCollection WriteSymmetricMessage(
            uint messageType,
            uint requestId,
            ChannelToken token,
            object messageBody,
            bool isRequest,
            out bool limitsExceeded)
        {
            limitsExceeded = false;
            bool success = false;
            BufferCollection chunksToProcess = null;

            try
            {
                // calculate chunk sizes.
                int maxCipherTextSize = SendBufferSize - TcpMessageLimits.SymmetricHeaderSize;
                int maxCipherBlocks = maxCipherTextSize / EncryptionBlockSize;
                int maxPlainTextSize = maxCipherBlocks * EncryptionBlockSize;
                int maxPayloadSize = maxPlainTextSize - SymmetricSignatureSize - 1 - TcpMessageLimits.SequenceHeaderSize;
                int headerSize = TcpMessageLimits.SymmetricHeaderSize + TcpMessageLimits.SequenceHeaderSize;

                // write the body to stream.
                ArraySegmentStream ostrm = new ArraySegmentStream(
                    BufferManager,
                    SendBufferSize,
                    headerSize,
                    maxPayloadSize);

                // check for encodeable body.

                if (messageBody is IEncodeable encodeable)
                {
                    // debug code used to verify that message aborts are handled correctly.
                    // int maxMessageSize = Quotas.MessageContext.MaxMessageSize;
                    // Quotas.MessageContext.MaxMessageSize = Int32.MaxValue;

                    BinaryEncoder.EncodeMessage(encodeable, ostrm, Quotas.MessageContext);

                    // Quotas.MessageContext.MaxMessageSize = maxMessageSize;
                }

                // check for raw bytes.

                if (messageBody is ArraySegment<byte>? rawBytes)
                {
                    BinaryEncoder encoder = new BinaryEncoder(ostrm, Quotas.MessageContext);
                    encoder.WriteRawBytes(rawBytes.Value.Array, rawBytes.Value.Offset, rawBytes.Value.Count);
                    encoder.Close();
                }

                chunksToProcess = ostrm.GetBuffers("WriteSymmetricMessage");

                // ensure there is at least one chunk.
                if (chunksToProcess.Count == 0)
                {
                    byte[] buffer = BufferManager.TakeBuffer(SendBufferSize, "WriteSymmetricMessage");
                    chunksToProcess.Add(new ArraySegment<byte>(buffer, 0, 0));
                }

                BufferCollection chunksToSend = new BufferCollection(chunksToProcess.Capacity);

                int messageSize = 0;

                for (int ii = 0; ii < chunksToProcess.Count; ii++)
                {
                    ArraySegment<byte> chunkToProcess = chunksToProcess[ii];

                    // nothing more to do if limits exceeded.
                    if (limitsExceeded)
                    {
                        BufferManager.ReturnBuffer(chunkToProcess.Array, "WriteSymmetricMessage");
                        continue;
                    }

                    MemoryStream strm = new MemoryStream(chunkToProcess.Array, 0, SendBufferSize);
                    BinaryEncoder encoder = new BinaryEncoder(strm, Quotas.MessageContext);

                    // check if the message needs to be aborted.
                    if (MessageLimitsExceeded(isRequest, messageSize + chunkToProcess.Count - headerSize, ii + 1))
                    {
                        encoder.WriteUInt32(null, messageType | TcpMessageType.Abort);

                        // replace the body in the chunk with an error message.
                        BinaryEncoder errorEncoder = new BinaryEncoder(
                            chunkToProcess.Array,
                            chunkToProcess.Offset,
                            chunkToProcess.Count,
                            Quotas.MessageContext);

                        WriteErrorMessageBody(errorEncoder, (isRequest) ? StatusCodes.BadRequestTooLarge : StatusCodes.BadResponseTooLarge);

                        int size = errorEncoder.Close();
                        chunkToProcess = new ArraySegment<byte>(chunkToProcess.Array, chunkToProcess.Offset, size);

                        limitsExceeded = true;
                    }

                    // check if the message is complete.
                    else if (ii == chunksToProcess.Count - 1)
                    {
                        encoder.WriteUInt32(null, messageType | TcpMessageType.Final);
                    }

                    // more chunks to follow.
                    else
                    {
                        encoder.WriteUInt32(null, messageType | TcpMessageType.Intermediate);
                    }

                    int count = 0;

                    count += TcpMessageLimits.SequenceHeaderSize;
                    count += chunkToProcess.Count;
                    count += SymmetricSignatureSize;

                    // calculate the padding.
                    int padding = 0;

                    if (SecurityMode == MessageSecurityMode.SignAndEncrypt)
                    {
                        // reserve one byte for the padding size.
                        count++;

                        if (count % EncryptionBlockSize != 0)
                        {
                            padding = EncryptionBlockSize - (count % EncryptionBlockSize);
                        }

                        count += padding;
                    }

                    count += TcpMessageLimits.SymmetricHeaderSize;

                    encoder.WriteUInt32(null, (uint)count);
                    encoder.WriteUInt32(null, ChannelId);
                    encoder.WriteUInt32(null, token.TokenId);

                    uint sequenceNumber = GetNewSequenceNumber();
                    encoder.WriteUInt32(null, sequenceNumber);

                    encoder.WriteUInt32(null, requestId);

                    // skip body.
                    strm.Seek(chunkToProcess.Count, SeekOrigin.Current);

                    // update message size count.
                    messageSize += chunkToProcess.Count;

                    // write padding.
                    if (SecurityMode == MessageSecurityMode.SignAndEncrypt)
                    {
                        for (int jj = 0; jj <= padding; jj++)
                        {
                            encoder.WriteByte(null, (byte)padding);
                        }
                    }

                    if (SecurityMode != MessageSecurityMode.None)
                    {
                        // calculate and write signature.
                        byte[] signature = Sign(token, new ArraySegment<byte>(chunkToProcess.Array, 0, encoder.Position), isRequest);

                        if (signature != null)
                        {
                            encoder.WriteRawBytes(signature, 0, signature.Length);
                        }
                    }

                    if (SecurityMode == MessageSecurityMode.SignAndEncrypt)
                    {
                        // encrypt the data.
                        ArraySegment<byte> dataToEncrypt = new ArraySegment<byte>(chunkToProcess.Array, TcpMessageLimits.SymmetricHeaderSize, encoder.Position - TcpMessageLimits.SymmetricHeaderSize);
                        Encrypt(token, dataToEncrypt, isRequest);
                    }

                    // add the header into chunk.
                    chunksToSend.Add(new ArraySegment<byte>(chunkToProcess.Array, 0, encoder.Position));
                }

                // ensure the buffers don't get cleaned up on exit.
                success = true;
                return chunksToSend;
            }
            finally
            {
                if (!success)
                {
                    chunksToProcess?.Release(BufferManager, "WriteSymmetricMessage");
                }
            }
        }

        /// <summary>
        /// Decrypts and verifies a message chunk.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "messageType"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1804:RemoveUnusedLocals", MessageId = "messageSize")]
        protected ArraySegment<byte> ReadSymmetricMessage(
            ArraySegment<byte> buffer,
            bool isRequest,
            out ChannelToken token,
            out uint requestId,
            out uint sequenceNumber)
        {
            BinaryDecoder decoder = new BinaryDecoder(buffer.Array, buffer.Offset, buffer.Count, Quotas.MessageContext);

            uint messageType = decoder.ReadUInt32(null);
            uint messageSize = decoder.ReadUInt32(null);
            uint channelId = decoder.ReadUInt32(null);
            uint tokenId = decoder.ReadUInt32(null);

            // ensure the channel is valid.
            if (channelId != ChannelId)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadTcpSecureChannelUnknown,
                    "SecureChannelId is not known. ChanneId={0}, CurrentChannelId={1}",
                    channelId,
                    ChannelId);
            }

            // check for a message secured with the new token.
            if (RenewedToken != null && RenewedToken.TokenId == tokenId)
            {
                ActivateToken(RenewedToken);
            }

            // check if activation of the new token should be forced.
            if (RenewedToken != null && CurrentToken.ActivationRequired)
            {
                ActivateToken(RenewedToken);

                Utils.Trace("Token #{0} activated forced.", CurrentToken.TokenId);
            }

            // check for valid token.
            ChannelToken currentToken = CurrentToken;

            if (currentToken == null)
            {
                throw new ServiceResultException(StatusCodes.BadSecureChannelClosed);
            }

            // find the token.
            if (currentToken.TokenId != tokenId && PreviousToken != null && PreviousToken.TokenId != tokenId)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadTcpSecureChannelUnknown,
                    "TokenId is not known. ChanneId={0}, TokenId={1}, CurrentTokenId={2}, PreviousTokenId={3}",
                    channelId,
                    tokenId,
                    currentToken.TokenId,
                    (PreviousToken != null) ? (int)PreviousToken.TokenId : -1);
            }

            token = currentToken;

            // check for a message secured with the token before it expired.
            if (PreviousToken != null && PreviousToken.TokenId == tokenId)
            {
                token = PreviousToken;
            }

            // check if token has expired.
            if (token.Expired)
            {
                throw ServiceResultException.Create(StatusCodes.BadTcpSecureChannelUnknown, "Token #{0} has expired. Lifetime={1:HH:mm:ss.fff}", token.TokenId, token.CreatedAt);
            }

            int headerSize = decoder.Position;

            if (SecurityMode == MessageSecurityMode.SignAndEncrypt)
            {
                // decrypt the message.
                Decrypt(token, new ArraySegment<byte>(buffer.Array, buffer.Offset + headerSize, buffer.Count - headerSize), isRequest);
            }

            if (SecurityMode != MessageSecurityMode.None)
            {
                // extract signature.
                byte[] signature = new byte[SymmetricSignatureSize];

                for (int ii = 0; ii < SymmetricSignatureSize; ii++)
                {
                    signature[ii] = buffer.Array[buffer.Offset + buffer.Count - SymmetricSignatureSize + ii];
                }

                // verify the signature.
                if (!Verify(token, signature, new ArraySegment<byte>(buffer.Array, buffer.Offset, buffer.Count - SymmetricSignatureSize), isRequest))
                {
                    Utils.Trace("Could not verify signature on message.");
                    throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Could not verify the signature on the message.");
                }
            }

            int paddingCount = 0;

            if (SecurityMode == MessageSecurityMode.SignAndEncrypt)
            {
                // verify padding.
                int paddingStart = buffer.Offset + buffer.Count - SymmetricSignatureSize - 1;
                paddingCount = buffer.Array[paddingStart];

                for (int ii = paddingStart - paddingCount; ii < paddingStart; ii++)
                {
                    if (buffer.Array[ii] != paddingCount)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Could not verify the padding in the message.");
                    }
                }

                // add byte for size.
                paddingCount++;
            }

            // extract request id and sequence number.
            sequenceNumber = decoder.ReadUInt32(null);
            requestId = decoder.ReadUInt32(null);

            // return an the data contained in the message.
            int startOfBody = buffer.Offset + TcpMessageLimits.SymmetricHeaderSize + TcpMessageLimits.SequenceHeaderSize;
            int sizeOfBody = buffer.Count - TcpMessageLimits.SymmetricHeaderSize - TcpMessageLimits.SequenceHeaderSize - paddingCount - SymmetricSignatureSize;

            return new ArraySegment<byte>(buffer.Array, startOfBody, sizeOfBody);
        }

        /// <summary>
        /// Returns the symmetric signature for the data.
        /// </summary>
        protected byte[] Sign(ChannelToken token, ArraySegment<byte> dataToSign, bool useClientKeys)
        {
            switch (SecurityPolicyUri)
            {
                default:
                case SecurityPolicies.None:
                {
                    return null;
                }

                case SecurityPolicies.Basic128Rsa15:
                case SecurityPolicies.Basic256:
                case SecurityPolicies.Basic256Sha256:
                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    return SymmetricSign(token, dataToSign, useClientKeys);
                }
            }
        }

        /// <summary>
        /// Returns the symmetric signature for the data.
        /// </summary>
        protected bool Verify(
            ChannelToken token,
            byte[] signature,
            ArraySegment<byte> dataToVerify,
            bool useClientKeys)
        {
            // verify signature.
            switch (SecurityPolicyUri)
            {
                case SecurityPolicies.None:
                {
                    return true;
                }

                case SecurityPolicies.Basic128Rsa15:
                case SecurityPolicies.Basic256:
                case SecurityPolicies.Basic256Sha256:
                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    return SymmetricVerify(token, signature, dataToVerify, useClientKeys);
                }

                default:
                {
                    return false;
                }
            }
        }

        /// <summary>
        /// Decrypts the data in a buffer using symmetric encryption.
        /// </summary>
        protected void Encrypt(ChannelToken token, ArraySegment<byte> dataToEncrypt, bool useClientKeys)
        {
            switch (SecurityPolicyUri)
            {
                default:
                case SecurityPolicies.None:
                {
                    break;
                }

                case SecurityPolicies.Basic256:
                case SecurityPolicies.Basic256Sha256:
                case SecurityPolicies.Basic128Rsa15:
                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    SymmetricEncrypt(token, dataToEncrypt, useClientKeys);
                    break;
                }
            }
        }

        /// <summary>
        /// Decrypts the data in a buffer using symmetric encryption.
        /// </summary>
        protected void Decrypt(ChannelToken token, ArraySegment<byte> dataToDecrypt, bool useClientKeys)
        {
            switch (SecurityPolicyUri)
            {
                default:
                case SecurityPolicies.None:
                {
                    break;
                }

                case SecurityPolicies.Basic256:
                case SecurityPolicies.Basic256Sha256:
                case SecurityPolicies.Basic128Rsa15:
                case SecurityPolicies.Aes128_Sha256_RsaOaep:
                case SecurityPolicies.Aes256_Sha256_RsaPss:
                {
                    SymmetricDecrypt(token, dataToDecrypt, useClientKeys);
                    break;
                }
            }
        }


        /// <summary>
        /// Signs the message using SHA1 HMAC
        /// </summary>
        private static byte[] SymmetricSign(ChannelToken token, ArraySegment<byte> dataToSign, bool useClientKeys)
        {
            // get HMAC object.
            HMAC hmac = (useClientKeys) ? token.ClientHmac : token.ServerHmac;

            // compute hash.
            MemoryStream istrm = new MemoryStream(dataToSign.Array, dataToSign.Offset, dataToSign.Count, false);
            byte[] signature = hmac.ComputeHash(istrm);
            istrm.Dispose();

            // return signature.
            return signature;
        }

        /// <summary>
        /// Verifies a HMAC for a message.
        /// </summary>
        private static bool SymmetricVerify(
            ChannelToken token,
            byte[] signature,
            ArraySegment<byte> dataToVerify,
            bool useClientKeys)
        {
            // get HMAC object.
            HMAC hmac = (useClientKeys) ? token.ClientHmac : token.ServerHmac;

            // compute hash.
            MemoryStream istrm = new MemoryStream(dataToVerify.Array, dataToVerify.Offset, dataToVerify.Count, false);
            byte[] computedSignature = hmac.ComputeHash(istrm);
            istrm.Dispose();

            // compare signatures.
            for (int ii = 0; ii < signature.Length; ii++)
            {
                if (computedSignature[ii] != signature[ii])
                {
                    string messageType = new UTF8Encoding().GetString(dataToVerify.Array, dataToVerify.Offset, 4);
                    int messageLength = BitConverter.ToInt32(dataToVerify.Array, dataToVerify.Offset + 4);
                    string expectedSignature = Utils.ToHexString(computedSignature);
                    string actualSignature = Utils.ToHexString(signature);

                    var message = new StringBuilder();
                    message.AppendLine("Could not validate signature.");
                    message.AppendLine("ChannelId={0}, TokenId={1}, MessageType={2}, Length={3}");
                    message.AppendLine("ExpectedSignature={4}");
                    message.AppendLine("ActualSignature={5}");
                    Utils.Trace(message.ToString(), token.ChannelId, token.TokenId,
                        messageType, messageLength, expectedSignature, actualSignature);

                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Encrypts a message using a symmetric algorithm.
        /// </summary>
        private static void SymmetricEncrypt(
            ChannelToken token,
            ArraySegment<byte> dataToEncrypt,
            bool useClientKeys)
        {
            SymmetricAlgorithm encryptingKey = (useClientKeys) ? token.ClientEncryptor : token.ServerEncryptor;

            if (encryptingKey == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Token missing symmetric key object.");
            }

            using (ICryptoTransform encryptor = encryptingKey.CreateEncryptor())
            {
                byte[] blockToEncrypt = dataToEncrypt.Array;

                int start = dataToEncrypt.Offset;
                int count = dataToEncrypt.Count;

                if (count % encryptor.InputBlockSize != 0)
                {
                    throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Input data is not an even number of encryption blocks.");
                }

                encryptor.TransformBlock(blockToEncrypt, start, count, blockToEncrypt, start);
            }
        }

        /// <summary>
        /// Decrypts a message using a symmetric algorithm.
        /// </summary>
        private static void SymmetricDecrypt(
            ChannelToken token,
            ArraySegment<byte> dataToDecrypt,
            bool useClientKeys)
        {
            // get the decrypting key.
            SymmetricAlgorithm decryptingKey = (useClientKeys) ? token.ClientEncryptor : token.ServerEncryptor;

            if (decryptingKey == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Token missing symmetric key object.");
            }

            using (ICryptoTransform decryptor = decryptingKey.CreateDecryptor())
            {
                byte[] blockToDecrypt = dataToDecrypt.Array;

                int start = dataToDecrypt.Offset;
                int count = dataToDecrypt.Count;

                if (count % decryptor.InputBlockSize != 0)
                {
                    throw ServiceResultException.Create(StatusCodes.BadSecurityChecksFailed, "Input data is not an even number of encryption blocks.");
                }

                decryptor.TransformBlock(blockToDecrypt, start, count, blockToDecrypt, start);
            }
        }
        #endregion

        #region Private Fields
        private ChannelToken m_currentToken;
        private ChannelToken m_previousToken;
        private ChannelToken m_renewedToken;
        private int m_hmacHashSize;
        private int m_signatureKeySize;
        private int m_encryptionKeySize;
        private int m_encryptionBlockSize;
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\Tcp\UaSCBinaryChannel.Symmetric.cs(290,36): error CS8116: It is not legal to use nullable type 'ArraySegment<byte>?' in a pattern; use the underlying type 'ArraySegment<byte>' instead.
######################################################################


######################################################################
Nr: 18 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Stack\Types\ContentFilter.Evaluate.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// This class contains functions used to evaluate a ContentFilter and report the
    /// results of the evaluation.
    /// </summary>
    public partial class ContentFilter
    {
        #region Public functions
        /// <summary>
        /// Evaluates the first element in the ContentFilter. If the first or any 
        /// subsequent element has dependent elements, the dependent elements are 
        /// evaluated before the root element (recursive descent). Elements which 
        /// are not linked (directly or indirectly) to the first element will not 
        /// be evaluated (they have no influence on the result). 
        /// </summary>
        /// <param name="context">The context to use when evaluating the filter.</param>
        /// <param name="target">The target to use when evaluating elements that reference the type model.</param>
        /// <returns>Returns true, false or null.</returns>
        public bool Evaluate(FilterContext context, IFilterTarget target)
        {
            // check if nothing to do.
            if (this.Elements.Count == 0)
            {
                return true;
            }

            bool? result = Evaluate(context, target, 0) as bool?;

            if (result == null)
            {
                return false;
            }

            return result.Value;
        }
        #endregion
        
        #region Private Methods
        /// <summary>
        /// Evaluates element at the specified index.
        /// </summary>
        private object Evaluate(FilterContext context, IFilterTarget target, int index)
        {
            // get the element to evaluate.
            ContentFilterElement element = Elements[index];

            switch (element.FilterOperator)
            {
                case FilterOperator.And: 
                {
                    return And(context, target, element);
                }
                    
                case FilterOperator.Or: 
                {
                    return Or(context, target, element);
                }

                case FilterOperator.Not: 
                {
                    return Not(context, target, element);
                }

                case FilterOperator.Equals: 
                {
                    return Equals(context, target, element);
                }

                case FilterOperator.GreaterThan: 
                {
                    return GreaterThan(context, target, element);
                }

                case FilterOperator.GreaterThanOrEqual: 
                {
                    return GreaterThanOrEqual(context, target, element);
                }

                case FilterOperator.LessThan: 
                {
                    return LessThan(context, target, element);
                }

                case FilterOperator.LessThanOrEqual: 
                {
                    return LessThanOrEqual(context, target, element);
                }

                case FilterOperator.Between: 
                {
                    return Between(context, target, element);
                }

                case FilterOperator.InList: 
                {
                    return InList(context, target, element);
                }

                case FilterOperator.Like: 
                {
                    return Like(context, target, element);
                }                    

                case FilterOperator.IsNull: 
                {
                    return IsNull(context, target, element);
                }             

                case FilterOperator.Cast: 
                {
                    return Cast(context, target, element);
                }

                case FilterOperator.OfType: 
                {
                    return OfType(context, target, element);
                }

                case FilterOperator.InView: 
                {
                    return InView(context, target, element);
                }

                case FilterOperator.RelatedTo: 
                {
                    return RelatedTo(context, target, element);
                }
            }
                        
            throw new ServiceResultException(StatusCodes.BadUnexpectedError, "FilterOperator is not recognized.");
        }

        /// <summary>
        /// Returns the operands for the element.
        /// </summary>
        private FilterOperand[] GetOperands(ContentFilterElement element, int expectedCount)
        {
            FilterOperand[] operands = new FilterOperand[element.FilterOperands.Count]; 

            int ii = 0;

            foreach (ExtensionObject extension in element.FilterOperands)
            {
                if (ExtensionObject.IsNull(extension))
                {
                    throw new ServiceResultException(StatusCodes.BadUnexpectedError, "FilterOperand is null.");
                }

                FilterOperand operand = extension.Body as FilterOperand;

                if (operand == null)
                {
                    throw new ServiceResultException(StatusCodes.BadUnexpectedError, "FilterOperand is not supported.");
                }
               
                operands[ii++] = operand;
            }

            if (expectedCount > 0 && expectedCount != operands.Length)
            {
                throw new ServiceResultException(StatusCodes.BadUnexpectedError, "ContentFilterElement does not have the correct number of operands.");
            }

            return operands;
        }

        /// <summary>
        /// Returns the value for the element.
        /// </summary>
        private object GetValue(FilterContext context, FilterOperand operand, IFilterTarget target)
        {
            // return the contained value for literal operands.
            LiteralOperand literal = operand as LiteralOperand;

            if (literal != null)
            {
                return literal.Value.Value;
            }

            // must query the filter target for simple attribute operands.
            SimpleAttributeOperand simpleAttribute = operand as SimpleAttributeOperand;

            if (simpleAttribute != null)
            {
                return target.GetAttributeValue(
                    context,
                    simpleAttribute.TypeDefinitionId,
                    simpleAttribute.BrowsePath,
                    simpleAttribute.AttributeId,
                    simpleAttribute.ParsedIndexRange);
            }

            // must query the filter target for attribute operands.
            AttributeOperand attribute = operand as AttributeOperand;

            if (attribute != null)
            {
                // AttributeOperands only supported in advanced filter targets.
                IAdvancedFilterTarget advancedTarget = target as IAdvancedFilterTarget;

                if (advancedTarget == null)
                {
                    return false;
                }

                return advancedTarget.GetRelatedAttributeValue(
                    context,
                    attribute.NodeId,
                    attribute.BrowsePath,
                    attribute.AttributeId,
                    attribute.ParsedIndexRange);
            }
            
            // recursively evaluate element operands.
            ElementOperand element = operand as ElementOperand;

            if (element != null)
            {
                return Evaluate(context, target, (int)element.Index);
            }
                    
            // oops - Validate() was not called.
            throw new ServiceResultException(StatusCodes.BadUnexpectedError, "FilterOperand is not supported.");
        }
        
        /// <summary>
        /// Returns the BuiltInType type for the value.
        /// </summary>
        private static BuiltInType GetBuiltInType(object value)
		{
            if (value == null)
            {
                return BuiltInType.Null;
            }
                
            // return the type of the element for array values.
            Type systemType = value.GetType();

            if (value is Array)
            {
                systemType = systemType.GetElementType();
            }            

			if (systemType == typeof(bool))            { return BuiltInType.Boolean;         }
			if (systemType == typeof(sbyte))           { return BuiltInType.SByte;           }
			if (systemType == typeof(byte))            { return BuiltInType.Byte;            }
			if (systemType == typeof(short))           { return BuiltInType.Int16;           }
			if (systemType == typeof(ushort))          { return BuiltInType.UInt16;          }
			if (systemType == typeof(int))             { return BuiltInType.Int32;           }
			if (systemType == typeof(uint))            { return BuiltInType.UInt32;          }
			if (systemType == typeof(long))            { return BuiltInType.Int64;           }
			if (systemType == typeof(ulong))           { return BuiltInType.UInt64;          }
			if (systemType == typeof(float))           { return BuiltInType.Float;           }
			if (systemType == typeof(double))          { return BuiltInType.Double;          }
			if (systemType == typeof(string))          { return BuiltInType.String;          }
			if (systemType == typeof(DateTime))        { return BuiltInType.DateTime;        }
			if (systemType == typeof(Guid))            { return BuiltInType.Guid;            }
			if (systemType == typeof(Uuid))            { return BuiltInType.Guid;            }
			if (systemType == typeof(byte[]))          { return BuiltInType.ByteString;      }
			if (systemType == typeof(XmlElement))      { return BuiltInType.XmlElement;      }
			if (systemType == typeof(NodeId))          { return BuiltInType.NodeId;          }
			if (systemType == typeof(ExpandedNodeId))  { return BuiltInType.ExpandedNodeId;  }
			if (systemType == typeof(StatusCode))      { return BuiltInType.StatusCode;      } 
		    if (systemType == typeof(DiagnosticInfo))  { return BuiltInType.DiagnosticInfo;  }
		    if (systemType == typeof(QualifiedName))   { return BuiltInType.QualifiedName;   }
		    if (systemType == typeof(LocalizedText))   { return BuiltInType.LocalizedText;   }
			if (systemType == typeof(ExtensionObject)) { return BuiltInType.ExtensionObject; }
			if (systemType == typeof(DataValue))       { return BuiltInType.DataValue;       }
			if (systemType == typeof(Variant))         { return BuiltInType.Variant;         }
			if (systemType == typeof(object))          { return BuiltInType.Variant;         }

            if (systemType.GetTypeInfo().IsEnum)
            {
                return BuiltInType.Enumeration;
            }

            // not a recognized type.
            return BuiltInType.Null;
	    }
                
        /// <summary>
        /// Returns the BuiltInType type for the DataTypeId.
        /// </summary>
        private static BuiltInType GetBuiltInType(NodeId datatypeId)
        {
            if (datatypeId == null || datatypeId.NamespaceIndex != 0 || datatypeId.IdType != IdType.Numeric)
            {
                return BuiltInType.Null;
            }

            return (BuiltInType)Enum.ToObject(typeof(BuiltInType), datatypeId.Identifier);
        }

        /// <summary>
        /// Returns the data type precedence for the value.
        /// </summary>
        private static int GetDataTypePrecedence(BuiltInType type)
        {           
            switch (type)
            {
                case BuiltInType.Double:         { return 18; }
                case BuiltInType.Float:          { return 17; }
                case BuiltInType.Int64:          { return 16; }
                case BuiltInType.UInt64:         { return 15; }
                case BuiltInType.Int32:          { return 14; }
                case BuiltInType.UInt32:         { return 13; }
                case BuiltInType.StatusCode:     { return 12; }
                case BuiltInType.Int16:          { return 11; }
                case BuiltInType.UInt16:         { return 10; }
                case BuiltInType.SByte:          { return 9;  }
                case BuiltInType.Byte:           { return 8;  }
                case BuiltInType.Boolean:        { return 7;  }
                case BuiltInType.Guid:           { return 6;  }
                case BuiltInType.String:         { return 5;  }
                case BuiltInType.ExpandedNodeId: { return 4;  }
                case BuiltInType.NodeId:         { return 3;  }
                case BuiltInType.LocalizedText:  { return 2;  }
                case BuiltInType.QualifiedName:  { return 1;  }
            }

            return 0;
        }
                              
        /// <summary>
        /// Implicitly converts the values according to their data type precedence.
        /// </summary>
        private static void DoImplicitConversion(ref object value1, ref object value2)
        {
            BuiltInType type1 = GetBuiltInType(value1);
            BuiltInType type2 = GetBuiltInType(value2);

            int precedence1 = GetDataTypePrecedence(type1);
            int precedence2 = GetDataTypePrecedence(type2);

            // nothing to do if already the same.
            if (precedence1 == precedence2)
            {
                return;
            }

            // convert to the value with higher precedence.
            if (precedence1 > precedence2)
            {
                value2 = Cast(value2, type2, type1);
            }
            else
            {
                value1 = Cast(value1, type1, type2);
            }
        }
        
        /// <summary>
        /// Returns true if the values are equal.
        /// </summary>
        private static bool IsEqual(object value1, object value2)
        {
            if (value1 == null || value2 == null)
            {
                return value1 == null && value2 == null;
            }

            if (value1 is DBNull || value2 is DBNull)
            {
                return value1 is DBNull && value2 is DBNull;
            }

            if (value1.GetType() != value2.GetType())
            {
                return false;
            }

            return Utils.IsEqual(value1, value2);
        }
        
        /// <summary>
        /// Returns true if the target string matches the UA pattern string. 
        /// The pattern string may include UA wildcards %_\[]!
        /// </summary>
        /// <param name="target">String to check for a pattern match.</param>
        /// <param name="pattern">Pattern to match with the target string.</param>
        /// <returns>true if the target string matches the pattern, otherwise false.</returns>
        private static bool Match(string target, string pattern)
        {
            string expression = pattern;

            // 1) Suppress unused regular expression characters with special meaning
            // the following characters have special meaning in a regular expression []\^$.|?*+()
            // the following characters are OPC UA wildcards %_\[]!
            // The specail meaning of the regular expression characters not coincident with the
            // OPC UA wildcards must be suppressed so as not to interfere with matching.
            // preceed all '^', '$', '.', '|', '?', '*', '+', '(', ')' with a '\'
            expression = Regex.Replace(expression, "([\\^\\$\\.\\|\\?\\*\\+\\(\\)])", "\\$1", RegexOptions.Compiled);
            
            // 2) Replace all OPC UA wildcards with their regular expression equivalents
            // replace all '%' with ".+", except "\%"
            expression = Regex.Replace(expression, "(?<!\\\\)%", ".*", RegexOptions.Compiled);
            
            // replace all '_' with '.', except "\_"
            expression = Regex.Replace(expression, "(?<!\\\\)_", ".", RegexOptions.Compiled);
            
            // replace all "[!" with "[^", except "\[!"
            expression = Regex.Replace(expression, "(?<!\\\\)(\\[!)", "[^", RegexOptions.Compiled);
            
            return Regex.IsMatch(target, expression);
        }
        #endregion

        #region Casting
        /// <summary>
        /// Converts a value to a Boolean
        /// </summary>
        private static object ToBoolean(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                bool[] output = new bool[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (bool)Cast(array.GetValue(ii), BuiltInType.Boolean);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Boolean:
                {
                    return (bool)value; 
                }
                    
                case BuiltInType.SByte:   return Convert.ToBoolean((byte)value);
                case BuiltInType.Byte:    return Convert.ToBoolean((byte)value);
                case BuiltInType.Int16:   return Convert.ToBoolean((short)value);
                case BuiltInType.UInt16:  return Convert.ToBoolean((ushort)value);
                case BuiltInType.Int32:   return Convert.ToBoolean((int)value);
                case BuiltInType.UInt32:  return Convert.ToBoolean((uint)value);
                case BuiltInType.Int64:   return Convert.ToBoolean((long)value);
                case BuiltInType.UInt64:  return Convert.ToBoolean((ulong)value);
                case BuiltInType.Float:   return Convert.ToBoolean((float)value);
                case BuiltInType.Double:  return Convert.ToBoolean((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToBoolean((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }

        /// <summary>
        /// Converts a value to a SByte
        /// </summary>
        private static object ToSByte(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                sbyte[] output = new sbyte[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (sbyte)Cast(array.GetValue(ii), BuiltInType.SByte);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.SByte:
                {
                    return (sbyte)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToSByte((bool)value);
                case BuiltInType.Byte:    return Convert.ToSByte((byte)value);
                case BuiltInType.Int16:   return Convert.ToSByte((short)value);
                case BuiltInType.UInt16:  return Convert.ToSByte((ushort)value);
                case BuiltInType.Int32:   return Convert.ToSByte((int)value);
                case BuiltInType.UInt32:  return Convert.ToSByte((uint)value);
                case BuiltInType.Int64:   return Convert.ToSByte((long)value);
                case BuiltInType.UInt64:  return Convert.ToSByte((ulong)value);
                case BuiltInType.Float:   return Convert.ToSByte((float)value);
                case BuiltInType.Double:  return Convert.ToSByte((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToSByte((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }

        /// <summary>
        /// Converts a value to a Byte
        /// </summary>
        private static object ToByte(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                throw new NotImplementedException("Arrays of Byte not supported. Use ByteString instead.");
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Byte:
                {
                    return (byte)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToByte((bool)value);
                case BuiltInType.SByte:   return Convert.ToByte((sbyte)value);
                case BuiltInType.Int16:   return Convert.ToByte((short)value);
                case BuiltInType.UInt16:  return Convert.ToByte((ushort)value);
                case BuiltInType.Int32:   return Convert.ToByte((int)value);
                case BuiltInType.UInt32:  return Convert.ToByte((uint)value);
                case BuiltInType.Int64:   return Convert.ToByte((long)value);
                case BuiltInType.UInt64:  return Convert.ToByte((ulong)value);
                case BuiltInType.Float:   return Convert.ToByte((float)value);
                case BuiltInType.Double:  return Convert.ToByte((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToByte((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }
        
        /// <summary>
        /// Converts a value to a Int16
        /// </summary>
        private static object ToInt16(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                short[] output = new short[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (short)Cast(array.GetValue(ii), BuiltInType.Int16);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Int16:
                {
                    return (short)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToInt16((bool)value);
                case BuiltInType.SByte:   return Convert.ToInt16((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToInt16((byte)value);
                case BuiltInType.UInt16:  return Convert.ToInt16((ushort)value);
                case BuiltInType.Int32:   return Convert.ToInt16((int)value);
                case BuiltInType.UInt32:  return Convert.ToInt16((uint)value);
                case BuiltInType.Int64:   return Convert.ToInt16((long)value);
                case BuiltInType.UInt64:  return Convert.ToInt16((ulong)value);
                case BuiltInType.Float:   return Convert.ToInt16((float)value);
                case BuiltInType.Double:  return Convert.ToInt16((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt16((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }

        /// <summary>
        /// Converts a value to a UInt16
        /// </summary>
        private static object ToUInt16(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                ushort[] output = new ushort[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (ushort)Cast(array.GetValue(ii), BuiltInType.UInt16);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.UInt16:
                {
                    return (ushort)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToUInt16((bool)value);
                case BuiltInType.SByte:   return Convert.ToUInt16((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToUInt16((byte)value);
                case BuiltInType.Int16:   return Convert.ToUInt16((short)value);
                case BuiltInType.Int32:   return Convert.ToUInt16((int)value);
                case BuiltInType.UInt32:  return Convert.ToUInt16((uint)value);
                case BuiltInType.Int64:   return Convert.ToUInt16((long)value);
                case BuiltInType.UInt64:  return Convert.ToUInt16((ulong)value);
                case BuiltInType.Float:   return Convert.ToUInt16((float)value);
                case BuiltInType.Double:  return Convert.ToUInt16((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt16((string)value); 
                }

                case BuiltInType.StatusCode:
                {
                    StatusCode code = (StatusCode)value;
                    return  (ushort)(code.CodeBits>>16); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }
        
        /// <summary>
        /// Converts a value to a Int32
        /// </summary>
        private static object ToInt32(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                int[] output = new int[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (int)Cast(array.GetValue(ii), BuiltInType.Int32);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Int32:
                {
                    return (int)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToInt32((bool)value);
                case BuiltInType.SByte:   return Convert.ToInt32((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToInt32((byte)value);
                case BuiltInType.Int16:   return Convert.ToInt32((short)value);
                case BuiltInType.UInt16:  return Convert.ToInt32((ushort)value);
                case BuiltInType.UInt32:  return Convert.ToInt32((uint)value);
                case BuiltInType.Int64:   return Convert.ToInt32((long)value);
                case BuiltInType.UInt64:  return Convert.ToInt32((ulong)value);
                case BuiltInType.Float:   return Convert.ToInt32((float)value);
                case BuiltInType.Double:  return Convert.ToInt32((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt32((string)value); 
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToInt32(((StatusCode)value).Code); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }

        /// <summary>
        /// Converts a value to a UInt32
        /// </summary>
        private static object ToUInt32(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                uint[] output = new uint[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (uint)Cast(array.GetValue(ii), BuiltInType.UInt32);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.UInt32:
                {
                    return (uint)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToUInt32((bool)value);
                case BuiltInType.SByte:   return Convert.ToUInt32((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToUInt32((byte)value);
                case BuiltInType.Int16:   return Convert.ToUInt32((short)value);
                case BuiltInType.UInt16:  return Convert.ToUInt32((ushort)value);
                case BuiltInType.Int32:   return Convert.ToUInt32((int)value);
                case BuiltInType.Int64:   return Convert.ToUInt32((long)value);
                case BuiltInType.UInt64:  return Convert.ToUInt32((ulong)value);
                case BuiltInType.Float:   return Convert.ToUInt32((float)value);
                case BuiltInType.Double:  return Convert.ToUInt32((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt32((string)value); 
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToUInt32(((StatusCode)value).Code); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }
        
        /// <summary>
        /// Converts a value to a Int64
        /// </summary>
        private static object ToInt64(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                long[] output = new long[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (long)Cast(array.GetValue(ii), BuiltInType.Int64);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Int64:
                {
                    return (long)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToInt64((bool)value);
                case BuiltInType.SByte:   return Convert.ToInt64((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToInt64((byte)value);
                case BuiltInType.Int16:   return Convert.ToInt64((short)value);
                case BuiltInType.UInt16:  return Convert.ToInt64((ushort)value);
                case BuiltInType.Int32:   return Convert.ToInt64((int)value);
                case BuiltInType.UInt32:  return Convert.ToInt64((uint)value);
                case BuiltInType.UInt64:  return Convert.ToInt64((ulong)value);
                case BuiltInType.Float:   return Convert.ToInt64((float)value);
                case BuiltInType.Double:  return Convert.ToInt64((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt64((string)value); 
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToInt64(((StatusCode)value).Code); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }        
                 
        /// <summary>
        /// Converts a value to a UInt64
        /// </summary>
        private static object ToUInt64(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                ulong[] output = new ulong[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (ulong)Cast(array.GetValue(ii), BuiltInType.UInt64);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.UInt64:
                {
                    return (ulong)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToUInt64((bool)value);
                case BuiltInType.SByte:   return Convert.ToUInt64((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToUInt64((byte)value);
                case BuiltInType.Int16:   return Convert.ToUInt64((short)value);
                case BuiltInType.UInt16:  return Convert.ToUInt64((ushort)value);
                case BuiltInType.Int32:   return Convert.ToUInt64((int)value);
                case BuiltInType.UInt32:  return Convert.ToUInt64((uint)value);
                case BuiltInType.Int64:   return Convert.ToUInt64((long)value);
                case BuiltInType.Float:   return Convert.ToUInt64((float)value);
                case BuiltInType.Double:  return Convert.ToUInt64((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt64((string)value); 
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToUInt64(((StatusCode)value).Code); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }        

        /// <summary>
        /// Converts a value to a Float
        /// </summary>
        private static object ToFloat(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                float[] output = new float[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (float)Cast(array.GetValue(ii), BuiltInType.Float);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Float:
                {
                    return (float)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToSingle((bool)value);
                case BuiltInType.SByte:   return Convert.ToSingle((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToSingle((byte)value);
                case BuiltInType.Int16:   return Convert.ToSingle((short)value);
                case BuiltInType.UInt16:  return Convert.ToSingle((ushort)value);
                case BuiltInType.Int32:   return Convert.ToSingle((int)value);
                case BuiltInType.UInt32:  return Convert.ToSingle((uint)value);
                case BuiltInType.Int64:   return Convert.ToSingle((long)value);
                case BuiltInType.UInt64:  return Convert.ToSingle((ulong)value);
                case BuiltInType.Double:  return Convert.ToSingle((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToSingle((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }        
                
        /// <summary>
        /// Converts a value to a Double
        /// </summary>
        private static object ToDouble(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                double[] output = new double[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (double)Cast(array.GetValue(ii), BuiltInType.Double);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Double:
                {
                    return (double)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToDouble((bool)value);
                case BuiltInType.SByte:   return Convert.ToDouble((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToDouble((byte)value);
                case BuiltInType.Int16:   return Convert.ToDouble((short)value);
                case BuiltInType.UInt16:  return Convert.ToDouble((ushort)value);
                case BuiltInType.Int32:   return Convert.ToDouble((int)value);
                case BuiltInType.UInt32:  return Convert.ToDouble((uint)value);
                case BuiltInType.Int64:   return Convert.ToDouble((long)value);
                case BuiltInType.UInt64:  return Convert.ToDouble((ulong)value);
                case BuiltInType.Float:   return Convert.ToDouble((float)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToDouble((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }        

        /// <summary>
        /// Converts a value to a String
        /// </summary>
        private static object ToString(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                String[] output = new String[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (String)Cast(array.GetValue(ii), BuiltInType.String);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.String:
                {
                    return (string)value;
                }

                case BuiltInType.Boolean:
                {
                    return XmlConvert.ToString((bool)value);
                }

                case BuiltInType.SByte:
                {
                    return XmlConvert.ToString((sbyte)value); 
                }

                case BuiltInType.Byte:
                {
                    return XmlConvert.ToString((byte)value); 
                }

                case BuiltInType.Int16:
                {
                    return XmlConvert.ToString((short)value); 
                }

                case BuiltInType.UInt16:
                {
                    return XmlConvert.ToString((ushort)value); 
                }

                case BuiltInType.Int32:
                {
                    return XmlConvert.ToString((int)value); 
                }

                case BuiltInType.UInt32:
                {
                    return XmlConvert.ToString((uint)value); 
                }

                case BuiltInType.Int64:
                {
                    return XmlConvert.ToString((long)value); 
                }

                case BuiltInType.UInt64:
                {
                    return XmlConvert.ToString((ulong)value); 
                }

                case BuiltInType.Float:
                {
                    return XmlConvert.ToString((float)value); 
                }

                case BuiltInType.Double:
                {
                    return XmlConvert.ToString((double)value); 
                }

                case BuiltInType.DateTime:
                {
                    return XmlConvert.ToString((DateTime)value, XmlDateTimeSerializationMode.Unspecified); 
                }

                case BuiltInType.Guid:
                {
                    return ((Guid)value).ToString(); 
                }

                case BuiltInType.NodeId:
                {
                    return ((NodeId)value).ToString(); 
                }

                case BuiltInType.ExpandedNodeId:
                {
                    return ((ExpandedNodeId)value).ToString(); 
                }

                case BuiltInType.LocalizedText:
                {
                    return ((LocalizedText)value).Text; 
                }

                case BuiltInType.QualifiedName:
                {
                    return ((QualifiedName)value).ToString(); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }

        /// <summary>
        /// Converts a value to a DateTime
        /// </summary>
        private static object ToDateTime(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                DateTime[] output = new DateTime[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (DateTime)Cast(array.GetValue(ii), BuiltInType.DateTime);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.DateTime:
                {
                    return (DateTime)value; 
                }

                case BuiltInType.String:
                {
                    return XmlConvert.ToDateTimeOffset((string) value); 
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a Guid
        /// </summary>
        private static object ToGuid(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                Guid[] output = new Guid[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (Guid)Cast(array.GetValue(ii), BuiltInType.Guid);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Guid:
                {
                    return (Guid)value; 
                }

                case BuiltInType.String:
                {
                    return new Guid((string)value); 
                }

                case BuiltInType.ByteString:
                {
                    return new Guid((byte[])value); 
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a ByteString
        /// </summary>
        private static object ToByteString(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                byte[][] output = new byte[array.Length][];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (byte[])Cast(array.GetValue(ii), BuiltInType.ByteString);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.ByteString:
                {
                    return (byte[])value; 
                }

                case BuiltInType.Guid:
                {
                    return ((Guid)value).ToByteArray(); 
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a NodeId
        /// </summary>
        private static object ToNodeId(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                NodeId[] output = new NodeId[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (NodeId)Cast(array.GetValue(ii), BuiltInType.NodeId);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.NodeId:
                {
                    return (NodeId)value; 
                }

                case BuiltInType.ExpandedNodeId:
                {
                    return (NodeId)(ExpandedNodeId)value; 
                }

                case BuiltInType.String:
                {
                    return NodeId.Parse((string)value);
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a ExpandedNodeId
        /// </summary>
        private static object ToExpandedNodeId(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                ExpandedNodeId[] output = new ExpandedNodeId[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (ExpandedNodeId)Cast(array.GetValue(ii), BuiltInType.ExpandedNodeId);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.ExpandedNodeId:
                {
                    return (ExpandedNodeId)value; 
                }

                case BuiltInType.NodeId:
                {
                    return (ExpandedNodeId)(NodeId)value; 
                }

                case BuiltInType.String:
                {
                    return ExpandedNodeId.Parse((string)value);
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a StatusCode
        /// </summary>
        private static object ToStatusCode(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                StatusCode[] output = new StatusCode[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (StatusCode)Cast(array.GetValue(ii), BuiltInType.StatusCode);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.StatusCode:
                {
                    return (StatusCode)value; 
                }

                case BuiltInType.UInt16:
                {
                    uint code = Convert.ToUInt32((ushort)value);
                    code <<= 16;
                    return (StatusCode)code; 
                }

                case BuiltInType.Int32:
                {
                    return (StatusCode)Convert.ToUInt32((int)value); 
                }               

                case BuiltInType.UInt32:
                {
                    return (StatusCode)(uint)value; 
                }                     
                    
                case BuiltInType.Int64:
                {
                    return (StatusCode)Convert.ToUInt32((long)value); 
                }

                case BuiltInType.UInt64:
                {
                    return (StatusCode)Convert.ToUInt32((ulong)value); 
                }
            }
            
            // conversion not supported.
            return null;
        }
        
        /// <summary>
        /// Converts a value to a QualifiedName
        /// </summary>
        private static object ToQualifiedName(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                QualifiedName[] output = new QualifiedName[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (QualifiedName)Cast(array.GetValue(ii), BuiltInType.QualifiedName);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.QualifiedName:
                {
                    return (QualifiedName)value; 
                }

                case BuiltInType.String:
                {
                    return QualifiedName.Parse((string)value);
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a LocalizedText
        /// </summary>
        private static object ToLocalizedText(object value, BuiltInType sourceType)
        {            
            // check for array conversions.
            Array array = value as Array;

            if (array != null)
            {
                LocalizedText[] output = new LocalizedText[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (LocalizedText)Cast(array.GetValue(ii), BuiltInType.LocalizedText);
                }

                return output;
            }

            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.LocalizedText:
                {
                    return (LocalizedText)value; 
                }

                case BuiltInType.String:
                {
                    return new LocalizedText((string)value);
                }
            }

            // conversion not supported.
            return null;
        }
        
        /// <summary>
        /// Casts a value to the specified target type.
        /// </summary>
        private static object Cast(object source, BuiltInType targetType)
        {
            BuiltInType sourceType = GetBuiltInType(source);

            if (sourceType == BuiltInType.Null)
            {
                return null;
            }

            return Cast(source, sourceType, targetType); 
        }

        /// <summary>
        /// Casts a value to the specified target type.
        /// </summary>
        private static object Cast(object source, BuiltInType sourceType, BuiltInType targetType)
        {
            // null always casts to null.
            if (source == null)
            {
                return null;
            }

            // extract the value from a Variant if specified.
            if (source is Variant variant)
            {
                return Cast(variant.Value, targetType);
            }

            // call the appropriate function if a conversion is supported for the target type.
            try
            {
                switch (targetType)
                {
                    case BuiltInType.Boolean:        return ToBoolean(source, sourceType);                
                    case BuiltInType.SByte:          return ToSByte(source, sourceType);
                    case BuiltInType.Byte:           return ToByte(source, sourceType);
                    case BuiltInType.Int16:          return ToInt16(source, sourceType);
                    case BuiltInType.UInt16:         return ToUInt16(source, sourceType);
                    case BuiltInType.Int32:          return ToInt32(source, sourceType);
                    case BuiltInType.UInt32:         return ToUInt32(source, sourceType);
                    case BuiltInType.Int64:          return ToInt64(source, sourceType);
                    case BuiltInType.UInt64:         return ToUInt64(source, sourceType);
                    case BuiltInType.Float:          return ToFloat(source, sourceType);
                    case BuiltInType.Double:         return ToDouble(source, sourceType);
                    case BuiltInType.String:         return ToString(source, sourceType);
                    case BuiltInType.DateTime:       return ToDateTime(source, sourceType);
                    case BuiltInType.Guid:           return ToGuid(source, sourceType);
                    case BuiltInType.ByteString:     return ToByteString(source, sourceType);
                    case BuiltInType.NodeId:         return ToNodeId(source, sourceType);
                    case BuiltInType.ExpandedNodeId: return ToExpandedNodeId(source, sourceType);
                    case BuiltInType.StatusCode:     return ToStatusCode(source, sourceType);
                    case BuiltInType.QualifiedName:  return ToQualifiedName(source, sourceType);
                    case BuiltInType.LocalizedText:  return ToLocalizedText(source, sourceType);
                }
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Error converting a {1} (Value={0}) to {2}.", source, sourceType, targetType);
            }

            // conversion not supported.
            return null;
        }
        #endregion

        #region FilterOperator Implementations
        /// <summary>
        /// And FilterOperator
        /// </summary>
        private bool? And(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            bool? lhs = GetValue(context, operands[0], target) as bool?;

            // no need for further processing if first operand is false.
            if (lhs != null && !lhs.Value)
            {
                return false;
            }

            bool? rhs = GetValue(context, operands[1], target) as bool?;
            
            if (lhs == null)
            {
                if (rhs == null || rhs == true)
                {
                    return null;
                }
                else
                {
                    return false;
                }
            }
            
            if (rhs == null)
            {
                if (lhs == null || lhs == true)
                {
                    return null;
                }
                else
                {
                    return false;
                }
            }

            return lhs.Value && rhs.Value;
        }
        
        /// <summary>
        /// Or FilterOperator
        /// </summary>
        private bool? Or(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            bool? lhs = GetValue(context, operands[0], target) as bool?;

            // no need for further processing if first operand is true.
            if (lhs != null && lhs.Value)
            {
                return true;
            }

            bool? rhs = GetValue(context, operands[1], target) as bool?;
            
            if (lhs == null)
            {
                if (rhs == null || rhs == false)
            {
                return null;
            }
                else
                {
                    return true;
                }
            }

            if (rhs == null)
            {
                if (lhs == null || lhs == false)
                {
                    return null;
                }
                else
                {
                    return true;
                }
            }
            
            return lhs.Value || rhs.Value;
        }
        
        /// <summary>
        /// Not FilterOperator
        /// </summary>
        private bool? Not(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 1);

            bool? rhs = GetValue(context, operands[0], target) as bool?;
            
            if (rhs == null)
            {
                return null;
            }
            
            return !rhs.Value;
        }
        
        /// <summary>
        /// Equals FilterOperator
        /// </summary>
        private bool Equals(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object lhs = GetValue(context, operands[0], target);
            object rhs = GetValue(context, operands[1], target);

            DoImplicitConversion(ref lhs, ref rhs);

            return IsEqual(lhs, rhs);
        }
        
        /// <summary>
        /// GreaterThan FilterOperator
        /// </summary>
        private bool? GreaterThan(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object lhs = GetValue(context, operands[0], target);
            object rhs = GetValue(context, operands[1], target);

            DoImplicitConversion(ref lhs, ref rhs);

            if (lhs is IComparable && rhs is IComparable)
            {
                return ((IComparable)lhs).CompareTo(rhs) > 0;
            }

            // return null if the types are not comparable.
            return null;
        }
        
        /// <summary>
        /// GreaterThanOrEqual FilterOperator
        /// </summary>
        private bool? GreaterThanOrEqual(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object lhs = GetValue(context, operands[0], target);
            object rhs = GetValue(context, operands[1], target);

            DoImplicitConversion(ref lhs, ref rhs);

            if (lhs is IComparable && rhs is IComparable)
            {
                return ((IComparable)lhs).CompareTo(rhs) >= 0;
            }

            // return null if the types are not comparable.
            return null;
        }
                
        /// <summary>
        /// LessThan FilterOperator
        /// </summary>
        private bool? LessThan(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object lhs = GetValue(context, operands[0], target);
            object rhs = GetValue(context, operands[1], target);

            DoImplicitConversion(ref lhs, ref rhs);

            if (lhs is IComparable && rhs is IComparable)
            {
                return ((IComparable)lhs).CompareTo(rhs) < 0;
            }

            // return null if the types are not comparable.
            return null;
        }
        
        /// <summary>
        /// LessThanOrEqual FilterOperator
        /// </summary>
        private bool? LessThanOrEqual(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object lhs = GetValue(context, operands[0], target);
            object rhs = GetValue(context, operands[1], target);

            DoImplicitConversion(ref lhs, ref rhs);

            if (lhs is IComparable && rhs is IComparable)
            {
                return ((IComparable)lhs).CompareTo(rhs) <= 0;
            }

            // return null if the types are not comparable.
            return null;
        }
                
        /// <summary>
        /// Between FilterOperator
        /// </summary>
        private bool? Between(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 3);

            object value = GetValue(context, operands[0], target);

            object min = GetValue(context, operands[1], target);
            object max = GetValue(context, operands[2], target);
            
            // the min and max could be different data types so the implicit conversion must be done twice.
            object lhs = value;
            DoImplicitConversion(ref lhs, ref min);

            bool? result = null;
            
            if (lhs is IComparable && min is IComparable)
            {
                // check if never in range no matter what happens with the upper bound.
                if (((IComparable)lhs).CompareTo(min) < 0)
                {
                    return false;
                }

                result = true;
            }
            
            lhs = value;
            DoImplicitConversion(ref lhs, ref max);
            
            if (lhs is IComparable && max is IComparable)
            {
                // check if never in range no matter what happens with the lower bound.
                if (((IComparable)lhs).CompareTo(max) > 0)
                {
                    return false;
                }

                // can't determine if in range if lower bound could not be resolved.
                return result != null;
            }
            
            // return null if the types are not comparable.
            return null;
        }
                
        /// <summary>
        /// InList FilterOperator
        /// </summary>
        private bool? InList(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 0);

            object value = GetValue(context, operands[0], target);

            // check for a match.
            for (int ii = 1; ii < operands.Length; ii++)
            {                
                object lhs = value;
                object rhs = GetValue(context, operands[ii], target);

                DoImplicitConversion(ref lhs, ref rhs);

                if (IsEqual(lhs, rhs))
                {
                    return true;
                }
            }

            // no match.
            return false;
        }
        
        /// <summary>
        /// Like FilterOperator
        /// </summary>
        private bool Like(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object firstOperand = GetValue(context, operands[0], target);
            string lhs;
            LocalizedText firstOperandLocalizedText = firstOperand as LocalizedText;
            if (firstOperandLocalizedText != null)
            {
                lhs = firstOperandLocalizedText.Text;
            }
            else
            {
                lhs = firstOperand as string;
            }
            
            object secondOperand = GetValue(context, operands[1], target);
            string rhs;
            LocalizedText secondOperandLocalizedText = secondOperand as LocalizedText;
            if (secondOperandLocalizedText != null)
            {
                rhs = secondOperandLocalizedText.Text;
            }
            else
            {
                rhs = secondOperand as string;
            }

            // this operator requires strings.
            if (lhs == null || rhs == null)
            {
                return false;
            }
          
            return Match((string)lhs, (string)rhs);
        }
        
        /// <summary>
        /// IsNull FilterOperator
        /// </summary>
        private bool IsNull(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 1);

            object rhs = GetValue(context, operands[0], target);
            
            if (rhs == null)
            {
                return true;
            }
            
            return false;
        }

        /// <summary>
        /// Cast FilterOperator
        /// </summary>
        private object Cast(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);
            
            // get the value to cast.
            object value = GetValue(context, operands[0], target);

            if (value == null)
            {
                return null;
            }

            // get the datatype to cast to.
            NodeId datatype = GetValue(context, operands[1], target) as NodeId;

            if (datatype == null)
            {
                return null;
            }

            BuiltInType targetType = GetBuiltInType(datatype);
            
            // cast the value.
            return Cast(value, targetType);
        }
                
        /// <summary>
        /// OfType FilterOperator
        /// </summary>
        private bool OfType(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 1);
            
            // get the desired type.
            NodeId typeDefinitionId = GetValue(context, operands[0], target) as NodeId;

            if (typeDefinitionId == null || target == null)
            {
                return false;
            }

            // check the type.
            try
            {
                return target.IsTypeOf(context, typeDefinitionId);
            }
            catch
            {
                return false;
            }
        }
                
        /// <summary>
        /// InView FilterOperator
        /// </summary>
        private bool InView(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            // views only supported in advanced filter targets.
            IAdvancedFilterTarget advancedFilter = target as IAdvancedFilterTarget;

            if (advancedFilter == null)
            {
                return false;
            }

            FilterOperand[] operands = GetOperands(element, 1);
            
            // get the desired type.
            NodeId viewId = GetValue(context, operands[0], target) as NodeId;

            if (viewId == null || target == null)
            {
                return false;
            }

            // check the target.
            try
            {
                return advancedFilter.IsInView(context, viewId);
            }
            catch
            {
                return false;
            }
        }
        
        /// <summary>
        /// RelatedTo FilterOperator
        /// </summary>
        private bool RelatedTo(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            return RelatedTo(context, target, element, null);
        }

        /// <summary>
        /// RelatedTo FilterOperator
        /// </summary>
        private bool RelatedTo(FilterContext context, IFilterTarget target, ContentFilterElement element, NodeId intermediateNodeId)
        {
            // RelatedTo only supported in advanced filter targets.
            IAdvancedFilterTarget advancedTarget = target as IAdvancedFilterTarget;

            if (advancedTarget == null)
            {
                return false;
            }

            FilterOperand[] operands = GetOperands(element, 6);
            
            // get the type of the source.
            NodeId sourceTypeId = GetValue(context, operands[0], target) as NodeId;

            if (sourceTypeId == null)
            {
                return false;
            }
                        
            // get the type of reference to follow.
            NodeId referenceTypeId = GetValue(context, operands[2], target) as NodeId;

            if (referenceTypeId == null)
            {
                return false;
            }
            
            // get the number of hops
            int? hops = 1;

            object hopsValue = GetValue(context, operands[3], target);

            if (hopsValue != null)
            {
                hops = Cast(hopsValue, BuiltInType.Int32) as int?;

                if (hops == null)
                {
                    hops = 1;
                }
            }

            // get whether to include type definition subtypes.
            bool? includeTypeDefinitionSubtypes = true;

            object includeValue = GetValue(context, operands[4], target);

            if (includeValue != null)
            {
                includeTypeDefinitionSubtypes = Cast(includeValue, BuiltInType.Boolean) as bool?;

                if (includeTypeDefinitionSubtypes == null)
                {
                    includeTypeDefinitionSubtypes = true;
                }
            }

            // get whether to include reference type subtypes.
            bool? includeReferenceTypeSubtypes = true;

            includeValue = GetValue(context, operands[5], target);

            if (includeValue != null)
            {
                includeReferenceTypeSubtypes = Cast(includeValue, BuiltInType.Boolean) as bool?;

                if (includeReferenceTypeSubtypes == null)
                {
                    includeReferenceTypeSubtypes = true;
                }
            }

            NodeId targetTypeId = null;

            // check if elements are chained.
            ElementOperand chainedOperand = operands[1] as ElementOperand;

            if (chainedOperand != null)
            {
                if (chainedOperand.Index < 0 || chainedOperand.Index >= Elements.Count)
                {
                    return false;
                }

                ContentFilterElement chainedElement = Elements[(int)chainedOperand.Index];

                // get the target type from the first operand of the chained element.
                if (chainedElement.FilterOperator == FilterOperator.RelatedTo)
                {
                    FilterOperand nestedType = ExtensionObject.ToEncodeable(chainedElement.FilterOperands[0]) as FilterOperand;

                    targetTypeId = GetValue(context, nestedType, target) as NodeId;

                    if (targetTypeId == null)
                    {
                        return false;
                    }

                    // find the nodes that meet the criteria in the first link of the chain.
                    IList<NodeId> nodeIds = advancedTarget.GetRelatedNodes(
                        context,
                        intermediateNodeId,
                        sourceTypeId,
                        targetTypeId,
                        referenceTypeId,
                        hops.Value,
                        includeTypeDefinitionSubtypes.Value,
                        includeReferenceTypeSubtypes.Value);

                    if (nodeIds == null || nodeIds.Count == 0)
                    {
                        return false;
                    }
                    
                    // recursively follow the chain.
                    for (int ii = 0; ii < nodeIds.Count; ii++)
                    {
                        // one match is all that is required.
                        if (RelatedTo(context, target, chainedElement, nodeIds[ii]))
                        {
                            return true;
                        }
                    }

                    // no matches.
                    return false;
                }
            }
            
            // get the type of the target.
            if (targetTypeId == null)
            {
                targetTypeId = GetValue(context, operands[1], target) as NodeId;

                if (targetTypeId == null)
                {
                    return false;
                }
            }

            // check the target.            
            try
            {
                bool relatedTo = advancedTarget.IsRelatedTo(
                    context,
                    intermediateNodeId,
                    sourceTypeId,
                    targetTypeId,
                    referenceTypeId,
                    hops.Value,
                    includeTypeDefinitionSubtypes.Value,
                    includeReferenceTypeSubtypes.Value);

                return relatedTo;
            }
            catch
            {
                return false;
            }
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// This class contains functions used to evaluate a ContentFilter and report the
    /// results of the evaluation.
    /// </summary>
    public partial class ContentFilter
    {
        #region Public functions
        /// <summary>
        /// Evaluates the first element in the ContentFilter. If the first or any 
        /// subsequent element has dependent elements, the dependent elements are 
        /// evaluated before the root element (recursive descent). Elements which 
        /// are not linked (directly or indirectly) to the first element will not 
        /// be evaluated (they have no influence on the result). 
        /// </summary>
        /// <param name="context">The context to use when evaluating the filter.</param>
        /// <param name="target">The target to use when evaluating elements that reference the type model.</param>
        /// <returns>Returns true, false or null.</returns>
        public bool Evaluate(FilterContext context, IFilterTarget target)
        {
            // check if nothing to do.
            if (this.Elements.Count == 0)
            {
                return true;
            }

            bool? result = Evaluate(context, target, 0) as bool?;

            if (result == null)
            {
                return false;
            }

            return result.Value;
        }
        #endregion
        
        #region Private Methods
        /// <summary>
        /// Evaluates element at the specified index.
        /// </summary>
        private object Evaluate(FilterContext context, IFilterTarget target, int index)
        {
            // get the element to evaluate.
            ContentFilterElement element = Elements[index];

            switch (element.FilterOperator)
            {
                case FilterOperator.And: 
                {
                    return And(context, target, element);
                }
                    
                case FilterOperator.Or: 
                {
                    return Or(context, target, element);
                }

                case FilterOperator.Not: 
                {
                    return Not(context, target, element);
                }

                case FilterOperator.Equals: 
                {
                    return Equals(context, target, element);
                }

                case FilterOperator.GreaterThan: 
                {
                    return GreaterThan(context, target, element);
                }

                case FilterOperator.GreaterThanOrEqual: 
                {
                    return GreaterThanOrEqual(context, target, element);
                }

                case FilterOperator.LessThan: 
                {
                    return LessThan(context, target, element);
                }

                case FilterOperator.LessThanOrEqual: 
                {
                    return LessThanOrEqual(context, target, element);
                }

                case FilterOperator.Between: 
                {
                    return Between(context, target, element);
                }

                case FilterOperator.InList: 
                {
                    return InList(context, target, element);
                }

                case FilterOperator.Like: 
                {
                    return Like(context, target, element);
                }                    

                case FilterOperator.IsNull: 
                {
                    return IsNull(context, target, element);
                }             

                case FilterOperator.Cast: 
                {
                    return Cast(context, target, element);
                }

                case FilterOperator.OfType: 
                {
                    return OfType(context, target, element);
                }

                case FilterOperator.InView: 
                {
                    return InView(context, target, element);
                }

                case FilterOperator.RelatedTo: 
                {
                    return RelatedTo(context, target, element);
                }
            }
                        
            throw new ServiceResultException(StatusCodes.BadUnexpectedError, "FilterOperator is not recognized.");
        }

        /// <summary>
        /// Returns the operands for the element.
        /// </summary>
        private FilterOperand[] GetOperands(ContentFilterElement element, int expectedCount)
        {
            FilterOperand[] operands = new FilterOperand[element.FilterOperands.Count]; 

            int ii = 0;

            foreach (ExtensionObject extension in element.FilterOperands)
            {
                if (ExtensionObject.IsNull(extension))
                {
                    throw new ServiceResultException(StatusCodes.BadUnexpectedError, "FilterOperand is null.");
                }

                FilterOperand operand = extension.Body as FilterOperand;

                if (operand == null)
                {
                    throw new ServiceResultException(StatusCodes.BadUnexpectedError, "FilterOperand is not supported.");
                }
               
                operands[ii++] = operand;
            }

            if (expectedCount > 0 && expectedCount != operands.Length)
            {
                throw new ServiceResultException(StatusCodes.BadUnexpectedError, "ContentFilterElement does not have the correct number of operands.");
            }

            return operands;
        }

        /// <summary>
        /// Returns the value for the element.
        /// </summary>
        private object GetValue(FilterContext context, FilterOperand operand, IFilterTarget target)
        {
            // return the contained value for literal operands.

            if (operand is LiteralOperand literal)
            {
                return literal.Value.Value;
            }

            // must query the filter target for simple attribute operands.

            if (operand is SimpleAttributeOperand simpleAttribute)
            {
                return target.GetAttributeValue(
                    context,
                    simpleAttribute.TypeDefinitionId,
                    simpleAttribute.BrowsePath,
                    simpleAttribute.AttributeId,
                    simpleAttribute.ParsedIndexRange);
            }

            // must query the filter target for attribute operands.

            if (operand is AttributeOperand attribute)
            {
                // AttributeOperands only supported in advanced filter targets.
                IAdvancedFilterTarget advancedTarget = target as IAdvancedFilterTarget;

                if (advancedTarget == null)
                {
                    return false;
                }

                return advancedTarget.GetRelatedAttributeValue(
                    context,
                    attribute.NodeId,
                    attribute.BrowsePath,
                    attribute.AttributeId,
                    attribute.ParsedIndexRange);
            }

            // recursively evaluate element operands.

            if (operand is ElementOperand element)
            {
                return Evaluate(context, target, (int)element.Index);
            }
                    
            // oops - Validate() was not called.
            throw new ServiceResultException(StatusCodes.BadUnexpectedError, "FilterOperand is not supported.");
        }
        
        /// <summary>
        /// Returns the BuiltInType type for the value.
        /// </summary>
        private static BuiltInType GetBuiltInType(object value)
		{
            if (value == null)
            {
                return BuiltInType.Null;
            }
                
            // return the type of the element for array values.
            Type systemType = value.GetType();

            if (value is Array)
            {
                systemType = systemType.GetElementType();
            }            

			if (systemType == typeof(bool))            { return BuiltInType.Boolean;         }
			if (systemType == typeof(sbyte))           { return BuiltInType.SByte;           }
			if (systemType == typeof(byte))            { return BuiltInType.Byte;            }
			if (systemType == typeof(short))           { return BuiltInType.Int16;           }
			if (systemType == typeof(ushort))          { return BuiltInType.UInt16;          }
			if (systemType == typeof(int))             { return BuiltInType.Int32;           }
			if (systemType == typeof(uint))            { return BuiltInType.UInt32;          }
			if (systemType == typeof(long))            { return BuiltInType.Int64;           }
			if (systemType == typeof(ulong))           { return BuiltInType.UInt64;          }
			if (systemType == typeof(float))           { return BuiltInType.Float;           }
			if (systemType == typeof(double))          { return BuiltInType.Double;          }
			if (systemType == typeof(string))          { return BuiltInType.String;          }
			if (systemType == typeof(DateTime))        { return BuiltInType.DateTime;        }
			if (systemType == typeof(Guid))            { return BuiltInType.Guid;            }
			if (systemType == typeof(Uuid))            { return BuiltInType.Guid;            }
			if (systemType == typeof(byte[]))          { return BuiltInType.ByteString;      }
			if (systemType == typeof(XmlElement))      { return BuiltInType.XmlElement;      }
			if (systemType == typeof(NodeId))          { return BuiltInType.NodeId;          }
			if (systemType == typeof(ExpandedNodeId))  { return BuiltInType.ExpandedNodeId;  }
			if (systemType == typeof(StatusCode))      { return BuiltInType.StatusCode;      } 
		    if (systemType == typeof(DiagnosticInfo))  { return BuiltInType.DiagnosticInfo;  }
		    if (systemType == typeof(QualifiedName))   { return BuiltInType.QualifiedName;   }
		    if (systemType == typeof(LocalizedText))   { return BuiltInType.LocalizedText;   }
			if (systemType == typeof(ExtensionObject)) { return BuiltInType.ExtensionObject; }
			if (systemType == typeof(DataValue))       { return BuiltInType.DataValue;       }
			if (systemType == typeof(Variant))         { return BuiltInType.Variant;         }
			if (systemType == typeof(object))          { return BuiltInType.Variant;         }

            if (systemType.GetTypeInfo().IsEnum)
            {
                return BuiltInType.Enumeration;
            }

            // not a recognized type.
            return BuiltInType.Null;
	    }
                
        /// <summary>
        /// Returns the BuiltInType type for the DataTypeId.
        /// </summary>
        private static BuiltInType GetBuiltInType(NodeId datatypeId)
        {
            if (datatypeId == null || datatypeId.NamespaceIndex != 0 || datatypeId.IdType != IdType.Numeric)
            {
                return BuiltInType.Null;
            }

            return (BuiltInType)Enum.ToObject(typeof(BuiltInType), datatypeId.Identifier);
        }

        /// <summary>
        /// Returns the data type precedence for the value.
        /// </summary>
        private static int GetDataTypePrecedence(BuiltInType type)
        {           
            switch (type)
            {
                case BuiltInType.Double:         { return 18; }
                case BuiltInType.Float:          { return 17; }
                case BuiltInType.Int64:          { return 16; }
                case BuiltInType.UInt64:         { return 15; }
                case BuiltInType.Int32:          { return 14; }
                case BuiltInType.UInt32:         { return 13; }
                case BuiltInType.StatusCode:     { return 12; }
                case BuiltInType.Int16:          { return 11; }
                case BuiltInType.UInt16:         { return 10; }
                case BuiltInType.SByte:          { return 9;  }
                case BuiltInType.Byte:           { return 8;  }
                case BuiltInType.Boolean:        { return 7;  }
                case BuiltInType.Guid:           { return 6;  }
                case BuiltInType.String:         { return 5;  }
                case BuiltInType.ExpandedNodeId: { return 4;  }
                case BuiltInType.NodeId:         { return 3;  }
                case BuiltInType.LocalizedText:  { return 2;  }
                case BuiltInType.QualifiedName:  { return 1;  }
            }

            return 0;
        }
                              
        /// <summary>
        /// Implicitly converts the values according to their data type precedence.
        /// </summary>
        private static void DoImplicitConversion(ref object value1, ref object value2)
        {
            BuiltInType type1 = GetBuiltInType(value1);
            BuiltInType type2 = GetBuiltInType(value2);

            int precedence1 = GetDataTypePrecedence(type1);
            int precedence2 = GetDataTypePrecedence(type2);

            // nothing to do if already the same.
            if (precedence1 == precedence2)
            {
                return;
            }

            // convert to the value with higher precedence.
            if (precedence1 > precedence2)
            {
                value2 = Cast(value2, type2, type1);
            }
            else
            {
                value1 = Cast(value1, type1, type2);
            }
        }
        
        /// <summary>
        /// Returns true if the values are equal.
        /// </summary>
        private static bool IsEqual(object value1, object value2)
        {
            if (value1 == null || value2 == null)
            {
                return value1 == null && value2 == null;
            }

            if (value1 is DBNull || value2 is DBNull)
            {
                return value1 is DBNull && value2 is DBNull;
            }

            if (value1.GetType() != value2.GetType())
            {
                return false;
            }

            return Utils.IsEqual(value1, value2);
        }
        
        /// <summary>
        /// Returns true if the target string matches the UA pattern string. 
        /// The pattern string may include UA wildcards %_\[]!
        /// </summary>
        /// <param name="target">String to check for a pattern match.</param>
        /// <param name="pattern">Pattern to match with the target string.</param>
        /// <returns>true if the target string matches the pattern, otherwise false.</returns>
        private static bool Match(string target, string pattern)
        {
            string expression = pattern;

            // 1) Suppress unused regular expression characters with special meaning
            // the following characters have special meaning in a regular expression []\^$.|?*+()
            // the following characters are OPC UA wildcards %_\[]!
            // The specail meaning of the regular expression characters not coincident with the
            // OPC UA wildcards must be suppressed so as not to interfere with matching.
            // preceed all '^', '$', '.', '|', '?', '*', '+', '(', ')' with a '\'
            expression = Regex.Replace(expression, "([\\^\\$\\.\\|\\?\\*\\+\\(\\)])", "\\$1", RegexOptions.Compiled);
            
            // 2) Replace all OPC UA wildcards with their regular expression equivalents
            // replace all '%' with ".+", except "\%"
            expression = Regex.Replace(expression, "(?<!\\\\)%", ".*", RegexOptions.Compiled);
            
            // replace all '_' with '.', except "\_"
            expression = Regex.Replace(expression, "(?<!\\\\)_", ".", RegexOptions.Compiled);
            
            // replace all "[!" with "[^", except "\[!"
            expression = Regex.Replace(expression, "(?<!\\\\)(\\[!)", "[^", RegexOptions.Compiled);
            
            return Regex.IsMatch(target, expression);
        }
        #endregion

        #region Casting
        /// <summary>
        /// Converts a value to a Boolean
        /// </summary>
        private static object ToBoolean(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                bool[] output = new bool[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (bool)Cast(array.GetValue(ii), BuiltInType.Boolean);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Boolean:
                {
                    return (bool)value; 
                }
                    
                case BuiltInType.SByte:   return Convert.ToBoolean((byte)value);
                case BuiltInType.Byte:    return Convert.ToBoolean((byte)value);
                case BuiltInType.Int16:   return Convert.ToBoolean((short)value);
                case BuiltInType.UInt16:  return Convert.ToBoolean((ushort)value);
                case BuiltInType.Int32:   return Convert.ToBoolean((int)value);
                case BuiltInType.UInt32:  return Convert.ToBoolean((uint)value);
                case BuiltInType.Int64:   return Convert.ToBoolean((long)value);
                case BuiltInType.UInt64:  return Convert.ToBoolean((ulong)value);
                case BuiltInType.Float:   return Convert.ToBoolean((float)value);
                case BuiltInType.Double:  return Convert.ToBoolean((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToBoolean((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }

        /// <summary>
        /// Converts a value to a SByte
        /// </summary>
        private static object ToSByte(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                sbyte[] output = new sbyte[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (sbyte)Cast(array.GetValue(ii), BuiltInType.SByte);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.SByte:
                {
                    return (sbyte)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToSByte((bool)value);
                case BuiltInType.Byte:    return Convert.ToSByte((byte)value);
                case BuiltInType.Int16:   return Convert.ToSByte((short)value);
                case BuiltInType.UInt16:  return Convert.ToSByte((ushort)value);
                case BuiltInType.Int32:   return Convert.ToSByte((int)value);
                case BuiltInType.UInt32:  return Convert.ToSByte((uint)value);
                case BuiltInType.Int64:   return Convert.ToSByte((long)value);
                case BuiltInType.UInt64:  return Convert.ToSByte((ulong)value);
                case BuiltInType.Float:   return Convert.ToSByte((float)value);
                case BuiltInType.Double:  return Convert.ToSByte((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToSByte((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }

        /// <summary>
        /// Converts a value to a Byte
        /// </summary>
        private static object ToByte(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                throw new NotImplementedException("Arrays of Byte not supported. Use ByteString instead.");
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Byte:
                {
                    return (byte)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToByte((bool)value);
                case BuiltInType.SByte:   return Convert.ToByte((sbyte)value);
                case BuiltInType.Int16:   return Convert.ToByte((short)value);
                case BuiltInType.UInt16:  return Convert.ToByte((ushort)value);
                case BuiltInType.Int32:   return Convert.ToByte((int)value);
                case BuiltInType.UInt32:  return Convert.ToByte((uint)value);
                case BuiltInType.Int64:   return Convert.ToByte((long)value);
                case BuiltInType.UInt64:  return Convert.ToByte((ulong)value);
                case BuiltInType.Float:   return Convert.ToByte((float)value);
                case BuiltInType.Double:  return Convert.ToByte((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToByte((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }
        
        /// <summary>
        /// Converts a value to a Int16
        /// </summary>
        private static object ToInt16(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                short[] output = new short[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (short)Cast(array.GetValue(ii), BuiltInType.Int16);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Int16:
                {
                    return (short)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToInt16((bool)value);
                case BuiltInType.SByte:   return Convert.ToInt16((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToInt16((byte)value);
                case BuiltInType.UInt16:  return Convert.ToInt16((ushort)value);
                case BuiltInType.Int32:   return Convert.ToInt16((int)value);
                case BuiltInType.UInt32:  return Convert.ToInt16((uint)value);
                case BuiltInType.Int64:   return Convert.ToInt16((long)value);
                case BuiltInType.UInt64:  return Convert.ToInt16((ulong)value);
                case BuiltInType.Float:   return Convert.ToInt16((float)value);
                case BuiltInType.Double:  return Convert.ToInt16((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt16((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }

        /// <summary>
        /// Converts a value to a UInt16
        /// </summary>
        private static object ToUInt16(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                ushort[] output = new ushort[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (ushort)Cast(array.GetValue(ii), BuiltInType.UInt16);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.UInt16:
                {
                    return (ushort)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToUInt16((bool)value);
                case BuiltInType.SByte:   return Convert.ToUInt16((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToUInt16((byte)value);
                case BuiltInType.Int16:   return Convert.ToUInt16((short)value);
                case BuiltInType.Int32:   return Convert.ToUInt16((int)value);
                case BuiltInType.UInt32:  return Convert.ToUInt16((uint)value);
                case BuiltInType.Int64:   return Convert.ToUInt16((long)value);
                case BuiltInType.UInt64:  return Convert.ToUInt16((ulong)value);
                case BuiltInType.Float:   return Convert.ToUInt16((float)value);
                case BuiltInType.Double:  return Convert.ToUInt16((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt16((string)value); 
                }

                case BuiltInType.StatusCode:
                {
                    StatusCode code = (StatusCode)value;
                    return  (ushort)(code.CodeBits>>16); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }
        
        /// <summary>
        /// Converts a value to a Int32
        /// </summary>
        private static object ToInt32(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                int[] output = new int[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (int)Cast(array.GetValue(ii), BuiltInType.Int32);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Int32:
                {
                    return (int)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToInt32((bool)value);
                case BuiltInType.SByte:   return Convert.ToInt32((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToInt32((byte)value);
                case BuiltInType.Int16:   return Convert.ToInt32((short)value);
                case BuiltInType.UInt16:  return Convert.ToInt32((ushort)value);
                case BuiltInType.UInt32:  return Convert.ToInt32((uint)value);
                case BuiltInType.Int64:   return Convert.ToInt32((long)value);
                case BuiltInType.UInt64:  return Convert.ToInt32((ulong)value);
                case BuiltInType.Float:   return Convert.ToInt32((float)value);
                case BuiltInType.Double:  return Convert.ToInt32((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt32((string)value); 
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToInt32(((StatusCode)value).Code); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }

        /// <summary>
        /// Converts a value to a UInt32
        /// </summary>
        private static object ToUInt32(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                uint[] output = new uint[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (uint)Cast(array.GetValue(ii), BuiltInType.UInt32);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.UInt32:
                {
                    return (uint)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToUInt32((bool)value);
                case BuiltInType.SByte:   return Convert.ToUInt32((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToUInt32((byte)value);
                case BuiltInType.Int16:   return Convert.ToUInt32((short)value);
                case BuiltInType.UInt16:  return Convert.ToUInt32((ushort)value);
                case BuiltInType.Int32:   return Convert.ToUInt32((int)value);
                case BuiltInType.Int64:   return Convert.ToUInt32((long)value);
                case BuiltInType.UInt64:  return Convert.ToUInt32((ulong)value);
                case BuiltInType.Float:   return Convert.ToUInt32((float)value);
                case BuiltInType.Double:  return Convert.ToUInt32((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt32((string)value); 
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToUInt32(((StatusCode)value).Code); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }
        
        /// <summary>
        /// Converts a value to a Int64
        /// </summary>
        private static object ToInt64(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                long[] output = new long[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (long)Cast(array.GetValue(ii), BuiltInType.Int64);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Int64:
                {
                    return (long)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToInt64((bool)value);
                case BuiltInType.SByte:   return Convert.ToInt64((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToInt64((byte)value);
                case BuiltInType.Int16:   return Convert.ToInt64((short)value);
                case BuiltInType.UInt16:  return Convert.ToInt64((ushort)value);
                case BuiltInType.Int32:   return Convert.ToInt64((int)value);
                case BuiltInType.UInt32:  return Convert.ToInt64((uint)value);
                case BuiltInType.UInt64:  return Convert.ToInt64((ulong)value);
                case BuiltInType.Float:   return Convert.ToInt64((float)value);
                case BuiltInType.Double:  return Convert.ToInt64((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt64((string)value); 
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToInt64(((StatusCode)value).Code); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }        
                 
        /// <summary>
        /// Converts a value to a UInt64
        /// </summary>
        private static object ToUInt64(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                ulong[] output = new ulong[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (ulong)Cast(array.GetValue(ii), BuiltInType.UInt64);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.UInt64:
                {
                    return (ulong)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToUInt64((bool)value);
                case BuiltInType.SByte:   return Convert.ToUInt64((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToUInt64((byte)value);
                case BuiltInType.Int16:   return Convert.ToUInt64((short)value);
                case BuiltInType.UInt16:  return Convert.ToUInt64((ushort)value);
                case BuiltInType.Int32:   return Convert.ToUInt64((int)value);
                case BuiltInType.UInt32:  return Convert.ToUInt64((uint)value);
                case BuiltInType.Int64:   return Convert.ToUInt64((long)value);
                case BuiltInType.Float:   return Convert.ToUInt64((float)value);
                case BuiltInType.Double:  return Convert.ToUInt64((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt64((string)value); 
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToUInt64(((StatusCode)value).Code); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }        

        /// <summary>
        /// Converts a value to a Float
        /// </summary>
        private static object ToFloat(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                float[] output = new float[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (float)Cast(array.GetValue(ii), BuiltInType.Float);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Float:
                {
                    return (float)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToSingle((bool)value);
                case BuiltInType.SByte:   return Convert.ToSingle((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToSingle((byte)value);
                case BuiltInType.Int16:   return Convert.ToSingle((short)value);
                case BuiltInType.UInt16:  return Convert.ToSingle((ushort)value);
                case BuiltInType.Int32:   return Convert.ToSingle((int)value);
                case BuiltInType.UInt32:  return Convert.ToSingle((uint)value);
                case BuiltInType.Int64:   return Convert.ToSingle((long)value);
                case BuiltInType.UInt64:  return Convert.ToSingle((ulong)value);
                case BuiltInType.Double:  return Convert.ToSingle((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToSingle((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }        
                
        /// <summary>
        /// Converts a value to a Double
        /// </summary>
        private static object ToDouble(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                double[] output = new double[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (double)Cast(array.GetValue(ii), BuiltInType.Double);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Double:
                {
                    return (double)value; 
                }
                    
                case BuiltInType.Boolean: return Convert.ToDouble((bool)value);
                case BuiltInType.SByte:   return Convert.ToDouble((sbyte)value);
                case BuiltInType.Byte:    return Convert.ToDouble((byte)value);
                case BuiltInType.Int16:   return Convert.ToDouble((short)value);
                case BuiltInType.UInt16:  return Convert.ToDouble((ushort)value);
                case BuiltInType.Int32:   return Convert.ToDouble((int)value);
                case BuiltInType.UInt32:  return Convert.ToDouble((uint)value);
                case BuiltInType.Int64:   return Convert.ToDouble((long)value);
                case BuiltInType.UInt64:  return Convert.ToDouble((ulong)value);
                case BuiltInType.Float:   return Convert.ToDouble((float)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToDouble((string)value); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }        

        /// <summary>
        /// Converts a value to a String
        /// </summary>
        private static object ToString(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                String[] output = new String[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (String)Cast(array.GetValue(ii), BuiltInType.String);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.String:
                {
                    return (string)value;
                }

                case BuiltInType.Boolean:
                {
                    return XmlConvert.ToString((bool)value);
                }

                case BuiltInType.SByte:
                {
                    return XmlConvert.ToString((sbyte)value); 
                }

                case BuiltInType.Byte:
                {
                    return XmlConvert.ToString((byte)value); 
                }

                case BuiltInType.Int16:
                {
                    return XmlConvert.ToString((short)value); 
                }

                case BuiltInType.UInt16:
                {
                    return XmlConvert.ToString((ushort)value); 
                }

                case BuiltInType.Int32:
                {
                    return XmlConvert.ToString((int)value); 
                }

                case BuiltInType.UInt32:
                {
                    return XmlConvert.ToString((uint)value); 
                }

                case BuiltInType.Int64:
                {
                    return XmlConvert.ToString((long)value); 
                }

                case BuiltInType.UInt64:
                {
                    return XmlConvert.ToString((ulong)value); 
                }

                case BuiltInType.Float:
                {
                    return XmlConvert.ToString((float)value); 
                }

                case BuiltInType.Double:
                {
                    return XmlConvert.ToString((double)value); 
                }

                case BuiltInType.DateTime:
                {
                    return XmlConvert.ToString((DateTime)value, XmlDateTimeSerializationMode.Unspecified); 
                }

                case BuiltInType.Guid:
                {
                    return ((Guid)value).ToString(); 
                }

                case BuiltInType.NodeId:
                {
                    return ((NodeId)value).ToString(); 
                }

                case BuiltInType.ExpandedNodeId:
                {
                    return ((ExpandedNodeId)value).ToString(); 
                }

                case BuiltInType.LocalizedText:
                {
                    return ((LocalizedText)value).Text; 
                }

                case BuiltInType.QualifiedName:
                {
                    return ((QualifiedName)value).ToString(); 
                }
            }
            
            // conversion not supported.
            return DBNull.Value;
        }

        /// <summary>
        /// Converts a value to a DateTime
        /// </summary>
        private static object ToDateTime(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                DateTime[] output = new DateTime[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (DateTime)Cast(array.GetValue(ii), BuiltInType.DateTime);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.DateTime:
                {
                    return (DateTime)value; 
                }

                case BuiltInType.String:
                {
                    return XmlConvert.ToDateTimeOffset((string) value); 
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a Guid
        /// </summary>
        private static object ToGuid(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                Guid[] output = new Guid[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (Guid)Cast(array.GetValue(ii), BuiltInType.Guid);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.Guid:
                {
                    return (Guid)value; 
                }

                case BuiltInType.String:
                {
                    return new Guid((string)value); 
                }

                case BuiltInType.ByteString:
                {
                    return new Guid((byte[])value); 
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a ByteString
        /// </summary>
        private static object ToByteString(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                byte[][] output = new byte[array.Length][];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (byte[])Cast(array.GetValue(ii), BuiltInType.ByteString);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.ByteString:
                {
                    return (byte[])value; 
                }

                case BuiltInType.Guid:
                {
                    return ((Guid)value).ToByteArray(); 
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a NodeId
        /// </summary>
        private static object ToNodeId(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                NodeId[] output = new NodeId[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (NodeId)Cast(array.GetValue(ii), BuiltInType.NodeId);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.NodeId:
                {
                    return (NodeId)value; 
                }

                case BuiltInType.ExpandedNodeId:
                {
                    return (NodeId)(ExpandedNodeId)value; 
                }

                case BuiltInType.String:
                {
                    return NodeId.Parse((string)value);
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a ExpandedNodeId
        /// </summary>
        private static object ToExpandedNodeId(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                ExpandedNodeId[] output = new ExpandedNodeId[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (ExpandedNodeId)Cast(array.GetValue(ii), BuiltInType.ExpandedNodeId);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.ExpandedNodeId:
                {
                    return (ExpandedNodeId)value; 
                }

                case BuiltInType.NodeId:
                {
                    return (ExpandedNodeId)(NodeId)value; 
                }

                case BuiltInType.String:
                {
                    return ExpandedNodeId.Parse((string)value);
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a StatusCode
        /// </summary>
        private static object ToStatusCode(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                StatusCode[] output = new StatusCode[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (StatusCode)Cast(array.GetValue(ii), BuiltInType.StatusCode);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.StatusCode:
                {
                    return (StatusCode)value; 
                }

                case BuiltInType.UInt16:
                {
                    uint code = Convert.ToUInt32((ushort)value);
                    code <<= 16;
                    return (StatusCode)code; 
                }

                case BuiltInType.Int32:
                {
                    return (StatusCode)Convert.ToUInt32((int)value); 
                }               

                case BuiltInType.UInt32:
                {
                    return (StatusCode)(uint)value; 
                }                     
                    
                case BuiltInType.Int64:
                {
                    return (StatusCode)Convert.ToUInt32((long)value); 
                }

                case BuiltInType.UInt64:
                {
                    return (StatusCode)Convert.ToUInt32((ulong)value); 
                }
            }
            
            // conversion not supported.
            return null;
        }
        
        /// <summary>
        /// Converts a value to a QualifiedName
        /// </summary>
        private static object ToQualifiedName(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                QualifiedName[] output = new QualifiedName[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (QualifiedName)Cast(array.GetValue(ii), BuiltInType.QualifiedName);
                }

                return output;
            }
            
            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.QualifiedName:
                {
                    return (QualifiedName)value; 
                }

                case BuiltInType.String:
                {
                    return QualifiedName.Parse((string)value);
                }
            }
            
            // conversion not supported.
            return null;
        }

        /// <summary>
        /// Converts a value to a LocalizedText
        /// </summary>
        private static object ToLocalizedText(object value, BuiltInType sourceType)
        {            
            // check for array conversions.

            if (value is Array array)
            {
                LocalizedText[] output = new LocalizedText[array.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    output[ii] = (LocalizedText)Cast(array.GetValue(ii), BuiltInType.LocalizedText);
                }

                return output;
            }

            // handle for supported conversions.
            switch (sourceType)
            {
                case BuiltInType.LocalizedText:
                {
                    return (LocalizedText)value; 
                }

                case BuiltInType.String:
                {
                    return new LocalizedText((string)value);
                }
            }

            // conversion not supported.
            return null;
        }
        
        /// <summary>
        /// Casts a value to the specified target type.
        /// </summary>
        private static object Cast(object source, BuiltInType targetType)
        {
            BuiltInType sourceType = GetBuiltInType(source);

            if (sourceType == BuiltInType.Null)
            {
                return null;
            }

            return Cast(source, sourceType, targetType); 
        }

        /// <summary>
        /// Casts a value to the specified target type.
        /// </summary>
        private static object Cast(object source, BuiltInType sourceType, BuiltInType targetType)
        {
            // null always casts to null.
            if (source == null)
            {
                return null;
            }

            // extract the value from a Variant if specified.
            if (source is Variant variant)
            {
                return Cast(variant.Value, targetType);
            }

            // call the appropriate function if a conversion is supported for the target type.
            try
            {
                switch (targetType)
                {
                    case BuiltInType.Boolean:        return ToBoolean(source, sourceType);                
                    case BuiltInType.SByte:          return ToSByte(source, sourceType);
                    case BuiltInType.Byte:           return ToByte(source, sourceType);
                    case BuiltInType.Int16:          return ToInt16(source, sourceType);
                    case BuiltInType.UInt16:         return ToUInt16(source, sourceType);
                    case BuiltInType.Int32:          return ToInt32(source, sourceType);
                    case BuiltInType.UInt32:         return ToUInt32(source, sourceType);
                    case BuiltInType.Int64:          return ToInt64(source, sourceType);
                    case BuiltInType.UInt64:         return ToUInt64(source, sourceType);
                    case BuiltInType.Float:          return ToFloat(source, sourceType);
                    case BuiltInType.Double:         return ToDouble(source, sourceType);
                    case BuiltInType.String:         return ToString(source, sourceType);
                    case BuiltInType.DateTime:       return ToDateTime(source, sourceType);
                    case BuiltInType.Guid:           return ToGuid(source, sourceType);
                    case BuiltInType.ByteString:     return ToByteString(source, sourceType);
                    case BuiltInType.NodeId:         return ToNodeId(source, sourceType);
                    case BuiltInType.ExpandedNodeId: return ToExpandedNodeId(source, sourceType);
                    case BuiltInType.StatusCode:     return ToStatusCode(source, sourceType);
                    case BuiltInType.QualifiedName:  return ToQualifiedName(source, sourceType);
                    case BuiltInType.LocalizedText:  return ToLocalizedText(source, sourceType);
                }
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Error converting a {1} (Value={0}) to {2}.", source, sourceType, targetType);
            }

            // conversion not supported.
            return null;
        }
        #endregion

        #region FilterOperator Implementations
        /// <summary>
        /// And FilterOperator
        /// </summary>
        private bool? And(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            // no need for further processing if first operand is false.
            if (GetValue(context, operands[0], target) is bool? lhs && !lhs.Value)
            {
                return false;
            }

            bool? rhs = GetValue(context, operands[1], target) as bool?;
            
            if (lhs == null)
            {
                if (rhs == null || rhs == true)
                {
                    return null;
                }
                else
                {
                    return false;
                }
            }
            
            if (rhs == null)
            {
                if (lhs == null || lhs == true)
                {
                    return null;
                }
                else
                {
                    return false;
                }
            }

            return lhs.Value && rhs.Value;
        }
        
        /// <summary>
        /// Or FilterOperator
        /// </summary>
        private bool? Or(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            // no need for further processing if first operand is true.
            if (GetValue(context, operands[0], target) is bool? lhs && lhs.Value)
            {
                return true;
            }

            bool? rhs = GetValue(context, operands[1], target) as bool?;
            
            if (lhs == null)
            {
                if (rhs == null || rhs == false)
            {
                return null;
            }
                else
                {
                    return true;
                }
            }

            if (rhs == null)
            {
                if (lhs == null || lhs == false)
                {
                    return null;
                }
                else
                {
                    return true;
                }
            }
            
            return lhs.Value || rhs.Value;
        }
        
        /// <summary>
        /// Not FilterOperator
        /// </summary>
        private bool? Not(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 1);

            bool? rhs = GetValue(context, operands[0], target) as bool?;
            
            if (rhs == null)
            {
                return null;
            }
            
            return !rhs.Value;
        }
        
        /// <summary>
        /// Equals FilterOperator
        /// </summary>
        private bool Equals(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object lhs = GetValue(context, operands[0], target);
            object rhs = GetValue(context, operands[1], target);

            DoImplicitConversion(ref lhs, ref rhs);

            return IsEqual(lhs, rhs);
        }
        
        /// <summary>
        /// GreaterThan FilterOperator
        /// </summary>
        private bool? GreaterThan(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object lhs = GetValue(context, operands[0], target);
            object rhs = GetValue(context, operands[1], target);

            DoImplicitConversion(ref lhs, ref rhs);

            if (lhs is IComparable && rhs is IComparable)
            {
                return ((IComparable)lhs).CompareTo(rhs) > 0;
            }

            // return null if the types are not comparable.
            return null;
        }
        
        /// <summary>
        /// GreaterThanOrEqual FilterOperator
        /// </summary>
        private bool? GreaterThanOrEqual(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object lhs = GetValue(context, operands[0], target);
            object rhs = GetValue(context, operands[1], target);

            DoImplicitConversion(ref lhs, ref rhs);

            if (lhs is IComparable && rhs is IComparable)
            {
                return ((IComparable)lhs).CompareTo(rhs) >= 0;
            }

            // return null if the types are not comparable.
            return null;
        }
                
        /// <summary>
        /// LessThan FilterOperator
        /// </summary>
        private bool? LessThan(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object lhs = GetValue(context, operands[0], target);
            object rhs = GetValue(context, operands[1], target);

            DoImplicitConversion(ref lhs, ref rhs);

            if (lhs is IComparable && rhs is IComparable)
            {
                return ((IComparable)lhs).CompareTo(rhs) < 0;
            }

            // return null if the types are not comparable.
            return null;
        }
        
        /// <summary>
        /// LessThanOrEqual FilterOperator
        /// </summary>
        private bool? LessThanOrEqual(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object lhs = GetValue(context, operands[0], target);
            object rhs = GetValue(context, operands[1], target);

            DoImplicitConversion(ref lhs, ref rhs);

            if (lhs is IComparable && rhs is IComparable)
            {
                return ((IComparable)lhs).CompareTo(rhs) <= 0;
            }

            // return null if the types are not comparable.
            return null;
        }
                
        /// <summary>
        /// Between FilterOperator
        /// </summary>
        private bool? Between(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 3);

            object value = GetValue(context, operands[0], target);

            object min = GetValue(context, operands[1], target);
            object max = GetValue(context, operands[2], target);
            
            // the min and max could be different data types so the implicit conversion must be done twice.
            object lhs = value;
            DoImplicitConversion(ref lhs, ref min);

            bool? result = null;
            
            if (lhs is IComparable && min is IComparable)
            {
                // check if never in range no matter what happens with the upper bound.
                if (((IComparable)lhs).CompareTo(min) < 0)
                {
                    return false;
                }

                result = true;
            }
            
            lhs = value;
            DoImplicitConversion(ref lhs, ref max);
            
            if (lhs is IComparable && max is IComparable)
            {
                // check if never in range no matter what happens with the lower bound.
                if (((IComparable)lhs).CompareTo(max) > 0)
                {
                    return false;
                }

                // can't determine if in range if lower bound could not be resolved.
                return result != null;
            }
            
            // return null if the types are not comparable.
            return null;
        }
                
        /// <summary>
        /// InList FilterOperator
        /// </summary>
        private bool? InList(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 0);

            object value = GetValue(context, operands[0], target);

            // check for a match.
            for (int ii = 1; ii < operands.Length; ii++)
            {                
                object lhs = value;
                object rhs = GetValue(context, operands[ii], target);

                DoImplicitConversion(ref lhs, ref rhs);

                if (IsEqual(lhs, rhs))
                {
                    return true;
                }
            }

            // no match.
            return false;
        }
        
        /// <summary>
        /// Like FilterOperator
        /// </summary>
        private bool Like(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);

            object firstOperand = GetValue(context, operands[0], target);
            string lhs;

            if (firstOperand is LocalizedText firstOperandLocalizedText)
            {
                lhs = firstOperandLocalizedText.Text;
            }
            else
            {
                lhs = firstOperand as string;
            }
            
            object secondOperand = GetValue(context, operands[1], target);
            string rhs;

            if (secondOperand is LocalizedText secondOperandLocalizedText)
            {
                rhs = secondOperandLocalizedText.Text;
            }
            else
            {
                rhs = secondOperand as string;
            }

            // this operator requires strings.
            if (lhs == null || rhs == null)
            {
                return false;
            }
          
            return Match((string)lhs, (string)rhs);
        }
        
        /// <summary>
        /// IsNull FilterOperator
        /// </summary>
        private bool IsNull(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 1);

            object rhs = GetValue(context, operands[0], target);
            
            if (rhs == null)
            {
                return true;
            }
            
            return false;
        }

        /// <summary>
        /// Cast FilterOperator
        /// </summary>
        private object Cast(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 2);
            
            // get the value to cast.
            object value = GetValue(context, operands[0], target);

            if (value == null)
            {
                return null;
            }

            // get the datatype to cast to.
            NodeId datatype = GetValue(context, operands[1], target) as NodeId;

            if (datatype == null)
            {
                return null;
            }

            BuiltInType targetType = GetBuiltInType(datatype);
            
            // cast the value.
            return Cast(value, targetType);
        }
                
        /// <summary>
        /// OfType FilterOperator
        /// </summary>
        private bool OfType(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            FilterOperand[] operands = GetOperands(element, 1);
            
            // get the desired type.
            NodeId typeDefinitionId = GetValue(context, operands[0], target) as NodeId;

            if (typeDefinitionId == null || target == null)
            {
                return false;
            }

            // check the type.
            try
            {
                return target.IsTypeOf(context, typeDefinitionId);
            }
            catch
            {
                return false;
            }
        }
                
        /// <summary>
        /// InView FilterOperator
        /// </summary>
        private bool InView(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            // views only supported in advanced filter targets.
            IAdvancedFilterTarget advancedFilter = target as IAdvancedFilterTarget;

            if (advancedFilter == null)
            {
                return false;
            }

            FilterOperand[] operands = GetOperands(element, 1);
            
            // get the desired type.
            NodeId viewId = GetValue(context, operands[0], target) as NodeId;

            if (viewId == null || target == null)
            {
                return false;
            }

            // check the target.
            try
            {
                return advancedFilter.IsInView(context, viewId);
            }
            catch
            {
                return false;
            }
        }
        
        /// <summary>
        /// RelatedTo FilterOperator
        /// </summary>
        private bool RelatedTo(FilterContext context, IFilterTarget target, ContentFilterElement element)
        {
            return RelatedTo(context, target, element, null);
        }

        /// <summary>
        /// RelatedTo FilterOperator
        /// </summary>
        private bool RelatedTo(FilterContext context, IFilterTarget target, ContentFilterElement element, NodeId intermediateNodeId)
        {
            // RelatedTo only supported in advanced filter targets.
            IAdvancedFilterTarget advancedTarget = target as IAdvancedFilterTarget;

            if (advancedTarget == null)
            {
                return false;
            }

            FilterOperand[] operands = GetOperands(element, 6);
            
            // get the type of the source.
            NodeId sourceTypeId = GetValue(context, operands[0], target) as NodeId;

            if (sourceTypeId == null)
            {
                return false;
            }
                        
            // get the type of reference to follow.
            NodeId referenceTypeId = GetValue(context, operands[2], target) as NodeId;

            if (referenceTypeId == null)
            {
                return false;
            }
            
            // get the number of hops
            int? hops = 1;

            object hopsValue = GetValue(context, operands[3], target);

            if (hopsValue != null)
            {
                hops = Cast(hopsValue, BuiltInType.Int32) as int?;

                if (hops == null)
                {
                    hops = 1;
                }
            }

            // get whether to include type definition subtypes.
            bool? includeTypeDefinitionSubtypes = true;

            object includeValue = GetValue(context, operands[4], target);

            if (includeValue != null)
            {
                includeTypeDefinitionSubtypes = Cast(includeValue, BuiltInType.Boolean) as bool?;

                if (includeTypeDefinitionSubtypes == null)
                {
                    includeTypeDefinitionSubtypes = true;
                }
            }

            // get whether to include reference type subtypes.
            bool? includeReferenceTypeSubtypes = true;

            includeValue = GetValue(context, operands[5], target);

            if (includeValue != null)
            {
                includeReferenceTypeSubtypes = Cast(includeValue, BuiltInType.Boolean) as bool?;

                if (includeReferenceTypeSubtypes == null)
                {
                    includeReferenceTypeSubtypes = true;
                }
            }

            NodeId targetTypeId = null;

            // check if elements are chained.

            if (operands[1] is ElementOperand chainedOperand)
            {
                if (chainedOperand.Index < 0 || chainedOperand.Index >= Elements.Count)
                {
                    return false;
                }

                ContentFilterElement chainedElement = Elements[(int)chainedOperand.Index];

                // get the target type from the first operand of the chained element.
                if (chainedElement.FilterOperator == FilterOperator.RelatedTo)
                {
                    FilterOperand nestedType = ExtensionObject.ToEncodeable(chainedElement.FilterOperands[0]) as FilterOperand;

                    targetTypeId = GetValue(context, nestedType, target) as NodeId;

                    if (targetTypeId == null)
                    {
                        return false;
                    }

                    // find the nodes that meet the criteria in the first link of the chain.
                    IList<NodeId> nodeIds = advancedTarget.GetRelatedNodes(
                        context,
                        intermediateNodeId,
                        sourceTypeId,
                        targetTypeId,
                        referenceTypeId,
                        hops.Value,
                        includeTypeDefinitionSubtypes.Value,
                        includeReferenceTypeSubtypes.Value);

                    if (nodeIds == null || nodeIds.Count == 0)
                    {
                        return false;
                    }
                    
                    // recursively follow the chain.
                    for (int ii = 0; ii < nodeIds.Count; ii++)
                    {
                        // one match is all that is required.
                        if (RelatedTo(context, target, chainedElement, nodeIds[ii]))
                        {
                            return true;
                        }
                    }

                    // no matches.
                    return false;
                }
            }
            
            // get the type of the target.
            if (targetTypeId == null)
            {
                targetTypeId = GetValue(context, operands[1], target) as NodeId;

                if (targetTypeId == null)
                {
                    return false;
                }
            }

            // check the target.            
            try
            {
                bool relatedTo = advancedTarget.IsRelatedTo(
                    context,
                    intermediateNodeId,
                    sourceTypeId,
                    targetTypeId,
                    referenceTypeId,
                    hops.Value,
                    includeTypeDefinitionSubtypes.Value,
                    includeReferenceTypeSubtypes.Value);

                return relatedTo;
            }
            catch
            {
                return false;
            }
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Stack\Types\ContentFilter.Evaluate.cs(1499,59): error CS8116: It is not legal to use nullable type 'bool?' in a pattern; use the underlying type 'bool' instead.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\Types\ContentFilter.Evaluate.cs(1506,17): error CS0165: Use of unassigned local variable 'lhs',D:\a\1\s\Stack\Opc.Ua.Core\Stack\Types\ContentFilter.Evaluate.cs(1541,59): error CS8116: It is not legal to use nullable type 'bool?' in a pattern; use the underlying type 'bool' instead.,D:\a\1\s\Stack\Opc.Ua.Core\Stack\Types\ContentFilter.Evaluate.cs(1548,17): error CS0165: Use of unassigned local variable 'lhs'
######################################################################


######################################################################
Nr: 19 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\NodeId.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.Serialization;
using System.Text;

namespace Opc.Ua
{
    /// <summary>
    /// Stores an identifier for a node in a server's address space.
    /// </summary>
    /// <remarks>
    /// <para>
    /// <b>Please refer to OPC Specifications</b>:
    /// <list type="bullet">
    /// <item><b>Address Space Model</b> setion <b>7.2</b></item>
    /// <item><b>Address Space Model</b> setion <b>5.2.2</b></item>
    /// </list>
    /// </para>
    /// <para>
    /// Stores the id of a Node, which resides within the server's address space.
    /// <br/></para>
    /// <para>
    /// The NodeId can be either:
    /// <list type="bullet">
    /// <item><see cref="uint"/></item>
    /// <item><see cref="Guid"/></item>
    /// <item><see cref="string"/></item>
    /// <item><see cref="byte"/>[]</item>
    /// </list>
    /// <br/></para>
    /// <note>
    /// <b>Important:</b> Keep in mind that the actual ID's of nodes should be unique such that no two
    /// nodes within an address-space share the same ID's.
    /// </note>
    /// <para>
    /// The NodeId can be assigned to a particular namespace index. This index is merely just a number and does
    /// not represent some index within a collection that this node has any knowledge of. The assumption is
    /// that the host of this object will manage that directly.
    /// <br/></para>
    /// </remarks>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class NodeId : IComparable, IFormattable
    {
        #region Constructors
        #region public NodeId()

        /// <summary>
        /// Initializes the object with default values.
        /// </summary>
        /// <remarks>
        /// Creates a new instance of the class which will have the default values. The actual
        /// Node Id will need to be defined as this constructor does not specify the id.
        /// </remarks>
        public NodeId()
        {
            Initialize();
        }

        #endregion
        #region public NodeId(NodeId value)
        /// <summary>
        /// Creates a deep copy of the value.
        /// </summary>
        /// <remarks>
        /// Creates a new NodeId by copying the properties of the node specified in the parameter.
        /// </remarks>
        /// <param name="value">The NodeId object whose properties will be copied.</param>
        /// <exception cref="ArgumentNullException">Thrown when <i>value</i> is null</exception>
        public NodeId(NodeId value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            m_namespaceIndex = value.m_namespaceIndex;
            m_identifierType = value.m_identifierType;
            m_identifier = Utils.Clone(value.m_identifier);
        }
        #endregion
        #region public NodeId(uint value)
        /// <summary>
        /// Initializes a numeric node identifier.
        /// </summary>
        /// <remarks>
        /// Creates a new NodeId that will have a numeric (unsigned-int) id
        /// </remarks>
        /// <param name="value">The numeric value of the id</param>
        public NodeId(uint value)
        {
            m_namespaceIndex = 0;
            m_identifierType = IdType.Numeric;
            m_identifier = value;
        }
        #endregion
        #region public NodeId(uint value, ushort namespaceIndex)
        /// <summary>
        /// Initializes a guid node identifier with a namespace index.
        /// </summary>
        /// <remarks>
        /// Creates a new NodeId that will use a numeric (unsigned int) for its Id, but also
        /// specifies which namespace this node should belong to.
        /// </remarks>
        /// <param name="value">The new (numeric) Id for the node being created</param>
        /// <param name="namespaceIndex">The index of the namespace that this node should belong to</param>
        /// <seealso cref="SetNamespaceIndex"/>
        public NodeId(uint value, ushort namespaceIndex)
        {
            m_namespaceIndex = namespaceIndex;
            m_identifierType = IdType.Numeric;
            m_identifier = value;
        }

        #endregion

        #region public NodeId(string value, ushort namespaceIndex)
        /// <summary>
        /// Initializes a string node identifier with a namespace index.
        /// </summary>
        /// <remarks>
        /// Creates a new NodeId that will use a string for its Id, but also
        /// specifies if the Id is a URI, and which namespace this node belongs to.
        /// </remarks>
        /// <param name="value">The new (string) Id for the node being created</param>
        /// <param name="namespaceIndex">The index of the namespace that this node belongs to</param>
        public NodeId(string value, ushort namespaceIndex)
        {
            m_namespaceIndex = namespaceIndex;
            m_identifierType = IdType.String;
            m_identifier = value;
        }

        #endregion
        #region public NodeId(Guid value)
        /// <summary>
        /// Initializes a guid node identifier.
        /// </summary>
        /// <remarks>
        /// Creates a new node whose Id will be a <see cref="Guid"/>.
        /// </remarks>
        /// <param name="value">The new Guid value of this nodes Id.</param>
        public NodeId(Guid value)
        {
            m_namespaceIndex = 0;
            m_identifierType = IdType.Guid;
            m_identifier = value;
        }

        #endregion        

        #region public NodeId(Guid value, ushort namespaceIndex)
        /// <summary>
        /// Initializes a guid node identifier.
        /// </summary>
        /// <remarks>
        /// Creates a new node whose Id will be a <see cref="Guid"/>.
        /// </remarks>
        /// <param name="value">The new Guid value of this nodes Id.</param>
        /// <param name="namespaceIndex">The index of the namespace that this node belongs to</param>
        public NodeId(Guid value, ushort namespaceIndex)
        {
            m_namespaceIndex = namespaceIndex;
            m_identifierType = IdType.Guid;
            m_identifier = value;
        }
        #endregion    

        #region public NodeId(byte[] value)
        /// <summary>
        /// Initializes a guid node identifier.
        /// </summary>
        /// <remarks>
        /// Creates a new node whose Id will be a series of <see cref="Byte"/>.
        /// </remarks>
        /// <param name="value">An array of <see cref="Byte"/> that will become this Node's ID</param>
        public NodeId(byte[] value)
        {
            m_namespaceIndex = 0;
            m_identifierType = IdType.Opaque;
            m_identifier = null;

            if (value != null)
            {
                byte[] copy = new byte[value.Length];
                Array.Copy(value, copy, value.Length);
                m_identifier = copy;
            }
        }

        #endregion        
        #region public NodeId(byte[] value, ushort namespaceIndex)
        /// <summary>
        /// Initializes an opaque node identifier with a namespace index.
        /// </summary>
        /// <remarks>
        /// Creates a new node whose Id will be a series of <see cref="Byte"/>, while specifying
        /// the index of the namespace that this node belongs to.
        /// </remarks>
        /// <param name="value">An array of <see cref="Byte"/> that will become this Node's ID</param>
        /// <param name="namespaceIndex">The index of the namespace that this node belongs to</param>
        public NodeId(byte[] value, ushort namespaceIndex)
        {
            m_namespaceIndex = namespaceIndex;
            m_identifierType = IdType.Opaque;
            m_identifier = null;

            if (value != null)
            {
                byte[] copy = new byte[value.Length];
                Array.Copy(value, copy, value.Length);
                m_identifier = copy;
            }
        }

        #endregion
        #region public NodeId(string text)
        /// <summary>
        /// Initializes a node id by parsing a node id string.
        /// </summary>
        /// <remarks>
        /// Creates a new node with a String id.
        /// </remarks>
        /// <param name="text">The string id of this new node</param>
        public NodeId(string text)
        {
            NodeId nodeId = NodeId.Parse(text);

            m_namespaceIndex = nodeId.NamespaceIndex;
            m_identifierType = nodeId.IdType;
            m_identifier = nodeId.Identifier;
        }

        #endregion

        #region public NodeId(object value, ushort namespaceIndex)
        /// <summary>
        /// Initializes a node identifier with a namespace index.
        /// </summary>
        /// <remarks>
        /// Throws an exception if the identifier type is not supported.
        /// </remarks>
        /// <param name="value">The identifier</param>
        /// <param name="namespaceIndex">The index of the namespace that qualifies the node</param>
        public NodeId(object value, ushort namespaceIndex)
        {
            m_namespaceIndex = namespaceIndex;

            if (value is uint)
            {
                SetIdentifier(IdType.Numeric, value);
                return;
            }

            if (value == null || value is string)
            {
                SetIdentifier(IdType.String, value);
                return;
            }

            if (value is Guid)
            {
                SetIdentifier(IdType.Guid, value);
                return;
            }

            if (value is Uuid)
            {
                SetIdentifier(IdType.Guid, value);
                return;
            }

            if (value is byte[])
            {
                SetIdentifier(IdType.Opaque, value);
                return;
            }

            throw new ArgumentException("Identifier type not supported.", nameof(value));
        }
        #endregion

        /// <summary>
        /// Initializes the object during deserialization.
        /// </summary>
        [OnDeserializing()]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        /// <summary>
        /// Initializes the object during deserialization.
        /// </summary>
        private void Initialize()
        {
            m_namespaceIndex = 0;
            m_identifierType = IdType.Numeric;
            m_identifier = null;
        }
        #endregion

        #region Static Members
        /// <summary>
        /// Converts an identifier and a namespaceUri to a local NodeId using the namespaceTable.
        /// </summary>
        /// <param name="identifier">The identifier for the node.</param>
        /// <param name="namespaceUri">The URI to look up.</param>
        /// <param name="namespaceTable">The table to use for the URI lookup.</param>
        /// <returns>A local NodeId</returns>
        /// <exception cref="ServiceResultException">Thrown when the namespace cannot be found</exception>
        public static NodeId Create(object identifier, string namespaceUri, NamespaceTable namespaceTable)
        {
            int index = -1;

            if (namespaceTable != null)
            {
                index = namespaceTable.GetIndex(namespaceUri);
            }

            if (index < 0)
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, "NamespaceUri ({0}) is not in the namespace table.", namespaceUri);
            }

            return new NodeId(identifier, (ushort)index);
        }

        #region public static implicit operator NodeId(uint value)
        /// <summary>
        /// Converts an integer to a numeric node identifier.
        /// </summary>
        /// <remarks>
        /// Converts an integer to a numeric node identifier for comparissons.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// 
        /// //create some variables
        /// uint id1 = 100, id2=101;
        /// NodeId node1;
        /// 
        /// //create our node
        /// node1 = new NodeId(id1);
        /// 
        /// //now to compare the node to the ids using a simple comparisson and Equals:
        /// Utils.Trace("Comparing NodeId to uint");
        /// Utils.Trace("\tComparing 100 to 100 = [equals] {0}", node1.Equals(id1));
        /// Utils.Trace("\tComparing 100 to 100 = [ ==   ] {0}", node1 == id1);
        /// Utils.Trace("\tComparing 100 to 101 = [equals] {0}", node1.Equals(id2));
        /// Utils.Trace("\tComparing 100 to 101 = [ ==   ] {0}", node1 == id2);
        /// 
        /// </code>
        /// <code lang="Visual Basic">
        /// 
        /// 'create some variables
        /// Dim id1 As UInt = 100
        /// Dim id2 As UInt = 102
        /// Dim node1 As NodeId
        /// 
        /// 'create our node
        /// node1 = new NodeId(id1)
        /// 
        /// 'now to compare the node to the ids using a simple comparisson and Equals:
        /// Utils.Trace("Comparing NodeId to uint")
        /// Utils.Trace( String.Format("   Comparing 100 to 100 = [equals] {0}", node1.Equals(id1)) )
        /// Utils.Trace( String.Format("   Comparing 100 to 100 = [  =   ] {0}", node1 = id1) )
        /// Utils.Trace( String.Format("   Comparing 100 to 101 = [equals] {0}", node1.Equals(id2)) )
        /// Utils.Trace( String.Format("   Comparing 100 to 101 = [  =   ] {0}", node1 = id2) )
        /// 
        /// </code>
        /// <para>
        /// This produces the following output (taken from C# example):
        /// <br/></para>
        /// <para>
        /// Comparing NodeId to uint<br/>
        ///     Comparing 100 to 100 = [equals] True<br/>
        ///     Comparing 100 to 100 = [ ==   ] True<br/>
        ///     Comparing 100 to 101 = [equals] False<br/>
        ///     Comparing 100 to 101 = [ ==   ] False<br/>
        /// <br/></para>
        /// </example>
        /// <param name="value">The <see cref="uint"/> to compare this node to.</param>
        public static implicit operator NodeId(uint value)
        {
            return new NodeId(value);
        }

        #endregion
        #region public static implicit operator NodeId(Guid value)
        /// <summary>
        /// Converts a guid to a guid node identifier.
        /// </summary>
        /// <remarks>
        /// Converts a NodeId into a Guid allowing you to compare a Node against a Guid.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// 
        /// //define our 2 GUID ids, and then define our node to use the first id.
        /// Guid id1 = Guid.NewGuid(), id2 = Guid.NewGuid();
        /// NodeId node1 = new NodeId(id1);
        /// 
        /// //now to compare the node to the guids
        /// Utils.Trace("\n\nComparing NodeId to GUID");
        /// Utils.Trace("\tComparing {0} to {0} = [equals] {2}", id1, id1, node1.Equals(id1));
        /// Utils.Trace("\tComparing {0} to {0} = [ ==   ] {2}", id1, id1, node1 == id1);
        /// Utils.Trace("\tComparing {0} to {1} = [equals] {2}", id1, id2, node1.Equals(id2));
        /// Utils.Trace("\tComparing {0} to {1} = [ ==   ] {2}", id1, id2, node1 == id2);
        /// 
        /// </code>
        /// <code lang="Visual Basic">
        /// 
        /// 'define our 2 GUID ids, and then define our node to use the first id.
        /// Dim id1 As Guid = Guid.NewGuid()
        /// Dim id2 As Guid = Guid.NewGuid()
        /// Dim node1 As NodeId = new NodeId(id1)
        /// 
        /// 'now to compare the node to the guids
        /// Utils.Trace("Comparing NodeId to GUID")
        /// Utils.Trace( String.Format( "  Comparing {0} to {0} = [equals] {2}", id1, id1, node1.Equals(id1)) );
        /// Utils.Trace( String.Format( "  Comparing {0} to {0} = [  =   ] {2}", id1, id1, node1 = id1) );
        /// Utils.Trace( String.Format( "  Comparing {0} to {0} = [equals] {2}", id1, id2, node1.Equals(id2)) );
        /// Utils.Trace( String.Format( "  Comparing {0} to {0} = [  =   ] {2}", id1, id2, node1 = id2) );
        /// 
        /// </code>
        /// <para>
        /// This produces the following output (taken from C# example):
        /// <br/></para>
        /// <para>
        /// Comparing NodeId to GUID<br/>
        ///     Comparing bbe8b5f2-0f50-4302-877f-346afb07704c to bbe8b5f2-0f50-4302-877f-346afb07704c = [equals] True<br/>
        ///     Comparing bbe8b5f2-0f50-4302-877f-346afb07704c to bbe8b5f2-0f50-4302-877f-346afb07704c = [  =   ] True<br/>
        ///     Comparing bbe8b5f2-0f50-4302-877f-346afb07704c to e707de86-4c11-4fe6-94b2-83638a9427e6 = [equals] False<br/>
        ///     Comparing bbe8b5f2-0f50-4302-877f-346afb07704c to e707de86-4c11-4fe6-94b2-83638a9427e6 = [  =   ] False<br/>
        /// <br/></para>
        /// </example>
        /// <param name="value">The <see cref="Guid"/> to compare this node to.</param>
        public static implicit operator NodeId(Guid value)
        {
            return new NodeId(value);
        }

        #endregion
        #region public static implicit operator NodeId(byte[] value)
        /// <summary>
        /// Converts a byte array to an opaque node identifier.
        /// </summary>
        /// <remarks>
        /// This operator allows you to compare a NodeId to an array of Bytes.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// 
        /// //define our 2 Byte[] ids, and then define our node to use the first id.
        /// byte[] id1 = new byte[] { 65, 66, 67, 68, 69 };
        /// byte[] id2 = new byte[] { 97, 98, 99, 100, 101 };
        /// NodeId node1 = new NodeId(id1);
        /// 
        /// //convert our bytes to string so we can display them 
        /// string id1String = System.Text.ASCIIEncoding.ASCII.GetString(id1);
        /// string id2String = System.Text.ASCIIEncoding.ASCII.GetString(id2);
        /// 
        /// //now to compare the node to the guids
        /// Utils.Trace("\n\nComparing NodeId to Byte[]");
        /// Utils.Trace("\tComparing {0} to {0} = [equals] {2}", id1String, id1String, node1.Equals(id1));
        /// Utils.Trace("\tComparing {0} to {0} = [  =   ] {2}", id1String, id1String, node1 == id1);
        /// Utils.Trace("\tComparing {0} to {1} = [equals] {2}", id1String, id2String, node1.Equals(id2));
        /// Utils.Trace("\tComparing {0} to {1} = [  =   ] {2}", id1String, id2String, node1 == id2);
        /// 
        /// </code>
        /// <code lang="Visual Basic">
        /// 
        /// 'define our 2 Byte[] ids, and then define our node to use the first id.
        /// Dim id1 As Byte() = New Byte() { 65, 66, 67, 68, 69 }
        /// Dim id2 As Byte() = New Byte() { 97, 98, 99, 100, 101 }
        /// Dim node1 As NodeId = New NodeId(id1)
        /// 
        /// 'convert our bytes to string so we can display them 
        /// Dim id1String As String = System.Text.ASCIIEncoding.ASCII.GetString(id1)
        /// Dim id2String As String = System.Text.ASCIIEncoding.ASCII.GetString(id2)
        /// 
        /// 'now to compare the node to the guids
        /// Utils.Trace("Comparing NodeId to Byte()")
        /// Utils.Trace( String.Format("Comparing {0} to {0} = [equals] {2}", id1String, id1String, node1.Equals(id1)) )
        /// Utils.Trace( String.Format("Comparing {0} to {0} = [  =   ] {2}", id1String, id1String, node1 = id1) )
        /// Utils.Trace( String.Format("Comparing {0} to {1} = [equals] {2}", id1String, id2String, node1.Equals(id2)) )
        /// Utils.Trace( String.Format("Comparing {0} to {1} = [  =   ] {2}", id1String, id2String, node1 = id2) )
        /// 
        /// </code>
        /// <para>
        /// This produces the following output (taken from C# example):
        /// <br/></para>
        /// <para>
        /// Comparing NodeId to Byte[]
        ///     Comparing ABCDE to ABCDE = [equals] True
        ///     Comparing ABCDE to ABCDE = [ ==   ] True
        ///     Comparing ABCDE to abcde = [equals] False
        ///     Comparing ABCDE to abcde = [ ==   ] False
        /// <br/></para>
        /// </example>
        /// <param name="value">The <see cref="Byte"/>[] array to compare this node to</param>
        public static implicit operator NodeId(byte[] value)
        {
            return new NodeId(value);
        }

        #endregion
        #region public static implicit operator NodeId(string text)
        /// <summary>
        /// Parses a node id string and initializes a node id.
        /// </summary>
        /// <remarks>
        /// Compares a Node to a String
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// 
        /// //define our 2 String ids, and then define our node to use the first id.
        /// String id1 = "Hello", id2 = "World";
        /// NodeId node1 = new NodeId(id1);
        /// 
        /// //now to compare the node to the guids
        /// Utils.Trace("\n\nComparing NodeId to String");
        /// Utils.Trace("\tComparing {0} to {0} = [equals] {2}", id1, id1, node1.Equals(id1));
        /// Utils.Trace("\tComparing {0} to {0} = [ ==   ] {2}", id1, id1, node1 == id1);
        /// Utils.Trace("\tComparing {0} to {1} = [equals] {2}", id1, id2, node1.Equals(id2));
        /// Utils.Trace("\tComparing {0} to {1} = [ ==   ] {2}", id1, id2, node1 == id2);
        /// 
        /// 
        /// </code>
        /// <code lang="Visual Basic">
        /// 
        /// 'define our 2 String ids, and then define our node to use the first id.
        /// Dim id1 As String = "Hello"
        /// Dim id2 As String = "World"
        /// Dim node1 As NodeId = New NodeId(id1)
        /// 
        /// 'now to compare the node to the guids
        /// Utils.Trace("Comparing NodeId to String");
        /// Utils.Trace(String.Format("Comparing {0} to {0} = [equals] {2}", id1, id1, node1.Equals(id1)));
        /// Utils.Trace(String.Format("Comparing {0} to {0} = [  =   ] {2}", id1, id1, node1 = id1));
        /// Utils.Trace(String.Format("Comparing {0} to {1} = [equals] {2}", id1, id2, node1.Equals(id2)));
        /// Utils.Trace(String.Format("Comparing {0} to {1} = [  =   ] {2}", id1, id2, node1 = id2));
        /// 
        /// </code>
        /// </example>
        /// <param name="text">The <see cref="String"/> to compare this node to.</param>
        public static implicit operator NodeId(string text)
        {
            return NodeId.Parse(text);
        }

        #endregion
        #region public static bool IsNull(NodeId nodeId)
        /// <summary>
        /// Checks if the node id represents a 'Null' node id.
        /// </summary>
        /// <remarks>
        /// Returns a true/false value to indicate if the specified NodeId is null.
        /// </remarks>
        /// <param name="nodeId">The NodeId to validate</param>
        public static bool IsNull(NodeId nodeId)
        {
            if (nodeId == null)
            {
                return true;
            }

            return nodeId.IsNullNodeId;
        }

        #endregion
        #region public static bool IsNull(ExpandedNodeId nodeId)
        /// <summary>
        /// Checks if the node id represents a 'Null' node id.
        /// </summary>
        /// <remarks>
        /// Returns a true/false to indicate if the specified <see cref="ExpandedNodeId"/> is null.
        /// </remarks>
        /// <param name="nodeId">The ExpandedNodeId to validate</param>
        public static bool IsNull(ExpandedNodeId nodeId)
        {
            if (nodeId == null)
            {
                return true;
            }

            return nodeId.IsNull;
        }
        #endregion
        #region public static NodeId Parse(string text)
        /// <summary>
        /// Parses a node id string and returns a node id object.
        /// </summary>
        /// <remarks>
        /// Parses a NodeId String and returns a NodeId object
        /// </remarks>
        /// <param name="text">The NodeId value as a string.</param>
        /// <exception cref="ServiceResultException">Thrown under a variety of circumstances, each time with a specific message.</exception>
        public static NodeId Parse(string text)
        {
            try
            {
                if (String.IsNullOrEmpty(text))
                {
                    return NodeId.Null;
                }

                ushort namespaceIndex = 0;

                // parse the namespace index if present.
                if (text.StartsWith("ns=", StringComparison.Ordinal))
                {
                    int index = text.IndexOf(';');

                    if (index == -1)
                    {
                        throw new ServiceResultException(StatusCodes.BadNodeIdInvalid, "Invalid namespace index.");
                    }

                    namespaceIndex = Convert.ToUInt16(text.Substring(3, index - 3), CultureInfo.InvariantCulture);

                    text = text.Substring(index + 1);
                }

                // parse numeric node identifier.
                if (text.StartsWith("i=", StringComparison.Ordinal))
                {
                    return new NodeId(Convert.ToUInt32(text.Substring(2), CultureInfo.InvariantCulture), namespaceIndex);
                }

                // parse string node identifier.
                if (text.StartsWith("s=", StringComparison.Ordinal))
                {
                    return new NodeId(text.Substring(2), namespaceIndex);
                }

                // parse guid node identifier.
                if (text.StartsWith("g=", StringComparison.Ordinal))
                {
                    return new NodeId(new Guid(text.Substring(2)), namespaceIndex);
                }

                // parse opaque node identifier.
                if (text.StartsWith("b=", StringComparison.Ordinal))
                {
                    return new NodeId(Convert.FromBase64String(text.Substring(2)), namespaceIndex);
                }

                // treat as a string identifier if a namespace was specified.
                if (namespaceIndex != 0)
                {
                    return new NodeId(text, namespaceIndex);
                }

                // treat as URI identifier.
                return new NodeId(text, 0);
            }
            catch (Exception e)
            {
                throw new ServiceResultException(
                    StatusCodes.BadNodeIdInvalid,
                    Utils.Format("Cannot parse node id text: '{0}'", text),
                    e);
            }
        }
        #endregion

        /// <summary>
        /// Returns an instance of a null NodeId.
        /// </summary>
        public static NodeId Null => s_Null;

        private static readonly NodeId s_Null = new NodeId();
        #endregion

        #region Public Methods (and some Internals)

        #region public string Format()
        /// <summary>
        /// Formats a node id as a string.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Formats a NodeId as a string.
        /// <br/></para>
        /// <para>
        /// An example of this would be:
        /// <br/></para>
        /// <para>
        /// NodeId = "hello123"<br/>
        /// NamespaceId = 1;<br/>
        /// <br/> This would translate into:<br/>
        /// ns=1;s=hello123
        /// <br/></para>
        /// </remarks>
        public string Format()
        {
            StringBuilder buffer = new StringBuilder();
            Format(buffer);
            return buffer.ToString();
        }

        /// <summary>
        /// Formats the NodeId as a string and appends it to the buffer.
        /// </summary>
        public void Format(StringBuilder buffer)
        {
            Format(buffer, m_identifier, m_identifierType, m_namespaceIndex);
        }

        /// <summary>
        /// Formats the NodeId as a string and appends it to the buffer.
        /// </summary>
        public static void Format(StringBuilder buffer, object identifier, IdType identifierType, ushort namespaceIndex)
        {
            if (namespaceIndex != 0)
            {
                buffer.AppendFormat(CultureInfo.InvariantCulture, "ns={0};", namespaceIndex);
            }

            // add identifier type prefix.
            switch (identifierType)
            {
                case IdType.Numeric:
                {
                    buffer.Append("i=");
                    break;
                }

                case IdType.String:
                {
                    buffer.Append("s=");
                    break;
                }

                case IdType.Guid:
                {
                    buffer.Append("g=");
                    break;
                }

                case IdType.Opaque:
                {
                    buffer.Append("b=");
                    break;
                }
            }

            // add identifier.
            FormatIdentifier(buffer, identifier, identifierType);
        }
        #endregion

        #region public override string ToString()

        /// <summary>
        /// Returns the string representation of a NodeId.
        /// </summary>
        /// <remarks>
        /// Returns the Node represented as a String. This is the same as calling
        /// <see cref="Format()"/>.
        /// </remarks>
        public override string ToString()
        {
            return ToString(null, null);
        }

        #endregion
        #region public static ExpandedNodeId ToExpandedNodeId(NodeId nodeId, NamespaceTable namespaceTable)
        /// <summary>
        /// Converts an node id to an expanded node id using a namespace table.
        /// </summary>
        /// <remarks>
        /// Returns an ExpandedNodeId based on the NodeId requested in the parameters. If the namespaceTable
        /// is specified then the relevant namespace will be returned from the namespaceTable collection which is
        /// also passed in as a parameter.
        /// </remarks>
        /// <returns>null, if the <i>nodeId</i> parameter is null. Otherwise an ExpandedNodeId will be returned for the specified nodeId</returns>
        /// <param name="nodeId">The NodeId to return, wrapped in within the ExpandedNodeId.</param>
        /// <param name="namespaceTable">The namespace tables collection that may be used to retrieve the namespace from that the specified NodeId belongs to</param>
        public static ExpandedNodeId ToExpandedNodeId(NodeId nodeId, NamespaceTable namespaceTable)
        {
            if (nodeId == null)
            {
                return null;
            }

            ExpandedNodeId expandedId = new ExpandedNodeId(nodeId);

            if (nodeId.NamespaceIndex > 0)
            {
                string uri = namespaceTable.GetString(nodeId.NamespaceIndex);

                if (uri != null)
                {
                    expandedId.SetNamespaceUri(uri);
                }
            }

            return expandedId;
        }

        #endregion
        /// <summary>
        /// Updates the namespace index.
        /// </summary>
        internal void SetNamespaceIndex(ushort value)
        {
            m_namespaceIndex = value;
        }

        /// <summary>
        /// Updates the identifier.
        /// </summary>
        internal void SetIdentifier(IdType idType, object value)
        {
            m_identifierType = idType;

            switch (idType)
            {
                case IdType.Opaque:
                {
                    m_identifier = Utils.Clone(value);
                    break;
                }

                default:
                {
                    m_identifier = value;
                    break;
                }
            }
        }

        /// <summary>
        /// Updates the identifier.
        /// </summary>
        internal void SetIdentifier(string value, IdType idType)
        {
            m_identifierType = idType;
            SetIdentifier(IdType.String, value);
        }

        #endregion

        #region IComparable Members

        #region public int CompareTo(object obj)
        /// <summary>
        /// Compares the current instance to the object.
        /// </summary>
        /// <remarks>
        /// Enables this object type to be compared to other types of object.
        /// </remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public int CompareTo(object obj)
        {
            // check for null.
            if (Object.ReferenceEquals(obj, null))
            {
                return -1;
            }

            // check for reference comparisons.
            if (Object.ReferenceEquals(this, obj))
            {
                return 0;
            }

            ushort namespaceIndex = this.m_namespaceIndex;
            IdType idType = this.m_identifierType;
            object id = null;

            // check for expanded node ids.
            NodeId nodeId = obj as NodeId;

            if (!Object.ReferenceEquals(nodeId, null))
            {
                namespaceIndex = nodeId.NamespaceIndex;
                idType = nodeId.IdType;
                id = nodeId.Identifier;
            }
            else
            {
                UInt32? uid = obj as UInt32?;

                // check for numeric contants.
                if (uid != null)
                {
                    if (namespaceIndex != 0 || idType != IdType.Numeric)
                    {
                        return -1;
                    }

                    uint id1 = (uint)m_identifier;
                    uint id2 = uid.Value;

                    if (id1 == id2)
                    {
                        return 0;
                    }

                    return (id1 < id2) ? -1 : +1;
                }

                ExpandedNodeId expandedId = obj as ExpandedNodeId;

                if (!Object.ReferenceEquals(expandedId, null))
                {
                    if (expandedId.IsAbsolute)
                    {
                        return -1;
                    }

                    namespaceIndex = expandedId.NamespaceIndex;
                    idType = expandedId.IdType;
                    id = expandedId.Identifier;
                }
            }

            // check for different namespace.
            if (namespaceIndex != m_namespaceIndex)
            {
                return (m_namespaceIndex < namespaceIndex) ? -1 : +1;
            }

            // check for different id type.
            if (idType != m_identifierType)
            {
                return (m_identifierType < idType) ? -1 : +1;
            }

            // check for two nulls.
            if (m_identifier == null && id == null)
            {
                return 0;
            }

            // check for a single null.
            if (m_identifier == null && id != null)
            {
                switch (idType)
                {
                    case IdType.String:
                    {
                        string stringId = id as string;

                        if (stringId.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Opaque:
                    {
                        byte[] opaqueId = id as byte[];

                        if (opaqueId.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Numeric:
                    {
                        uint? numericId = id as uint?;

                        if (numericId.Value == 0)
                        {
                            return 0;
                        }

                        break;
                    }
                }

                return -1;
            }

            // check for a single null.
            if (m_identifier != null && id == null)
            {
                switch (idType)
                {
                    case IdType.String:
                    {
                        string stringId = m_identifier as string;

                        if (stringId.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Opaque:
                    {
                        byte[] opaqueId = m_identifier as byte[];

                        if (opaqueId.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Numeric:
                    {
                        uint? numericId = m_identifier as uint?;

                        if (numericId.Value == 0)
                        {
                            return 0;
                        }

                        break;
                    }
                }

                return +1;
            }

            // compare ids.
            switch (idType)
            {
                case IdType.Numeric:
                {
                    uint id1 = (uint)m_identifier;
                    uint id2 = (uint)id;

                    if (id1 == id2)
                    {
                        return 0;
                    }

                    return (id1 < id2) ? -1 : +1;
                }

                case IdType.String:
                {
                    string id1 = (string)m_identifier;
                    string id2 = (string)id;
                    return String.CompareOrdinal(id1, id2);
                }

                case IdType.Guid:
                {
                    Guid id1 = (Guid)m_identifier;
                    if (id is Uuid uuid)
                    {
                        return id1.CompareTo(uuid);
                    }
                    return id1.CompareTo((Guid)id);
                }

                case IdType.Opaque:
                {
                    byte[] id1 = (byte[])m_identifier;
                    byte[] id2 = (byte[])id;

                    if (id1.Length == id2.Length)
                    {
                        for (int ii = 0; ii < id1.Length; ii++)
                        {
                            if (id1[ii] != id2[ii])
                            {
                                return (id1[ii] < id2[ii]) ? -1 : +1;
                            }
                        }

                        return 0;
                    }

                    return (id1.Length < id2.Length) ? -1 : +1;
                }
            }

            // invalid id type - should never get here.
            return +1;
        }

        #endregion
        #region public static bool operator>(NodeId value1, NodeId value2)
        /// <summary>
        /// Returns true if a is greater than b.
        /// </summary>
        /// <remarks>
        /// Returns true if a is greater than b.
        /// </remarks>
        public static bool operator >(NodeId value1, NodeId value2)
        {
            if (!Object.ReferenceEquals(value1, null))
            {
                return value1.CompareTo(value2) > 0;
            }

            return false;
        }

        #endregion        
        #region public static bool operator<(NodeId value1, NodeId value2)
        /// <summary>
        /// Returns true if a is less than b.
        /// </summary>
        /// <remarks>
        /// Returns true if a is less than b.
        /// </remarks>
        public static bool operator <(NodeId value1, NodeId value2)
        {
            if (!Object.ReferenceEquals(value1, null))
            {
                return value1.CompareTo(value2) < 0;
            }

            return true;
        }
        #endregion

        #endregion

        #region IFormattable Members

        #region public string ToString(string format, IFormatProvider formatProvider)
        /// <summary>
        /// Returns the string representation of a NodeId.
        /// </summary>
        /// <remarks>
        /// Returns the string representation of a NodeId. This is the same as calling
        /// <see cref="Format()"/>.
        /// </remarks>
        /// <exception cref="FormatException">Thrown when the format is not null</exception>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                return String.Format(formatProvider, "{0}", Format());
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }

        #endregion

        #endregion

        /// <summary>
        /// Makes a deep copy of the object.
        /// </summary>
        /// <remarks>
        /// Returns a copy of this object.
        /// </remarks>
        public new object MemberwiseClone()
        {
            // this object cannot be altered after it is created so no new allocation is necessary.
            return this;
        }

        #region Comparison Functions

        #region public override bool Equals(object obj)
        /// <summary>
        /// Determines if the specified object is equal to the NodeId.
        /// </summary>
        /// <remarks>
        /// Returns a true/false if the specified NodeId is the same as this NodeId.
        /// </remarks>
        /// <param name="obj">The object (NodeId or ExpandedNodeId is desired) to compare to</param>
        public override bool Equals(object obj)
        {
            return (CompareTo(obj) == 0);
        }

        #endregion
        #region public override int GetHashCode()
        /// <summary>
        /// Returns a unique hashcode for the NodeId
        /// </summary>
        /// <remarks>
        /// Returns a unique hashcode for the NodeId
        /// </remarks>
        public override int GetHashCode()
        {
            if (m_identifier == null)
            {
                return 0;
            }

            if (m_identifierType == IdType.Opaque)
            {
                byte[] id = (byte[])m_identifier;

                int hash = id.Length;

                for (int ii = 0; ii < 16 && ii < id.Length; ii++)
                {
                    hash <<= 1;
                    hash += id[ii];

                    if (id.Length - ii >= 1)
                    {
                        hash += (id[id.Length - ii - 1] << 16);
                    }
                }

                return hash;
            }

            return m_identifier.GetHashCode();
        }

        #endregion
        #region public static bool operator==(NodeId a, object b) 
        /// <summary>
        /// Returns true if the objects are equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are equal.
        /// </remarks>
        public static bool operator ==(NodeId value1, object value2)
        {
            if (Object.ReferenceEquals(value1, null))
            {
                return Object.ReferenceEquals(value2, null);
            }

            return (value1.CompareTo(value2) == 0);
        }

        #endregion
        #region public static bool operator!=(NodeId value1, object value2) 
        /// <summary>
        /// Returns true if the objects are not equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are not equal.
        /// </remarks>
        public static bool operator !=(NodeId value1, object value2)
        {
            if (Object.ReferenceEquals(value1, null))
            {
                return !Object.ReferenceEquals(value2, null);
            }

            return (value1.CompareTo(value2) != 0);
        }


        #endregion

        #endregion

        #region Public Properties

        #region internal string IdentifierText
        /// <summary>
        /// The node identifier formatted as a URI.
        /// </summary>
        /// <remarks>
        /// The node identifier formatted as a URI.
        /// </remarks>
        [DataMember(Name = "Identifier", Order = 1)]
        internal string IdentifierText
        {
            get
            {
                return Format();
            }
            set
            {
                NodeId nodeId = NodeId.Parse(value);

                m_namespaceIndex = nodeId.NamespaceIndex;
                m_identifierType = nodeId.IdType;
                m_identifier = nodeId.Identifier;
            }
        }

        #endregion                
        #region public ushort NamespaceIndex
        /// <summary>
        /// The index of the namespace URI in the server's namespace array.
        /// </summary>
        /// <remarks>
        /// The index of the namespace URI in the server's namespace array.
        /// </remarks>
        public ushort NamespaceIndex => m_namespaceIndex;

        #endregion
        #region public IdType IdType
        /// <summary>
        /// The type of node identifier used.
        /// </summary>
        /// <remarks>
        /// Returns the type of Id, whether it is:
        /// <list type="bullet">
        /// <item><see cref="uint"/></item>
        /// <item><see cref="Guid"/></item>
        /// <item><see cref="string"/></item>
        /// <item><see cref="byte"/>[]</item>
        /// </list>
        /// </remarks>
        /// <seealso cref="IdType"/>
        public IdType IdType => m_identifierType;

        #endregion
        #region public object Identifier
        /// <summary>
        /// The node identifier.
        /// </summary>
        /// <remarks>
        /// Returns the Id in its native format, i.e. UInt, GUID, String etc.
        /// </remarks>
        public object Identifier
        {
            get
            {
                if (m_identifier == null)
                {
                    switch (m_identifierType)
                    {
                        case IdType.Numeric: { return (uint)0; }
                        case IdType.Guid: { return Guid.Empty; }
                    }
                }

                return m_identifier;
            }
        }

        #endregion             
        #region public bool IsNull
        /// <summary>
        /// Whether the object represents a Null NodeId.
        /// </summary>
        /// <remarks>
        /// Whether the NodeId represents a Null NodeId.
        /// </remarks>
        public bool IsNullNodeId
        {
            get
            {
                // non-zero namespace means it can't be null.
                if (m_namespaceIndex != 0)
                {
                    return false;
                }

                // the definition of a null identifier depends on the identifier type.
                if (m_identifier != null)
                {
                    switch (m_identifierType)
                    {
                        case IdType.Numeric:
                        {
                            if (!m_identifier.Equals((uint)0))
                            {
                                return false;
                            }

                            break;
                        }

                        case IdType.String:
                        {
                            if (!String.IsNullOrEmpty((string)m_identifier))
                            {
                                return false;
                            }

                            break;
                        }

                        case IdType.Guid:
                        {
                            if (!m_identifier.Equals(Guid.Empty))
                            {
                                return false;
                            }

                            break;
                        }

                        case IdType.Opaque:
                        {
                            if (m_identifier != null && ((byte[])m_identifier).Length > 0)
                            {
                                return false;
                            }

                            break;
                        }
                    }
                }

                // must be null.
                return true;
            }
        }

        #endregion

        #endregion

        #region Private Methods
        /// <summary>
        /// Compares two node identifiers.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private static int CompareIdentifiers(IdType idType1, object id1, IdType idType2, object id2)
        {
            if (id1 == null && id2 == null)
            {
                return 0;
            }

            if (idType1 != idType2)
            {
                return idType1.CompareTo(idType2);
            }

            if (id1 == null || id2 == null)
            {
                object nonNull = id1;

                if (id1 == null)
                {
                    nonNull = id2;
                }

                switch (idType1)
                {
                    case IdType.Numeric:
                    {
                        if (nonNull is uint && (uint)nonNull == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Guid:
                    {
                        if (nonNull is Guid && (Guid)nonNull == Guid.Empty)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.String:
                    {
                        string text = nonNull as string;

                        if (text != null && text.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Opaque:
                    {
                        byte[] bytes = nonNull as byte[];

                        if (bytes != null && bytes.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }
                }

                return (id1 == null) ? -1 : +1;
            }

            byte[] bytes1 = id1 as byte[];

            if (bytes1 != null)
            {
                byte[] bytes2 = id2 as byte[];

                if (bytes2 == null)
                {
                    return +1;
                }

                if (bytes1.Length != bytes2.Length)
                {
                    return bytes1.Length.CompareTo(bytes2.Length);
                }

                for (int ii = 0; ii < bytes1.Length; ii++)
                {
                    int result = bytes1[ii].CompareTo(bytes2[ii]);

                    if (result != 0)
                    {
                        return result;
                    }
                }

                // both arrays are equal.
                return 0;
            }

            IComparable comparable1 = id1 as IComparable;

            if (comparable1 != null)
            {
                return comparable1.CompareTo(id2);
            }

            return String.CompareOrdinal(id1.ToString(), id2.ToString());
        }

        /// <summary>
        /// Formats a node id as a string.
        /// </summary>
        private static void FormatIdentifier(StringBuilder buffer, object identifier, IdType identifierType)
        {
            switch (identifierType)
            {
                case IdType.Numeric:
                {
                    if (identifier == null)
                    {
                        buffer.Append('0');
                        break;
                    }

                    buffer.AppendFormat(CultureInfo.InvariantCulture, "{0}", identifier);
                    break;
                }

                case IdType.String:
                {
                    buffer.AppendFormat(CultureInfo.InvariantCulture, "{0}", identifier);
                    break;
                }

                case IdType.Guid:
                {
                    if (identifier == null)
                    {
                        buffer.Append(Guid.Empty);
                        break;
                    }

                    buffer.AppendFormat(CultureInfo.InvariantCulture, "{0}", identifier);
                    break;
                }

                case IdType.Opaque:
                {
                    if (identifier != null)
                    {
                        buffer.AppendFormat(CultureInfo.InvariantCulture, "{0}", Convert.ToBase64String((byte[])identifier));
                    }

                    break;
                }
            }
        }

        #endregion

        #region Private Fields
        private ushort m_namespaceIndex;
        private IdType m_identifierType;
        private object m_identifier;
        #endregion
    }

    #region NodeIdCollection Class
    /// <summary>
    /// A collection of NodeIds.
    /// </summary>
    /// <remarks>
    /// Provides a strongly-typed collection of <see cref="NodeId"/>.
    /// </remarks>
    [CollectionDataContract(Name = "ListOfNodeId", Namespace = Namespaces.OpcUaXsd, ItemName = "NodeId")]
    public partial class NodeIdCollection : List<NodeId>
    {

        #region CTORs

        /// <summary>
        /// Initializes an empty collection.
        /// </summary>
        /// <remarks>
        /// Initializes an empty collection.
        /// </remarks>
        public NodeIdCollection() { }

        /// <summary>
        /// Initializes the collection from another collection.
        /// </summary>
        /// <remarks>
        /// Creates a new collection based on the referenced collection.
        /// </remarks>
        /// <param name="collection">The existing collection to use as the basis of creating this collection</param>
        public NodeIdCollection(IEnumerable<NodeId> collection) : base(collection) { }

        /// <summary>
        /// Initializes the collection with the specified capacity.
        /// </summary>
        /// <remarks>
        /// Creates a new collection while specifying the max size of the collection.
        /// </remarks>
        /// <param name="capacity">The max. capacity of the collection</param>
        public NodeIdCollection(int capacity) : base(capacity) { }

        #endregion        

        #region public static NodeIdCollection ToNodeIdCollection(NodeId[] values)
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <remarks>
        /// A quick-use method that will take an array of <see cref="NodeId"/> objects and will
        /// return them within a <see cref="NodeIdCollection"/>.
        /// </remarks>
        /// <param name="values">An array of <see cref="NodeId"/> to add to the collection</param>
        /// <returns>A <see cref="NodeIdCollection"/> containing the <see cref="NodeId"/>'s added via the parameters</returns>
        public static NodeIdCollection ToNodeIdCollection(NodeId[] values)
        {
            if (values != null)
            {
                return new NodeIdCollection(values);
            }

            return new NodeIdCollection();
        }

        #endregion
        #region public static implicit operator NodeIdCollection(NodeId[] values)
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <remarks>
        /// Converts an array to a collection.
        /// </remarks>
        /// <param name="values">An array of <see cref="NodeId"/> objects to compare</param>
        public static implicit operator NodeIdCollection(NodeId[] values)
        {
            return ToNodeIdCollection(values);
        }

        #endregion

        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        /// <remarks>
        /// Creates a deep copy of the collection.
        /// </remarks>
        public new object MemberwiseClone()
        {
            NodeIdCollection clone = new NodeIdCollection(this.Count);

            foreach (NodeId element in this)
            {
                clone.Add((NodeId)Utils.Clone(element));
            }

            return clone;
        }
    }//class
    #endregion

    /// <summary>
    /// A dictionary designed to provide efficient lookups for objects identified by a NodeId
    /// </summary>
    public class NodeIdDictionary<T> : IDictionary<NodeId, T>
    {
        #region Constructors
        /// <summary>
        /// Creates an empty dictionary.
        /// </summary>
        public NodeIdDictionary()
        {
            m_version = 0;
            m_numericIds = new SortedDictionary<ulong, T>();
        }
        #endregion

        #region IDictionary<NodeId,T> Members
        /// <summary cref="IDictionary.Add" />
        public void Add(NodeId key, T value)
        {
            if (key == null)
            {
                throw new ArgumentNullException(nameof(key));
            }

            m_version++;

            switch (key.IdType)
            {
                case IdType.Numeric:
                {
                    ulong id = ((ulong)key.NamespaceIndex) << 32;
                    id += (uint)key.Identifier;
                    m_numericIds.Add(id, value);
                    return;
                }

                case IdType.String:
                {
                    IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, true);
                    dictionary.Add((string)key.Identifier, value);
                    return;
                }

                case IdType.Guid:
                {
                    IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, true);
                    dictionary.Add((Guid)key.Identifier, value);
                    return;
                }

                case IdType.Opaque:
                {
                    IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, true);
                    dictionary.Add(new NodeIdDictionary<T>.ByteKey((byte[])key.Identifier), value);
                    return;
                }
            }

            throw new ArgumentOutOfRangeException(nameof(key), "key.IdType");
        }

        /// <summary cref="IDictionary{TKey,TValue}.ContainsKey" />
        public bool ContainsKey(NodeId key)
        {
            if (key == null)
            {
                return false;
            }

            switch (key.IdType)
            {
                case IdType.Numeric:
                {
                    ulong id = ((ulong)key.NamespaceIndex) << 32;
                    id += (uint)key.Identifier;
                    return m_numericIds.ContainsKey(id);
                }

                case IdType.String:
                {
                    IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.ContainsKey((string)key.Identifier);
                    }

                    break;
                }

                case IdType.Guid:
                {
                    IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.ContainsKey((Guid)key.Identifier);
                    }

                    break;
                }

                case IdType.Opaque:
                {
                    IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.ContainsKey(new ByteKey((byte[])key.Identifier));
                    }

                    break;
                }
            }

            return false;
        }

        /// <summary cref="IDictionary{TKey,TValue}.Keys" />
        public ICollection<NodeId> Keys
        {
            get
            {
                List<NodeId> keys = new List<NodeId>();

                foreach (ulong id in m_numericIds.Keys)
                {
                    keys.Add(new NodeId((uint)(id & 0xFFFFFFFF), (ushort)((id >> 32) & 0xFFFF)));
                }

                if (m_dictionarySets == null)
                {
                    return keys;
                }

                for (ushort ii = 0; ii < (ushort)m_dictionarySets.Length; ii++)
                {
                    DictionarySet dictionarySet = m_dictionarySets[ii];

                    if (dictionarySet == null)
                    {
                        continue;
                    }

                    if (dictionarySet.String != null)
                    {
                        foreach (string id in dictionarySet.String.Keys)
                        {
                            keys.Add(new NodeId(id, ii));
                        }
                    }

                    if (dictionarySet.Guid != null)
                    {
                        foreach (Guid id in dictionarySet.Guid.Keys)
                        {
                            keys.Add(new NodeId(id, ii));
                        }
                    }

                    if (dictionarySet.Opaque != null)
                    {
                        foreach (ByteKey id in dictionarySet.Opaque.Keys)
                        {
                            keys.Add(new NodeId(id.Bytes, ii));
                        }
                    }
                }

                return keys;
            }
        }

        /// <summary cref="IDictionary.Remove" />
        public bool Remove(NodeId key)
        {
            if (key == null)
            {
                return false;
            }

            m_version++;

            switch (key.IdType)
            {
                case IdType.Numeric:
                {
                    ulong id = ((ulong)key.NamespaceIndex) << 32;
                    id += (uint)key.Identifier;
                    return m_numericIds.Remove(id);
                }

                case IdType.String:
                {
                    IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.Remove((string)key.Identifier);
                    }

                    break;
                }

                case IdType.Guid:
                {
                    IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.Remove((Guid)key.Identifier);
                    }

                    break;
                }

                case IdType.Opaque:
                {
                    IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.Remove(new ByteKey((byte[])key.Identifier));
                    }

                    break;
                }
            }

            return false;
        }

        /// <summary cref="IDictionary{TKey,TValue}.TryGetValue" />
        public bool TryGetValue(NodeId key, out T value)
        {
            value = default(T);

            if (key == null)
            {
                return false;
            }

            switch (key.IdType)
            {
                case IdType.Numeric:
                {
                    ulong id = ((ulong)key.NamespaceIndex) << 32;
                    id += (uint)key.Identifier;
                    return m_numericIds.TryGetValue(id, out value);
                }

                case IdType.String:
                {
                    IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.TryGetValue((string)key.Identifier, out value);
                    }

                    break;
                }

                case IdType.Guid:
                {
                    IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.TryGetValue((Guid)key.Identifier, out value);
                    }

                    break;
                }

                case IdType.Opaque:
                {
                    IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.TryGetValue(new ByteKey((byte[])key.Identifier), out value);
                    }

                    break;
                }
            }

            return false;
        }

        /// <summary cref="IDictionary{TKey,TValue}.Values" />
        public ICollection<T> Values
        {
            get
            {
                List<T> values = new List<T>();
                values.AddRange(m_numericIds.Values);

                if (m_dictionarySets == null)
                {
                    return values;
                }

                for (int ii = 0; ii < m_dictionarySets.Length; ii++)
                {
                    DictionarySet dictionarySet = m_dictionarySets[ii];

                    if (dictionarySet == null)
                    {
                        continue;
                    }

                    if (dictionarySet.String != null)
                    {
                        values.AddRange(dictionarySet.String.Values);
                    }

                    if (dictionarySet.Guid != null)
                    {
                        values.AddRange(dictionarySet.Guid.Values);
                    }

                    if (dictionarySet.Opaque != null)
                    {
                        values.AddRange(dictionarySet.Opaque.Values);
                    }
                }

                return values;
            }
        }

        /// <summary>
        /// Gets or sets the value with the specified NodeId.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        public T this[NodeId key]
        {
            get
            {
                if (key == null)
                {
                    throw new ArgumentNullException(nameof(key));
                }

                switch (key.IdType)
                {
                    case IdType.Numeric:
                    {
                        ulong id = ((ulong)key.NamespaceIndex) << 32;
                        id += (uint)key.Identifier;
                        return m_numericIds[id];
                    }

                    case IdType.String:
                    {
                        IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, false);

                        if (dictionary != null)
                        {
                            return dictionary[(string)key.Identifier];
                        }

                        break;
                    }

                    case IdType.Guid:
                    {
                        IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, false);

                        if (dictionary != null)
                        {
                            return dictionary[(Guid)key.Identifier];
                        }

                        break;
                    }

                    case IdType.Opaque:
                    {
                        IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, false);

                        if (dictionary != null)
                        {
                            return dictionary[new ByteKey((byte[])key.Identifier)];
                        }

                        break;
                    }
                }

                throw new KeyNotFoundException();
            }

            set
            {
                if (key == null)
                {
                    throw new ArgumentNullException(nameof(key));
                }

                m_version++;

                switch (key.IdType)
                {
                    case IdType.Numeric:
                    {
                        ulong id = ((ulong)key.NamespaceIndex) << 32;
                        id += (uint)key.Identifier;
                        m_numericIds[id] = value;
                        return;
                    }

                    case IdType.String:
                    {
                        IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, true);
                        dictionary[(string)key.Identifier] = value;
                        return;
                    }

                    case IdType.Guid:
                    {
                        IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, true);
                        dictionary[(Guid)key.Identifier] = value;
                        return;
                    }

                    case IdType.Opaque:
                    {
                        IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, true);
                        dictionary[new ByteKey((byte[])key.Identifier)] = value;
                        return;
                    }
                }

                throw new ArgumentOutOfRangeException(nameof(key), "key.IdType");
            }
        }
        #endregion

        #region ICollection<KeyValuePair<NodeId,T>> Members
        /// <summary cref="ICollection{T}.Add" />
        public void Add(KeyValuePair<NodeId, T> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary cref="ICollection{T}.Clear" />
        public void Clear()
        {
            m_version++;
            m_numericIds.Clear();
            m_dictionarySets = null;
        }

        /// <summary cref="ICollection{T}.Contains" />
        public bool Contains(KeyValuePair<NodeId, T> item)
        {
            T value;

            if (!TryGetValue(item.Key, out value))
            {
                return false;
            }

            return Object.Equals(value, item.Value);
        }

        /// <summary cref="ICollection{T}.CopyTo" />
        public void CopyTo(KeyValuePair<NodeId, T>[] array, int arrayIndex)
        {
            if (array == null)
            {
                throw new ArgumentNullException(nameof(array));
            }

            if (arrayIndex < 0 || array.Length <= arrayIndex)
            {
                throw new ArgumentOutOfRangeException(nameof(arrayIndex), "arrayIndex < 0 || array.Length <= arrayIndex");
            }

            foreach (KeyValuePair<ulong, T> entry in m_numericIds)
            {
                CheckCopyTo(array, arrayIndex);

                array[arrayIndex++] = new KeyValuePair<NodeId, T>(
                    new NodeId((uint)(entry.Key & 0xFFFFFFFF), (ushort)((entry.Key >> 32) & 0xFFFF)),
                    entry.Value);
            }

            if (m_dictionarySets == null)
            {
                return;
            }

            for (int ii = 0; ii < m_dictionarySets.Length; ii++)
            {
                DictionarySet dictionarySet = m_dictionarySets[ii];

                if (dictionarySet == null)
                {
                    continue;
                }

                if (dictionarySet.String != null)
                {
                    foreach (KeyValuePair<string, T> entry in dictionarySet.String)
                    {
                        CheckCopyTo(array, arrayIndex);
                        array[arrayIndex++] = new KeyValuePair<NodeId, T>(new NodeId(entry.Key, (ushort)ii), entry.Value);
                    }
                }

                if (dictionarySet.Guid != null)
                {
                    foreach (KeyValuePair<Guid, T> entry in dictionarySet.Guid)
                    {
                        CheckCopyTo(array, arrayIndex);
                        array[arrayIndex++] = new KeyValuePair<NodeId, T>(new NodeId(entry.Key, (ushort)ii), entry.Value);
                    }
                }

                if (dictionarySet.Opaque != null)
                {
                    foreach (KeyValuePair<ByteKey, T> entry in dictionarySet.Opaque)
                    {
                        CheckCopyTo(array, arrayIndex);
                        array[arrayIndex++] = new KeyValuePair<NodeId, T>(new NodeId(entry.Key.Bytes, (ushort)ii), entry.Value);
                    }
                }
            }
        }

        /// <summary>
        /// Checks that there is enough space in the array.
        /// </summary>
        private static void CheckCopyTo(KeyValuePair<NodeId, T>[] array, int arrayIndex)
        {
            if (arrayIndex >= array.Length)
            {
                throw new ArgumentException("Not enough space in array.", nameof(array));
            }
        }

        /// <summary cref="ICollection{T}.Count" />
        public int Count
        {
            get
            {
                int count = m_numericIds.Count;

                if (m_dictionarySets == null)
                {
                    return count;
                }

                for (int ii = 0; ii < m_dictionarySets.Length; ii++)
                {
                    DictionarySet dictionarySet = m_dictionarySets[ii];

                    if (dictionarySet == null)
                    {
                        continue;
                    }

                    if (dictionarySet.String != null)
                    {
                        count += dictionarySet.String.Count;
                    }

                    if (dictionarySet.Guid != null)
                    {
                        count += dictionarySet.Guid.Count;
                    }

                    if (dictionarySet.Opaque != null)
                    {
                        count += dictionarySet.Opaque.Count;
                    }
                }

                return count;
            }
        }

        /// <summary cref="ICollection{T}.IsReadOnly" />
        public bool IsReadOnly => false;

        /// <summary cref="ICollection{T}.Remove" />
        public bool Remove(KeyValuePair<NodeId, T> item)
        {
            return Remove(item.Key);
        }
        #endregion

        #region IEnumerable<KeyValuePair<NodeId,T>> Members
        /// <summary cref="System.Collections.IEnumerable.GetEnumerator()" />
        public IEnumerator<KeyValuePair<NodeId, T>> GetEnumerator()
        {
            return new Enumerator(this);
        }
        #endregion

        #region IEnumerable Members
        /// <summary cref="System.Collections.IEnumerable.GetEnumerator()" />
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Returns the dictionary set for the specified namespace.
        /// </summary>
        private DictionarySet GetDictionarySet(ushort namespaceIndex, bool create)
        {
            if (m_dictionarySets == null || m_dictionarySets.Length <= namespaceIndex)
            {
                if (!create)
                {
                    return null;
                }

                DictionarySet[] dictionarySets = new NodeIdDictionary<T>.DictionarySet[namespaceIndex + 1];

                if (m_dictionarySets != null)
                {
                    Array.Copy(m_dictionarySets, dictionarySets, m_dictionarySets.Length);
                }

                m_dictionarySets = dictionarySets;
            }

            DictionarySet dictionarySet = m_dictionarySets[namespaceIndex];

            if (dictionarySet == null)
            {
                if (!create)
                {
                    return null;
                }

                m_dictionarySets[namespaceIndex] = dictionarySet = new NodeIdDictionary<T>.DictionarySet();
            }

            return dictionarySet;
        }

        /// <summary>
        /// Returns the dictionary set for String identifiers in the specified namespace.
        /// </summary>
        private IDictionary<string, T> GetStringDictionary(ushort namespaceIndex, bool create)
        {
            DictionarySet dictionarySet = GetDictionarySet(namespaceIndex, create);

            if (dictionarySet == null)
            {
                return null;
            }

            IDictionary<string, T> dictionary = dictionarySet.String;

            if (dictionary == null)
            {
                if (!create)
                {
                    return null;
                }

                dictionary = dictionarySet.String = new SortedDictionary<string, T>();
            }

            return dictionary;
        }

        /// <summary>
        /// Returns the dictionary set for Guid identifiers in the specified namespace.
        /// </summary>
        private IDictionary<Guid, T> GetGuidDictionary(ushort namespaceIndex, bool create)
        {
            DictionarySet dictionarySet = GetDictionarySet(namespaceIndex, create);

            if (dictionarySet == null)
            {
                return null;
            }

            IDictionary<Guid, T> dictionary = dictionarySet.Guid;

            if (dictionary == null)
            {
                if (!create)
                {
                    return null;
                }

                dictionary = dictionarySet.Guid = new SortedDictionary<Guid, T>();
            }

            return dictionary;
        }

        /// <summary>
        /// Returns the dictionary set for Opaque identifiers in the specified namespace.
        /// </summary>
        private IDictionary<ByteKey, T> GetOpaqueDictionary(ushort namespaceIndex, bool create)
        {
            DictionarySet dictionarySet = GetDictionarySet(namespaceIndex, create);

            if (dictionarySet == null)
            {
                return null;
            }

            IDictionary<ByteKey, T> dictionary = dictionarySet.Opaque;

            if (dictionary == null)
            {
                if (!create)
                {
                    return null;
                }

                dictionary = dictionarySet.Opaque = new SortedDictionary<ByteKey, T>();
            }

            return dictionary;
        }
        #endregion

        #region DictionarySet Class
        /// <summary>
        /// Stores the dictionaries for a single namespace index.
        /// </summary>
        private class DictionarySet
        {
            public SortedDictionary<string, T> String;
            public SortedDictionary<Guid, T> Guid;
            public SortedDictionary<ByteKey, T> Opaque;
        }
        #endregion

        #region ByteKey Class
        /// <summary>
        /// Wraps a byte array for use as a key in a dictionary.
        /// </summary>
        private struct ByteKey : IEquatable<ByteKey>, IComparable<ByteKey>
        {
            #region Public Interface
            /// <summary>
            /// Initializes the key with an array of bytes.
            /// </summary>
            public ByteKey(byte[] bytes)
            {
                Bytes = bytes;
            }

            /// <summary>
            /// The array of bytes.
            /// </summary>
            public byte[] Bytes;
            #endregion

            #region IEquatable<ByteKey> Members
            /// <summary cref="IEquatable{T}"></summary>
            public bool Equals(ByteKey other)
            {
                if (other.Bytes == null || Bytes == null)
                {
                    return (other.Bytes == null && Bytes == null);
                }

                if (other.Bytes.Length != Bytes.Length)
                {
                    return false;
                }

                for (int ii = 0; ii < other.Bytes.Length; ii++)
                {
                    if (other.Bytes[ii] != Bytes[ii])
                    {
                        return false;
                    }
                }

                return false;
            }
            #endregion

            #region IComparable<ByteKey> Members
            /// <summary cref="IComparable{T}.CompareTo"></summary>
            public int CompareTo(ByteKey other)
            {
                if (other.Bytes == null || Bytes == null)
                {
                    return (other.Bytes == null) ? +1 : -1;
                }

                if (other.Bytes.Length != Bytes.Length)
                {
                    return (other.Bytes.Length < Bytes.Length) ? +1 : -1;
                }

                for (int ii = 0; ii < other.Bytes.Length; ii++)
                {
                    if (other.Bytes[ii] != Bytes[ii])
                    {
                        return (other.Bytes[ii] < Bytes[ii]) ? +1 : -1;
                    }
                }

                return 0;
            }
            #endregion
        }
        #endregion        

        #region Enumerator Class
        /// <summary>
        /// The enumerator for the node dictionary.
        /// </summary>
        private class Enumerator : IEnumerator<KeyValuePair<NodeId, T>>
        {
            #region Constructors
            /// <summary>
            /// Constructs the enumerator for the specified dictionary.
            /// </summary>
            public Enumerator(NodeIdDictionary<T> dictionary)
            {
                m_dictionary = dictionary;
                m_version = dictionary.m_version;
                m_idType = 0;
                m_namespaceIndex = 0;
            }
            #endregion

            #region IEnumerator<KeyValuePair<NodeId,T>> Members
            /// <summary cref="IEnumerator{T}.Current" />
            public KeyValuePair<NodeId, T> Current
            {
                get
                {
                    CheckVersion();

                    if (m_enumerator == null)
                    {
                        throw new InvalidOperationException("The enumerator is positioned before the first element of the collection or after the last element.");
                    }

                    NodeId id = null;

                    switch (m_idType)
                    {
                        case IdType.Numeric:
                        {
                            ulong key = (ulong)m_enumerator.Key;
                            id = new NodeId((uint)(key & 0xFFFFFFFF), (ushort)((key >> 32) & 0xFFFF));
                            break;
                        }

                        case IdType.String:
                        {
                            id = new NodeId((string)m_enumerator.Key, m_namespaceIndex);
                            break;
                        }

                        case IdType.Guid:
                        {
                            id = new NodeId((Guid)m_enumerator.Key, m_namespaceIndex);
                            break;
                        }

                        case IdType.Opaque:
                        {
                            id = new NodeId(((ByteKey)m_enumerator.Key).Bytes, m_namespaceIndex);
                            break;
                        }
                    }

                    return new KeyValuePair<NodeId, T>(id, (T)m_enumerator.Value);
                }
            }
            #endregion

            #region IDisposable Members
            /// <summary>
            /// Frees any unmanaged resources.
            /// </summary>
            public void Dispose()
            {
                Dispose(true);
            }

            /// <summary>
            /// An overrideable version of the Dispose.
            /// </summary>
            protected virtual void Dispose(bool disposing)
            {
                if (disposing)
                {
                    // do to nothing.
                }
            }
            #endregion

            #region IEnumerator Members
            /// <summary cref="IEnumerator.Current" />
            object System.Collections.IEnumerator.Current => this.Current;

            /// <summary cref="IEnumerator.MoveNext" />
            public bool MoveNext()
            {
                CheckVersion();

                if (m_enumerator == null)
                {
                    m_enumerator = m_dictionary.m_numericIds.GetEnumerator();
                    m_idType = IdType.Numeric;
                    m_namespaceIndex = 0;
                }

                bool result = m_enumerator.MoveNext();

                if (result)
                {
                    return true;
                }

                while (m_dictionary.m_dictionarySets != null && m_namespaceIndex < m_dictionary.m_dictionarySets.Length)
                {
                    if (m_idType == IdType.Numeric)
                    {
                        m_idType = IdType.String;

                        IDictionary<string, T> dictionary = m_dictionary.GetStringDictionary(m_namespaceIndex, false);

                        if (dictionary != null)
                        {
                            ReleaseEnumerator();
                            m_enumerator = (IDictionaryEnumerator)dictionary.GetEnumerator();

                            if (m_enumerator.MoveNext())
                            {
                                return true;
                            }
                        }
                    }

                    if (m_idType == IdType.String)
                    {
                        m_idType = IdType.Guid;

                        IDictionary<Guid, T> dictionary = m_dictionary.GetGuidDictionary(m_namespaceIndex, false);

                        if (dictionary != null)
                        {
                            ReleaseEnumerator();
                            m_enumerator = (IDictionaryEnumerator)dictionary.GetEnumerator();

                            if (m_enumerator.MoveNext())
                            {
                                return true;
                            }
                        }
                    }

                    if (m_idType == IdType.Guid)
                    {
                        m_idType = IdType.Opaque;

                        IDictionary<ByteKey, T> dictionary = m_dictionary.GetOpaqueDictionary(m_namespaceIndex, false);

                        if (dictionary != null)
                        {
                            ReleaseEnumerator();
                            m_enumerator = (IDictionaryEnumerator)dictionary.GetEnumerator();

                            if (m_enumerator.MoveNext())
                            {
                                return true;
                            }
                        }
                    }

                    m_idType = IdType.Numeric;
                    m_namespaceIndex++;
                }

                ReleaseEnumerator();
                return false;
            }

            /// <summary cref="IEnumerator.Reset" />
            public void Reset()
            {
                CheckVersion();
                ReleaseEnumerator();
                m_idType = 0;
                m_namespaceIndex = 0;
            }
            #endregion

            #region Private Methods
            /// <summary>
            /// Releases and disposes the current enumerator.
            /// </summary>
            private void ReleaseEnumerator()
            {
                if (m_enumerator != null)
                {
                    IDisposable diposeable = m_enumerator as IDisposable;

                    diposeable?.Dispose();

                    m_enumerator = null;
                }
            }

            /// <summary>
            /// Checks if the dictionary has changed.
            /// </summary>
            private void CheckVersion()
            {
                if (m_version != m_dictionary.m_version)
                {
                    throw new InvalidOperationException("The dictionary was modified after the enumerator was created.");
                }
            }
            #endregion

            #region Private Fields
            private NodeIdDictionary<T> m_dictionary;
            private ushort m_namespaceIndex;
            private IdType m_idType;
            private IDictionaryEnumerator m_enumerator;
            private ulong m_version;
            #endregion
        }
        #endregion

        #region Private Fields
        private DictionarySet[] m_dictionarySets;
        private SortedDictionary<ulong, T> m_numericIds;
        private ulong m_version;
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.Serialization;
using System.Text;

namespace Opc.Ua
{
    /// <summary>
    /// Stores an identifier for a node in a server's address space.
    /// </summary>
    /// <remarks>
    /// <para>
    /// <b>Please refer to OPC Specifications</b>:
    /// <list type="bullet">
    /// <item><b>Address Space Model</b> setion <b>7.2</b></item>
    /// <item><b>Address Space Model</b> setion <b>5.2.2</b></item>
    /// </list>
    /// </para>
    /// <para>
    /// Stores the id of a Node, which resides within the server's address space.
    /// <br/></para>
    /// <para>
    /// The NodeId can be either:
    /// <list type="bullet">
    /// <item><see cref="uint"/></item>
    /// <item><see cref="Guid"/></item>
    /// <item><see cref="string"/></item>
    /// <item><see cref="byte"/>[]</item>
    /// </list>
    /// <br/></para>
    /// <note>
    /// <b>Important:</b> Keep in mind that the actual ID's of nodes should be unique such that no two
    /// nodes within an address-space share the same ID's.
    /// </note>
    /// <para>
    /// The NodeId can be assigned to a particular namespace index. This index is merely just a number and does
    /// not represent some index within a collection that this node has any knowledge of. The assumption is
    /// that the host of this object will manage that directly.
    /// <br/></para>
    /// </remarks>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class NodeId : IComparable, IFormattable
    {
        #region Constructors
        #region public NodeId()

        /// <summary>
        /// Initializes the object with default values.
        /// </summary>
        /// <remarks>
        /// Creates a new instance of the class which will have the default values. The actual
        /// Node Id will need to be defined as this constructor does not specify the id.
        /// </remarks>
        public NodeId()
        {
            Initialize();
        }

        #endregion
        #region public NodeId(NodeId value)
        /// <summary>
        /// Creates a deep copy of the value.
        /// </summary>
        /// <remarks>
        /// Creates a new NodeId by copying the properties of the node specified in the parameter.
        /// </remarks>
        /// <param name="value">The NodeId object whose properties will be copied.</param>
        /// <exception cref="ArgumentNullException">Thrown when <i>value</i> is null</exception>
        public NodeId(NodeId value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            m_namespaceIndex = value.m_namespaceIndex;
            m_identifierType = value.m_identifierType;
            m_identifier = Utils.Clone(value.m_identifier);
        }
        #endregion
        #region public NodeId(uint value)
        /// <summary>
        /// Initializes a numeric node identifier.
        /// </summary>
        /// <remarks>
        /// Creates a new NodeId that will have a numeric (unsigned-int) id
        /// </remarks>
        /// <param name="value">The numeric value of the id</param>
        public NodeId(uint value)
        {
            m_namespaceIndex = 0;
            m_identifierType = IdType.Numeric;
            m_identifier = value;
        }
        #endregion
        #region public NodeId(uint value, ushort namespaceIndex)
        /// <summary>
        /// Initializes a guid node identifier with a namespace index.
        /// </summary>
        /// <remarks>
        /// Creates a new NodeId that will use a numeric (unsigned int) for its Id, but also
        /// specifies which namespace this node should belong to.
        /// </remarks>
        /// <param name="value">The new (numeric) Id for the node being created</param>
        /// <param name="namespaceIndex">The index of the namespace that this node should belong to</param>
        /// <seealso cref="SetNamespaceIndex"/>
        public NodeId(uint value, ushort namespaceIndex)
        {
            m_namespaceIndex = namespaceIndex;
            m_identifierType = IdType.Numeric;
            m_identifier = value;
        }

        #endregion

        #region public NodeId(string value, ushort namespaceIndex)
        /// <summary>
        /// Initializes a string node identifier with a namespace index.
        /// </summary>
        /// <remarks>
        /// Creates a new NodeId that will use a string for its Id, but also
        /// specifies if the Id is a URI, and which namespace this node belongs to.
        /// </remarks>
        /// <param name="value">The new (string) Id for the node being created</param>
        /// <param name="namespaceIndex">The index of the namespace that this node belongs to</param>
        public NodeId(string value, ushort namespaceIndex)
        {
            m_namespaceIndex = namespaceIndex;
            m_identifierType = IdType.String;
            m_identifier = value;
        }

        #endregion
        #region public NodeId(Guid value)
        /// <summary>
        /// Initializes a guid node identifier.
        /// </summary>
        /// <remarks>
        /// Creates a new node whose Id will be a <see cref="Guid"/>.
        /// </remarks>
        /// <param name="value">The new Guid value of this nodes Id.</param>
        public NodeId(Guid value)
        {
            m_namespaceIndex = 0;
            m_identifierType = IdType.Guid;
            m_identifier = value;
        }

        #endregion        

        #region public NodeId(Guid value, ushort namespaceIndex)
        /// <summary>
        /// Initializes a guid node identifier.
        /// </summary>
        /// <remarks>
        /// Creates a new node whose Id will be a <see cref="Guid"/>.
        /// </remarks>
        /// <param name="value">The new Guid value of this nodes Id.</param>
        /// <param name="namespaceIndex">The index of the namespace that this node belongs to</param>
        public NodeId(Guid value, ushort namespaceIndex)
        {
            m_namespaceIndex = namespaceIndex;
            m_identifierType = IdType.Guid;
            m_identifier = value;
        }
        #endregion    

        #region public NodeId(byte[] value)
        /// <summary>
        /// Initializes a guid node identifier.
        /// </summary>
        /// <remarks>
        /// Creates a new node whose Id will be a series of <see cref="Byte"/>.
        /// </remarks>
        /// <param name="value">An array of <see cref="Byte"/> that will become this Node's ID</param>
        public NodeId(byte[] value)
        {
            m_namespaceIndex = 0;
            m_identifierType = IdType.Opaque;
            m_identifier = null;

            if (value != null)
            {
                byte[] copy = new byte[value.Length];
                Array.Copy(value, copy, value.Length);
                m_identifier = copy;
            }
        }

        #endregion        
        #region public NodeId(byte[] value, ushort namespaceIndex)
        /// <summary>
        /// Initializes an opaque node identifier with a namespace index.
        /// </summary>
        /// <remarks>
        /// Creates a new node whose Id will be a series of <see cref="Byte"/>, while specifying
        /// the index of the namespace that this node belongs to.
        /// </remarks>
        /// <param name="value">An array of <see cref="Byte"/> that will become this Node's ID</param>
        /// <param name="namespaceIndex">The index of the namespace that this node belongs to</param>
        public NodeId(byte[] value, ushort namespaceIndex)
        {
            m_namespaceIndex = namespaceIndex;
            m_identifierType = IdType.Opaque;
            m_identifier = null;

            if (value != null)
            {
                byte[] copy = new byte[value.Length];
                Array.Copy(value, copy, value.Length);
                m_identifier = copy;
            }
        }

        #endregion
        #region public NodeId(string text)
        /// <summary>
        /// Initializes a node id by parsing a node id string.
        /// </summary>
        /// <remarks>
        /// Creates a new node with a String id.
        /// </remarks>
        /// <param name="text">The string id of this new node</param>
        public NodeId(string text)
        {
            NodeId nodeId = NodeId.Parse(text);

            m_namespaceIndex = nodeId.NamespaceIndex;
            m_identifierType = nodeId.IdType;
            m_identifier = nodeId.Identifier;
        }

        #endregion

        #region public NodeId(object value, ushort namespaceIndex)
        /// <summary>
        /// Initializes a node identifier with a namespace index.
        /// </summary>
        /// <remarks>
        /// Throws an exception if the identifier type is not supported.
        /// </remarks>
        /// <param name="value">The identifier</param>
        /// <param name="namespaceIndex">The index of the namespace that qualifies the node</param>
        public NodeId(object value, ushort namespaceIndex)
        {
            m_namespaceIndex = namespaceIndex;

            if (value is uint)
            {
                SetIdentifier(IdType.Numeric, value);
                return;
            }

            if (value == null || value is string)
            {
                SetIdentifier(IdType.String, value);
                return;
            }

            if (value is Guid)
            {
                SetIdentifier(IdType.Guid, value);
                return;
            }

            if (value is Uuid)
            {
                SetIdentifier(IdType.Guid, value);
                return;
            }

            if (value is byte[])
            {
                SetIdentifier(IdType.Opaque, value);
                return;
            }

            throw new ArgumentException("Identifier type not supported.", nameof(value));
        }
        #endregion

        /// <summary>
        /// Initializes the object during deserialization.
        /// </summary>
        [OnDeserializing()]
        private void Initialize(StreamingContext context)
        {
            Initialize();
        }

        /// <summary>
        /// Initializes the object during deserialization.
        /// </summary>
        private void Initialize()
        {
            m_namespaceIndex = 0;
            m_identifierType = IdType.Numeric;
            m_identifier = null;
        }
        #endregion

        #region Static Members
        /// <summary>
        /// Converts an identifier and a namespaceUri to a local NodeId using the namespaceTable.
        /// </summary>
        /// <param name="identifier">The identifier for the node.</param>
        /// <param name="namespaceUri">The URI to look up.</param>
        /// <param name="namespaceTable">The table to use for the URI lookup.</param>
        /// <returns>A local NodeId</returns>
        /// <exception cref="ServiceResultException">Thrown when the namespace cannot be found</exception>
        public static NodeId Create(object identifier, string namespaceUri, NamespaceTable namespaceTable)
        {
            int index = -1;

            if (namespaceTable != null)
            {
                index = namespaceTable.GetIndex(namespaceUri);
            }

            if (index < 0)
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, "NamespaceUri ({0}) is not in the namespace table.", namespaceUri);
            }

            return new NodeId(identifier, (ushort)index);
        }

        #region public static implicit operator NodeId(uint value)
        /// <summary>
        /// Converts an integer to a numeric node identifier.
        /// </summary>
        /// <remarks>
        /// Converts an integer to a numeric node identifier for comparissons.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// 
        /// //create some variables
        /// uint id1 = 100, id2=101;
        /// NodeId node1;
        /// 
        /// //create our node
        /// node1 = new NodeId(id1);
        /// 
        /// //now to compare the node to the ids using a simple comparisson and Equals:
        /// Utils.Trace("Comparing NodeId to uint");
        /// Utils.Trace("\tComparing 100 to 100 = [equals] {0}", node1.Equals(id1));
        /// Utils.Trace("\tComparing 100 to 100 = [ ==   ] {0}", node1 == id1);
        /// Utils.Trace("\tComparing 100 to 101 = [equals] {0}", node1.Equals(id2));
        /// Utils.Trace("\tComparing 100 to 101 = [ ==   ] {0}", node1 == id2);
        /// 
        /// </code>
        /// <code lang="Visual Basic">
        /// 
        /// 'create some variables
        /// Dim id1 As UInt = 100
        /// Dim id2 As UInt = 102
        /// Dim node1 As NodeId
        /// 
        /// 'create our node
        /// node1 = new NodeId(id1)
        /// 
        /// 'now to compare the node to the ids using a simple comparisson and Equals:
        /// Utils.Trace("Comparing NodeId to uint")
        /// Utils.Trace( String.Format("   Comparing 100 to 100 = [equals] {0}", node1.Equals(id1)) )
        /// Utils.Trace( String.Format("   Comparing 100 to 100 = [  =   ] {0}", node1 = id1) )
        /// Utils.Trace( String.Format("   Comparing 100 to 101 = [equals] {0}", node1.Equals(id2)) )
        /// Utils.Trace( String.Format("   Comparing 100 to 101 = [  =   ] {0}", node1 = id2) )
        /// 
        /// </code>
        /// <para>
        /// This produces the following output (taken from C# example):
        /// <br/></para>
        /// <para>
        /// Comparing NodeId to uint<br/>
        ///     Comparing 100 to 100 = [equals] True<br/>
        ///     Comparing 100 to 100 = [ ==   ] True<br/>
        ///     Comparing 100 to 101 = [equals] False<br/>
        ///     Comparing 100 to 101 = [ ==   ] False<br/>
        /// <br/></para>
        /// </example>
        /// <param name="value">The <see cref="uint"/> to compare this node to.</param>
        public static implicit operator NodeId(uint value)
        {
            return new NodeId(value);
        }

        #endregion
        #region public static implicit operator NodeId(Guid value)
        /// <summary>
        /// Converts a guid to a guid node identifier.
        /// </summary>
        /// <remarks>
        /// Converts a NodeId into a Guid allowing you to compare a Node against a Guid.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// 
        /// //define our 2 GUID ids, and then define our node to use the first id.
        /// Guid id1 = Guid.NewGuid(), id2 = Guid.NewGuid();
        /// NodeId node1 = new NodeId(id1);
        /// 
        /// //now to compare the node to the guids
        /// Utils.Trace("\n\nComparing NodeId to GUID");
        /// Utils.Trace("\tComparing {0} to {0} = [equals] {2}", id1, id1, node1.Equals(id1));
        /// Utils.Trace("\tComparing {0} to {0} = [ ==   ] {2}", id1, id1, node1 == id1);
        /// Utils.Trace("\tComparing {0} to {1} = [equals] {2}", id1, id2, node1.Equals(id2));
        /// Utils.Trace("\tComparing {0} to {1} = [ ==   ] {2}", id1, id2, node1 == id2);
        /// 
        /// </code>
        /// <code lang="Visual Basic">
        /// 
        /// 'define our 2 GUID ids, and then define our node to use the first id.
        /// Dim id1 As Guid = Guid.NewGuid()
        /// Dim id2 As Guid = Guid.NewGuid()
        /// Dim node1 As NodeId = new NodeId(id1)
        /// 
        /// 'now to compare the node to the guids
        /// Utils.Trace("Comparing NodeId to GUID")
        /// Utils.Trace( String.Format( "  Comparing {0} to {0} = [equals] {2}", id1, id1, node1.Equals(id1)) );
        /// Utils.Trace( String.Format( "  Comparing {0} to {0} = [  =   ] {2}", id1, id1, node1 = id1) );
        /// Utils.Trace( String.Format( "  Comparing {0} to {0} = [equals] {2}", id1, id2, node1.Equals(id2)) );
        /// Utils.Trace( String.Format( "  Comparing {0} to {0} = [  =   ] {2}", id1, id2, node1 = id2) );
        /// 
        /// </code>
        /// <para>
        /// This produces the following output (taken from C# example):
        /// <br/></para>
        /// <para>
        /// Comparing NodeId to GUID<br/>
        ///     Comparing bbe8b5f2-0f50-4302-877f-346afb07704c to bbe8b5f2-0f50-4302-877f-346afb07704c = [equals] True<br/>
        ///     Comparing bbe8b5f2-0f50-4302-877f-346afb07704c to bbe8b5f2-0f50-4302-877f-346afb07704c = [  =   ] True<br/>
        ///     Comparing bbe8b5f2-0f50-4302-877f-346afb07704c to e707de86-4c11-4fe6-94b2-83638a9427e6 = [equals] False<br/>
        ///     Comparing bbe8b5f2-0f50-4302-877f-346afb07704c to e707de86-4c11-4fe6-94b2-83638a9427e6 = [  =   ] False<br/>
        /// <br/></para>
        /// </example>
        /// <param name="value">The <see cref="Guid"/> to compare this node to.</param>
        public static implicit operator NodeId(Guid value)
        {
            return new NodeId(value);
        }

        #endregion
        #region public static implicit operator NodeId(byte[] value)
        /// <summary>
        /// Converts a byte array to an opaque node identifier.
        /// </summary>
        /// <remarks>
        /// This operator allows you to compare a NodeId to an array of Bytes.
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// 
        /// //define our 2 Byte[] ids, and then define our node to use the first id.
        /// byte[] id1 = new byte[] { 65, 66, 67, 68, 69 };
        /// byte[] id2 = new byte[] { 97, 98, 99, 100, 101 };
        /// NodeId node1 = new NodeId(id1);
        /// 
        /// //convert our bytes to string so we can display them 
        /// string id1String = System.Text.ASCIIEncoding.ASCII.GetString(id1);
        /// string id2String = System.Text.ASCIIEncoding.ASCII.GetString(id2);
        /// 
        /// //now to compare the node to the guids
        /// Utils.Trace("\n\nComparing NodeId to Byte[]");
        /// Utils.Trace("\tComparing {0} to {0} = [equals] {2}", id1String, id1String, node1.Equals(id1));
        /// Utils.Trace("\tComparing {0} to {0} = [  =   ] {2}", id1String, id1String, node1 == id1);
        /// Utils.Trace("\tComparing {0} to {1} = [equals] {2}", id1String, id2String, node1.Equals(id2));
        /// Utils.Trace("\tComparing {0} to {1} = [  =   ] {2}", id1String, id2String, node1 == id2);
        /// 
        /// </code>
        /// <code lang="Visual Basic">
        /// 
        /// 'define our 2 Byte[] ids, and then define our node to use the first id.
        /// Dim id1 As Byte() = New Byte() { 65, 66, 67, 68, 69 }
        /// Dim id2 As Byte() = New Byte() { 97, 98, 99, 100, 101 }
        /// Dim node1 As NodeId = New NodeId(id1)
        /// 
        /// 'convert our bytes to string so we can display them 
        /// Dim id1String As String = System.Text.ASCIIEncoding.ASCII.GetString(id1)
        /// Dim id2String As String = System.Text.ASCIIEncoding.ASCII.GetString(id2)
        /// 
        /// 'now to compare the node to the guids
        /// Utils.Trace("Comparing NodeId to Byte()")
        /// Utils.Trace( String.Format("Comparing {0} to {0} = [equals] {2}", id1String, id1String, node1.Equals(id1)) )
        /// Utils.Trace( String.Format("Comparing {0} to {0} = [  =   ] {2}", id1String, id1String, node1 = id1) )
        /// Utils.Trace( String.Format("Comparing {0} to {1} = [equals] {2}", id1String, id2String, node1.Equals(id2)) )
        /// Utils.Trace( String.Format("Comparing {0} to {1} = [  =   ] {2}", id1String, id2String, node1 = id2) )
        /// 
        /// </code>
        /// <para>
        /// This produces the following output (taken from C# example):
        /// <br/></para>
        /// <para>
        /// Comparing NodeId to Byte[]
        ///     Comparing ABCDE to ABCDE = [equals] True
        ///     Comparing ABCDE to ABCDE = [ ==   ] True
        ///     Comparing ABCDE to abcde = [equals] False
        ///     Comparing ABCDE to abcde = [ ==   ] False
        /// <br/></para>
        /// </example>
        /// <param name="value">The <see cref="Byte"/>[] array to compare this node to</param>
        public static implicit operator NodeId(byte[] value)
        {
            return new NodeId(value);
        }

        #endregion
        #region public static implicit operator NodeId(string text)
        /// <summary>
        /// Parses a node id string and initializes a node id.
        /// </summary>
        /// <remarks>
        /// Compares a Node to a String
        /// </remarks>
        /// <example>
        /// <code lang="C#">
        /// 
        /// //define our 2 String ids, and then define our node to use the first id.
        /// String id1 = "Hello", id2 = "World";
        /// NodeId node1 = new NodeId(id1);
        /// 
        /// //now to compare the node to the guids
        /// Utils.Trace("\n\nComparing NodeId to String");
        /// Utils.Trace("\tComparing {0} to {0} = [equals] {2}", id1, id1, node1.Equals(id1));
        /// Utils.Trace("\tComparing {0} to {0} = [ ==   ] {2}", id1, id1, node1 == id1);
        /// Utils.Trace("\tComparing {0} to {1} = [equals] {2}", id1, id2, node1.Equals(id2));
        /// Utils.Trace("\tComparing {0} to {1} = [ ==   ] {2}", id1, id2, node1 == id2);
        /// 
        /// 
        /// </code>
        /// <code lang="Visual Basic">
        /// 
        /// 'define our 2 String ids, and then define our node to use the first id.
        /// Dim id1 As String = "Hello"
        /// Dim id2 As String = "World"
        /// Dim node1 As NodeId = New NodeId(id1)
        /// 
        /// 'now to compare the node to the guids
        /// Utils.Trace("Comparing NodeId to String");
        /// Utils.Trace(String.Format("Comparing {0} to {0} = [equals] {2}", id1, id1, node1.Equals(id1)));
        /// Utils.Trace(String.Format("Comparing {0} to {0} = [  =   ] {2}", id1, id1, node1 = id1));
        /// Utils.Trace(String.Format("Comparing {0} to {1} = [equals] {2}", id1, id2, node1.Equals(id2)));
        /// Utils.Trace(String.Format("Comparing {0} to {1} = [  =   ] {2}", id1, id2, node1 = id2));
        /// 
        /// </code>
        /// </example>
        /// <param name="text">The <see cref="String"/> to compare this node to.</param>
        public static implicit operator NodeId(string text)
        {
            return NodeId.Parse(text);
        }

        #endregion
        #region public static bool IsNull(NodeId nodeId)
        /// <summary>
        /// Checks if the node id represents a 'Null' node id.
        /// </summary>
        /// <remarks>
        /// Returns a true/false value to indicate if the specified NodeId is null.
        /// </remarks>
        /// <param name="nodeId">The NodeId to validate</param>
        public static bool IsNull(NodeId nodeId)
        {
            if (nodeId == null)
            {
                return true;
            }

            return nodeId.IsNullNodeId;
        }

        #endregion
        #region public static bool IsNull(ExpandedNodeId nodeId)
        /// <summary>
        /// Checks if the node id represents a 'Null' node id.
        /// </summary>
        /// <remarks>
        /// Returns a true/false to indicate if the specified <see cref="ExpandedNodeId"/> is null.
        /// </remarks>
        /// <param name="nodeId">The ExpandedNodeId to validate</param>
        public static bool IsNull(ExpandedNodeId nodeId)
        {
            if (nodeId == null)
            {
                return true;
            }

            return nodeId.IsNull;
        }
        #endregion
        #region public static NodeId Parse(string text)
        /// <summary>
        /// Parses a node id string and returns a node id object.
        /// </summary>
        /// <remarks>
        /// Parses a NodeId String and returns a NodeId object
        /// </remarks>
        /// <param name="text">The NodeId value as a string.</param>
        /// <exception cref="ServiceResultException">Thrown under a variety of circumstances, each time with a specific message.</exception>
        public static NodeId Parse(string text)
        {
            try
            {
                if (String.IsNullOrEmpty(text))
                {
                    return NodeId.Null;
                }

                ushort namespaceIndex = 0;

                // parse the namespace index if present.
                if (text.StartsWith("ns=", StringComparison.Ordinal))
                {
                    int index = text.IndexOf(';');

                    if (index == -1)
                    {
                        throw new ServiceResultException(StatusCodes.BadNodeIdInvalid, "Invalid namespace index.");
                    }

                    namespaceIndex = Convert.ToUInt16(text.Substring(3, index - 3), CultureInfo.InvariantCulture);

                    text = text.Substring(index + 1);
                }

                // parse numeric node identifier.
                if (text.StartsWith("i=", StringComparison.Ordinal))
                {
                    return new NodeId(Convert.ToUInt32(text.Substring(2), CultureInfo.InvariantCulture), namespaceIndex);
                }

                // parse string node identifier.
                if (text.StartsWith("s=", StringComparison.Ordinal))
                {
                    return new NodeId(text.Substring(2), namespaceIndex);
                }

                // parse guid node identifier.
                if (text.StartsWith("g=", StringComparison.Ordinal))
                {
                    return new NodeId(new Guid(text.Substring(2)), namespaceIndex);
                }

                // parse opaque node identifier.
                if (text.StartsWith("b=", StringComparison.Ordinal))
                {
                    return new NodeId(Convert.FromBase64String(text.Substring(2)), namespaceIndex);
                }

                // treat as a string identifier if a namespace was specified.
                if (namespaceIndex != 0)
                {
                    return new NodeId(text, namespaceIndex);
                }

                // treat as URI identifier.
                return new NodeId(text, 0);
            }
            catch (Exception e)
            {
                throw new ServiceResultException(
                    StatusCodes.BadNodeIdInvalid,
                    Utils.Format("Cannot parse node id text: '{0}'", text),
                    e);
            }
        }
        #endregion

        /// <summary>
        /// Returns an instance of a null NodeId.
        /// </summary>
        public static NodeId Null => s_Null;

        private static readonly NodeId s_Null = new NodeId();
        #endregion

        #region Public Methods (and some Internals)

        #region public string Format()
        /// <summary>
        /// Formats a node id as a string.
        /// </summary>
        /// <remarks>
        /// <para>
        /// Formats a NodeId as a string.
        /// <br/></para>
        /// <para>
        /// An example of this would be:
        /// <br/></para>
        /// <para>
        /// NodeId = "hello123"<br/>
        /// NamespaceId = 1;<br/>
        /// <br/> This would translate into:<br/>
        /// ns=1;s=hello123
        /// <br/></para>
        /// </remarks>
        public string Format()
        {
            StringBuilder buffer = new StringBuilder();
            Format(buffer);
            return buffer.ToString();
        }

        /// <summary>
        /// Formats the NodeId as a string and appends it to the buffer.
        /// </summary>
        public void Format(StringBuilder buffer)
        {
            Format(buffer, m_identifier, m_identifierType, m_namespaceIndex);
        }

        /// <summary>
        /// Formats the NodeId as a string and appends it to the buffer.
        /// </summary>
        public static void Format(StringBuilder buffer, object identifier, IdType identifierType, ushort namespaceIndex)
        {
            if (namespaceIndex != 0)
            {
                buffer.AppendFormat(CultureInfo.InvariantCulture, "ns={0};", namespaceIndex);
            }

            // add identifier type prefix.
            switch (identifierType)
            {
                case IdType.Numeric:
                {
                    buffer.Append("i=");
                    break;
                }

                case IdType.String:
                {
                    buffer.Append("s=");
                    break;
                }

                case IdType.Guid:
                {
                    buffer.Append("g=");
                    break;
                }

                case IdType.Opaque:
                {
                    buffer.Append("b=");
                    break;
                }
            }

            // add identifier.
            FormatIdentifier(buffer, identifier, identifierType);
        }
        #endregion

        #region public override string ToString()

        /// <summary>
        /// Returns the string representation of a NodeId.
        /// </summary>
        /// <remarks>
        /// Returns the Node represented as a String. This is the same as calling
        /// <see cref="Format()"/>.
        /// </remarks>
        public override string ToString()
        {
            return ToString(null, null);
        }

        #endregion
        #region public static ExpandedNodeId ToExpandedNodeId(NodeId nodeId, NamespaceTable namespaceTable)
        /// <summary>
        /// Converts an node id to an expanded node id using a namespace table.
        /// </summary>
        /// <remarks>
        /// Returns an ExpandedNodeId based on the NodeId requested in the parameters. If the namespaceTable
        /// is specified then the relevant namespace will be returned from the namespaceTable collection which is
        /// also passed in as a parameter.
        /// </remarks>
        /// <returns>null, if the <i>nodeId</i> parameter is null. Otherwise an ExpandedNodeId will be returned for the specified nodeId</returns>
        /// <param name="nodeId">The NodeId to return, wrapped in within the ExpandedNodeId.</param>
        /// <param name="namespaceTable">The namespace tables collection that may be used to retrieve the namespace from that the specified NodeId belongs to</param>
        public static ExpandedNodeId ToExpandedNodeId(NodeId nodeId, NamespaceTable namespaceTable)
        {
            if (nodeId == null)
            {
                return null;
            }

            ExpandedNodeId expandedId = new ExpandedNodeId(nodeId);

            if (nodeId.NamespaceIndex > 0)
            {
                string uri = namespaceTable.GetString(nodeId.NamespaceIndex);

                if (uri != null)
                {
                    expandedId.SetNamespaceUri(uri);
                }
            }

            return expandedId;
        }

        #endregion
        /// <summary>
        /// Updates the namespace index.
        /// </summary>
        internal void SetNamespaceIndex(ushort value)
        {
            m_namespaceIndex = value;
        }

        /// <summary>
        /// Updates the identifier.
        /// </summary>
        internal void SetIdentifier(IdType idType, object value)
        {
            m_identifierType = idType;

            switch (idType)
            {
                case IdType.Opaque:
                {
                    m_identifier = Utils.Clone(value);
                    break;
                }

                default:
                {
                    m_identifier = value;
                    break;
                }
            }
        }

        /// <summary>
        /// Updates the identifier.
        /// </summary>
        internal void SetIdentifier(string value, IdType idType)
        {
            m_identifierType = idType;
            SetIdentifier(IdType.String, value);
        }

        #endregion

        #region IComparable Members

        #region public int CompareTo(object obj)
        /// <summary>
        /// Compares the current instance to the object.
        /// </summary>
        /// <remarks>
        /// Enables this object type to be compared to other types of object.
        /// </remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public int CompareTo(object obj)
        {
            // check for null.
            if (Object.ReferenceEquals(obj, null))
            {
                return -1;
            }

            // check for reference comparisons.
            if (Object.ReferenceEquals(this, obj))
            {
                return 0;
            }

            ushort namespaceIndex = this.m_namespaceIndex;
            IdType idType = this.m_identifierType;
            object id = null;

            // check for expanded node ids.
            NodeId nodeId = obj as NodeId;

            if (!Object.ReferenceEquals(nodeId, null))
            {
                namespaceIndex = nodeId.NamespaceIndex;
                idType = nodeId.IdType;
                id = nodeId.Identifier;
            }
            else
            {
                // check for numeric contants.
                if (obj is UInt32? uid)
                {
                    if (namespaceIndex != 0 || idType != IdType.Numeric)
                    {
                        return -1;
                    }

                    uint id1 = (uint)m_identifier;
                    uint id2 = uid.Value;

                    if (id1 == id2)
                    {
                        return 0;
                    }

                    return (id1 < id2) ? -1 : +1;
                }

                ExpandedNodeId expandedId = obj as ExpandedNodeId;

                if (!Object.ReferenceEquals(expandedId, null))
                {
                    if (expandedId.IsAbsolute)
                    {
                        return -1;
                    }

                    namespaceIndex = expandedId.NamespaceIndex;
                    idType = expandedId.IdType;
                    id = expandedId.Identifier;
                }
            }

            // check for different namespace.
            if (namespaceIndex != m_namespaceIndex)
            {
                return (m_namespaceIndex < namespaceIndex) ? -1 : +1;
            }

            // check for different id type.
            if (idType != m_identifierType)
            {
                return (m_identifierType < idType) ? -1 : +1;
            }

            // check for two nulls.
            if (m_identifier == null && id == null)
            {
                return 0;
            }

            // check for a single null.
            if (m_identifier == null && id != null)
            {
                switch (idType)
                {
                    case IdType.String:
                    {
                        string stringId = id as string;

                        if (stringId.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Opaque:
                    {
                        byte[] opaqueId = id as byte[];

                        if (opaqueId.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Numeric:
                    {
                        uint? numericId = id as uint?;

                        if (numericId.Value == 0)
                        {
                            return 0;
                        }

                        break;
                    }
                }

                return -1;
            }

            // check for a single null.
            if (m_identifier != null && id == null)
            {
                switch (idType)
                {
                    case IdType.String:
                    {
                        string stringId = m_identifier as string;

                        if (stringId.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Opaque:
                    {
                        byte[] opaqueId = m_identifier as byte[];

                        if (opaqueId.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Numeric:
                    {
                        uint? numericId = m_identifier as uint?;

                        if (numericId.Value == 0)
                        {
                            return 0;
                        }

                        break;
                    }
                }

                return +1;
            }

            // compare ids.
            switch (idType)
            {
                case IdType.Numeric:
                {
                    uint id1 = (uint)m_identifier;
                    uint id2 = (uint)id;

                    if (id1 == id2)
                    {
                        return 0;
                    }

                    return (id1 < id2) ? -1 : +1;
                }

                case IdType.String:
                {
                    string id1 = (string)m_identifier;
                    string id2 = (string)id;
                    return String.CompareOrdinal(id1, id2);
                }

                case IdType.Guid:
                {
                    Guid id1 = (Guid)m_identifier;
                    if (id is Uuid uuid)
                    {
                        return id1.CompareTo(uuid);
                    }
                    return id1.CompareTo((Guid)id);
                }

                case IdType.Opaque:
                {
                    byte[] id1 = (byte[])m_identifier;
                    byte[] id2 = (byte[])id;

                    if (id1.Length == id2.Length)
                    {
                        for (int ii = 0; ii < id1.Length; ii++)
                        {
                            if (id1[ii] != id2[ii])
                            {
                                return (id1[ii] < id2[ii]) ? -1 : +1;
                            }
                        }

                        return 0;
                    }

                    return (id1.Length < id2.Length) ? -1 : +1;
                }
            }

            // invalid id type - should never get here.
            return +1;
        }

        #endregion
        #region public static bool operator>(NodeId value1, NodeId value2)
        /// <summary>
        /// Returns true if a is greater than b.
        /// </summary>
        /// <remarks>
        /// Returns true if a is greater than b.
        /// </remarks>
        public static bool operator >(NodeId value1, NodeId value2)
        {
            if (!Object.ReferenceEquals(value1, null))
            {
                return value1.CompareTo(value2) > 0;
            }

            return false;
        }

        #endregion        
        #region public static bool operator<(NodeId value1, NodeId value2)
        /// <summary>
        /// Returns true if a is less than b.
        /// </summary>
        /// <remarks>
        /// Returns true if a is less than b.
        /// </remarks>
        public static bool operator <(NodeId value1, NodeId value2)
        {
            if (!Object.ReferenceEquals(value1, null))
            {
                return value1.CompareTo(value2) < 0;
            }

            return true;
        }
        #endregion

        #endregion

        #region IFormattable Members

        #region public string ToString(string format, IFormatProvider formatProvider)
        /// <summary>
        /// Returns the string representation of a NodeId.
        /// </summary>
        /// <remarks>
        /// Returns the string representation of a NodeId. This is the same as calling
        /// <see cref="Format()"/>.
        /// </remarks>
        /// <exception cref="FormatException">Thrown when the format is not null</exception>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                return String.Format(formatProvider, "{0}", Format());
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }

        #endregion

        #endregion

        /// <summary>
        /// Makes a deep copy of the object.
        /// </summary>
        /// <remarks>
        /// Returns a copy of this object.
        /// </remarks>
        public new object MemberwiseClone()
        {
            // this object cannot be altered after it is created so no new allocation is necessary.
            return this;
        }

        #region Comparison Functions

        #region public override bool Equals(object obj)
        /// <summary>
        /// Determines if the specified object is equal to the NodeId.
        /// </summary>
        /// <remarks>
        /// Returns a true/false if the specified NodeId is the same as this NodeId.
        /// </remarks>
        /// <param name="obj">The object (NodeId or ExpandedNodeId is desired) to compare to</param>
        public override bool Equals(object obj)
        {
            return (CompareTo(obj) == 0);
        }

        #endregion
        #region public override int GetHashCode()
        /// <summary>
        /// Returns a unique hashcode for the NodeId
        /// </summary>
        /// <remarks>
        /// Returns a unique hashcode for the NodeId
        /// </remarks>
        public override int GetHashCode()
        {
            if (m_identifier == null)
            {
                return 0;
            }

            if (m_identifierType == IdType.Opaque)
            {
                byte[] id = (byte[])m_identifier;

                int hash = id.Length;

                for (int ii = 0; ii < 16 && ii < id.Length; ii++)
                {
                    hash <<= 1;
                    hash += id[ii];

                    if (id.Length - ii >= 1)
                    {
                        hash += (id[id.Length - ii - 1] << 16);
                    }
                }

                return hash;
            }

            return m_identifier.GetHashCode();
        }

        #endregion
        #region public static bool operator==(NodeId a, object b) 
        /// <summary>
        /// Returns true if the objects are equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are equal.
        /// </remarks>
        public static bool operator ==(NodeId value1, object value2)
        {
            if (Object.ReferenceEquals(value1, null))
            {
                return Object.ReferenceEquals(value2, null);
            }

            return (value1.CompareTo(value2) == 0);
        }

        #endregion
        #region public static bool operator!=(NodeId value1, object value2) 
        /// <summary>
        /// Returns true if the objects are not equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are not equal.
        /// </remarks>
        public static bool operator !=(NodeId value1, object value2)
        {
            if (Object.ReferenceEquals(value1, null))
            {
                return !Object.ReferenceEquals(value2, null);
            }

            return (value1.CompareTo(value2) != 0);
        }


        #endregion

        #endregion

        #region Public Properties

        #region internal string IdentifierText
        /// <summary>
        /// The node identifier formatted as a URI.
        /// </summary>
        /// <remarks>
        /// The node identifier formatted as a URI.
        /// </remarks>
        [DataMember(Name = "Identifier", Order = 1)]
        internal string IdentifierText
        {
            get
            {
                return Format();
            }
            set
            {
                NodeId nodeId = NodeId.Parse(value);

                m_namespaceIndex = nodeId.NamespaceIndex;
                m_identifierType = nodeId.IdType;
                m_identifier = nodeId.Identifier;
            }
        }

        #endregion                
        #region public ushort NamespaceIndex
        /// <summary>
        /// The index of the namespace URI in the server's namespace array.
        /// </summary>
        /// <remarks>
        /// The index of the namespace URI in the server's namespace array.
        /// </remarks>
        public ushort NamespaceIndex => m_namespaceIndex;

        #endregion
        #region public IdType IdType
        /// <summary>
        /// The type of node identifier used.
        /// </summary>
        /// <remarks>
        /// Returns the type of Id, whether it is:
        /// <list type="bullet">
        /// <item><see cref="uint"/></item>
        /// <item><see cref="Guid"/></item>
        /// <item><see cref="string"/></item>
        /// <item><see cref="byte"/>[]</item>
        /// </list>
        /// </remarks>
        /// <seealso cref="IdType"/>
        public IdType IdType => m_identifierType;

        #endregion
        #region public object Identifier
        /// <summary>
        /// The node identifier.
        /// </summary>
        /// <remarks>
        /// Returns the Id in its native format, i.e. UInt, GUID, String etc.
        /// </remarks>
        public object Identifier
        {
            get
            {
                if (m_identifier == null)
                {
                    switch (m_identifierType)
                    {
                        case IdType.Numeric: { return (uint)0; }
                        case IdType.Guid: { return Guid.Empty; }
                    }
                }

                return m_identifier;
            }
        }

        #endregion             
        #region public bool IsNull
        /// <summary>
        /// Whether the object represents a Null NodeId.
        /// </summary>
        /// <remarks>
        /// Whether the NodeId represents a Null NodeId.
        /// </remarks>
        public bool IsNullNodeId
        {
            get
            {
                // non-zero namespace means it can't be null.
                if (m_namespaceIndex != 0)
                {
                    return false;
                }

                // the definition of a null identifier depends on the identifier type.
                if (m_identifier != null)
                {
                    switch (m_identifierType)
                    {
                        case IdType.Numeric:
                        {
                            if (!m_identifier.Equals((uint)0))
                            {
                                return false;
                            }

                            break;
                        }

                        case IdType.String:
                        {
                            if (!String.IsNullOrEmpty((string)m_identifier))
                            {
                                return false;
                            }

                            break;
                        }

                        case IdType.Guid:
                        {
                            if (!m_identifier.Equals(Guid.Empty))
                            {
                                return false;
                            }

                            break;
                        }

                        case IdType.Opaque:
                        {
                            if (m_identifier != null && ((byte[])m_identifier).Length > 0)
                            {
                                return false;
                            }

                            break;
                        }
                    }
                }

                // must be null.
                return true;
            }
        }

        #endregion

        #endregion

        #region Private Methods
        /// <summary>
        /// Compares two node identifiers.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private static int CompareIdentifiers(IdType idType1, object id1, IdType idType2, object id2)
        {
            if (id1 == null && id2 == null)
            {
                return 0;
            }

            if (idType1 != idType2)
            {
                return idType1.CompareTo(idType2);
            }

            if (id1 == null || id2 == null)
            {
                object nonNull = id1;

                if (id1 == null)
                {
                    nonNull = id2;
                }

                switch (idType1)
                {
                    case IdType.Numeric:
                    {
                        if (nonNull is uint && (uint)nonNull == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Guid:
                    {
                        if (nonNull is Guid && (Guid)nonNull == Guid.Empty)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.String:
                    {
                        if (nonNull is string text && text.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }

                    case IdType.Opaque:
                    {
                        if (nonNull is byte[] bytes && bytes.Length == 0)
                        {
                            return 0;
                        }

                        break;
                    }
                }

                return (id1 == null) ? -1 : +1;
            }

            if (id1 is byte[] bytes1)
            {
                byte[] bytes2 = id2 as byte[];

                if (bytes2 == null)
                {
                    return +1;
                }

                if (bytes1.Length != bytes2.Length)
                {
                    return bytes1.Length.CompareTo(bytes2.Length);
                }

                for (int ii = 0; ii < bytes1.Length; ii++)
                {
                    int result = bytes1[ii].CompareTo(bytes2[ii]);

                    if (result != 0)
                    {
                        return result;
                    }
                }

                // both arrays are equal.
                return 0;
            }

            if (id1 is IComparable comparable1)
            {
                return comparable1.CompareTo(id2);
            }

            return String.CompareOrdinal(id1.ToString(), id2.ToString());
        }

        /// <summary>
        /// Formats a node id as a string.
        /// </summary>
        private static void FormatIdentifier(StringBuilder buffer, object identifier, IdType identifierType)
        {
            switch (identifierType)
            {
                case IdType.Numeric:
                {
                    if (identifier == null)
                    {
                        buffer.Append('0');
                        break;
                    }

                    buffer.AppendFormat(CultureInfo.InvariantCulture, "{0}", identifier);
                    break;
                }

                case IdType.String:
                {
                    buffer.AppendFormat(CultureInfo.InvariantCulture, "{0}", identifier);
                    break;
                }

                case IdType.Guid:
                {
                    if (identifier == null)
                    {
                        buffer.Append(Guid.Empty);
                        break;
                    }

                    buffer.AppendFormat(CultureInfo.InvariantCulture, "{0}", identifier);
                    break;
                }

                case IdType.Opaque:
                {
                    if (identifier != null)
                    {
                        buffer.AppendFormat(CultureInfo.InvariantCulture, "{0}", Convert.ToBase64String((byte[])identifier));
                    }

                    break;
                }
            }
        }

        #endregion

        #region Private Fields
        private ushort m_namespaceIndex;
        private IdType m_identifierType;
        private object m_identifier;
        #endregion
    }

    #region NodeIdCollection Class
    /// <summary>
    /// A collection of NodeIds.
    /// </summary>
    /// <remarks>
    /// Provides a strongly-typed collection of <see cref="NodeId"/>.
    /// </remarks>
    [CollectionDataContract(Name = "ListOfNodeId", Namespace = Namespaces.OpcUaXsd, ItemName = "NodeId")]
    public partial class NodeIdCollection : List<NodeId>
    {

        #region CTORs

        /// <summary>
        /// Initializes an empty collection.
        /// </summary>
        /// <remarks>
        /// Initializes an empty collection.
        /// </remarks>
        public NodeIdCollection() { }

        /// <summary>
        /// Initializes the collection from another collection.
        /// </summary>
        /// <remarks>
        /// Creates a new collection based on the referenced collection.
        /// </remarks>
        /// <param name="collection">The existing collection to use as the basis of creating this collection</param>
        public NodeIdCollection(IEnumerable<NodeId> collection) : base(collection) { }

        /// <summary>
        /// Initializes the collection with the specified capacity.
        /// </summary>
        /// <remarks>
        /// Creates a new collection while specifying the max size of the collection.
        /// </remarks>
        /// <param name="capacity">The max. capacity of the collection</param>
        public NodeIdCollection(int capacity) : base(capacity) { }

        #endregion        

        #region public static NodeIdCollection ToNodeIdCollection(NodeId[] values)
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <remarks>
        /// A quick-use method that will take an array of <see cref="NodeId"/> objects and will
        /// return them within a <see cref="NodeIdCollection"/>.
        /// </remarks>
        /// <param name="values">An array of <see cref="NodeId"/> to add to the collection</param>
        /// <returns>A <see cref="NodeIdCollection"/> containing the <see cref="NodeId"/>'s added via the parameters</returns>
        public static NodeIdCollection ToNodeIdCollection(NodeId[] values)
        {
            if (values != null)
            {
                return new NodeIdCollection(values);
            }

            return new NodeIdCollection();
        }

        #endregion
        #region public static implicit operator NodeIdCollection(NodeId[] values)
        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <remarks>
        /// Converts an array to a collection.
        /// </remarks>
        /// <param name="values">An array of <see cref="NodeId"/> objects to compare</param>
        public static implicit operator NodeIdCollection(NodeId[] values)
        {
            return ToNodeIdCollection(values);
        }

        #endregion

        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        /// <remarks>
        /// Creates a deep copy of the collection.
        /// </remarks>
        public new object MemberwiseClone()
        {
            NodeIdCollection clone = new NodeIdCollection(this.Count);

            foreach (NodeId element in this)
            {
                clone.Add((NodeId)Utils.Clone(element));
            }

            return clone;
        }
    }//class
    #endregion

    /// <summary>
    /// A dictionary designed to provide efficient lookups for objects identified by a NodeId
    /// </summary>
    public class NodeIdDictionary<T> : IDictionary<NodeId, T>
    {
        #region Constructors
        /// <summary>
        /// Creates an empty dictionary.
        /// </summary>
        public NodeIdDictionary()
        {
            m_version = 0;
            m_numericIds = new SortedDictionary<ulong, T>();
        }
        #endregion

        #region IDictionary<NodeId,T> Members
        /// <summary cref="IDictionary.Add" />
        public void Add(NodeId key, T value)
        {
            if (key == null)
            {
                throw new ArgumentNullException(nameof(key));
            }

            m_version++;

            switch (key.IdType)
            {
                case IdType.Numeric:
                {
                    ulong id = ((ulong)key.NamespaceIndex) << 32;
                    id += (uint)key.Identifier;
                    m_numericIds.Add(id, value);
                    return;
                }

                case IdType.String:
                {
                    IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, true);
                    dictionary.Add((string)key.Identifier, value);
                    return;
                }

                case IdType.Guid:
                {
                    IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, true);
                    dictionary.Add((Guid)key.Identifier, value);
                    return;
                }

                case IdType.Opaque:
                {
                    IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, true);
                    dictionary.Add(new NodeIdDictionary<T>.ByteKey((byte[])key.Identifier), value);
                    return;
                }
            }

            throw new ArgumentOutOfRangeException(nameof(key), "key.IdType");
        }

        /// <summary cref="IDictionary{TKey,TValue}.ContainsKey" />
        public bool ContainsKey(NodeId key)
        {
            if (key == null)
            {
                return false;
            }

            switch (key.IdType)
            {
                case IdType.Numeric:
                {
                    ulong id = ((ulong)key.NamespaceIndex) << 32;
                    id += (uint)key.Identifier;
                    return m_numericIds.ContainsKey(id);
                }

                case IdType.String:
                {
                    IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.ContainsKey((string)key.Identifier);
                    }

                    break;
                }

                case IdType.Guid:
                {
                    IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.ContainsKey((Guid)key.Identifier);
                    }

                    break;
                }

                case IdType.Opaque:
                {
                    IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.ContainsKey(new ByteKey((byte[])key.Identifier));
                    }

                    break;
                }
            }

            return false;
        }

        /// <summary cref="IDictionary{TKey,TValue}.Keys" />
        public ICollection<NodeId> Keys
        {
            get
            {
                List<NodeId> keys = new List<NodeId>();

                foreach (ulong id in m_numericIds.Keys)
                {
                    keys.Add(new NodeId((uint)(id & 0xFFFFFFFF), (ushort)((id >> 32) & 0xFFFF)));
                }

                if (m_dictionarySets == null)
                {
                    return keys;
                }

                for (ushort ii = 0; ii < (ushort)m_dictionarySets.Length; ii++)
                {
                    DictionarySet dictionarySet = m_dictionarySets[ii];

                    if (dictionarySet == null)
                    {
                        continue;
                    }

                    if (dictionarySet.String != null)
                    {
                        foreach (string id in dictionarySet.String.Keys)
                        {
                            keys.Add(new NodeId(id, ii));
                        }
                    }

                    if (dictionarySet.Guid != null)
                    {
                        foreach (Guid id in dictionarySet.Guid.Keys)
                        {
                            keys.Add(new NodeId(id, ii));
                        }
                    }

                    if (dictionarySet.Opaque != null)
                    {
                        foreach (ByteKey id in dictionarySet.Opaque.Keys)
                        {
                            keys.Add(new NodeId(id.Bytes, ii));
                        }
                    }
                }

                return keys;
            }
        }

        /// <summary cref="IDictionary.Remove" />
        public bool Remove(NodeId key)
        {
            if (key == null)
            {
                return false;
            }

            m_version++;

            switch (key.IdType)
            {
                case IdType.Numeric:
                {
                    ulong id = ((ulong)key.NamespaceIndex) << 32;
                    id += (uint)key.Identifier;
                    return m_numericIds.Remove(id);
                }

                case IdType.String:
                {
                    IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.Remove((string)key.Identifier);
                    }

                    break;
                }

                case IdType.Guid:
                {
                    IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.Remove((Guid)key.Identifier);
                    }

                    break;
                }

                case IdType.Opaque:
                {
                    IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.Remove(new ByteKey((byte[])key.Identifier));
                    }

                    break;
                }
            }

            return false;
        }

        /// <summary cref="IDictionary{TKey,TValue}.TryGetValue" />
        public bool TryGetValue(NodeId key, out T value)
        {
            value = default(T);

            if (key == null)
            {
                return false;
            }

            switch (key.IdType)
            {
                case IdType.Numeric:
                {
                    ulong id = ((ulong)key.NamespaceIndex) << 32;
                    id += (uint)key.Identifier;
                    return m_numericIds.TryGetValue(id, out value);
                }

                case IdType.String:
                {
                    IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.TryGetValue((string)key.Identifier, out value);
                    }

                    break;
                }

                case IdType.Guid:
                {
                    IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.TryGetValue((Guid)key.Identifier, out value);
                    }

                    break;
                }

                case IdType.Opaque:
                {
                    IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, false);

                    if (dictionary != null)
                    {
                        return dictionary.TryGetValue(new ByteKey((byte[])key.Identifier), out value);
                    }

                    break;
                }
            }

            return false;
        }

        /// <summary cref="IDictionary{TKey,TValue}.Values" />
        public ICollection<T> Values
        {
            get
            {
                List<T> values = new List<T>();
                values.AddRange(m_numericIds.Values);

                if (m_dictionarySets == null)
                {
                    return values;
                }

                for (int ii = 0; ii < m_dictionarySets.Length; ii++)
                {
                    DictionarySet dictionarySet = m_dictionarySets[ii];

                    if (dictionarySet == null)
                    {
                        continue;
                    }

                    if (dictionarySet.String != null)
                    {
                        values.AddRange(dictionarySet.String.Values);
                    }

                    if (dictionarySet.Guid != null)
                    {
                        values.AddRange(dictionarySet.Guid.Values);
                    }

                    if (dictionarySet.Opaque != null)
                    {
                        values.AddRange(dictionarySet.Opaque.Values);
                    }
                }

                return values;
            }
        }

        /// <summary>
        /// Gets or sets the value with the specified NodeId.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        public T this[NodeId key]
        {
            get
            {
                if (key == null)
                {
                    throw new ArgumentNullException(nameof(key));
                }

                switch (key.IdType)
                {
                    case IdType.Numeric:
                    {
                        ulong id = ((ulong)key.NamespaceIndex) << 32;
                        id += (uint)key.Identifier;
                        return m_numericIds[id];
                    }

                    case IdType.String:
                    {
                        IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, false);

                        if (dictionary != null)
                        {
                            return dictionary[(string)key.Identifier];
                        }

                        break;
                    }

                    case IdType.Guid:
                    {
                        IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, false);

                        if (dictionary != null)
                        {
                            return dictionary[(Guid)key.Identifier];
                        }

                        break;
                    }

                    case IdType.Opaque:
                    {
                        IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, false);

                        if (dictionary != null)
                        {
                            return dictionary[new ByteKey((byte[])key.Identifier)];
                        }

                        break;
                    }
                }

                throw new KeyNotFoundException();
            }

            set
            {
                if (key == null)
                {
                    throw new ArgumentNullException(nameof(key));
                }

                m_version++;

                switch (key.IdType)
                {
                    case IdType.Numeric:
                    {
                        ulong id = ((ulong)key.NamespaceIndex) << 32;
                        id += (uint)key.Identifier;
                        m_numericIds[id] = value;
                        return;
                    }

                    case IdType.String:
                    {
                        IDictionary<string, T> dictionary = GetStringDictionary(key.NamespaceIndex, true);
                        dictionary[(string)key.Identifier] = value;
                        return;
                    }

                    case IdType.Guid:
                    {
                        IDictionary<Guid, T> dictionary = GetGuidDictionary(key.NamespaceIndex, true);
                        dictionary[(Guid)key.Identifier] = value;
                        return;
                    }

                    case IdType.Opaque:
                    {
                        IDictionary<ByteKey, T> dictionary = GetOpaqueDictionary(key.NamespaceIndex, true);
                        dictionary[new ByteKey((byte[])key.Identifier)] = value;
                        return;
                    }
                }

                throw new ArgumentOutOfRangeException(nameof(key), "key.IdType");
            }
        }
        #endregion

        #region ICollection<KeyValuePair<NodeId,T>> Members
        /// <summary cref="ICollection{T}.Add" />
        public void Add(KeyValuePair<NodeId, T> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary cref="ICollection{T}.Clear" />
        public void Clear()
        {
            m_version++;
            m_numericIds.Clear();
            m_dictionarySets = null;
        }

        /// <summary cref="ICollection{T}.Contains" />
        public bool Contains(KeyValuePair<NodeId, T> item)
        {
            T value;

            if (!TryGetValue(item.Key, out value))
            {
                return false;
            }

            return Object.Equals(value, item.Value);
        }

        /// <summary cref="ICollection{T}.CopyTo" />
        public void CopyTo(KeyValuePair<NodeId, T>[] array, int arrayIndex)
        {
            if (array == null)
            {
                throw new ArgumentNullException(nameof(array));
            }

            if (arrayIndex < 0 || array.Length <= arrayIndex)
            {
                throw new ArgumentOutOfRangeException(nameof(arrayIndex), "arrayIndex < 0 || array.Length <= arrayIndex");
            }

            foreach (KeyValuePair<ulong, T> entry in m_numericIds)
            {
                CheckCopyTo(array, arrayIndex);

                array[arrayIndex++] = new KeyValuePair<NodeId, T>(
                    new NodeId((uint)(entry.Key & 0xFFFFFFFF), (ushort)((entry.Key >> 32) & 0xFFFF)),
                    entry.Value);
            }

            if (m_dictionarySets == null)
            {
                return;
            }

            for (int ii = 0; ii < m_dictionarySets.Length; ii++)
            {
                DictionarySet dictionarySet = m_dictionarySets[ii];

                if (dictionarySet == null)
                {
                    continue;
                }

                if (dictionarySet.String != null)
                {
                    foreach (KeyValuePair<string, T> entry in dictionarySet.String)
                    {
                        CheckCopyTo(array, arrayIndex);
                        array[arrayIndex++] = new KeyValuePair<NodeId, T>(new NodeId(entry.Key, (ushort)ii), entry.Value);
                    }
                }

                if (dictionarySet.Guid != null)
                {
                    foreach (KeyValuePair<Guid, T> entry in dictionarySet.Guid)
                    {
                        CheckCopyTo(array, arrayIndex);
                        array[arrayIndex++] = new KeyValuePair<NodeId, T>(new NodeId(entry.Key, (ushort)ii), entry.Value);
                    }
                }

                if (dictionarySet.Opaque != null)
                {
                    foreach (KeyValuePair<ByteKey, T> entry in dictionarySet.Opaque)
                    {
                        CheckCopyTo(array, arrayIndex);
                        array[arrayIndex++] = new KeyValuePair<NodeId, T>(new NodeId(entry.Key.Bytes, (ushort)ii), entry.Value);
                    }
                }
            }
        }

        /// <summary>
        /// Checks that there is enough space in the array.
        /// </summary>
        private static void CheckCopyTo(KeyValuePair<NodeId, T>[] array, int arrayIndex)
        {
            if (arrayIndex >= array.Length)
            {
                throw new ArgumentException("Not enough space in array.", nameof(array));
            }
        }

        /// <summary cref="ICollection{T}.Count" />
        public int Count
        {
            get
            {
                int count = m_numericIds.Count;

                if (m_dictionarySets == null)
                {
                    return count;
                }

                for (int ii = 0; ii < m_dictionarySets.Length; ii++)
                {
                    DictionarySet dictionarySet = m_dictionarySets[ii];

                    if (dictionarySet == null)
                    {
                        continue;
                    }

                    if (dictionarySet.String != null)
                    {
                        count += dictionarySet.String.Count;
                    }

                    if (dictionarySet.Guid != null)
                    {
                        count += dictionarySet.Guid.Count;
                    }

                    if (dictionarySet.Opaque != null)
                    {
                        count += dictionarySet.Opaque.Count;
                    }
                }

                return count;
            }
        }

        /// <summary cref="ICollection{T}.IsReadOnly" />
        public bool IsReadOnly => false;

        /// <summary cref="ICollection{T}.Remove" />
        public bool Remove(KeyValuePair<NodeId, T> item)
        {
            return Remove(item.Key);
        }
        #endregion

        #region IEnumerable<KeyValuePair<NodeId,T>> Members
        /// <summary cref="System.Collections.IEnumerable.GetEnumerator()" />
        public IEnumerator<KeyValuePair<NodeId, T>> GetEnumerator()
        {
            return new Enumerator(this);
        }
        #endregion

        #region IEnumerable Members
        /// <summary cref="System.Collections.IEnumerable.GetEnumerator()" />
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Returns the dictionary set for the specified namespace.
        /// </summary>
        private DictionarySet GetDictionarySet(ushort namespaceIndex, bool create)
        {
            if (m_dictionarySets == null || m_dictionarySets.Length <= namespaceIndex)
            {
                if (!create)
                {
                    return null;
                }

                DictionarySet[] dictionarySets = new NodeIdDictionary<T>.DictionarySet[namespaceIndex + 1];

                if (m_dictionarySets != null)
                {
                    Array.Copy(m_dictionarySets, dictionarySets, m_dictionarySets.Length);
                }

                m_dictionarySets = dictionarySets;
            }

            DictionarySet dictionarySet = m_dictionarySets[namespaceIndex];

            if (dictionarySet == null)
            {
                if (!create)
                {
                    return null;
                }

                m_dictionarySets[namespaceIndex] = dictionarySet = new NodeIdDictionary<T>.DictionarySet();
            }

            return dictionarySet;
        }

        /// <summary>
        /// Returns the dictionary set for String identifiers in the specified namespace.
        /// </summary>
        private IDictionary<string, T> GetStringDictionary(ushort namespaceIndex, bool create)
        {
            DictionarySet dictionarySet = GetDictionarySet(namespaceIndex, create);

            if (dictionarySet == null)
            {
                return null;
            }

            IDictionary<string, T> dictionary = dictionarySet.String;

            if (dictionary == null)
            {
                if (!create)
                {
                    return null;
                }

                dictionary = dictionarySet.String = new SortedDictionary<string, T>();
            }

            return dictionary;
        }

        /// <summary>
        /// Returns the dictionary set for Guid identifiers in the specified namespace.
        /// </summary>
        private IDictionary<Guid, T> GetGuidDictionary(ushort namespaceIndex, bool create)
        {
            DictionarySet dictionarySet = GetDictionarySet(namespaceIndex, create);

            if (dictionarySet == null)
            {
                return null;
            }

            IDictionary<Guid, T> dictionary = dictionarySet.Guid;

            if (dictionary == null)
            {
                if (!create)
                {
                    return null;
                }

                dictionary = dictionarySet.Guid = new SortedDictionary<Guid, T>();
            }

            return dictionary;
        }

        /// <summary>
        /// Returns the dictionary set for Opaque identifiers in the specified namespace.
        /// </summary>
        private IDictionary<ByteKey, T> GetOpaqueDictionary(ushort namespaceIndex, bool create)
        {
            DictionarySet dictionarySet = GetDictionarySet(namespaceIndex, create);

            if (dictionarySet == null)
            {
                return null;
            }

            IDictionary<ByteKey, T> dictionary = dictionarySet.Opaque;

            if (dictionary == null)
            {
                if (!create)
                {
                    return null;
                }

                dictionary = dictionarySet.Opaque = new SortedDictionary<ByteKey, T>();
            }

            return dictionary;
        }
        #endregion

        #region DictionarySet Class
        /// <summary>
        /// Stores the dictionaries for a single namespace index.
        /// </summary>
        private class DictionarySet
        {
            public SortedDictionary<string, T> String;
            public SortedDictionary<Guid, T> Guid;
            public SortedDictionary<ByteKey, T> Opaque;
        }
        #endregion

        #region ByteKey Class
        /// <summary>
        /// Wraps a byte array for use as a key in a dictionary.
        /// </summary>
        private struct ByteKey : IEquatable<ByteKey>, IComparable<ByteKey>
        {
            #region Public Interface
            /// <summary>
            /// Initializes the key with an array of bytes.
            /// </summary>
            public ByteKey(byte[] bytes)
            {
                Bytes = bytes;
            }

            /// <summary>
            /// The array of bytes.
            /// </summary>
            public byte[] Bytes;
            #endregion

            #region IEquatable<ByteKey> Members
            /// <summary cref="IEquatable{T}"></summary>
            public bool Equals(ByteKey other)
            {
                if (other.Bytes == null || Bytes == null)
                {
                    return (other.Bytes == null && Bytes == null);
                }

                if (other.Bytes.Length != Bytes.Length)
                {
                    return false;
                }

                for (int ii = 0; ii < other.Bytes.Length; ii++)
                {
                    if (other.Bytes[ii] != Bytes[ii])
                    {
                        return false;
                    }
                }

                return false;
            }
            #endregion

            #region IComparable<ByteKey> Members
            /// <summary cref="IComparable{T}.CompareTo"></summary>
            public int CompareTo(ByteKey other)
            {
                if (other.Bytes == null || Bytes == null)
                {
                    return (other.Bytes == null) ? +1 : -1;
                }

                if (other.Bytes.Length != Bytes.Length)
                {
                    return (other.Bytes.Length < Bytes.Length) ? +1 : -1;
                }

                for (int ii = 0; ii < other.Bytes.Length; ii++)
                {
                    if (other.Bytes[ii] != Bytes[ii])
                    {
                        return (other.Bytes[ii] < Bytes[ii]) ? +1 : -1;
                    }
                }

                return 0;
            }
            #endregion
        }
        #endregion        

        #region Enumerator Class
        /// <summary>
        /// The enumerator for the node dictionary.
        /// </summary>
        private class Enumerator : IEnumerator<KeyValuePair<NodeId, T>>
        {
            #region Constructors
            /// <summary>
            /// Constructs the enumerator for the specified dictionary.
            /// </summary>
            public Enumerator(NodeIdDictionary<T> dictionary)
            {
                m_dictionary = dictionary;
                m_version = dictionary.m_version;
                m_idType = 0;
                m_namespaceIndex = 0;
            }
            #endregion

            #region IEnumerator<KeyValuePair<NodeId,T>> Members
            /// <summary cref="IEnumerator{T}.Current" />
            public KeyValuePair<NodeId, T> Current
            {
                get
                {
                    CheckVersion();

                    if (m_enumerator == null)
                    {
                        throw new InvalidOperationException("The enumerator is positioned before the first element of the collection or after the last element.");
                    }

                    NodeId id = null;

                    switch (m_idType)
                    {
                        case IdType.Numeric:
                        {
                            ulong key = (ulong)m_enumerator.Key;
                            id = new NodeId((uint)(key & 0xFFFFFFFF), (ushort)((key >> 32) & 0xFFFF));
                            break;
                        }

                        case IdType.String:
                        {
                            id = new NodeId((string)m_enumerator.Key, m_namespaceIndex);
                            break;
                        }

                        case IdType.Guid:
                        {
                            id = new NodeId((Guid)m_enumerator.Key, m_namespaceIndex);
                            break;
                        }

                        case IdType.Opaque:
                        {
                            id = new NodeId(((ByteKey)m_enumerator.Key).Bytes, m_namespaceIndex);
                            break;
                        }
                    }

                    return new KeyValuePair<NodeId, T>(id, (T)m_enumerator.Value);
                }
            }
            #endregion

            #region IDisposable Members
            /// <summary>
            /// Frees any unmanaged resources.
            /// </summary>
            public void Dispose()
            {
                Dispose(true);
            }

            /// <summary>
            /// An overrideable version of the Dispose.
            /// </summary>
            protected virtual void Dispose(bool disposing)
            {
                if (disposing)
                {
                    // do to nothing.
                }
            }
            #endregion

            #region IEnumerator Members
            /// <summary cref="IEnumerator.Current" />
            object System.Collections.IEnumerator.Current => this.Current;

            /// <summary cref="IEnumerator.MoveNext" />
            public bool MoveNext()
            {
                CheckVersion();

                if (m_enumerator == null)
                {
                    m_enumerator = m_dictionary.m_numericIds.GetEnumerator();
                    m_idType = IdType.Numeric;
                    m_namespaceIndex = 0;
                }

                bool result = m_enumerator.MoveNext();

                if (result)
                {
                    return true;
                }

                while (m_dictionary.m_dictionarySets != null && m_namespaceIndex < m_dictionary.m_dictionarySets.Length)
                {
                    if (m_idType == IdType.Numeric)
                    {
                        m_idType = IdType.String;

                        IDictionary<string, T> dictionary = m_dictionary.GetStringDictionary(m_namespaceIndex, false);

                        if (dictionary != null)
                        {
                            ReleaseEnumerator();
                            m_enumerator = (IDictionaryEnumerator)dictionary.GetEnumerator();

                            if (m_enumerator.MoveNext())
                            {
                                return true;
                            }
                        }
                    }

                    if (m_idType == IdType.String)
                    {
                        m_idType = IdType.Guid;

                        IDictionary<Guid, T> dictionary = m_dictionary.GetGuidDictionary(m_namespaceIndex, false);

                        if (dictionary != null)
                        {
                            ReleaseEnumerator();
                            m_enumerator = (IDictionaryEnumerator)dictionary.GetEnumerator();

                            if (m_enumerator.MoveNext())
                            {
                                return true;
                            }
                        }
                    }

                    if (m_idType == IdType.Guid)
                    {
                        m_idType = IdType.Opaque;

                        IDictionary<ByteKey, T> dictionary = m_dictionary.GetOpaqueDictionary(m_namespaceIndex, false);

                        if (dictionary != null)
                        {
                            ReleaseEnumerator();
                            m_enumerator = (IDictionaryEnumerator)dictionary.GetEnumerator();

                            if (m_enumerator.MoveNext())
                            {
                                return true;
                            }
                        }
                    }

                    m_idType = IdType.Numeric;
                    m_namespaceIndex++;
                }

                ReleaseEnumerator();
                return false;
            }

            /// <summary cref="IEnumerator.Reset" />
            public void Reset()
            {
                CheckVersion();
                ReleaseEnumerator();
                m_idType = 0;
                m_namespaceIndex = 0;
            }
            #endregion

            #region Private Methods
            /// <summary>
            /// Releases and disposes the current enumerator.
            /// </summary>
            private void ReleaseEnumerator()
            {
                if (m_enumerator != null)
                {
                    IDisposable diposeable = m_enumerator as IDisposable;

                    diposeable?.Dispose();

                    m_enumerator = null;
                }
            }

            /// <summary>
            /// Checks if the dictionary has changed.
            /// </summary>
            private void CheckVersion()
            {
                if (m_version != m_dictionary.m_version)
                {
                    throw new InvalidOperationException("The dictionary was modified after the enumerator was created.");
                }
            }
            #endregion

            #region Private Fields
            private NodeIdDictionary<T> m_dictionary;
            private ushort m_namespaceIndex;
            private IdType m_idType;
            private IDictionaryEnumerator m_enumerator;
            private ulong m_version;
            #endregion
        }
        #endregion

        #region Private Fields
        private DictionarySet[] m_dictionarySets;
        private SortedDictionary<ulong, T> m_numericIds;
        private ulong m_version;
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\NodeId.cs(898,28): error CS8116: It is not legal to use nullable type 'uint?' in a pattern; use the underlying type 'uint' instead.
######################################################################


######################################################################
Nr: 20 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\Variant.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// A structure that could contain value with any of the UA built-in data types.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The Variant is described in <b>Part 6 - Mappings, Section 6.2.2.15</b>, titled <b>Variant</b>
    /// <br/></para>
    /// <para>
    /// Variant is a data type in COM, but not within the .NET Framework. Therefore OPC UA has its own
    /// Variant type that supports all of the OPC UA data-types.
    /// <br/></para>
    /// </remarks>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public partial struct Variant : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Creates a deep copy of the value.
        /// </summary>
        /// <remarks>
        /// Creates a new Variant instance, while deep-copying the contents of the specified Variant
        /// </remarks>
        /// <param name="value">The Variant value to copy.</param>
        public Variant(Variant value)
        {
            m_value = Utils.Clone(value.m_value);
            m_typeInfo = value.m_typeInfo;
        }

        /// <summary>
        /// Constructs a Variant
        /// </summary>
        /// <param name="value">The value to store.</param>
        /// <param name="typeInfo">The type information for the value.</param>
        public Variant(object value, TypeInfo typeInfo)
        {
            m_value = null;
            m_typeInfo = typeInfo;
            Set(value, typeInfo);

#if DEBUG

            TypeInfo sanityCheck = TypeInfo.Construct(m_value);

            // except special case byte array vs. bytestring
            if (sanityCheck.BuiltInType == BuiltInType.ByteString &&
                sanityCheck.ValueRank == ValueRanks.Scalar &&
                typeInfo.BuiltInType == BuiltInType.Byte &&
                typeInfo.ValueRank == ValueRanks.OneDimension)
            {
                return;
            }

            // An enumeration can contain Int32
            if (sanityCheck.BuiltInType == BuiltInType.Int32 &&
                typeInfo.BuiltInType == BuiltInType.Enumeration)
            {
                return;
            }

            System.Diagnostics.Debug.Assert(
                sanityCheck.BuiltInType == m_typeInfo.BuiltInType,
                Utils.Format("{0} != {1}",
                sanityCheck.BuiltInType,
                typeInfo.BuiltInType));

            System.Diagnostics.Debug.Assert(
                sanityCheck.ValueRank == m_typeInfo.ValueRank,
                Utils.Format("{0} != {1}",
                sanityCheck.ValueRank,
                typeInfo.ValueRank));

#endif
        }

        /// <summary>
        /// Initializes the object with an object value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant instance while specifying the value.
        /// </remarks>
        /// <param name="value">The value to encode within the variant</param>
        public Variant(object value)
        {
            m_value = null;
            m_typeInfo = TypeInfo.Construct(value);
            Set(value, m_typeInfo);
        }

        /// <summary>
        /// Initializes the variant with matrix.
        /// </summary>
        /// <param name="value">The value to store within the variant</param>
        public Variant(Matrix value)
        {
            m_value = value;
            m_typeInfo = value.TypeInfo;
        }

        /// <summary>
        /// Initializes the object with a bool value.
        /// </summary>
        /// <remarks>
        /// Creates a new Variant with a Boolean value.
        /// </remarks>
        /// <param name="value">The value of the variant</param>
        public Variant(bool value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Boolean;
        }

        /// <summary>
        /// Initializes the object with a sbyte value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="sbyte"/> value
        /// </remarks>
        /// <param name="value">The <see cref="sbyte"/> value of the Variant</param>
        public Variant(sbyte value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.SByte;
        }

        /// <summary>
        /// Initializes the object with a byte value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="byte"/> value
        /// </remarks>
        /// <param name="value">The <see cref="byte"/> value of the Variant</param>
        public Variant(byte value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Byte;
        }

        /// <summary>
        /// Initializes the object with a short value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="short"/> value
        /// </remarks>
        /// <param name="value">The <see cref="short"/> value of the Variant</param>
        public Variant(short value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int16;
        }

        /// <summary>
        /// Initializes the object with a ushort value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ushort"/> value
        /// </remarks>
        /// <param name="value">The <see cref="ushort"/> value of the Variant</param>
        public Variant(ushort value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt16;
        }

        /// <summary>
        /// Initializes the object with an int value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="int"/> value
        /// </remarks>
        /// <param name="value">The <see cref="int"/> value of the Variant</param>
        public Variant(int value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int32;
        }

        /// <summary>
        /// Initializes the object with a uint value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="uint"/> value
        /// </remarks>
        /// <param name="value">The <see cref="uint"/> value of the Variant</param>
        public Variant(uint value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt32;
        }

        /// <summary>
        /// Initializes the object with a long value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="long"/> value
        /// </remarks>
        /// <param name="value">The <see cref="long"/> value of the Variant</param>
        public Variant(long value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int64;
        }

        /// <summary>
        /// Initializes the object with a ulong value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ulong"/> value
        /// </remarks>
        /// <param name="value">The <see cref="ulong"/> value of the Variant</param>
        public Variant(ulong value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt64;
        }

        /// <summary>
        /// Initializes the object with a float value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="float"/> value
        /// </remarks>
        /// <param name="value">The <see cref="float"/> value of the Variant</param>
        public Variant(float value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Float;
        }

        /// <summary>
        /// Initializes the object with a double value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="double"/> value
        /// </remarks>
        /// <param name="value">The <see cref="double"/> value of the Variant</param>
        public Variant(double value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Double;
        }

        /// <summary>
        /// Initializes the object with a string value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="string"/> value
        /// </remarks>
        /// <param name="value">The <see cref="string"/> value of the Variant</param>
        public Variant(string value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.String;
        }

        /// <summary>
        /// Initializes the object with a DateTime value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="DateTime"/> value
        /// </remarks>
        /// <param name="value">The <see cref="DateTime"/> value of the Variant</param>
        public Variant(DateTime value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.DateTime;
        }

        /// <summary>
        /// Initializes the object with a Guid value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="Guid"/> value
        /// </remarks>
        /// <param name="value">The <see cref="Guid"/> value of the Variant</param>
        public Variant(Guid value)
        {
            m_value = new Uuid(value);
            m_typeInfo = TypeInfo.Scalars.Guid;
        }

        /// <summary>
        /// Initializes the object with a Uuid value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="Uuid"/> value
        /// </remarks>
        /// <param name="value">The <see cref="Uuid"/> value of the Variant</param>
        public Variant(Uuid value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Guid;
        }

        /// <summary>
        /// Initializes the object with a byte[] value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="byte"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="byte"/>-array value of the Variant</param>
        public Variant(byte[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ByteString;
        }

        /// <summary>
        /// Initializes the object with a XmlElement value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="XmlElement"/> value
        /// </remarks>
        /// <param name="value">The <see cref="XmlElement"/> value of the Variant</param>
        public Variant(XmlElement value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.XmlElement;
        }

        /// <summary>
        /// Initializes the object with a NodeId value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="NodeId"/> value
        /// </remarks>
        /// <param name="value">The <see cref="NodeId"/> value of the Variant</param>
        public Variant(NodeId value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.NodeId;
        }

        /// <summary>
        /// Initializes the object with a ExpandedNodeId value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ExpandedNodeId"/> value
        /// </remarks>
        /// <param name="value">The <see cref="ExpandedNodeId"/> value of the Variant</param>
        public Variant(ExpandedNodeId value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ExpandedNodeId;
        }

        /// <summary>
        /// Initializes the object with a StatusCode value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="StatusCode"/> value
        /// </remarks>
        /// <param name="value">The <see cref="StatusCode"/> value of the Variant</param>
        public Variant(StatusCode value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.StatusCode;
        }

        /// <summary>
        /// Initializes the object with a QualifiedName value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="QualifiedName"/> value
        /// </remarks>
        /// <param name="value">The <see cref="QualifiedName"/> value of the Variant</param>
        public Variant(QualifiedName value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.QualifiedName;
        }

        /// <summary>
        /// Initializes the object with a LocalizedText value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="LocalizedText"/> value
        /// </remarks>
        /// <param name="value">The <see cref="LocalizedText"/> value of the Variant</param>
        public Variant(LocalizedText value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.LocalizedText;
        }

        /// <summary>
        /// Initializes the object with a ExtensionObject value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ExtensionObject"/> value
        /// </remarks>
        /// <param name="value">The <see cref="ExtensionObject"/> value of the Variant</param>
        public Variant(ExtensionObject value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ExtensionObject;
        }

        /// <summary>
        /// Initializes the object with a DataValue value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="DataValue"/> value
        /// </remarks>
        /// <param name="value">The <see cref="DataValue"/> value of the Variant</param>
        public Variant(DataValue value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.DataValue;
        }

        /// <summary>
        /// Initializes the object with a bool array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="bool"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="bool"/>-array value of the Variant</param>
        public Variant(bool[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Boolean;
        }

        /// <summary>
        /// Initializes the object with a sbyte array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="sbyte"/>-arrat value
        /// </remarks>
        /// <param name="value">The <see cref="sbyte"/>-array value of the Variant</param>
        public Variant(sbyte[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.SByte;
        }

        /// <summary>
        /// Initializes the object with a short array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="short"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="short"/>-array value of the Variant</param>
        public Variant(short[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int16;
        }

        /// <summary>
        /// Initializes the object with a ushort array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ushort"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="ushort"/>-array value of the Variant</param>
        public Variant(ushort[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt16;
        }

        /// <summary>
        /// Initializes the object with an int array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="int"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="int"/>-array value of the Variant</param>
        public Variant(int[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int32;
        }

        /// <summary>
        /// Initializes the object with a uint array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="uint"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="uint"/>-array value of the Variant</param>
        public Variant(uint[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt32;
        }

        /// <summary>
        /// Initializes the object with a long array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="long"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="long"/>-array value of the Variant</param>
        public Variant(long[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int64;
        }

        /// <summary>
        /// Initializes the object with a ulong array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ulong"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="ulong"/>-array value of the Variant</param>
        public Variant(ulong[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt64;
        }

        /// <summary>
        /// Initializes the object with a float array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="float"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="float"/>-array value of the Variant</param>
        public Variant(float[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Float;
        }

        /// <summary>
        /// Initializes the object with a double array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="double"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="double"/>-array value of the Variant</param>
        public Variant(double[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Double;
        }

        /// <summary>
        /// Initializes the object with a string array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="string"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="string"/>-array value of the Variant</param>
        public Variant(string[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.String;
        }

        /// <summary>
        /// Initializes the object with a DateTime array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="DateTime"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="DateTime"/>-array value of the Variant</param>
        public Variant(DateTime[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.DateTime;
        }

        /// <summary>
        /// Initializes the object with a Guid array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="Guid"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="Guid"/>-array value of the Variant</param>
        public Variant(Guid[] value)
        {
            m_value = null;
            m_typeInfo = TypeInfo.Arrays.Guid;
            Set(value);
        }

        /// <summary>
        /// Initializes the object with a Uuid array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="Uuid"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="Uuid"/>-array value of the Variant</param>
        public Variant(Uuid[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Guid;
        }

        /// <summary>
        /// Initializes the object with a byte[] array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a 2-d <see cref="byte"/>-array value
        /// </remarks>
        /// <param name="value">The 2-d <see cref="byte"/>-array value of the Variant</param>
        public Variant(byte[][] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ByteString;
        }

        /// <summary>
        /// Initializes the object with a XmlElement array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="XmlElement"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="XmlElement"/>-array value of the Variant</param>
        public Variant(XmlElement[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.XmlElement;
        }

        /// <summary>
        /// Initializes the object with a NodeId array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="NodeId"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="NodeId"/>-array value of the Variant</param>
        public Variant(NodeId[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.NodeId;
        }

        /// <summary>
        /// Initializes the object with a ExpandedNodeId array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ExpandedNodeId"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="ExpandedNodeId"/>-array value of the Variant</param>
        public Variant(ExpandedNodeId[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ExpandedNodeId;
        }

        /// <summary>
        /// Initializes the object with a StatusCode array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="StatusCode"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="StatusCode"/>-array value of the Variant</param>
        public Variant(StatusCode[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.StatusCode;
        }

        /// <summary>
        /// Initializes the object with a QualifiedName array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="QualifiedName"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="QualifiedName"/>-array value of the Variant</param>
        public Variant(QualifiedName[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.QualifiedName;
        }

        /// <summary>
        /// Initializes the object with a LocalizedText array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="LocalizedText"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="LocalizedText"/>-array value of the Variant</param>
        public Variant(LocalizedText[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.LocalizedText;
        }

        /// <summary>
        /// Initializes the object with a ExtensionObject array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ExtensionObject"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="ExtensionObject"/>-array value of the Variant</param>
        public Variant(ExtensionObject[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ExtensionObject;
        }

        /// <summary>
        /// Initializes the object with a DataValue array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="DataValue"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="DataValue"/>-array value of the Variant</param>
        public Variant(DataValue[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.DataValue;
        }

        /// <summary>
        /// Initializes the object with a Variant array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="Variant"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="Variant"/>-array value of the Variant</param>
        public Variant(Variant[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Variant;
        }

        /// <summary>
        /// Initializes the object with a object array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="object"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="object"/>-array value of the Variant</param>
        public Variant(object[] value)
        {
            m_value = null;
            m_typeInfo = TypeInfo.Arrays.Variant;
            Set(value);
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// The value stored in the object.
        /// </summary>
        /// <remarks>
        /// The value stored within the Variant object.
        /// </remarks>
        [DataMember(Name = "Value", Order = 1)]
        private XmlElement XmlEncodedValue
        {
            get
            {
                // create encoder.
                XmlEncoder encoder = new XmlEncoder(MessageContextExtension.CurrentContext);

                // write value.
                encoder.WriteVariantContents(m_value, m_typeInfo);

                // create document from encoder.
                XmlDocument document = new XmlDocument();
                document.InnerXml = encoder.Close();

                // return element.
                return document.DocumentElement;
            }

            set
            {
                // check for null values.
                if (value == null)
                {
                    m_value = null;
                    return;
                }

                TypeInfo typeInfo = null;

                // create decoder.
                XmlDecoder decoder = new XmlDecoder(value, MessageContextExtension.CurrentContext);

                try
                {
                    // read value.
                    object body = decoder.ReadVariantContents(out typeInfo);
                    Set(body, typeInfo);
                }
                catch (Exception e)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadDecodingError,
                        e,
                        "Error decoding Variant value.");
                }
                finally
                {
                    // close decoder.
                    decoder.Close();
                }
            }
        }

        /// <summary>
        /// The value stored in the object.
        /// </summary>
        /// <remarks>
        /// The value stored -as <see cref="Object"/>- within the Variant object.
        /// </remarks>
        public object Value
        {
            get { return m_value; }
            set { Set(value, TypeInfo.Construct(value)); }
        }

        /// <summary>
        /// The type information for the matrix.
        /// </summary>
        public TypeInfo TypeInfo => m_typeInfo;
        #endregion

        #region IFormattable Members
        /// <summary>
        /// Returns the string representation of the object.
        /// </summary>
        /// <remarks>
        /// Returns the string representation of the object.
        /// </remarks>
        /// <exception cref="FormatException">Thrown when the 'format' argument is NOT null.</exception>
        /// <param name="format">(Unused) Always pass a NULL value</param>
        /// <param name="formatProvider">The format-provider to use. If unsure, pass an empty string or null</param>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                StringBuilder buffer = new StringBuilder();
                AppendFormat(buffer, m_value, formatProvider);
                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }

        /// <summary>
        /// Formats a value as a string.
        /// </summary>
        private void AppendFormat(StringBuilder buffer, object value, IFormatProvider formatProvider)
        {
            // check for null.
            if (value == null || m_typeInfo == null)
            {
                buffer.Append("(null)");
                return;
            }

            // convert byte string to hexstring.
            if (m_typeInfo.BuiltInType == BuiltInType.ByteString && m_typeInfo.ValueRank < 0)
            {
                byte[] bytes = (byte[])value;

                for (int ii = 0; ii < bytes.Length; ii++)
                {
                    buffer.AppendFormat(formatProvider, "{0:X2}", bytes[ii]);
                }

                return;
            }

            // convert XML element to string.
            if (m_typeInfo.BuiltInType == BuiltInType.XmlElement && m_typeInfo.ValueRank < 0)
            {
                XmlElement xml = (XmlElement)value;
                buffer.AppendFormat(formatProvider, "{0}", xml.OuterXml);
                return;
            }

            // recusrively write individual elements of an array.
            Array array = value as Array;

            if (array != null && m_typeInfo.ValueRank <= 1)
            {
                buffer.Append("{");

                if (array.Length > 0)
                {
                    AppendFormat(buffer, array.GetValue(0), formatProvider);
                }

                for (int ii = 1; ii < array.Length; ii++)
                {
                    buffer.Append(" |");
                    AppendFormat(buffer, array.GetValue(ii), formatProvider);
                }

                buffer.Append("}");
                return;
            }

            // let the object format itself.
            buffer.AppendFormat(formatProvider, "{0}", value);
        }
        #endregion

        #region ICloneable Members
        /// <summary>
        /// Makes a deep copy of the object.
        /// </summary>
        /// <remarks>
        /// Makes a deep copy of the object.
        /// </remarks>
        public new object MemberwiseClone()
        {
            return new Variant(Utils.Clone(this.Value));
        }
        #endregion

        #region Static Operators
        /// <summary>
        /// Returns true if the objects are not equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are not equal.
        /// </remarks>
        public static bool operator ==(Variant a, Variant b)
        {
            return a.Equals(b);
        }

        /// <summary>
        /// Returns true if the objects are not equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are not equal.
        /// </remarks>
        public static bool operator !=(Variant a, Variant b)
        {
            return !a.Equals(b);
        }

        /// <summary>
        /// Converts a bool value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a bool value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(bool value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a sbyte value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a sbyte value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(sbyte value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a byte value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a byte value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(byte value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a short value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a short value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(short value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ushort value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ushort value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ushort value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a int value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a int value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(int value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a uint value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a uint value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(uint value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a long value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a long value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(long value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ulong value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ulong value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ulong value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a float value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a float value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(float value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a double value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a double value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(double value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a string value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a string value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(string value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a DateTime value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a DateTime value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(DateTime value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a Guid value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a Guid value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(Guid value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a Uuid value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a Uuid value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(Uuid value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a byte[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a byte[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(byte[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a XmlElement value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a XmlElement value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(XmlElement value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a NodeId value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a NodeId value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(NodeId value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ExpandedNodeId value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ExpandedNodeId value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ExpandedNodeId value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a StatusCode value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a StatusCode value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(StatusCode value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a QualifiedName value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a QualifiedName value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(QualifiedName value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a LocalizedText value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a LocalizedText value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(LocalizedText value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ExtensionObject value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ExtensionObject value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ExtensionObject value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a DataValue value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a DataValue value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(DataValue value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a bool[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a bool[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(bool[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a sbyte[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a sbyte[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(sbyte[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a short[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a short[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(short[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ushort[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ushort[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ushort[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a int[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a int[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(int[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a uint[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a uint[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(uint[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a long[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a long[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(long[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ulong[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ulong[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ulong[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a float[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a float[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(float[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a double[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a double[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(double[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a string []value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a string []value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(string[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a DateTime[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a DateTime[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(DateTime[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a Guid[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a Guid[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(Guid[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a Uuid[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a Uuid[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(Uuid[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a byte[][] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a byte[][] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(byte[][] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a XmlElement[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a XmlElement[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(XmlElement[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a NodeId[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a NodeId[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(NodeId[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ExpandedNodeId[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ExpandedNodeId[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ExpandedNodeId[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a StatusCode[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a StatusCode[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(StatusCode[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a QualifiedName[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a QualifiedName[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(QualifiedName[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a LocalizedText[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a LocalizedText[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(LocalizedText[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ExtensionObject[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ExtensionObject[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ExtensionObject[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a DataValue[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a DataValue[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(DataValue[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a Variant[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a Variant[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(Variant[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a object[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a object[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(object[] value)
        {
            return new Variant(value);
        }
        #endregion

        #region Static Fields
        /// <summary>
        /// An constant containing a null Variant structure.
        /// </summary>
        /// <remarks>
        /// An constant containing a null Variant structure.
        /// </remarks>
        public static readonly Variant Null = new Variant();
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Determines if the specified object is equal to the object.
        /// </summary>
        /// <remarks>
        /// Determines if the specified object is equal to the object.
        /// </remarks>
        public override bool Equals(object obj)
        {
            if (Object.ReferenceEquals(this, obj))
            {
                return true;
            }

            Variant? variant = obj as Variant?;

            if (variant != null)
            {
                return Utils.IsEqual(m_value, variant.Value.m_value);
            }

            return false;
        }

        /// <summary>
        /// Returns a unique hashcode for the object.
        /// </summary>
        public override int GetHashCode()
        {
            if (this.m_value != null)
            {
                return m_value.GetHashCode();
            }

            return 0;
        }

        /// <summary>
        /// Converts the value to a human readable string.
        /// </summary>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Initializes the object with a bool value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="bool"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="bool"/> value to set this Variant to</param>
        public void Set(bool value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Boolean;
        }

        /// <summary>
        /// Initializes the object with a sbyte value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="sbyte"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="sbyte"/> value to set this Variant to</param>
        public void Set(sbyte value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.SByte;
        }

        /// <summary>
        /// Initializes the object with a byte value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="byte"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="byte"/> value to set this Variant to</param>
        public void Set(byte value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Byte;
        }

        /// <summary>
        /// Initializes the object with a short value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="short"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="short"/> value to set this Variant to</param>
        public void Set(short value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int16;
        }

        /// <summary>
        /// Initializes the object with a ushort value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ushort"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="ushort"/> value to set this Variant to</param>
        public void Set(ushort value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt16;
        }

        /// <summary>
        /// Initializes the object with an int value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="int"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="int"/> value to set this Variant to</param>
        public void Set(int value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int32;
        }

        /// <summary>
        /// Initializes the object with a uint value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="uint"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="uint"/> value to set this Variant to</param>
        public void Set(uint value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt32;
        }

        /// <summary>
        /// Initializes the object with a long value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="long"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="long"/> value to set this Variant to</param>
        public void Set(long value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int64;
        }

        /// <summary>
        /// Initializes the object with a ulong value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ulong"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="ulong"/> value to set this Variant to</param>
        public void Set(ulong value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt64;
        }

        /// <summary>
        /// Initializes the object with a float value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="float"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="float"/> value to set this Variant to</param>
        public void Set(float value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Float;
        }

        /// <summary>
        /// Initializes the object with a double value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="double"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="double"/> value to set this Variant to</param>
        public void Set(double value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Double;
        }

        /// <summary>
        /// Initializes the object with a string value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="string"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="string"/> value to set this Variant to</param>
        public void Set(string value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.String;
        }

        /// <summary>
        /// Initializes the object with a DateTime value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="DateTime"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="DateTime"/> value to set this Variant to</param>
        public void Set(DateTime value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.DateTime;
        }

        /// <summary>
        /// Initializes the object with a Guid value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="Guid"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="Guid"/> value to set this Variant to</param>
        public void Set(Guid value)
        {
            m_value = new Uuid(value);
            m_typeInfo = TypeInfo.Scalars.Guid;
        }

        /// <summary>
        /// Initializes the object with a Uuid value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="Uuid"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="Uuid"/> value to set this Variant to</param>
        public void Set(Uuid value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Guid;
        }

        /// <summary>
        /// Initializes the object with a byte[] value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="byte"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="byte"/>-array value to set this Variant to</param>
        public void Set(byte[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ByteString;
        }

        /// <summary>
        /// Initializes the object with a XmlElement value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="XmlElement"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="XmlElement"/> value to set this Variant to</param>
        public void Set(XmlElement value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.XmlElement;
        }

        /// <summary>
        /// Initializes the object with a NodeId value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="NodeId"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="NodeId"/> value to set this Variant to</param>
        public void Set(NodeId value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.NodeId;
        }

        /// <summary>
        /// Initializes the object with a ExpandedNodeId value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ExpandedNodeId"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="ExpandedNodeId"/> value to set this Variant to</param>
        public void Set(ExpandedNodeId value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ExpandedNodeId;
        }

        /// <summary>
        /// Initializes the object with a StatusCode value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="StatusCode"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="StatusCode"/> value to set this Variant to</param>
        public void Set(StatusCode value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.StatusCode;
        }

        /// <summary>
        /// Initializes the object with a QualifiedName value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="QualifiedName"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="QualifiedName"/> value to set this Variant to</param>
        public void Set(QualifiedName value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.QualifiedName;
        }

        /// <summary>
        /// Initializes the object with a LocalizedText value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="LocalizedText"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="LocalizedText"/> value to set this Variant to</param>
        public void Set(LocalizedText value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.LocalizedText;
        }

        /// <summary>
        /// Initializes the object with a ExtensionObject value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ExtensionObject"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="ExtensionObject"/> value to set this Variant to</param>
        public void Set(ExtensionObject value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ExtensionObject;
        }

        /// <summary>
        /// Initializes the object with a DataValue value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="DataValue"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="DataValue"/> value to set this Variant to</param>
        public void Set(DataValue value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.DataValue;
        }

        /// <summary>
        /// Initializes the object with a bool array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="bool"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="bool"/>-array value to set this Variant to</param>
        public void Set(bool[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Boolean;
        }

        /// <summary>
        /// Initializes the object with a sbyte array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="sbyte"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="sbyte"/>-array value to set this Variant to</param>
        public void Set(sbyte[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.SByte;
        }

        /// <summary>
        /// Initializes the object with a short array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="short"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="short"/>-array value to set this Variant to</param>
        public void Set(short[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int16;
        }

        /// <summary>
        /// Initializes the object with a ushort array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ushort"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="ushort"/>-array value to set this Variant to</param>
        public void Set(ushort[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt16;
        }

        /// <summary>
        /// Initializes the object with an int array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="int"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="int"/>-array value to set this Variant to</param>
        public void Set(int[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int32;
        }

        /// <summary>
        /// Initializes the object with a uint array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="uint"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="uint"/>-array value to set this Variant to</param>
        public void Set(uint[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt32;
        }

        /// <summary>
        /// Initializes the object with a long array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="long"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="long"/>-array value to set this Variant to</param>
        public void Set(long[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int64;
        }

        /// <summary>
        /// Initializes the object with a ulong array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ulong"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="ulong"/>-array value to set this Variant to</param>
        public void Set(ulong[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt64;
        }

        /// <summary>
        /// Initializes the object with a float array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="float"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="float"/>-array value to set this Variant to</param>
        public void Set(float[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Float;
        }

        /// <summary>
        /// Initializes the object with a double array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="double"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="double"/>-array value to set this Variant to</param>
        public void Set(double[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Double;
        }

        /// <summary>
        /// Initializes the object with a string array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="string"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="string"/>-array value to set this Variant to</param>
        public void Set(string[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.String;
        }

        /// <summary>
        /// Initializes the object with a DateTime array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="DateTime"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="DateTime"/>-array value to set this Variant to</param>
        public void Set(DateTime[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.DateTime;
        }

        /// <summary>
        /// Initializes the object with a Guid array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="Guid"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="Guid"/>-array value to set this Variant to</param>
        public void Set(Guid[] value)
        {
            m_value = null;

            if (value != null)
            {
                Uuid[] uuids = new Uuid[value.Length];

                for (int ii = 0; ii < value.Length; ii++)
                {
                    uuids[ii] = new Uuid(value[ii]);
                }

                m_value = uuids;
            }

            m_typeInfo = TypeInfo.Arrays.Guid;
        }

        /// <summary>
        /// Initializes the object with a Uuid array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="Uuid"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="Uuid"/>-array value to set this Variant to</param>
        public void Set(Uuid[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Guid;
        }

        /// <summary>
        /// Initializes the object with a byte[] array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a 2-d <see cref="byte"/>-array value.
        /// </remarks>
        /// <param name="value">The 2-d <see cref="byte"/>-array value to set this Variant to</param>
        public void Set(byte[][] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ByteString;
        }

        /// <summary>
        /// Initializes the object with a XmlElement array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="XmlElement"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="XmlElement"/>-array value to set this Variant to</param>
        public void Set(XmlElement[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.XmlElement;
        }

        /// <summary>
        /// Initializes the object with a NodeId array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="NodeId"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="NodeId"/>-array value to set this Variant to</param>
        public void Set(NodeId[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.NodeId;
        }

        /// <summary>
        /// Initializes the object with a ExpandedNodeId array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ExpandedNodeId"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="ExpandedNodeId"/>-array value to set this Variant to</param>
        public void Set(ExpandedNodeId[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ExpandedNodeId;
        }

        /// <summary>
        /// Initializes the object with a StatusCode array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="StatusCode"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="StatusCode"/>-array value to set this Variant to</param>
        public void Set(StatusCode[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.StatusCode;
        }

        /// <summary>
        /// Initializes the object with a QualifiedName array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="QualifiedName"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="QualifiedName"/>-array value to set this Variant to</param>
        public void Set(QualifiedName[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.QualifiedName;
        }

        /// <summary>
        /// Initializes the object with a LocalizedText array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="LocalizedText"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="LocalizedText"/>-array value to set this Variant to</param>
        public void Set(LocalizedText[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.LocalizedText;
        }

        /// <summary>
        /// Initializes the object with a ExtensionObject array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ExtensionObject"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="ExtensionObject"/>-array value to set this Variant to</param>
        public void Set(ExtensionObject[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ExtensionObject;
        }

        /// <summary>
        /// Initializes the object with a DataValue array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="DataValue"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="DataValue"/>-array value to set this Variant to</param>
        public void Set(DataValue[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.DataValue;
        }

        /// <summary>
        /// Initializes the object with a Variant array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="Variant"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="Variant"/>-array value to set this Variant to</param>
        public void Set(Variant[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Variant;
        }

        /// <summary>
        /// Initializes the object with a object array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="object"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="object"/>-array value to set this Variant to</param>
        public void Set(object[] value)
        {
            m_value = null;

            if (value != null)
            {
                Variant[] anyValues = new Variant[value.Length];

                for (int ii = 0; ii < value.Length; ii++)
                {
                    anyValues[ii] = new Variant(value[ii]);
                }

                m_value = anyValues;
            }

            m_typeInfo = TypeInfo.Arrays.Variant;
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Stores a scalar value in the variant.
        /// </summary>
        private void SetScalar(object value, TypeInfo typeInfo)
        {
            m_typeInfo = typeInfo;

            switch (typeInfo.BuiltInType)
            {
                // handle special types that can be converted to something the variant supports.
                case BuiltInType.Null:
                {
                    // check for enumerated value.
                    if (value.GetType().GetTypeInfo().IsEnum)
                    {
                        Set(Convert.ToInt32(value, CultureInfo.InvariantCulture));
                        return;
                    }

                    // check for matrix
                    Matrix matrix = value as Matrix;

                    if (matrix != null)
                    {
                        m_value = matrix;
                        return;
                    }

                    // not supported.
                    throw new ServiceResultException(
                        StatusCodes.BadNotSupported,
                        Utils.Format("The type '{0}' cannot be stored in a Variant object.", value.GetType().FullName));
                }

                // convert Guids to Uuids.
                case BuiltInType.Guid:
                {
                    Guid? guid = value as Guid?;

                    if (guid != null)
                    {
                        m_value = new Uuid(guid.Value);
                        return;
                    }

                    m_value = value;
                    return;
                }

                // convert encodeables to extension objects.
                case BuiltInType.ExtensionObject:
                {
                    IEncodeable encodeable = value as IEncodeable;

                    if (encodeable != null)
                    {
                        m_value = new ExtensionObject(encodeable);
                        return;
                    }

                    m_value = value;
                    return;
                }

                // convert encodeables to extension objects.
                case BuiltInType.Variant:
                {
                    m_value = ((Variant)value).Value;
                    m_typeInfo = TypeInfo.Construct(m_value);
                    return;
                }

                // just save the value.
                default:
                {
                    m_value = value;
                    return;
                }
            }
        }

        /// <summary>
        /// Stores a on dimensional arrau value in the variant.
        /// </summary>
        private void SetArray(Array array, TypeInfo typeInfo)
        {
            m_typeInfo = typeInfo;

            switch (typeInfo.BuiltInType)
            {
                // handle special types that can be converted to something the variant supports.
                case BuiltInType.Null:
                {
                    // check for enumerated value.
                    if (array.GetType().GetElementType().GetTypeInfo().IsEnum)
                    {
                        int[] values = new int[array.Length];

                        for (int ii = 0; ii < array.Length; ii++)
                        {
                            values[ii] = Convert.ToInt32(array.GetValue(ii), CultureInfo.InvariantCulture);
                        }

                        m_value = values;
                        return;
                    }

                    // not supported.
                    throw new ServiceResultException(
                        StatusCodes.BadNotSupported,
                        Utils.Format("The type '{0}' cannot be stored in a Variant object.", array.GetType().FullName));
                }

                // convert Guids to Uuids.
                case BuiltInType.Guid:
                {
                    Guid[] guids = array as Guid[];

                    if (guids != null)
                    {
                        Set(guids);
                        return;
                    }

                    m_value = array;
                    return;
                }

                // convert encodeables to extension objects.
                case BuiltInType.ExtensionObject:
                {
                    IEncodeable[] encodeables = array as IEncodeable[];

                    if (encodeables != null)
                    {
                        ExtensionObject[] extensions = new ExtensionObject[encodeables.Length];

                        for (int ii = 0; ii < encodeables.Length; ii++)
                        {
                            extensions[ii] = new ExtensionObject(encodeables[ii]);
                        }

                        m_value = extensions;
                        return;
                    }

                    m_value = array;
                    return;
                }

                // convert objects to variants objects.
                case BuiltInType.Variant:
                {
                    object[] objects = array as object[];

                    if (objects != null)
                    {
                        Variant[] variants = new Variant[objects.Length];

                        for (int ii = 0; ii < objects.Length; ii++)
                        {
                            variants[ii] = new Variant(objects[ii]);
                        }

                        m_value = variants;
                        return;
                    }

                    m_value = array;
                    return;
                }

                // just save the value.
                default:
                {
                    m_value = array;
                    return;
                }
            }
        }

        /// <summary>
        /// Initializes the object with a collection.
        /// </summary>
        private void SetList(IList value, TypeInfo typeInfo)
        {
            m_typeInfo = typeInfo;

            Array array = TypeInfo.CreateArray(typeInfo.BuiltInType, value.Count);

            for (int ii = 0; ii < value.Count; ii++)
            {
                if (typeInfo.BuiltInType == BuiltInType.ExtensionObject)
                {
                    IEncodeable encodeable = value[ii] as IEncodeable;

                    if (encodeable != null)
                    {
                        array.SetValue(new ExtensionObject(encodeable), ii);
                        continue;
                    }
                }

                array.SetValue(value[ii], ii);
            }

            SetArray(array, typeInfo);
        }

        /// <summary>
        /// Initializes the object with an object.
        /// </summary>
        private void Set(object value, TypeInfo typeInfo)
        {
            // check for null values.
            if (value == null)
            {
                m_value = null;
                m_typeInfo = typeInfo;
                return;
            }

            // handle scalar values.
            if (typeInfo.ValueRank < 0)
            {
                SetScalar(value, typeInfo);
                return;
            }

            Array array = value as Array;

            // handle one dimensional arrays.
            if (typeInfo.ValueRank <= 1)
            {
                // handle arrays.
                if (array != null)
                {
                    SetArray(array, typeInfo);
                    return;
                }

                // handle lists.
                IList list = value as IList;

                if (list != null)
                {
                    SetList(list, typeInfo);
                    return;
                }
            }

            // handle multidimensional array.
            if (array != null)
            {
                m_value = new Matrix(array, typeInfo.BuiltInType);
                m_typeInfo = typeInfo;
                return;
            }

            // handle matrix.
            Matrix matrix = value as Matrix;

            if (matrix != null)
            {
                m_value = matrix;
                m_typeInfo = matrix.TypeInfo;
                return;
            }

            // not supported.
            throw new ServiceResultException(
                   StatusCodes.BadNotSupported,
                   Utils.Format("Arrays of the type '{0}' cannot be stored in a Variant object.", value.GetType().FullName));
        }
        #endregion

        #region Private Members
        private object m_value;
        private TypeInfo m_typeInfo;
        #endregion
    }

    #region VariantCollection Class
    /// <summary>
    /// A collection of Variant objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfVariant", Namespace = Namespaces.OpcUaXsd, ItemName = "Variant")]
    public partial class VariantCollection : List<Variant>
    {
        /// <summary>
        /// Initializes an empty collection.
        /// </summary>
        public VariantCollection() { }

        /// <summary>
        /// Initializes the collection from another collection.
        /// </summary>
        /// <remarks>
        /// Provides a strongly-typed collection of <see cref="Variant"/> objects.
        /// </remarks>
        public VariantCollection(IEnumerable<Variant> collection) : base(collection) { }

        /// <summary>
        /// Initializes the collection with the specified capacity.
        /// </summary>
        /// <remarks>
        /// Initializes the collection with the specified capacity.
        /// </remarks>
        /// <param name="capacity">The capacity to constrain the collection to</param>
        public VariantCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <remarks>
        /// Converts an array of <see cref="Variant"/> to a collection.
        /// </remarks>
        /// <param name="values">An array of <see cref="Variant"/> to convert to a collection</param>
        public static VariantCollection ToVariantCollection(Variant[] values)
        {
            if (values != null)
            {
                return new VariantCollection(values);
            }

            return new VariantCollection();
        }

        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <remarks>
        /// Converts an array of <see cref="Variant"/> to a collection.
        /// </remarks>
        /// <param name="values">An array of <see cref="Variant"/> to convert to a collection</param>
        public static implicit operator VariantCollection(Variant[] values)
        {
            return ToVariantCollection(values);
        }

        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        /// <remarks>
        /// Creates a deep copy of the collection.
        /// </remarks>
        public new object MemberwiseClone()
        {
            VariantCollection clone = new VariantCollection(this.Count);

            foreach (Variant element in this)
            {
                clone.Add((Variant)Utils.Clone(element));
            }

            return clone;
        }
    }//class
    #endregion

    /// <summary>
    /// Wraps a multi-dimensional array for use within a Variant.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class Matrix : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Initializes the matrix with a multidimensional array.
        /// </summary>
        public Matrix(Array value, BuiltInType builtInType)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            m_elements = value;
            m_dimensions = new int[value.Rank];

            for (int ii = 0; ii < m_dimensions.Length; ii++)
            {
                m_dimensions[ii] = value.GetLength(ii);
            }

            m_elements = Utils.FlattenArray(value);
            m_typeInfo = new TypeInfo(builtInType, m_dimensions.Length);

#if DEBUG
            TypeInfo sanityCheck = TypeInfo.Construct(m_elements);
            System.Diagnostics.Debug.Assert(sanityCheck.BuiltInType == builtInType || (sanityCheck.BuiltInType == BuiltInType.ByteString && builtInType == BuiltInType.Byte));
#endif
        }

        /// <summary>
        /// Initializes the matrix with a one dimensional array and a list of dimensions.
        /// </summary>
        public Matrix(Array elements, BuiltInType builtInType, params int[] dimensions)
        {
            if (elements == null) throw new ArgumentNullException(nameof(elements));

            m_elements = elements;
            m_dimensions = dimensions;

            if (dimensions != null && dimensions.Length > 0)
            {
                int length = 1;

                for (int ii = 0; ii < dimensions.Length; ii++)
                {
                    length *= dimensions[ii];
                }

                if (length != elements.Length)
                {
                    throw new ArgumentException("The number of elements in the array does not match the dimensions.");
                }
            }
            else
            {
                m_dimensions = new int[] { elements.Length };
            }

            m_typeInfo = new TypeInfo(builtInType, m_dimensions.Length);

#if DEBUG
            TypeInfo sanityCheck = TypeInfo.Construct(m_elements);
            System.Diagnostics.Debug.Assert(sanityCheck.BuiltInType == builtInType ||
                (sanityCheck.BuiltInType == BuiltInType.Int32 && builtInType == BuiltInType.Enumeration) ||
                (sanityCheck.BuiltInType == BuiltInType.ByteString && builtInType == BuiltInType.Byte) ||
                (builtInType == BuiltInType.Variant));
#endif
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The elements of the matrix.
        /// </summary>
        /// <value>An array of elements.</value>
        public Array Elements => m_elements;

        /// <summary>
        /// The dimensions of the matrix.
        /// </summary>
        /// <value>The dimensions of the array.</value>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays")]
        public int[] Dimensions => m_dimensions;

        /// <summary>
        /// The type information for the matrix.
        /// </summary>
        /// <value>The type information.</value>
        public TypeInfo TypeInfo => m_typeInfo;

        /// <summary>
        /// Returns the flattened array as a multi-dimensional array.
        /// </summary>
        public Array ToArray()
        {
            Array array = Array.CreateInstance(m_elements.GetType().GetElementType(), m_dimensions);

            int[] indexes = new int[m_dimensions.Length];

            for (int ii = 0; ii < m_elements.Length; ii++)
            {
                array.SetValue(m_elements.GetValue(ii), indexes);

                for (int jj = indexes.Length - 1; jj >= 0; jj--)
                {
                    indexes[jj]++;

                    if (indexes[jj] < m_dimensions[jj])
                    {
                        break;
                    }

                    indexes[jj] = 0;
                }
            }

            return array;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Determines if the specified object is equal to the object.
        /// </summary>
        /// <remarks>
        /// Determines if the specified object is equal to the object.
        /// </remarks>
        public override bool Equals(object obj)
        {
            if (Object.ReferenceEquals(this, obj))
            {
                return true;
            }

            Matrix matrix = obj as Matrix;

            if (matrix != null)
            {
                if (!m_typeInfo.Equals(matrix.TypeInfo))
                {
                    return false;
                }
                if (!Utils.IsEqual(m_dimensions, matrix.Dimensions))
                {
                    return false;
                }
                return Utils.IsEqual(m_elements, matrix.Elements);
            }

            return false;
        }

        /// <summary>
        /// Returns a unique hashcode for the object.
        /// </summary>
        public override int GetHashCode()
        {
            if (m_elements != null)
            {
                return m_elements.GetHashCode();
            }
            if (m_typeInfo != null)
            {
                return m_typeInfo.GetHashCode();
            }
            if (m_dimensions != null)
            {
                return m_dimensions.GetHashCode();
            }
            return base.GetHashCode();
        }
        #endregion

        #region IFormattable Members
        /// <summary>
        /// Returns the string representation of the object.
        /// </summary>
        /// <param name="format">(Unused) Always pass a NULL value</param>
        /// <param name="formatProvider">The format-provider to use. If unsure, pass an empty string or null</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        /// <remarks>
        /// Returns the string representation of the object.
        /// </remarks>
        /// <exception cref="FormatException">Thrown when the 'format' argument is NOT null.</exception>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                StringBuilder buffer = new StringBuilder();

                buffer.AppendFormat("{0}[", m_elements.GetType().GetElementType().Name);

                for (int ii = 0; ii < m_dimensions.Length; ii++)
                {
                    if (ii > 0)
                    {
                        buffer.Append(",");
                    }

                    buffer.AppendFormat(formatProvider, "{0}", m_dimensions[ii]);
                }

                buffer.AppendFormat(formatProvider, "]");

                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region ICloneable Members
        /// <summary>
        /// Makes a deep copy of the object.
        /// </summary>
        /// <returns>
        /// A new object that is a copy of this instance.
        /// </returns>
        public new object MemberwiseClone()
        {
            return new Matrix((Array)Utils.Clone(m_elements), m_typeInfo.BuiltInType, (int[])Utils.Clone(m_dimensions));
        }
        #endregion

        #region Private Fields
        private Array m_elements;
        private int[] m_dimensions;
        private TypeInfo m_typeInfo;
        #endregion
    }

}//namespace

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// A structure that could contain value with any of the UA built-in data types.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The Variant is described in <b>Part 6 - Mappings, Section 6.2.2.15</b>, titled <b>Variant</b>
    /// <br/></para>
    /// <para>
    /// Variant is a data type in COM, but not within the .NET Framework. Therefore OPC UA has its own
    /// Variant type that supports all of the OPC UA data-types.
    /// <br/></para>
    /// </remarks>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public partial struct Variant : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Creates a deep copy of the value.
        /// </summary>
        /// <remarks>
        /// Creates a new Variant instance, while deep-copying the contents of the specified Variant
        /// </remarks>
        /// <param name="value">The Variant value to copy.</param>
        public Variant(Variant value)
        {
            m_value = Utils.Clone(value.m_value);
            m_typeInfo = value.m_typeInfo;
        }

        /// <summary>
        /// Constructs a Variant
        /// </summary>
        /// <param name="value">The value to store.</param>
        /// <param name="typeInfo">The type information for the value.</param>
        public Variant(object value, TypeInfo typeInfo)
        {
            m_value = null;
            m_typeInfo = typeInfo;
            Set(value, typeInfo);

#if DEBUG

            TypeInfo sanityCheck = TypeInfo.Construct(m_value);

            // except special case byte array vs. bytestring
            if (sanityCheck.BuiltInType == BuiltInType.ByteString &&
                sanityCheck.ValueRank == ValueRanks.Scalar &&
                typeInfo.BuiltInType == BuiltInType.Byte &&
                typeInfo.ValueRank == ValueRanks.OneDimension)
            {
                return;
            }

            // An enumeration can contain Int32
            if (sanityCheck.BuiltInType == BuiltInType.Int32 &&
                typeInfo.BuiltInType == BuiltInType.Enumeration)
            {
                return;
            }

            System.Diagnostics.Debug.Assert(
                sanityCheck.BuiltInType == m_typeInfo.BuiltInType,
                Utils.Format("{0} != {1}",
                sanityCheck.BuiltInType,
                typeInfo.BuiltInType));

            System.Diagnostics.Debug.Assert(
                sanityCheck.ValueRank == m_typeInfo.ValueRank,
                Utils.Format("{0} != {1}",
                sanityCheck.ValueRank,
                typeInfo.ValueRank));

#endif
        }

        /// <summary>
        /// Initializes the object with an object value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant instance while specifying the value.
        /// </remarks>
        /// <param name="value">The value to encode within the variant</param>
        public Variant(object value)
        {
            m_value = null;
            m_typeInfo = TypeInfo.Construct(value);
            Set(value, m_typeInfo);
        }

        /// <summary>
        /// Initializes the variant with matrix.
        /// </summary>
        /// <param name="value">The value to store within the variant</param>
        public Variant(Matrix value)
        {
            m_value = value;
            m_typeInfo = value.TypeInfo;
        }

        /// <summary>
        /// Initializes the object with a bool value.
        /// </summary>
        /// <remarks>
        /// Creates a new Variant with a Boolean value.
        /// </remarks>
        /// <param name="value">The value of the variant</param>
        public Variant(bool value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Boolean;
        }

        /// <summary>
        /// Initializes the object with a sbyte value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="sbyte"/> value
        /// </remarks>
        /// <param name="value">The <see cref="sbyte"/> value of the Variant</param>
        public Variant(sbyte value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.SByte;
        }

        /// <summary>
        /// Initializes the object with a byte value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="byte"/> value
        /// </remarks>
        /// <param name="value">The <see cref="byte"/> value of the Variant</param>
        public Variant(byte value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Byte;
        }

        /// <summary>
        /// Initializes the object with a short value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="short"/> value
        /// </remarks>
        /// <param name="value">The <see cref="short"/> value of the Variant</param>
        public Variant(short value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int16;
        }

        /// <summary>
        /// Initializes the object with a ushort value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ushort"/> value
        /// </remarks>
        /// <param name="value">The <see cref="ushort"/> value of the Variant</param>
        public Variant(ushort value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt16;
        }

        /// <summary>
        /// Initializes the object with an int value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="int"/> value
        /// </remarks>
        /// <param name="value">The <see cref="int"/> value of the Variant</param>
        public Variant(int value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int32;
        }

        /// <summary>
        /// Initializes the object with a uint value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="uint"/> value
        /// </remarks>
        /// <param name="value">The <see cref="uint"/> value of the Variant</param>
        public Variant(uint value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt32;
        }

        /// <summary>
        /// Initializes the object with a long value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="long"/> value
        /// </remarks>
        /// <param name="value">The <see cref="long"/> value of the Variant</param>
        public Variant(long value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int64;
        }

        /// <summary>
        /// Initializes the object with a ulong value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ulong"/> value
        /// </remarks>
        /// <param name="value">The <see cref="ulong"/> value of the Variant</param>
        public Variant(ulong value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt64;
        }

        /// <summary>
        /// Initializes the object with a float value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="float"/> value
        /// </remarks>
        /// <param name="value">The <see cref="float"/> value of the Variant</param>
        public Variant(float value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Float;
        }

        /// <summary>
        /// Initializes the object with a double value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="double"/> value
        /// </remarks>
        /// <param name="value">The <see cref="double"/> value of the Variant</param>
        public Variant(double value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Double;
        }

        /// <summary>
        /// Initializes the object with a string value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="string"/> value
        /// </remarks>
        /// <param name="value">The <see cref="string"/> value of the Variant</param>
        public Variant(string value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.String;
        }

        /// <summary>
        /// Initializes the object with a DateTime value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="DateTime"/> value
        /// </remarks>
        /// <param name="value">The <see cref="DateTime"/> value of the Variant</param>
        public Variant(DateTime value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.DateTime;
        }

        /// <summary>
        /// Initializes the object with a Guid value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="Guid"/> value
        /// </remarks>
        /// <param name="value">The <see cref="Guid"/> value of the Variant</param>
        public Variant(Guid value)
        {
            m_value = new Uuid(value);
            m_typeInfo = TypeInfo.Scalars.Guid;
        }

        /// <summary>
        /// Initializes the object with a Uuid value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="Uuid"/> value
        /// </remarks>
        /// <param name="value">The <see cref="Uuid"/> value of the Variant</param>
        public Variant(Uuid value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Guid;
        }

        /// <summary>
        /// Initializes the object with a byte[] value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="byte"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="byte"/>-array value of the Variant</param>
        public Variant(byte[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ByteString;
        }

        /// <summary>
        /// Initializes the object with a XmlElement value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="XmlElement"/> value
        /// </remarks>
        /// <param name="value">The <see cref="XmlElement"/> value of the Variant</param>
        public Variant(XmlElement value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.XmlElement;
        }

        /// <summary>
        /// Initializes the object with a NodeId value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="NodeId"/> value
        /// </remarks>
        /// <param name="value">The <see cref="NodeId"/> value of the Variant</param>
        public Variant(NodeId value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.NodeId;
        }

        /// <summary>
        /// Initializes the object with a ExpandedNodeId value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ExpandedNodeId"/> value
        /// </remarks>
        /// <param name="value">The <see cref="ExpandedNodeId"/> value of the Variant</param>
        public Variant(ExpandedNodeId value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ExpandedNodeId;
        }

        /// <summary>
        /// Initializes the object with a StatusCode value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="StatusCode"/> value
        /// </remarks>
        /// <param name="value">The <see cref="StatusCode"/> value of the Variant</param>
        public Variant(StatusCode value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.StatusCode;
        }

        /// <summary>
        /// Initializes the object with a QualifiedName value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="QualifiedName"/> value
        /// </remarks>
        /// <param name="value">The <see cref="QualifiedName"/> value of the Variant</param>
        public Variant(QualifiedName value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.QualifiedName;
        }

        /// <summary>
        /// Initializes the object with a LocalizedText value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="LocalizedText"/> value
        /// </remarks>
        /// <param name="value">The <see cref="LocalizedText"/> value of the Variant</param>
        public Variant(LocalizedText value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.LocalizedText;
        }

        /// <summary>
        /// Initializes the object with a ExtensionObject value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ExtensionObject"/> value
        /// </remarks>
        /// <param name="value">The <see cref="ExtensionObject"/> value of the Variant</param>
        public Variant(ExtensionObject value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ExtensionObject;
        }

        /// <summary>
        /// Initializes the object with a DataValue value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="DataValue"/> value
        /// </remarks>
        /// <param name="value">The <see cref="DataValue"/> value of the Variant</param>
        public Variant(DataValue value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.DataValue;
        }

        /// <summary>
        /// Initializes the object with a bool array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="bool"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="bool"/>-array value of the Variant</param>
        public Variant(bool[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Boolean;
        }

        /// <summary>
        /// Initializes the object with a sbyte array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="sbyte"/>-arrat value
        /// </remarks>
        /// <param name="value">The <see cref="sbyte"/>-array value of the Variant</param>
        public Variant(sbyte[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.SByte;
        }

        /// <summary>
        /// Initializes the object with a short array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="short"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="short"/>-array value of the Variant</param>
        public Variant(short[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int16;
        }

        /// <summary>
        /// Initializes the object with a ushort array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ushort"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="ushort"/>-array value of the Variant</param>
        public Variant(ushort[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt16;
        }

        /// <summary>
        /// Initializes the object with an int array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="int"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="int"/>-array value of the Variant</param>
        public Variant(int[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int32;
        }

        /// <summary>
        /// Initializes the object with a uint array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="uint"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="uint"/>-array value of the Variant</param>
        public Variant(uint[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt32;
        }

        /// <summary>
        /// Initializes the object with a long array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="long"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="long"/>-array value of the Variant</param>
        public Variant(long[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int64;
        }

        /// <summary>
        /// Initializes the object with a ulong array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ulong"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="ulong"/>-array value of the Variant</param>
        public Variant(ulong[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt64;
        }

        /// <summary>
        /// Initializes the object with a float array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="float"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="float"/>-array value of the Variant</param>
        public Variant(float[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Float;
        }

        /// <summary>
        /// Initializes the object with a double array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="double"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="double"/>-array value of the Variant</param>
        public Variant(double[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Double;
        }

        /// <summary>
        /// Initializes the object with a string array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="string"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="string"/>-array value of the Variant</param>
        public Variant(string[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.String;
        }

        /// <summary>
        /// Initializes the object with a DateTime array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="DateTime"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="DateTime"/>-array value of the Variant</param>
        public Variant(DateTime[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.DateTime;
        }

        /// <summary>
        /// Initializes the object with a Guid array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="Guid"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="Guid"/>-array value of the Variant</param>
        public Variant(Guid[] value)
        {
            m_value = null;
            m_typeInfo = TypeInfo.Arrays.Guid;
            Set(value);
        }

        /// <summary>
        /// Initializes the object with a Uuid array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="Uuid"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="Uuid"/>-array value of the Variant</param>
        public Variant(Uuid[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Guid;
        }

        /// <summary>
        /// Initializes the object with a byte[] array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a 2-d <see cref="byte"/>-array value
        /// </remarks>
        /// <param name="value">The 2-d <see cref="byte"/>-array value of the Variant</param>
        public Variant(byte[][] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ByteString;
        }

        /// <summary>
        /// Initializes the object with a XmlElement array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="XmlElement"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="XmlElement"/>-array value of the Variant</param>
        public Variant(XmlElement[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.XmlElement;
        }

        /// <summary>
        /// Initializes the object with a NodeId array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="NodeId"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="NodeId"/>-array value of the Variant</param>
        public Variant(NodeId[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.NodeId;
        }

        /// <summary>
        /// Initializes the object with a ExpandedNodeId array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ExpandedNodeId"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="ExpandedNodeId"/>-array value of the Variant</param>
        public Variant(ExpandedNodeId[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ExpandedNodeId;
        }

        /// <summary>
        /// Initializes the object with a StatusCode array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="StatusCode"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="StatusCode"/>-array value of the Variant</param>
        public Variant(StatusCode[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.StatusCode;
        }

        /// <summary>
        /// Initializes the object with a QualifiedName array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="QualifiedName"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="QualifiedName"/>-array value of the Variant</param>
        public Variant(QualifiedName[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.QualifiedName;
        }

        /// <summary>
        /// Initializes the object with a LocalizedText array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="LocalizedText"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="LocalizedText"/>-array value of the Variant</param>
        public Variant(LocalizedText[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.LocalizedText;
        }

        /// <summary>
        /// Initializes the object with a ExtensionObject array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="ExtensionObject"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="ExtensionObject"/>-array value of the Variant</param>
        public Variant(ExtensionObject[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ExtensionObject;
        }

        /// <summary>
        /// Initializes the object with a DataValue array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="DataValue"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="DataValue"/>-array value of the Variant</param>
        public Variant(DataValue[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.DataValue;
        }

        /// <summary>
        /// Initializes the object with a Variant array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="Variant"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="Variant"/>-array value of the Variant</param>
        public Variant(Variant[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Variant;
        }

        /// <summary>
        /// Initializes the object with a object array value.
        /// </summary>
        /// <remarks>
        /// Creates a new variant with a <see cref="object"/>-array value
        /// </remarks>
        /// <param name="value">The <see cref="object"/>-array value of the Variant</param>
        public Variant(object[] value)
        {
            m_value = null;
            m_typeInfo = TypeInfo.Arrays.Variant;
            Set(value);
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// The value stored in the object.
        /// </summary>
        /// <remarks>
        /// The value stored within the Variant object.
        /// </remarks>
        [DataMember(Name = "Value", Order = 1)]
        private XmlElement XmlEncodedValue
        {
            get
            {
                // create encoder.
                XmlEncoder encoder = new XmlEncoder(MessageContextExtension.CurrentContext);

                // write value.
                encoder.WriteVariantContents(m_value, m_typeInfo);

                // create document from encoder.
                XmlDocument document = new XmlDocument();
                document.InnerXml = encoder.Close();

                // return element.
                return document.DocumentElement;
            }

            set
            {
                // check for null values.
                if (value == null)
                {
                    m_value = null;
                    return;
                }

                TypeInfo typeInfo = null;

                // create decoder.
                XmlDecoder decoder = new XmlDecoder(value, MessageContextExtension.CurrentContext);

                try
                {
                    // read value.
                    object body = decoder.ReadVariantContents(out typeInfo);
                    Set(body, typeInfo);
                }
                catch (Exception e)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadDecodingError,
                        e,
                        "Error decoding Variant value.");
                }
                finally
                {
                    // close decoder.
                    decoder.Close();
                }
            }
        }

        /// <summary>
        /// The value stored in the object.
        /// </summary>
        /// <remarks>
        /// The value stored -as <see cref="Object"/>- within the Variant object.
        /// </remarks>
        public object Value
        {
            get { return m_value; }
            set { Set(value, TypeInfo.Construct(value)); }
        }

        /// <summary>
        /// The type information for the matrix.
        /// </summary>
        public TypeInfo TypeInfo => m_typeInfo;
        #endregion

        #region IFormattable Members
        /// <summary>
        /// Returns the string representation of the object.
        /// </summary>
        /// <remarks>
        /// Returns the string representation of the object.
        /// </remarks>
        /// <exception cref="FormatException">Thrown when the 'format' argument is NOT null.</exception>
        /// <param name="format">(Unused) Always pass a NULL value</param>
        /// <param name="formatProvider">The format-provider to use. If unsure, pass an empty string or null</param>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                StringBuilder buffer = new StringBuilder();
                AppendFormat(buffer, m_value, formatProvider);
                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }

        /// <summary>
        /// Formats a value as a string.
        /// </summary>
        private void AppendFormat(StringBuilder buffer, object value, IFormatProvider formatProvider)
        {
            // check for null.
            if (value == null || m_typeInfo == null)
            {
                buffer.Append("(null)");
                return;
            }

            // convert byte string to hexstring.
            if (m_typeInfo.BuiltInType == BuiltInType.ByteString && m_typeInfo.ValueRank < 0)
            {
                byte[] bytes = (byte[])value;

                for (int ii = 0; ii < bytes.Length; ii++)
                {
                    buffer.AppendFormat(formatProvider, "{0:X2}", bytes[ii]);
                }

                return;
            }

            // convert XML element to string.
            if (m_typeInfo.BuiltInType == BuiltInType.XmlElement && m_typeInfo.ValueRank < 0)
            {
                XmlElement xml = (XmlElement)value;
                buffer.AppendFormat(formatProvider, "{0}", xml.OuterXml);
                return;
            }

            // recusrively write individual elements of an array.

            if (value is Array array && m_typeInfo.ValueRank <= 1)
            {
                buffer.Append("{");

                if (array.Length > 0)
                {
                    AppendFormat(buffer, array.GetValue(0), formatProvider);
                }

                for (int ii = 1; ii < array.Length; ii++)
                {
                    buffer.Append(" |");
                    AppendFormat(buffer, array.GetValue(ii), formatProvider);
                }

                buffer.Append("}");
                return;
            }

            // let the object format itself.
            buffer.AppendFormat(formatProvider, "{0}", value);
        }
        #endregion

        #region ICloneable Members
        /// <summary>
        /// Makes a deep copy of the object.
        /// </summary>
        /// <remarks>
        /// Makes a deep copy of the object.
        /// </remarks>
        public new object MemberwiseClone()
        {
            return new Variant(Utils.Clone(this.Value));
        }
        #endregion

        #region Static Operators
        /// <summary>
        /// Returns true if the objects are not equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are not equal.
        /// </remarks>
        public static bool operator ==(Variant a, Variant b)
        {
            return a.Equals(b);
        }

        /// <summary>
        /// Returns true if the objects are not equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are not equal.
        /// </remarks>
        public static bool operator !=(Variant a, Variant b)
        {
            return !a.Equals(b);
        }

        /// <summary>
        /// Converts a bool value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a bool value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(bool value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a sbyte value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a sbyte value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(sbyte value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a byte value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a byte value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(byte value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a short value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a short value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(short value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ushort value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ushort value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ushort value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a int value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a int value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(int value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a uint value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a uint value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(uint value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a long value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a long value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(long value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ulong value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ulong value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ulong value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a float value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a float value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(float value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a double value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a double value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(double value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a string value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a string value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(string value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a DateTime value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a DateTime value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(DateTime value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a Guid value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a Guid value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(Guid value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a Uuid value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a Uuid value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(Uuid value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a byte[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a byte[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(byte[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a XmlElement value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a XmlElement value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(XmlElement value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a NodeId value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a NodeId value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(NodeId value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ExpandedNodeId value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ExpandedNodeId value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ExpandedNodeId value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a StatusCode value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a StatusCode value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(StatusCode value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a QualifiedName value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a QualifiedName value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(QualifiedName value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a LocalizedText value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a LocalizedText value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(LocalizedText value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ExtensionObject value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ExtensionObject value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ExtensionObject value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a DataValue value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a DataValue value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(DataValue value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a bool[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a bool[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(bool[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a sbyte[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a sbyte[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(sbyte[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a short[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a short[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(short[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ushort[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ushort[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ushort[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a int[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a int[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(int[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a uint[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a uint[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(uint[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a long[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a long[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(long[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ulong[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ulong[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ulong[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a float[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a float[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(float[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a double[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a double[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(double[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a string []value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a string []value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(string[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a DateTime[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a DateTime[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(DateTime[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a Guid[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a Guid[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(Guid[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a Uuid[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a Uuid[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(Uuid[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a byte[][] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a byte[][] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(byte[][] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a XmlElement[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a XmlElement[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(XmlElement[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a NodeId[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a NodeId[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(NodeId[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ExpandedNodeId[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ExpandedNodeId[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ExpandedNodeId[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a StatusCode[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a StatusCode[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(StatusCode[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a QualifiedName[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a QualifiedName[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(QualifiedName[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a LocalizedText[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a LocalizedText[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(LocalizedText[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a ExtensionObject[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a ExtensionObject[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(ExtensionObject[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a DataValue[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a DataValue[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(DataValue[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a Variant[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a Variant[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(Variant[] value)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Converts a object[] value to an Variant object.
        /// </summary>
        /// <remarks>
        /// Converts a object[] value to an Variant object.
        /// </remarks>
        public static implicit operator Variant(object[] value)
        {
            return new Variant(value);
        }
        #endregion

        #region Static Fields
        /// <summary>
        /// An constant containing a null Variant structure.
        /// </summary>
        /// <remarks>
        /// An constant containing a null Variant structure.
        /// </remarks>
        public static readonly Variant Null = new Variant();
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Determines if the specified object is equal to the object.
        /// </summary>
        /// <remarks>
        /// Determines if the specified object is equal to the object.
        /// </remarks>
        public override bool Equals(object obj)
        {
            if (Object.ReferenceEquals(this, obj))
            {
                return true;
            }

            if (obj is Variant? variant)
            {
                return Utils.IsEqual(m_value, variant.Value.m_value);
            }

            return false;
        }

        /// <summary>
        /// Returns a unique hashcode for the object.
        /// </summary>
        public override int GetHashCode()
        {
            if (this.m_value != null)
            {
                return m_value.GetHashCode();
            }

            return 0;
        }

        /// <summary>
        /// Converts the value to a human readable string.
        /// </summary>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Initializes the object with a bool value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="bool"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="bool"/> value to set this Variant to</param>
        public void Set(bool value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Boolean;
        }

        /// <summary>
        /// Initializes the object with a sbyte value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="sbyte"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="sbyte"/> value to set this Variant to</param>
        public void Set(sbyte value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.SByte;
        }

        /// <summary>
        /// Initializes the object with a byte value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="byte"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="byte"/> value to set this Variant to</param>
        public void Set(byte value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Byte;
        }

        /// <summary>
        /// Initializes the object with a short value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="short"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="short"/> value to set this Variant to</param>
        public void Set(short value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int16;
        }

        /// <summary>
        /// Initializes the object with a ushort value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ushort"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="ushort"/> value to set this Variant to</param>
        public void Set(ushort value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt16;
        }

        /// <summary>
        /// Initializes the object with an int value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="int"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="int"/> value to set this Variant to</param>
        public void Set(int value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int32;
        }

        /// <summary>
        /// Initializes the object with a uint value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="uint"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="uint"/> value to set this Variant to</param>
        public void Set(uint value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt32;
        }

        /// <summary>
        /// Initializes the object with a long value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="long"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="long"/> value to set this Variant to</param>
        public void Set(long value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Int64;
        }

        /// <summary>
        /// Initializes the object with a ulong value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ulong"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="ulong"/> value to set this Variant to</param>
        public void Set(ulong value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.UInt64;
        }

        /// <summary>
        /// Initializes the object with a float value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="float"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="float"/> value to set this Variant to</param>
        public void Set(float value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Float;
        }

        /// <summary>
        /// Initializes the object with a double value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="double"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="double"/> value to set this Variant to</param>
        public void Set(double value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Double;
        }

        /// <summary>
        /// Initializes the object with a string value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="string"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="string"/> value to set this Variant to</param>
        public void Set(string value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.String;
        }

        /// <summary>
        /// Initializes the object with a DateTime value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="DateTime"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="DateTime"/> value to set this Variant to</param>
        public void Set(DateTime value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.DateTime;
        }

        /// <summary>
        /// Initializes the object with a Guid value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="Guid"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="Guid"/> value to set this Variant to</param>
        public void Set(Guid value)
        {
            m_value = new Uuid(value);
            m_typeInfo = TypeInfo.Scalars.Guid;
        }

        /// <summary>
        /// Initializes the object with a Uuid value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="Uuid"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="Uuid"/> value to set this Variant to</param>
        public void Set(Uuid value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.Guid;
        }

        /// <summary>
        /// Initializes the object with a byte[] value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="byte"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="byte"/>-array value to set this Variant to</param>
        public void Set(byte[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ByteString;
        }

        /// <summary>
        /// Initializes the object with a XmlElement value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="XmlElement"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="XmlElement"/> value to set this Variant to</param>
        public void Set(XmlElement value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.XmlElement;
        }

        /// <summary>
        /// Initializes the object with a NodeId value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="NodeId"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="NodeId"/> value to set this Variant to</param>
        public void Set(NodeId value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.NodeId;
        }

        /// <summary>
        /// Initializes the object with a ExpandedNodeId value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ExpandedNodeId"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="ExpandedNodeId"/> value to set this Variant to</param>
        public void Set(ExpandedNodeId value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ExpandedNodeId;
        }

        /// <summary>
        /// Initializes the object with a StatusCode value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="StatusCode"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="StatusCode"/> value to set this Variant to</param>
        public void Set(StatusCode value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.StatusCode;
        }

        /// <summary>
        /// Initializes the object with a QualifiedName value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="QualifiedName"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="QualifiedName"/> value to set this Variant to</param>
        public void Set(QualifiedName value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.QualifiedName;
        }

        /// <summary>
        /// Initializes the object with a LocalizedText value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="LocalizedText"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="LocalizedText"/> value to set this Variant to</param>
        public void Set(LocalizedText value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.LocalizedText;
        }

        /// <summary>
        /// Initializes the object with a ExtensionObject value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ExtensionObject"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="ExtensionObject"/> value to set this Variant to</param>
        public void Set(ExtensionObject value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.ExtensionObject;
        }

        /// <summary>
        /// Initializes the object with a DataValue value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="DataValue"/> value.
        /// </remarks>
        /// <param name="value">The <see cref="DataValue"/> value to set this Variant to</param>
        public void Set(DataValue value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Scalars.DataValue;
        }

        /// <summary>
        /// Initializes the object with a bool array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="bool"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="bool"/>-array value to set this Variant to</param>
        public void Set(bool[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Boolean;
        }

        /// <summary>
        /// Initializes the object with a sbyte array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="sbyte"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="sbyte"/>-array value to set this Variant to</param>
        public void Set(sbyte[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.SByte;
        }

        /// <summary>
        /// Initializes the object with a short array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="short"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="short"/>-array value to set this Variant to</param>
        public void Set(short[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int16;
        }

        /// <summary>
        /// Initializes the object with a ushort array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ushort"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="ushort"/>-array value to set this Variant to</param>
        public void Set(ushort[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt16;
        }

        /// <summary>
        /// Initializes the object with an int array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="int"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="int"/>-array value to set this Variant to</param>
        public void Set(int[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int32;
        }

        /// <summary>
        /// Initializes the object with a uint array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="uint"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="uint"/>-array value to set this Variant to</param>
        public void Set(uint[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt32;
        }

        /// <summary>
        /// Initializes the object with a long array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="long"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="long"/>-array value to set this Variant to</param>
        public void Set(long[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Int64;
        }

        /// <summary>
        /// Initializes the object with a ulong array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ulong"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="ulong"/>-array value to set this Variant to</param>
        public void Set(ulong[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.UInt64;
        }

        /// <summary>
        /// Initializes the object with a float array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="float"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="float"/>-array value to set this Variant to</param>
        public void Set(float[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Float;
        }

        /// <summary>
        /// Initializes the object with a double array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="double"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="double"/>-array value to set this Variant to</param>
        public void Set(double[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Double;
        }

        /// <summary>
        /// Initializes the object with a string array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="string"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="string"/>-array value to set this Variant to</param>
        public void Set(string[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.String;
        }

        /// <summary>
        /// Initializes the object with a DateTime array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="DateTime"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="DateTime"/>-array value to set this Variant to</param>
        public void Set(DateTime[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.DateTime;
        }

        /// <summary>
        /// Initializes the object with a Guid array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="Guid"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="Guid"/>-array value to set this Variant to</param>
        public void Set(Guid[] value)
        {
            m_value = null;

            if (value != null)
            {
                Uuid[] uuids = new Uuid[value.Length];

                for (int ii = 0; ii < value.Length; ii++)
                {
                    uuids[ii] = new Uuid(value[ii]);
                }

                m_value = uuids;
            }

            m_typeInfo = TypeInfo.Arrays.Guid;
        }

        /// <summary>
        /// Initializes the object with a Uuid array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="Uuid"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="Uuid"/>-array value to set this Variant to</param>
        public void Set(Uuid[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Guid;
        }

        /// <summary>
        /// Initializes the object with a byte[] array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a 2-d <see cref="byte"/>-array value.
        /// </remarks>
        /// <param name="value">The 2-d <see cref="byte"/>-array value to set this Variant to</param>
        public void Set(byte[][] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ByteString;
        }

        /// <summary>
        /// Initializes the object with a XmlElement array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="XmlElement"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="XmlElement"/>-array value to set this Variant to</param>
        public void Set(XmlElement[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.XmlElement;
        }

        /// <summary>
        /// Initializes the object with a NodeId array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="NodeId"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="NodeId"/>-array value to set this Variant to</param>
        public void Set(NodeId[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.NodeId;
        }

        /// <summary>
        /// Initializes the object with a ExpandedNodeId array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ExpandedNodeId"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="ExpandedNodeId"/>-array value to set this Variant to</param>
        public void Set(ExpandedNodeId[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ExpandedNodeId;
        }

        /// <summary>
        /// Initializes the object with a StatusCode array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="StatusCode"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="StatusCode"/>-array value to set this Variant to</param>
        public void Set(StatusCode[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.StatusCode;
        }

        /// <summary>
        /// Initializes the object with a QualifiedName array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="QualifiedName"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="QualifiedName"/>-array value to set this Variant to</param>
        public void Set(QualifiedName[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.QualifiedName;
        }

        /// <summary>
        /// Initializes the object with a LocalizedText array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="LocalizedText"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="LocalizedText"/>-array value to set this Variant to</param>
        public void Set(LocalizedText[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.LocalizedText;
        }

        /// <summary>
        /// Initializes the object with a ExtensionObject array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="ExtensionObject"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="ExtensionObject"/>-array value to set this Variant to</param>
        public void Set(ExtensionObject[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.ExtensionObject;
        }

        /// <summary>
        /// Initializes the object with a DataValue array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="DataValue"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="DataValue"/>-array value to set this Variant to</param>
        public void Set(DataValue[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.DataValue;
        }

        /// <summary>
        /// Initializes the object with a Variant array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="Variant"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="Variant"/>-array value to set this Variant to</param>
        public void Set(Variant[] value)
        {
            m_value = value;
            m_typeInfo = TypeInfo.Arrays.Variant;
        }

        /// <summary>
        /// Initializes the object with a object array value.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a <see cref="object"/>-array value.
        /// </remarks>
        /// <param name="value">The <see cref="object"/>-array value to set this Variant to</param>
        public void Set(object[] value)
        {
            m_value = null;

            if (value != null)
            {
                Variant[] anyValues = new Variant[value.Length];

                for (int ii = 0; ii < value.Length; ii++)
                {
                    anyValues[ii] = new Variant(value[ii]);
                }

                m_value = anyValues;
            }

            m_typeInfo = TypeInfo.Arrays.Variant;
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Stores a scalar value in the variant.
        /// </summary>
        private void SetScalar(object value, TypeInfo typeInfo)
        {
            m_typeInfo = typeInfo;

            switch (typeInfo.BuiltInType)
            {
                // handle special types that can be converted to something the variant supports.
                case BuiltInType.Null:
                {
                    // check for enumerated value.
                    if (value.GetType().GetTypeInfo().IsEnum)
                    {
                        Set(Convert.ToInt32(value, CultureInfo.InvariantCulture));
                        return;
                    }

                    // check for matrix

                    if (value is Matrix matrix)
                    {
                        m_value = matrix;
                        return;
                    }

                    // not supported.
                    throw new ServiceResultException(
                        StatusCodes.BadNotSupported,
                        Utils.Format("The type '{0}' cannot be stored in a Variant object.", value.GetType().FullName));
                }

                // convert Guids to Uuids.
                case BuiltInType.Guid:
                {
                    if (value is Guid? guid)
                    {
                        m_value = new Uuid(guid.Value);
                        return;
                    }

                    m_value = value;
                    return;
                }

                // convert encodeables to extension objects.
                case BuiltInType.ExtensionObject:
                {
                    if (value is IEncodeable encodeable)
                    {
                        m_value = new ExtensionObject(encodeable);
                        return;
                    }

                    m_value = value;
                    return;
                }

                // convert encodeables to extension objects.
                case BuiltInType.Variant:
                {
                    m_value = ((Variant)value).Value;
                    m_typeInfo = TypeInfo.Construct(m_value);
                    return;
                }

                // just save the value.
                default:
                {
                    m_value = value;
                    return;
                }
            }
        }

        /// <summary>
        /// Stores a on dimensional arrau value in the variant.
        /// </summary>
        private void SetArray(Array array, TypeInfo typeInfo)
        {
            m_typeInfo = typeInfo;

            switch (typeInfo.BuiltInType)
            {
                // handle special types that can be converted to something the variant supports.
                case BuiltInType.Null:
                {
                    // check for enumerated value.
                    if (array.GetType().GetElementType().GetTypeInfo().IsEnum)
                    {
                        int[] values = new int[array.Length];

                        for (int ii = 0; ii < array.Length; ii++)
                        {
                            values[ii] = Convert.ToInt32(array.GetValue(ii), CultureInfo.InvariantCulture);
                        }

                        m_value = values;
                        return;
                    }

                    // not supported.
                    throw new ServiceResultException(
                        StatusCodes.BadNotSupported,
                        Utils.Format("The type '{0}' cannot be stored in a Variant object.", array.GetType().FullName));
                }

                // convert Guids to Uuids.
                case BuiltInType.Guid:
                {
                    if (array is Guid[] guids)
                    {
                        Set(guids);
                        return;
                    }

                    m_value = array;
                    return;
                }

                // convert encodeables to extension objects.
                case BuiltInType.ExtensionObject:
                {
                    if (array is IEncodeable[] encodeables)
                    {
                        ExtensionObject[] extensions = new ExtensionObject[encodeables.Length];

                        for (int ii = 0; ii < encodeables.Length; ii++)
                        {
                            extensions[ii] = new ExtensionObject(encodeables[ii]);
                        }

                        m_value = extensions;
                        return;
                    }

                    m_value = array;
                    return;
                }

                // convert objects to variants objects.
                case BuiltInType.Variant:
                {
                    if (array is object[] objects)
                    {
                        Variant[] variants = new Variant[objects.Length];

                        for (int ii = 0; ii < objects.Length; ii++)
                        {
                            variants[ii] = new Variant(objects[ii]);
                        }

                        m_value = variants;
                        return;
                    }

                    m_value = array;
                    return;
                }

                // just save the value.
                default:
                {
                    m_value = array;
                    return;
                }
            }
        }

        /// <summary>
        /// Initializes the object with a collection.
        /// </summary>
        private void SetList(IList value, TypeInfo typeInfo)
        {
            m_typeInfo = typeInfo;

            Array array = TypeInfo.CreateArray(typeInfo.BuiltInType, value.Count);

            for (int ii = 0; ii < value.Count; ii++)
            {
                if (typeInfo.BuiltInType == BuiltInType.ExtensionObject)
                {
                    if (value[ii] is IEncodeable encodeable)
                    {
                        array.SetValue(new ExtensionObject(encodeable), ii);
                        continue;
                    }
                }

                array.SetValue(value[ii], ii);
            }

            SetArray(array, typeInfo);
        }

        /// <summary>
        /// Initializes the object with an object.
        /// </summary>
        private void Set(object value, TypeInfo typeInfo)
        {
            // check for null values.
            if (value == null)
            {
                m_value = null;
                m_typeInfo = typeInfo;
                return;
            }

            // handle scalar values.
            if (typeInfo.ValueRank < 0)
            {
                SetScalar(value, typeInfo);
                return;
            }

            // handle one dimensional arrays.
            if (typeInfo.ValueRank <= 1)
            {
                // handle arrays.
                if (value is Array array)
                {
                    SetArray(array, typeInfo);
                    return;
                }

                // handle lists.

                if (value is IList list)
                {
                    SetList(list, typeInfo);
                    return;
                }
            }

            // handle multidimensional array.
            if (value is Array array)
            {
                m_value = new Matrix(array, typeInfo.BuiltInType);
                m_typeInfo = typeInfo;
                return;
            }

            // handle matrix.

            if (value is Matrix matrix)
            {
                m_value = matrix;
                m_typeInfo = matrix.TypeInfo;
                return;
            }

            // not supported.
            throw new ServiceResultException(
                   StatusCodes.BadNotSupported,
                   Utils.Format("Arrays of the type '{0}' cannot be stored in a Variant object.", value.GetType().FullName));
        }
        #endregion

        #region Private Members
        private object m_value;
        private TypeInfo m_typeInfo;
        #endregion
    }

    #region VariantCollection Class
    /// <summary>
    /// A collection of Variant objects.
    /// </summary>
    [CollectionDataContract(Name = "ListOfVariant", Namespace = Namespaces.OpcUaXsd, ItemName = "Variant")]
    public partial class VariantCollection : List<Variant>
    {
        /// <summary>
        /// Initializes an empty collection.
        /// </summary>
        public VariantCollection() { }

        /// <summary>
        /// Initializes the collection from another collection.
        /// </summary>
        /// <remarks>
        /// Provides a strongly-typed collection of <see cref="Variant"/> objects.
        /// </remarks>
        public VariantCollection(IEnumerable<Variant> collection) : base(collection) { }

        /// <summary>
        /// Initializes the collection with the specified capacity.
        /// </summary>
        /// <remarks>
        /// Initializes the collection with the specified capacity.
        /// </remarks>
        /// <param name="capacity">The capacity to constrain the collection to</param>
        public VariantCollection(int capacity) : base(capacity) { }

        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <remarks>
        /// Converts an array of <see cref="Variant"/> to a collection.
        /// </remarks>
        /// <param name="values">An array of <see cref="Variant"/> to convert to a collection</param>
        public static VariantCollection ToVariantCollection(Variant[] values)
        {
            if (values != null)
            {
                return new VariantCollection(values);
            }

            return new VariantCollection();
        }

        /// <summary>
        /// Converts an array to a collection.
        /// </summary>
        /// <remarks>
        /// Converts an array of <see cref="Variant"/> to a collection.
        /// </remarks>
        /// <param name="values">An array of <see cref="Variant"/> to convert to a collection</param>
        public static implicit operator VariantCollection(Variant[] values)
        {
            return ToVariantCollection(values);
        }

        /// <summary>
        /// Creates a deep copy of the collection.
        /// </summary>
        /// <remarks>
        /// Creates a deep copy of the collection.
        /// </remarks>
        public new object MemberwiseClone()
        {
            VariantCollection clone = new VariantCollection(this.Count);

            foreach (Variant element in this)
            {
                clone.Add((Variant)Utils.Clone(element));
            }

            return clone;
        }
    }//class
    #endregion

    /// <summary>
    /// Wraps a multi-dimensional array for use within a Variant.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    public class Matrix : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Initializes the matrix with a multidimensional array.
        /// </summary>
        public Matrix(Array value, BuiltInType builtInType)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            m_elements = value;
            m_dimensions = new int[value.Rank];

            for (int ii = 0; ii < m_dimensions.Length; ii++)
            {
                m_dimensions[ii] = value.GetLength(ii);
            }

            m_elements = Utils.FlattenArray(value);
            m_typeInfo = new TypeInfo(builtInType, m_dimensions.Length);

#if DEBUG
            TypeInfo sanityCheck = TypeInfo.Construct(m_elements);
            System.Diagnostics.Debug.Assert(sanityCheck.BuiltInType == builtInType || (sanityCheck.BuiltInType == BuiltInType.ByteString && builtInType == BuiltInType.Byte));
#endif
        }

        /// <summary>
        /// Initializes the matrix with a one dimensional array and a list of dimensions.
        /// </summary>
        public Matrix(Array elements, BuiltInType builtInType, params int[] dimensions)
        {
            if (elements == null) throw new ArgumentNullException(nameof(elements));

            m_elements = elements;
            m_dimensions = dimensions;

            if (dimensions != null && dimensions.Length > 0)
            {
                int length = 1;

                for (int ii = 0; ii < dimensions.Length; ii++)
                {
                    length *= dimensions[ii];
                }

                if (length != elements.Length)
                {
                    throw new ArgumentException("The number of elements in the array does not match the dimensions.");
                }
            }
            else
            {
                m_dimensions = new int[] { elements.Length };
            }

            m_typeInfo = new TypeInfo(builtInType, m_dimensions.Length);

#if DEBUG
            TypeInfo sanityCheck = TypeInfo.Construct(m_elements);
            System.Diagnostics.Debug.Assert(sanityCheck.BuiltInType == builtInType ||
                (sanityCheck.BuiltInType == BuiltInType.Int32 && builtInType == BuiltInType.Enumeration) ||
                (sanityCheck.BuiltInType == BuiltInType.ByteString && builtInType == BuiltInType.Byte) ||
                (builtInType == BuiltInType.Variant));
#endif
        }
        #endregion

        #region Public Members
        /// <summary>
        /// The elements of the matrix.
        /// </summary>
        /// <value>An array of elements.</value>
        public Array Elements => m_elements;

        /// <summary>
        /// The dimensions of the matrix.
        /// </summary>
        /// <value>The dimensions of the array.</value>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1819:PropertiesShouldNotReturnArrays")]
        public int[] Dimensions => m_dimensions;

        /// <summary>
        /// The type information for the matrix.
        /// </summary>
        /// <value>The type information.</value>
        public TypeInfo TypeInfo => m_typeInfo;

        /// <summary>
        /// Returns the flattened array as a multi-dimensional array.
        /// </summary>
        public Array ToArray()
        {
            Array array = Array.CreateInstance(m_elements.GetType().GetElementType(), m_dimensions);

            int[] indexes = new int[m_dimensions.Length];

            for (int ii = 0; ii < m_elements.Length; ii++)
            {
                array.SetValue(m_elements.GetValue(ii), indexes);

                for (int jj = indexes.Length - 1; jj >= 0; jj--)
                {
                    indexes[jj]++;

                    if (indexes[jj] < m_dimensions[jj])
                    {
                        break;
                    }

                    indexes[jj] = 0;
                }
            }

            return array;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Determines if the specified object is equal to the object.
        /// </summary>
        /// <remarks>
        /// Determines if the specified object is equal to the object.
        /// </remarks>
        public override bool Equals(object obj)
        {
            if (Object.ReferenceEquals(this, obj))
            {
                return true;
            }

            if (obj is Matrix matrix)
            {
                if (!m_typeInfo.Equals(matrix.TypeInfo))
                {
                    return false;
                }
                if (!Utils.IsEqual(m_dimensions, matrix.Dimensions))
                {
                    return false;
                }
                return Utils.IsEqual(m_elements, matrix.Elements);
            }

            return false;
        }

        /// <summary>
        /// Returns a unique hashcode for the object.
        /// </summary>
        public override int GetHashCode()
        {
            if (m_elements != null)
            {
                return m_elements.GetHashCode();
            }
            if (m_typeInfo != null)
            {
                return m_typeInfo.GetHashCode();
            }
            if (m_dimensions != null)
            {
                return m_dimensions.GetHashCode();
            }
            return base.GetHashCode();
        }
        #endregion

        #region IFormattable Members
        /// <summary>
        /// Returns the string representation of the object.
        /// </summary>
        /// <param name="format">(Unused) Always pass a NULL value</param>
        /// <param name="formatProvider">The format-provider to use. If unsure, pass an empty string or null</param>
        /// <returns>
        /// A <see cref="T:System.String"/> containing the value of the current instance in the specified format.
        /// </returns>
        /// <remarks>
        /// Returns the string representation of the object.
        /// </remarks>
        /// <exception cref="FormatException">Thrown when the 'format' argument is NOT null.</exception>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                StringBuilder buffer = new StringBuilder();

                buffer.AppendFormat("{0}[", m_elements.GetType().GetElementType().Name);

                for (int ii = 0; ii < m_dimensions.Length; ii++)
                {
                    if (ii > 0)
                    {
                        buffer.Append(",");
                    }

                    buffer.AppendFormat(formatProvider, "{0}", m_dimensions[ii]);
                }

                buffer.AppendFormat(formatProvider, "]");

                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region ICloneable Members
        /// <summary>
        /// Makes a deep copy of the object.
        /// </summary>
        /// <returns>
        /// A new object that is a copy of this instance.
        /// </returns>
        public new object MemberwiseClone()
        {
            return new Matrix((Array)Utils.Clone(m_elements), m_typeInfo.BuiltInType, (int[])Utils.Clone(m_dimensions));
        }
        #endregion

        #region Private Fields
        private Array m_elements;
        private int[] m_dimensions;
        private TypeInfo m_typeInfo;
        #endregion
    }

}//namespace

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\Variant.cs(1523,24): error CS8116: It is not legal to use nullable type 'Variant?' in a pattern; use the underlying type 'Variant' instead.,D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\Variant.cs(2255,34): error CS8116: It is not legal to use nullable type 'Guid?' in a pattern; use the underlying type 'Guid' instead.,D:\a\1\s\Stack\Opc.Ua.Core\Types\BuiltIn\Variant.cs(2439,36): error CS0136: A local or parameter named 'array' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 21 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\BinaryEncoder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// Encodes objects in a stream using the UA Binary encoding.
    /// </summary>
    public class BinaryEncoder : IEncoder, IDisposable
    {
        #region Constructor
        /// <summary>
        /// Creates an encoder that writes to a memory buffer.
        /// </summary>
        public BinaryEncoder(ServiceMessageContext context)
        {
            m_ostrm = new MemoryStream();
            m_writer = new BinaryWriter(m_ostrm);
            m_context = context;
            m_nestingLevel = 0;
        }

        /// <summary>
        /// Creates an encoder that writes to a fixed size memory buffer.
        /// </summary>
        public BinaryEncoder(byte[] buffer, int start, int count, ServiceMessageContext context)
        {
            if (buffer == null) throw new ArgumentNullException(nameof(buffer));

            m_ostrm = new MemoryStream(buffer, start, count);
            m_writer = new BinaryWriter(m_ostrm);
            m_context = context;
            m_nestingLevel = 0;
        }

        /// <summary>
        /// Creates an encoder that writes to the stream.
        /// </summary>
        public BinaryEncoder(Stream stream, ServiceMessageContext context)
        {
            if (stream == null) throw new ArgumentNullException(nameof(stream));

            m_ostrm = stream;
            m_writer = new BinaryWriter(m_ostrm);
            m_context = context;
            m_nestingLevel = 0;
        }
        #endregion

        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (m_writer != null)
                {
                    m_writer.Flush();
                    m_writer.Dispose();
                }

                m_ostrm?.Dispose();
            }
        }
        #endregion

        #region Public Members
        /// <summary>
        /// Initializes the tables used to map namespace and server uris during encoding.
        /// </summary>
        /// <param name="namespaceUris">The namespaces URIs referenced by the data being encoded.</param>
        /// <param name="serverUris">The server URIs referenced by the data being encoded.</param>
        public void SetMappingTables(NamespaceTable namespaceUris, StringTable serverUris)
        {
            m_namespaceMappings = null;

            if (namespaceUris != null && m_context.NamespaceUris != null)
            {
                m_namespaceMappings = namespaceUris.CreateMapping(m_context.NamespaceUris, false);
            }

            m_serverMappings = null;

            if (serverUris != null && m_context.ServerUris != null)
            {
                m_serverMappings = serverUris.CreateMapping(m_context.ServerUris, false);
            }
        }

        /// <summary>
        /// Completes writing and returns the buffer (if available).
        /// </summary>
        public byte[] CloseAndReturnBuffer()
        {
            m_writer.Flush();
            m_writer.Dispose();

            if (m_ostrm is MemoryStream memoryStream)
            {
                return memoryStream.ToArray();
            }

            return null;
        }

        /// <summary>
        /// Completes writing and returns position in the stream.
        /// </summary>
        public int Close()
        {
            int position = (int)m_writer.BaseStream.Position;
            m_writer.Flush();
            m_writer.Dispose();
            return position;
        }

        /// <summary>
        /// Gets or sets the position in the stream.
        /// </summary>
        public int Position
        {
            get
            {
                return (int)m_writer.BaseStream.Position;
            }

            set
            {
                m_writer.Seek(value, SeekOrigin.Begin);
            }
        }

        /// <summary>
        /// Gets the stream that the encoder is writing to.
        /// </summary>
        public Stream BaseStream => m_writer.BaseStream;

        /// <summary>
        /// Writes raw bytes to the stream.
        /// </summary>
        public void WriteRawBytes(byte[] buffer, int offset, int count)
        {
            m_writer.Write(buffer, offset, count);
        }

        /// <summary>
        /// Encodes a message in a buffer.
        /// </summary>
        public static byte[] EncodeMessage(IEncodeable message, ServiceMessageContext context)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));
            if (context == null) throw new ArgumentNullException(nameof(context));

            // create encoder.
            BinaryEncoder encoder = new BinaryEncoder(context);

            // encode message
            encoder.EncodeMessage(message);

            // close encoder.
            return encoder.CloseAndReturnBuffer();
        }

        /// <summary>
        /// Encodes a session-less message to a buffer.
        /// </summary>
        public static void EncodeSessionLessMessage(IEncodeable message, Stream stream, ServiceMessageContext context, bool leaveOpen = false)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));
            if (context == null) throw new ArgumentNullException(nameof(context));

            // create encoder.
            BinaryEncoder encoder = new BinaryEncoder(stream, context);

            try
            {
                long start = encoder.m_ostrm.Position;

                // write the type id.
                encoder.WriteNodeId(null, DataTypeIds.SessionlessInvokeRequestType);

                // write the message.
                SessionLessServiceMessage envelope = new SessionLessServiceMessage();
                envelope.NamespaceUris = context.NamespaceUris;
                envelope.ServerUris = context.ServerUris;
                envelope.Message = message;

                envelope.Encode(encoder);

                // check that the max message size was not exceeded.
                if (context.MaxMessageSize > 0 && context.MaxMessageSize < (int)(encoder.m_ostrm.Position - start))
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadEncodingLimitsExceeded,
                        "MaxMessageSize {0} < {1}",
                        context.MaxMessageSize,
                        (int)(encoder.m_ostrm.Position - start));
                }
            }
            finally
            {
                // close encoder.
                if (!leaveOpen)
                {
                    encoder.CloseAndReturnBuffer();
                }
            }
        }

        /// <summary>
        /// Encodes a message in a stream.
        /// </summary>
        public static void EncodeMessage(IEncodeable message, Stream stream, ServiceMessageContext context, bool leaveOpen = false)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));
            if (stream == null) throw new ArgumentNullException(nameof(stream));
            if (context == null) throw new ArgumentNullException(nameof(context));

            // create encoder.
            BinaryEncoder encoder = new BinaryEncoder(stream, context);

            // encode message
            encoder.EncodeMessage(message);

            // close encoder.
            if (!leaveOpen)
            {
                encoder.CloseAndReturnBuffer();
            }
        }

        /// <summary>
        /// Encodes a message with its header.
        /// </summary>
        public void EncodeMessage(IEncodeable message)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));

            long start = m_ostrm.Position;

            // convert the namespace uri to an index.
            NodeId typeId = ExpandedNodeId.ToNodeId(message.BinaryEncodingId, m_context.NamespaceUris);

            // write the type id.
            WriteNodeId(null, typeId);

            // write the message.
            WriteEncodeable(null, message, message.GetType());

            // check that the max message size was not exceeded.
            if (m_context.MaxMessageSize > 0 && m_context.MaxMessageSize < (int)(m_ostrm.Position - start))
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxMessageSize {0} < {1}",
                    m_context.MaxMessageSize,
                    (int)(m_ostrm.Position - start));
            }
        }

        /// <summary>
        /// Saves a string table from a binary stream.
        /// </summary>
        public void SaveStringTable(StringTable stringTable)
        {
            if (stringTable == null || stringTable.Count <= 1)
            {
                WriteInt32(null, -1);
                return;
            }

            WriteInt32(null, stringTable.Count - 1);

            for (uint ii = 1; ii < stringTable.Count; ii++)
            {
                WriteString(null, stringTable.GetString(ii));
            }
        }
        #endregion

        #region IEncoder Members
        /// <summary>
        /// The type of encoding being used.
        /// </summary>
        public EncodingType EncodingType => EncodingType.Binary;

        /// <summary>
        /// The message context associated with the encoder.
        /// </summary>
        public ServiceMessageContext Context => m_context;

        /// <summary>
        /// Binary Encoder always produces reversible encoding.
        /// </summary>
        public bool UseReversibleEncoding => true;

        /// <summary>
        /// Pushes a namespace onto the namespace stack.
        /// </summary>
        public void PushNamespace(string namespaceUri)
        {
            // not used in the binary encoding.
        }

        /// <summary>
        /// Pops a namespace from the namespace stack.
        /// </summary>
        public void PopNamespace()
        {
            // not used in the binary encoding.
        }

        /// <summary>
        /// Writes a boolean to the stream.
        /// </summary>
        public void WriteBoolean(string fieldName, bool value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a sbyte to the stream.
        /// </summary>
        public void WriteSByte(string fieldName, sbyte value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a byte to the stream.
        /// </summary>
        public void WriteByte(string fieldName, byte value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a short to the stream.
        /// </summary>
        public void WriteInt16(string fieldName, short value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a ushort to the stream.
        /// </summary>
        public void WriteUInt16(string fieldName, ushort value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes an int to the stream.
        /// </summary>
        public void WriteInt32(string fieldName, int value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a uint to the stream.
        /// </summary>
        public void WriteUInt32(string fieldName, uint value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a long to the stream.
        /// </summary>
        public void WriteInt64(string fieldName, long value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a ulong to the stream.
        /// </summary>
        public void WriteUInt64(string fieldName, ulong value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a float to the stream.
        /// </summary>
        public void WriteFloat(string fieldName, float value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a double to the stream.
        /// </summary>
        public void WriteDouble(string fieldName, double value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a string to the stream.
        /// </summary>
        public void WriteString(string fieldName, string value)
        {
            if (value == null)
            {
                WriteInt32(null, -1);
                return;
            }

            byte[] bytes = new UTF8Encoding().GetBytes(value);

            if (m_context.MaxStringLength > 0 && m_context.MaxStringLength < bytes.Length)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxStringLength {0} < {1}",
                    m_context.MaxStringLength,
                    bytes.Length);
            }

            WriteByteString(null, new UTF8Encoding().GetBytes(value));
        }

        /// <summary>
        /// Writes a UTC date/time to the stream.
        /// </summary>
        public void WriteDateTime(string fieldName, DateTime value)
        {
            value = Utils.ToOpcUaUniversalTime(value);

            long ticks = value.Ticks;

            // check for max value.
            if (ticks >= DateTime.MaxValue.Ticks)
            {
                ticks = Int64.MaxValue;
            }

            // check for min value.
            else
            {
                ticks -= Utils.TimeBase.Ticks;

                if (ticks <= 0)
                {
                    ticks = 0;
                }
            }

            m_writer.Write(ticks);
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Uuid value)
        {
            m_writer.Write(((Guid)value).ToByteArray());
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Guid value)
        {
            m_writer.Write(((Guid)value).ToByteArray());
        }

        /// <summary>
        /// Writes a byte string to the stream.
        /// </summary>
        public void WriteByteString(string fieldName, byte[] value)
        {
            if (value == null)
            {
                WriteInt32(null, -1);
                return;
            }

            if (m_context.MaxByteStringLength > 0 && m_context.MaxByteStringLength < value.Length)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxByteStringLength {0} < {1}",
                    m_context.MaxByteStringLength,
                    value.Length);
            }

            WriteInt32(null, value.Length);
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes an XmlElement to the stream.
        /// </summary>
        public void WriteXmlElement(string fieldName, XmlElement value)
        {
            if (value == null)
            {
                WriteInt32(null, -1);
                return;
            }

            WriteByteString(null, new UTF8Encoding().GetBytes(value.OuterXml));
        }

        /// <summary>
        /// Writes an NodeId to the stream.
        /// </summary>
        public void WriteNodeId(string fieldName, NodeId value)
        {
            // write a null node id.
            if (value == null)
            {
                WriteUInt16(null, 0);
                return;
            }

            ushort namespaceIndex = value.NamespaceIndex;

            if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
            {
                namespaceIndex = m_namespaceMappings[namespaceIndex];
            }

            // get the node encoding.
            byte encoding = GetNodeIdEncoding(value.IdType, value.Identifier, namespaceIndex);

            // write the encoding.
            WriteByte(null, encoding);

            // write the node.
            WriteNodeIdBody(encoding, value.Identifier, namespaceIndex);
        }

        /// <summary>
        /// Writes an ExpandedNodeId to the stream.
        /// </summary>
        public void WriteExpandedNodeId(string fieldName, ExpandedNodeId value)
        {
            // write a null node id.
            if (value == null)
            {
                WriteUInt16(null, 0);
                return;
            }

            ushort namespaceIndex = value.NamespaceIndex;

            if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
            {
                namespaceIndex = m_namespaceMappings[namespaceIndex];
            }

            uint serverIndex = value.ServerIndex;

            if (m_serverMappings != null && m_serverMappings.Length > serverIndex)
            {
                serverIndex = m_serverMappings[serverIndex];
            }

            // get the node encoding.
            byte encoding = GetNodeIdEncoding(value.IdType, value.Identifier, namespaceIndex);

            // add the bit indicating a uri string is encoded as well.
            if (!String.IsNullOrEmpty(value.NamespaceUri))
            {
                encoding |= 0x80;
            }

            // add the bit indicating a server index.
            if (serverIndex > 0)
            {
                encoding |= 0x40;
            }

            // write the encoding.
            WriteByte(null, encoding);

            // write the node id.
            WriteNodeIdBody(encoding, value.Identifier, namespaceIndex);

            // write the namespace uri.
            if ((encoding & 0x80) != 0)
            {
                WriteString(null, value.NamespaceUri);
            }

            // write the server index.
            if ((encoding & 0x40) != 0)
            {
                WriteUInt32(null, serverIndex);
            }
        }

        /// <summary>
        /// Writes an StatusCode to the stream.
        /// </summary>
        public void WriteStatusCode(string fieldName, StatusCode value)
        {
            WriteUInt32(null, value.Code);
        }

        /// <summary>
        /// Writes an DiagnosticInfo to the stream.
        /// </summary>
        public void WriteDiagnosticInfo(string fieldName, DiagnosticInfo value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            // check for null.
            if (value == null)
            {
                WriteByte(null, 0);
                return;
            }

            m_nestingLevel++;

            // calculate the encoding.
            byte encoding = 0;

            if (value.SymbolicId >= 0)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.SymbolicId;
            }

            if (value.NamespaceUri >= 0)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.NamespaceUri;
            }

            if (value.Locale >= 0)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.Locale;
            }

            if (value.LocalizedText >= 0)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.LocalizedText;
            }

            if (value.AdditionalInfo != null)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.AdditionalInfo;
            }

            if (value.InnerStatusCode != StatusCodes.Good)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.InnerStatusCode;
            }

            if (value.InnerDiagnosticInfo != null)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.InnerDiagnosticInfo;
            }

            // write the encoding.
            WriteByte(null, encoding);

            // write the fields of the diagnostic info structure.
            if ((encoding & (byte)DiagnosticInfoEncodingBits.SymbolicId) != 0)
            {
                WriteInt32(null, value.SymbolicId);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.NamespaceUri) != 0)
            {
                WriteInt32(null, value.NamespaceUri);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.Locale) != 0)
            {
                WriteInt32(null, value.Locale);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.LocalizedText) != 0)
            {
                WriteInt32(null, value.LocalizedText);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.AdditionalInfo) != 0)
            {
                WriteString(null, value.AdditionalInfo);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.InnerStatusCode) != 0)
            {
                WriteStatusCode(null, value.InnerStatusCode);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.InnerDiagnosticInfo) != 0)
            {
                WriteDiagnosticInfo(null, value.InnerDiagnosticInfo);
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an QualifiedName to the stream.
        /// </summary>
        public void WriteQualifiedName(string fieldName, QualifiedName value)
        {
            // check for null.
            if (value == null)
            {
                value = new QualifiedName();
            }

            ushort namespaceIndex = value.NamespaceIndex;

            if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
            {
                namespaceIndex = m_namespaceMappings[namespaceIndex];
            }

            WriteUInt16(null, namespaceIndex);
            WriteString(null, value.Name);
        }

        /// <summary>
        /// Writes an LocalizedText to the stream.
        /// </summary>
        public void WriteLocalizedText(string fieldName, LocalizedText value)
        {
            // check for null.
            if (value == null)
            {
                WriteByte(null, 0);
                return;
            }

            // calculate the encoding.
            byte encoding = 0;

            if (value.Locale != null)
            {
                encoding |= (byte)LocalizedTextEncodingBits.Locale;
            }

            if (value.Text != null)
            {
                encoding |= (byte)LocalizedTextEncodingBits.Text;
            }

            // write the encoding.
            WriteByte(null, encoding);

            // write the fields.
            if ((encoding & (byte)LocalizedTextEncodingBits.Locale) != 0)
            {
                WriteString(null, value.Locale);
            }

            if ((encoding & (byte)LocalizedTextEncodingBits.Text) != 0)
            {
                WriteString(null, value.Text);
            }
        }

        /// <summary>
        /// Writes an Variant to the stream.
        /// </summary>
        public void WriteVariant(string fieldName, Variant value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            WriteVariantValue(fieldName, value);

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValue(string fieldName, DataValue value)
        {
            // check for null.
            if (value == null)
            {
                WriteByte(null, 0);
                return;
            }

            // calculate the encoding.
            byte encoding = 0;

            if (value.Value != null)
            {
                encoding |= (byte)DataValueEncodingBits.Value;
            }

            if (value.StatusCode != StatusCodes.Good)
            {
                encoding |= (byte)DataValueEncodingBits.StatusCode;
            }

            if (value.SourceTimestamp != DateTime.MinValue)
            {
                encoding |= (byte)DataValueEncodingBits.SourceTimestamp;
            }

            if (value.SourcePicoseconds != 0)
            {
                encoding |= (byte)DataValueEncodingBits.SourcePicoseconds;
            }

            if (value.ServerTimestamp != DateTime.MinValue)
            {
                encoding |= (byte)DataValueEncodingBits.ServerTimestamp;
            }

            if (value.ServerPicoseconds != 0)
            {
                encoding |= (byte)DataValueEncodingBits.ServerPicoseconds;
            }

            // write the encoding.
            WriteByte(null, encoding);

            // write the fields of the data value structure.
            if ((encoding & (byte)DataValueEncodingBits.Value) != 0)
            {
                WriteVariant(null, value.WrappedValue);
            }

            if ((encoding & (byte)DataValueEncodingBits.StatusCode) != 0)
            {
                WriteStatusCode(null, value.StatusCode);
            }

            if ((encoding & (byte)DataValueEncodingBits.SourceTimestamp) != 0)
            {
                WriteDateTime(null, value.SourceTimestamp);
            }

            if ((encoding & (byte)DataValueEncodingBits.SourcePicoseconds) != 0)
            {
                WriteUInt16(null, value.SourcePicoseconds);
            }

            if ((encoding & (byte)DataValueEncodingBits.ServerTimestamp) != 0)
            {
                WriteDateTime(null, value.ServerTimestamp);
            }

            if ((encoding & (byte)DataValueEncodingBits.ServerPicoseconds) != 0)
            {
                WriteUInt16(null, value.ServerPicoseconds);
            }
        }

        /// <summary>
        /// Writes an ExtensionObject to the stream.
        /// </summary>
        public void WriteExtensionObject(string fieldName, ExtensionObject value)
        {
            // check for null.
            if (value == null)
            {
                WriteNodeId(null, NodeId.Null);
                WriteByte(null, Convert.ToByte(ExtensionObjectEncoding.None, CultureInfo.InvariantCulture));
                return;
            }

            IEncodeable encodeable = value.Body as IEncodeable;

            // write the type id.
            ExpandedNodeId typeId = value.TypeId;

            if (encodeable != null)
            {
                if (value.Encoding == ExtensionObjectEncoding.Xml)
                {
                    typeId = encodeable.XmlEncodingId;
                }
                else
                {
                    typeId = encodeable.BinaryEncodingId;
                }
            }

            NodeId localTypeId = ExpandedNodeId.ToNodeId(typeId, m_context.NamespaceUris);

            if (NodeId.IsNull(localTypeId) && !NodeId.IsNull(typeId))
            {
                if (encodeable != null)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadEncodingError,
                        "Cannot encode bodies of type '{0}' in ExtensionObject unless the NamespaceUri ({1}) is in the encoder's NamespaceTable.",
                        encodeable.GetType().FullName,
                        typeId.NamespaceUri);
                }

                localTypeId = NodeId.Null;
            }

            WriteNodeId(null, localTypeId);

            // determine the encoding type.
            byte encoding = Convert.ToByte(value.Encoding, CultureInfo.InvariantCulture);

            if (value.Encoding == ExtensionObjectEncoding.EncodeableObject)
            {
                encoding = Convert.ToByte(ExtensionObjectEncoding.Binary, CultureInfo.InvariantCulture);
            }

            object body = value.Body;

            if (body == null)
            {
                encoding = Convert.ToByte(ExtensionObjectEncoding.None, CultureInfo.InvariantCulture);
            }

            // write the encoding type.
            WriteByte(null, encoding);

            // nothing more to do for null bodies.
            if (body == null)
            {
                return;
            }

            // write binary bodies.
            byte[] bytes = body as byte[];

            if (bytes != null)
            {
                WriteByteString(null, bytes);
                return;
            }

            // write XML bodies.
            XmlElement xml = body as XmlElement;

            if (xml != null)
            {
                WriteXmlElement(null, xml);
                return;
            }

            // write encodeable bodies.
            if (encodeable == null)
            {
                throw new ServiceResultException(
                    StatusCodes.BadEncodingError,
                    Utils.Format("Cannot encode bodies of type '{0}' in extension objects.", body.GetType().FullName));
            }

            // check if it possible to write the extension directly to the stream.
            if (m_writer.BaseStream.CanSeek)
            {
                long start = m_writer.BaseStream.Position;

                // write a placeholder for the body length.
                WriteInt32(null, -1);
                encodeable.Encode(this);

                // update body length.
                long delta = m_writer.BaseStream.Position - start;

                m_writer.Seek((int)-delta, SeekOrigin.Current);
                WriteInt32(null, (int)(delta - 4));
                m_writer.Seek((int)(delta - 4), SeekOrigin.Current);
            }

            // must pre-encode and then write the bytes.
            else
            {
                BinaryEncoder encoder = new BinaryEncoder(this.m_context);
                encoder.WriteEncodeable(null, encodeable, null);
                bytes = encoder.CloseAndReturnBuffer();
                WriteByteString(null, bytes);
            }
        }

        /// <summary>
        /// Writes an encodeable object to the stream.
        /// </summary>
        public void WriteEncodeable(string fieldName, IEncodeable value, System.Type systemType)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            // create a default object if a null object specified.
            if (value == null)
            {
                if (systemType == null) throw new ArgumentNullException(nameof(systemType));
                value = Activator.CreateInstance(systemType) as IEncodeable;
            }

            m_nestingLevel++;

            // encode the object.
            value?.Encode(this);

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an enumerated value array to the stream.
        /// </summary>
        public void WriteEnumerated(string fieldName, Enum value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            WriteInt32(null, Convert.ToInt32(value, CultureInfo.InvariantCulture));
        }

        /// <summary>
        /// Writes a boolean array to the stream.
        /// </summary>
        public void WriteBooleanArray(string fieldName, IList<bool> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteBoolean(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteSByteArray(string fieldName, IList<sbyte> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteSByte(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteByteArray(string fieldName, IList<byte> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteByte(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a short array to the stream.
        /// </summary>
        public void WriteInt16Array(string fieldName, IList<short> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt16(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a ushort array to the stream.
        /// </summary>
        public void WriteUInt16Array(string fieldName, IList<ushort> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt16(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a int array to the stream.
        /// </summary>
        public void WriteInt32Array(string fieldName, IList<int> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt32(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a uint array to the stream.
        /// </summary>
        public void WriteUInt32Array(string fieldName, IList<uint> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt32(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a long array to the stream.
        /// </summary>
        public void WriteInt64Array(string fieldName, IList<long> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt64(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a ulong array to the stream.
        /// </summary>
        public void WriteUInt64Array(string fieldName, IList<ulong> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt64(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a float array to the stream.
        /// </summary>
        public void WriteFloatArray(string fieldName, IList<float> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteFloat(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a double array to the stream.
        /// </summary>
        public void WriteDoubleArray(string fieldName, IList<double> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDouble(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a string array to the stream.
        /// </summary>
        public void WriteStringArray(string fieldName, IList<string> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteString(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a UTC date/time array to the stream.
        /// </summary>
        public void WriteDateTimeArray(string fieldName, IList<DateTime> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDateTime(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Uuid> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteGuid(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Guid> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteGuid(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a byte string array to the stream.
        /// </summary>
        public void WriteByteStringArray(string fieldName, IList<byte[]> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteByteString(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an XmlElement array to the stream.
        /// </summary>
        public void WriteXmlElementArray(string fieldName, IList<XmlElement> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteXmlElement(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an NodeId array to the stream.
        /// </summary>
        public void WriteNodeIdArray(string fieldName, IList<NodeId> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteNodeId(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an ExpandedNodeId array to the stream.
        /// </summary>
        public void WriteExpandedNodeIdArray(string fieldName, IList<ExpandedNodeId> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteExpandedNodeId(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an StatusCode array to the stream.
        /// </summary>
        public void WriteStatusCodeArray(string fieldName, IList<StatusCode> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteStatusCode(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an DiagnosticInfo array to the stream.
        /// </summary>
        public void WriteDiagnosticInfoArray(string fieldName, IList<DiagnosticInfo> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDiagnosticInfo(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an QualifiedName array to the stream.
        /// </summary>
        public void WriteQualifiedNameArray(string fieldName, IList<QualifiedName> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteQualifiedName(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an LocalizedText array to the stream.
        /// </summary>
        public void WriteLocalizedTextArray(string fieldName, IList<LocalizedText> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteLocalizedText(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteVariantArray(string fieldName, IList<Variant> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteVariant(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValueArray(string fieldName, IList<DataValue> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDataValue(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an extension object array to the stream.
        /// </summary>
        public void WriteExtensionObjectArray(string fieldName, IList<ExtensionObject> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteExtensionObject(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an encodeable object array to the stream.
        /// </summary>
        public void WriteEncodeableArray(string fieldName, IList<IEncodeable> values, System.Type systemType)
        {
            // write length.
            if (WriteArrayLength((Array)values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteEncodeable(null, values[ii], systemType);
            }
        }

        /// <summary>
        /// Writes an enumerated value array to the stream.
        /// </summary>
        public void WriteEnumeratedArray(string fieldName, Array values, System.Type systemType)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Length; ii++)
            {
                WriteEnumerated(null, (Enum)values.GetValue(ii));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Writes an object array to the stream (converts to Variant first).
        /// </summary>
        private void WriteObjectArray(string fieldName, IList<object> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteVariant(null, new Variant(values[ii]));
            }
        }

        /// <summary>
        /// Write the length of an array. Returns true if the array is empty.
        /// </summary>
        private bool WriteArrayLength<T>(ICollection<T> values)
        {
            // check for null.
            if (values == null)
            {
                WriteInt32(null, -1);
                return true;
            }

            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxArrayLength {0} < {1}",
                    m_context.MaxArrayLength,
                    values.Count);
            }

            // write length.
            WriteInt32(null, values.Count);
            return values.Count == 0;
        }

        /// <summary>
        /// Write the length of an array. Returns true if the array is empty.
        /// </summary>
        private bool WriteArrayLength(Array values)
        {
            // check for null.
            if (values == null)
            {
                WriteInt32(null, -1);
                return true;
            }

            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Length)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxArrayLength {0} < {1}",
                    m_context.MaxArrayLength,
                    values.Length);
            }

            // write length.
            WriteInt32(null, values.Length);
            return values.Length == 0;
        }

        /// <summary>
        /// Returns the node id encoding byte for a node id value.
        /// </summary>
        private static byte GetNodeIdEncoding(IdType idType, object identifier, uint namespaceIndex)
        {
            NodeIdEncodingBits encoding = NodeIdEncodingBits.Numeric;

            switch (idType)
            {
                case IdType.Numeric:
                {
                    uint id = Convert.ToUInt32(identifier, CultureInfo.InvariantCulture);

                    if (id <= Byte.MaxValue && namespaceIndex == 0)
                    {
                        encoding = NodeIdEncodingBits.TwoByte;
                        break;
                    }

                    if (id <= UInt16.MaxValue && namespaceIndex <= Byte.MaxValue)
                    {
                        encoding = NodeIdEncodingBits.FourByte;
                        break;
                    }

                    encoding = NodeIdEncodingBits.Numeric;
                    break;
                }

                case IdType.String:
                {
                    encoding = NodeIdEncodingBits.String;
                    break;
                }

                case IdType.Guid:
                {
                    encoding = NodeIdEncodingBits.Guid;
                    break;
                }

                case IdType.Opaque:
                {
                    encoding = NodeIdEncodingBits.ByteString;
                    break;
                }

                default:
                {
                    throw new ServiceResultException(
                        StatusCodes.BadEncodingError,
                        Utils.Format("NodeId identifier type '{0}' not supported.", idType));
                }
            }

            return Convert.ToByte(encoding, CultureInfo.InvariantCulture);
        }

        /// <summary>
        /// Writes the body of a node id to the stream.
        /// </summary>
        private void WriteNodeIdBody(byte encoding, object identifier, ushort namespaceIndex)
        {
            // write the node id.
            switch ((NodeIdEncodingBits)(0x3F & encoding))
            {
                case NodeIdEncodingBits.TwoByte:
                {
                    WriteByte(null, Convert.ToByte(identifier, CultureInfo.InvariantCulture));
                    break;
                }

                case NodeIdEncodingBits.FourByte:
                {
                    WriteByte(null, Convert.ToByte(namespaceIndex));
                    WriteUInt16(null, Convert.ToUInt16(identifier, CultureInfo.InvariantCulture));
                    break;
                }

                case NodeIdEncodingBits.Numeric:
                {
                    WriteUInt16(null, namespaceIndex);
                    WriteUInt32(null, Convert.ToUInt32(identifier, CultureInfo.InvariantCulture));
                    break;
                }

                case NodeIdEncodingBits.String:
                {
                    WriteUInt16(null, namespaceIndex);
                    WriteString(null, (string)identifier);
                    break;
                }

                case NodeIdEncodingBits.Guid:
                {
                    WriteUInt16(null, namespaceIndex);
                    WriteGuid(null, new Uuid((Guid)identifier));
                    break;
                }

                case NodeIdEncodingBits.ByteString:
                {
                    WriteUInt16(null, namespaceIndex);
                    WriteByteString(null, (byte[])identifier);
                    break;
                }
            }
        }

        /// <summary>
        /// Writes an Variant to the stream.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void WriteVariantValue(string fieldName, Variant value)
        {
            // check for null.
            if (value.Value == null || value.TypeInfo == null || value.TypeInfo.BuiltInType == BuiltInType.Null)
            {
                WriteByte(null, 0);
                return;
            }

            // encode enums as int32.
            byte encodingByte = (byte)value.TypeInfo.BuiltInType;
            if (value.TypeInfo.BuiltInType == BuiltInType.Enumeration)
            {
                encodingByte = (byte)BuiltInType.Int32;
            }

            object valueToEncode = value.Value;

            if (value.TypeInfo.ValueRank < 0)
            {
                WriteByte(null, encodingByte);

                switch (value.TypeInfo.BuiltInType)
                {
                    case BuiltInType.Boolean: { WriteBoolean(null, (bool)valueToEncode); return; }
                    case BuiltInType.SByte: { WriteSByte(null, (sbyte)valueToEncode); return; }
                    case BuiltInType.Byte: { WriteByte(null, (byte)valueToEncode); return; }
                    case BuiltInType.Int16: { WriteInt16(null, (short)valueToEncode); return; }
                    case BuiltInType.UInt16: { WriteUInt16(null, (ushort)valueToEncode); return; }
                    case BuiltInType.Int32: { WriteInt32(null, (int)valueToEncode); return; }
                    case BuiltInType.UInt32: { WriteUInt32(null, (uint)valueToEncode); return; }
                    case BuiltInType.Int64: { WriteInt64(null, (long)valueToEncode); return; }
                    case BuiltInType.UInt64: { WriteUInt64(null, (ulong)valueToEncode); return; }
                    case BuiltInType.Float: { WriteFloat(null, (float)valueToEncode); return; }
                    case BuiltInType.Double: { WriteDouble(null, (double)valueToEncode); return; }
                    case BuiltInType.String: { WriteString(null, (string)valueToEncode); return; }
                    case BuiltInType.DateTime: { WriteDateTime(null, (DateTime)valueToEncode); return; }
                    case BuiltInType.Guid: { WriteGuid(null, (Uuid)valueToEncode); return; }
                    case BuiltInType.ByteString: { WriteByteString(null, (byte[])valueToEncode); return; }
                    case BuiltInType.XmlElement: { WriteXmlElement(null, (XmlElement)valueToEncode); return; }
                    case BuiltInType.NodeId: { WriteNodeId(null, (NodeId)valueToEncode); return; }
                    case BuiltInType.ExpandedNodeId: { WriteExpandedNodeId(null, (ExpandedNodeId)valueToEncode); return; }
                    case BuiltInType.StatusCode: { WriteStatusCode(null, (StatusCode)valueToEncode); return; }
                    case BuiltInType.QualifiedName: { WriteQualifiedName(null, (QualifiedName)valueToEncode); return; }
                    case BuiltInType.LocalizedText: { WriteLocalizedText(null, (LocalizedText)valueToEncode); return; }
                    case BuiltInType.ExtensionObject: { WriteExtensionObject(null, (ExtensionObject)valueToEncode); return; }
                    case BuiltInType.DataValue: { WriteDataValue(null, (DataValue)valueToEncode); return; }
                    case BuiltInType.Enumeration: { WriteInt32(null, Convert.ToInt32(valueToEncode)); return; }
                }

                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingError,
                    "Unexpected type encountered while encoding a Variant: {0}",
                    value.TypeInfo.BuiltInType);
            }

            if (value.TypeInfo.ValueRank >= 0)
            {
                Matrix matrix = null;

                encodingByte |= (byte)VariantArrayEncodingBits.Array;

                if (value.TypeInfo.ValueRank > 1)
                {
                    encodingByte |= (byte)VariantArrayEncodingBits.ArrayDimensions;
                    matrix = (Matrix)valueToEncode;
                    valueToEncode = matrix.Elements;
                }

                WriteByte(null, encodingByte);

                switch (value.TypeInfo.BuiltInType)
                {
                    case BuiltInType.Boolean: { WriteBooleanArray(null, (bool[])valueToEncode); break; }
                    case BuiltInType.SByte: { WriteSByteArray(null, (sbyte[])valueToEncode); break; }
                    case BuiltInType.Byte: { WriteByteArray(null, (byte[])valueToEncode); break; }
                    case BuiltInType.Int16: { WriteInt16Array(null, (short[])valueToEncode); break; }
                    case BuiltInType.UInt16: { WriteUInt16Array(null, (ushort[])valueToEncode); break; }
                    case BuiltInType.Int32: { WriteInt32Array(null, (int[])valueToEncode); break; }
                    case BuiltInType.UInt32: { WriteUInt32Array(null, (uint[])valueToEncode); break; }
                    case BuiltInType.Int64: { WriteInt64Array(null, (long[])valueToEncode); break; }
                    case BuiltInType.UInt64: { WriteUInt64Array(null, (ulong[])valueToEncode); break; }
                    case BuiltInType.Float: { WriteFloatArray(null, (float[])valueToEncode); break; }
                    case BuiltInType.Double: { WriteDoubleArray(null, (double[])valueToEncode); break; }
                    case BuiltInType.String: { WriteStringArray(null, (string[])valueToEncode); break; }
                    case BuiltInType.DateTime: { WriteDateTimeArray(null, (DateTime[])valueToEncode); break; }
                    case BuiltInType.Guid: { WriteGuidArray(null, (Uuid[])valueToEncode); break; }
                    case BuiltInType.ByteString: { WriteByteStringArray(null, (byte[][])valueToEncode); break; }
                    case BuiltInType.XmlElement: { WriteXmlElementArray(null, (XmlElement[])valueToEncode); break; }
                    case BuiltInType.NodeId: { WriteNodeIdArray(null, (NodeId[])valueToEncode); break; }
                    case BuiltInType.ExpandedNodeId: { WriteExpandedNodeIdArray(null, (ExpandedNodeId[])valueToEncode); break; }
                    case BuiltInType.StatusCode: { WriteStatusCodeArray(null, (StatusCode[])valueToEncode); break; }
                    case BuiltInType.QualifiedName: { WriteQualifiedNameArray(null, (QualifiedName[])valueToEncode); break; }
                    case BuiltInType.LocalizedText: { WriteLocalizedTextArray(null, (LocalizedText[])valueToEncode); break; }
                    case BuiltInType.ExtensionObject: { WriteExtensionObjectArray(null, (ExtensionObject[])valueToEncode); break; }
                    case BuiltInType.DataValue: { WriteDataValueArray(null, (DataValue[])valueToEncode); break; }

                    case BuiltInType.Enumeration:
                    {
                        // Check whether the value to encode is int array.
                        int[] ints = valueToEncode as int[];
                        if (ints == null)
                        {
                            Enum[] enums = valueToEncode as Enum[];
                            if (enums == null)
                            {
                                throw new ServiceResultException(
                                    StatusCodes.BadEncodingError,
                                    Utils.Format("Type '{0}' is not allowed in an Enumeration.", value.GetType().FullName));
                            }
                            ints = new int[enums.Length];
                            for (int ii = 0; ii < enums.Length; ii++)
                            {
                                ints[ii] = (int)(object)enums[ii];
                            }
                        }

                        WriteInt32Array(null, ints);
                        break;
                    }

                    case BuiltInType.Variant:
                    {
                        Variant[] variants = valueToEncode as Variant[];

                        if (variants != null)
                        {
                            WriteVariantArray(null, variants);
                            break;
                        }

                        object[] objects = valueToEncode as object[];

                        if (objects != null)
                        {
                            WriteObjectArray(null, objects);
                            break;
                        }

                        throw ServiceResultException.Create(
                            StatusCodes.BadEncodingError,
                            "Unexpected type encountered while encoding a Matrix: {0}",
                            valueToEncode.GetType());
                    }

                    default:
                    {
                        throw ServiceResultException.Create(
                            StatusCodes.BadEncodingError,
                            "Unexpected type encountered while encoding a Variant: {0}",
                            value.TypeInfo.BuiltInType);
                    }
                }

                // write the dimensions.
                if (value.TypeInfo.ValueRank > 1)
                {
                    WriteInt32Array(null, (int[])matrix.Dimensions);
                }
            }
        }
        #endregion

        #region Private Fields
        private Stream m_ostrm;
        private BinaryWriter m_writer;
        private ServiceMessageContext m_context;
        private ushort[] m_namespaceMappings;
        private ushort[] m_serverMappings;
        private uint m_nestingLevel;
        #endregion
    }

    #region Internal Enumerations
    /// <summary>
    /// The possible values for the node id encoding byte.
    /// </summary>
    internal enum NodeIdEncodingBits
    {
        TwoByte = 0x00,
        FourByte = 0x01,
        Numeric = 0x02,
        String = 0x03,
        Guid = 0x04,
        ByteString = 0x05
    }

    /// <summary>
    /// The possible values for the diagnostic info encoding byte.
    /// </summary>
    [Flags]
    internal enum DiagnosticInfoEncodingBits
    {
        SymbolicId = 0x01,
        NamespaceUri = 0x02,
        LocalizedText = 0x04,
        Locale = 0x08,
        AdditionalInfo = 0x10,
        InnerStatusCode = 0x20,
        InnerDiagnosticInfo = 0x40,
    }

    /// <summary>
    /// The possible values for the localized text encoding byte.
    /// </summary>
    [Flags]
    internal enum LocalizedTextEncodingBits
    {
        Locale = 0x01,
        Text = 0x02
    }

    /// <summary>
    /// The possible values for the data value encoding byte.
    /// </summary>
    [Flags]
    internal enum DataValueEncodingBits
    {
        Value = 0x01,
        StatusCode = 0x02,
        SourceTimestamp = 0x04,
        ServerTimestamp = 0x08,
        SourcePicoseconds = 0x10,
        ServerPicoseconds = 0x20
    }

    /// <summary>
    /// The possible values for the data value encoding byte.
    /// </summary>
    [Flags]
    internal enum ExtensionObjectEncodingBits
    {
        TypeId = 0x01,
        BinaryBody = 0x02,
        XmlBody = 0x04
    }

    /// <summary>
    /// The possible values for Variant encoding bits.
    /// </summary>
    [Flags]
    internal enum VariantArrayEncodingBits
    {
        Array = 0x80,
        ArrayDimensions = 0x40,
        TypeMask = 0x3F
    }
    #endregion
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// Encodes objects in a stream using the UA Binary encoding.
    /// </summary>
    public class BinaryEncoder : IEncoder, IDisposable
    {
        #region Constructor
        /// <summary>
        /// Creates an encoder that writes to a memory buffer.
        /// </summary>
        public BinaryEncoder(ServiceMessageContext context)
        {
            m_ostrm = new MemoryStream();
            m_writer = new BinaryWriter(m_ostrm);
            m_context = context;
            m_nestingLevel = 0;
        }

        /// <summary>
        /// Creates an encoder that writes to a fixed size memory buffer.
        /// </summary>
        public BinaryEncoder(byte[] buffer, int start, int count, ServiceMessageContext context)
        {
            if (buffer == null) throw new ArgumentNullException(nameof(buffer));

            m_ostrm = new MemoryStream(buffer, start, count);
            m_writer = new BinaryWriter(m_ostrm);
            m_context = context;
            m_nestingLevel = 0;
        }

        /// <summary>
        /// Creates an encoder that writes to the stream.
        /// </summary>
        public BinaryEncoder(Stream stream, ServiceMessageContext context)
        {
            if (stream == null) throw new ArgumentNullException(nameof(stream));

            m_ostrm = stream;
            m_writer = new BinaryWriter(m_ostrm);
            m_context = context;
            m_nestingLevel = 0;
        }
        #endregion

        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (m_writer != null)
                {
                    m_writer.Flush();
                    m_writer.Dispose();
                }

                m_ostrm?.Dispose();
            }
        }
        #endregion

        #region Public Members
        /// <summary>
        /// Initializes the tables used to map namespace and server uris during encoding.
        /// </summary>
        /// <param name="namespaceUris">The namespaces URIs referenced by the data being encoded.</param>
        /// <param name="serverUris">The server URIs referenced by the data being encoded.</param>
        public void SetMappingTables(NamespaceTable namespaceUris, StringTable serverUris)
        {
            m_namespaceMappings = null;

            if (namespaceUris != null && m_context.NamespaceUris != null)
            {
                m_namespaceMappings = namespaceUris.CreateMapping(m_context.NamespaceUris, false);
            }

            m_serverMappings = null;

            if (serverUris != null && m_context.ServerUris != null)
            {
                m_serverMappings = serverUris.CreateMapping(m_context.ServerUris, false);
            }
        }

        /// <summary>
        /// Completes writing and returns the buffer (if available).
        /// </summary>
        public byte[] CloseAndReturnBuffer()
        {
            m_writer.Flush();
            m_writer.Dispose();

            if (m_ostrm is MemoryStream memoryStream)
            {
                return memoryStream.ToArray();
            }

            return null;
        }

        /// <summary>
        /// Completes writing and returns position in the stream.
        /// </summary>
        public int Close()
        {
            int position = (int)m_writer.BaseStream.Position;
            m_writer.Flush();
            m_writer.Dispose();
            return position;
        }

        /// <summary>
        /// Gets or sets the position in the stream.
        /// </summary>
        public int Position
        {
            get
            {
                return (int)m_writer.BaseStream.Position;
            }

            set
            {
                m_writer.Seek(value, SeekOrigin.Begin);
            }
        }

        /// <summary>
        /// Gets the stream that the encoder is writing to.
        /// </summary>
        public Stream BaseStream => m_writer.BaseStream;

        /// <summary>
        /// Writes raw bytes to the stream.
        /// </summary>
        public void WriteRawBytes(byte[] buffer, int offset, int count)
        {
            m_writer.Write(buffer, offset, count);
        }

        /// <summary>
        /// Encodes a message in a buffer.
        /// </summary>
        public static byte[] EncodeMessage(IEncodeable message, ServiceMessageContext context)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));
            if (context == null) throw new ArgumentNullException(nameof(context));

            // create encoder.
            BinaryEncoder encoder = new BinaryEncoder(context);

            // encode message
            encoder.EncodeMessage(message);

            // close encoder.
            return encoder.CloseAndReturnBuffer();
        }

        /// <summary>
        /// Encodes a session-less message to a buffer.
        /// </summary>
        public static void EncodeSessionLessMessage(IEncodeable message, Stream stream, ServiceMessageContext context, bool leaveOpen = false)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));
            if (context == null) throw new ArgumentNullException(nameof(context));

            // create encoder.
            BinaryEncoder encoder = new BinaryEncoder(stream, context);

            try
            {
                long start = encoder.m_ostrm.Position;

                // write the type id.
                encoder.WriteNodeId(null, DataTypeIds.SessionlessInvokeRequestType);

                // write the message.
                SessionLessServiceMessage envelope = new SessionLessServiceMessage();
                envelope.NamespaceUris = context.NamespaceUris;
                envelope.ServerUris = context.ServerUris;
                envelope.Message = message;

                envelope.Encode(encoder);

                // check that the max message size was not exceeded.
                if (context.MaxMessageSize > 0 && context.MaxMessageSize < (int)(encoder.m_ostrm.Position - start))
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadEncodingLimitsExceeded,
                        "MaxMessageSize {0} < {1}",
                        context.MaxMessageSize,
                        (int)(encoder.m_ostrm.Position - start));
                }
            }
            finally
            {
                // close encoder.
                if (!leaveOpen)
                {
                    encoder.CloseAndReturnBuffer();
                }
            }
        }

        /// <summary>
        /// Encodes a message in a stream.
        /// </summary>
        public static void EncodeMessage(IEncodeable message, Stream stream, ServiceMessageContext context, bool leaveOpen = false)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));
            if (stream == null) throw new ArgumentNullException(nameof(stream));
            if (context == null) throw new ArgumentNullException(nameof(context));

            // create encoder.
            BinaryEncoder encoder = new BinaryEncoder(stream, context);

            // encode message
            encoder.EncodeMessage(message);

            // close encoder.
            if (!leaveOpen)
            {
                encoder.CloseAndReturnBuffer();
            }
        }

        /// <summary>
        /// Encodes a message with its header.
        /// </summary>
        public void EncodeMessage(IEncodeable message)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));

            long start = m_ostrm.Position;

            // convert the namespace uri to an index.
            NodeId typeId = ExpandedNodeId.ToNodeId(message.BinaryEncodingId, m_context.NamespaceUris);

            // write the type id.
            WriteNodeId(null, typeId);

            // write the message.
            WriteEncodeable(null, message, message.GetType());

            // check that the max message size was not exceeded.
            if (m_context.MaxMessageSize > 0 && m_context.MaxMessageSize < (int)(m_ostrm.Position - start))
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxMessageSize {0} < {1}",
                    m_context.MaxMessageSize,
                    (int)(m_ostrm.Position - start));
            }
        }

        /// <summary>
        /// Saves a string table from a binary stream.
        /// </summary>
        public void SaveStringTable(StringTable stringTable)
        {
            if (stringTable == null || stringTable.Count <= 1)
            {
                WriteInt32(null, -1);
                return;
            }

            WriteInt32(null, stringTable.Count - 1);

            for (uint ii = 1; ii < stringTable.Count; ii++)
            {
                WriteString(null, stringTable.GetString(ii));
            }
        }
        #endregion

        #region IEncoder Members
        /// <summary>
        /// The type of encoding being used.
        /// </summary>
        public EncodingType EncodingType => EncodingType.Binary;

        /// <summary>
        /// The message context associated with the encoder.
        /// </summary>
        public ServiceMessageContext Context => m_context;

        /// <summary>
        /// Binary Encoder always produces reversible encoding.
        /// </summary>
        public bool UseReversibleEncoding => true;

        /// <summary>
        /// Pushes a namespace onto the namespace stack.
        /// </summary>
        public void PushNamespace(string namespaceUri)
        {
            // not used in the binary encoding.
        }

        /// <summary>
        /// Pops a namespace from the namespace stack.
        /// </summary>
        public void PopNamespace()
        {
            // not used in the binary encoding.
        }

        /// <summary>
        /// Writes a boolean to the stream.
        /// </summary>
        public void WriteBoolean(string fieldName, bool value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a sbyte to the stream.
        /// </summary>
        public void WriteSByte(string fieldName, sbyte value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a byte to the stream.
        /// </summary>
        public void WriteByte(string fieldName, byte value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a short to the stream.
        /// </summary>
        public void WriteInt16(string fieldName, short value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a ushort to the stream.
        /// </summary>
        public void WriteUInt16(string fieldName, ushort value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes an int to the stream.
        /// </summary>
        public void WriteInt32(string fieldName, int value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a uint to the stream.
        /// </summary>
        public void WriteUInt32(string fieldName, uint value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a long to the stream.
        /// </summary>
        public void WriteInt64(string fieldName, long value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a ulong to the stream.
        /// </summary>
        public void WriteUInt64(string fieldName, ulong value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a float to the stream.
        /// </summary>
        public void WriteFloat(string fieldName, float value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a double to the stream.
        /// </summary>
        public void WriteDouble(string fieldName, double value)
        {
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes a string to the stream.
        /// </summary>
        public void WriteString(string fieldName, string value)
        {
            if (value == null)
            {
                WriteInt32(null, -1);
                return;
            }

            byte[] bytes = new UTF8Encoding().GetBytes(value);

            if (m_context.MaxStringLength > 0 && m_context.MaxStringLength < bytes.Length)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxStringLength {0} < {1}",
                    m_context.MaxStringLength,
                    bytes.Length);
            }

            WriteByteString(null, new UTF8Encoding().GetBytes(value));
        }

        /// <summary>
        /// Writes a UTC date/time to the stream.
        /// </summary>
        public void WriteDateTime(string fieldName, DateTime value)
        {
            value = Utils.ToOpcUaUniversalTime(value);

            long ticks = value.Ticks;

            // check for max value.
            if (ticks >= DateTime.MaxValue.Ticks)
            {
                ticks = Int64.MaxValue;
            }

            // check for min value.
            else
            {
                ticks -= Utils.TimeBase.Ticks;

                if (ticks <= 0)
                {
                    ticks = 0;
                }
            }

            m_writer.Write(ticks);
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Uuid value)
        {
            m_writer.Write(((Guid)value).ToByteArray());
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Guid value)
        {
            m_writer.Write(((Guid)value).ToByteArray());
        }

        /// <summary>
        /// Writes a byte string to the stream.
        /// </summary>
        public void WriteByteString(string fieldName, byte[] value)
        {
            if (value == null)
            {
                WriteInt32(null, -1);
                return;
            }

            if (m_context.MaxByteStringLength > 0 && m_context.MaxByteStringLength < value.Length)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxByteStringLength {0} < {1}",
                    m_context.MaxByteStringLength,
                    value.Length);
            }

            WriteInt32(null, value.Length);
            m_writer.Write(value);
        }

        /// <summary>
        /// Writes an XmlElement to the stream.
        /// </summary>
        public void WriteXmlElement(string fieldName, XmlElement value)
        {
            if (value == null)
            {
                WriteInt32(null, -1);
                return;
            }

            WriteByteString(null, new UTF8Encoding().GetBytes(value.OuterXml));
        }

        /// <summary>
        /// Writes an NodeId to the stream.
        /// </summary>
        public void WriteNodeId(string fieldName, NodeId value)
        {
            // write a null node id.
            if (value == null)
            {
                WriteUInt16(null, 0);
                return;
            }

            ushort namespaceIndex = value.NamespaceIndex;

            if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
            {
                namespaceIndex = m_namespaceMappings[namespaceIndex];
            }

            // get the node encoding.
            byte encoding = GetNodeIdEncoding(value.IdType, value.Identifier, namespaceIndex);

            // write the encoding.
            WriteByte(null, encoding);

            // write the node.
            WriteNodeIdBody(encoding, value.Identifier, namespaceIndex);
        }

        /// <summary>
        /// Writes an ExpandedNodeId to the stream.
        /// </summary>
        public void WriteExpandedNodeId(string fieldName, ExpandedNodeId value)
        {
            // write a null node id.
            if (value == null)
            {
                WriteUInt16(null, 0);
                return;
            }

            ushort namespaceIndex = value.NamespaceIndex;

            if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
            {
                namespaceIndex = m_namespaceMappings[namespaceIndex];
            }

            uint serverIndex = value.ServerIndex;

            if (m_serverMappings != null && m_serverMappings.Length > serverIndex)
            {
                serverIndex = m_serverMappings[serverIndex];
            }

            // get the node encoding.
            byte encoding = GetNodeIdEncoding(value.IdType, value.Identifier, namespaceIndex);

            // add the bit indicating a uri string is encoded as well.
            if (!String.IsNullOrEmpty(value.NamespaceUri))
            {
                encoding |= 0x80;
            }

            // add the bit indicating a server index.
            if (serverIndex > 0)
            {
                encoding |= 0x40;
            }

            // write the encoding.
            WriteByte(null, encoding);

            // write the node id.
            WriteNodeIdBody(encoding, value.Identifier, namespaceIndex);

            // write the namespace uri.
            if ((encoding & 0x80) != 0)
            {
                WriteString(null, value.NamespaceUri);
            }

            // write the server index.
            if ((encoding & 0x40) != 0)
            {
                WriteUInt32(null, serverIndex);
            }
        }

        /// <summary>
        /// Writes an StatusCode to the stream.
        /// </summary>
        public void WriteStatusCode(string fieldName, StatusCode value)
        {
            WriteUInt32(null, value.Code);
        }

        /// <summary>
        /// Writes an DiagnosticInfo to the stream.
        /// </summary>
        public void WriteDiagnosticInfo(string fieldName, DiagnosticInfo value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            // check for null.
            if (value == null)
            {
                WriteByte(null, 0);
                return;
            }

            m_nestingLevel++;

            // calculate the encoding.
            byte encoding = 0;

            if (value.SymbolicId >= 0)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.SymbolicId;
            }

            if (value.NamespaceUri >= 0)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.NamespaceUri;
            }

            if (value.Locale >= 0)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.Locale;
            }

            if (value.LocalizedText >= 0)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.LocalizedText;
            }

            if (value.AdditionalInfo != null)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.AdditionalInfo;
            }

            if (value.InnerStatusCode != StatusCodes.Good)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.InnerStatusCode;
            }

            if (value.InnerDiagnosticInfo != null)
            {
                encoding |= (byte)DiagnosticInfoEncodingBits.InnerDiagnosticInfo;
            }

            // write the encoding.
            WriteByte(null, encoding);

            // write the fields of the diagnostic info structure.
            if ((encoding & (byte)DiagnosticInfoEncodingBits.SymbolicId) != 0)
            {
                WriteInt32(null, value.SymbolicId);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.NamespaceUri) != 0)
            {
                WriteInt32(null, value.NamespaceUri);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.Locale) != 0)
            {
                WriteInt32(null, value.Locale);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.LocalizedText) != 0)
            {
                WriteInt32(null, value.LocalizedText);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.AdditionalInfo) != 0)
            {
                WriteString(null, value.AdditionalInfo);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.InnerStatusCode) != 0)
            {
                WriteStatusCode(null, value.InnerStatusCode);
            }

            if ((encoding & (byte)DiagnosticInfoEncodingBits.InnerDiagnosticInfo) != 0)
            {
                WriteDiagnosticInfo(null, value.InnerDiagnosticInfo);
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an QualifiedName to the stream.
        /// </summary>
        public void WriteQualifiedName(string fieldName, QualifiedName value)
        {
            // check for null.
            if (value == null)
            {
                value = new QualifiedName();
            }

            ushort namespaceIndex = value.NamespaceIndex;

            if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
            {
                namespaceIndex = m_namespaceMappings[namespaceIndex];
            }

            WriteUInt16(null, namespaceIndex);
            WriteString(null, value.Name);
        }

        /// <summary>
        /// Writes an LocalizedText to the stream.
        /// </summary>
        public void WriteLocalizedText(string fieldName, LocalizedText value)
        {
            // check for null.
            if (value == null)
            {
                WriteByte(null, 0);
                return;
            }

            // calculate the encoding.
            byte encoding = 0;

            if (value.Locale != null)
            {
                encoding |= (byte)LocalizedTextEncodingBits.Locale;
            }

            if (value.Text != null)
            {
                encoding |= (byte)LocalizedTextEncodingBits.Text;
            }

            // write the encoding.
            WriteByte(null, encoding);

            // write the fields.
            if ((encoding & (byte)LocalizedTextEncodingBits.Locale) != 0)
            {
                WriteString(null, value.Locale);
            }

            if ((encoding & (byte)LocalizedTextEncodingBits.Text) != 0)
            {
                WriteString(null, value.Text);
            }
        }

        /// <summary>
        /// Writes an Variant to the stream.
        /// </summary>
        public void WriteVariant(string fieldName, Variant value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            WriteVariantValue(fieldName, value);

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValue(string fieldName, DataValue value)
        {
            // check for null.
            if (value == null)
            {
                WriteByte(null, 0);
                return;
            }

            // calculate the encoding.
            byte encoding = 0;

            if (value.Value != null)
            {
                encoding |= (byte)DataValueEncodingBits.Value;
            }

            if (value.StatusCode != StatusCodes.Good)
            {
                encoding |= (byte)DataValueEncodingBits.StatusCode;
            }

            if (value.SourceTimestamp != DateTime.MinValue)
            {
                encoding |= (byte)DataValueEncodingBits.SourceTimestamp;
            }

            if (value.SourcePicoseconds != 0)
            {
                encoding |= (byte)DataValueEncodingBits.SourcePicoseconds;
            }

            if (value.ServerTimestamp != DateTime.MinValue)
            {
                encoding |= (byte)DataValueEncodingBits.ServerTimestamp;
            }

            if (value.ServerPicoseconds != 0)
            {
                encoding |= (byte)DataValueEncodingBits.ServerPicoseconds;
            }

            // write the encoding.
            WriteByte(null, encoding);

            // write the fields of the data value structure.
            if ((encoding & (byte)DataValueEncodingBits.Value) != 0)
            {
                WriteVariant(null, value.WrappedValue);
            }

            if ((encoding & (byte)DataValueEncodingBits.StatusCode) != 0)
            {
                WriteStatusCode(null, value.StatusCode);
            }

            if ((encoding & (byte)DataValueEncodingBits.SourceTimestamp) != 0)
            {
                WriteDateTime(null, value.SourceTimestamp);
            }

            if ((encoding & (byte)DataValueEncodingBits.SourcePicoseconds) != 0)
            {
                WriteUInt16(null, value.SourcePicoseconds);
            }

            if ((encoding & (byte)DataValueEncodingBits.ServerTimestamp) != 0)
            {
                WriteDateTime(null, value.ServerTimestamp);
            }

            if ((encoding & (byte)DataValueEncodingBits.ServerPicoseconds) != 0)
            {
                WriteUInt16(null, value.ServerPicoseconds);
            }
        }

        /// <summary>
        /// Writes an ExtensionObject to the stream.
        /// </summary>
        public void WriteExtensionObject(string fieldName, ExtensionObject value)
        {
            // check for null.
            if (value == null)
            {
                WriteNodeId(null, NodeId.Null);
                WriteByte(null, Convert.ToByte(ExtensionObjectEncoding.None, CultureInfo.InvariantCulture));
                return;
            }

            // write the type id.
            ExpandedNodeId typeId = value.TypeId;

            if (value.Body is IEncodeable encodeable)
            {
                if (value.Encoding == ExtensionObjectEncoding.Xml)
                {
                    typeId = encodeable.XmlEncodingId;
                }
                else
                {
                    typeId = encodeable.BinaryEncodingId;
                }
            }

            NodeId localTypeId = ExpandedNodeId.ToNodeId(typeId, m_context.NamespaceUris);

            if (NodeId.IsNull(localTypeId) && !NodeId.IsNull(typeId))
            {
                if (value.Body is IEncodeable encodeable)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadEncodingError,
                        "Cannot encode bodies of type '{0}' in ExtensionObject unless the NamespaceUri ({1}) is in the encoder's NamespaceTable.",
                        encodeable.GetType().FullName,
                        typeId.NamespaceUri);
                }

                localTypeId = NodeId.Null;
            }

            WriteNodeId(null, localTypeId);

            // determine the encoding type.
            byte encoding = Convert.ToByte(value.Encoding, CultureInfo.InvariantCulture);

            if (value.Encoding == ExtensionObjectEncoding.EncodeableObject)
            {
                encoding = Convert.ToByte(ExtensionObjectEncoding.Binary, CultureInfo.InvariantCulture);
            }

            object body = value.Body;

            if (body == null)
            {
                encoding = Convert.ToByte(ExtensionObjectEncoding.None, CultureInfo.InvariantCulture);
            }

            // write the encoding type.
            WriteByte(null, encoding);

            // nothing more to do for null bodies.
            if (body == null)
            {
                return;
            }

            // write binary bodies.

            if (body is byte[] bytes)
            {
                WriteByteString(null, bytes);
                return;
            }

            // write XML bodies.

            if (body is XmlElement xml)
            {
                WriteXmlElement(null, xml);
                return;
            }

            // write encodeable bodies.
            if (encodeable == null)
            {
                throw new ServiceResultException(
                    StatusCodes.BadEncodingError,
                    Utils.Format("Cannot encode bodies of type '{0}' in extension objects.", body.GetType().FullName));
            }

            // check if it possible to write the extension directly to the stream.
            if (m_writer.BaseStream.CanSeek)
            {
                long start = m_writer.BaseStream.Position;

                // write a placeholder for the body length.
                WriteInt32(null, -1);
                encodeable.Encode(this);

                // update body length.
                long delta = m_writer.BaseStream.Position - start;

                m_writer.Seek((int)-delta, SeekOrigin.Current);
                WriteInt32(null, (int)(delta - 4));
                m_writer.Seek((int)(delta - 4), SeekOrigin.Current);
            }

            // must pre-encode and then write the bytes.
            else
            {
                BinaryEncoder encoder = new BinaryEncoder(this.m_context);
                encoder.WriteEncodeable(null, encodeable, null);
                bytes = encoder.CloseAndReturnBuffer();
                WriteByteString(null, bytes);
            }
        }

        /// <summary>
        /// Writes an encodeable object to the stream.
        /// </summary>
        public void WriteEncodeable(string fieldName, IEncodeable value, System.Type systemType)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            // create a default object if a null object specified.
            if (value == null)
            {
                if (systemType == null) throw new ArgumentNullException(nameof(systemType));
                value = Activator.CreateInstance(systemType) as IEncodeable;
            }

            m_nestingLevel++;

            // encode the object.
            value?.Encode(this);

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an enumerated value array to the stream.
        /// </summary>
        public void WriteEnumerated(string fieldName, Enum value)
        {
            if (value == null) throw new ArgumentNullException(nameof(value));

            WriteInt32(null, Convert.ToInt32(value, CultureInfo.InvariantCulture));
        }

        /// <summary>
        /// Writes a boolean array to the stream.
        /// </summary>
        public void WriteBooleanArray(string fieldName, IList<bool> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteBoolean(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteSByteArray(string fieldName, IList<sbyte> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteSByte(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteByteArray(string fieldName, IList<byte> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteByte(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a short array to the stream.
        /// </summary>
        public void WriteInt16Array(string fieldName, IList<short> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt16(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a ushort array to the stream.
        /// </summary>
        public void WriteUInt16Array(string fieldName, IList<ushort> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt16(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a int array to the stream.
        /// </summary>
        public void WriteInt32Array(string fieldName, IList<int> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt32(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a uint array to the stream.
        /// </summary>
        public void WriteUInt32Array(string fieldName, IList<uint> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt32(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a long array to the stream.
        /// </summary>
        public void WriteInt64Array(string fieldName, IList<long> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt64(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a ulong array to the stream.
        /// </summary>
        public void WriteUInt64Array(string fieldName, IList<ulong> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt64(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a float array to the stream.
        /// </summary>
        public void WriteFloatArray(string fieldName, IList<float> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteFloat(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a double array to the stream.
        /// </summary>
        public void WriteDoubleArray(string fieldName, IList<double> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDouble(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a string array to the stream.
        /// </summary>
        public void WriteStringArray(string fieldName, IList<string> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteString(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a UTC date/time array to the stream.
        /// </summary>
        public void WriteDateTimeArray(string fieldName, IList<DateTime> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDateTime(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Uuid> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteGuid(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Guid> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteGuid(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes a byte string array to the stream.
        /// </summary>
        public void WriteByteStringArray(string fieldName, IList<byte[]> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteByteString(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an XmlElement array to the stream.
        /// </summary>
        public void WriteXmlElementArray(string fieldName, IList<XmlElement> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteXmlElement(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an NodeId array to the stream.
        /// </summary>
        public void WriteNodeIdArray(string fieldName, IList<NodeId> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteNodeId(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an ExpandedNodeId array to the stream.
        /// </summary>
        public void WriteExpandedNodeIdArray(string fieldName, IList<ExpandedNodeId> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteExpandedNodeId(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an StatusCode array to the stream.
        /// </summary>
        public void WriteStatusCodeArray(string fieldName, IList<StatusCode> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteStatusCode(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an DiagnosticInfo array to the stream.
        /// </summary>
        public void WriteDiagnosticInfoArray(string fieldName, IList<DiagnosticInfo> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDiagnosticInfo(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an QualifiedName array to the stream.
        /// </summary>
        public void WriteQualifiedNameArray(string fieldName, IList<QualifiedName> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteQualifiedName(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an LocalizedText array to the stream.
        /// </summary>
        public void WriteLocalizedTextArray(string fieldName, IList<LocalizedText> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteLocalizedText(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteVariantArray(string fieldName, IList<Variant> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteVariant(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValueArray(string fieldName, IList<DataValue> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDataValue(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an extension object array to the stream.
        /// </summary>
        public void WriteExtensionObjectArray(string fieldName, IList<ExtensionObject> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteExtensionObject(null, values[ii]);
            }
        }

        /// <summary>
        /// Writes an encodeable object array to the stream.
        /// </summary>
        public void WriteEncodeableArray(string fieldName, IList<IEncodeable> values, System.Type systemType)
        {
            // write length.
            if (WriteArrayLength((Array)values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteEncodeable(null, values[ii], systemType);
            }
        }

        /// <summary>
        /// Writes an enumerated value array to the stream.
        /// </summary>
        public void WriteEnumeratedArray(string fieldName, Array values, System.Type systemType)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Length; ii++)
            {
                WriteEnumerated(null, (Enum)values.GetValue(ii));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Writes an object array to the stream (converts to Variant first).
        /// </summary>
        private void WriteObjectArray(string fieldName, IList<object> values)
        {
            // write length.
            if (WriteArrayLength(values))
            {
                return;
            }

            // write contents.
            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteVariant(null, new Variant(values[ii]));
            }
        }

        /// <summary>
        /// Write the length of an array. Returns true if the array is empty.
        /// </summary>
        private bool WriteArrayLength<T>(ICollection<T> values)
        {
            // check for null.
            if (values == null)
            {
                WriteInt32(null, -1);
                return true;
            }

            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxArrayLength {0} < {1}",
                    m_context.MaxArrayLength,
                    values.Count);
            }

            // write length.
            WriteInt32(null, values.Count);
            return values.Count == 0;
        }

        /// <summary>
        /// Write the length of an array. Returns true if the array is empty.
        /// </summary>
        private bool WriteArrayLength(Array values)
        {
            // check for null.
            if (values == null)
            {
                WriteInt32(null, -1);
                return true;
            }

            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Length)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxArrayLength {0} < {1}",
                    m_context.MaxArrayLength,
                    values.Length);
            }

            // write length.
            WriteInt32(null, values.Length);
            return values.Length == 0;
        }

        /// <summary>
        /// Returns the node id encoding byte for a node id value.
        /// </summary>
        private static byte GetNodeIdEncoding(IdType idType, object identifier, uint namespaceIndex)
        {
            NodeIdEncodingBits encoding = NodeIdEncodingBits.Numeric;

            switch (idType)
            {
                case IdType.Numeric:
                {
                    uint id = Convert.ToUInt32(identifier, CultureInfo.InvariantCulture);

                    if (id <= Byte.MaxValue && namespaceIndex == 0)
                    {
                        encoding = NodeIdEncodingBits.TwoByte;
                        break;
                    }

                    if (id <= UInt16.MaxValue && namespaceIndex <= Byte.MaxValue)
                    {
                        encoding = NodeIdEncodingBits.FourByte;
                        break;
                    }

                    encoding = NodeIdEncodingBits.Numeric;
                    break;
                }

                case IdType.String:
                {
                    encoding = NodeIdEncodingBits.String;
                    break;
                }

                case IdType.Guid:
                {
                    encoding = NodeIdEncodingBits.Guid;
                    break;
                }

                case IdType.Opaque:
                {
                    encoding = NodeIdEncodingBits.ByteString;
                    break;
                }

                default:
                {
                    throw new ServiceResultException(
                        StatusCodes.BadEncodingError,
                        Utils.Format("NodeId identifier type '{0}' not supported.", idType));
                }
            }

            return Convert.ToByte(encoding, CultureInfo.InvariantCulture);
        }

        /// <summary>
        /// Writes the body of a node id to the stream.
        /// </summary>
        private void WriteNodeIdBody(byte encoding, object identifier, ushort namespaceIndex)
        {
            // write the node id.
            switch ((NodeIdEncodingBits)(0x3F & encoding))
            {
                case NodeIdEncodingBits.TwoByte:
                {
                    WriteByte(null, Convert.ToByte(identifier, CultureInfo.InvariantCulture));
                    break;
                }

                case NodeIdEncodingBits.FourByte:
                {
                    WriteByte(null, Convert.ToByte(namespaceIndex));
                    WriteUInt16(null, Convert.ToUInt16(identifier, CultureInfo.InvariantCulture));
                    break;
                }

                case NodeIdEncodingBits.Numeric:
                {
                    WriteUInt16(null, namespaceIndex);
                    WriteUInt32(null, Convert.ToUInt32(identifier, CultureInfo.InvariantCulture));
                    break;
                }

                case NodeIdEncodingBits.String:
                {
                    WriteUInt16(null, namespaceIndex);
                    WriteString(null, (string)identifier);
                    break;
                }

                case NodeIdEncodingBits.Guid:
                {
                    WriteUInt16(null, namespaceIndex);
                    WriteGuid(null, new Uuid((Guid)identifier));
                    break;
                }

                case NodeIdEncodingBits.ByteString:
                {
                    WriteUInt16(null, namespaceIndex);
                    WriteByteString(null, (byte[])identifier);
                    break;
                }
            }
        }

        /// <summary>
        /// Writes an Variant to the stream.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private void WriteVariantValue(string fieldName, Variant value)
        {
            // check for null.
            if (value.Value == null || value.TypeInfo == null || value.TypeInfo.BuiltInType == BuiltInType.Null)
            {
                WriteByte(null, 0);
                return;
            }

            // encode enums as int32.
            byte encodingByte = (byte)value.TypeInfo.BuiltInType;
            if (value.TypeInfo.BuiltInType == BuiltInType.Enumeration)
            {
                encodingByte = (byte)BuiltInType.Int32;
            }

            object valueToEncode = value.Value;

            if (value.TypeInfo.ValueRank < 0)
            {
                WriteByte(null, encodingByte);

                switch (value.TypeInfo.BuiltInType)
                {
                    case BuiltInType.Boolean: { WriteBoolean(null, (bool)valueToEncode); return; }
                    case BuiltInType.SByte: { WriteSByte(null, (sbyte)valueToEncode); return; }
                    case BuiltInType.Byte: { WriteByte(null, (byte)valueToEncode); return; }
                    case BuiltInType.Int16: { WriteInt16(null, (short)valueToEncode); return; }
                    case BuiltInType.UInt16: { WriteUInt16(null, (ushort)valueToEncode); return; }
                    case BuiltInType.Int32: { WriteInt32(null, (int)valueToEncode); return; }
                    case BuiltInType.UInt32: { WriteUInt32(null, (uint)valueToEncode); return; }
                    case BuiltInType.Int64: { WriteInt64(null, (long)valueToEncode); return; }
                    case BuiltInType.UInt64: { WriteUInt64(null, (ulong)valueToEncode); return; }
                    case BuiltInType.Float: { WriteFloat(null, (float)valueToEncode); return; }
                    case BuiltInType.Double: { WriteDouble(null, (double)valueToEncode); return; }
                    case BuiltInType.String: { WriteString(null, (string)valueToEncode); return; }
                    case BuiltInType.DateTime: { WriteDateTime(null, (DateTime)valueToEncode); return; }
                    case BuiltInType.Guid: { WriteGuid(null, (Uuid)valueToEncode); return; }
                    case BuiltInType.ByteString: { WriteByteString(null, (byte[])valueToEncode); return; }
                    case BuiltInType.XmlElement: { WriteXmlElement(null, (XmlElement)valueToEncode); return; }
                    case BuiltInType.NodeId: { WriteNodeId(null, (NodeId)valueToEncode); return; }
                    case BuiltInType.ExpandedNodeId: { WriteExpandedNodeId(null, (ExpandedNodeId)valueToEncode); return; }
                    case BuiltInType.StatusCode: { WriteStatusCode(null, (StatusCode)valueToEncode); return; }
                    case BuiltInType.QualifiedName: { WriteQualifiedName(null, (QualifiedName)valueToEncode); return; }
                    case BuiltInType.LocalizedText: { WriteLocalizedText(null, (LocalizedText)valueToEncode); return; }
                    case BuiltInType.ExtensionObject: { WriteExtensionObject(null, (ExtensionObject)valueToEncode); return; }
                    case BuiltInType.DataValue: { WriteDataValue(null, (DataValue)valueToEncode); return; }
                    case BuiltInType.Enumeration: { WriteInt32(null, Convert.ToInt32(valueToEncode)); return; }
                }

                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingError,
                    "Unexpected type encountered while encoding a Variant: {0}",
                    value.TypeInfo.BuiltInType);
            }

            if (value.TypeInfo.ValueRank >= 0)
            {
                Matrix matrix = null;

                encodingByte |= (byte)VariantArrayEncodingBits.Array;

                if (value.TypeInfo.ValueRank > 1)
                {
                    encodingByte |= (byte)VariantArrayEncodingBits.ArrayDimensions;
                    matrix = (Matrix)valueToEncode;
                    valueToEncode = matrix.Elements;
                }

                WriteByte(null, encodingByte);

                switch (value.TypeInfo.BuiltInType)
                {
                    case BuiltInType.Boolean: { WriteBooleanArray(null, (bool[])valueToEncode); break; }
                    case BuiltInType.SByte: { WriteSByteArray(null, (sbyte[])valueToEncode); break; }
                    case BuiltInType.Byte: { WriteByteArray(null, (byte[])valueToEncode); break; }
                    case BuiltInType.Int16: { WriteInt16Array(null, (short[])valueToEncode); break; }
                    case BuiltInType.UInt16: { WriteUInt16Array(null, (ushort[])valueToEncode); break; }
                    case BuiltInType.Int32: { WriteInt32Array(null, (int[])valueToEncode); break; }
                    case BuiltInType.UInt32: { WriteUInt32Array(null, (uint[])valueToEncode); break; }
                    case BuiltInType.Int64: { WriteInt64Array(null, (long[])valueToEncode); break; }
                    case BuiltInType.UInt64: { WriteUInt64Array(null, (ulong[])valueToEncode); break; }
                    case BuiltInType.Float: { WriteFloatArray(null, (float[])valueToEncode); break; }
                    case BuiltInType.Double: { WriteDoubleArray(null, (double[])valueToEncode); break; }
                    case BuiltInType.String: { WriteStringArray(null, (string[])valueToEncode); break; }
                    case BuiltInType.DateTime: { WriteDateTimeArray(null, (DateTime[])valueToEncode); break; }
                    case BuiltInType.Guid: { WriteGuidArray(null, (Uuid[])valueToEncode); break; }
                    case BuiltInType.ByteString: { WriteByteStringArray(null, (byte[][])valueToEncode); break; }
                    case BuiltInType.XmlElement: { WriteXmlElementArray(null, (XmlElement[])valueToEncode); break; }
                    case BuiltInType.NodeId: { WriteNodeIdArray(null, (NodeId[])valueToEncode); break; }
                    case BuiltInType.ExpandedNodeId: { WriteExpandedNodeIdArray(null, (ExpandedNodeId[])valueToEncode); break; }
                    case BuiltInType.StatusCode: { WriteStatusCodeArray(null, (StatusCode[])valueToEncode); break; }
                    case BuiltInType.QualifiedName: { WriteQualifiedNameArray(null, (QualifiedName[])valueToEncode); break; }
                    case BuiltInType.LocalizedText: { WriteLocalizedTextArray(null, (LocalizedText[])valueToEncode); break; }
                    case BuiltInType.ExtensionObject: { WriteExtensionObjectArray(null, (ExtensionObject[])valueToEncode); break; }
                    case BuiltInType.DataValue: { WriteDataValueArray(null, (DataValue[])valueToEncode); break; }

                    case BuiltInType.Enumeration:
                    {
                        // Check whether the value to encode is int array.
                        int[] ints = valueToEncode as int[];
                        if (ints == null)
                        {
                            Enum[] enums = valueToEncode as Enum[];
                            if (enums == null)
                            {
                                throw new ServiceResultException(
                                    StatusCodes.BadEncodingError,
                                    Utils.Format("Type '{0}' is not allowed in an Enumeration.", value.GetType().FullName));
                            }
                            ints = new int[enums.Length];
                            for (int ii = 0; ii < enums.Length; ii++)
                            {
                                ints[ii] = (int)(object)enums[ii];
                            }
                        }

                        WriteInt32Array(null, ints);
                        break;
                    }

                    case BuiltInType.Variant:
                    {
                        if (valueToEncode is Variant[] variants)
                        {
                            WriteVariantArray(null, variants);
                            break;
                        }

                        if (valueToEncode is object[] objects)
                        {
                            WriteObjectArray(null, objects);
                            break;
                        }

                        throw ServiceResultException.Create(
                            StatusCodes.BadEncodingError,
                            "Unexpected type encountered while encoding a Matrix: {0}",
                            valueToEncode.GetType());
                    }

                    default:
                    {
                        throw ServiceResultException.Create(
                            StatusCodes.BadEncodingError,
                            "Unexpected type encountered while encoding a Variant: {0}",
                            value.TypeInfo.BuiltInType);
                    }
                }

                // write the dimensions.
                if (value.TypeInfo.ValueRank > 1)
                {
                    WriteInt32Array(null, (int[])matrix.Dimensions);
                }
            }
        }
        #endregion

        #region Private Fields
        private Stream m_ostrm;
        private BinaryWriter m_writer;
        private ServiceMessageContext m_context;
        private ushort[] m_namespaceMappings;
        private ushort[] m_serverMappings;
        private uint m_nestingLevel;
        #endregion
    }

    #region Internal Enumerations
    /// <summary>
    /// The possible values for the node id encoding byte.
    /// </summary>
    internal enum NodeIdEncodingBits
    {
        TwoByte = 0x00,
        FourByte = 0x01,
        Numeric = 0x02,
        String = 0x03,
        Guid = 0x04,
        ByteString = 0x05
    }

    /// <summary>
    /// The possible values for the diagnostic info encoding byte.
    /// </summary>
    [Flags]
    internal enum DiagnosticInfoEncodingBits
    {
        SymbolicId = 0x01,
        NamespaceUri = 0x02,
        LocalizedText = 0x04,
        Locale = 0x08,
        AdditionalInfo = 0x10,
        InnerStatusCode = 0x20,
        InnerDiagnosticInfo = 0x40,
    }

    /// <summary>
    /// The possible values for the localized text encoding byte.
    /// </summary>
    [Flags]
    internal enum LocalizedTextEncodingBits
    {
        Locale = 0x01,
        Text = 0x02
    }

    /// <summary>
    /// The possible values for the data value encoding byte.
    /// </summary>
    [Flags]
    internal enum DataValueEncodingBits
    {
        Value = 0x01,
        StatusCode = 0x02,
        SourceTimestamp = 0x04,
        ServerTimestamp = 0x08,
        SourcePicoseconds = 0x10,
        ServerPicoseconds = 0x20
    }

    /// <summary>
    /// The possible values for the data value encoding byte.
    /// </summary>
    [Flags]
    internal enum ExtensionObjectEncodingBits
    {
        TypeId = 0x01,
        BinaryBody = 0x02,
        XmlBody = 0x04
    }

    /// <summary>
    /// The possible values for Variant encoding bits.
    /// </summary>
    [Flags]
    internal enum VariantArrayEncodingBits
    {
        Array = 0x80,
        ArrayDimensions = 0x40,
        TypeMask = 0x3F
    }
    #endregion
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\BinaryEncoder.cs(930,47): error CS0136: A local or parameter named 'encodeable' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\BinaryEncoder.cs(985,17): error CS0165: Use of unassigned local variable 'encodeable'
######################################################################


######################################################################
Nr: 22 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\EncodableObject.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
	/// A concrete base class used by the autogenerated code.
	/// </summary>
    [DataContract(Name = "EncodeableObject", Namespace = Namespaces.OpcUaXsd)]
    public abstract class EncodeableObject : IEncodeable
    {
        #region IEncodeable Methods
        /// <summary cref="IEncodeable.TypeId" />
        public abstract ExpandedNodeId TypeId { get; }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public abstract ExpandedNodeId BinaryEncodingId { get; }

        /// <summary cref="IEncodeable.XmlEncodingId" />
        public abstract ExpandedNodeId XmlEncodingId { get; }

        /// <summary cref="IEncodeable.Encode" />
        public virtual void Encode(IEncoder encoder) { }

        /// <summary cref="IEncodeable.Decode" />
		public virtual void Decode(IDecoder decoder) { }

        /// <summary>
        /// Checks if the value has changed.
        /// </summary>
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            throw new NotImplementedException("Subclass must implement this method.");
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Applies the data encoding to the value.
        /// </summary>
        public static ServiceResult ApplyDataEncoding(ServiceMessageContext context, QualifiedName dataEncoding, ref object value)
        {
            // check if nothing to do.
            if (QualifiedName.IsNull(dataEncoding) || value == null)
            {
                return ServiceResult.Good;
            }

            // check for supported encoding type.
            if (dataEncoding.NamespaceIndex != 0)
            {
                return StatusCodes.BadDataEncodingUnsupported;
            }

            bool useXml = dataEncoding.Name == BrowseNames.DefaultXml;

            if (!useXml && dataEncoding.Name != BrowseNames.DefaultBinary)
            {
                return StatusCodes.BadDataEncodingInvalid;
            }

            try
            {
                // check for array of encodeables.
                IList<IEncodeable> encodeables = value as IList<IEncodeable>;

                if (encodeables == null)
                {
                    // check for array of extension objects.
                    IList<ExtensionObject> extensions = value as IList<ExtensionObject>;

                    if (extensions != null)
                    {
                        // convert extension objects to encodeables.
                        encodeables = new IEncodeable[extensions.Count];

                        for (int ii = 0; ii < encodeables.Count; ii++)
                        {
                            if (ExtensionObject.IsNull(extensions[ii]))
                            {
                                encodeables[ii] = null;
                                continue;
                            }

                            IEncodeable element = extensions[ii].Body as IEncodeable;

                            if (element == null)
                            {
                                return StatusCodes.BadTypeMismatch;
                            }

                            encodeables[ii] = element;
                        }
                    }
                }

                // apply data encoding to the array.
                if (encodeables != null)
                {
                    ExtensionObject[] extensions = new ExtensionObject[encodeables.Count];

                    for (int ii = 0; ii < extensions.Length; ii++)
                    {
                        extensions[ii] = Encode(context, encodeables[ii], useXml);
                    }

                    value = extensions;
                    return ServiceResult.Good;
                }

                // check for scalar value.
                IEncodeable encodeable = value as IEncodeable;

                if (encodeable == null)
                {
                    ExtensionObject extension = value as ExtensionObject;

                    if (extension == null)
                    {
                        return StatusCodes.BadDataEncodingUnsupported;
                    }

                    encodeable = extension.Body as IEncodeable;
                }

                if (encodeable == null)
                {
                    return StatusCodes.BadDataEncodingUnsupported;
                }

                // do conversion.
                value = Encode(context, encodeable, useXml);
                return ServiceResult.Good;
            }
            catch (Exception e)
            {
                return ServiceResult.Create(e, StatusCodes.BadTypeMismatch, "Could not convert value to requested format.");
            }
        }

        /// <summary>
        /// Encodes the object in XML or Binary
        /// </summary>
        public static ExtensionObject Encode(ServiceMessageContext context, IEncodeable encodeable, bool useXml)
        {
            if (useXml)
            {
                XmlElement body = EncodeableObject.EncodeXml(encodeable, context);
                return new ExtensionObject(encodeable.XmlEncodingId, body);
            }
            else
            {
                byte[] body = EncodeableObject.EncodeBinary(encodeable, context);
                return new ExtensionObject(encodeable.BinaryEncodingId, body);
            }
        }

        /// <summary>
        /// Encodes the object in XML.
        /// </summary>
        public static XmlElement EncodeXml(IEncodeable encodeable, ServiceMessageContext context)
        {
            // create encoder.
            XmlEncoder encoder = new XmlEncoder(context);

            // write body.
            encoder.WriteExtensionObjectBody(encodeable);

            // create document from encoder.
            XmlDocument document = new XmlDocument();
            document.InnerXml = encoder.Close();

            // return root element.
            return document.DocumentElement;
        }

        /// <summary>
        /// Encodes the object in binary
        /// </summary>
        public static byte[] EncodeBinary(IEncodeable encodeable, ServiceMessageContext context)
        {
            BinaryEncoder encoder = new BinaryEncoder(context);
            encoder.WriteEncodeable(null, encodeable, null);
            return encoder.CloseAndReturnBuffer();
        }
        #endregion

        /// <summary>
        /// Returns a deep copy of an encodeable object.
        /// </summary>
        public new object MemberwiseClone()
        {
            return base.MemberwiseClone();
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Runtime.Serialization;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
	/// A concrete base class used by the autogenerated code.
	/// </summary>
    [DataContract(Name = "EncodeableObject", Namespace = Namespaces.OpcUaXsd)]
    public abstract class EncodeableObject : IEncodeable
    {
        #region IEncodeable Methods
        /// <summary cref="IEncodeable.TypeId" />
        public abstract ExpandedNodeId TypeId { get; }

        /// <summary cref="IEncodeable.BinaryEncodingId" />
        public abstract ExpandedNodeId BinaryEncodingId { get; }

        /// <summary cref="IEncodeable.XmlEncodingId" />
        public abstract ExpandedNodeId XmlEncodingId { get; }

        /// <summary cref="IEncodeable.Encode" />
        public virtual void Encode(IEncoder encoder) { }

        /// <summary cref="IEncodeable.Decode" />
		public virtual void Decode(IDecoder decoder) { }

        /// <summary>
        /// Checks if the value has changed.
        /// </summary>
        public virtual bool IsEqual(IEncodeable encodeable)
        {
            throw new NotImplementedException("Subclass must implement this method.");
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Applies the data encoding to the value.
        /// </summary>
        public static ServiceResult ApplyDataEncoding(ServiceMessageContext context, QualifiedName dataEncoding, ref object value)
        {
            // check if nothing to do.
            if (QualifiedName.IsNull(dataEncoding) || value == null)
            {
                return ServiceResult.Good;
            }

            // check for supported encoding type.
            if (dataEncoding.NamespaceIndex != 0)
            {
                return StatusCodes.BadDataEncodingUnsupported;
            }

            bool useXml = dataEncoding.Name == BrowseNames.DefaultXml;

            if (!useXml && dataEncoding.Name != BrowseNames.DefaultBinary)
            {
                return StatusCodes.BadDataEncodingInvalid;
            }

            try
            {
                // check for array of encodeables.

                if (encodeables == null)
                {
                    // check for array of extension objects.

                    if (value is IList<ExtensionObject> extensions)
                    {
                        // convert extension objects to encodeables.
                        encodeables = new IEncodeable[extensions.Count];

                        for (int ii = 0; ii < encodeables.Count; ii++)
                        {
                            if (ExtensionObject.IsNull(extensions[ii]))
                            {
                                encodeables[ii] = null;
                                continue;
                            }

                            IEncodeable element = extensions[ii].Body as IEncodeable;

                            if (element == null)
                            {
                                return StatusCodes.BadTypeMismatch;
                            }

                            encodeables[ii] = element;
                        }
                    }
                }

                // apply data encoding to the array.
                if (value is IList<IEncodeable> encodeables)
                {
                    ExtensionObject[] extensions = new ExtensionObject[encodeables.Count];

                    for (int ii = 0; ii < extensions.Length; ii++)
                    {
                        extensions[ii] = Encode(context, encodeables[ii], useXml);
                    }

                    value = extensions;
                    return ServiceResult.Good;
                }

                // check for scalar value.
                IEncodeable encodeable = value as IEncodeable;

                if (encodeable == null)
                {
                    ExtensionObject extension = value as ExtensionObject;

                    if (extension == null)
                    {
                        return StatusCodes.BadDataEncodingUnsupported;
                    }

                    encodeable = extension.Body as IEncodeable;
                }

                if (encodeable == null)
                {
                    return StatusCodes.BadDataEncodingUnsupported;
                }

                // do conversion.
                value = Encode(context, encodeable, useXml);
                return ServiceResult.Good;
            }
            catch (Exception e)
            {
                return ServiceResult.Create(e, StatusCodes.BadTypeMismatch, "Could not convert value to requested format.");
            }
        }

        /// <summary>
        /// Encodes the object in XML or Binary
        /// </summary>
        public static ExtensionObject Encode(ServiceMessageContext context, IEncodeable encodeable, bool useXml)
        {
            if (useXml)
            {
                XmlElement body = EncodeableObject.EncodeXml(encodeable, context);
                return new ExtensionObject(encodeable.XmlEncodingId, body);
            }
            else
            {
                byte[] body = EncodeableObject.EncodeBinary(encodeable, context);
                return new ExtensionObject(encodeable.BinaryEncodingId, body);
            }
        }

        /// <summary>
        /// Encodes the object in XML.
        /// </summary>
        public static XmlElement EncodeXml(IEncodeable encodeable, ServiceMessageContext context)
        {
            // create encoder.
            XmlEncoder encoder = new XmlEncoder(context);

            // write body.
            encoder.WriteExtensionObjectBody(encodeable);

            // create document from encoder.
            XmlDocument document = new XmlDocument();
            document.InnerXml = encoder.Close();

            // return root element.
            return document.DocumentElement;
        }

        /// <summary>
        /// Encodes the object in binary
        /// </summary>
        public static byte[] EncodeBinary(IEncodeable encodeable, ServiceMessageContext context)
        {
            BinaryEncoder encoder = new BinaryEncoder(context);
            encoder.WriteEncodeable(null, encodeable, null);
            return encoder.CloseAndReturnBuffer();
        }
        #endregion

        /// <summary>
        /// Returns a deep copy of an encodeable object.
        /// </summary>
        public new object MemberwiseClone()
        {
            return base.MemberwiseClone();
        }
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\EncodableObject.cs(80,21): error CS0841: Cannot use local variable 'encodeables' before it is declared,D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\EncodableObject.cs(87,25): error CS0841: Cannot use local variable 'encodeables' before it is declared,D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\EncodableObject.cs(89,47): error CS0841: Cannot use local variable 'encodeables' before it is declared,D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\EncodableObject.cs(93,33): error CS0841: Cannot use local variable 'encodeables' before it is declared,D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\EncodableObject.cs(104,29): error CS0841: Cannot use local variable 'encodeables' before it is declared
######################################################################


######################################################################
Nr: 23 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\JsonDecoder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using Newtonsoft.Json;

namespace Opc.Ua
{
    /// <summary>
    /// Reads objects from a JSON stream.
    /// </summary>
    public class JsonDecoder : IDecoder, IDisposable
    {
        #region Private Fields
        private JsonTextReader m_reader;
        private Dictionary<string, object> m_root;
        private Stack<object> m_stack;
        private ServiceMessageContext m_context;
        private ushort[] m_namespaceMappings;
        private ushort[] m_serverMappings;
        private uint m_nestingLevel;
        // JSON encoded value of: 9999-12-31T23:59:59Z
        private DateTime m_dateTimeMaxJsonValue = new DateTime((long)3155378975990000000);
        private enum JTokenNullObject
        {
            Undefined = 0,
            Object = 1,
            Array = 2
        };
        #endregion

        #region Constructors
        /// <summary>
        /// Create a JSON decoder to decode a string.
        /// </summary>
        /// <param name="json">The JSON encoded string.</param>
        /// <param name="context">The service message context to use.</param>
        public JsonDecoder(string json, ServiceMessageContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }
            Initialize();

            m_context = context;
            m_nestingLevel = 0;
            m_reader = new JsonTextReader(new StringReader(json));
            m_root = ReadObject();
            m_stack = new Stack<object>();
            m_stack.Push(m_root);
        }

        /// <summary>
        /// Create a JSON decoder to decode a <see cref="Type"/>from a <see cref="JsonTextReader"/>.
        /// </summary>
        /// <param name="systemType">The system type of the encoded JSON stram.</param>
        /// <param name="reader">The text reader.</param>
        /// <param name="context">The service message context to use.</param>
        public JsonDecoder(Type systemType, JsonTextReader reader, ServiceMessageContext context)
        {
            Initialize();

            m_context = context;
            m_nestingLevel = 0;
            m_reader = reader;
            m_root = ReadObject();
            m_stack = new Stack<object>();
            m_stack.Push(m_root);
        }

        /// <summary>
        /// Sets private members to default values.
        /// </summary>
        private void Initialize()
        {
            m_reader = null;
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Decodes a session-less message from a buffer.
        /// </summary>
        public static IEncodeable DecodeSessionLessMessage(byte[] buffer, ServiceMessageContext context)
        {
            if (buffer == null) throw new ArgumentNullException(nameof(buffer));
            if (context == null) throw new ArgumentNullException(nameof(context));

            JsonDecoder decoder = new JsonDecoder(UTF8Encoding.UTF8.GetString(buffer), context);

            try
            {
                // decode the actual message.
                SessionLessServiceMessage message = new SessionLessServiceMessage();
                message.Decode(decoder);
                return message.Message;
            }
            finally
            {
                decoder.Close();
            }
        }

        /// <summary>
        /// Decodes a message from a buffer.
        /// </summary>
        public static IEncodeable DecodeMessage(byte[] buffer, System.Type expectedType, ServiceMessageContext context)
        {
            return DecodeMessage(new ArraySegment<byte>(buffer), expectedType, context);
        }

        /// <summary>
        /// Decodes a message from a buffer.
        /// </summary>
        public static IEncodeable DecodeMessage(ArraySegment<byte> buffer, System.Type expectedType, ServiceMessageContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }

            // check that the max message size was not exceeded.
            if (context.MaxMessageSize > 0 && context.MaxMessageSize < buffer.Count)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxMessageSize {0} < {1}",
                    context.MaxMessageSize,
                    buffer.Count);
            }

            JsonDecoder decoder = new JsonDecoder(UTF8Encoding.UTF8.GetString(buffer.Array, buffer.Offset, buffer.Count), context);

            try
            {
                return decoder.DecodeMessage(expectedType);
            }
            finally
            {
                decoder.Close();
            }
        }

        /// <summary>
        /// Decodes an object from a buffer.
        /// </summary>
        public IEncodeable DecodeMessage(System.Type expectedType)
        {
            var namespaceUris = ReadStringArray("NamespaceUris");
            var serverUris = ReadStringArray("ServerUris");

            if ((namespaceUris != null && namespaceUris.Count > 0) || (serverUris != null && serverUris.Count > 0))
            {
                var namespaces = (namespaceUris == null || namespaceUris.Count == 0) ? m_context.NamespaceUris : new NamespaceTable(namespaceUris);
                var servers = (serverUris == null || serverUris.Count == 0) ? m_context.ServerUris : new StringTable(serverUris);

                SetMappingTables(namespaces, servers);
            }

            // read the node id.
            NodeId typeId = ReadNodeId("TypeId");

            // convert to absolute node id.
            ExpandedNodeId absoluteId = NodeId.ToExpandedNodeId(typeId, m_context.NamespaceUris);

            // lookup message type.
            Type actualType = m_context.Factory.GetSystemType(absoluteId);

            if (actualType == null)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingError, Utils.Format("Cannot decode message with type id: {0}.", absoluteId));
            }

            // read the message.
            IEncodeable message = ReadEncodeable("Body", actualType);

            // return the message.
            return message;
        }


        /// <summary>
        /// Initializes the tables used to map namespace and server uris during decoding.
        /// </summary>
        /// <param name="namespaceUris">The namespaces URIs referenced by the data being decoded.</param>
        /// <param name="serverUris">The server URIs referenced by the data being decoded.</param>
        public void SetMappingTables(NamespaceTable namespaceUris, StringTable serverUris)
        {
            m_namespaceMappings = null;

            if (namespaceUris != null && m_context.NamespaceUris != null)
            {
                m_namespaceMappings = m_context.NamespaceUris.CreateMapping(namespaceUris, false);
            }

            m_serverMappings = null;

            if (serverUris != null && m_context.ServerUris != null)
            {
                m_serverMappings = m_context.ServerUris.CreateMapping(serverUris, false);
            }
        }

        /// <summary>
        /// Closes the stream used for reading.
        /// </summary>
        public void Close()
        {
            m_reader.Close();
        }

        /// <summary>
        /// Closes the stream used for reading.
        /// </summary>
        public void Close(bool checkEof)
        {
            if (checkEof && m_reader.TokenType != JsonToken.EndObject)
            {
                while (m_reader.Read() && m_reader.TokenType != JsonToken.EndObject)
                {
                    ;
                }
            }

            m_reader.Close();
        }

        private List<object> ReadArray()
        {
            List<object> elements = new List<object>();

            while (m_reader.Read() && m_reader.TokenType != JsonToken.EndArray)
            {
                switch (m_reader.TokenType)
                {
                    case JsonToken.Comment:
                    {
                        break;
                    }

                    case JsonToken.Null:
                    {
                        elements.Add(JTokenNullObject.Array);
                        break;
                    }
                    case JsonToken.Date:
                    case JsonToken.Boolean:
                    case JsonToken.Integer:
                    case JsonToken.Float:
                    case JsonToken.String:
                    {
                        elements.Add(m_reader.Value);
                        break;
                    }

                    case JsonToken.StartArray:
                    {
                        elements.Add(ReadArray());
                        break;
                    }

                    case JsonToken.StartObject:
                    {
                        elements.Add(ReadObject());
                        break;
                    }

                    default:
                        break;
                }
            }

            return elements;
        }

        private Dictionary<string, object> ReadObject()
        {
            Dictionary<string, object> fields = new Dictionary<string, object>();

            while (m_reader.Read() && m_reader.TokenType != JsonToken.EndObject)
            {
                if (m_reader.TokenType == JsonToken.PropertyName)
                {
                    string name = (string)m_reader.Value;

                    if (m_reader.Read() && m_reader.TokenType != JsonToken.EndObject)
                    {
                        switch (m_reader.TokenType)
                        {
                            case JsonToken.Comment:
                            {
                                break;
                            }

                            case JsonToken.Null:
                            {
                                fields[name] = JTokenNullObject.Object;
                                break;
                            }

                            case JsonToken.Date:
                            case JsonToken.Bytes:
                            case JsonToken.Boolean:
                            case JsonToken.Integer:
                            case JsonToken.Float:
                            case JsonToken.String:
                            {
                                fields[name] = m_reader.Value;
                                break;
                            }

                            case JsonToken.StartArray:
                            {
                                fields[name] = ReadArray();
                                break;
                            }

                            case JsonToken.StartObject:
                            {
                                fields[name] = ReadObject();
                                break;
                            }

                            default:
                                break;
                        }
                    }
                }
            }

            return fields;
        }

        /// <summary>
        /// Reads the body extension object from the stream.
        /// </summary>
        public object ReadExtensionObjectBody(ExpandedNodeId typeId)
        {
            return null;
        }
        #endregion

        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                m_reader?.Close();
            }
        }
        #endregion

        #region IDecoder Members
        /// <summary>
        /// The type of encoding being used.
        /// </summary>
        public EncodingType EncodingType => EncodingType.Json;

        /// <summary>
        /// The message context associated with the decoder.
        /// </summary>
        public ServiceMessageContext Context => m_context;

        /// <summary>
        /// Pushes a namespace onto the namespace stack.
        /// </summary>
        public void PushNamespace(string namespaceUri)
        {
        }

        /// <summary>
        /// Pops a namespace from the namespace stack.
        /// </summary>
        public void PopNamespace()
        {
        }

        /// <summary>
        /// Read a decoded JSON field.
        /// </summary>
        /// <param name="fieldName">The name of the field.</param>
        /// <param name="token">The returned object token of the field.</param>
        public bool ReadField(string fieldName, out object token)
        {
            token = null;

            if (String.IsNullOrEmpty(fieldName))
            {
                token = m_stack.Peek();
                return true;
            }

            var context = m_stack.Peek() as Dictionary<string, object>;

            if (context == null || !context.TryGetValue(fieldName, out token))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Reads a boolean from the stream.
        /// </summary>
        public bool ReadBoolean(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return false;
            }

            var value = token as bool?;

            if (value == null)
            {
                return false;
            }

            return (bool)token;
        }

        /// <summary>
        /// Reads a sbyte from the stream.
        /// </summary>
        public sbyte ReadSByte(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                return 0;
            }

            if (value < SByte.MinValue || value > SByte.MaxValue)
            {
                return 0;
            }

            return (sbyte)value;
        }

        /// <summary>
        /// Reads a byte from the stream.
        /// </summary>
        public byte ReadByte(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                return 0;
            }

            if (value < Byte.MinValue || value > Byte.MaxValue)
            {
                return 0;
            }

            return (byte)value;
        }

        /// <summary>
        /// Reads a short from the stream.
        /// </summary>
        public short ReadInt16(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                return 0;
            }
;
            if (value < Int16.MinValue || value > Int16.MaxValue)
            {
                return 0;
            }

            return (short)value;
        }

        /// <summary>
        /// Reads a ushort from the stream.
        /// </summary>
        public ushort ReadUInt16(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                return 0;
            }

            if (value < UInt16.MinValue || value > UInt16.MaxValue)
            {
                return 0;
            }

            return (ushort)value;
        }

        /// <summary>
        /// Reads an int from the stream.
        /// </summary>
        public int ReadInt32(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                return 0;
            }

            if (value < Int32.MinValue || value > Int32.MaxValue)
            {
                return 0;
            }

            return (int)value;
        }

        /// <summary>
        /// Reads a uint from the stream.
        /// </summary>
        public uint ReadUInt32(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                var text = token as string;
                uint number = 0;

                if (text == null || !UInt32.TryParse(text, NumberStyles.Integer, CultureInfo.InvariantCulture, out number))
                {
                    return 0;
                }

                return number;
            }

            if (value < UInt32.MinValue || value > UInt32.MaxValue)
            {
                return 0;
            }

            return (uint)value;
        }

        /// <summary>
        /// Reads a long from the stream.
        /// </summary>
        public long ReadInt64(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                var text = token as string;
                long number = 0;

                if (text == null || !Int64.TryParse(text, NumberStyles.Integer, CultureInfo.InvariantCulture, out number))
                {
                    return 0;
                }

                return number;
            }

            if (value < Int64.MinValue || value > Int64.MaxValue)
            {
                return 0;
            }

            return (long)value;
        }

        /// <summary>
        /// Reads a ulong from the stream.
        /// </summary>
        public ulong ReadUInt64(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                var text = token as string;
                ulong number = 0;

                if (text == null || !UInt64.TryParse(text,
                    NumberStyles.Integer,
                    CultureInfo.InvariantCulture, out number))
                {
                    return 0;
                }

                return number;
            }

            if (value < 0)
            {
                return 0;
            }

            return (ulong)value;
        }

        /// <summary>
        /// Reads a float from the stream.
        /// </summary>
        public float ReadFloat(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as double?;

            if (value == null)
            {
                var text = token as string;
                float number = 0;
                if (text == null || !Single.TryParse(text, NumberStyles.Float, CultureInfo.InvariantCulture, out number))
                {
                    if (text != null)
                    {
                        if (String.Compare(text, "Infinity", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Single.PositiveInfinity;
                        }
                        else if (String.Compare(text, "-Infinity", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Single.NegativeInfinity;
                        }
                        else if (String.Compare(text, "NaN", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Single.NaN;
                        }
                    }

                    var integer = token as long?;
                    if (integer == null)
                    {
                        return 0;
                    }

                    return (float)integer;
                }

                return number;
            }

            float floatValue = (float)value;
            if (floatValue >= Single.MinValue && floatValue <= Single.MaxValue)
            {
                return (float)value;
            }

            return 0;
        }

        /// <summary>
        /// Reads a double from the stream.
        /// </summary>
        public double ReadDouble(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as double?;

            if (value == null)
            {
                var text = token as string;
                double number = 0;

                if (text == null || !Double.TryParse(text, NumberStyles.Float, CultureInfo.InvariantCulture, out number))
                {
                    if (text != null)
                    {
                        if (String.Compare(text, "Infinity", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Double.PositiveInfinity;
                        }
                        else if (String.Compare(text, "-Infinity", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Double.NegativeInfinity;
                        }
                        else if (String.Compare(text, "NaN", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Double.NaN;
                        }
                    }

                    var integer = token as long?;

                    if (integer == null)
                    {
                        return 0;
                    }

                    return (double)integer;
                }

                return number;
            }

            return (double)value;
        }

        /// <summary>
        /// Reads a string from the stream.
        /// </summary>
        public string ReadString(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            var value = token as string;

            if (value == null)
            {
                return null;
            }

            if (m_context.MaxStringLength > 0 && m_context.MaxStringLength < value.Length)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            return (string)value;
        }

        /// <summary>
        /// Reads a UTC date/time from the stream.
        /// </summary>
        public DateTime ReadDateTime(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return DateTime.MinValue;
            }

            var value = token as DateTime?;
            if (value != null)
            {
                return value.Value >= m_dateTimeMaxJsonValue ? DateTime.MaxValue : value.Value;
            }

            var text = token as string;
            if (text != null)
            {
                var result = XmlConvert.ToDateTime(text, XmlDateTimeSerializationMode.Utc);
                return result >= m_dateTimeMaxJsonValue ? DateTime.MaxValue : result;
            }

            return DateTime.MinValue;
        }

        /// <summary>
        /// Reads a GUID from the stream.
        /// </summary>
        public Uuid ReadGuid(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return Uuid.Empty;
            }

            var value = token as string;

            if (value == null)
            {
                return Uuid.Empty;
            }

            return new Uuid(value);
        }

        /// <summary>
        /// Reads a byte string from the stream.
        /// </summary>
        public byte[] ReadByteString(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            if (token is JTokenNullObject)
            {
                return null;
            }

            var value = token as string;
            if (value == null)
            {
                return new byte[0];
            }

            var bytes = Convert.FromBase64String(value);

            if (m_context.MaxByteStringLength > 0 && m_context.MaxByteStringLength < bytes.Length)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            return bytes;
        }


        /// <summary>
        /// Reads an XmlElement from the stream.
        /// </summary>
        public XmlElement ReadXmlElement(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            var value = token as string;

            if (value == null)
            {
                return null;
            }

            var bytes = Convert.FromBase64String(value);

            if (bytes != null && bytes.Length > 0)
            {
                XmlDocument document = new XmlDocument();
                string xmlString = new UTF8Encoding().GetString(bytes, 0, bytes.Length);

                using (XmlReader reader = XmlReader.Create(new StringReader(xmlString),
                    new XmlReaderSettings() { DtdProcessing = System.Xml.DtdProcessing.Prohibit }))
                {
                    document.Load(reader);
                }

                return document.DocumentElement;
            }

            return null;
        }

        /// <summary>
        /// Reads an NodeId from the stream.
        /// </summary>
        public NodeId ReadNodeId(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return NodeId.Null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return NodeId.Null;
            }

            IdType idType = IdType.Numeric;
            ushort namespaceIndex = 0;

            try
            {
                m_stack.Push(value);

                if (value.ContainsKey("IdType"))
                {
                    idType = (IdType)ReadInt32("IdType");
                }

                if (value.ContainsKey("Namespace"))
                {
                    namespaceIndex = ReadUInt16("Namespace");
                }

                if (value.ContainsKey("Id"))
                {
                    switch (idType)
                    {
                        case IdType.Numeric:
                        default:
                        {
                            return new NodeId(ReadUInt32("Id"), namespaceIndex);
                        }

                        case IdType.Opaque:
                        {
                            return new NodeId(ReadByteString("Id"), namespaceIndex);
                        }

                        case IdType.String:
                        {
                            return new NodeId(ReadString("Id"), namespaceIndex);
                        }

                        case IdType.Guid:
                        {
                            return new NodeId(ReadGuid("Id"), namespaceIndex);
                        }

                    }
                }
                return DefaultNodeId(idType, namespaceIndex);
            }
            finally
            {
                m_stack.Pop();
            }
        }

        /// <summary>
        /// Reads an ExpandedNodeId from the stream.
        /// </summary>
        public ExpandedNodeId ReadExpandedNodeId(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return ExpandedNodeId.Null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return ExpandedNodeId.Null;
            }

            IdType idType = IdType.Numeric;
            ushort namespaceIndex = 0;
            string namespaceUri = null;
            uint serverIndex = 0;

            try
            {
                m_stack.Push(value);

                if (value.ContainsKey("IdType"))
                {
                    idType = (IdType)ReadInt32("IdType");
                }

                object namespaceToken = null;

                if (ReadField("Namespace", out namespaceToken))
                {
                    var index = namespaceToken as long?;

                    if (index == null)
                    {
                        namespaceUri = namespaceToken as string;
                    }
                    else
                    {
                        if (index.Value >= 0 || index.Value < UInt16.MaxValue)
                        {
                            namespaceIndex = (ushort)index.Value;
                        }
                    }
                }

                if (value.ContainsKey("ServerUri"))
                {
                    serverIndex = ReadUInt32("ServerUri");
                }

                if (value.ContainsKey("Id"))
                {
                    switch (idType)
                    {
                        case IdType.Numeric:
                        default:
                        {
                            return new ExpandedNodeId(ReadUInt32("Id"), namespaceIndex, namespaceUri, serverIndex);
                        }

                        case IdType.Opaque:
                        {
                            return new ExpandedNodeId(ReadByteString("Id"), namespaceIndex, namespaceUri, serverIndex);
                        }

                        case IdType.String:
                        {
                            return new ExpandedNodeId(ReadString("Id"), namespaceIndex, namespaceUri, serverIndex);
                        }

                        case IdType.Guid:
                        {
                            return new ExpandedNodeId(ReadGuid("Id"), namespaceIndex, namespaceUri, serverIndex);
                        }
                    }
                }

                return new ExpandedNodeId(DefaultNodeId(idType, namespaceIndex), namespaceUri, serverIndex);
            }
            finally
            {
                m_stack.Pop();
            }
        }


        /// <summary>
        /// Reads an StatusCode from the stream.
        /// </summary>
        public StatusCode ReadStatusCode(string fieldName)
        {
            return ReadUInt32(fieldName);
        }

        /// <summary>
        /// Reads an DiagnosticInfo from the stream.
        /// </summary>
        public DiagnosticInfo ReadDiagnosticInfo(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return null;
            }

            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            try
            {
                m_nestingLevel++;
                m_stack.Push(value);

                DiagnosticInfo di = new DiagnosticInfo();

                if (value.ContainsKey("SymbolicId"))
                {
                    di.SymbolicId = ReadInt32("SymbolicId");
                }

                if (value.ContainsKey("NamespaceUri"))
                {
                    di.NamespaceUri = ReadInt32("NamespaceUri");
                }

                if (value.ContainsKey("Locale"))
                {
                    di.Locale = ReadInt32("Locale");
                }

                if (value.ContainsKey("LocalizedText"))
                {
                    di.LocalizedText = ReadInt32("LocalizedText");
                }

                if (value.ContainsKey("AdditionalInfo"))
                {
                    di.AdditionalInfo = ReadString("AdditionalInfo");
                }

                if (value.ContainsKey("InnerStatusCode"))
                {
                    di.InnerStatusCode = ReadStatusCode("InnerStatusCode");
                }

                if (value.ContainsKey("InnerDiagnosticInfo"))
                {
                    di.InnerDiagnosticInfo = ReadDiagnosticInfo("InnerDiagnosticInfo");
                }

                return di;
            }
            finally
            {
                m_nestingLevel--;
                m_stack.Pop();
            }
        }

        /// <summary>
        /// Reads an QualifiedName from the stream.
        /// </summary>
        public QualifiedName ReadQualifiedName(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return QualifiedName.Null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return QualifiedName.Null;
            }

            UInt16 namespaceIndex = 0;
            string name = null;
            try
            {
                m_stack.Push(value);

                if (value.ContainsKey("Name"))
                {
                    name = ReadString("Name");
                }

                if (value.ContainsKey("Uri"))
                {
                    namespaceIndex = ReadUInt16("Uri");
                }
            }
            finally
            {
                m_stack.Pop();
            }

            return new QualifiedName(name, namespaceIndex);
        }

        /// <summary>
        /// Reads an LocalizedText from the stream.
        /// </summary>
        public LocalizedText ReadLocalizedText(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return LocalizedText.Null;
            }

            string locale = null;
            string text = null;

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                text = token as string;

                if (text != null)
                {
                    return new LocalizedText(text);
                }

                return LocalizedText.Null;
            }

            try
            {
                m_stack.Push(value);

                if (value.ContainsKey("Locale"))
                {
                    locale = ReadString("Locale");
                }

                if (value.ContainsKey("Text"))
                {
                    text = ReadString("Text");
                }
            }
            finally
            {
                m_stack.Pop();
            }

            return new LocalizedText(locale, text);
        }

        private Variant ReadVariantBody(string fieldName, BuiltInType type)
        {
            switch (type)
            {
                case BuiltInType.Boolean: { return new Variant(ReadBoolean(fieldName), TypeInfo.Scalars.Boolean); }
                case BuiltInType.SByte: { return new Variant(ReadSByte(fieldName), TypeInfo.Scalars.SByte); }
                case BuiltInType.Byte: { return new Variant(ReadByte(fieldName), TypeInfo.Scalars.Byte); }
                case BuiltInType.Int16: { return new Variant(ReadInt16(fieldName), TypeInfo.Scalars.Int16); }
                case BuiltInType.UInt16: { return new Variant(ReadUInt16(fieldName), TypeInfo.Scalars.UInt16); }
                case BuiltInType.Int32: { return new Variant(ReadInt32(fieldName), TypeInfo.Scalars.Int32); }
                case BuiltInType.UInt32: { return new Variant(ReadUInt32(fieldName), TypeInfo.Scalars.UInt32); }
                case BuiltInType.Int64: { return new Variant(ReadInt64(fieldName), TypeInfo.Scalars.Int64); }
                case BuiltInType.UInt64: { return new Variant(ReadUInt64(fieldName), TypeInfo.Scalars.UInt64); }
                case BuiltInType.Float: { return new Variant(ReadFloat(fieldName), TypeInfo.Scalars.Float); }
                case BuiltInType.Double: { return new Variant(ReadDouble(fieldName), TypeInfo.Scalars.Double); }
                case BuiltInType.String: { return new Variant(ReadString(fieldName), TypeInfo.Scalars.String); }
                case BuiltInType.ByteString: { return new Variant(ReadByteString(fieldName), TypeInfo.Scalars.ByteString); }
                case BuiltInType.DateTime: { return new Variant(ReadDateTime(fieldName), TypeInfo.Scalars.DateTime); }
                case BuiltInType.Guid: { return new Variant(ReadGuid(fieldName), TypeInfo.Scalars.Guid); }
                case BuiltInType.NodeId: { return new Variant(ReadNodeId(fieldName), TypeInfo.Scalars.NodeId); }
                case BuiltInType.ExpandedNodeId: { return new Variant(ReadExpandedNodeId(fieldName), TypeInfo.Scalars.ExpandedNodeId); }
                case BuiltInType.QualifiedName: { return new Variant(ReadQualifiedName(fieldName), TypeInfo.Scalars.QualifiedName); }
                case BuiltInType.LocalizedText: { return new Variant(ReadLocalizedText(fieldName), TypeInfo.Scalars.LocalizedText); }
                case BuiltInType.StatusCode: { return new Variant(ReadStatusCode(fieldName), TypeInfo.Scalars.StatusCode); }
                case BuiltInType.XmlElement: { return new Variant(ReadXmlElement(fieldName), TypeInfo.Scalars.XmlElement); }
                case BuiltInType.ExtensionObject: { return new Variant(ReadExtensionObject(fieldName), TypeInfo.Scalars.ExtensionObject); }
                case BuiltInType.Variant: { return new Variant(ReadVariant(fieldName), TypeInfo.Scalars.Variant); }
            }

            return Variant.Null;
        }

        private Variant ReadVariantArrayBody(string fieldName, BuiltInType type)
        {
            switch (type)
            {
                case BuiltInType.Boolean: { return new Variant(ReadBooleanArray(fieldName), TypeInfo.Arrays.Boolean); }
                case BuiltInType.SByte: { return new Variant(ReadSByteArray(fieldName), TypeInfo.Arrays.SByte); }
                case BuiltInType.Byte: { return new Variant(ReadByteArray(fieldName), TypeInfo.Arrays.Byte); }
                case BuiltInType.Int16: { return new Variant(ReadInt16Array(fieldName), TypeInfo.Arrays.Int16); }
                case BuiltInType.UInt16: { return new Variant(ReadUInt16Array(fieldName), TypeInfo.Arrays.UInt16); }
                case BuiltInType.Int32: { return new Variant(ReadInt32Array(fieldName), TypeInfo.Arrays.Int32); }
                case BuiltInType.UInt32: { return new Variant(ReadUInt32Array(fieldName), TypeInfo.Arrays.UInt32); }
                case BuiltInType.Int64: { return new Variant(ReadInt64Array(fieldName), TypeInfo.Arrays.Int64); }
                case BuiltInType.UInt64: { return new Variant(ReadUInt64Array(fieldName), TypeInfo.Arrays.UInt64); }
                case BuiltInType.Float: { return new Variant(ReadFloatArray(fieldName), TypeInfo.Arrays.Float); }
                case BuiltInType.Double: { return new Variant(ReadDoubleArray(fieldName), TypeInfo.Arrays.Double); }
                case BuiltInType.String: { return new Variant(ReadStringArray(fieldName), TypeInfo.Arrays.String); }
                case BuiltInType.ByteString: { return new Variant(ReadByteStringArray(fieldName), TypeInfo.Arrays.ByteString); }
                case BuiltInType.DateTime: { return new Variant(ReadDateTimeArray(fieldName), TypeInfo.Arrays.DateTime); }
                case BuiltInType.Guid: { return new Variant(ReadGuidArray(fieldName), TypeInfo.Arrays.Guid); }
                case BuiltInType.NodeId: { return new Variant(ReadNodeIdArray(fieldName), TypeInfo.Arrays.NodeId); }
                case BuiltInType.ExpandedNodeId: { return new Variant(ReadExpandedNodeIdArray(fieldName), TypeInfo.Arrays.ExpandedNodeId); }
                case BuiltInType.QualifiedName: { return new Variant(ReadQualifiedNameArray(fieldName), TypeInfo.Arrays.QualifiedName); }
                case BuiltInType.LocalizedText: { return new Variant(ReadLocalizedTextArray(fieldName), TypeInfo.Arrays.LocalizedText); }
                case BuiltInType.StatusCode: { return new Variant(ReadStatusCodeArray(fieldName), TypeInfo.Arrays.StatusCode); }
                case BuiltInType.XmlElement: { return new Variant(ReadXmlElementArray(fieldName), TypeInfo.Arrays.XmlElement); }
                case BuiltInType.ExtensionObject: { return new Variant(ReadExtensionObjectArray(fieldName), TypeInfo.Arrays.ExtensionObject); }
                case BuiltInType.Variant: { return new Variant(ReadVariantArray(fieldName), TypeInfo.Arrays.Variant); }
            }

            return Variant.Null;
        }

        /// <summary>
        /// Reads an Variant from the stream.
        /// </summary>
        public Variant ReadVariant(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return Variant.Null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return Variant.Null;
            }

            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }
            try
            {
                m_nestingLevel++;
                m_stack.Push(value);

                BuiltInType type = (BuiltInType)ReadByte("Type");

                var context = m_stack.Peek() as Dictionary<string, object>;

                if (!context.TryGetValue("Body", out token))
                {
                    return Variant.Null;
                }

                Variant array;
                if (token is Array)
                {
                    array = ReadVariantBody("Body", type);
                }
                else if (token is List<object>)
                {
                    array = ReadVariantArrayBody("Body", type);
                }
                else
                {
                    return ReadVariantBody("Body", type);
                }
                var dimensions = ReadInt32Array("Dimensions");
                if (array.Value is Array && dimensions != null && dimensions.Count > 1)
                {
                    array = new Variant(new Matrix((Array)array.Value, type, dimensions.ToArray()));
                }
                return array;
            }
            finally
            {
                m_nestingLevel--;
                m_stack.Pop();
            }
        }

        /// <summary>
        /// Reads an DataValue from the stream.
        /// </summary>
        public DataValue ReadDataValue(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return null;
            }

            DataValue dv = new DataValue();

            try
            {
                m_stack.Push(value);

                dv.WrappedValue = ReadVariant("Value");
                dv.StatusCode = ReadStatusCode("StatusCode");
                dv.SourceTimestamp = ReadDateTime("SourceTimestamp");
                dv.SourcePicoseconds = ReadUInt16("SourcePicoseconds");
                dv.ServerTimestamp = ReadDateTime("ServerTimestamp");
                dv.ServerPicoseconds = ReadUInt16("ServerPicoseconds");
            }
            finally
            {
                m_stack.Pop();
            }

            return dv;
        }

        private void EncodeAsJson(JsonTextWriter writer, object value)
        {
            var map = value as Dictionary<string, object>;

            if (map != null)
            {
                EncodeAsJson(writer, map);
                return;
            }

            var list = value as List<object>;

            if (list != null)
            {
                writer.WriteStartArray();

                foreach (var element in list)
                {
                    EncodeAsJson(writer, element);
                }

                writer.WriteStartArray();
                return;
            }

            writer.WriteValue(value);
        }

        private void EncodeAsJson(JsonTextWriter writer, Dictionary<string, object> value)
        {
            writer.WriteStartObject();

            foreach (var field in value)
            {
                writer.WritePropertyName(field.Key);
                EncodeAsJson(writer, field.Value);
            }

            writer.WriteEndObject();
        }

        /// <summary>
        /// Reads an extension object from the stream.
        /// </summary>
        public ExtensionObject ReadExtensionObject(string fieldName)
        {
            var extension = ExtensionObject.Null;
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return extension;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return extension;
            }

            try
            {
                m_stack.Push(value);

                ExpandedNodeId typeId = ReadExpandedNodeId("TypeId");
                ExpandedNodeId absoluteId =
                    typeId.IsAbsolute ?
                    typeId :
                    NodeId.ToExpandedNodeId(typeId.InnerNodeId, m_context.NamespaceUris);

                if (!NodeId.IsNull(typeId) && NodeId.IsNull(absoluteId))
                {
                    Utils.Trace("Cannot de-serialized extension objects if the NamespaceUri is not in the NamespaceTable: Type = {0}", typeId);
                }
                else
                {
                    typeId = absoluteId;
                }

                byte encoding = ReadByte("Encoding");

                if (encoding == (byte)ExtensionObjectEncoding.Binary)
                {
                    var bytes = ReadByteString("Body");
                    return new ExtensionObject(typeId, bytes ?? new byte[0]);
                }

                if (encoding == (byte)ExtensionObjectEncoding.Xml)
                {
                    var xml = ReadXmlElement("Body");
                    if (xml == null)
                    {
                        return extension;
                    }
                    return new ExtensionObject(typeId, xml);
                }

                if (encoding == (byte)ExtensionObjectEncoding.Json)
                {
                    var json = ReadString("Body");
                    if (String.IsNullOrEmpty(json))
                    {
                        return extension;
                    }
                    return new ExtensionObject(typeId, json);
                }

                Type systemType = m_context.Factory.GetSystemType(typeId);

                if (systemType != null)
                {
                    var encodeable = ReadEncodeable("Body", systemType);
                    if (encodeable == null)
                    {
                        return extension;
                    }

                    return new ExtensionObject(typeId, encodeable);
                }

                var ostrm = new MemoryStream();

                using (JsonTextWriter writer = new JsonTextWriter(new StreamWriter(ostrm)))
                {
                    EncodeAsJson(writer, token);
                }

                return new ExtensionObject(typeId, ostrm.ToArray());
            }
            finally
            {
                m_stack.Pop();
            }
        }

        /// <summary>
        /// Reads an encodeable object from the stream.
        /// </summary>
        /// <param name="fieldName">The encodeable object field name</param>
        /// <param name="systemType">The system type of the encopdeable object to be read</param>
        /// <param name="encodeableTypeId">The TypeId for the <see cref="IEncodeable"/> instance that will be read.</param>
        /// <returns>An <see cref="IEncodeable"/> object that was read from the stream.</returns>
        public IEncodeable ReadEncodeable(string fieldName, System.Type systemType, ExpandedNodeId encodeableTypeId = null)
        {
            if (systemType == null)
            {
                throw new ArgumentNullException(nameof(systemType));
            }

            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            IEncodeable value = Activator.CreateInstance(systemType) as IEncodeable;

            if (value == null)
            {
                throw new ServiceResultException(StatusCodes.BadDecodingError, Utils.Format("Type does not support IEncodeable interface: '{0}'", systemType.FullName));
            }

            if (encodeableTypeId != null)
            {
                // set type identifier for custom complex data types before decode.
                IComplexTypeInstance complexTypeInstance = value as IComplexTypeInstance;

                if (complexTypeInstance != null)
                {
                    complexTypeInstance.TypeId = encodeableTypeId;
                }
            }

            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            try
            {
                m_stack.Push(token);

                value.Decode(this);
            }
            finally
            {
                m_stack.Pop();
            }

            m_nestingLevel--;

            return value;
        }

        /// <summary>
        ///  Reads an enumerated value from the stream.
        /// </summary>
        public Enum ReadEnumerated(string fieldName, System.Type enumType)
        {
            if (enumType == null)
            {
                throw new ArgumentNullException(nameof(enumType));
            }

            return (Enum)Enum.ToObject(enumType, ReadInt32(fieldName));
        }

        private bool ReadArrayField(string fieldName, out List<object> array)
        {
            object token = array = null;

            if (!ReadField(fieldName, out token))
            {
                return false;
            }

            array = token as List<object>;

            if (array == null)
            {
                return false;
            }

            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < array.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            return true;
        }

        /// <summary>
        /// Reads a boolean array from the stream.
        /// </summary>
        public BooleanCollection ReadBooleanArray(string fieldName)
        {
            var values = new BooleanCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadBoolean(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a sbyte array from the stream.
        /// </summary>
        public SByteCollection ReadSByteArray(string fieldName)
        {
            var values = new SByteCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadSByte(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a byte array from the stream.
        /// </summary>
        public ByteCollection ReadByteArray(string fieldName)
        {
            var values = new ByteCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadByte(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a short array from the stream.
        /// </summary>
        public Int16Collection ReadInt16Array(string fieldName)
        {
            var values = new Int16Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadInt16(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a ushort array from the stream.
        /// </summary>
        public UInt16Collection ReadUInt16Array(string fieldName)
        {
            var values = new UInt16Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadUInt16(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a int array from the stream.
        /// </summary>
        public Int32Collection ReadInt32Array(string fieldName)
        {
            var values = new Int32Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadInt32(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a uint array from the stream.
        /// </summary>
        public UInt32Collection ReadUInt32Array(string fieldName)
        {
            var values = new UInt32Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadUInt32(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a long array from the stream.
        /// </summary>
        public Int64Collection ReadInt64Array(string fieldName)
        {
            var values = new Int64Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadInt64(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a ulong array from the stream.
        /// </summary>
        public UInt64Collection ReadUInt64Array(string fieldName)
        {
            var values = new UInt64Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadUInt64(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a float array from the stream.
        /// </summary>
        public FloatCollection ReadFloatArray(string fieldName)
        {
            var values = new FloatCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadFloat(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a double array from the stream.
        /// </summary>
        public DoubleCollection ReadDoubleArray(string fieldName)
        {
            var values = new DoubleCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadDouble(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a string array from the stream.
        /// </summary>
        public StringCollection ReadStringArray(string fieldName)
        {
            var values = new StringCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadString(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a UTC date/time array from the stream.
        /// </summary>
        public DateTimeCollection ReadDateTimeArray(string fieldName)
        {
            var values = new DateTimeCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadDateTime(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a GUID array from the stream.
        /// </summary>
        public UuidCollection ReadGuidArray(string fieldName)
        {
            var values = new UuidCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadGuid(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a byte string array from the stream.
        /// </summary>
        public ByteStringCollection ReadByteStringArray(string fieldName)
        {
            var values = new ByteStringCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadByteString(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an XmlElement array from the stream.
        /// </summary>
        public XmlElementCollection ReadXmlElementArray(string fieldName)
        {
            var values = new XmlElementCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadXmlElement(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an NodeId array from the stream.
        /// </summary>
        public NodeIdCollection ReadNodeIdArray(string fieldName)
        {
            var values = new NodeIdCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadNodeId(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an ExpandedNodeId array from the stream.
        /// </summary>
        public ExpandedNodeIdCollection ReadExpandedNodeIdArray(string fieldName)
        {
            var values = new ExpandedNodeIdCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadExpandedNodeId(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an StatusCode array from the stream.
        /// </summary>
        public StatusCodeCollection ReadStatusCodeArray(string fieldName)
        {
            var values = new StatusCodeCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadStatusCode(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an DiagnosticInfo array from the stream.
        /// </summary>
        public DiagnosticInfoCollection ReadDiagnosticInfoArray(string fieldName)
        {
            var values = new DiagnosticInfoCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadDiagnosticInfo(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an QualifiedName array from the stream.
        /// </summary>
        public QualifiedNameCollection ReadQualifiedNameArray(string fieldName)
        {
            var values = new QualifiedNameCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadQualifiedName(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an LocalizedText array from the stream.
        /// </summary>
        public LocalizedTextCollection ReadLocalizedTextArray(string fieldName)
        {
            var values = new LocalizedTextCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadLocalizedText(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an Variant array from the stream.
        /// </summary>
        public VariantCollection ReadVariantArray(string fieldName)
        {
            var values = new VariantCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadVariant(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an DataValue array from the stream.
        /// </summary>
        public DataValueCollection ReadDataValueArray(string fieldName)
        {
            var values = new DataValueCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadDataValue(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an array of extension objects from the stream.
        /// </summary>
        public ExtensionObjectCollection ReadExtensionObjectArray(string fieldName)
        {
            var values = new ExtensionObjectCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadExtensionObject(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an encodeable array from the stream.
        /// </summary>
        /// <param name="fieldName">The encodeable array field name</param>
        /// <param name="systemType">The system type of the encopdeable objects to be read object</param>
        /// <param name="encodeableTypeId">The TypeId for the <see cref="IEncodeable"/> instances that will be read.</param>
        /// <returns>An <see cref="IEncodeable"/> array that was read from the stream.</returns>
        public Array ReadEncodeableArray(string fieldName, System.Type systemType, ExpandedNodeId encodeableTypeId = null)
        {
            if (systemType == null)
            {
                throw new ArgumentNullException(nameof(systemType));
            }

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return Array.CreateInstance(systemType, 0);
            }

            var values = Array.CreateInstance(systemType, token.Count);

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadEncodeable(null, systemType, encodeableTypeId);
                    values.SetValue(element, ii);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an enumerated value array from the stream.
        /// </summary>
        public Array ReadEnumeratedArray(string fieldName, System.Type enumType)
        {
            if (enumType == null)
            {
                throw new ArgumentNullException(nameof(enumType));
            }

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return Array.CreateInstance(enumType, 0);
            }

            var values = Array.CreateInstance(enumType, token.Count);

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadEnumerated(null, enumType);
                    values.SetValue(element, ii);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }
        #endregion

        #region Private Methods
        private NodeId DefaultNodeId(IdType idType, ushort namespaceIndex)
        {
            switch (idType)
            {
                case IdType.Numeric:
                default:
                {
                    return new NodeId(0U, namespaceIndex);
                }

                case IdType.Opaque:
                {
                    return new NodeId(new byte[0], namespaceIndex);
                }

                case IdType.String:
                {
                    return new NodeId("", namespaceIndex);
                }

                case IdType.Guid:
                {
                    return new NodeId(Guid.Empty, namespaceIndex);
                }
            }
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;
using Newtonsoft.Json;

namespace Opc.Ua
{
    /// <summary>
    /// Reads objects from a JSON stream.
    /// </summary>
    public class JsonDecoder : IDecoder, IDisposable
    {
        #region Private Fields
        private JsonTextReader m_reader;
        private Dictionary<string, object> m_root;
        private Stack<object> m_stack;
        private ServiceMessageContext m_context;
        private ushort[] m_namespaceMappings;
        private ushort[] m_serverMappings;
        private uint m_nestingLevel;
        // JSON encoded value of: 9999-12-31T23:59:59Z
        private DateTime m_dateTimeMaxJsonValue = new DateTime((long)3155378975990000000);
        private enum JTokenNullObject
        {
            Undefined = 0,
            Object = 1,
            Array = 2
        };
        #endregion

        #region Constructors
        /// <summary>
        /// Create a JSON decoder to decode a string.
        /// </summary>
        /// <param name="json">The JSON encoded string.</param>
        /// <param name="context">The service message context to use.</param>
        public JsonDecoder(string json, ServiceMessageContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }
            Initialize();

            m_context = context;
            m_nestingLevel = 0;
            m_reader = new JsonTextReader(new StringReader(json));
            m_root = ReadObject();
            m_stack = new Stack<object>();
            m_stack.Push(m_root);
        }

        /// <summary>
        /// Create a JSON decoder to decode a <see cref="Type"/>from a <see cref="JsonTextReader"/>.
        /// </summary>
        /// <param name="systemType">The system type of the encoded JSON stram.</param>
        /// <param name="reader">The text reader.</param>
        /// <param name="context">The service message context to use.</param>
        public JsonDecoder(Type systemType, JsonTextReader reader, ServiceMessageContext context)
        {
            Initialize();

            m_context = context;
            m_nestingLevel = 0;
            m_reader = reader;
            m_root = ReadObject();
            m_stack = new Stack<object>();
            m_stack.Push(m_root);
        }

        /// <summary>
        /// Sets private members to default values.
        /// </summary>
        private void Initialize()
        {
            m_reader = null;
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Decodes a session-less message from a buffer.
        /// </summary>
        public static IEncodeable DecodeSessionLessMessage(byte[] buffer, ServiceMessageContext context)
        {
            if (buffer == null) throw new ArgumentNullException(nameof(buffer));
            if (context == null) throw new ArgumentNullException(nameof(context));

            JsonDecoder decoder = new JsonDecoder(UTF8Encoding.UTF8.GetString(buffer), context);

            try
            {
                // decode the actual message.
                SessionLessServiceMessage message = new SessionLessServiceMessage();
                message.Decode(decoder);
                return message.Message;
            }
            finally
            {
                decoder.Close();
            }
        }

        /// <summary>
        /// Decodes a message from a buffer.
        /// </summary>
        public static IEncodeable DecodeMessage(byte[] buffer, System.Type expectedType, ServiceMessageContext context)
        {
            return DecodeMessage(new ArraySegment<byte>(buffer), expectedType, context);
        }

        /// <summary>
        /// Decodes a message from a buffer.
        /// </summary>
        public static IEncodeable DecodeMessage(ArraySegment<byte> buffer, System.Type expectedType, ServiceMessageContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException(nameof(context));
            }

            // check that the max message size was not exceeded.
            if (context.MaxMessageSize > 0 && context.MaxMessageSize < buffer.Count)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "MaxMessageSize {0} < {1}",
                    context.MaxMessageSize,
                    buffer.Count);
            }

            JsonDecoder decoder = new JsonDecoder(UTF8Encoding.UTF8.GetString(buffer.Array, buffer.Offset, buffer.Count), context);

            try
            {
                return decoder.DecodeMessage(expectedType);
            }
            finally
            {
                decoder.Close();
            }
        }

        /// <summary>
        /// Decodes an object from a buffer.
        /// </summary>
        public IEncodeable DecodeMessage(System.Type expectedType)
        {
            var namespaceUris = ReadStringArray("NamespaceUris");
            var serverUris = ReadStringArray("ServerUris");

            if ((namespaceUris != null && namespaceUris.Count > 0) || (serverUris != null && serverUris.Count > 0))
            {
                var namespaces = (namespaceUris == null || namespaceUris.Count == 0) ? m_context.NamespaceUris : new NamespaceTable(namespaceUris);
                var servers = (serverUris == null || serverUris.Count == 0) ? m_context.ServerUris : new StringTable(serverUris);

                SetMappingTables(namespaces, servers);
            }

            // read the node id.
            NodeId typeId = ReadNodeId("TypeId");

            // convert to absolute node id.
            ExpandedNodeId absoluteId = NodeId.ToExpandedNodeId(typeId, m_context.NamespaceUris);

            // lookup message type.
            Type actualType = m_context.Factory.GetSystemType(absoluteId);

            if (actualType == null)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingError, Utils.Format("Cannot decode message with type id: {0}.", absoluteId));
            }

            // read the message.
            IEncodeable message = ReadEncodeable("Body", actualType);

            // return the message.
            return message;
        }


        /// <summary>
        /// Initializes the tables used to map namespace and server uris during decoding.
        /// </summary>
        /// <param name="namespaceUris">The namespaces URIs referenced by the data being decoded.</param>
        /// <param name="serverUris">The server URIs referenced by the data being decoded.</param>
        public void SetMappingTables(NamespaceTable namespaceUris, StringTable serverUris)
        {
            m_namespaceMappings = null;

            if (namespaceUris != null && m_context.NamespaceUris != null)
            {
                m_namespaceMappings = m_context.NamespaceUris.CreateMapping(namespaceUris, false);
            }

            m_serverMappings = null;

            if (serverUris != null && m_context.ServerUris != null)
            {
                m_serverMappings = m_context.ServerUris.CreateMapping(serverUris, false);
            }
        }

        /// <summary>
        /// Closes the stream used for reading.
        /// </summary>
        public void Close()
        {
            m_reader.Close();
        }

        /// <summary>
        /// Closes the stream used for reading.
        /// </summary>
        public void Close(bool checkEof)
        {
            if (checkEof && m_reader.TokenType != JsonToken.EndObject)
            {
                while (m_reader.Read() && m_reader.TokenType != JsonToken.EndObject)
                {
                    ;
                }
            }

            m_reader.Close();
        }

        private List<object> ReadArray()
        {
            List<object> elements = new List<object>();

            while (m_reader.Read() && m_reader.TokenType != JsonToken.EndArray)
            {
                switch (m_reader.TokenType)
                {
                    case JsonToken.Comment:
                    {
                        break;
                    }

                    case JsonToken.Null:
                    {
                        elements.Add(JTokenNullObject.Array);
                        break;
                    }
                    case JsonToken.Date:
                    case JsonToken.Boolean:
                    case JsonToken.Integer:
                    case JsonToken.Float:
                    case JsonToken.String:
                    {
                        elements.Add(m_reader.Value);
                        break;
                    }

                    case JsonToken.StartArray:
                    {
                        elements.Add(ReadArray());
                        break;
                    }

                    case JsonToken.StartObject:
                    {
                        elements.Add(ReadObject());
                        break;
                    }

                    default:
                        break;
                }
            }

            return elements;
        }

        private Dictionary<string, object> ReadObject()
        {
            Dictionary<string, object> fields = new Dictionary<string, object>();

            while (m_reader.Read() && m_reader.TokenType != JsonToken.EndObject)
            {
                if (m_reader.TokenType == JsonToken.PropertyName)
                {
                    string name = (string)m_reader.Value;

                    if (m_reader.Read() && m_reader.TokenType != JsonToken.EndObject)
                    {
                        switch (m_reader.TokenType)
                        {
                            case JsonToken.Comment:
                            {
                                break;
                            }

                            case JsonToken.Null:
                            {
                                fields[name] = JTokenNullObject.Object;
                                break;
                            }

                            case JsonToken.Date:
                            case JsonToken.Bytes:
                            case JsonToken.Boolean:
                            case JsonToken.Integer:
                            case JsonToken.Float:
                            case JsonToken.String:
                            {
                                fields[name] = m_reader.Value;
                                break;
                            }

                            case JsonToken.StartArray:
                            {
                                fields[name] = ReadArray();
                                break;
                            }

                            case JsonToken.StartObject:
                            {
                                fields[name] = ReadObject();
                                break;
                            }

                            default:
                                break;
                        }
                    }
                }
            }

            return fields;
        }

        /// <summary>
        /// Reads the body extension object from the stream.
        /// </summary>
        public object ReadExtensionObjectBody(ExpandedNodeId typeId)
        {
            return null;
        }
        #endregion

        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                m_reader?.Close();
            }
        }
        #endregion

        #region IDecoder Members
        /// <summary>
        /// The type of encoding being used.
        /// </summary>
        public EncodingType EncodingType => EncodingType.Json;

        /// <summary>
        /// The message context associated with the decoder.
        /// </summary>
        public ServiceMessageContext Context => m_context;

        /// <summary>
        /// Pushes a namespace onto the namespace stack.
        /// </summary>
        public void PushNamespace(string namespaceUri)
        {
        }

        /// <summary>
        /// Pops a namespace from the namespace stack.
        /// </summary>
        public void PopNamespace()
        {
        }

        /// <summary>
        /// Read a decoded JSON field.
        /// </summary>
        /// <param name="fieldName">The name of the field.</param>
        /// <param name="token">The returned object token of the field.</param>
        public bool ReadField(string fieldName, out object token)
        {
            token = null;

            if (String.IsNullOrEmpty(fieldName))
            {
                token = m_stack.Peek();
                return true;
            }

            var context = m_stack.Peek() as Dictionary<string, object>;

            if (context == null || !context.TryGetValue(fieldName, out token))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Reads a boolean from the stream.
        /// </summary>
        public bool ReadBoolean(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return false;
            }

            var value = token as bool?;

            if (value == null)
            {
                return false;
            }

            return (bool)token;
        }

        /// <summary>
        /// Reads a sbyte from the stream.
        /// </summary>
        public sbyte ReadSByte(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                return 0;
            }

            if (value < SByte.MinValue || value > SByte.MaxValue)
            {
                return 0;
            }

            return (sbyte)value;
        }

        /// <summary>
        /// Reads a byte from the stream.
        /// </summary>
        public byte ReadByte(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                return 0;
            }

            if (value < Byte.MinValue || value > Byte.MaxValue)
            {
                return 0;
            }

            return (byte)value;
        }

        /// <summary>
        /// Reads a short from the stream.
        /// </summary>
        public short ReadInt16(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                return 0;
            }
;
            if (value < Int16.MinValue || value > Int16.MaxValue)
            {
                return 0;
            }

            return (short)value;
        }

        /// <summary>
        /// Reads a ushort from the stream.
        /// </summary>
        public ushort ReadUInt16(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                return 0;
            }

            if (value < UInt16.MinValue || value > UInt16.MaxValue)
            {
                return 0;
            }

            return (ushort)value;
        }

        /// <summary>
        /// Reads an int from the stream.
        /// </summary>
        public int ReadInt32(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                return 0;
            }

            if (value < Int32.MinValue || value > Int32.MaxValue)
            {
                return 0;
            }

            return (int)value;
        }

        /// <summary>
        /// Reads a uint from the stream.
        /// </summary>
        public uint ReadUInt32(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                var text = token as string;
                uint number = 0;

                if (text == null || !UInt32.TryParse(text, NumberStyles.Integer, CultureInfo.InvariantCulture, out number))
                {
                    return 0;
                }

                return number;
            }

            if (value < UInt32.MinValue || value > UInt32.MaxValue)
            {
                return 0;
            }

            return (uint)value;
        }

        /// <summary>
        /// Reads a long from the stream.
        /// </summary>
        public long ReadInt64(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                var text = token as string;
                long number = 0;

                if (text == null || !Int64.TryParse(text, NumberStyles.Integer, CultureInfo.InvariantCulture, out number))
                {
                    return 0;
                }

                return number;
            }

            if (value < Int64.MinValue || value > Int64.MaxValue)
            {
                return 0;
            }

            return (long)value;
        }

        /// <summary>
        /// Reads a ulong from the stream.
        /// </summary>
        public ulong ReadUInt64(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as long?;

            if (value == null)
            {
                var text = token as string;
                ulong number = 0;

                if (text == null || !UInt64.TryParse(text,
                    NumberStyles.Integer,
                    CultureInfo.InvariantCulture, out number))
                {
                    return 0;
                }

                return number;
            }

            if (value < 0)
            {
                return 0;
            }

            return (ulong)value;
        }

        /// <summary>
        /// Reads a float from the stream.
        /// </summary>
        public float ReadFloat(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as double?;

            if (value == null)
            {
                float number = 0;
                if (text == null || !Single.TryParse(text, NumberStyles.Float, CultureInfo.InvariantCulture, out number))
                {
                    if (token is string text)
                    {
                        if (String.Compare(text, "Infinity", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Single.PositiveInfinity;
                        }
                        else if (String.Compare(text, "-Infinity", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Single.NegativeInfinity;
                        }
                        else if (String.Compare(text, "NaN", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Single.NaN;
                        }
                    }

                    var integer = token as long?;
                    if (integer == null)
                    {
                        return 0;
                    }

                    return (float)integer;
                }

                return number;
            }

            float floatValue = (float)value;
            if (floatValue >= Single.MinValue && floatValue <= Single.MaxValue)
            {
                return (float)value;
            }

            return 0;
        }

        /// <summary>
        /// Reads a double from the stream.
        /// </summary>
        public double ReadDouble(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return 0;
            }

            var value = token as double?;

            if (value == null)
            {
                double number = 0;

                if (text == null || !Double.TryParse(text, NumberStyles.Float, CultureInfo.InvariantCulture, out number))
                {
                    if (token is string text)
                    {
                        if (String.Compare(text, "Infinity", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Double.PositiveInfinity;
                        }
                        else if (String.Compare(text, "-Infinity", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Double.NegativeInfinity;
                        }
                        else if (String.Compare(text, "NaN", StringComparison.OrdinalIgnoreCase) == 0)
                        {
                            return Double.NaN;
                        }
                    }

                    var integer = token as long?;

                    if (integer == null)
                    {
                        return 0;
                    }

                    return (double)integer;
                }

                return number;
            }

            return (double)value;
        }

        /// <summary>
        /// Reads a string from the stream.
        /// </summary>
        public string ReadString(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            var value = token as string;

            if (value == null)
            {
                return null;
            }

            if (m_context.MaxStringLength > 0 && m_context.MaxStringLength < value.Length)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            return (string)value;
        }

        /// <summary>
        /// Reads a UTC date/time from the stream.
        /// </summary>
        public DateTime ReadDateTime(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return DateTime.MinValue;
            }

            if (token is DateTime? value)
            {
                return value.Value >= m_dateTimeMaxJsonValue ? DateTime.MaxValue : value.Value;
            }

            if (token is string text)
            {
                var result = XmlConvert.ToDateTime(text, XmlDateTimeSerializationMode.Utc);
                return result >= m_dateTimeMaxJsonValue ? DateTime.MaxValue : result;
            }

            return DateTime.MinValue;
        }

        /// <summary>
        /// Reads a GUID from the stream.
        /// </summary>
        public Uuid ReadGuid(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return Uuid.Empty;
            }

            var value = token as string;

            if (value == null)
            {
                return Uuid.Empty;
            }

            return new Uuid(value);
        }

        /// <summary>
        /// Reads a byte string from the stream.
        /// </summary>
        public byte[] ReadByteString(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            if (token is JTokenNullObject)
            {
                return null;
            }

            var value = token as string;
            if (value == null)
            {
                return new byte[0];
            }

            var bytes = Convert.FromBase64String(value);

            if (m_context.MaxByteStringLength > 0 && m_context.MaxByteStringLength < bytes.Length)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            return bytes;
        }


        /// <summary>
        /// Reads an XmlElement from the stream.
        /// </summary>
        public XmlElement ReadXmlElement(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            var value = token as string;

            if (value == null)
            {
                return null;
            }

            var bytes = Convert.FromBase64String(value);

            if (bytes != null && bytes.Length > 0)
            {
                XmlDocument document = new XmlDocument();
                string xmlString = new UTF8Encoding().GetString(bytes, 0, bytes.Length);

                using (XmlReader reader = XmlReader.Create(new StringReader(xmlString),
                    new XmlReaderSettings() { DtdProcessing = System.Xml.DtdProcessing.Prohibit }))
                {
                    document.Load(reader);
                }

                return document.DocumentElement;
            }

            return null;
        }

        /// <summary>
        /// Reads an NodeId from the stream.
        /// </summary>
        public NodeId ReadNodeId(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return NodeId.Null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return NodeId.Null;
            }

            IdType idType = IdType.Numeric;
            ushort namespaceIndex = 0;

            try
            {
                m_stack.Push(value);

                if (value.ContainsKey("IdType"))
                {
                    idType = (IdType)ReadInt32("IdType");
                }

                if (value.ContainsKey("Namespace"))
                {
                    namespaceIndex = ReadUInt16("Namespace");
                }

                if (value.ContainsKey("Id"))
                {
                    switch (idType)
                    {
                        case IdType.Numeric:
                        default:
                        {
                            return new NodeId(ReadUInt32("Id"), namespaceIndex);
                        }

                        case IdType.Opaque:
                        {
                            return new NodeId(ReadByteString("Id"), namespaceIndex);
                        }

                        case IdType.String:
                        {
                            return new NodeId(ReadString("Id"), namespaceIndex);
                        }

                        case IdType.Guid:
                        {
                            return new NodeId(ReadGuid("Id"), namespaceIndex);
                        }

                    }
                }
                return DefaultNodeId(idType, namespaceIndex);
            }
            finally
            {
                m_stack.Pop();
            }
        }

        /// <summary>
        /// Reads an ExpandedNodeId from the stream.
        /// </summary>
        public ExpandedNodeId ReadExpandedNodeId(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return ExpandedNodeId.Null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return ExpandedNodeId.Null;
            }

            IdType idType = IdType.Numeric;
            ushort namespaceIndex = 0;
            string namespaceUri = null;
            uint serverIndex = 0;

            try
            {
                m_stack.Push(value);

                if (value.ContainsKey("IdType"))
                {
                    idType = (IdType)ReadInt32("IdType");
                }

                object namespaceToken = null;

                if (ReadField("Namespace", out namespaceToken))
                {
                    var index = namespaceToken as long?;

                    if (index == null)
                    {
                        namespaceUri = namespaceToken as string;
                    }
                    else
                    {
                        if (index.Value >= 0 || index.Value < UInt16.MaxValue)
                        {
                            namespaceIndex = (ushort)index.Value;
                        }
                    }
                }

                if (value.ContainsKey("ServerUri"))
                {
                    serverIndex = ReadUInt32("ServerUri");
                }

                if (value.ContainsKey("Id"))
                {
                    switch (idType)
                    {
                        case IdType.Numeric:
                        default:
                        {
                            return new ExpandedNodeId(ReadUInt32("Id"), namespaceIndex, namespaceUri, serverIndex);
                        }

                        case IdType.Opaque:
                        {
                            return new ExpandedNodeId(ReadByteString("Id"), namespaceIndex, namespaceUri, serverIndex);
                        }

                        case IdType.String:
                        {
                            return new ExpandedNodeId(ReadString("Id"), namespaceIndex, namespaceUri, serverIndex);
                        }

                        case IdType.Guid:
                        {
                            return new ExpandedNodeId(ReadGuid("Id"), namespaceIndex, namespaceUri, serverIndex);
                        }
                    }
                }

                return new ExpandedNodeId(DefaultNodeId(idType, namespaceIndex), namespaceUri, serverIndex);
            }
            finally
            {
                m_stack.Pop();
            }
        }


        /// <summary>
        /// Reads an StatusCode from the stream.
        /// </summary>
        public StatusCode ReadStatusCode(string fieldName)
        {
            return ReadUInt32(fieldName);
        }

        /// <summary>
        /// Reads an DiagnosticInfo from the stream.
        /// </summary>
        public DiagnosticInfo ReadDiagnosticInfo(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return null;
            }

            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            try
            {
                m_nestingLevel++;
                m_stack.Push(value);

                DiagnosticInfo di = new DiagnosticInfo();

                if (value.ContainsKey("SymbolicId"))
                {
                    di.SymbolicId = ReadInt32("SymbolicId");
                }

                if (value.ContainsKey("NamespaceUri"))
                {
                    di.NamespaceUri = ReadInt32("NamespaceUri");
                }

                if (value.ContainsKey("Locale"))
                {
                    di.Locale = ReadInt32("Locale");
                }

                if (value.ContainsKey("LocalizedText"))
                {
                    di.LocalizedText = ReadInt32("LocalizedText");
                }

                if (value.ContainsKey("AdditionalInfo"))
                {
                    di.AdditionalInfo = ReadString("AdditionalInfo");
                }

                if (value.ContainsKey("InnerStatusCode"))
                {
                    di.InnerStatusCode = ReadStatusCode("InnerStatusCode");
                }

                if (value.ContainsKey("InnerDiagnosticInfo"))
                {
                    di.InnerDiagnosticInfo = ReadDiagnosticInfo("InnerDiagnosticInfo");
                }

                return di;
            }
            finally
            {
                m_nestingLevel--;
                m_stack.Pop();
            }
        }

        /// <summary>
        /// Reads an QualifiedName from the stream.
        /// </summary>
        public QualifiedName ReadQualifiedName(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return QualifiedName.Null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return QualifiedName.Null;
            }

            UInt16 namespaceIndex = 0;
            string name = null;
            try
            {
                m_stack.Push(value);

                if (value.ContainsKey("Name"))
                {
                    name = ReadString("Name");
                }

                if (value.ContainsKey("Uri"))
                {
                    namespaceIndex = ReadUInt16("Uri");
                }
            }
            finally
            {
                m_stack.Pop();
            }

            return new QualifiedName(name, namespaceIndex);
        }

        /// <summary>
        /// Reads an LocalizedText from the stream.
        /// </summary>
        public LocalizedText ReadLocalizedText(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return LocalizedText.Null;
            }

            string locale = null;
            string text = null;

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                text = token as string;

                if (text != null)
                {
                    return new LocalizedText(text);
                }

                return LocalizedText.Null;
            }

            try
            {
                m_stack.Push(value);

                if (value.ContainsKey("Locale"))
                {
                    locale = ReadString("Locale");
                }

                if (value.ContainsKey("Text"))
                {
                    text = ReadString("Text");
                }
            }
            finally
            {
                m_stack.Pop();
            }

            return new LocalizedText(locale, text);
        }

        private Variant ReadVariantBody(string fieldName, BuiltInType type)
        {
            switch (type)
            {
                case BuiltInType.Boolean: { return new Variant(ReadBoolean(fieldName), TypeInfo.Scalars.Boolean); }
                case BuiltInType.SByte: { return new Variant(ReadSByte(fieldName), TypeInfo.Scalars.SByte); }
                case BuiltInType.Byte: { return new Variant(ReadByte(fieldName), TypeInfo.Scalars.Byte); }
                case BuiltInType.Int16: { return new Variant(ReadInt16(fieldName), TypeInfo.Scalars.Int16); }
                case BuiltInType.UInt16: { return new Variant(ReadUInt16(fieldName), TypeInfo.Scalars.UInt16); }
                case BuiltInType.Int32: { return new Variant(ReadInt32(fieldName), TypeInfo.Scalars.Int32); }
                case BuiltInType.UInt32: { return new Variant(ReadUInt32(fieldName), TypeInfo.Scalars.UInt32); }
                case BuiltInType.Int64: { return new Variant(ReadInt64(fieldName), TypeInfo.Scalars.Int64); }
                case BuiltInType.UInt64: { return new Variant(ReadUInt64(fieldName), TypeInfo.Scalars.UInt64); }
                case BuiltInType.Float: { return new Variant(ReadFloat(fieldName), TypeInfo.Scalars.Float); }
                case BuiltInType.Double: { return new Variant(ReadDouble(fieldName), TypeInfo.Scalars.Double); }
                case BuiltInType.String: { return new Variant(ReadString(fieldName), TypeInfo.Scalars.String); }
                case BuiltInType.ByteString: { return new Variant(ReadByteString(fieldName), TypeInfo.Scalars.ByteString); }
                case BuiltInType.DateTime: { return new Variant(ReadDateTime(fieldName), TypeInfo.Scalars.DateTime); }
                case BuiltInType.Guid: { return new Variant(ReadGuid(fieldName), TypeInfo.Scalars.Guid); }
                case BuiltInType.NodeId: { return new Variant(ReadNodeId(fieldName), TypeInfo.Scalars.NodeId); }
                case BuiltInType.ExpandedNodeId: { return new Variant(ReadExpandedNodeId(fieldName), TypeInfo.Scalars.ExpandedNodeId); }
                case BuiltInType.QualifiedName: { return new Variant(ReadQualifiedName(fieldName), TypeInfo.Scalars.QualifiedName); }
                case BuiltInType.LocalizedText: { return new Variant(ReadLocalizedText(fieldName), TypeInfo.Scalars.LocalizedText); }
                case BuiltInType.StatusCode: { return new Variant(ReadStatusCode(fieldName), TypeInfo.Scalars.StatusCode); }
                case BuiltInType.XmlElement: { return new Variant(ReadXmlElement(fieldName), TypeInfo.Scalars.XmlElement); }
                case BuiltInType.ExtensionObject: { return new Variant(ReadExtensionObject(fieldName), TypeInfo.Scalars.ExtensionObject); }
                case BuiltInType.Variant: { return new Variant(ReadVariant(fieldName), TypeInfo.Scalars.Variant); }
            }

            return Variant.Null;
        }

        private Variant ReadVariantArrayBody(string fieldName, BuiltInType type)
        {
            switch (type)
            {
                case BuiltInType.Boolean: { return new Variant(ReadBooleanArray(fieldName), TypeInfo.Arrays.Boolean); }
                case BuiltInType.SByte: { return new Variant(ReadSByteArray(fieldName), TypeInfo.Arrays.SByte); }
                case BuiltInType.Byte: { return new Variant(ReadByteArray(fieldName), TypeInfo.Arrays.Byte); }
                case BuiltInType.Int16: { return new Variant(ReadInt16Array(fieldName), TypeInfo.Arrays.Int16); }
                case BuiltInType.UInt16: { return new Variant(ReadUInt16Array(fieldName), TypeInfo.Arrays.UInt16); }
                case BuiltInType.Int32: { return new Variant(ReadInt32Array(fieldName), TypeInfo.Arrays.Int32); }
                case BuiltInType.UInt32: { return new Variant(ReadUInt32Array(fieldName), TypeInfo.Arrays.UInt32); }
                case BuiltInType.Int64: { return new Variant(ReadInt64Array(fieldName), TypeInfo.Arrays.Int64); }
                case BuiltInType.UInt64: { return new Variant(ReadUInt64Array(fieldName), TypeInfo.Arrays.UInt64); }
                case BuiltInType.Float: { return new Variant(ReadFloatArray(fieldName), TypeInfo.Arrays.Float); }
                case BuiltInType.Double: { return new Variant(ReadDoubleArray(fieldName), TypeInfo.Arrays.Double); }
                case BuiltInType.String: { return new Variant(ReadStringArray(fieldName), TypeInfo.Arrays.String); }
                case BuiltInType.ByteString: { return new Variant(ReadByteStringArray(fieldName), TypeInfo.Arrays.ByteString); }
                case BuiltInType.DateTime: { return new Variant(ReadDateTimeArray(fieldName), TypeInfo.Arrays.DateTime); }
                case BuiltInType.Guid: { return new Variant(ReadGuidArray(fieldName), TypeInfo.Arrays.Guid); }
                case BuiltInType.NodeId: { return new Variant(ReadNodeIdArray(fieldName), TypeInfo.Arrays.NodeId); }
                case BuiltInType.ExpandedNodeId: { return new Variant(ReadExpandedNodeIdArray(fieldName), TypeInfo.Arrays.ExpandedNodeId); }
                case BuiltInType.QualifiedName: { return new Variant(ReadQualifiedNameArray(fieldName), TypeInfo.Arrays.QualifiedName); }
                case BuiltInType.LocalizedText: { return new Variant(ReadLocalizedTextArray(fieldName), TypeInfo.Arrays.LocalizedText); }
                case BuiltInType.StatusCode: { return new Variant(ReadStatusCodeArray(fieldName), TypeInfo.Arrays.StatusCode); }
                case BuiltInType.XmlElement: { return new Variant(ReadXmlElementArray(fieldName), TypeInfo.Arrays.XmlElement); }
                case BuiltInType.ExtensionObject: { return new Variant(ReadExtensionObjectArray(fieldName), TypeInfo.Arrays.ExtensionObject); }
                case BuiltInType.Variant: { return new Variant(ReadVariantArray(fieldName), TypeInfo.Arrays.Variant); }
            }

            return Variant.Null;
        }

        /// <summary>
        /// Reads an Variant from the stream.
        /// </summary>
        public Variant ReadVariant(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return Variant.Null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return Variant.Null;
            }

            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }
            try
            {
                m_nestingLevel++;
                m_stack.Push(value);

                BuiltInType type = (BuiltInType)ReadByte("Type");

                var context = m_stack.Peek() as Dictionary<string, object>;

                if (!context.TryGetValue("Body", out token))
                {
                    return Variant.Null;
                }

                Variant array;
                if (token is Array)
                {
                    array = ReadVariantBody("Body", type);
                }
                else if (token is List<object>)
                {
                    array = ReadVariantArrayBody("Body", type);
                }
                else
                {
                    return ReadVariantBody("Body", type);
                }
                var dimensions = ReadInt32Array("Dimensions");
                if (array.Value is Array && dimensions != null && dimensions.Count > 1)
                {
                    array = new Variant(new Matrix((Array)array.Value, type, dimensions.ToArray()));
                }
                return array;
            }
            finally
            {
                m_nestingLevel--;
                m_stack.Pop();
            }
        }

        /// <summary>
        /// Reads an DataValue from the stream.
        /// </summary>
        public DataValue ReadDataValue(string fieldName)
        {
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return null;
            }

            DataValue dv = new DataValue();

            try
            {
                m_stack.Push(value);

                dv.WrappedValue = ReadVariant("Value");
                dv.StatusCode = ReadStatusCode("StatusCode");
                dv.SourceTimestamp = ReadDateTime("SourceTimestamp");
                dv.SourcePicoseconds = ReadUInt16("SourcePicoseconds");
                dv.ServerTimestamp = ReadDateTime("ServerTimestamp");
                dv.ServerPicoseconds = ReadUInt16("ServerPicoseconds");
            }
            finally
            {
                m_stack.Pop();
            }

            return dv;
        }

        private void EncodeAsJson(JsonTextWriter writer, object value)
        {
            if (value is Dictionary<string, object> map)
            {
                EncodeAsJson(writer, map);
                return;
            }

            if (value is List<object> list)
            {
                writer.WriteStartArray();

                foreach (var element in list)
                {
                    EncodeAsJson(writer, element);
                }

                writer.WriteStartArray();
                return;
            }

            writer.WriteValue(value);
        }

        private void EncodeAsJson(JsonTextWriter writer, Dictionary<string, object> value)
        {
            writer.WriteStartObject();

            foreach (var field in value)
            {
                writer.WritePropertyName(field.Key);
                EncodeAsJson(writer, field.Value);
            }

            writer.WriteEndObject();
        }

        /// <summary>
        /// Reads an extension object from the stream.
        /// </summary>
        public ExtensionObject ReadExtensionObject(string fieldName)
        {
            var extension = ExtensionObject.Null;
            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return extension;
            }

            var value = token as Dictionary<string, object>;

            if (value == null)
            {
                return extension;
            }

            try
            {
                m_stack.Push(value);

                ExpandedNodeId typeId = ReadExpandedNodeId("TypeId");
                ExpandedNodeId absoluteId =
                    typeId.IsAbsolute ?
                    typeId :
                    NodeId.ToExpandedNodeId(typeId.InnerNodeId, m_context.NamespaceUris);

                if (!NodeId.IsNull(typeId) && NodeId.IsNull(absoluteId))
                {
                    Utils.Trace("Cannot de-serialized extension objects if the NamespaceUri is not in the NamespaceTable: Type = {0}", typeId);
                }
                else
                {
                    typeId = absoluteId;
                }

                byte encoding = ReadByte("Encoding");

                if (encoding == (byte)ExtensionObjectEncoding.Binary)
                {
                    var bytes = ReadByteString("Body");
                    return new ExtensionObject(typeId, bytes ?? new byte[0]);
                }

                if (encoding == (byte)ExtensionObjectEncoding.Xml)
                {
                    var xml = ReadXmlElement("Body");
                    if (xml == null)
                    {
                        return extension;
                    }
                    return new ExtensionObject(typeId, xml);
                }

                if (encoding == (byte)ExtensionObjectEncoding.Json)
                {
                    var json = ReadString("Body");
                    if (String.IsNullOrEmpty(json))
                    {
                        return extension;
                    }
                    return new ExtensionObject(typeId, json);
                }

                Type systemType = m_context.Factory.GetSystemType(typeId);

                if (systemType != null)
                {
                    var encodeable = ReadEncodeable("Body", systemType);
                    if (encodeable == null)
                    {
                        return extension;
                    }

                    return new ExtensionObject(typeId, encodeable);
                }

                var ostrm = new MemoryStream();

                using (JsonTextWriter writer = new JsonTextWriter(new StreamWriter(ostrm)))
                {
                    EncodeAsJson(writer, token);
                }

                return new ExtensionObject(typeId, ostrm.ToArray());
            }
            finally
            {
                m_stack.Pop();
            }
        }

        /// <summary>
        /// Reads an encodeable object from the stream.
        /// </summary>
        /// <param name="fieldName">The encodeable object field name</param>
        /// <param name="systemType">The system type of the encopdeable object to be read</param>
        /// <param name="encodeableTypeId">The TypeId for the <see cref="IEncodeable"/> instance that will be read.</param>
        /// <returns>An <see cref="IEncodeable"/> object that was read from the stream.</returns>
        public IEncodeable ReadEncodeable(string fieldName, System.Type systemType, ExpandedNodeId encodeableTypeId = null)
        {
            if (systemType == null)
            {
                throw new ArgumentNullException(nameof(systemType));
            }

            object token = null;

            if (!ReadField(fieldName, out token))
            {
                return null;
            }

            IEncodeable value = Activator.CreateInstance(systemType) as IEncodeable;

            if (value == null)
            {
                throw new ServiceResultException(StatusCodes.BadDecodingError, Utils.Format("Type does not support IEncodeable interface: '{0}'", systemType.FullName));
            }

            if (encodeableTypeId != null)
            {
                // set type identifier for custom complex data types before decode.

                if (value is IComplexTypeInstance complexTypeInstance)
                {
                    complexTypeInstance.TypeId = encodeableTypeId;
                }
            }

            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            try
            {
                m_stack.Push(token);

                value.Decode(this);
            }
            finally
            {
                m_stack.Pop();
            }

            m_nestingLevel--;

            return value;
        }

        /// <summary>
        ///  Reads an enumerated value from the stream.
        /// </summary>
        public Enum ReadEnumerated(string fieldName, System.Type enumType)
        {
            if (enumType == null)
            {
                throw new ArgumentNullException(nameof(enumType));
            }

            return (Enum)Enum.ToObject(enumType, ReadInt32(fieldName));
        }

        private bool ReadArrayField(string fieldName, out List<object> array)
        {
            object token = array = null;

            if (!ReadField(fieldName, out token))
            {
                return false;
            }

            array = token as List<object>;

            if (array == null)
            {
                return false;
            }

            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < array.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            return true;
        }

        /// <summary>
        /// Reads a boolean array from the stream.
        /// </summary>
        public BooleanCollection ReadBooleanArray(string fieldName)
        {
            var values = new BooleanCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadBoolean(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a sbyte array from the stream.
        /// </summary>
        public SByteCollection ReadSByteArray(string fieldName)
        {
            var values = new SByteCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadSByte(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a byte array from the stream.
        /// </summary>
        public ByteCollection ReadByteArray(string fieldName)
        {
            var values = new ByteCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadByte(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a short array from the stream.
        /// </summary>
        public Int16Collection ReadInt16Array(string fieldName)
        {
            var values = new Int16Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadInt16(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a ushort array from the stream.
        /// </summary>
        public UInt16Collection ReadUInt16Array(string fieldName)
        {
            var values = new UInt16Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadUInt16(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a int array from the stream.
        /// </summary>
        public Int32Collection ReadInt32Array(string fieldName)
        {
            var values = new Int32Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadInt32(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a uint array from the stream.
        /// </summary>
        public UInt32Collection ReadUInt32Array(string fieldName)
        {
            var values = new UInt32Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadUInt32(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a long array from the stream.
        /// </summary>
        public Int64Collection ReadInt64Array(string fieldName)
        {
            var values = new Int64Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadInt64(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a ulong array from the stream.
        /// </summary>
        public UInt64Collection ReadUInt64Array(string fieldName)
        {
            var values = new UInt64Collection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadUInt64(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a float array from the stream.
        /// </summary>
        public FloatCollection ReadFloatArray(string fieldName)
        {
            var values = new FloatCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadFloat(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a double array from the stream.
        /// </summary>
        public DoubleCollection ReadDoubleArray(string fieldName)
        {
            var values = new DoubleCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadDouble(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a string array from the stream.
        /// </summary>
        public StringCollection ReadStringArray(string fieldName)
        {
            var values = new StringCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadString(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a UTC date/time array from the stream.
        /// </summary>
        public DateTimeCollection ReadDateTimeArray(string fieldName)
        {
            var values = new DateTimeCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    values.Add(ReadDateTime(null));
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a GUID array from the stream.
        /// </summary>
        public UuidCollection ReadGuidArray(string fieldName)
        {
            var values = new UuidCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadGuid(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads a byte string array from the stream.
        /// </summary>
        public ByteStringCollection ReadByteStringArray(string fieldName)
        {
            var values = new ByteStringCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadByteString(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an XmlElement array from the stream.
        /// </summary>
        public XmlElementCollection ReadXmlElementArray(string fieldName)
        {
            var values = new XmlElementCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadXmlElement(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an NodeId array from the stream.
        /// </summary>
        public NodeIdCollection ReadNodeIdArray(string fieldName)
        {
            var values = new NodeIdCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadNodeId(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an ExpandedNodeId array from the stream.
        /// </summary>
        public ExpandedNodeIdCollection ReadExpandedNodeIdArray(string fieldName)
        {
            var values = new ExpandedNodeIdCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadExpandedNodeId(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an StatusCode array from the stream.
        /// </summary>
        public StatusCodeCollection ReadStatusCodeArray(string fieldName)
        {
            var values = new StatusCodeCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadStatusCode(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an DiagnosticInfo array from the stream.
        /// </summary>
        public DiagnosticInfoCollection ReadDiagnosticInfoArray(string fieldName)
        {
            var values = new DiagnosticInfoCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadDiagnosticInfo(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an QualifiedName array from the stream.
        /// </summary>
        public QualifiedNameCollection ReadQualifiedNameArray(string fieldName)
        {
            var values = new QualifiedNameCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadQualifiedName(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an LocalizedText array from the stream.
        /// </summary>
        public LocalizedTextCollection ReadLocalizedTextArray(string fieldName)
        {
            var values = new LocalizedTextCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadLocalizedText(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an Variant array from the stream.
        /// </summary>
        public VariantCollection ReadVariantArray(string fieldName)
        {
            var values = new VariantCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadVariant(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an DataValue array from the stream.
        /// </summary>
        public DataValueCollection ReadDataValueArray(string fieldName)
        {
            var values = new DataValueCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadDataValue(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an array of extension objects from the stream.
        /// </summary>
        public ExtensionObjectCollection ReadExtensionObjectArray(string fieldName)
        {
            var values = new ExtensionObjectCollection();

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return values;
            }

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadExtensionObject(null);
                    values.Add(element);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an encodeable array from the stream.
        /// </summary>
        /// <param name="fieldName">The encodeable array field name</param>
        /// <param name="systemType">The system type of the encopdeable objects to be read object</param>
        /// <param name="encodeableTypeId">The TypeId for the <see cref="IEncodeable"/> instances that will be read.</param>
        /// <returns>An <see cref="IEncodeable"/> array that was read from the stream.</returns>
        public Array ReadEncodeableArray(string fieldName, System.Type systemType, ExpandedNodeId encodeableTypeId = null)
        {
            if (systemType == null)
            {
                throw new ArgumentNullException(nameof(systemType));
            }

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return Array.CreateInstance(systemType, 0);
            }

            var values = Array.CreateInstance(systemType, token.Count);

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadEncodeable(null, systemType, encodeableTypeId);
                    values.SetValue(element, ii);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }

        /// <summary>
        /// Reads an enumerated value array from the stream.
        /// </summary>
        public Array ReadEnumeratedArray(string fieldName, System.Type enumType)
        {
            if (enumType == null)
            {
                throw new ArgumentNullException(nameof(enumType));
            }

            List<object> token = null;

            if (!ReadArrayField(fieldName, out token))
            {
                return Array.CreateInstance(enumType, 0);
            }

            var values = Array.CreateInstance(enumType, token.Count);

            for (int ii = 0; ii < token.Count; ii++)
            {
                try
                {
                    m_stack.Push(token[ii]);
                    var element = ReadEnumerated(null, enumType);
                    values.SetValue(element, ii);
                }
                finally
                {
                    m_stack.Pop();
                }
            }

            return values;
        }
        #endregion

        #region Private Methods
        private NodeId DefaultNodeId(IdType idType, ushort namespaceIndex)
        {
            switch (idType)
            {
                case IdType.Numeric:
                default:
                {
                    return new NodeId(0U, namespaceIndex);
                }

                case IdType.Opaque:
                {
                    return new NodeId(new byte[0], namespaceIndex);
                }

                case IdType.String:
                {
                    return new NodeId("", namespaceIndex);
                }

                case IdType.Guid:
                {
                    return new NodeId(Guid.Empty, namespaceIndex);
                }
            }
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\JsonDecoder.cs(710,21): error CS0103: The name 'text' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\JsonDecoder.cs(710,54): error CS0103: The name 'text' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\JsonDecoder.cs(767,21): error CS0103: The name 'text' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\JsonDecoder.cs(767,54): error CS0103: The name 'text' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\JsonDecoder.cs(840,26): error CS8116: It is not legal to use nullable type 'DateTime?' in a pattern; use the underlying type 'DateTime' instead.
######################################################################


######################################################################
Nr: 24 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\JsonEncoder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// Writes objects to a JSON stream.
    /// </summary>
    public class JsonEncoder : IEncoder, IDisposable
    {
        #region Private Fields
        private MemoryStream m_destination;
        private StreamWriter m_writer;
        private Stack<string> m_namespaces;
        private bool m_commaRequired;
        private bool m_inVariantWithEncoding;
        private ServiceMessageContext m_context;
        private ushort[] m_namespaceMappings;
        private ushort[] m_serverMappings;
        private uint m_nestingLevel;
        private bool m_topLevelIsArray;
        private bool m_levelOneSkipped;
        private bool m_dontWriteClosing;
        #endregion

        #region Constructors
        /// <summary>
        /// Initializes the object with default values.
        /// </summary>
        public JsonEncoder(
            ServiceMessageContext context,
            bool useReversibleEncoding,
            StreamWriter writer = null,
            bool topLevelIsArray = false)
        {
            Initialize();

            m_context = context;
            m_nestingLevel = 0;
            m_writer = writer;
            UseReversibleEncoding = useReversibleEncoding;
            m_topLevelIsArray = topLevelIsArray;
            m_levelOneSkipped = false;

            // defaults for JSON encoding
            // -- encode namespace index for reversible encoding
            // -- do not include default values for built in types
            //    which are not a Number or a bool
            // -- include default values for numbers and bool
            ForceNamespaceUri = false;
            IncludeDefaultValues = false;
            IncludeDefaultNumberValues = true;

            if (m_writer == null)
            {
                m_destination = new MemoryStream();
                m_writer = new StreamWriter(m_destination, new UTF8Encoding(false));
            }

            if (m_topLevelIsArray)
            {
                m_writer.Write("[");
            }
            else
            {
                m_writer.Write("{");
            }
        }

        /// <summary>
        /// Sets private members to default values.
        /// </summary>
        private void Initialize()
        {
            m_destination = null;
            m_writer = null;
            m_namespaces = new Stack<string>();
            m_commaRequired = false;
        }

        /// <summary>
        /// Writes the root element to the stream.
        /// </summary>
        private void Initialize(string fieldName, string namespaceUri)
        {
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Encodes a session-less message to a buffer.
        /// </summary>
        public static void EncodeSessionLessMessage(IEncodeable message, Stream stream, ServiceMessageContext context, bool leaveOpen = false)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));
            if (context == null) throw new ArgumentNullException(nameof(context));

            // create encoder.
            JsonEncoder encoder = new JsonEncoder(context, true, new StreamWriter(stream, new UTF8Encoding(false), 65535, leaveOpen));

            try
            {
                long start = stream.Position;

                // write the message.
                var envelope = new SessionLessServiceMessage {
                    NamespaceUris = context.NamespaceUris,
                    ServerUris = context.ServerUris,
                    Message = message
                };

                envelope.Encode(encoder);

                // check that the max message size was not exceeded.
                if (context.MaxMessageSize > 0 && context.MaxMessageSize < (int)(stream.Position - start))
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadEncodingLimitsExceeded,
                        "MaxMessageSize {0} < {1}",
                        context.MaxMessageSize,
                        (int)(stream.Position - start));
                }

                encoder.Close();
            }
            finally
            {
                if (leaveOpen)
                {
                    encoder.m_writer.Flush();
                    stream.Position = 0;
                }
            }
        }

        /// <summary>
        /// Encodes a message in a stream.
        /// </summary>
        public static ArraySegment<byte> EncodeMessage(IEncodeable message, byte[] buffer, ServiceMessageContext context)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));
            if (buffer == null) throw new ArgumentNullException(nameof(buffer));
            if (context == null) throw new ArgumentNullException(nameof(context));

            using (MemoryStream stream = new MemoryStream(buffer, true))
            {
                var encoder = new JsonEncoder(context, true, new StreamWriter(stream, new UTF8Encoding(false), 65535, false));

                // encode message
                encoder.EncodeMessage(message);
                int length = encoder.Close();

                return new ArraySegment<byte>(buffer, 0, length);
            }
        }

        /// <summary>
        /// Encodes a message with its header.
        /// </summary>
        public void EncodeMessage(IEncodeable message)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));

            // convert the namespace uri to an index.
            NodeId typeId = ExpandedNodeId.ToNodeId(message.TypeId, m_context.NamespaceUris);

            // write the type id.
            WriteNodeId("TypeId", typeId);

            // write the message.
            WriteEncodeable("Body", message, message.GetType());
        }

        /// <summary>
        /// Initializes the tables used to map namespace and server uris during encoding.
        /// </summary>
        /// <param name="namespaceUris">The namespaces URIs referenced by the data being encoded.</param>
        /// <param name="serverUris">The server URIs referenced by the data being encoded.</param>
        public void SetMappingTables(NamespaceTable namespaceUris, StringTable serverUris)
        {
            m_namespaceMappings = null;

            if (namespaceUris != null && m_context.NamespaceUris != null)
            {
                m_namespaceMappings = namespaceUris.CreateMapping(m_context.NamespaceUris, false);
            }

            m_serverMappings = null;

            if (serverUris != null && m_context.ServerUris != null)
            {
                m_serverMappings = serverUris.CreateMapping(m_context.ServerUris, false);
            }
        }

        /// <summary>
        /// Completes writing and returns the JSON text.
        /// </summary>
        public string CloseAndReturnText()
        {
            Close();
            if (m_destination == null)
            {
                return String.Empty;
            }
            return Encoding.UTF8.GetString(m_destination.ToArray());
        }

        /// <summary>
        /// Completes writing and returns the text length.
        /// </summary>
        public int Close()
        {
            if (!m_dontWriteClosing)
            {
            if (m_topLevelIsArray)
            {
                m_writer.Write("]");
            }
            else
            {
                m_writer.Write("}");
            }
            }

            m_writer.Flush();
            int length = (int)m_writer.BaseStream.Position;
            m_writer.Dispose();
            m_writer = null;
            return length;
        }
        #endregion

        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (m_writer != null)
                {
                    Close();
                }
            }
        }
        #endregion

        #region IEncoder Members
        /// <summary>
        /// The type of encoding being used.
        /// </summary>
        public EncodingType EncodingType => EncodingType.Json;

        /// <summary>
        /// The message context associated with the encoder.
        /// </summary>
        public ServiceMessageContext Context => m_context;

        /// <summary>
        /// The Json encoder reversible encoding option
        /// </summary>
        public bool UseReversibleEncoding { get; private set; }

        /// <summary>
        /// The Json encoder to encoder namespace URI instead of
        /// namespace Index in NodeIds.
        /// </summary>
        public bool ForceNamespaceUri { get; set; }

        /// <summary>
        /// The Json encoder default value option.
        /// </summary>
        public bool IncludeDefaultValues { get; set; }

        /// <summary>
        /// The Json encoder default value option.
        /// </summary>
        public bool IncludeDefaultNumberValues { get; set; }

        /// <summary>
        /// Pushes a namespace onto the namespace stack.
        /// </summary>
        public void PushNamespace(string namespaceUri)
        {
            m_namespaces.Push(namespaceUri);
        }

        /// <summary>
        /// Pops a namespace from the namespace stack.
        /// </summary>
        public void PopNamespace()
        {
            m_namespaces.Pop();
        }

        /// <summary>
        /// Push the begin of a structure on the decoder stack.
        /// </summary>
        /// <param name="fieldName">The name of the structure field.</param>
        public void PushStructure(string fieldName)
        {
            m_nestingLevel++;

            if (m_commaRequired)
            {
                m_writer.Write(",");
            }

            if (!String.IsNullOrEmpty(fieldName))
            {
                m_writer.Write("\"");
                EscapeString(fieldName);
                m_writer.Write("\":");
            }
            else if (!m_commaRequired)
            {
                if (m_nestingLevel == 1 && !m_topLevelIsArray)
                {
                    m_levelOneSkipped = true;
                    return;
                }
            }

            m_commaRequired = false;
            m_writer.Write("{");
        }

        /// <summary>
        /// Push the begin of an array on the decoder stack.
        /// </summary>
        /// <param name="fieldName">The name of the array field.</param>
        public void PushArray(string fieldName)
        {
            m_nestingLevel++;

            if (m_commaRequired)
            {
                m_writer.Write(",");
            }

            if (!String.IsNullOrEmpty(fieldName))
            {
                m_writer.Write("\"");
                EscapeString(fieldName);
                m_writer.Write("\":");
            }
            else if (!m_commaRequired)
            {
                if (m_nestingLevel == 1 && !m_topLevelIsArray)
                {
                    m_levelOneSkipped = true;
                    return;
                }
            }

            m_commaRequired = false;
            m_writer.Write("[");
        }

        /// <summary>
        /// Pop the structure from the decoder stack.
        /// </summary>
        public void PopStructure()
        {
            if (m_nestingLevel > 1 || m_topLevelIsArray ||
               (m_nestingLevel == 1 && !m_levelOneSkipped))
            {
                m_writer.Write("}");
                m_commaRequired = true;
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Pop the array from the decoder stack.
        /// </summary>
        public void PopArray()
        {
            if (m_nestingLevel > 1 || m_topLevelIsArray ||
               (m_nestingLevel == 1 && !m_levelOneSkipped))
            {
                m_writer.Write("]");
                m_commaRequired = true;
            }

            m_nestingLevel--;
        }

        private readonly char[] m_specialChars = new char[] { '"', '\\', '\n', '\r', '\t', '\b', '\f', };
        private readonly char[] m_substitution = new char[] { '"', '\\', 'n', 'r', 't', 'b', 'f' };

        private void EscapeString(string value)
        {
            foreach (char ch in value)
            {
                bool found = false;

                for (int ii = 0; ii < m_specialChars.Length; ii++)
                {
                    if (m_specialChars[ii] == ch)
                    {
                        m_writer.Write('\\');
                        m_writer.Write(m_substitution[ii]);
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    if (ch < 32)
                    {
                        m_writer.Write("\\u");
                        m_writer.Write("{0:X4}", (int)ch);
                        continue;
                    }

                    m_writer.Write(ch);
                }
            }
        }

        private void WriteSimpleField(string fieldName, string value, bool quotes)
        {
            if (!String.IsNullOrEmpty(fieldName))
            {
                if (value == null)
                {
                    return;
                }

                if (m_commaRequired)
                {
                    m_writer.Write(",");
                }

                m_writer.Write("\"");
                EscapeString(fieldName);
                m_writer.Write("\":");
            }
            else
            {
                if (m_commaRequired)
                {
                    m_writer.Write(",");
                }
            }

            if (value != null)
            {
                if (quotes)
                {
                    m_writer.Write("\"");
                    EscapeString(value);
                    m_writer.Write("\"");
                }
                else
                {
                    m_writer.Write(value);
                }
            }
            else
            {
                m_writer.Write("null");
            }

            m_commaRequired = true;
        }

        /// <summary>
        /// Writes a boolean to the stream.
        /// </summary>
        public void WriteBoolean(string fieldName, bool value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && !value)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (value)
            {
                WriteSimpleField(fieldName, "true", false);
            }
            else
            {
                WriteSimpleField(fieldName, "false", false);
            }
        }

        /// <summary>
        /// Writes a sbyte to the stream.
        /// </summary>
        public void WriteSByte(string fieldName, sbyte value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes a byte to the stream.
        /// </summary>
        public void WriteByte(string fieldName, byte value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes a short to the stream.
        /// </summary>
        public void WriteInt16(string fieldName, short value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes a ushort to the stream.
        /// </summary>
        public void WriteUInt16(string fieldName, ushort value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes an int to the stream.
        /// </summary>
        public void WriteInt32(string fieldName, int value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes a uint to the stream.
        /// </summary>
        public void WriteUInt32(string fieldName, uint value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes a long to the stream.
        /// </summary>
        public void WriteInt64(string fieldName, long value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), true);
        }

        /// <summary>
        /// Writes a ulong to the stream.
        /// </summary>
        public void WriteUInt64(string fieldName, ulong value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), true);
        }

        /// <summary>
        /// Writes a float to the stream.
        /// </summary>
        public void WriteFloat(string fieldName, float value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && (value > -Single.Epsilon) && (value < Single.Epsilon))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (Single.IsNaN(value))
            {
                WriteSimpleField(fieldName, "NaN", true);
            }
            else if (Single.IsPositiveInfinity(value))
            {
                WriteSimpleField(fieldName, "Infinity", true);
            }
            else if (Single.IsNegativeInfinity(value))
            {
                WriteSimpleField(fieldName, "-Infinity", true);
            }
            else
            {
                WriteSimpleField(fieldName, value.ToString("R", CultureInfo.InvariantCulture), false);
            }
        }

        /// <summary>
        /// Writes a double to the stream.
        /// </summary>
        public void WriteDouble(string fieldName, double value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && (value > -Double.Epsilon) && (value < Double.Epsilon))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (Double.IsNaN(value))
            {
                WriteSimpleField(fieldName, "NaN", true);
            }
            else if (Double.IsPositiveInfinity(value))
            {
                WriteSimpleField(fieldName, "Infinity", true);
            }
            else if (Double.IsNegativeInfinity(value))
            {
                WriteSimpleField(fieldName, "-Infinity", true);
            }
            else
            {
                WriteSimpleField(fieldName, value.ToString("R", CultureInfo.InvariantCulture), false);
            }
        }

        /// <summary>
        /// Writes a string to the stream.
        /// </summary>
        public void WriteString(string fieldName, string value)
        {
            if (fieldName != null && !IncludeDefaultValues && value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value, true);
        }

        /// <summary>
        /// Writes a UTC date/time to the stream.
        /// </summary>
        public void WriteDateTime(string fieldName, DateTime value)
        {
            if (fieldName != null && !IncludeDefaultValues && value == DateTime.MinValue)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (value <= DateTime.MinValue)
            {
                WriteSimpleField(fieldName, "0001-01-01T00:00:00Z", true);
            }
            else if (value >= DateTime.MaxValue)
            {
                WriteSimpleField(fieldName, "9999-12-31T23:59:59Z", true);
            }
            else
            {
                WriteSimpleField(fieldName, value.ToUniversalTime()
                    .ToString("yyyy-MM-dd'T'HH:mm:ss.FFFFFFFK", CultureInfo.InvariantCulture), true);
            }
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Uuid value)
        {
            if (fieldName != null && !IncludeDefaultValues && value == Uuid.Empty)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(), true);
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Guid value)
        {
            if (fieldName != null && !IncludeDefaultValues && value == Guid.Empty)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(), true);
        }

        /// <summary>
        /// Writes a byte string to the stream.
        /// </summary>
        public void WriteByteString(string fieldName, byte[] value)
        {
            if (value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            // check the length.
            if (m_context.MaxByteStringLength > 0 && m_context.MaxByteStringLength < value.Length)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            WriteSimpleField(fieldName, Convert.ToBase64String(value), true);
        }

        /// <summary>
        /// Writes an XmlElement to the stream.
        /// </summary>
        public void WriteXmlElement(string fieldName, XmlElement value)
        {
            if (value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            var xml = value.OuterXml;
            var bytes = Encoding.UTF8.GetBytes(xml);

            WriteSimpleField(fieldName, Convert.ToBase64String(bytes), true);
        }

        private void WriteNamespaceIndex(string fieldName, ushort namespaceIndex)
        {
            if (namespaceIndex == 0)
            {
                return;
            }

            if (!UseReversibleEncoding && namespaceIndex > 1)
            {
                var uri = m_context.NamespaceUris.GetString(namespaceIndex);
                if (!String.IsNullOrEmpty(uri))
                {
                    WriteSimpleField(fieldName, uri, true);
                    return;
                }
            }

            if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
            {
                namespaceIndex = m_namespaceMappings[namespaceIndex];
            }

            if (namespaceIndex != 0)
            {
                WriteUInt16(fieldName, namespaceIndex);
            }
        }

        private void WriteNodeIdContents(NodeId value, string namespaceUri = null)
        {
            if (value.IdType > IdType.Numeric)
            {
                WriteInt32("IdType", (int)value.IdType);
            }

            switch (value.IdType)
            {
                case IdType.Numeric:
                {
                    WriteUInt32("Id", (uint)value.Identifier);
                    break;
                }

                case IdType.String:
                {
                    WriteString("Id", (string)value.Identifier);
                    break;
                }

                case IdType.Guid:
                {
                    WriteGuid("Id", (Guid)value.Identifier);
                    break;
                }

                case IdType.Opaque:
                {
                    WriteByteString("Id", (byte[])value.Identifier);
                    break;
                }
            }

            if (namespaceUri != null)
            {
                WriteString("Namespace", namespaceUri);
            }
            else
            {
                WriteNamespaceIndex("Namespace", value.NamespaceIndex);
            }
        }


        /// <summary>
        /// Writes an NodeId to the stream.
        /// </summary>
        public void WriteNodeId(string fieldName, NodeId value)
        {
            if (value == null ||
                (NodeId.IsNull(value) && (value.IdType == IdType.Numeric)))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushStructure(fieldName);

            ushort namespaceIndex = value.NamespaceIndex;
            if (ForceNamespaceUri && namespaceIndex > 1)
            {
                string namespaceUri = Context.NamespaceUris.GetString(namespaceIndex);
                WriteNodeIdContents(value, namespaceUri);
            }
            else
            {
                WriteNodeIdContents(value);
            }
            PopStructure();
        }

        /// <summary>
        /// Writes an ExpandedNodeId to the stream.
        /// </summary>
        public void WriteExpandedNodeId(string fieldName, ExpandedNodeId value)
        {
            if (value == null || value.InnerNodeId == null ||
                (!UseReversibleEncoding && NodeId.IsNull(value)))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushStructure(fieldName);

            string namespaceUri = value.NamespaceUri;
            ushort namespaceIndex = value.InnerNodeId.NamespaceIndex;
            if (ForceNamespaceUri && namespaceUri == null && namespaceIndex > 1)
            {
                namespaceUri = Context.NamespaceUris.GetString(namespaceIndex);
            }
            WriteNodeIdContents(value.InnerNodeId, namespaceUri);

            uint serverIndex = value.ServerIndex;

            if (serverIndex >= 1)
            {
                var uri = m_context.ServerUris.GetString(serverIndex);

                if (!String.IsNullOrEmpty(uri))
                {
                    WriteSimpleField("ServerUri", uri, true);
                    PopStructure();
                    return;
                }

                if (m_serverMappings != null && m_serverMappings.Length > serverIndex)
                {
                    serverIndex = m_serverMappings[serverIndex];
                }

                if (serverIndex != 0)
                {
                    WriteUInt32("ServerUri", serverIndex);
                }
            }

            PopStructure();
        }


        /// <summary>
        /// Writes an StatusCode to the stream.
        /// </summary>
        public void WriteStatusCode(string fieldName, StatusCode value)
        {
            if (fieldName != null && !IncludeDefaultValues && value == StatusCodes.Good)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (UseReversibleEncoding)
            {
                WriteUInt32(fieldName, value.Code);
                return;
            }

            if (value != StatusCodes.Good)
            {
                PushStructure(fieldName);
                WriteSimpleField("Code", value.Code.ToString(CultureInfo.InvariantCulture), false);
                WriteSimpleField("Symbol", StatusCode.LookupSymbolicId(value.CodeBits), true);
                PopStructure();
            }
        }

        /// <summary>
        /// Writes an DiagnosticInfo to the stream.
        /// </summary>
        public void WriteDiagnosticInfo(string fieldName, DiagnosticInfo value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            if (value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            m_nestingLevel++;

            PushStructure(fieldName);

            if (value.SymbolicId >= 0)
            {
                WriteSimpleField("SymbolicId", value.SymbolicId.ToString(CultureInfo.InvariantCulture), false);
            }

            if (value.NamespaceUri >= 0)
            {
                WriteSimpleField("NamespaceUri", value.NamespaceUri.ToString(CultureInfo.InvariantCulture), false);
            }

            if (value.Locale >= 0)
            {
                WriteSimpleField("Locale", value.Locale.ToString(CultureInfo.InvariantCulture), false);
            }

            if (value.LocalizedText >= 0)
            {
                WriteSimpleField("LocalizedText", value.LocalizedText.ToString(CultureInfo.InvariantCulture), false);
            }

            if (value.AdditionalInfo != null)
            {
                WriteSimpleField("AdditionalInfo", value.AdditionalInfo, true);
            }

            if (value.InnerStatusCode != StatusCodes.Good)
            {
                WriteStatusCode("InnerStatusCode", value.InnerStatusCode);
            }

            if (value.InnerDiagnosticInfo != null)
            {
                WriteDiagnosticInfo("InnerDiagnosticInfo", value.InnerDiagnosticInfo);
            }

            PopStructure();

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an QualifiedName to the stream.
        /// </summary>
        public void WriteQualifiedName(string fieldName, QualifiedName value)
        {
            if (QualifiedName.IsNull(value))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushStructure(fieldName);

            WriteString("Name", value.Name);
            WriteNamespaceIndex("Uri", value.NamespaceIndex);

            PopStructure();
        }

        /// <summary>
        /// Writes an LocalizedText to the stream.
        /// </summary>
        public void WriteLocalizedText(string fieldName, LocalizedText value)
        {
            if (LocalizedText.IsNullOrEmpty(value))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (UseReversibleEncoding)
            {
                PushStructure(fieldName);

                WriteSimpleField("Text", value.Text, true);

                if (!String.IsNullOrEmpty(value.Locale))
                {
                    WriteSimpleField("Locale", value.Locale, true);
                }

                PopStructure();
            }
            else
            {
                WriteSimpleField(fieldName, value.Text, true);
            }
        }

        /// <summary>
        /// Writes an Variant to the stream.
        /// </summary>
        public void WriteVariant(string fieldName, Variant value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            if (Variant.Null == value)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            m_nestingLevel++;

            bool isNull = (value.TypeInfo == null || value.TypeInfo.BuiltInType == BuiltInType.Null || value.Value == null);

            if (UseReversibleEncoding && !isNull)
            {
                PushStructure(fieldName);
                // encode enums as int32.
                byte encodingByte = (byte)value.TypeInfo.BuiltInType;
                if (value.TypeInfo.BuiltInType == BuiltInType.Enumeration)
                {
                    encodingByte = (byte)BuiltInType.Int32;
                }

                WriteByte("Type", encodingByte);
                fieldName = "Body";
            }

            if (m_commaRequired)
            {
                m_writer.Write(",");
            }

            if (!String.IsNullOrEmpty(fieldName))
            {
                m_writer.Write("\"");
                EscapeString(fieldName);
                m_writer.Write("\":");
            }

            WriteVariantContents(value.Value, value.TypeInfo);

            if (UseReversibleEncoding && !isNull)
            {
                Matrix matrix = value.Value as Matrix;

                if (matrix != null)
                {
                    WriteInt32Array("Dimensions", matrix.Dimensions);
                }

                PopStructure();
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValue(string fieldName, DataValue value, bool useReversibleEncoding)
        {
            bool currentValue = UseReversibleEncoding;

            try
            {
                UseReversibleEncoding = useReversibleEncoding;
                WriteDataValue(fieldName, value);
            }
            finally
            {
                UseReversibleEncoding = currentValue;
            }
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValue(string fieldName, DataValue value)
        {
            if (value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushStructure(fieldName);

            if (value != null)
            {
                if (value.WrappedValue.TypeInfo != null && value.WrappedValue.TypeInfo.BuiltInType != BuiltInType.Null)
                {
                    WriteVariant("Value", value.WrappedValue);
                }

                if (value.StatusCode != StatusCodes.Good)
                {
                    WriteStatusCode("StatusCode", value.StatusCode);
                }

                if (value.SourceTimestamp != DateTime.MinValue)
                {
                    WriteDateTime("SourceTimestamp", value.SourceTimestamp);

                    if (value.SourcePicoseconds != 0)
                    {
                        WriteUInt16("SourcePicoseconds", value.SourcePicoseconds);
                    }
                }

                if (value.ServerTimestamp != DateTime.MinValue)
                {
                    WriteDateTime("ServerTimestamp", value.ServerTimestamp);

                    if (value.ServerPicoseconds != 0)
                    {
                        WriteUInt16("ServerPicoseconds", value.ServerPicoseconds);
                    }
                }
            }

            PopStructure();
        }

        /// <summary>
        /// Writes an ExtensionObject to the stream.
        /// </summary>
        public void WriteExtensionObject(string fieldName, ExtensionObject value)
        {
            if (value == null || value.Encoding == ExtensionObjectEncoding.None)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            var encodeable = value.Body as IEncodeable;
            if (!UseReversibleEncoding && encodeable != null)
            {
                var structureType = value.Body as IStructureTypeInfo;
                if (structureType != null &&
                    structureType.StructureType == StructureType.Union)
                {
                    encodeable.Encode(this);
                    return;
                }

                PushStructure(fieldName);
                encodeable.Encode(this);
                PopStructure();
                return;
            }

            PushStructure(fieldName);

            if (UseReversibleEncoding)
            {
                var nodeId = ExpandedNodeId.ToNodeId(value.TypeId, Context.NamespaceUris);
                WriteNodeId("TypeId", nodeId);
            }
            else
            {
                WriteExpandedNodeId("TypeId", value.TypeId);
            }

            if (encodeable != null)
            {
                WriteEncodeable("Body", encodeable, null);
            }
            else
            {
                if (value.Body != null)
                {
                    if (value.Encoding == ExtensionObjectEncoding.Json)
                    {
                        WriteSimpleField("Body", value.Body as string, true);
                    }
                    else
                    {
                        WriteByte("Encoding", (byte)value.Encoding);
                        if (value.Encoding == ExtensionObjectEncoding.Binary)
                        {
                            WriteByteString("Body", value.Body as byte[]);
                        }
                        else if (value.Encoding == ExtensionObjectEncoding.Xml)
                        {
                            WriteXmlElement("Body", value.Body as XmlElement);
                        }
                    }
                }
            }

            PopStructure();
        }

        /// <summary>
        /// Writes an encodeable object to the stream.
        /// </summary>
        public void WriteEncodeable(string fieldName, IEncodeable value, System.Type systemType)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }


            if (value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (m_nestingLevel == 0 && (m_commaRequired || m_topLevelIsArray))
            {
                if (string.IsNullOrWhiteSpace(fieldName) ^ m_topLevelIsArray)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadEncodingError,
                        "With Array as top level, encodeables with fieldname will create invalid json");
                }
            }

            if (m_nestingLevel == 0 && !m_commaRequired)
            {
                if (string.IsNullOrWhiteSpace(fieldName) && !m_topLevelIsArray)
                {
                    m_writer.Flush();
                    if (m_writer.BaseStream.Length == 1) //Opening "{"
                    {
                        m_writer.BaseStream.Seek(0, SeekOrigin.Begin);
                    }
                    m_dontWriteClosing = true;
                }
            }

            m_nestingLevel++;

            PushStructure(fieldName);

            value?.Encode(this);

            PopStructure();

            m_nestingLevel--;

        }

        /// <summary>
        /// Writes an enumerated value to the stream.
        /// </summary>
        public void WriteEnumerated(string fieldName, Enum value)
        {
            int numeric = Convert.ToInt32(value, CultureInfo.InvariantCulture);
            var numericString = numeric.ToString();
            if (UseReversibleEncoding)
            {
                WriteSimpleField(fieldName, numericString, false);
            }
            else
            {
                var valueString = value.ToString();
                if (valueString == numericString)
                {
                    WriteSimpleField(fieldName, numericString, true);
                }
                else
                {
                    WriteSimpleField(fieldName, Utils.Format("{0}_{1}", value.ToString(), numeric), true);
                }
            }
        }

        /// <summary>
        /// Writes an enumerated Int32 value to the stream.
        /// </summary>
        public void WriteEnumerated(string fieldName, int numeric)
        {
            var numericString = numeric.ToString(CultureInfo.InvariantCulture);
            WriteSimpleField(fieldName, numericString, !UseReversibleEncoding);
        }

        /// <summary>
        /// Writes a boolean array to the stream.
        /// </summary>
        public void WriteBooleanArray(string fieldName, IList<bool> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteBoolean(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteSByteArray(string fieldName, IList<sbyte> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteSByte(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteByteArray(string fieldName, IList<byte> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteByte(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a short array to the stream.
        /// </summary>
        public void WriteInt16Array(string fieldName, IList<short> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt16(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a ushort array to the stream.
        /// </summary>
        public void WriteUInt16Array(string fieldName, IList<ushort> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt16(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a int array to the stream.
        /// </summary>
        public void WriteInt32Array(string fieldName, IList<int> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt32(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a uint array to the stream.
        /// </summary>
        public void WriteUInt32Array(string fieldName, IList<uint> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt32(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a long array to the stream.
        /// </summary>
        public void WriteInt64Array(string fieldName, IList<long> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt64(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a ulong array to the stream.
        /// </summary>
        public void WriteUInt64Array(string fieldName, IList<ulong> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt64(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a float array to the stream.
        /// </summary>
        public void WriteFloatArray(string fieldName, IList<float> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteFloat(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a double array to the stream.
        /// </summary>
        public void WriteDoubleArray(string fieldName, IList<double> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDouble(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a string array to the stream.
        /// </summary>
        public void WriteStringArray(string fieldName, IList<string> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteString(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a UTC date/time array to the stream.
        /// </summary>
        public void WriteDateTimeArray(string fieldName, IList<DateTime> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (values[ii] <= DateTime.MinValue)
                {
                    WriteSimpleField(null, null, false);
                }
                else
                {
                    WriteDateTime(null, values[ii]);
                }
            }

            PopArray();
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Uuid> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteGuid(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Guid> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteGuid(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a byte string array to the stream.
        /// </summary>
        public void WriteByteStringArray(string fieldName, IList<byte[]> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteByteString(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an XmlElement array to the stream.
        /// </summary>
        public void WriteXmlElementArray(string fieldName, IList<XmlElement> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteXmlElement(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an NodeId array to the stream.
        /// </summary>
        public void WriteNodeIdArray(string fieldName, IList<NodeId> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteNodeId(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an ExpandedNodeId array to the stream.
        /// </summary>
        public void WriteExpandedNodeIdArray(string fieldName, IList<ExpandedNodeId> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteExpandedNodeId(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an StatusCode array to the stream.
        /// </summary>
        public void WriteStatusCodeArray(string fieldName, IList<StatusCode> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (!UseReversibleEncoding &&
                    values[ii] == StatusCodes.Good)
                {
                    WriteSimpleField(null, null, false);
                }
                else
                {
                    WriteStatusCode(null, values[ii]);
                }
            }

            PopArray();
        }

        /// <summary>
        /// Writes an DiagnosticInfo array to the stream.
        /// </summary>
        public void WriteDiagnosticInfoArray(string fieldName, IList<DiagnosticInfo> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDiagnosticInfo(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an QualifiedName array to the stream.
        /// </summary>
        public void WriteQualifiedNameArray(string fieldName, IList<QualifiedName> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteQualifiedName(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an LocalizedText array to the stream.
        /// </summary>
        public void WriteLocalizedTextArray(string fieldName, IList<LocalizedText> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteLocalizedText(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteVariantArray(string fieldName, IList<Variant> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (values[ii] == Variant.Null)
                {
                    WriteSimpleField(null, null, false);
                    continue;
                }

                WriteVariant(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValueArray(string fieldName, IList<DataValue> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDataValue(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an extension object array to the stream.
        /// </summary>
        public void WriteExtensionObjectArray(string fieldName, IList<ExtensionObject> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteExtensionObject(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an encodeable object array to the stream.
        /// </summary>
        public void WriteEncodeableArray(string fieldName, IList<IEncodeable> values, System.Type systemType)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (string.IsNullOrWhiteSpace(fieldName) && m_nestingLevel == 0 && !m_topLevelIsArray)
            {
                m_writer.Flush();
                if (m_writer.BaseStream.Length == 1) //Opening "{"
                {
                    m_writer.BaseStream.Seek(0, SeekOrigin.Begin);
                }

                m_nestingLevel++;
                PushArray(fieldName);

                for (int ii = 0; ii < values.Count; ii++)
                {
                    WriteEncodeable(null, values[ii], systemType);
                }

                PopArray();
                m_dontWriteClosing = true;
                m_nestingLevel--;

            }
            else if (!string.IsNullOrWhiteSpace(fieldName) && m_nestingLevel == 0 && m_topLevelIsArray)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingError,
                    "With Array as top level, encodeables array with filename will create invalid json");
            }
            else
            {
                PushArray(fieldName);

	            // check the length.
	            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
	            {
	                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
	            }

	            for (int ii = 0; ii < values.Count; ii++)
	            {
	                WriteEncodeable(null, values[ii], systemType);
	            }

	            PopArray();
            }
        }

        /// <summary>
        /// Writes an enumerated value array to the stream.
        /// </summary>
        public void WriteEnumeratedArray(string fieldName, Array values, System.Type systemType)
        {
            if (values == null || values.Length == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Length)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            // encode each element in the array.
            Type arrayType = values.GetType().GetElementType();
            if (arrayType.IsEnum)
            {
                foreach (Enum value in values)
                {
                    WriteEnumerated(null, value);
                }
            }
            else
            {
                if (arrayType != typeof(Int32))
                {
                    throw new ServiceResultException(
                        StatusCodes.BadEncodingError,
                        Utils.Format("Type '{0}' is not allowed in an Enumeration.", arrayType.FullName));
                }
                foreach (Int32 value in values)
                {
                    WriteEnumerated(null, value);
                }
            }

            PopArray();
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Writes the contents of an Variant to the stream.
        /// </summary>
        public void WriteVariantContents(object value, TypeInfo typeInfo)
        {
            try
            {
                m_inVariantWithEncoding = UseReversibleEncoding;

                // check for null.
                if (value == null)
                {
                    return;
                }

                m_commaRequired = false;

                // write scalar.
                if (typeInfo.ValueRank < 0)
                {
                    switch (typeInfo.BuiltInType)
                    {
                        case BuiltInType.Boolean: { WriteBoolean(null, (bool)value); return; }
                        case BuiltInType.SByte: { WriteSByte(null, (sbyte)value); return; }
                        case BuiltInType.Byte: { WriteByte(null, (byte)value); return; }
                        case BuiltInType.Int16: { WriteInt16(null, (short)value); return; }
                        case BuiltInType.UInt16: { WriteUInt16(null, (ushort)value); return; }
                        case BuiltInType.Int32: { WriteInt32(null, (int)value); return; }
                        case BuiltInType.UInt32: { WriteUInt32(null, (uint)value); return; }
                        case BuiltInType.Int64: { WriteInt64(null, (long)value); return; }
                        case BuiltInType.UInt64: { WriteUInt64(null, (ulong)value); return; }
                        case BuiltInType.Float: { WriteFloat(null, (float)value); return; }
                        case BuiltInType.Double: { WriteDouble(null, (double)value); return; }
                        case BuiltInType.String: { WriteString(null, (string)value); return; }
                        case BuiltInType.DateTime: { WriteDateTime(null, (DateTime)value); return; }
                        case BuiltInType.Guid: { WriteGuid(null, (Uuid)value); return; }
                        case BuiltInType.ByteString: { WriteByteString(null, (byte[])value); return; }
                        case BuiltInType.XmlElement: { WriteXmlElement(null, (XmlElement)value); return; }
                        case BuiltInType.NodeId: { WriteNodeId(null, (NodeId)value); return; }
                        case BuiltInType.ExpandedNodeId: { WriteExpandedNodeId(null, (ExpandedNodeId)value); return; }
                        case BuiltInType.StatusCode: { WriteStatusCode(null, (StatusCode)value); return; }
                        case BuiltInType.QualifiedName: { WriteQualifiedName(null, (QualifiedName)value); return; }
                        case BuiltInType.LocalizedText: { WriteLocalizedText(null, (LocalizedText)value); return; }
                        case BuiltInType.ExtensionObject: { WriteExtensionObject(null, (ExtensionObject)value); return; }
                        case BuiltInType.DataValue: { WriteDataValue(null, (DataValue)value); return; }
                        case BuiltInType.Enumeration: { WriteEnumerated(null, (Enum)value); return; }
                    }
                }

                // write array.
                else if (typeInfo.ValueRank <= 1)
                {
                    switch (typeInfo.BuiltInType)
                    {
                        case BuiltInType.Boolean: { WriteBooleanArray(null, (bool[])value); return; }
                        case BuiltInType.SByte: { WriteSByteArray(null, (sbyte[])value); return; }
                        case BuiltInType.Byte: { WriteByteArray(null, (byte[])value); return; }
                        case BuiltInType.Int16: { WriteInt16Array(null, (short[])value); return; }
                        case BuiltInType.UInt16: { WriteUInt16Array(null, (ushort[])value); return; }
                        case BuiltInType.Int32: { WriteInt32Array(null, (int[])value); return; }
                        case BuiltInType.UInt32: { WriteUInt32Array(null, (uint[])value); return; }
                        case BuiltInType.Int64: { WriteInt64Array(null, (long[])value); return; }
                        case BuiltInType.UInt64: { WriteUInt64Array(null, (ulong[])value); return; }
                        case BuiltInType.Float: { WriteFloatArray(null, (float[])value); return; }
                        case BuiltInType.Double: { WriteDoubleArray(null, (double[])value); return; }
                        case BuiltInType.String: { WriteStringArray(null, (string[])value); return; }
                        case BuiltInType.DateTime: { WriteDateTimeArray(null, (DateTime[])value); return; }
                        case BuiltInType.Guid: { WriteGuidArray(null, (Uuid[])value); return; }
                        case BuiltInType.ByteString: { WriteByteStringArray(null, (byte[][])value); return; }
                        case BuiltInType.XmlElement: { WriteXmlElementArray(null, (XmlElement[])value); return; }
                        case BuiltInType.NodeId: { WriteNodeIdArray(null, (NodeId[])value); return; }
                        case BuiltInType.ExpandedNodeId: { WriteExpandedNodeIdArray(null, (ExpandedNodeId[])value); return; }
                        case BuiltInType.StatusCode: { WriteStatusCodeArray(null, (StatusCode[])value); return; }
                        case BuiltInType.QualifiedName: { WriteQualifiedNameArray(null, (QualifiedName[])value); return; }
                        case BuiltInType.LocalizedText: { WriteLocalizedTextArray(null, (LocalizedText[])value); return; }
                        case BuiltInType.ExtensionObject: { WriteExtensionObjectArray(null, (ExtensionObject[])value); return; }
                        case BuiltInType.DataValue: { WriteDataValueArray(null, (DataValue[])value); return; }
                        case BuiltInType.Enumeration:
                        {
                            Array array = value as Array;
                            WriteEnumeratedArray(null, array, array.GetType().GetElementType());
                            return;
                        }

                        case BuiltInType.Variant:
                        {
                            Variant[] variants = value as Variant[];

                            if (variants != null)
                            {
                                WriteVariantArray(null, variants);
                                return;
                            }

                            object[] objects = value as object[];

                            if (objects != null)
                            {
                                WriteObjectArray(null, objects);
                                return;
                            }

                            throw ServiceResultException.Create(
                                StatusCodes.BadEncodingError,
                                "Unexpected type encountered while encoding an array of Variants: {0}",
                                value.GetType());
                        }
                    }
                }

                // write matrix.
                else if (typeInfo.ValueRank > 1)
                {
                    Matrix matrix = value as Matrix;
                    if (matrix != null)
                    {
                        if (UseReversibleEncoding)
                        {
                            WriteVariantContents(matrix.Elements, new TypeInfo(typeInfo.BuiltInType, 1));
                        }
                        else
                        {
                            int index = 0;
                            WriteStructureMatrix(matrix, 0, ref index, typeInfo);
                        }
                        return;
                    }
                }

                // oops - should never happen.
                throw new ServiceResultException(
                    StatusCodes.BadEncodingError,
                    Utils.Format("Type '{0}' is not allowed in an Variant.", value.GetType().FullName));
            }
            finally
            {
                m_inVariantWithEncoding = false;
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Write multi dimensional array in structure.
        /// </summary>
        private void WriteStructureMatrix(
            Matrix matrix,
            int dim,
            ref int index,
            TypeInfo typeInfo)
        {
            var arrayLen = matrix.Dimensions[dim];
            if (dim == matrix.Dimensions.Length - 1)
            {
                // Create a slice of values for the top dimension
                var copy = Array.CreateInstance(
                    matrix.Elements.GetType().GetElementType(), arrayLen);
                Array.Copy(matrix.Elements, index, copy, 0, arrayLen);
                // Write slice as value rank
                if (m_commaRequired)
                {
                    m_writer.Write(",");
                }
                WriteVariantContents(copy, new TypeInfo(typeInfo.BuiltInType, 1));
                index += arrayLen;
            }
            else
            {
                PushArray(null);
                for (var i = 0; i < arrayLen; i++)
                {
                    WriteStructureMatrix(matrix, dim + 1, ref index, typeInfo);
                }
                PopArray();
            }
        }

        /// <summary>
        /// Write multi dimensional array in Variant.
        /// </summary>
        private void WriteVariantMatrix(string fieldName, Matrix value)
        {
            PushStructure(fieldName);
            WriteVariant("Matrix", new Variant(value.Elements, new TypeInfo(value.TypeInfo.BuiltInType, ValueRanks.OneDimension)));
            WriteInt32Array("Dimensions", value.Dimensions);
            PopStructure();
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteObjectArray(string fieldName, IList<object> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            if (values != null)
            {
                for (int ii = 0; ii < values.Count; ii++)
                {
                    WriteVariant("Variant", new Variant(values[ii]));
                }
            }

            PopArray();
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// Writes objects to a JSON stream.
    /// </summary>
    public class JsonEncoder : IEncoder, IDisposable
    {
        #region Private Fields
        private MemoryStream m_destination;
        private StreamWriter m_writer;
        private Stack<string> m_namespaces;
        private bool m_commaRequired;
        private bool m_inVariantWithEncoding;
        private ServiceMessageContext m_context;
        private ushort[] m_namespaceMappings;
        private ushort[] m_serverMappings;
        private uint m_nestingLevel;
        private bool m_topLevelIsArray;
        private bool m_levelOneSkipped;
        private bool m_dontWriteClosing;
        #endregion

        #region Constructors
        /// <summary>
        /// Initializes the object with default values.
        /// </summary>
        public JsonEncoder(
            ServiceMessageContext context,
            bool useReversibleEncoding,
            StreamWriter writer = null,
            bool topLevelIsArray = false)
        {
            Initialize();

            m_context = context;
            m_nestingLevel = 0;
            m_writer = writer;
            UseReversibleEncoding = useReversibleEncoding;
            m_topLevelIsArray = topLevelIsArray;
            m_levelOneSkipped = false;

            // defaults for JSON encoding
            // -- encode namespace index for reversible encoding
            // -- do not include default values for built in types
            //    which are not a Number or a bool
            // -- include default values for numbers and bool
            ForceNamespaceUri = false;
            IncludeDefaultValues = false;
            IncludeDefaultNumberValues = true;

            if (m_writer == null)
            {
                m_destination = new MemoryStream();
                m_writer = new StreamWriter(m_destination, new UTF8Encoding(false));
            }

            if (m_topLevelIsArray)
            {
                m_writer.Write("[");
            }
            else
            {
                m_writer.Write("{");
            }
        }

        /// <summary>
        /// Sets private members to default values.
        /// </summary>
        private void Initialize()
        {
            m_destination = null;
            m_writer = null;
            m_namespaces = new Stack<string>();
            m_commaRequired = false;
        }

        /// <summary>
        /// Writes the root element to the stream.
        /// </summary>
        private void Initialize(string fieldName, string namespaceUri)
        {
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Encodes a session-less message to a buffer.
        /// </summary>
        public static void EncodeSessionLessMessage(IEncodeable message, Stream stream, ServiceMessageContext context, bool leaveOpen = false)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));
            if (context == null) throw new ArgumentNullException(nameof(context));

            // create encoder.
            JsonEncoder encoder = new JsonEncoder(context, true, new StreamWriter(stream, new UTF8Encoding(false), 65535, leaveOpen));

            try
            {
                long start = stream.Position;

                // write the message.
                var envelope = new SessionLessServiceMessage {
                    NamespaceUris = context.NamespaceUris,
                    ServerUris = context.ServerUris,
                    Message = message
                };

                envelope.Encode(encoder);

                // check that the max message size was not exceeded.
                if (context.MaxMessageSize > 0 && context.MaxMessageSize < (int)(stream.Position - start))
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadEncodingLimitsExceeded,
                        "MaxMessageSize {0} < {1}",
                        context.MaxMessageSize,
                        (int)(stream.Position - start));
                }

                encoder.Close();
            }
            finally
            {
                if (leaveOpen)
                {
                    encoder.m_writer.Flush();
                    stream.Position = 0;
                }
            }
        }

        /// <summary>
        /// Encodes a message in a stream.
        /// </summary>
        public static ArraySegment<byte> EncodeMessage(IEncodeable message, byte[] buffer, ServiceMessageContext context)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));
            if (buffer == null) throw new ArgumentNullException(nameof(buffer));
            if (context == null) throw new ArgumentNullException(nameof(context));

            using (MemoryStream stream = new MemoryStream(buffer, true))
            {
                var encoder = new JsonEncoder(context, true, new StreamWriter(stream, new UTF8Encoding(false), 65535, false));

                // encode message
                encoder.EncodeMessage(message);
                int length = encoder.Close();

                return new ArraySegment<byte>(buffer, 0, length);
            }
        }

        /// <summary>
        /// Encodes a message with its header.
        /// </summary>
        public void EncodeMessage(IEncodeable message)
        {
            if (message == null) throw new ArgumentNullException(nameof(message));

            // convert the namespace uri to an index.
            NodeId typeId = ExpandedNodeId.ToNodeId(message.TypeId, m_context.NamespaceUris);

            // write the type id.
            WriteNodeId("TypeId", typeId);

            // write the message.
            WriteEncodeable("Body", message, message.GetType());
        }

        /// <summary>
        /// Initializes the tables used to map namespace and server uris during encoding.
        /// </summary>
        /// <param name="namespaceUris">The namespaces URIs referenced by the data being encoded.</param>
        /// <param name="serverUris">The server URIs referenced by the data being encoded.</param>
        public void SetMappingTables(NamespaceTable namespaceUris, StringTable serverUris)
        {
            m_namespaceMappings = null;

            if (namespaceUris != null && m_context.NamespaceUris != null)
            {
                m_namespaceMappings = namespaceUris.CreateMapping(m_context.NamespaceUris, false);
            }

            m_serverMappings = null;

            if (serverUris != null && m_context.ServerUris != null)
            {
                m_serverMappings = serverUris.CreateMapping(m_context.ServerUris, false);
            }
        }

        /// <summary>
        /// Completes writing and returns the JSON text.
        /// </summary>
        public string CloseAndReturnText()
        {
            Close();
            if (m_destination == null)
            {
                return String.Empty;
            }
            return Encoding.UTF8.GetString(m_destination.ToArray());
        }

        /// <summary>
        /// Completes writing and returns the text length.
        /// </summary>
        public int Close()
        {
            if (!m_dontWriteClosing)
            {
            if (m_topLevelIsArray)
            {
                m_writer.Write("]");
            }
            else
            {
                m_writer.Write("}");
            }
            }

            m_writer.Flush();
            int length = (int)m_writer.BaseStream.Position;
            m_writer.Dispose();
            m_writer = null;
            return length;
        }
        #endregion

        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (m_writer != null)
                {
                    Close();
                }
            }
        }
        #endregion

        #region IEncoder Members
        /// <summary>
        /// The type of encoding being used.
        /// </summary>
        public EncodingType EncodingType => EncodingType.Json;

        /// <summary>
        /// The message context associated with the encoder.
        /// </summary>
        public ServiceMessageContext Context => m_context;

        /// <summary>
        /// The Json encoder reversible encoding option
        /// </summary>
        public bool UseReversibleEncoding { get; private set; }

        /// <summary>
        /// The Json encoder to encoder namespace URI instead of
        /// namespace Index in NodeIds.
        /// </summary>
        public bool ForceNamespaceUri { get; set; }

        /// <summary>
        /// The Json encoder default value option.
        /// </summary>
        public bool IncludeDefaultValues { get; set; }

        /// <summary>
        /// The Json encoder default value option.
        /// </summary>
        public bool IncludeDefaultNumberValues { get; set; }

        /// <summary>
        /// Pushes a namespace onto the namespace stack.
        /// </summary>
        public void PushNamespace(string namespaceUri)
        {
            m_namespaces.Push(namespaceUri);
        }

        /// <summary>
        /// Pops a namespace from the namespace stack.
        /// </summary>
        public void PopNamespace()
        {
            m_namespaces.Pop();
        }

        /// <summary>
        /// Push the begin of a structure on the decoder stack.
        /// </summary>
        /// <param name="fieldName">The name of the structure field.</param>
        public void PushStructure(string fieldName)
        {
            m_nestingLevel++;

            if (m_commaRequired)
            {
                m_writer.Write(",");
            }

            if (!String.IsNullOrEmpty(fieldName))
            {
                m_writer.Write("\"");
                EscapeString(fieldName);
                m_writer.Write("\":");
            }
            else if (!m_commaRequired)
            {
                if (m_nestingLevel == 1 && !m_topLevelIsArray)
                {
                    m_levelOneSkipped = true;
                    return;
                }
            }

            m_commaRequired = false;
            m_writer.Write("{");
        }

        /// <summary>
        /// Push the begin of an array on the decoder stack.
        /// </summary>
        /// <param name="fieldName">The name of the array field.</param>
        public void PushArray(string fieldName)
        {
            m_nestingLevel++;

            if (m_commaRequired)
            {
                m_writer.Write(",");
            }

            if (!String.IsNullOrEmpty(fieldName))
            {
                m_writer.Write("\"");
                EscapeString(fieldName);
                m_writer.Write("\":");
            }
            else if (!m_commaRequired)
            {
                if (m_nestingLevel == 1 && !m_topLevelIsArray)
                {
                    m_levelOneSkipped = true;
                    return;
                }
            }

            m_commaRequired = false;
            m_writer.Write("[");
        }

        /// <summary>
        /// Pop the structure from the decoder stack.
        /// </summary>
        public void PopStructure()
        {
            if (m_nestingLevel > 1 || m_topLevelIsArray ||
               (m_nestingLevel == 1 && !m_levelOneSkipped))
            {
                m_writer.Write("}");
                m_commaRequired = true;
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Pop the array from the decoder stack.
        /// </summary>
        public void PopArray()
        {
            if (m_nestingLevel > 1 || m_topLevelIsArray ||
               (m_nestingLevel == 1 && !m_levelOneSkipped))
            {
                m_writer.Write("]");
                m_commaRequired = true;
            }

            m_nestingLevel--;
        }

        private readonly char[] m_specialChars = new char[] { '"', '\\', '\n', '\r', '\t', '\b', '\f', };
        private readonly char[] m_substitution = new char[] { '"', '\\', 'n', 'r', 't', 'b', 'f' };

        private void EscapeString(string value)
        {
            foreach (char ch in value)
            {
                bool found = false;

                for (int ii = 0; ii < m_specialChars.Length; ii++)
                {
                    if (m_specialChars[ii] == ch)
                    {
                        m_writer.Write('\\');
                        m_writer.Write(m_substitution[ii]);
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    if (ch < 32)
                    {
                        m_writer.Write("\\u");
                        m_writer.Write("{0:X4}", (int)ch);
                        continue;
                    }

                    m_writer.Write(ch);
                }
            }
        }

        private void WriteSimpleField(string fieldName, string value, bool quotes)
        {
            if (!String.IsNullOrEmpty(fieldName))
            {
                if (value == null)
                {
                    return;
                }

                if (m_commaRequired)
                {
                    m_writer.Write(",");
                }

                m_writer.Write("\"");
                EscapeString(fieldName);
                m_writer.Write("\":");
            }
            else
            {
                if (m_commaRequired)
                {
                    m_writer.Write(",");
                }
            }

            if (value != null)
            {
                if (quotes)
                {
                    m_writer.Write("\"");
                    EscapeString(value);
                    m_writer.Write("\"");
                }
                else
                {
                    m_writer.Write(value);
                }
            }
            else
            {
                m_writer.Write("null");
            }

            m_commaRequired = true;
        }

        /// <summary>
        /// Writes a boolean to the stream.
        /// </summary>
        public void WriteBoolean(string fieldName, bool value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && !value)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (value)
            {
                WriteSimpleField(fieldName, "true", false);
            }
            else
            {
                WriteSimpleField(fieldName, "false", false);
            }
        }

        /// <summary>
        /// Writes a sbyte to the stream.
        /// </summary>
        public void WriteSByte(string fieldName, sbyte value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes a byte to the stream.
        /// </summary>
        public void WriteByte(string fieldName, byte value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes a short to the stream.
        /// </summary>
        public void WriteInt16(string fieldName, short value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes a ushort to the stream.
        /// </summary>
        public void WriteUInt16(string fieldName, ushort value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes an int to the stream.
        /// </summary>
        public void WriteInt32(string fieldName, int value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes a uint to the stream.
        /// </summary>
        public void WriteUInt32(string fieldName, uint value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), false);
        }

        /// <summary>
        /// Writes a long to the stream.
        /// </summary>
        public void WriteInt64(string fieldName, long value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), true);
        }

        /// <summary>
        /// Writes a ulong to the stream.
        /// </summary>
        public void WriteUInt64(string fieldName, ulong value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && value == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(CultureInfo.InvariantCulture), true);
        }

        /// <summary>
        /// Writes a float to the stream.
        /// </summary>
        public void WriteFloat(string fieldName, float value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && (value > -Single.Epsilon) && (value < Single.Epsilon))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (Single.IsNaN(value))
            {
                WriteSimpleField(fieldName, "NaN", true);
            }
            else if (Single.IsPositiveInfinity(value))
            {
                WriteSimpleField(fieldName, "Infinity", true);
            }
            else if (Single.IsNegativeInfinity(value))
            {
                WriteSimpleField(fieldName, "-Infinity", true);
            }
            else
            {
                WriteSimpleField(fieldName, value.ToString("R", CultureInfo.InvariantCulture), false);
            }
        }

        /// <summary>
        /// Writes a double to the stream.
        /// </summary>
        public void WriteDouble(string fieldName, double value)
        {
            if (fieldName != null && !IncludeDefaultNumberValues && (value > -Double.Epsilon) && (value < Double.Epsilon))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (Double.IsNaN(value))
            {
                WriteSimpleField(fieldName, "NaN", true);
            }
            else if (Double.IsPositiveInfinity(value))
            {
                WriteSimpleField(fieldName, "Infinity", true);
            }
            else if (Double.IsNegativeInfinity(value))
            {
                WriteSimpleField(fieldName, "-Infinity", true);
            }
            else
            {
                WriteSimpleField(fieldName, value.ToString("R", CultureInfo.InvariantCulture), false);
            }
        }

        /// <summary>
        /// Writes a string to the stream.
        /// </summary>
        public void WriteString(string fieldName, string value)
        {
            if (fieldName != null && !IncludeDefaultValues && value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value, true);
        }

        /// <summary>
        /// Writes a UTC date/time to the stream.
        /// </summary>
        public void WriteDateTime(string fieldName, DateTime value)
        {
            if (fieldName != null && !IncludeDefaultValues && value == DateTime.MinValue)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (value <= DateTime.MinValue)
            {
                WriteSimpleField(fieldName, "0001-01-01T00:00:00Z", true);
            }
            else if (value >= DateTime.MaxValue)
            {
                WriteSimpleField(fieldName, "9999-12-31T23:59:59Z", true);
            }
            else
            {
                WriteSimpleField(fieldName, value.ToUniversalTime()
                    .ToString("yyyy-MM-dd'T'HH:mm:ss.FFFFFFFK", CultureInfo.InvariantCulture), true);
            }
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Uuid value)
        {
            if (fieldName != null && !IncludeDefaultValues && value == Uuid.Empty)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(), true);
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Guid value)
        {
            if (fieldName != null && !IncludeDefaultValues && value == Guid.Empty)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            WriteSimpleField(fieldName, value.ToString(), true);
        }

        /// <summary>
        /// Writes a byte string to the stream.
        /// </summary>
        public void WriteByteString(string fieldName, byte[] value)
        {
            if (value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            // check the length.
            if (m_context.MaxByteStringLength > 0 && m_context.MaxByteStringLength < value.Length)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            WriteSimpleField(fieldName, Convert.ToBase64String(value), true);
        }

        /// <summary>
        /// Writes an XmlElement to the stream.
        /// </summary>
        public void WriteXmlElement(string fieldName, XmlElement value)
        {
            if (value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            var xml = value.OuterXml;
            var bytes = Encoding.UTF8.GetBytes(xml);

            WriteSimpleField(fieldName, Convert.ToBase64String(bytes), true);
        }

        private void WriteNamespaceIndex(string fieldName, ushort namespaceIndex)
        {
            if (namespaceIndex == 0)
            {
                return;
            }

            if (!UseReversibleEncoding && namespaceIndex > 1)
            {
                var uri = m_context.NamespaceUris.GetString(namespaceIndex);
                if (!String.IsNullOrEmpty(uri))
                {
                    WriteSimpleField(fieldName, uri, true);
                    return;
                }
            }

            if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
            {
                namespaceIndex = m_namespaceMappings[namespaceIndex];
            }

            if (namespaceIndex != 0)
            {
                WriteUInt16(fieldName, namespaceIndex);
            }
        }

        private void WriteNodeIdContents(NodeId value, string namespaceUri = null)
        {
            if (value.IdType > IdType.Numeric)
            {
                WriteInt32("IdType", (int)value.IdType);
            }

            switch (value.IdType)
            {
                case IdType.Numeric:
                {
                    WriteUInt32("Id", (uint)value.Identifier);
                    break;
                }

                case IdType.String:
                {
                    WriteString("Id", (string)value.Identifier);
                    break;
                }

                case IdType.Guid:
                {
                    WriteGuid("Id", (Guid)value.Identifier);
                    break;
                }

                case IdType.Opaque:
                {
                    WriteByteString("Id", (byte[])value.Identifier);
                    break;
                }
            }

            if (namespaceUri != null)
            {
                WriteString("Namespace", namespaceUri);
            }
            else
            {
                WriteNamespaceIndex("Namespace", value.NamespaceIndex);
            }
        }


        /// <summary>
        /// Writes an NodeId to the stream.
        /// </summary>
        public void WriteNodeId(string fieldName, NodeId value)
        {
            if (value == null ||
                (NodeId.IsNull(value) && (value.IdType == IdType.Numeric)))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushStructure(fieldName);

            ushort namespaceIndex = value.NamespaceIndex;
            if (ForceNamespaceUri && namespaceIndex > 1)
            {
                string namespaceUri = Context.NamespaceUris.GetString(namespaceIndex);
                WriteNodeIdContents(value, namespaceUri);
            }
            else
            {
                WriteNodeIdContents(value);
            }
            PopStructure();
        }

        /// <summary>
        /// Writes an ExpandedNodeId to the stream.
        /// </summary>
        public void WriteExpandedNodeId(string fieldName, ExpandedNodeId value)
        {
            if (value == null || value.InnerNodeId == null ||
                (!UseReversibleEncoding && NodeId.IsNull(value)))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushStructure(fieldName);

            string namespaceUri = value.NamespaceUri;
            ushort namespaceIndex = value.InnerNodeId.NamespaceIndex;
            if (ForceNamespaceUri && namespaceUri == null && namespaceIndex > 1)
            {
                namespaceUri = Context.NamespaceUris.GetString(namespaceIndex);
            }
            WriteNodeIdContents(value.InnerNodeId, namespaceUri);

            uint serverIndex = value.ServerIndex;

            if (serverIndex >= 1)
            {
                var uri = m_context.ServerUris.GetString(serverIndex);

                if (!String.IsNullOrEmpty(uri))
                {
                    WriteSimpleField("ServerUri", uri, true);
                    PopStructure();
                    return;
                }

                if (m_serverMappings != null && m_serverMappings.Length > serverIndex)
                {
                    serverIndex = m_serverMappings[serverIndex];
                }

                if (serverIndex != 0)
                {
                    WriteUInt32("ServerUri", serverIndex);
                }
            }

            PopStructure();
        }


        /// <summary>
        /// Writes an StatusCode to the stream.
        /// </summary>
        public void WriteStatusCode(string fieldName, StatusCode value)
        {
            if (fieldName != null && !IncludeDefaultValues && value == StatusCodes.Good)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (UseReversibleEncoding)
            {
                WriteUInt32(fieldName, value.Code);
                return;
            }

            if (value != StatusCodes.Good)
            {
                PushStructure(fieldName);
                WriteSimpleField("Code", value.Code.ToString(CultureInfo.InvariantCulture), false);
                WriteSimpleField("Symbol", StatusCode.LookupSymbolicId(value.CodeBits), true);
                PopStructure();
            }
        }

        /// <summary>
        /// Writes an DiagnosticInfo to the stream.
        /// </summary>
        public void WriteDiagnosticInfo(string fieldName, DiagnosticInfo value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            if (value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            m_nestingLevel++;

            PushStructure(fieldName);

            if (value.SymbolicId >= 0)
            {
                WriteSimpleField("SymbolicId", value.SymbolicId.ToString(CultureInfo.InvariantCulture), false);
            }

            if (value.NamespaceUri >= 0)
            {
                WriteSimpleField("NamespaceUri", value.NamespaceUri.ToString(CultureInfo.InvariantCulture), false);
            }

            if (value.Locale >= 0)
            {
                WriteSimpleField("Locale", value.Locale.ToString(CultureInfo.InvariantCulture), false);
            }

            if (value.LocalizedText >= 0)
            {
                WriteSimpleField("LocalizedText", value.LocalizedText.ToString(CultureInfo.InvariantCulture), false);
            }

            if (value.AdditionalInfo != null)
            {
                WriteSimpleField("AdditionalInfo", value.AdditionalInfo, true);
            }

            if (value.InnerStatusCode != StatusCodes.Good)
            {
                WriteStatusCode("InnerStatusCode", value.InnerStatusCode);
            }

            if (value.InnerDiagnosticInfo != null)
            {
                WriteDiagnosticInfo("InnerDiagnosticInfo", value.InnerDiagnosticInfo);
            }

            PopStructure();

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an QualifiedName to the stream.
        /// </summary>
        public void WriteQualifiedName(string fieldName, QualifiedName value)
        {
            if (QualifiedName.IsNull(value))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushStructure(fieldName);

            WriteString("Name", value.Name);
            WriteNamespaceIndex("Uri", value.NamespaceIndex);

            PopStructure();
        }

        /// <summary>
        /// Writes an LocalizedText to the stream.
        /// </summary>
        public void WriteLocalizedText(string fieldName, LocalizedText value)
        {
            if (LocalizedText.IsNullOrEmpty(value))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (UseReversibleEncoding)
            {
                PushStructure(fieldName);

                WriteSimpleField("Text", value.Text, true);

                if (!String.IsNullOrEmpty(value.Locale))
                {
                    WriteSimpleField("Locale", value.Locale, true);
                }

                PopStructure();
            }
            else
            {
                WriteSimpleField(fieldName, value.Text, true);
            }
        }

        /// <summary>
        /// Writes an Variant to the stream.
        /// </summary>
        public void WriteVariant(string fieldName, Variant value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            if (Variant.Null == value)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            m_nestingLevel++;

            bool isNull = (value.TypeInfo == null || value.TypeInfo.BuiltInType == BuiltInType.Null || value.Value == null);

            if (UseReversibleEncoding && !isNull)
            {
                PushStructure(fieldName);
                // encode enums as int32.
                byte encodingByte = (byte)value.TypeInfo.BuiltInType;
                if (value.TypeInfo.BuiltInType == BuiltInType.Enumeration)
                {
                    encodingByte = (byte)BuiltInType.Int32;
                }

                WriteByte("Type", encodingByte);
                fieldName = "Body";
            }

            if (m_commaRequired)
            {
                m_writer.Write(",");
            }

            if (!String.IsNullOrEmpty(fieldName))
            {
                m_writer.Write("\"");
                EscapeString(fieldName);
                m_writer.Write("\":");
            }

            WriteVariantContents(value.Value, value.TypeInfo);

            if (UseReversibleEncoding && !isNull)
            {
                if (value.Value is Matrix matrix)
                {
                    WriteInt32Array("Dimensions", matrix.Dimensions);
                }

                PopStructure();
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValue(string fieldName, DataValue value, bool useReversibleEncoding)
        {
            bool currentValue = UseReversibleEncoding;

            try
            {
                UseReversibleEncoding = useReversibleEncoding;
                WriteDataValue(fieldName, value);
            }
            finally
            {
                UseReversibleEncoding = currentValue;
            }
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValue(string fieldName, DataValue value)
        {
            if (value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushStructure(fieldName);

            if (value != null)
            {
                if (value.WrappedValue.TypeInfo != null && value.WrappedValue.TypeInfo.BuiltInType != BuiltInType.Null)
                {
                    WriteVariant("Value", value.WrappedValue);
                }

                if (value.StatusCode != StatusCodes.Good)
                {
                    WriteStatusCode("StatusCode", value.StatusCode);
                }

                if (value.SourceTimestamp != DateTime.MinValue)
                {
                    WriteDateTime("SourceTimestamp", value.SourceTimestamp);

                    if (value.SourcePicoseconds != 0)
                    {
                        WriteUInt16("SourcePicoseconds", value.SourcePicoseconds);
                    }
                }

                if (value.ServerTimestamp != DateTime.MinValue)
                {
                    WriteDateTime("ServerTimestamp", value.ServerTimestamp);

                    if (value.ServerPicoseconds != 0)
                    {
                        WriteUInt16("ServerPicoseconds", value.ServerPicoseconds);
                    }
                }
            }

            PopStructure();
        }

        /// <summary>
        /// Writes an ExtensionObject to the stream.
        /// </summary>
        public void WriteExtensionObject(string fieldName, ExtensionObject value)
        {
            if (value == null || value.Encoding == ExtensionObjectEncoding.None)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (!UseReversibleEncoding && value.Body is IEncodeable encodeable)
            {
                if (value.Body is IStructureTypeInfo structureType &&
                    structureType.StructureType == StructureType.Union)
                {
                    encodeable.Encode(this);
                    return;
                }

                PushStructure(fieldName);
                encodeable.Encode(this);
                PopStructure();
                return;
            }

            PushStructure(fieldName);

            if (UseReversibleEncoding)
            {
                var nodeId = ExpandedNodeId.ToNodeId(value.TypeId, Context.NamespaceUris);
                WriteNodeId("TypeId", nodeId);
            }
            else
            {
                WriteExpandedNodeId("TypeId", value.TypeId);
            }

            if (value.Body is IEncodeable encodeable)
            {
                WriteEncodeable("Body", encodeable, null);
            }
            else
            {
                if (value.Body != null)
                {
                    if (value.Encoding == ExtensionObjectEncoding.Json)
                    {
                        WriteSimpleField("Body", value.Body as string, true);
                    }
                    else
                    {
                        WriteByte("Encoding", (byte)value.Encoding);
                        if (value.Encoding == ExtensionObjectEncoding.Binary)
                        {
                            WriteByteString("Body", value.Body as byte[]);
                        }
                        else if (value.Encoding == ExtensionObjectEncoding.Xml)
                        {
                            WriteXmlElement("Body", value.Body as XmlElement);
                        }
                    }
                }
            }

            PopStructure();
        }

        /// <summary>
        /// Writes an encodeable object to the stream.
        /// </summary>
        public void WriteEncodeable(string fieldName, IEncodeable value, System.Type systemType)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }


            if (value == null)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (m_nestingLevel == 0 && (m_commaRequired || m_topLevelIsArray))
            {
                if (string.IsNullOrWhiteSpace(fieldName) ^ m_topLevelIsArray)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadEncodingError,
                        "With Array as top level, encodeables with fieldname will create invalid json");
                }
            }

            if (m_nestingLevel == 0 && !m_commaRequired)
            {
                if (string.IsNullOrWhiteSpace(fieldName) && !m_topLevelIsArray)
                {
                    m_writer.Flush();
                    if (m_writer.BaseStream.Length == 1) //Opening "{"
                    {
                        m_writer.BaseStream.Seek(0, SeekOrigin.Begin);
                    }
                    m_dontWriteClosing = true;
                }
            }

            m_nestingLevel++;

            PushStructure(fieldName);

            value?.Encode(this);

            PopStructure();

            m_nestingLevel--;

        }

        /// <summary>
        /// Writes an enumerated value to the stream.
        /// </summary>
        public void WriteEnumerated(string fieldName, Enum value)
        {
            int numeric = Convert.ToInt32(value, CultureInfo.InvariantCulture);
            var numericString = numeric.ToString();
            if (UseReversibleEncoding)
            {
                WriteSimpleField(fieldName, numericString, false);
            }
            else
            {
                var valueString = value.ToString();
                if (valueString == numericString)
                {
                    WriteSimpleField(fieldName, numericString, true);
                }
                else
                {
                    WriteSimpleField(fieldName, Utils.Format("{0}_{1}", value.ToString(), numeric), true);
                }
            }
        }

        /// <summary>
        /// Writes an enumerated Int32 value to the stream.
        /// </summary>
        public void WriteEnumerated(string fieldName, int numeric)
        {
            var numericString = numeric.ToString(CultureInfo.InvariantCulture);
            WriteSimpleField(fieldName, numericString, !UseReversibleEncoding);
        }

        /// <summary>
        /// Writes a boolean array to the stream.
        /// </summary>
        public void WriteBooleanArray(string fieldName, IList<bool> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteBoolean(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteSByteArray(string fieldName, IList<sbyte> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteSByte(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteByteArray(string fieldName, IList<byte> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteByte(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a short array to the stream.
        /// </summary>
        public void WriteInt16Array(string fieldName, IList<short> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt16(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a ushort array to the stream.
        /// </summary>
        public void WriteUInt16Array(string fieldName, IList<ushort> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt16(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a int array to the stream.
        /// </summary>
        public void WriteInt32Array(string fieldName, IList<int> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt32(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a uint array to the stream.
        /// </summary>
        public void WriteUInt32Array(string fieldName, IList<uint> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt32(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a long array to the stream.
        /// </summary>
        public void WriteInt64Array(string fieldName, IList<long> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteInt64(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a ulong array to the stream.
        /// </summary>
        public void WriteUInt64Array(string fieldName, IList<ulong> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteUInt64(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a float array to the stream.
        /// </summary>
        public void WriteFloatArray(string fieldName, IList<float> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteFloat(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a double array to the stream.
        /// </summary>
        public void WriteDoubleArray(string fieldName, IList<double> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDouble(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a string array to the stream.
        /// </summary>
        public void WriteStringArray(string fieldName, IList<string> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteString(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a UTC date/time array to the stream.
        /// </summary>
        public void WriteDateTimeArray(string fieldName, IList<DateTime> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (values[ii] <= DateTime.MinValue)
                {
                    WriteSimpleField(null, null, false);
                }
                else
                {
                    WriteDateTime(null, values[ii]);
                }
            }

            PopArray();
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Uuid> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteGuid(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Guid> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteGuid(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes a byte string array to the stream.
        /// </summary>
        public void WriteByteStringArray(string fieldName, IList<byte[]> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteByteString(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an XmlElement array to the stream.
        /// </summary>
        public void WriteXmlElementArray(string fieldName, IList<XmlElement> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteXmlElement(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an NodeId array to the stream.
        /// </summary>
        public void WriteNodeIdArray(string fieldName, IList<NodeId> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteNodeId(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an ExpandedNodeId array to the stream.
        /// </summary>
        public void WriteExpandedNodeIdArray(string fieldName, IList<ExpandedNodeId> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteExpandedNodeId(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an StatusCode array to the stream.
        /// </summary>
        public void WriteStatusCodeArray(string fieldName, IList<StatusCode> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (!UseReversibleEncoding &&
                    values[ii] == StatusCodes.Good)
                {
                    WriteSimpleField(null, null, false);
                }
                else
                {
                    WriteStatusCode(null, values[ii]);
                }
            }

            PopArray();
        }

        /// <summary>
        /// Writes an DiagnosticInfo array to the stream.
        /// </summary>
        public void WriteDiagnosticInfoArray(string fieldName, IList<DiagnosticInfo> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDiagnosticInfo(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an QualifiedName array to the stream.
        /// </summary>
        public void WriteQualifiedNameArray(string fieldName, IList<QualifiedName> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteQualifiedName(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an LocalizedText array to the stream.
        /// </summary>
        public void WriteLocalizedTextArray(string fieldName, IList<LocalizedText> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteLocalizedText(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteVariantArray(string fieldName, IList<Variant> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                if (values[ii] == Variant.Null)
                {
                    WriteSimpleField(null, null, false);
                    continue;
                }

                WriteVariant(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValueArray(string fieldName, IList<DataValue> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteDataValue(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an extension object array to the stream.
        /// </summary>
        public void WriteExtensionObjectArray(string fieldName, IList<ExtensionObject> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            for (int ii = 0; ii < values.Count; ii++)
            {
                WriteExtensionObject(null, values[ii]);
            }

            PopArray();
        }

        /// <summary>
        /// Writes an encodeable object array to the stream.
        /// </summary>
        public void WriteEncodeableArray(string fieldName, IList<IEncodeable> values, System.Type systemType)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            if (string.IsNullOrWhiteSpace(fieldName) && m_nestingLevel == 0 && !m_topLevelIsArray)
            {
                m_writer.Flush();
                if (m_writer.BaseStream.Length == 1) //Opening "{"
                {
                    m_writer.BaseStream.Seek(0, SeekOrigin.Begin);
                }

                m_nestingLevel++;
                PushArray(fieldName);

                for (int ii = 0; ii < values.Count; ii++)
                {
                    WriteEncodeable(null, values[ii], systemType);
                }

                PopArray();
                m_dontWriteClosing = true;
                m_nestingLevel--;

            }
            else if (!string.IsNullOrWhiteSpace(fieldName) && m_nestingLevel == 0 && m_topLevelIsArray)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingError,
                    "With Array as top level, encodeables array with filename will create invalid json");
            }
            else
            {
                PushArray(fieldName);

	            // check the length.
	            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
	            {
	                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
	            }

	            for (int ii = 0; ii < values.Count; ii++)
	            {
	                WriteEncodeable(null, values[ii], systemType);
	            }

	            PopArray();
            }
        }

        /// <summary>
        /// Writes an enumerated value array to the stream.
        /// </summary>
        public void WriteEnumeratedArray(string fieldName, Array values, System.Type systemType)
        {
            if (values == null || values.Length == 0)
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            // check the length.
            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Length)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            // encode each element in the array.
            Type arrayType = values.GetType().GetElementType();
            if (arrayType.IsEnum)
            {
                foreach (Enum value in values)
                {
                    WriteEnumerated(null, value);
                }
            }
            else
            {
                if (arrayType != typeof(Int32))
                {
                    throw new ServiceResultException(
                        StatusCodes.BadEncodingError,
                        Utils.Format("Type '{0}' is not allowed in an Enumeration.", arrayType.FullName));
                }
                foreach (Int32 value in values)
                {
                    WriteEnumerated(null, value);
                }
            }

            PopArray();
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Writes the contents of an Variant to the stream.
        /// </summary>
        public void WriteVariantContents(object value, TypeInfo typeInfo)
        {
            try
            {
                m_inVariantWithEncoding = UseReversibleEncoding;

                // check for null.
                if (value == null)
                {
                    return;
                }

                m_commaRequired = false;

                // write scalar.
                if (typeInfo.ValueRank < 0)
                {
                    switch (typeInfo.BuiltInType)
                    {
                        case BuiltInType.Boolean: { WriteBoolean(null, (bool)value); return; }
                        case BuiltInType.SByte: { WriteSByte(null, (sbyte)value); return; }
                        case BuiltInType.Byte: { WriteByte(null, (byte)value); return; }
                        case BuiltInType.Int16: { WriteInt16(null, (short)value); return; }
                        case BuiltInType.UInt16: { WriteUInt16(null, (ushort)value); return; }
                        case BuiltInType.Int32: { WriteInt32(null, (int)value); return; }
                        case BuiltInType.UInt32: { WriteUInt32(null, (uint)value); return; }
                        case BuiltInType.Int64: { WriteInt64(null, (long)value); return; }
                        case BuiltInType.UInt64: { WriteUInt64(null, (ulong)value); return; }
                        case BuiltInType.Float: { WriteFloat(null, (float)value); return; }
                        case BuiltInType.Double: { WriteDouble(null, (double)value); return; }
                        case BuiltInType.String: { WriteString(null, (string)value); return; }
                        case BuiltInType.DateTime: { WriteDateTime(null, (DateTime)value); return; }
                        case BuiltInType.Guid: { WriteGuid(null, (Uuid)value); return; }
                        case BuiltInType.ByteString: { WriteByteString(null, (byte[])value); return; }
                        case BuiltInType.XmlElement: { WriteXmlElement(null, (XmlElement)value); return; }
                        case BuiltInType.NodeId: { WriteNodeId(null, (NodeId)value); return; }
                        case BuiltInType.ExpandedNodeId: { WriteExpandedNodeId(null, (ExpandedNodeId)value); return; }
                        case BuiltInType.StatusCode: { WriteStatusCode(null, (StatusCode)value); return; }
                        case BuiltInType.QualifiedName: { WriteQualifiedName(null, (QualifiedName)value); return; }
                        case BuiltInType.LocalizedText: { WriteLocalizedText(null, (LocalizedText)value); return; }
                        case BuiltInType.ExtensionObject: { WriteExtensionObject(null, (ExtensionObject)value); return; }
                        case BuiltInType.DataValue: { WriteDataValue(null, (DataValue)value); return; }
                        case BuiltInType.Enumeration: { WriteEnumerated(null, (Enum)value); return; }
                    }
                }

                // write array.
                else if (typeInfo.ValueRank <= 1)
                {
                    switch (typeInfo.BuiltInType)
                    {
                        case BuiltInType.Boolean: { WriteBooleanArray(null, (bool[])value); return; }
                        case BuiltInType.SByte: { WriteSByteArray(null, (sbyte[])value); return; }
                        case BuiltInType.Byte: { WriteByteArray(null, (byte[])value); return; }
                        case BuiltInType.Int16: { WriteInt16Array(null, (short[])value); return; }
                        case BuiltInType.UInt16: { WriteUInt16Array(null, (ushort[])value); return; }
                        case BuiltInType.Int32: { WriteInt32Array(null, (int[])value); return; }
                        case BuiltInType.UInt32: { WriteUInt32Array(null, (uint[])value); return; }
                        case BuiltInType.Int64: { WriteInt64Array(null, (long[])value); return; }
                        case BuiltInType.UInt64: { WriteUInt64Array(null, (ulong[])value); return; }
                        case BuiltInType.Float: { WriteFloatArray(null, (float[])value); return; }
                        case BuiltInType.Double: { WriteDoubleArray(null, (double[])value); return; }
                        case BuiltInType.String: { WriteStringArray(null, (string[])value); return; }
                        case BuiltInType.DateTime: { WriteDateTimeArray(null, (DateTime[])value); return; }
                        case BuiltInType.Guid: { WriteGuidArray(null, (Uuid[])value); return; }
                        case BuiltInType.ByteString: { WriteByteStringArray(null, (byte[][])value); return; }
                        case BuiltInType.XmlElement: { WriteXmlElementArray(null, (XmlElement[])value); return; }
                        case BuiltInType.NodeId: { WriteNodeIdArray(null, (NodeId[])value); return; }
                        case BuiltInType.ExpandedNodeId: { WriteExpandedNodeIdArray(null, (ExpandedNodeId[])value); return; }
                        case BuiltInType.StatusCode: { WriteStatusCodeArray(null, (StatusCode[])value); return; }
                        case BuiltInType.QualifiedName: { WriteQualifiedNameArray(null, (QualifiedName[])value); return; }
                        case BuiltInType.LocalizedText: { WriteLocalizedTextArray(null, (LocalizedText[])value); return; }
                        case BuiltInType.ExtensionObject: { WriteExtensionObjectArray(null, (ExtensionObject[])value); return; }
                        case BuiltInType.DataValue: { WriteDataValueArray(null, (DataValue[])value); return; }
                        case BuiltInType.Enumeration:
                        {
                            Array array = value as Array;
                            WriteEnumeratedArray(null, array, array.GetType().GetElementType());
                            return;
                        }

                        case BuiltInType.Variant:
                        {
                            if (value is Variant[] variants)
                            {
                                WriteVariantArray(null, variants);
                                return;
                            }

                            if (value is object[] objects)
                            {
                                WriteObjectArray(null, objects);
                                return;
                            }

                            throw ServiceResultException.Create(
                                StatusCodes.BadEncodingError,
                                "Unexpected type encountered while encoding an array of Variants: {0}",
                                value.GetType());
                        }
                    }
                }

                // write matrix.
                else if (typeInfo.ValueRank > 1)
                {
                    if (value is Matrix matrix)
                    {
                        if (UseReversibleEncoding)
                        {
                            WriteVariantContents(matrix.Elements, new TypeInfo(typeInfo.BuiltInType, 1));
                        }
                        else
                        {
                            int index = 0;
                            WriteStructureMatrix(matrix, 0, ref index, typeInfo);
                        }
                        return;
                    }
                }

                // oops - should never happen.
                throw new ServiceResultException(
                    StatusCodes.BadEncodingError,
                    Utils.Format("Type '{0}' is not allowed in an Variant.", value.GetType().FullName));
            }
            finally
            {
                m_inVariantWithEncoding = false;
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Write multi dimensional array in structure.
        /// </summary>
        private void WriteStructureMatrix(
            Matrix matrix,
            int dim,
            ref int index,
            TypeInfo typeInfo)
        {
            var arrayLen = matrix.Dimensions[dim];
            if (dim == matrix.Dimensions.Length - 1)
            {
                // Create a slice of values for the top dimension
                var copy = Array.CreateInstance(
                    matrix.Elements.GetType().GetElementType(), arrayLen);
                Array.Copy(matrix.Elements, index, copy, 0, arrayLen);
                // Write slice as value rank
                if (m_commaRequired)
                {
                    m_writer.Write(",");
                }
                WriteVariantContents(copy, new TypeInfo(typeInfo.BuiltInType, 1));
                index += arrayLen;
            }
            else
            {
                PushArray(null);
                for (var i = 0; i < arrayLen; i++)
                {
                    WriteStructureMatrix(matrix, dim + 1, ref index, typeInfo);
                }
                PopArray();
            }
        }

        /// <summary>
        /// Write multi dimensional array in Variant.
        /// </summary>
        private void WriteVariantMatrix(string fieldName, Matrix value)
        {
            PushStructure(fieldName);
            WriteVariant("Matrix", new Variant(value.Elements, new TypeInfo(value.TypeInfo.BuiltInType, ValueRanks.OneDimension)));
            WriteInt32Array("Dimensions", value.Dimensions);
            PopStructure();
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteObjectArray(string fieldName, IList<object> values)
        {
            if (values == null || (values.Count == 0 && !m_inVariantWithEncoding))
            {
                WriteSimpleField(fieldName, null, false);
                return;
            }

            PushArray(fieldName);

            if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
            {
                throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
            }

            if (values != null)
            {
                for (int ii = 0; ii < values.Count; ii++)
                {
                    WriteVariant("Variant", new Variant(values[ii]));
                }
            }

            PopArray();
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\JsonEncoder.cs(1252,43): error CS0128: A local variable or function named 'encodeable' is already defined in this scope,D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\JsonEncoder.cs(1254,41): error CS0165: Use of unassigned local variable 'encodeable'
######################################################################


######################################################################
Nr: 25 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\XmlEncoder.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// Writes objects to a XML stream.
    /// </summary>
    public class XmlEncoder : IEncoder, IDisposable
    {
        #region Constructors
        /// <summary>
        /// Initializes the object with default values.
        /// </summary>
        public XmlEncoder(ServiceMessageContext context)
        {
            Initialize();

            m_destination = new StringBuilder();
            m_context = context;
            m_nestingLevel = 0;

            XmlWriterSettings settings = new XmlWriterSettings();
            settings.CheckCharacters = false;
            settings.ConformanceLevel = ConformanceLevel.Auto;
            settings.NamespaceHandling = NamespaceHandling.OmitDuplicates;
            settings.NewLineHandling = NewLineHandling.Replace;

            m_writer = XmlWriter.Create(m_destination, settings);
        }

        /// <summary>
        /// Initializes the object with a system type to encode and a XML writer.
        /// </summary>
        public XmlEncoder(System.Type systemType, XmlWriter writer, ServiceMessageContext context)
        :
            this(EncodeableFactory.GetXmlName(systemType), writer, context)
        {
        }

        /// <summary>
        /// Initializes the object with a system type to encode and a XML writer.
        /// </summary>
        public XmlEncoder(XmlQualifiedName root, XmlWriter writer, ServiceMessageContext context)
        {
            Initialize();

            if (writer == null)
            {
                m_destination = new StringBuilder();
                m_writer = XmlWriter.Create(m_destination);
            }
            else
            {
                m_destination = null;
                m_writer = writer;
            }

            Initialize(root.Name, root.Namespace);
            m_context = context;
            m_nestingLevel = 0;
        }

        /// <summary>
        /// Sets private members to default values.
        /// </summary>
        private void Initialize()
        {
            m_destination = null;
            m_writer = null;
            m_namespaces = new Stack<string>();
            m_root = null;
        }

        /// <summary>
        /// Writes the root element to the stream.
        /// </summary>
        private void Initialize(string fieldName, string namespaceUri)
        {
            m_root = new XmlQualifiedName(fieldName, namespaceUri);

            string uaxPrefix = m_writer.LookupPrefix(Namespaces.OpcUaXsd);

            if (uaxPrefix == null)
            {
                uaxPrefix = "uax";
            }

            if (namespaceUri == Namespaces.OpcUaXsd)
            {
                m_writer.WriteStartElement(uaxPrefix, fieldName, namespaceUri);
            }
            else
            {
                m_writer.WriteStartElement(fieldName, namespaceUri);
            }

            string xsiPrefix = m_writer.LookupPrefix(Namespaces.XmlSchemaInstance);

            if (xsiPrefix == null)
            {
                m_writer.WriteAttributeString("xmlns", "xsi", null, Namespaces.XmlSchemaInstance);
            }

            uaxPrefix = m_writer.LookupPrefix(Namespaces.OpcUaXsd);

            if (uaxPrefix == null)
            {
                m_writer.WriteAttributeString("xmlns", "uax", null, Namespaces.OpcUaXsd);
            }

            PushNamespace(namespaceUri);
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Initializes the tables used to map namespace and server uris during encoding.
        /// </summary>
        /// <param name="namespaceUris">The namespaces URIs referenced by the data being encoded.</param>
        /// <param name="serverUris">The server URIs referenced by the data being encoded.</param>
        public void SetMappingTables(NamespaceTable namespaceUris, StringTable serverUris)
        {
            m_namespaceMappings = null;

            if (namespaceUris != null && m_context.NamespaceUris != null)
            {
                m_namespaceMappings = namespaceUris.CreateMapping(m_context.NamespaceUris, false);
            }

            m_serverMappings = null;

            if (serverUris != null && m_context.ServerUris != null)
            {
                m_serverMappings = serverUris.CreateMapping(m_context.ServerUris, false);
            }
        }

        /// <summary>
        /// Saves a string table from an XML stream.
        /// </summary>
        /// <param name="tableName">Name of the table.</param>
        /// <param name="elementName">Name of the element.</param>
        /// <param name="stringTable">The string table.</param>
        public void SaveStringTable(string tableName, string elementName, StringTable stringTable)
        {
            if (stringTable == null || stringTable.Count <= 1)
            {
                return;
            }

            PushNamespace(Namespaces.OpcUaXsd);

            try
            {
                Push(tableName, Namespaces.OpcUaXsd);

                for (ushort ii = 1; ii < stringTable.Count; ii++)
                {
                    WriteString(elementName, stringTable.GetString(ii));
                }

                Pop();
            }
            finally
            {
                PopNamespace();
            }
        }

        /// <summary>
        /// Writes a start element.
        /// </summary>
        /// <param name="fieldName">The name of the element.</param>
        /// <param name="namespaceUri">The namespace that qualifies the element name.</param>
        public void Push(string fieldName, string namespaceUri)
        {
            m_writer.WriteStartElement(fieldName, namespaceUri);
            PushNamespace(namespaceUri);
        }

        /// <summary>
        /// Writes an end element.
        /// </summary>
        public void Pop()
        {
            m_writer.WriteEndElement();
            PopNamespace();
        }

        /// <summary>
        /// Completes writing and returns the XML text.
        /// </summary>
        public string Close()
        {
            if (m_root != null)
            {
                m_writer.WriteEndElement();
            }

            m_writer.Flush();
            m_writer.Dispose();

            if (m_destination != null)
            {
                return m_destination.ToString();
            }

            return null;
        }
        #endregion

        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (m_writer != null)
                {
                    m_writer.Flush();
                    m_writer.Dispose();
                    m_writer = null;
                }
            }
        }
        #endregion

        #region IEncoder Members
        /// <summary>
        /// The type of encoding being used.
        /// </summary>
        public EncodingType EncodingType => EncodingType.Xml;

        /// <summary>
        /// The message context associated with the encoder.
        /// </summary>
        public ServiceMessageContext Context => m_context;

        /// <summary>
        /// Xml Encoder always produces reversible encoding.
        /// </summary>
        public bool UseReversibleEncoding => true;

        /// <summary>
        /// Pushes a namespace onto the namespace stack.
        /// </summary>
        public void PushNamespace(string namespaceUri)
        {
            m_namespaces.Push(namespaceUri);
        }

        /// <summary>
        /// Pops a namespace from the namespace stack.
        /// </summary>
        public void PopNamespace()
        {
            m_namespaces.Pop();
        }

        /// <summary>
        /// Writes a boolean to the stream.
        /// </summary>
        public void WriteBoolean(string fieldName, bool value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a sbyte to the stream.
        /// </summary>
        public void WriteSByte(string fieldName, sbyte value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a byte to the stream.
        /// </summary>
        public void WriteByte(string fieldName, byte value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a short to the stream.
        /// </summary>
        public void WriteInt16(string fieldName, short value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a ushort to the stream.
        /// </summary>
        public void WriteUInt16(string fieldName, ushort value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an int to the stream.
        /// </summary>
        public void WriteInt32(string fieldName, int value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a uint to the stream.
        /// </summary>
        public void WriteUInt32(string fieldName, uint value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a long to the stream.
        /// </summary>
        public void WriteInt64(string fieldName, long value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a ulong to the stream.
        /// </summary>
        public void WriteUInt64(string fieldName, ulong value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(XmlConvert.ToString(value));
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a float to the stream.
        /// </summary>
        public void WriteFloat(string fieldName, float value)
        {
            if (BeginField(fieldName, false, false))
            {
                if (Single.IsNaN(value))
                {
                    m_writer.WriteValue("NaN");
                }
                else if (Single.IsPositiveInfinity(value))
                {
                    m_writer.WriteValue("INF");
                }
                else if (Single.IsNegativeInfinity(value))
                {
                    m_writer.WriteValue("-INF");
                }
                else
                {
                    m_writer.WriteValue(value);
                }

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a double to the stream.
        /// </summary>
        public void WriteDouble(string fieldName, double value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a string to the stream.
        /// </summary>
        public void WriteString(string fieldName, string value)
        {
            WriteString(fieldName, value, false);
        }

        private void WriteString(string fieldName, string value, bool isArrayElement)
        {
            if (BeginField(fieldName, value == null, true, isArrayElement))
            {
                // check the length.
                if (m_context.MaxStringLength > 0 && m_context.MaxStringLength < value.Length)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                if (!String.IsNullOrWhiteSpace(value))
                {
                    m_writer.WriteString(value);
                }

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a UTC date/time to the stream.
        /// </summary>
        public void WriteDateTime(string fieldName, DateTime value)
        {
            if (BeginField(fieldName, false, false))
            {
                value = Utils.ToOpcUaUniversalTime(value);
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Uuid value)
        {
            if (BeginField(fieldName, false, false))
            {
                PushNamespace(Namespaces.OpcUaXsd);
                WriteString("String", value.GuidString);
                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Guid value)
        {
            if (BeginField(fieldName, false, false))
            {
                PushNamespace(Namespaces.OpcUaXsd);
                WriteString("String", value.ToString());
                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a byte string to the stream.
        /// </summary>
        public void WriteByteString(string fieldName, byte[] value)
        {
            WriteByteString(fieldName, value, false);
        }

        private void WriteByteString(string fieldName, byte[] value, bool isArrayElement = false)
        {
            if (BeginField(fieldName, value == null, true, isArrayElement))
            {
                // check the length.
                if (m_context.MaxByteStringLength > 0 && m_context.MaxByteStringLength < value.Length)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                m_writer.WriteValue(Convert.ToBase64String(value, Base64FormattingOptions.InsertLineBreaks));
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an XmlElement to the stream.
        /// </summary>
        public void WriteXmlElement(string fieldName, XmlElement value)
        {
            WriteXmlElement(fieldName, value, false);
        }

        private void WriteXmlElement(string fieldName, XmlElement value, bool isArrayElement)
        {
            if (BeginField(fieldName, value == null, true, isArrayElement))
            {
                m_writer.WriteRaw(value.OuterXml);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an NodeId to the stream.
        /// </summary>
        public void WriteNodeId(string fieldName, NodeId value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    ushort namespaceIndex = value.NamespaceIndex;

                    if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
                    {
                        namespaceIndex = m_namespaceMappings[namespaceIndex];
                    }

                    StringBuilder buffer = new StringBuilder();
                    NodeId.Format(buffer, value.Identifier, value.IdType, namespaceIndex);
                    WriteString("Identifier", buffer.ToString());
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an ExpandedNodeId to the stream.
        /// </summary>
        public void WriteExpandedNodeId(string fieldName, ExpandedNodeId value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    ushort namespaceIndex = value.NamespaceIndex;

                    if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
                    {
                        namespaceIndex = m_namespaceMappings[namespaceIndex];
                    }

                    uint serverIndex = value.ServerIndex;

                    if (m_serverMappings != null && m_serverMappings.Length > serverIndex)
                    {
                        serverIndex = m_serverMappings[serverIndex];
                    }

                    StringBuilder buffer = new StringBuilder();
                    ExpandedNodeId.Format(buffer, value.Identifier, value.IdType, namespaceIndex, value.NamespaceUri, serverIndex);
                    WriteString("Identifier", buffer.ToString());
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an StatusCode to the stream.
        /// </summary>
        public void WriteStatusCode(string fieldName, StatusCode value)
        {
            if (BeginField(fieldName, false, false))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    WriteUInt32("Code", value.Code);
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an DiagnosticInfo to the stream.
        /// </summary>
        public void WriteDiagnosticInfo(string fieldName, DiagnosticInfo value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    WriteInt32("SymbolicId", value.SymbolicId);
                    WriteInt32("NamespaceUri", value.NamespaceUri);
                    WriteInt32("Locale", value.Locale);
                    WriteInt32("LocalizedText", value.LocalizedText);
                    WriteString("AdditionalInfo", value.AdditionalInfo);
                    WriteStatusCode("InnerStatusCode", value.InnerStatusCode);
                    WriteDiagnosticInfo("InnerDiagnosticInfo", value.InnerDiagnosticInfo);
                }

                PopNamespace();

                EndField(fieldName);
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an QualifiedName to the stream.
        /// </summary>
        public void WriteQualifiedName(string fieldName, QualifiedName value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                ushort namespaceIndex = value.NamespaceIndex;

                if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
                {
                    namespaceIndex = m_namespaceMappings[namespaceIndex];
                }

                if (value != null)
                {
                    WriteUInt16("NamespaceIndex", namespaceIndex);
                    WriteString("Name", value.Name);
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an LocalizedText to the stream.
        /// </summary>
        public void WriteLocalizedText(string fieldName, LocalizedText value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    if (!String.IsNullOrEmpty(value.Locale))
                    {
                        WriteString("Locale", value.Locale);
                    }

                    if (!String.IsNullOrEmpty(value.Text))
                    {
                        WriteString("Text", value.Text);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteVariant(string fieldName, Variant value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            if (BeginField(fieldName, false, false))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                m_writer.WriteStartElement("Value", Namespaces.OpcUaXsd);
                WriteVariantContents(value.Value, value.TypeInfo);
                m_writer.WriteEndElement();

                PopNamespace();

                EndField(fieldName);
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValue(string fieldName, DataValue value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    WriteVariant("Value", value.WrappedValue);
                    WriteStatusCode("StatusCode", value.StatusCode);
                    WriteDateTime("SourceTimestamp", value.SourceTimestamp);
                    WriteUInt16("SourcePicoseconds", value.SourcePicoseconds);
                    WriteDateTime("ServerTimestamp", value.ServerTimestamp);
                    WriteUInt16("ServerPicoseconds", value.ServerPicoseconds);
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an ExtensionObject to the stream.
        /// </summary>
        public void WriteExtensionObject(string fieldName, ExtensionObject value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                // check for null.
                if (value == null)
                {
                    EndField(fieldName);
                    PopNamespace();
                    return;
                }

                IEncodeable encodeable = value.Body as IEncodeable;

                // write the type id.
                ExpandedNodeId typeId = value.TypeId;

                if (encodeable != null)
                {
                    if (value.Encoding == ExtensionObjectEncoding.Binary)
                    {
                        typeId = encodeable.BinaryEncodingId;
                    }
                    else
                    {
                        typeId = encodeable.XmlEncodingId;
                    }
                }

                NodeId localTypeId = ExpandedNodeId.ToNodeId(typeId, m_context.NamespaceUris);

                if (NodeId.IsNull(localTypeId) && !NodeId.IsNull(typeId))
                {
                    if (encodeable != null)
                    {
                        throw ServiceResultException.Create(
                            StatusCodes.BadEncodingError,
                            "Cannot encode bodies of type '{0}' in ExtensionObject unless the NamespaceUri ({1}) is in the encoder's NamespaceTable.",
                            encodeable.GetType().FullName,
                            typeId.NamespaceUri);
                    }

                    localTypeId = NodeId.Null;
                }

                WriteNodeId("TypeId", localTypeId);

                object body = value.Body;

                if (body == null)
                {
                    EndField(fieldName);
                    PopNamespace();
                    return;
                }

                // write the body.
                m_writer.WriteStartElement("Body", Namespaces.OpcUaXsd);

                WriteExtensionObjectBody(body);

                // end of body.
                m_writer.WriteEndElement();

                EndField(fieldName);
                PopNamespace();
            }
        }

        /// <summary>
        /// Writes an encodeable object to the stream.
        /// </summary>
        public void WriteEncodeable(string fieldName, IEncodeable value, System.Type systemType)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            if (BeginField(fieldName, value == null, true))
            {
                value?.Encode(this);

                EndField(fieldName);
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an enumerated value array to the stream.
        /// </summary>
        public void WriteEnumerated(string fieldName, Enum value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                if (value != null)
                {
                    var valueSymbol = value.ToString();
                    var valueInt32 = Convert.ToInt32(value, CultureInfo.InvariantCulture).ToString();
                    if (valueSymbol != valueInt32)
                    {
                        m_writer.WriteString(Utils.Format("{0}_{1}", valueSymbol, valueInt32));
                    }
                    else
                    {
                        m_writer.WriteString(valueSymbol);
                    }
                }

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a boolean array to the stream.
        /// </summary>
        public void WriteBooleanArray(string fieldName, IList<bool> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteBoolean("Boolean", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteSByteArray(string fieldName, IList<sbyte> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteSByte("SByte", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteByteArray(string fieldName, IList<byte> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteByte("Byte", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a short array to the stream.
        /// </summary>
        public void WriteInt16Array(string fieldName, IList<short> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteInt16("Int16", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a ushort array to the stream.
        /// </summary>
        public void WriteUInt16Array(string fieldName, IList<ushort> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteUInt16("UInt16", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a int array to the stream.
        /// </summary>
        public void WriteInt32Array(string fieldName, IList<int> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteInt32("Int32", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a uint array to the stream.
        /// </summary>
        public void WriteUInt32Array(string fieldName, IList<uint> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteUInt32("UInt32", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a long array to the stream.
        /// </summary>
        public void WriteInt64Array(string fieldName, IList<long> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteInt64("Int64", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a ulong array to the stream.
        /// </summary>
        public void WriteUInt64Array(string fieldName, IList<ulong> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteUInt64("UInt64", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a float array to the stream.
        /// </summary>
        public void WriteFloatArray(string fieldName, IList<float> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteFloat("Float", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a double array to the stream.
        /// </summary>
        public void WriteDoubleArray(string fieldName, IList<double> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteDouble("Double", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a string array to the stream.
        /// </summary>
        public void WriteStringArray(string fieldName, IList<string> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteString("String", values[ii], true);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a UTC date/time array to the stream.
        /// </summary>
        public void WriteDateTimeArray(string fieldName, IList<DateTime> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteDateTime("DateTime", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Uuid> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteGuid("Guid", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Guid> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteGuid("Guid", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a byte string array to the stream.
        /// </summary>
        public void WriteByteStringArray(string fieldName, IList<byte[]> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteByteString("ByteString", values[ii], true);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an XmlElement array to the stream.
        /// </summary>
        public void WriteXmlElementArray(string fieldName, IList<XmlElement> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteXmlElement("XmlElement", values[ii], true);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an NodeId array to the stream.
        /// </summary>
        public void WriteNodeIdArray(string fieldName, IList<NodeId> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteNodeId("NodeId", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an ExpandedNodeId array to the stream.
        /// </summary>
        public void WriteExpandedNodeIdArray(string fieldName, IList<ExpandedNodeId> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteExpandedNodeId("ExpandedNodeId", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an StatusCode array to the stream.
        /// </summary>
        public void WriteStatusCodeArray(string fieldName, IList<StatusCode> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteStatusCode("StatusCode", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an DiagnosticInfo array to the stream.
        /// </summary>
        public void WriteDiagnosticInfoArray(string fieldName, IList<DiagnosticInfo> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteDiagnosticInfo("DiagnosticInfo", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an QualifiedName array to the stream.
        /// </summary>
        public void WriteQualifiedNameArray(string fieldName, IList<QualifiedName> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteQualifiedName("QualifiedName", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an LocalizedText array to the stream.
        /// </summary>
        public void WriteLocalizedTextArray(string fieldName, IList<LocalizedText> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteLocalizedText("LocalizedText", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteVariantArray(string fieldName, IList<Variant> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteVariant("Variant", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValueArray(string fieldName, IList<DataValue> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteDataValue("DataValue", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an extension object array to the stream.
        /// </summary>
        public void WriteExtensionObjectArray(string fieldName, IList<ExtensionObject> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteExtensionObject("ExtensionObject", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an encodeable object array to the stream.
        /// </summary>
        public void WriteEncodeableArray(string fieldName, IList<IEncodeable> values, System.Type systemType)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                // get name for type being encoded.
                XmlQualifiedName xmlName = EncodeableFactory.GetXmlName(systemType);

                if (xmlName == null)
                {
                    xmlName = new XmlQualifiedName("IEncodeable", Namespaces.OpcUaXsd);
                }

                PushNamespace(xmlName.Namespace);

                // encode each element in the array.
                for (int ii = 0; ii < values.Count; ii++)
                {
                    IEncodeable value = values[ii];

                    if (systemType != null)
                    {
                        if (!systemType.IsInstanceOfType(value))
                        {
                            throw new ServiceResultException(
                                StatusCodes.BadEncodingError,
                                Utils.Format("Objects with type '{0}' are not allowed in the array being serialized.", systemType.FullName));
                        }

                        WriteEncodeable(xmlName.Name, value, systemType);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an enumerated value array to the stream.
        /// </summary>
        public void WriteEnumeratedArray(string fieldName, Array values, System.Type systemType)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Length)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                // get name for type being encoded.
                XmlQualifiedName xmlName = EncodeableFactory.GetXmlName(systemType);

                if (xmlName == null)
                {
                    xmlName = new XmlQualifiedName("Enumerated", Namespaces.OpcUaXsd);
                }

                PushNamespace(xmlName.Namespace);

                if (values != null)
                {
                    // encode each element in the array.
                    foreach (Enum value in values)
                    {
                        WriteEnumerated(xmlName.Name, value);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Writes the contents of an Variant to the stream.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public void WriteVariantContents(object value, TypeInfo typeInfo)
        {
            // check for null.
            if (value == null)
            {
                m_writer.WriteStartElement("Null", Namespaces.OpcUaXsd);
                m_writer.WriteEndElement();
                return;
            }

            try
            {
                PushNamespace(Namespaces.OpcUaXsd);

                // write scalar.
                if (typeInfo.ValueRank < 0)
                {
                    switch (typeInfo.BuiltInType)
                    {
                        case BuiltInType.Boolean: { WriteBoolean("Boolean", (bool)value); return; }
                        case BuiltInType.SByte: { WriteSByte("SByte", (sbyte)value); return; }
                        case BuiltInType.Byte: { WriteByte("Byte", (byte)value); return; }
                        case BuiltInType.Int16: { WriteInt16("Int16", (short)value); return; }
                        case BuiltInType.UInt16: { WriteUInt16("UInt16", (ushort)value); return; }
                        case BuiltInType.Int32: { WriteInt32("Int32", (int)value); return; }
                        case BuiltInType.UInt32: { WriteUInt32("UInt32", (uint)value); return; }
                        case BuiltInType.Int64: { WriteInt64("Int64", (long)value); return; }
                        case BuiltInType.UInt64: { WriteUInt64("UInt64", (ulong)value); return; }
                        case BuiltInType.Float: { WriteFloat("Float", (float)value); return; }
                        case BuiltInType.Double: { WriteDouble("Double", (double)value); return; }
                        case BuiltInType.String: { WriteString("String", (string)value); return; }
                        case BuiltInType.DateTime: { WriteDateTime("DateTime", (DateTime)value); return; }
                        case BuiltInType.Guid: { WriteGuid("Guid", (Uuid)value); return; }
                        case BuiltInType.ByteString: { WriteByteString("ByteString", (byte[])value); return; }
                        case BuiltInType.XmlElement: { WriteXmlElement("XmlElement", (XmlElement)value); return; }
                        case BuiltInType.NodeId: { WriteNodeId("NodeId", (NodeId)value); return; }
                        case BuiltInType.ExpandedNodeId: { WriteExpandedNodeId("ExpandedNodeId", (ExpandedNodeId)value); return; }
                        case BuiltInType.StatusCode: { WriteStatusCode("StatusCode", (StatusCode)value); return; }
                        case BuiltInType.QualifiedName: { WriteQualifiedName("QualifiedName", (QualifiedName)value); return; }
                        case BuiltInType.LocalizedText: { WriteLocalizedText("LocalizedText", (LocalizedText)value); return; }
                        case BuiltInType.ExtensionObject: { WriteExtensionObject("ExtensionObject", (ExtensionObject)value); return; }
                        case BuiltInType.DataValue: { WriteDataValue("DataValue", (DataValue)value); return; }
                        case BuiltInType.Enumeration: { WriteInt32("Int32", (int)value); return; }
                    }
                }

                // write array.
                else if (typeInfo.ValueRank <= 1)
                {
                    switch (typeInfo.BuiltInType)
                    {
                        case BuiltInType.Boolean: { WriteBooleanArray("ListOfBoolean", (bool[])value); return; }
                        case BuiltInType.SByte: { WriteSByteArray("ListOfSByte", (sbyte[])value); return; }
                        case BuiltInType.Byte: { WriteByteArray("ListOfByte", (byte[])value); return; }
                        case BuiltInType.Int16: { WriteInt16Array("ListOfInt16", (short[])value); return; }
                        case BuiltInType.UInt16: { WriteUInt16Array("ListOfUInt16", (ushort[])value); return; }
                        case BuiltInType.Int32: { WriteInt32Array("ListOfInt32", (int[])value); return; }
                        case BuiltInType.UInt32: { WriteUInt32Array("ListOfUInt32", (uint[])value); return; }
                        case BuiltInType.Int64: { WriteInt64Array("ListOfInt64", (long[])value); return; }
                        case BuiltInType.UInt64: { WriteUInt64Array("ListOfUInt64", (ulong[])value); return; }
                        case BuiltInType.Float: { WriteFloatArray("ListOfFloat", (float[])value); return; }
                        case BuiltInType.Double: { WriteDoubleArray("ListOfDouble", (double[])value); return; }
                        case BuiltInType.String: { WriteStringArray("ListOfString", (string[])value); return; }
                        case BuiltInType.DateTime: { WriteDateTimeArray("ListOfDateTime", (DateTime[])value); return; }
                        case BuiltInType.Guid: { WriteGuidArray("ListOfGuid", (Uuid[])value); return; }
                        case BuiltInType.ByteString: { WriteByteStringArray("ListOfByteString", (byte[][])value); return; }
                        case BuiltInType.XmlElement: { WriteXmlElementArray("ListOfXmlElement", (XmlElement[])value); return; }
                        case BuiltInType.NodeId: { WriteNodeIdArray("ListOfNodeId", (NodeId[])value); return; }
                        case BuiltInType.ExpandedNodeId: { WriteExpandedNodeIdArray("ListOfExpandedNodeId", (ExpandedNodeId[])value); return; }
                        case BuiltInType.StatusCode: { WriteStatusCodeArray("ListOfStatusCode", (StatusCode[])value); return; }
                        case BuiltInType.QualifiedName: { WriteQualifiedNameArray("ListOfQualifiedName", (QualifiedName[])value); return; }
                        case BuiltInType.LocalizedText: { WriteLocalizedTextArray("ListOfLocalizedText", (LocalizedText[])value); return; }
                        case BuiltInType.ExtensionObject: { WriteExtensionObjectArray("ListOfExtensionObject", (ExtensionObject[])value); return; }
                        case BuiltInType.DataValue: { WriteDataValueArray("ListOfDataValue", (DataValue[])value); return; }

                        case BuiltInType.Enumeration:
                        {
                            int[] ints = value as int[];
                            if (ints == null)
                            {
                                Enum[] enums = value as Enum[];
                                if (enums == null)
                                {
                                    throw new ServiceResultException(
                                        StatusCodes.BadEncodingError,
                                        Utils.Format("Type '{0}' is not allowed in an Enumeration.", value.GetType().FullName));
                                }
                                ints = new int[enums.Length];
                                for (int ii = 0; ii < enums.Length; ii++)
                                {
                                    ints[ii] = (int)(object)enums[ii];
                                }
                            }

                            WriteInt32Array("ListOfInt32", ints);
                            return;
                        }

                        case BuiltInType.Variant:
                        {
                            Variant[] variants = value as Variant[];

                            if (variants != null)
                            {
                                WriteVariantArray("ListOfVariant", variants);
                                return;
                            }

                            object[] objects = value as object[];

                            if (objects != null)
                            {
                                WriteObjectArray("ListOfVariant", objects);
                                return;
                            }

                            throw ServiceResultException.Create(
                                StatusCodes.BadEncodingError,
                                "Unexpected type encountered while encoding an array of Variants: {0}",
                                value.GetType());
                        }
                    }
                }

                // write matrix.
                else if (typeInfo.ValueRank > 1)
                {
                    WriteMatrix("Matrix", (Matrix)value);
                    return;
                }

                // oops - should never happen.
                throw new ServiceResultException(
                    StatusCodes.BadEncodingError,
                    Utils.Format("Type '{0}' is not allowed in an Variant.", value.GetType().FullName));
            }
            finally
            {
                PopNamespace();
            }
        }

        /// <summary>
        /// Writes the body of an ExtensionObject to the stream.
        /// </summary>
        public void WriteExtensionObjectBody(object body)
        {
            // nothing to do for null bodies.
            if (body == null)
            {
                return;
            }

            // encode byte body.
            byte[] bytes = body as byte[];

            if (bytes != null)
            {
                m_writer.WriteStartElement("ByteString", Namespaces.OpcUaXsd);
                m_writer.WriteString(Convert.ToBase64String(bytes, Base64FormattingOptions.InsertLineBreaks));
                m_writer.WriteEndElement();
                return;
            }

            // encode xml body.
            XmlElement xml = body as XmlElement;

            if (xml != null)
            {
                XmlReader reader = XmlReader.Create(new StringReader(xml.OuterXml));
                m_writer.WriteNode(reader, false);
                reader.Dispose();
                return;
            }

            IEncodeable encodeable = body as IEncodeable;

            if (encodeable == null)
            {
                throw new ServiceResultException(
                    StatusCodes.BadEncodingError,
                    Utils.Format("Don't know how to encode extension object body with type '{0}'.", body.GetType().FullName));
            }

            // encode extension object in xml.
            XmlQualifiedName xmlName = EncodeableFactory.GetXmlName(encodeable.GetType());
            m_writer.WriteStartElement(xmlName.Name, xmlName.Namespace);
            encodeable.Encode(this);
            m_writer.WriteEndElement();
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        private void WriteMatrix(string fieldName, Matrix value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            if (BeginField(fieldName, value == null, true, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    m_writer.WriteStartElement("Elements", Namespaces.OpcUaXsd);
                    WriteVariantContents(value.Elements, new TypeInfo(value.TypeInfo.BuiltInType, ValueRanks.OneDimension));
                    m_writer.WriteEndElement();

                    WriteInt32Array("Dimensions", value.Dimensions);
                }

                PopNamespace();

                EndField(fieldName);
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteObjectArray(string fieldName, IList<object> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteVariant("Variant", new Variant(values[ii]));
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes the start element for a field.
        /// </summary>
        private bool BeginField(string fieldName, bool isDefault, bool isNillable, bool isArrayElement = false)
        {
            // specifying a null field name means the start/end tags should not be written.
            if (!String.IsNullOrEmpty(fieldName))
            {
                if (isNillable && isDefault && !isArrayElement)
                {
                    return false;
                }

                m_writer.WriteStartElement(fieldName, m_namespaces.Peek());

                if (isDefault)
                {
                    if (isNillable)
                    {
                        m_writer.WriteAttributeString("nil", Namespaces.XmlSchemaInstance, "true");
                    }

                    m_writer.WriteEndElement();
                    return false;
                }
            }

            return !isDefault;
        }

        /// <summary>
        /// Writes the end element for a field.
        /// </summary>
        private void EndField(string fieldName)
        {
            if (!String.IsNullOrEmpty(fieldName))
            {
                m_writer.WriteEndElement();
            }
        }
        #endregion

        #region Private Fields
        private StringBuilder m_destination;
        private XmlWriter m_writer;
        private Stack<string> m_namespaces;
        private XmlQualifiedName m_root;
        private ServiceMessageContext m_context;
        private ushort[] m_namespaceMappings;
        private ushort[] m_serverMappings;
        private uint m_nestingLevel;
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// Writes objects to a XML stream.
    /// </summary>
    public class XmlEncoder : IEncoder, IDisposable
    {
        #region Constructors
        /// <summary>
        /// Initializes the object with default values.
        /// </summary>
        public XmlEncoder(ServiceMessageContext context)
        {
            Initialize();

            m_destination = new StringBuilder();
            m_context = context;
            m_nestingLevel = 0;

            XmlWriterSettings settings = new XmlWriterSettings();
            settings.CheckCharacters = false;
            settings.ConformanceLevel = ConformanceLevel.Auto;
            settings.NamespaceHandling = NamespaceHandling.OmitDuplicates;
            settings.NewLineHandling = NewLineHandling.Replace;

            m_writer = XmlWriter.Create(m_destination, settings);
        }

        /// <summary>
        /// Initializes the object with a system type to encode and a XML writer.
        /// </summary>
        public XmlEncoder(System.Type systemType, XmlWriter writer, ServiceMessageContext context)
        :
            this(EncodeableFactory.GetXmlName(systemType), writer, context)
        {
        }

        /// <summary>
        /// Initializes the object with a system type to encode and a XML writer.
        /// </summary>
        public XmlEncoder(XmlQualifiedName root, XmlWriter writer, ServiceMessageContext context)
        {
            Initialize();

            if (writer == null)
            {
                m_destination = new StringBuilder();
                m_writer = XmlWriter.Create(m_destination);
            }
            else
            {
                m_destination = null;
                m_writer = writer;
            }

            Initialize(root.Name, root.Namespace);
            m_context = context;
            m_nestingLevel = 0;
        }

        /// <summary>
        /// Sets private members to default values.
        /// </summary>
        private void Initialize()
        {
            m_destination = null;
            m_writer = null;
            m_namespaces = new Stack<string>();
            m_root = null;
        }

        /// <summary>
        /// Writes the root element to the stream.
        /// </summary>
        private void Initialize(string fieldName, string namespaceUri)
        {
            m_root = new XmlQualifiedName(fieldName, namespaceUri);

            string uaxPrefix = m_writer.LookupPrefix(Namespaces.OpcUaXsd);

            if (uaxPrefix == null)
            {
                uaxPrefix = "uax";
            }

            if (namespaceUri == Namespaces.OpcUaXsd)
            {
                m_writer.WriteStartElement(uaxPrefix, fieldName, namespaceUri);
            }
            else
            {
                m_writer.WriteStartElement(fieldName, namespaceUri);
            }

            string xsiPrefix = m_writer.LookupPrefix(Namespaces.XmlSchemaInstance);

            if (xsiPrefix == null)
            {
                m_writer.WriteAttributeString("xmlns", "xsi", null, Namespaces.XmlSchemaInstance);
            }

            uaxPrefix = m_writer.LookupPrefix(Namespaces.OpcUaXsd);

            if (uaxPrefix == null)
            {
                m_writer.WriteAttributeString("xmlns", "uax", null, Namespaces.OpcUaXsd);
            }

            PushNamespace(namespaceUri);
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Initializes the tables used to map namespace and server uris during encoding.
        /// </summary>
        /// <param name="namespaceUris">The namespaces URIs referenced by the data being encoded.</param>
        /// <param name="serverUris">The server URIs referenced by the data being encoded.</param>
        public void SetMappingTables(NamespaceTable namespaceUris, StringTable serverUris)
        {
            m_namespaceMappings = null;

            if (namespaceUris != null && m_context.NamespaceUris != null)
            {
                m_namespaceMappings = namespaceUris.CreateMapping(m_context.NamespaceUris, false);
            }

            m_serverMappings = null;

            if (serverUris != null && m_context.ServerUris != null)
            {
                m_serverMappings = serverUris.CreateMapping(m_context.ServerUris, false);
            }
        }

        /// <summary>
        /// Saves a string table from an XML stream.
        /// </summary>
        /// <param name="tableName">Name of the table.</param>
        /// <param name="elementName">Name of the element.</param>
        /// <param name="stringTable">The string table.</param>
        public void SaveStringTable(string tableName, string elementName, StringTable stringTable)
        {
            if (stringTable == null || stringTable.Count <= 1)
            {
                return;
            }

            PushNamespace(Namespaces.OpcUaXsd);

            try
            {
                Push(tableName, Namespaces.OpcUaXsd);

                for (ushort ii = 1; ii < stringTable.Count; ii++)
                {
                    WriteString(elementName, stringTable.GetString(ii));
                }

                Pop();
            }
            finally
            {
                PopNamespace();
            }
        }

        /// <summary>
        /// Writes a start element.
        /// </summary>
        /// <param name="fieldName">The name of the element.</param>
        /// <param name="namespaceUri">The namespace that qualifies the element name.</param>
        public void Push(string fieldName, string namespaceUri)
        {
            m_writer.WriteStartElement(fieldName, namespaceUri);
            PushNamespace(namespaceUri);
        }

        /// <summary>
        /// Writes an end element.
        /// </summary>
        public void Pop()
        {
            m_writer.WriteEndElement();
            PopNamespace();
        }

        /// <summary>
        /// Completes writing and returns the XML text.
        /// </summary>
        public string Close()
        {
            if (m_root != null)
            {
                m_writer.WriteEndElement();
            }

            m_writer.Flush();
            m_writer.Dispose();

            if (m_destination != null)
            {
                return m_destination.ToString();
            }

            return null;
        }
        #endregion

        #region IDisposable Members
        /// <summary>
        /// Frees any unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
        }

        /// <summary>
        /// An overrideable version of the Dispose.
        /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (m_writer != null)
                {
                    m_writer.Flush();
                    m_writer.Dispose();
                    m_writer = null;
                }
            }
        }
        #endregion

        #region IEncoder Members
        /// <summary>
        /// The type of encoding being used.
        /// </summary>
        public EncodingType EncodingType => EncodingType.Xml;

        /// <summary>
        /// The message context associated with the encoder.
        /// </summary>
        public ServiceMessageContext Context => m_context;

        /// <summary>
        /// Xml Encoder always produces reversible encoding.
        /// </summary>
        public bool UseReversibleEncoding => true;

        /// <summary>
        /// Pushes a namespace onto the namespace stack.
        /// </summary>
        public void PushNamespace(string namespaceUri)
        {
            m_namespaces.Push(namespaceUri);
        }

        /// <summary>
        /// Pops a namespace from the namespace stack.
        /// </summary>
        public void PopNamespace()
        {
            m_namespaces.Pop();
        }

        /// <summary>
        /// Writes a boolean to the stream.
        /// </summary>
        public void WriteBoolean(string fieldName, bool value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a sbyte to the stream.
        /// </summary>
        public void WriteSByte(string fieldName, sbyte value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a byte to the stream.
        /// </summary>
        public void WriteByte(string fieldName, byte value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a short to the stream.
        /// </summary>
        public void WriteInt16(string fieldName, short value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a ushort to the stream.
        /// </summary>
        public void WriteUInt16(string fieldName, ushort value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an int to the stream.
        /// </summary>
        public void WriteInt32(string fieldName, int value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a uint to the stream.
        /// </summary>
        public void WriteUInt32(string fieldName, uint value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a long to the stream.
        /// </summary>
        public void WriteInt64(string fieldName, long value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a ulong to the stream.
        /// </summary>
        public void WriteUInt64(string fieldName, ulong value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(XmlConvert.ToString(value));
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a float to the stream.
        /// </summary>
        public void WriteFloat(string fieldName, float value)
        {
            if (BeginField(fieldName, false, false))
            {
                if (Single.IsNaN(value))
                {
                    m_writer.WriteValue("NaN");
                }
                else if (Single.IsPositiveInfinity(value))
                {
                    m_writer.WriteValue("INF");
                }
                else if (Single.IsNegativeInfinity(value))
                {
                    m_writer.WriteValue("-INF");
                }
                else
                {
                    m_writer.WriteValue(value);
                }

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a double to the stream.
        /// </summary>
        public void WriteDouble(string fieldName, double value)
        {
            if (BeginField(fieldName, false, false))
            {
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a string to the stream.
        /// </summary>
        public void WriteString(string fieldName, string value)
        {
            WriteString(fieldName, value, false);
        }

        private void WriteString(string fieldName, string value, bool isArrayElement)
        {
            if (BeginField(fieldName, value == null, true, isArrayElement))
            {
                // check the length.
                if (m_context.MaxStringLength > 0 && m_context.MaxStringLength < value.Length)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                if (!String.IsNullOrWhiteSpace(value))
                {
                    m_writer.WriteString(value);
                }

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a UTC date/time to the stream.
        /// </summary>
        public void WriteDateTime(string fieldName, DateTime value)
        {
            if (BeginField(fieldName, false, false))
            {
                value = Utils.ToOpcUaUniversalTime(value);
                m_writer.WriteValue(value);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Uuid value)
        {
            if (BeginField(fieldName, false, false))
            {
                PushNamespace(Namespaces.OpcUaXsd);
                WriteString("String", value.GuidString);
                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a GUID to the stream.
        /// </summary>
        public void WriteGuid(string fieldName, Guid value)
        {
            if (BeginField(fieldName, false, false))
            {
                PushNamespace(Namespaces.OpcUaXsd);
                WriteString("String", value.ToString());
                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a byte string to the stream.
        /// </summary>
        public void WriteByteString(string fieldName, byte[] value)
        {
            WriteByteString(fieldName, value, false);
        }

        private void WriteByteString(string fieldName, byte[] value, bool isArrayElement = false)
        {
            if (BeginField(fieldName, value == null, true, isArrayElement))
            {
                // check the length.
                if (m_context.MaxByteStringLength > 0 && m_context.MaxByteStringLength < value.Length)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                m_writer.WriteValue(Convert.ToBase64String(value, Base64FormattingOptions.InsertLineBreaks));
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an XmlElement to the stream.
        /// </summary>
        public void WriteXmlElement(string fieldName, XmlElement value)
        {
            WriteXmlElement(fieldName, value, false);
        }

        private void WriteXmlElement(string fieldName, XmlElement value, bool isArrayElement)
        {
            if (BeginField(fieldName, value == null, true, isArrayElement))
            {
                m_writer.WriteRaw(value.OuterXml);
                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an NodeId to the stream.
        /// </summary>
        public void WriteNodeId(string fieldName, NodeId value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    ushort namespaceIndex = value.NamespaceIndex;

                    if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
                    {
                        namespaceIndex = m_namespaceMappings[namespaceIndex];
                    }

                    StringBuilder buffer = new StringBuilder();
                    NodeId.Format(buffer, value.Identifier, value.IdType, namespaceIndex);
                    WriteString("Identifier", buffer.ToString());
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an ExpandedNodeId to the stream.
        /// </summary>
        public void WriteExpandedNodeId(string fieldName, ExpandedNodeId value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    ushort namespaceIndex = value.NamespaceIndex;

                    if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
                    {
                        namespaceIndex = m_namespaceMappings[namespaceIndex];
                    }

                    uint serverIndex = value.ServerIndex;

                    if (m_serverMappings != null && m_serverMappings.Length > serverIndex)
                    {
                        serverIndex = m_serverMappings[serverIndex];
                    }

                    StringBuilder buffer = new StringBuilder();
                    ExpandedNodeId.Format(buffer, value.Identifier, value.IdType, namespaceIndex, value.NamespaceUri, serverIndex);
                    WriteString("Identifier", buffer.ToString());
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an StatusCode to the stream.
        /// </summary>
        public void WriteStatusCode(string fieldName, StatusCode value)
        {
            if (BeginField(fieldName, false, false))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    WriteUInt32("Code", value.Code);
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an DiagnosticInfo to the stream.
        /// </summary>
        public void WriteDiagnosticInfo(string fieldName, DiagnosticInfo value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    WriteInt32("SymbolicId", value.SymbolicId);
                    WriteInt32("NamespaceUri", value.NamespaceUri);
                    WriteInt32("Locale", value.Locale);
                    WriteInt32("LocalizedText", value.LocalizedText);
                    WriteString("AdditionalInfo", value.AdditionalInfo);
                    WriteStatusCode("InnerStatusCode", value.InnerStatusCode);
                    WriteDiagnosticInfo("InnerDiagnosticInfo", value.InnerDiagnosticInfo);
                }

                PopNamespace();

                EndField(fieldName);
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an QualifiedName to the stream.
        /// </summary>
        public void WriteQualifiedName(string fieldName, QualifiedName value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                ushort namespaceIndex = value.NamespaceIndex;

                if (m_namespaceMappings != null && m_namespaceMappings.Length > namespaceIndex)
                {
                    namespaceIndex = m_namespaceMappings[namespaceIndex];
                }

                if (value != null)
                {
                    WriteUInt16("NamespaceIndex", namespaceIndex);
                    WriteString("Name", value.Name);
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an LocalizedText to the stream.
        /// </summary>
        public void WriteLocalizedText(string fieldName, LocalizedText value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    if (!String.IsNullOrEmpty(value.Locale))
                    {
                        WriteString("Locale", value.Locale);
                    }

                    if (!String.IsNullOrEmpty(value.Text))
                    {
                        WriteString("Text", value.Text);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteVariant(string fieldName, Variant value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            if (BeginField(fieldName, false, false))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                m_writer.WriteStartElement("Value", Namespaces.OpcUaXsd);
                WriteVariantContents(value.Value, value.TypeInfo);
                m_writer.WriteEndElement();

                PopNamespace();

                EndField(fieldName);
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValue(string fieldName, DataValue value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    WriteVariant("Value", value.WrappedValue);
                    WriteStatusCode("StatusCode", value.StatusCode);
                    WriteDateTime("SourceTimestamp", value.SourceTimestamp);
                    WriteUInt16("SourcePicoseconds", value.SourcePicoseconds);
                    WriteDateTime("ServerTimestamp", value.ServerTimestamp);
                    WriteUInt16("ServerPicoseconds", value.ServerPicoseconds);
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an ExtensionObject to the stream.
        /// </summary>
        public void WriteExtensionObject(string fieldName, ExtensionObject value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                // check for null.
                if (value == null)
                {
                    EndField(fieldName);
                    PopNamespace();
                    return;
                }

                // write the type id.
                ExpandedNodeId typeId = value.TypeId;

                if (value.Body is IEncodeable encodeable)
                {
                    if (value.Encoding == ExtensionObjectEncoding.Binary)
                    {
                        typeId = encodeable.BinaryEncodingId;
                    }
                    else
                    {
                        typeId = encodeable.XmlEncodingId;
                    }
                }

                NodeId localTypeId = ExpandedNodeId.ToNodeId(typeId, m_context.NamespaceUris);

                if (NodeId.IsNull(localTypeId) && !NodeId.IsNull(typeId))
                {
                    if (value.Body is IEncodeable encodeable)
                    {
                        throw ServiceResultException.Create(
                            StatusCodes.BadEncodingError,
                            "Cannot encode bodies of type '{0}' in ExtensionObject unless the NamespaceUri ({1}) is in the encoder's NamespaceTable.",
                            encodeable.GetType().FullName,
                            typeId.NamespaceUri);
                    }

                    localTypeId = NodeId.Null;
                }

                WriteNodeId("TypeId", localTypeId);

                object body = value.Body;

                if (body == null)
                {
                    EndField(fieldName);
                    PopNamespace();
                    return;
                }

                // write the body.
                m_writer.WriteStartElement("Body", Namespaces.OpcUaXsd);

                WriteExtensionObjectBody(body);

                // end of body.
                m_writer.WriteEndElement();

                EndField(fieldName);
                PopNamespace();
            }
        }

        /// <summary>
        /// Writes an encodeable object to the stream.
        /// </summary>
        public void WriteEncodeable(string fieldName, IEncodeable value, System.Type systemType)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            if (BeginField(fieldName, value == null, true))
            {
                value?.Encode(this);

                EndField(fieldName);
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an enumerated value array to the stream.
        /// </summary>
        public void WriteEnumerated(string fieldName, Enum value)
        {
            if (BeginField(fieldName, value == null, true))
            {
                if (value != null)
                {
                    var valueSymbol = value.ToString();
                    var valueInt32 = Convert.ToInt32(value, CultureInfo.InvariantCulture).ToString();
                    if (valueSymbol != valueInt32)
                    {
                        m_writer.WriteString(Utils.Format("{0}_{1}", valueSymbol, valueInt32));
                    }
                    else
                    {
                        m_writer.WriteString(valueSymbol);
                    }
                }

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a boolean array to the stream.
        /// </summary>
        public void WriteBooleanArray(string fieldName, IList<bool> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteBoolean("Boolean", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteSByteArray(string fieldName, IList<sbyte> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteSByte("SByte", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a sbyte array to the stream.
        /// </summary>
        public void WriteByteArray(string fieldName, IList<byte> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteByte("Byte", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a short array to the stream.
        /// </summary>
        public void WriteInt16Array(string fieldName, IList<short> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteInt16("Int16", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a ushort array to the stream.
        /// </summary>
        public void WriteUInt16Array(string fieldName, IList<ushort> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteUInt16("UInt16", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a int array to the stream.
        /// </summary>
        public void WriteInt32Array(string fieldName, IList<int> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteInt32("Int32", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a uint array to the stream.
        /// </summary>
        public void WriteUInt32Array(string fieldName, IList<uint> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteUInt32("UInt32", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a long array to the stream.
        /// </summary>
        public void WriteInt64Array(string fieldName, IList<long> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteInt64("Int64", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a ulong array to the stream.
        /// </summary>
        public void WriteUInt64Array(string fieldName, IList<ulong> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteUInt64("UInt64", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a float array to the stream.
        /// </summary>
        public void WriteFloatArray(string fieldName, IList<float> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteFloat("Float", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a double array to the stream.
        /// </summary>
        public void WriteDoubleArray(string fieldName, IList<double> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteDouble("Double", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a string array to the stream.
        /// </summary>
        public void WriteStringArray(string fieldName, IList<string> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteString("String", values[ii], true);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a UTC date/time array to the stream.
        /// </summary>
        public void WriteDateTimeArray(string fieldName, IList<DateTime> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteDateTime("DateTime", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Uuid> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteGuid("Guid", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a GUID array to the stream.
        /// </summary>
        public void WriteGuidArray(string fieldName, IList<Guid> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteGuid("Guid", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes a byte string array to the stream.
        /// </summary>
        public void WriteByteStringArray(string fieldName, IList<byte[]> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteByteString("ByteString", values[ii], true);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an XmlElement array to the stream.
        /// </summary>
        public void WriteXmlElementArray(string fieldName, IList<XmlElement> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteXmlElement("XmlElement", values[ii], true);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an NodeId array to the stream.
        /// </summary>
        public void WriteNodeIdArray(string fieldName, IList<NodeId> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteNodeId("NodeId", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an ExpandedNodeId array to the stream.
        /// </summary>
        public void WriteExpandedNodeIdArray(string fieldName, IList<ExpandedNodeId> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteExpandedNodeId("ExpandedNodeId", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an StatusCode array to the stream.
        /// </summary>
        public void WriteStatusCodeArray(string fieldName, IList<StatusCode> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteStatusCode("StatusCode", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an DiagnosticInfo array to the stream.
        /// </summary>
        public void WriteDiagnosticInfoArray(string fieldName, IList<DiagnosticInfo> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteDiagnosticInfo("DiagnosticInfo", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an QualifiedName array to the stream.
        /// </summary>
        public void WriteQualifiedNameArray(string fieldName, IList<QualifiedName> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteQualifiedName("QualifiedName", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an LocalizedText array to the stream.
        /// </summary>
        public void WriteLocalizedTextArray(string fieldName, IList<LocalizedText> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteLocalizedText("LocalizedText", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteVariantArray(string fieldName, IList<Variant> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteVariant("Variant", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        public void WriteDataValueArray(string fieldName, IList<DataValue> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteDataValue("DataValue", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an extension object array to the stream.
        /// </summary>
        public void WriteExtensionObjectArray(string fieldName, IList<ExtensionObject> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteExtensionObject("ExtensionObject", values[ii]);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an encodeable object array to the stream.
        /// </summary>
        public void WriteEncodeableArray(string fieldName, IList<IEncodeable> values, System.Type systemType)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                // get name for type being encoded.
                XmlQualifiedName xmlName = EncodeableFactory.GetXmlName(systemType);

                if (xmlName == null)
                {
                    xmlName = new XmlQualifiedName("IEncodeable", Namespaces.OpcUaXsd);
                }

                PushNamespace(xmlName.Namespace);

                // encode each element in the array.
                for (int ii = 0; ii < values.Count; ii++)
                {
                    IEncodeable value = values[ii];

                    if (systemType != null)
                    {
                        if (!systemType.IsInstanceOfType(value))
                        {
                            throw new ServiceResultException(
                                StatusCodes.BadEncodingError,
                                Utils.Format("Objects with type '{0}' are not allowed in the array being serialized.", systemType.FullName));
                        }

                        WriteEncodeable(xmlName.Name, value, systemType);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes an enumerated value array to the stream.
        /// </summary>
        public void WriteEnumeratedArray(string fieldName, Array values, System.Type systemType)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Length)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                // get name for type being encoded.
                XmlQualifiedName xmlName = EncodeableFactory.GetXmlName(systemType);

                if (xmlName == null)
                {
                    xmlName = new XmlQualifiedName("Enumerated", Namespaces.OpcUaXsd);
                }

                PushNamespace(xmlName.Namespace);

                if (values != null)
                {
                    // encode each element in the array.
                    foreach (Enum value in values)
                    {
                        WriteEnumerated(xmlName.Name, value);
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Writes the contents of an Variant to the stream.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public void WriteVariantContents(object value, TypeInfo typeInfo)
        {
            // check for null.
            if (value == null)
            {
                m_writer.WriteStartElement("Null", Namespaces.OpcUaXsd);
                m_writer.WriteEndElement();
                return;
            }

            try
            {
                PushNamespace(Namespaces.OpcUaXsd);

                // write scalar.
                if (typeInfo.ValueRank < 0)
                {
                    switch (typeInfo.BuiltInType)
                    {
                        case BuiltInType.Boolean: { WriteBoolean("Boolean", (bool)value); return; }
                        case BuiltInType.SByte: { WriteSByte("SByte", (sbyte)value); return; }
                        case BuiltInType.Byte: { WriteByte("Byte", (byte)value); return; }
                        case BuiltInType.Int16: { WriteInt16("Int16", (short)value); return; }
                        case BuiltInType.UInt16: { WriteUInt16("UInt16", (ushort)value); return; }
                        case BuiltInType.Int32: { WriteInt32("Int32", (int)value); return; }
                        case BuiltInType.UInt32: { WriteUInt32("UInt32", (uint)value); return; }
                        case BuiltInType.Int64: { WriteInt64("Int64", (long)value); return; }
                        case BuiltInType.UInt64: { WriteUInt64("UInt64", (ulong)value); return; }
                        case BuiltInType.Float: { WriteFloat("Float", (float)value); return; }
                        case BuiltInType.Double: { WriteDouble("Double", (double)value); return; }
                        case BuiltInType.String: { WriteString("String", (string)value); return; }
                        case BuiltInType.DateTime: { WriteDateTime("DateTime", (DateTime)value); return; }
                        case BuiltInType.Guid: { WriteGuid("Guid", (Uuid)value); return; }
                        case BuiltInType.ByteString: { WriteByteString("ByteString", (byte[])value); return; }
                        case BuiltInType.XmlElement: { WriteXmlElement("XmlElement", (XmlElement)value); return; }
                        case BuiltInType.NodeId: { WriteNodeId("NodeId", (NodeId)value); return; }
                        case BuiltInType.ExpandedNodeId: { WriteExpandedNodeId("ExpandedNodeId", (ExpandedNodeId)value); return; }
                        case BuiltInType.StatusCode: { WriteStatusCode("StatusCode", (StatusCode)value); return; }
                        case BuiltInType.QualifiedName: { WriteQualifiedName("QualifiedName", (QualifiedName)value); return; }
                        case BuiltInType.LocalizedText: { WriteLocalizedText("LocalizedText", (LocalizedText)value); return; }
                        case BuiltInType.ExtensionObject: { WriteExtensionObject("ExtensionObject", (ExtensionObject)value); return; }
                        case BuiltInType.DataValue: { WriteDataValue("DataValue", (DataValue)value); return; }
                        case BuiltInType.Enumeration: { WriteInt32("Int32", (int)value); return; }
                    }
                }

                // write array.
                else if (typeInfo.ValueRank <= 1)
                {
                    switch (typeInfo.BuiltInType)
                    {
                        case BuiltInType.Boolean: { WriteBooleanArray("ListOfBoolean", (bool[])value); return; }
                        case BuiltInType.SByte: { WriteSByteArray("ListOfSByte", (sbyte[])value); return; }
                        case BuiltInType.Byte: { WriteByteArray("ListOfByte", (byte[])value); return; }
                        case BuiltInType.Int16: { WriteInt16Array("ListOfInt16", (short[])value); return; }
                        case BuiltInType.UInt16: { WriteUInt16Array("ListOfUInt16", (ushort[])value); return; }
                        case BuiltInType.Int32: { WriteInt32Array("ListOfInt32", (int[])value); return; }
                        case BuiltInType.UInt32: { WriteUInt32Array("ListOfUInt32", (uint[])value); return; }
                        case BuiltInType.Int64: { WriteInt64Array("ListOfInt64", (long[])value); return; }
                        case BuiltInType.UInt64: { WriteUInt64Array("ListOfUInt64", (ulong[])value); return; }
                        case BuiltInType.Float: { WriteFloatArray("ListOfFloat", (float[])value); return; }
                        case BuiltInType.Double: { WriteDoubleArray("ListOfDouble", (double[])value); return; }
                        case BuiltInType.String: { WriteStringArray("ListOfString", (string[])value); return; }
                        case BuiltInType.DateTime: { WriteDateTimeArray("ListOfDateTime", (DateTime[])value); return; }
                        case BuiltInType.Guid: { WriteGuidArray("ListOfGuid", (Uuid[])value); return; }
                        case BuiltInType.ByteString: { WriteByteStringArray("ListOfByteString", (byte[][])value); return; }
                        case BuiltInType.XmlElement: { WriteXmlElementArray("ListOfXmlElement", (XmlElement[])value); return; }
                        case BuiltInType.NodeId: { WriteNodeIdArray("ListOfNodeId", (NodeId[])value); return; }
                        case BuiltInType.ExpandedNodeId: { WriteExpandedNodeIdArray("ListOfExpandedNodeId", (ExpandedNodeId[])value); return; }
                        case BuiltInType.StatusCode: { WriteStatusCodeArray("ListOfStatusCode", (StatusCode[])value); return; }
                        case BuiltInType.QualifiedName: { WriteQualifiedNameArray("ListOfQualifiedName", (QualifiedName[])value); return; }
                        case BuiltInType.LocalizedText: { WriteLocalizedTextArray("ListOfLocalizedText", (LocalizedText[])value); return; }
                        case BuiltInType.ExtensionObject: { WriteExtensionObjectArray("ListOfExtensionObject", (ExtensionObject[])value); return; }
                        case BuiltInType.DataValue: { WriteDataValueArray("ListOfDataValue", (DataValue[])value); return; }

                        case BuiltInType.Enumeration:
                        {
                            int[] ints = value as int[];
                            if (ints == null)
                            {
                                Enum[] enums = value as Enum[];
                                if (enums == null)
                                {
                                    throw new ServiceResultException(
                                        StatusCodes.BadEncodingError,
                                        Utils.Format("Type '{0}' is not allowed in an Enumeration.", value.GetType().FullName));
                                }
                                ints = new int[enums.Length];
                                for (int ii = 0; ii < enums.Length; ii++)
                                {
                                    ints[ii] = (int)(object)enums[ii];
                                }
                            }

                            WriteInt32Array("ListOfInt32", ints);
                            return;
                        }

                        case BuiltInType.Variant:
                        {
                            if (value is Variant[] variants)
                            {
                                WriteVariantArray("ListOfVariant", variants);
                                return;
                            }

                            if (value is object[] objects)
                            {
                                WriteObjectArray("ListOfVariant", objects);
                                return;
                            }

                            throw ServiceResultException.Create(
                                StatusCodes.BadEncodingError,
                                "Unexpected type encountered while encoding an array of Variants: {0}",
                                value.GetType());
                        }
                    }
                }

                // write matrix.
                else if (typeInfo.ValueRank > 1)
                {
                    WriteMatrix("Matrix", (Matrix)value);
                    return;
                }

                // oops - should never happen.
                throw new ServiceResultException(
                    StatusCodes.BadEncodingError,
                    Utils.Format("Type '{0}' is not allowed in an Variant.", value.GetType().FullName));
            }
            finally
            {
                PopNamespace();
            }
        }

        /// <summary>
        /// Writes the body of an ExtensionObject to the stream.
        /// </summary>
        public void WriteExtensionObjectBody(object body)
        {
            // nothing to do for null bodies.
            if (body == null)
            {
                return;
            }

            // encode byte body.

            if (body is byte[] bytes)
            {
                m_writer.WriteStartElement("ByteString", Namespaces.OpcUaXsd);
                m_writer.WriteString(Convert.ToBase64String(bytes, Base64FormattingOptions.InsertLineBreaks));
                m_writer.WriteEndElement();
                return;
            }

            // encode xml body.

            if (body is XmlElement xml)
            {
                XmlReader reader = XmlReader.Create(new StringReader(xml.OuterXml));
                m_writer.WriteNode(reader, false);
                reader.Dispose();
                return;
            }

            IEncodeable encodeable = body as IEncodeable;

            if (encodeable == null)
            {
                throw new ServiceResultException(
                    StatusCodes.BadEncodingError,
                    Utils.Format("Don't know how to encode extension object body with type '{0}'.", body.GetType().FullName));
            }

            // encode extension object in xml.
            XmlQualifiedName xmlName = EncodeableFactory.GetXmlName(encodeable.GetType());
            m_writer.WriteStartElement(xmlName.Name, xmlName.Namespace);
            encodeable.Encode(this);
            m_writer.WriteEndElement();
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Writes an DataValue array to the stream.
        /// </summary>
        private void WriteMatrix(string fieldName, Matrix value)
        {
            // check the nesting level for avoiding a stack overflow.
            if (m_nestingLevel > m_context.MaxEncodingNestingLevels)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadEncodingLimitsExceeded,
                    "Maximum nesting level of {0} was exceeded",
                    m_context.MaxEncodingNestingLevels);
            }

            m_nestingLevel++;

            if (BeginField(fieldName, value == null, true, true))
            {
                PushNamespace(Namespaces.OpcUaXsd);

                if (value != null)
                {
                    m_writer.WriteStartElement("Elements", Namespaces.OpcUaXsd);
                    WriteVariantContents(value.Elements, new TypeInfo(value.TypeInfo.BuiltInType, ValueRanks.OneDimension));
                    m_writer.WriteEndElement();

                    WriteInt32Array("Dimensions", value.Dimensions);
                }

                PopNamespace();

                EndField(fieldName);
            }

            m_nestingLevel--;
        }

        /// <summary>
        /// Writes an Variant array to the stream.
        /// </summary>
        public void WriteObjectArray(string fieldName, IList<object> values)
        {
            if (BeginField(fieldName, values == null, true, true))
            {
                // check the length.
                if (m_context.MaxArrayLength > 0 && m_context.MaxArrayLength < values.Count)
                {
                    throw new ServiceResultException(StatusCodes.BadEncodingLimitsExceeded);
                }

                PushNamespace(Namespaces.OpcUaXsd);

                if (values != null)
                {
                    for (int ii = 0; ii < values.Count; ii++)
                    {
                        WriteVariant("Variant", new Variant(values[ii]));
                    }
                }

                PopNamespace();

                EndField(fieldName);
            }
        }

        /// <summary>
        /// Writes the start element for a field.
        /// </summary>
        private bool BeginField(string fieldName, bool isDefault, bool isNillable, bool isArrayElement = false)
        {
            // specifying a null field name means the start/end tags should not be written.
            if (!String.IsNullOrEmpty(fieldName))
            {
                if (isNillable && isDefault && !isArrayElement)
                {
                    return false;
                }

                m_writer.WriteStartElement(fieldName, m_namespaces.Peek());

                if (isDefault)
                {
                    if (isNillable)
                    {
                        m_writer.WriteAttributeString("nil", Namespaces.XmlSchemaInstance, "true");
                    }

                    m_writer.WriteEndElement();
                    return false;
                }
            }

            return !isDefault;
        }

        /// <summary>
        /// Writes the end element for a field.
        /// </summary>
        private void EndField(string fieldName)
        {
            if (!String.IsNullOrEmpty(fieldName))
            {
                m_writer.WriteEndElement();
            }
        }
        #endregion

        #region Private Fields
        private StringBuilder m_destination;
        private XmlWriter m_writer;
        private Stack<string> m_namespaces;
        private XmlQualifiedName m_root;
        private ServiceMessageContext m_context;
        private ushort[] m_namespaceMappings;
        private ushort[] m_serverMappings;
        private uint m_nestingLevel;
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Types\Encoders\XmlEncoder.cs(818,51): error CS0136: A local or parameter named 'encodeable' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
######################################################################


######################################################################
Nr: 26 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\NumericRange.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;

namespace Opc.Ua
{
    /// <summary>
    /// A class that stores a numeric range.
    /// </summary>
    /// <remarks>
    /// A class that stores a numeric range.
    /// </remarks>
	public struct NumericRange : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Initializes the object with a begin index.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a begin index.
        /// </remarks>
        /// <param name="begin">The starting point of the range</param>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when the parameter is less than -1</exception>
        public NumericRange(int begin)
        {
            if (begin < -1)
            {
                throw new ArgumentOutOfRangeException(nameof(begin));
            }

            m_begin = -1;
            m_end = -1;
            m_subranges = null;

            Begin = begin;
        }

        /// <summary>
        /// Initializes the object with a begin and end indexes.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a begin and end indexes.
        /// </remarks>
        /// <param name="begin">The end of the range</param>
        /// <param name="end">The beginning of the range</param>
        public NumericRange(int begin, int end)
        {
            m_begin = -1;
            m_end = -1;
            m_subranges = null;

            Begin = begin;
            End = end;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// The begining of the numeric range.
        /// </summary>
        /// <remarks>
        /// The begining of the numeric range.
        /// </remarks>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when the value is less than -1, or when the value is greater than the end</exception>
        public int Begin
        {
            get { return m_begin; }

            set
            {
                if (value < -1)
                {
                    throw new ArgumentOutOfRangeException(nameof(value), "Begin");
                }

                if (m_end != -1 && (m_begin > m_end || m_begin < 0))
                {
                    throw new ArgumentOutOfRangeException(nameof(value), "Begin > End");
                }

                m_begin = value;
            }
        }

        /// <summary>
        /// The end of the numeric range.
        /// </summary>
        /// <remarks>
        /// The end of the numeric range.
        /// </remarks>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when the value is less
        /// than -1 or when the end is less than the beginning</exception>
        public int End
        {
            get { return m_end; }

            set
            {
                if (value < -1)
                {
                    throw new ArgumentOutOfRangeException(nameof(value), "End");
                }

                if (m_end != -1 && (m_begin > m_end || m_begin < 0))
                {
                    throw new ArgumentOutOfRangeException(nameof(value), "Begin > End");
                }

                m_end = value;
            }
        }

        /// <summary>
        /// The number of elements specified by the range.
        /// </summary>
        /// <remarks>
        /// The number of elements specified by the range.
        /// </remarks>
        public int Count
        {
            get
            {
                if (m_begin == -1)
                {
                    return 0;
                }

                if (m_end == -1)
                {
                    return 1;
                }

                return m_end - m_begin + 1;
            }
        }

        /// <summary>
        /// Gets the number of dimensions in the range.
        /// </summary>
        /// <value>The number of dimensions.</value>
        public int Dimensions
        {
            get
            {
                if (m_begin == -1)
                {
                    return 0;
                }

                if (m_subranges == null)
                {
                    return 1;
                }

                return m_subranges.Length;
            }
        }

        /// <summary>
        /// Gets or sets the sub ranges for multidimensional ranges.
        /// </summary>
        /// <value>The sub ranges.</value>
        public NumericRange[] SubRanges
        {
            get
            {
                return m_subranges;
            }

            set
            {
                m_subranges = value;
            }
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Ensures the bounds are valid values for the object passed in.
        /// </summary>
        /// <remarks>
        /// Returns false if the object is not indexable or if the numeric range is out-of-bounds.
        /// </remarks>
        /// <param name="value">The value to check</param>
        public bool EnsureValid(object value)
        {
            int count = -1;

            // check for collections.
            ICollection collection = value as ICollection;

            if (collection != null)
            {
                count = collection.Count;
            }
            else
            {
                // check for arrays.
                Array array = value as Array;

                if (array != null)
                {
                    count = array.Length;
                }
            }

            // ensure bounds are less than count.
            return EnsureValid(count);
        }

        /// <summary>
        /// Ensures the bounds are valid values for a collection with the specified length.
        /// </summary>
        /// <remarks>
        /// Returns false if the numeric range is out-of-bounds.
        /// </remarks>
        /// <param name="count">The value to check is within range</param>
        public bool EnsureValid(int count)
        {
            // object not indexable.
            if (count == -1)
            {
                return false;
            }

            // check bounds.
            if (m_begin > count || m_end >= count)
            {
                return false;
            }

            // set begin.
            if (m_begin < 0)
            {
                m_begin = 0;
            }

            // set end.
            if (m_end < 0)
            {
                m_end = count;
            }

            return true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Returns true if the objects are equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are equal.
        /// </remarks>
        /// <param name="obj">The object to test against this</param>
        public override bool Equals(object obj)
        {
            if (Object.ReferenceEquals(this, obj))
            {
                return true;
            }

            NumericRange? range = obj as NumericRange?;

            if (range == null)
            {
                return false;
            }

            return (range.Value.m_begin == m_begin) && (range.Value.m_end == m_end);
        }

        /// <summary>
        /// Returns true if the objects are equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are equal.
        /// </remarks>
        /// <param name="value1">The first value to compare</param>
        /// <param name="value2">The second value to compare</param>
        public static bool operator ==(NumericRange value1, NumericRange value2)
        {
            return value1.Equals(value2);
        }

        /// <summary>
        /// Returns true if the objects are not equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are not equal.
        /// </remarks>
        /// <param name="value1">The first value to compare</param>
        /// <param name="value2">The second value to compare</param>
        public static bool operator !=(NumericRange value1, NumericRange value2)
        {
            return !value1.Equals(value2);
        }

        /// <summary>
        /// Returns a suitable hash code for the object.
        /// </summary>
        /// <remarks>
        /// Returns a suitable hash code for the object.
        /// </remarks>
        public override int GetHashCode()
        {
            return m_begin.GetHashCode() + m_end.GetHashCode();
        }

        /// <summary>
        /// Returns the string representation of the object.
        /// </summary>
        /// <remarks>
        /// Returns the string representation of the object.
        /// </remarks>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        #region IFormattable Members
        /// <summary>
        /// Formats the numeric range as a string.
        /// </summary>
        /// <remarks>
        /// Formats the numeric range as a string.
        /// </remarks>
        /// <param name="format">(Unused) Always pass NULL/NOTHING</param>
        /// <param name="formatProvider">(Unused) Always pass NULL/NOTHING</param>
        /// <exception cref="FormatException">Thrown when a non null/nothing is passed for either parameter</exception>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                if (m_end < 0)
                {
                    return String.Format(formatProvider, "{0}", m_begin);
                }

                return String.Format(formatProvider, "{0}:{1}", m_begin, m_end);
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region Static Members
        /// <summary>
        /// An empty numeric range.
        /// </summary>
        /// <remarks>
        /// An empty numeric range.
        /// </remarks>
        public static NumericRange Empty => s_Empty;

        private static readonly NumericRange s_Empty = new NumericRange(-1, -1);

        /// <summary>
        /// Parses a string representing a numeric range.
        /// </summary>
        /// <param name="textToParse">The text to parse, prior to checking it is within the allowed range</param>
        /// <param name="range">The parsed range.</param>
        /// <returns>The reason for any error.</returns>
        public static ServiceResult Validate(string textToParse, out NumericRange range)
        {
            range = NumericRange.Empty;

            if (String.IsNullOrEmpty(textToParse))
            {
                return ServiceResult.Good;
            }

            // check for multidimensional ranges.
            int index = textToParse.IndexOf(',');

            if (index >= 0)
            {
                int start = 0;
                List<NumericRange> subranges = new List<NumericRange>();

                for (int ii = 0; ii < textToParse.Length; ii++)
                {
                    char ch = textToParse[ii];

                    if (ch == ',' || ii == textToParse.Length - 1)
                    {
                        NumericRange subrange = new NumericRange();
                        string subtext = (ch == ',') ? textToParse.Substring(start, ii - start) : textToParse.Substring(start);
                        ServiceResult result = Validate(subtext, out subrange);

                        if (ServiceResult.IsBad(result))
                        {
                            return result;
                        }

                        subranges.Add(subrange);
                        start = ii + 1;
                    }
                }

                // must have at least two entries.
                if (subranges.Count < 2)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                range.m_begin = subranges[0].Begin;
                range.m_end = subranges[0].End;
                range.m_subranges = subranges.ToArray();

                return ServiceResult.Good;
            }

            try
            {
                index = textToParse.IndexOf(':');

                if (index != -1)
                {
                    range.Begin = Convert.ToInt32(textToParse.Substring(0, index), CultureInfo.InvariantCulture);
                    range.End = Convert.ToInt32(textToParse.Substring(index + 1), CultureInfo.InvariantCulture);

                    if (range.End < 0)
                    {
                        return ServiceResult.Create(
                            StatusCodes.BadIndexRangeInvalid,
                            "NumericRange does not have a valid end index ({0}).",
                            range.End);
                    }

                    if (range.Begin >= range.End)
                    {
                        return ServiceResult.Create(
                            StatusCodes.BadIndexRangeInvalid,
                            "NumericRange does not have a start index that is less than the end index ({0}).",
                            range);
                    }
                }
                else
                {
                    range.Begin = Convert.ToInt32(textToParse, CultureInfo.InvariantCulture);
                    range.End = -1;
                }

                if (range.Begin < 0)
                {
                    return ServiceResult.Create(
                        StatusCodes.BadIndexRangeInvalid,
                        "NumericRange does not have a valid start index ({0}).",
                        range.Begin);
                }
            }
            catch (Exception e)
            {
                return ServiceResult.Create(
                    e,
                    StatusCodes.BadIndexRangeInvalid,
                    "NumericRange cannot be parsed ({0}).",
                    textToParse);
            }

            return ServiceResult.Good;
        }

        /// <summary>
        /// Applies the multidimensional index range.
        /// </summary>
        private StatusCode ApplyMultiRange(ref object value)
        {
            Array array = value as Array;
            TypeInfo typeInfo = null;

            // check for matrix.
            if (array == null)
            {
                Matrix matrix = value as Matrix;

                if (matrix == null || matrix.Dimensions.Length != m_subranges.Length)
                {
                    value = null;
                    return StatusCodes.BadIndexRangeNoData;
                }

                array = matrix.ToArray();
            }

            typeInfo = TypeInfo.Construct(array);

            // check for matching dimensions.
            NumericRange? finalRange = null;

            if (m_subranges.Length > typeInfo.ValueRank)
            {
                if (typeInfo.BuiltInType == BuiltInType.ByteString || typeInfo.BuiltInType == BuiltInType.String)
                {
                    if (m_subranges.Length == typeInfo.ValueRank + 1)
                    {
                        finalRange = m_subranges[m_subranges.Length - 1];
                    }
                }

                if (finalRange == null)
                {
                    value = null;
                    return StatusCodes.BadIndexRangeNoData;
                }
            }

            // create the dimensions of the target.
            int[] dimensions = new int[typeInfo.ValueRank];

            for (int ii = 0; ii < dimensions.Length; ii++)
            {
                if (m_subranges.Length > ii)
                {
                    if (m_subranges[ii].m_begin >= array.GetLength(ii))
                    {
                        value = null;
                        return StatusCodes.BadIndexRangeNoData;
                    }

                    dimensions[ii] = m_subranges[ii].Count;
                }
                else
                {
                    dimensions[ii] = array.GetLength(ii);
                }
            }

            Array subset = TypeInfo.CreateArray(typeInfo.BuiltInType, dimensions);

            int length = subset.Length;
            int[] dstIndexes = new int[dimensions.Length];
            int[] srcIndexes = new int[dimensions.Length];

            bool dataFound = false;

            for (int ii = 0; ii < length; ii++)
            {
                int divisor = subset.Length;
                bool outOfRange = false;

                for (int jj = 0; jj < dstIndexes.Length; jj++)
                {
                    divisor /= dimensions[jj];
                    dstIndexes[jj] = (ii / divisor) % dimensions[jj];
                    srcIndexes[jj] = dstIndexes[jj] + m_subranges[jj].m_begin;

                    if (array.GetLength(jj) <= srcIndexes[jj])
                    {
                        outOfRange = true;
                        break;
                    }
                }

                if (outOfRange)
                {
                    continue;
                }

                object element = array.GetValue(srcIndexes);

                if (element != null)
                {
                    if (finalRange != null)
                    {
                        StatusCode result = finalRange.Value.ApplyRange(ref element);

                        if (StatusCode.IsBad(result))
                        {
                            if (result != StatusCodes.BadIndexRangeNoData)
                            {
                                value = null;
                                return result;
                            }

                            continue;
                        }
                    }

                    dataFound = true;
                    subset.SetValue(element, dstIndexes);
                }
            }

            if (!dataFound)
            {
                value = null;
                return StatusCodes.BadIndexRangeNoData;
            }

            value = subset;
            return StatusCodes.Good;
        }

        /// <summary>
        /// Applies the multidimensional index range.
        /// </summary>
        public StatusCode UpdateRange(ref object dst, object src)
        {
            // check for trivial case.
            if (dst == null)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            TypeInfo dstTypeInfo = TypeInfo.Construct(dst);

            // check for subset of string or byte string.
            if (dstTypeInfo.ValueRank == ValueRanks.Scalar)
            {
                if (this.Dimensions > 1)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                // check for subset of string.
                if (dstTypeInfo.BuiltInType == BuiltInType.String)
                {
                    string srcString = src as string;
                    char[] dstString = ((string)dst).ToCharArray();

                    if (srcString == null || srcString.Length != this.Count)
                    {
                        return StatusCodes.BadIndexRangeInvalid;
                    }

                    if (this.m_begin >= dstString.Length || ((this.m_end > 0 && this.m_end >= dstString.Length)))
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }

                    for (int jj = 0; jj < srcString.Length; jj++)
                    {
                        dstString[this.m_begin + jj] = srcString[jj];
                    }

                    dst = new string(dstString);
                    return StatusCodes.Good;
                }

                // update elements within a byte string.
                else if (dstTypeInfo.BuiltInType == BuiltInType.ByteString)
                {
                    byte[] srcString = src as byte[];
                    byte[] dstString = (byte[])dst;

                    if (srcString == null || srcString.Length != this.Count)
                    {
                        return StatusCodes.BadIndexRangeInvalid;
                    }

                    if (this.m_begin >= dstString.Length || ((this.m_end > 0 && this.m_end >= dstString.Length)))
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }

                    for (int jj = 0; jj < srcString.Length; jj++)
                    {
                        dstString[this.m_begin + jj] = srcString[jj];
                    }

                    return StatusCodes.Good;
                }

                // index range not supported.
                return StatusCodes.BadIndexRangeInvalid;
            }

            Array srcArray = src as Array;
            Array dstArray = dst as Array;

            // check for destinations specified as a matrix.
            if (dstArray == null)
            {
                Matrix matrix = dst as Matrix;

                if (matrix == null || m_subranges == null || matrix.Dimensions.Length != m_subranges.Length)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                dstArray = matrix.ToArray();
            }

            // check for input specified as a matrix.
            if (srcArray == null)
            {
                Matrix matrix = src as Matrix;

                if (matrix == null || m_subranges == null || matrix.Dimensions.Length != m_subranges.Length)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                srcArray = matrix.ToArray();
            }

            TypeInfo srcTypeInfo = TypeInfo.Construct(srcArray);

            if (srcTypeInfo.BuiltInType != dstTypeInfo.BuiltInType)
            {
                return StatusCodes.BadIndexRangeInvalid;
            }

            if (srcTypeInfo.ValueRank != dstTypeInfo.ValueRank)
            {
                return StatusCodes.BadIndexRangeInvalid;
            }

            // handle one dimension.
            if (m_subranges == null)
            {
                if (dstTypeInfo.ValueRank > 1)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                if (srcArray.Length != this.Count)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                if (this.m_begin >= dstArray.Length || ((this.m_end > 0 && this.m_end >= dstArray.Length)))
                {
                    return StatusCodes.BadIndexRangeNoData;
                }

                for (int jj = 0; jj < srcArray.Length; jj++)
                {
                    dstArray.SetValue(srcArray.GetValue(jj), this.m_begin + jj);
                }

                if (dst is Matrix)
                {
                    // dstArray is a copy of the data of the dst Matrix so create new Matrix with modified data
                    dst = new Matrix(dstArray, dstTypeInfo.BuiltInType);
                }

                return StatusCodes.Good;
            }

            // check for matching dimensions.
            NumericRange? finalRange = null;

            if (m_subranges != null && m_subranges.Length > srcTypeInfo.ValueRank)
            {
                if (srcTypeInfo.BuiltInType == BuiltInType.ByteString || srcTypeInfo.BuiltInType == BuiltInType.String)
                {
                    if (m_subranges.Length == srcTypeInfo.ValueRank + 1)
                    {
                        finalRange = m_subranges[m_subranges.Length - 1];
                    }
                }

                if (finalRange == null)
                {
                    return StatusCodes.BadIndexRangeNoData;
                }
            }

            // get the dimensions of the array being copied.
            int srcCount = 1;
            int[] dimensions = new int[srcTypeInfo.ValueRank];

            for (int ii = 0; ii < dimensions.Length; ii++)
            {
                if (m_subranges.Length < ii)
                {
                    if (m_subranges[ii].Count != srcArray.GetLength(ii))
                    {
                        return StatusCodes.BadIndexRangeInvalid;
                    }
                }

                dimensions[ii] = srcArray.GetLength(ii);
                srcCount *= dimensions[ii];
            }

            // check that the index range falls with the target array.
            int[] dstIndexes = new int[dimensions.Length];

            for (int ii = 0; ii < srcCount; ii++)
            {
                // check target dimensions.
                int divisor = srcCount;

                for (int jj = 0; jj < dimensions.Length; jj++)
                {
                    divisor /= dimensions[jj];
                    int index = (ii / divisor) % dimensions[jj];
                    int start = 0;

                    if (m_subranges.Length > jj)
                    {
                        start = m_subranges[jj].m_begin;
                    }

                    if (start + index >= dstArray.GetLength(jj))
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }

                    dstIndexes[jj] = start + index;
                }

                if (finalRange == null)
                {
                    continue;
                }

                // check for subset of string or byte string.
                int last = finalRange.Value.m_begin;

                if (finalRange.Value.m_end > 0)
                {
                    last = finalRange.Value.m_end;
                }

                object element = dstArray.GetValue(dstIndexes);

                // check for subset of string.
                if (dstTypeInfo.BuiltInType == BuiltInType.String)
                {
                    string str = (string)element;

                    if (str == null || last >= str.Length)
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }
                }

                // check for subset of byte string.
                else if (dstTypeInfo.BuiltInType == BuiltInType.ByteString)
                {
                    byte[] str = (byte[])element;

                    if (str == null || last >= str.Length)
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }
                }
            }

            // copy data.
            int[] srcIndexes = new int[dimensions.Length];

            for (int ii = 0; ii < srcCount; ii++)
            {
                // calculate dimensions.
                int divisor = srcCount;

                for (int jj = 0; jj < dimensions.Length; jj++)
                {
                    divisor /= dimensions[jj];
                    int index = (ii / divisor) % dimensions[jj];
                    int start = 0;

                    if (m_subranges.Length > jj)
                    {
                        start = m_subranges[jj].m_begin;
                    }

                    if (start + index >= dstArray.GetLength(jj))
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }

                    srcIndexes[jj] = index;
                    dstIndexes[jj] = start + index;
                }

                // get the element to copy.
                object element1 = srcArray.GetValue(srcIndexes);

                if (finalRange == null)
                {
                    dstArray.SetValue(element1, dstIndexes);
                    continue;
                }

                object element2 = dstArray.GetValue(dstIndexes);

                // update elements within a string.
                if (dstTypeInfo.BuiltInType == BuiltInType.String)
                {
                    string srcString = (string)element1;
                    char[] dstString = ((string)element2).ToCharArray();

                    if (srcString != null)
                    {
                        for (int jj = 0; jj < srcString.Length; jj++)
                        {
                            dstString[finalRange.Value.m_begin + jj] = srcString[jj];
                        }
                    }

                    dstArray.SetValue(new string(dstString), dstIndexes);
                }

                // update elements within a byte string.
                else if (dstTypeInfo.BuiltInType == BuiltInType.ByteString)
                {
                    byte[] srcString = (byte[])element1;
                    byte[] dstString = (byte[])element2;

                    if (srcString != null)
                    {
                        for (int jj = 0; jj < srcString.Length; jj++)
                        {
                            dstString[finalRange.Value.m_begin + jj] = srcString[jj];
                        }
                    }
                }
            }

            if(dst is Matrix)
            {
                // dstArray is a copy of the data of the dst Matrix so create new Matrix with modified data
                dst = new Matrix(dstArray, dstTypeInfo.BuiltInType);
            }

            return StatusCodes.Good;
        }

        /// <summary>
        /// Applys the index range to an array value.
        /// </summary>
        /// <remarks>
        /// Replaces the value
        /// </remarks>
        /// <param name="value">The array to subset.</param>
        /// <returns>The reason for the failure if the range could not be applied.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1007:UseGenericsWhereAppropriate")]
        public StatusCode ApplyRange(ref object value)
        {
            // check for empty range.
            if (this.m_begin == -1 && this.m_end == -1)
            {
                return StatusCodes.Good;
            }

            // nothing to do for null values.
            if (value == null)
            {
                return StatusCodes.Good;
            }

            Array array = value as Array;

            // check for list type.
            IList list = null;
            TypeInfo typeInfo = null;

            if (array == null)
            {
                list = value as IList;

                if (list != null)
                {
                    typeInfo = TypeInfo.Construct(list);
                }
            }

            bool isString = false;

            // check for array.
            if (array == null && list == null)
            {
                // check for string.
                String chars = value as String;

                if (chars != null)
                {
                    isString = true;
                    array = chars.ToCharArray();
                }
            }

            // check for multidimensional arrays.
            if (m_subranges != null)
            {
                return ApplyMultiRange(ref value);
            }

            if(list == null && array == null)
            {
                value = null;
                return StatusCodes.BadIndexRangeNoData;
            }

            // get length.
            int length = 0;

            if (list != null)
            {
                length = list.Count;
            }
            else
            {
                length = array.Length;
            }

            int begin = this.m_begin;

            // choose a default start.
            if (begin == -1)
            {
                begin = 0;
            }

            // return an empty array if begin is beyond the end of the array.
            if (begin >= length)
            {
                value = null;
                return StatusCodes.BadIndexRangeNoData;
            }

            // only copy if actually asking for a subset.
            int end = this.m_end;

            // check if looking for a single element.
            if (end == -1)
            {
                end = begin;
            }

            // ensure end of array is not exceeded.
            else if (end >= length - 1)
            {
                end = length - 1;
            }

            Array clone = null;
            int subLength = end - begin + 1;

            // check for list.
            if (list != null && typeInfo != null)
            {
                clone = TypeInfo.CreateArray(typeInfo.BuiltInType, subLength);

                for (int ii = begin; ii < subLength; ii++)
                {
                    clone.SetValue(list[ii], ii - begin);
                }

                return StatusCodes.Good;
            }

            // handle array or string.
            if (isString)
            {
                clone = new char[subLength];
            }
            else
            {
                clone = Array.CreateInstance(array.GetType().GetElementType(), subLength);
            }

            Array.Copy(array, begin, clone, 0, clone.Length);

            if (isString)
            {
                value = new string((char[])clone);
            }
            else
            {
                value = clone;
            }

            return StatusCodes.Good;
        }

        /// <summary>
        /// Parses a string representing a numeric range.
        /// </summary>
        /// <remarks>
        /// Parses a string representing a numeric range.
        /// </remarks>
        /// <param name="textToParse">The text to parse, prior to checking it is within the allowed range</param>
        /// <exception cref="ServiceResultException">Thrown when the numeric value of the parsed text is out of range</exception>
        public static NumericRange Parse(string textToParse)
        {
            NumericRange range = NumericRange.Empty;

            ServiceResult result = Validate(textToParse, out range);

            if (ServiceResult.IsBad(result))
            {
                throw new ServiceResultException(result);
            }

            return range;
        }
        #endregion

        #region Private Fields
        private int m_begin;
        private int m_end;
        private NumericRange[] m_subranges;
        #endregion

    }//class

}//namespace

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;

namespace Opc.Ua
{
    /// <summary>
    /// A class that stores a numeric range.
    /// </summary>
    /// <remarks>
    /// A class that stores a numeric range.
    /// </remarks>
	public struct NumericRange : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Initializes the object with a begin index.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a begin index.
        /// </remarks>
        /// <param name="begin">The starting point of the range</param>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when the parameter is less than -1</exception>
        public NumericRange(int begin)
        {
            if (begin < -1)
            {
                throw new ArgumentOutOfRangeException(nameof(begin));
            }

            m_begin = -1;
            m_end = -1;
            m_subranges = null;

            Begin = begin;
        }

        /// <summary>
        /// Initializes the object with a begin and end indexes.
        /// </summary>
        /// <remarks>
        /// Initializes the object with a begin and end indexes.
        /// </remarks>
        /// <param name="begin">The end of the range</param>
        /// <param name="end">The beginning of the range</param>
        public NumericRange(int begin, int end)
        {
            m_begin = -1;
            m_end = -1;
            m_subranges = null;

            Begin = begin;
            End = end;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// The begining of the numeric range.
        /// </summary>
        /// <remarks>
        /// The begining of the numeric range.
        /// </remarks>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when the value is less than -1, or when the value is greater than the end</exception>
        public int Begin
        {
            get { return m_begin; }

            set
            {
                if (value < -1)
                {
                    throw new ArgumentOutOfRangeException(nameof(value), "Begin");
                }

                if (m_end != -1 && (m_begin > m_end || m_begin < 0))
                {
                    throw new ArgumentOutOfRangeException(nameof(value), "Begin > End");
                }

                m_begin = value;
            }
        }

        /// <summary>
        /// The end of the numeric range.
        /// </summary>
        /// <remarks>
        /// The end of the numeric range.
        /// </remarks>
        /// <exception cref="ArgumentOutOfRangeException">Thrown when the value is less
        /// than -1 or when the end is less than the beginning</exception>
        public int End
        {
            get { return m_end; }

            set
            {
                if (value < -1)
                {
                    throw new ArgumentOutOfRangeException(nameof(value), "End");
                }

                if (m_end != -1 && (m_begin > m_end || m_begin < 0))
                {
                    throw new ArgumentOutOfRangeException(nameof(value), "Begin > End");
                }

                m_end = value;
            }
        }

        /// <summary>
        /// The number of elements specified by the range.
        /// </summary>
        /// <remarks>
        /// The number of elements specified by the range.
        /// </remarks>
        public int Count
        {
            get
            {
                if (m_begin == -1)
                {
                    return 0;
                }

                if (m_end == -1)
                {
                    return 1;
                }

                return m_end - m_begin + 1;
            }
        }

        /// <summary>
        /// Gets the number of dimensions in the range.
        /// </summary>
        /// <value>The number of dimensions.</value>
        public int Dimensions
        {
            get
            {
                if (m_begin == -1)
                {
                    return 0;
                }

                if (m_subranges == null)
                {
                    return 1;
                }

                return m_subranges.Length;
            }
        }

        /// <summary>
        /// Gets or sets the sub ranges for multidimensional ranges.
        /// </summary>
        /// <value>The sub ranges.</value>
        public NumericRange[] SubRanges
        {
            get
            {
                return m_subranges;
            }

            set
            {
                m_subranges = value;
            }
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Ensures the bounds are valid values for the object passed in.
        /// </summary>
        /// <remarks>
        /// Returns false if the object is not indexable or if the numeric range is out-of-bounds.
        /// </remarks>
        /// <param name="value">The value to check</param>
        public bool EnsureValid(object value)
        {
            int count = -1;

            // check for collections.

            if (value is ICollection collection)
            {
                count = collection.Count;
            }
            else
            {
                // check for arrays.

                if (value is Array array)
                {
                    count = array.Length;
                }
            }

            // ensure bounds are less than count.
            return EnsureValid(count);
        }

        /// <summary>
        /// Ensures the bounds are valid values for a collection with the specified length.
        /// </summary>
        /// <remarks>
        /// Returns false if the numeric range is out-of-bounds.
        /// </remarks>
        /// <param name="count">The value to check is within range</param>
        public bool EnsureValid(int count)
        {
            // object not indexable.
            if (count == -1)
            {
                return false;
            }

            // check bounds.
            if (m_begin > count || m_end >= count)
            {
                return false;
            }

            // set begin.
            if (m_begin < 0)
            {
                m_begin = 0;
            }

            // set end.
            if (m_end < 0)
            {
                m_end = count;
            }

            return true;
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Returns true if the objects are equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are equal.
        /// </remarks>
        /// <param name="obj">The object to test against this</param>
        public override bool Equals(object obj)
        {
            if (Object.ReferenceEquals(this, obj))
            {
                return true;
            }

            NumericRange? range = obj as NumericRange?;

            if (range == null)
            {
                return false;
            }

            return (range.Value.m_begin == m_begin) && (range.Value.m_end == m_end);
        }

        /// <summary>
        /// Returns true if the objects are equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are equal.
        /// </remarks>
        /// <param name="value1">The first value to compare</param>
        /// <param name="value2">The second value to compare</param>
        public static bool operator ==(NumericRange value1, NumericRange value2)
        {
            return value1.Equals(value2);
        }

        /// <summary>
        /// Returns true if the objects are not equal.
        /// </summary>
        /// <remarks>
        /// Returns true if the objects are not equal.
        /// </remarks>
        /// <param name="value1">The first value to compare</param>
        /// <param name="value2">The second value to compare</param>
        public static bool operator !=(NumericRange value1, NumericRange value2)
        {
            return !value1.Equals(value2);
        }

        /// <summary>
        /// Returns a suitable hash code for the object.
        /// </summary>
        /// <remarks>
        /// Returns a suitable hash code for the object.
        /// </remarks>
        public override int GetHashCode()
        {
            return m_begin.GetHashCode() + m_end.GetHashCode();
        }

        /// <summary>
        /// Returns the string representation of the object.
        /// </summary>
        /// <remarks>
        /// Returns the string representation of the object.
        /// </remarks>
        public override string ToString()
        {
            return ToString(null, null);
        }
        #endregion

        #region IFormattable Members
        /// <summary>
        /// Formats the numeric range as a string.
        /// </summary>
        /// <remarks>
        /// Formats the numeric range as a string.
        /// </remarks>
        /// <param name="format">(Unused) Always pass NULL/NOTHING</param>
        /// <param name="formatProvider">(Unused) Always pass NULL/NOTHING</param>
        /// <exception cref="FormatException">Thrown when a non null/nothing is passed for either parameter</exception>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                if (m_end < 0)
                {
                    return String.Format(formatProvider, "{0}", m_begin);
                }

                return String.Format(formatProvider, "{0}:{1}", m_begin, m_end);
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region Static Members
        /// <summary>
        /// An empty numeric range.
        /// </summary>
        /// <remarks>
        /// An empty numeric range.
        /// </remarks>
        public static NumericRange Empty => s_Empty;

        private static readonly NumericRange s_Empty = new NumericRange(-1, -1);

        /// <summary>
        /// Parses a string representing a numeric range.
        /// </summary>
        /// <param name="textToParse">The text to parse, prior to checking it is within the allowed range</param>
        /// <param name="range">The parsed range.</param>
        /// <returns>The reason for any error.</returns>
        public static ServiceResult Validate(string textToParse, out NumericRange range)
        {
            range = NumericRange.Empty;

            if (String.IsNullOrEmpty(textToParse))
            {
                return ServiceResult.Good;
            }

            // check for multidimensional ranges.
            int index = textToParse.IndexOf(',');

            if (index >= 0)
            {
                int start = 0;
                List<NumericRange> subranges = new List<NumericRange>();

                for (int ii = 0; ii < textToParse.Length; ii++)
                {
                    char ch = textToParse[ii];

                    if (ch == ',' || ii == textToParse.Length - 1)
                    {
                        NumericRange subrange = new NumericRange();
                        string subtext = (ch == ',') ? textToParse.Substring(start, ii - start) : textToParse.Substring(start);
                        ServiceResult result = Validate(subtext, out subrange);

                        if (ServiceResult.IsBad(result))
                        {
                            return result;
                        }

                        subranges.Add(subrange);
                        start = ii + 1;
                    }
                }

                // must have at least two entries.
                if (subranges.Count < 2)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                range.m_begin = subranges[0].Begin;
                range.m_end = subranges[0].End;
                range.m_subranges = subranges.ToArray();

                return ServiceResult.Good;
            }

            try
            {
                index = textToParse.IndexOf(':');

                if (index != -1)
                {
                    range.Begin = Convert.ToInt32(textToParse.Substring(0, index), CultureInfo.InvariantCulture);
                    range.End = Convert.ToInt32(textToParse.Substring(index + 1), CultureInfo.InvariantCulture);

                    if (range.End < 0)
                    {
                        return ServiceResult.Create(
                            StatusCodes.BadIndexRangeInvalid,
                            "NumericRange does not have a valid end index ({0}).",
                            range.End);
                    }

                    if (range.Begin >= range.End)
                    {
                        return ServiceResult.Create(
                            StatusCodes.BadIndexRangeInvalid,
                            "NumericRange does not have a start index that is less than the end index ({0}).",
                            range);
                    }
                }
                else
                {
                    range.Begin = Convert.ToInt32(textToParse, CultureInfo.InvariantCulture);
                    range.End = -1;
                }

                if (range.Begin < 0)
                {
                    return ServiceResult.Create(
                        StatusCodes.BadIndexRangeInvalid,
                        "NumericRange does not have a valid start index ({0}).",
                        range.Begin);
                }
            }
            catch (Exception e)
            {
                return ServiceResult.Create(
                    e,
                    StatusCodes.BadIndexRangeInvalid,
                    "NumericRange cannot be parsed ({0}).",
                    textToParse);
            }

            return ServiceResult.Good;
        }

        /// <summary>
        /// Applies the multidimensional index range.
        /// </summary>
        private StatusCode ApplyMultiRange(ref object value)
        {
            Array array = value as Array;
            TypeInfo typeInfo = null;

            // check for matrix.
            if (array == null)
            {
                Matrix matrix = value as Matrix;

                if (matrix == null || matrix.Dimensions.Length != m_subranges.Length)
                {
                    value = null;
                    return StatusCodes.BadIndexRangeNoData;
                }

                array = matrix.ToArray();
            }

            typeInfo = TypeInfo.Construct(array);

            // check for matching dimensions.
            NumericRange? finalRange = null;

            if (m_subranges.Length > typeInfo.ValueRank)
            {
                if (typeInfo.BuiltInType == BuiltInType.ByteString || typeInfo.BuiltInType == BuiltInType.String)
                {
                    if (m_subranges.Length == typeInfo.ValueRank + 1)
                    {
                        finalRange = m_subranges[m_subranges.Length - 1];
                    }
                }

                if (finalRange == null)
                {
                    value = null;
                    return StatusCodes.BadIndexRangeNoData;
                }
            }

            // create the dimensions of the target.
            int[] dimensions = new int[typeInfo.ValueRank];

            for (int ii = 0; ii < dimensions.Length; ii++)
            {
                if (m_subranges.Length > ii)
                {
                    if (m_subranges[ii].m_begin >= array.GetLength(ii))
                    {
                        value = null;
                        return StatusCodes.BadIndexRangeNoData;
                    }

                    dimensions[ii] = m_subranges[ii].Count;
                }
                else
                {
                    dimensions[ii] = array.GetLength(ii);
                }
            }

            Array subset = TypeInfo.CreateArray(typeInfo.BuiltInType, dimensions);

            int length = subset.Length;
            int[] dstIndexes = new int[dimensions.Length];
            int[] srcIndexes = new int[dimensions.Length];

            bool dataFound = false;

            for (int ii = 0; ii < length; ii++)
            {
                int divisor = subset.Length;
                bool outOfRange = false;

                for (int jj = 0; jj < dstIndexes.Length; jj++)
                {
                    divisor /= dimensions[jj];
                    dstIndexes[jj] = (ii / divisor) % dimensions[jj];
                    srcIndexes[jj] = dstIndexes[jj] + m_subranges[jj].m_begin;

                    if (array.GetLength(jj) <= srcIndexes[jj])
                    {
                        outOfRange = true;
                        break;
                    }
                }

                if (outOfRange)
                {
                    continue;
                }

                object element = array.GetValue(srcIndexes);

                if (element != null)
                {
                    if (finalRange != null)
                    {
                        StatusCode result = finalRange.Value.ApplyRange(ref element);

                        if (StatusCode.IsBad(result))
                        {
                            if (result != StatusCodes.BadIndexRangeNoData)
                            {
                                value = null;
                                return result;
                            }

                            continue;
                        }
                    }

                    dataFound = true;
                    subset.SetValue(element, dstIndexes);
                }
            }

            if (!dataFound)
            {
                value = null;
                return StatusCodes.BadIndexRangeNoData;
            }

            value = subset;
            return StatusCodes.Good;
        }

        /// <summary>
        /// Applies the multidimensional index range.
        /// </summary>
        public StatusCode UpdateRange(ref object dst, object src)
        {
            // check for trivial case.
            if (dst == null)
            {
                return StatusCodes.BadIndexRangeNoData;
            }

            TypeInfo dstTypeInfo = TypeInfo.Construct(dst);

            // check for subset of string or byte string.
            if (dstTypeInfo.ValueRank == ValueRanks.Scalar)
            {
                if (this.Dimensions > 1)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                // check for subset of string.
                if (dstTypeInfo.BuiltInType == BuiltInType.String)
                {
                    char[] dstString = ((string)dst).ToCharArray();

                    if (srcString == null || srcString.Length != this.Count)
                    {
                        return StatusCodes.BadIndexRangeInvalid;
                    }

                    if (this.m_begin >= dstString.Length || ((this.m_end > 0 && this.m_end >= dstString.Length)))
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }

                    for (int jj = 0; jj < srcString.Length; jj++)
                    {
                        dstString[this.m_begin + jj] = srcString[jj];
                    }

                    dst = new string(dstString);
                    return StatusCodes.Good;
                }

                // update elements within a byte string.
                else if (dstTypeInfo.BuiltInType == BuiltInType.ByteString)
                {
                    byte[] dstString = (byte[])dst;

                    if (srcString == null || srcString.Length != this.Count)
                    {
                        return StatusCodes.BadIndexRangeInvalid;
                    }

                    if (this.m_begin >= dstString.Length || ((this.m_end > 0 && this.m_end >= dstString.Length)))
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }

                    for (int jj = 0; jj < srcString.Length; jj++)
                    {
                        dstString[this.m_begin + jj] = srcString[jj];
                    }

                    return StatusCodes.Good;
                }

                // index range not supported.
                return StatusCodes.BadIndexRangeInvalid;
            }

            Array srcArray = src as Array;
            Array dstArray = dst as Array;

            // check for destinations specified as a matrix.
            if (dstArray == null)
            {
                Matrix matrix = dst as Matrix;

                if (matrix == null || m_subranges == null || matrix.Dimensions.Length != m_subranges.Length)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                dstArray = matrix.ToArray();
            }

            // check for input specified as a matrix.
            if (srcArray == null)
            {
                Matrix matrix = src as Matrix;

                if (matrix == null || m_subranges == null || matrix.Dimensions.Length != m_subranges.Length)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                srcArray = matrix.ToArray();
            }

            TypeInfo srcTypeInfo = TypeInfo.Construct(srcArray);

            if (srcTypeInfo.BuiltInType != dstTypeInfo.BuiltInType)
            {
                return StatusCodes.BadIndexRangeInvalid;
            }

            if (srcTypeInfo.ValueRank != dstTypeInfo.ValueRank)
            {
                return StatusCodes.BadIndexRangeInvalid;
            }

            // handle one dimension.
            if (m_subranges == null)
            {
                if (dstTypeInfo.ValueRank > 1)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                if (srcArray.Length != this.Count)
                {
                    return StatusCodes.BadIndexRangeInvalid;
                }

                if (this.m_begin >= dstArray.Length || ((this.m_end > 0 && this.m_end >= dstArray.Length)))
                {
                    return StatusCodes.BadIndexRangeNoData;
                }

                for (int jj = 0; jj < srcArray.Length; jj++)
                {
                    dstArray.SetValue(srcArray.GetValue(jj), this.m_begin + jj);
                }

                if (dst is Matrix)
                {
                    // dstArray is a copy of the data of the dst Matrix so create new Matrix with modified data
                    dst = new Matrix(dstArray, dstTypeInfo.BuiltInType);
                }

                return StatusCodes.Good;
            }

            // check for matching dimensions.
            NumericRange? finalRange = null;

            if (m_subranges != null && m_subranges.Length > srcTypeInfo.ValueRank)
            {
                if (srcTypeInfo.BuiltInType == BuiltInType.ByteString || srcTypeInfo.BuiltInType == BuiltInType.String)
                {
                    if (m_subranges.Length == srcTypeInfo.ValueRank + 1)
                    {
                        finalRange = m_subranges[m_subranges.Length - 1];
                    }
                }

                if (finalRange == null)
                {
                    return StatusCodes.BadIndexRangeNoData;
                }
            }

            // get the dimensions of the array being copied.
            int srcCount = 1;
            int[] dimensions = new int[srcTypeInfo.ValueRank];

            for (int ii = 0; ii < dimensions.Length; ii++)
            {
                if (m_subranges.Length < ii)
                {
                    if (m_subranges[ii].Count != srcArray.GetLength(ii))
                    {
                        return StatusCodes.BadIndexRangeInvalid;
                    }
                }

                dimensions[ii] = srcArray.GetLength(ii);
                srcCount *= dimensions[ii];
            }

            // check that the index range falls with the target array.
            int[] dstIndexes = new int[dimensions.Length];

            for (int ii = 0; ii < srcCount; ii++)
            {
                // check target dimensions.
                int divisor = srcCount;

                for (int jj = 0; jj < dimensions.Length; jj++)
                {
                    divisor /= dimensions[jj];
                    int index = (ii / divisor) % dimensions[jj];
                    int start = 0;

                    if (m_subranges.Length > jj)
                    {
                        start = m_subranges[jj].m_begin;
                    }

                    if (start + index >= dstArray.GetLength(jj))
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }

                    dstIndexes[jj] = start + index;
                }

                if (finalRange == null)
                {
                    continue;
                }

                // check for subset of string or byte string.
                int last = finalRange.Value.m_begin;

                if (finalRange.Value.m_end > 0)
                {
                    last = finalRange.Value.m_end;
                }

                object element = dstArray.GetValue(dstIndexes);

                // check for subset of string.
                if (dstTypeInfo.BuiltInType == BuiltInType.String)
                {
                    string str = (string)element;

                    if (str == null || last >= str.Length)
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }
                }

                // check for subset of byte string.
                else if (dstTypeInfo.BuiltInType == BuiltInType.ByteString)
                {
                    byte[] str = (byte[])element;

                    if (str == null || last >= str.Length)
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }
                }
            }

            // copy data.
            int[] srcIndexes = new int[dimensions.Length];

            for (int ii = 0; ii < srcCount; ii++)
            {
                // calculate dimensions.
                int divisor = srcCount;

                for (int jj = 0; jj < dimensions.Length; jj++)
                {
                    divisor /= dimensions[jj];
                    int index = (ii / divisor) % dimensions[jj];
                    int start = 0;

                    if (m_subranges.Length > jj)
                    {
                        start = m_subranges[jj].m_begin;
                    }

                    if (start + index >= dstArray.GetLength(jj))
                    {
                        return StatusCodes.BadIndexRangeNoData;
                    }

                    srcIndexes[jj] = index;
                    dstIndexes[jj] = start + index;
                }

                // get the element to copy.
                object element1 = srcArray.GetValue(srcIndexes);

                if (finalRange == null)
                {
                    dstArray.SetValue(element1, dstIndexes);
                    continue;
                }

                object element2 = dstArray.GetValue(dstIndexes);

                // update elements within a string.
                if (dstTypeInfo.BuiltInType == BuiltInType.String)
                {
                    string srcString = (string)element1;
                    char[] dstString = ((string)element2).ToCharArray();

                    if (src is string srcString)
                    {
                        for (int jj = 0; jj < srcString.Length; jj++)
                        {
                            dstString[finalRange.Value.m_begin + jj] = srcString[jj];
                        }
                    }

                    dstArray.SetValue(new string(dstString), dstIndexes);
                }

                // update elements within a byte string.
                else if (dstTypeInfo.BuiltInType == BuiltInType.ByteString)
                {
                    byte[] srcString = (byte[])element1;
                    byte[] dstString = (byte[])element2;

                    if (src is string srcString)
                    {
                        for (int jj = 0; jj < srcString.Length; jj++)
                        {
                            dstString[finalRange.Value.m_begin + jj] = srcString[jj];
                        }
                    }
                }
            }

            if(dst is Matrix)
            {
                // dstArray is a copy of the data of the dst Matrix so create new Matrix with modified data
                dst = new Matrix(dstArray, dstTypeInfo.BuiltInType);
            }

            return StatusCodes.Good;
        }

        /// <summary>
        /// Applys the index range to an array value.
        /// </summary>
        /// <remarks>
        /// Replaces the value
        /// </remarks>
        /// <param name="value">The array to subset.</param>
        /// <returns>The reason for the failure if the range could not be applied.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1007:UseGenericsWhereAppropriate")]
        public StatusCode ApplyRange(ref object value)
        {
            // check for empty range.
            if (this.m_begin == -1 && this.m_end == -1)
            {
                return StatusCodes.Good;
            }

            // nothing to do for null values.
            if (value == null)
            {
                return StatusCodes.Good;
            }

            Array array = value as Array;

            // check for list type.
            IList list = null;
            TypeInfo typeInfo = null;

            if (array == null)
            {
                list = value as IList;

                if (list != null)
                {
                    typeInfo = TypeInfo.Construct(list);
                }
            }

            bool isString = false;

            // check for array.
            if (array == null && list == null)
            {
                // check for string.

                if (value is String chars)
                {
                    isString = true;
                    array = chars.ToCharArray();
                }
            }

            // check for multidimensional arrays.
            if (m_subranges != null)
            {
                return ApplyMultiRange(ref value);
            }

            if(list == null && array == null)
            {
                value = null;
                return StatusCodes.BadIndexRangeNoData;
            }

            // get length.
            int length = 0;

            if (list != null)
            {
                length = list.Count;
            }
            else
            {
                length = array.Length;
            }

            int begin = this.m_begin;

            // choose a default start.
            if (begin == -1)
            {
                begin = 0;
            }

            // return an empty array if begin is beyond the end of the array.
            if (begin >= length)
            {
                value = null;
                return StatusCodes.BadIndexRangeNoData;
            }

            // only copy if actually asking for a subset.
            int end = this.m_end;

            // check if looking for a single element.
            if (end == -1)
            {
                end = begin;
            }

            // ensure end of array is not exceeded.
            else if (end >= length - 1)
            {
                end = length - 1;
            }

            Array clone = null;
            int subLength = end - begin + 1;

            // check for list.
            if (list != null && typeInfo != null)
            {
                clone = TypeInfo.CreateArray(typeInfo.BuiltInType, subLength);

                for (int ii = begin; ii < subLength; ii++)
                {
                    clone.SetValue(list[ii], ii - begin);
                }

                return StatusCodes.Good;
            }

            // handle array or string.
            if (isString)
            {
                clone = new char[subLength];
            }
            else
            {
                clone = Array.CreateInstance(array.GetType().GetElementType(), subLength);
            }

            Array.Copy(array, begin, clone, 0, clone.Length);

            if (isString)
            {
                value = new string((char[])clone);
            }
            else
            {
                value = clone;
            }

            return StatusCodes.Good;
        }

        /// <summary>
        /// Parses a string representing a numeric range.
        /// </summary>
        /// <remarks>
        /// Parses a string representing a numeric range.
        /// </remarks>
        /// <param name="textToParse">The text to parse, prior to checking it is within the allowed range</param>
        /// <exception cref="ServiceResultException">Thrown when the numeric value of the parsed text is out of range</exception>
        public static NumericRange Parse(string textToParse)
        {
            NumericRange range = NumericRange.Empty;

            ServiceResult result = Validate(textToParse, out range);

            if (ServiceResult.IsBad(result))
            {
                throw new ServiceResultException(result);
            }

            return range;
        }
        #endregion

        #region Private Fields
        private int m_begin;
        private int m_end;
        private NumericRange[] m_subranges;
        #endregion

    }//class

}//namespace

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\NumericRange.cs(634,25): error CS0103: The name 'srcString' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\NumericRange.cs(634,46): error CS0103: The name 'srcString' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\NumericRange.cs(644,43): error CS0103: The name 'srcString' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\NumericRange.cs(646,56): error CS0103: The name 'srcString' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\NumericRange.cs(658,25): error CS0103: The name 'srcString' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\NumericRange.cs(658,46): error CS0103: The name 'srcString' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\NumericRange.cs(668,43): error CS0103: The name 'srcString' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\NumericRange.cs(670,56): error CS0103: The name 'srcString' does not exist in the current context,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\NumericRange.cs(900,39): error CS0128: A local variable or function named 'srcString' is already defined in this scope,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\NumericRange.cs(917,39): error CS0128: A local variable or function named 'srcString' is already defined in this scope
######################################################################


######################################################################
Nr: 27 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\TypeInfo.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Reflection;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// The set of built-in data types for UA type descriptions.
    /// </summary>
    /// <remarks>
    /// An enumeration that lists all of the built-in data types for OPC UA Type Descriptions.
    /// </remarks>
    public enum BuiltInType : int
    {
        /// <summary>
        /// An invalid or unspecified value.
        /// </summary>
        Null = 0,

        /// <summary>
        /// A boolean logic value (true or false).
        /// </summary>
        Boolean = 1,

        /// <summary>
        /// An 8 bit signed integer value.
        /// </summary>
        SByte = 2,

        /// <summary>
        /// An 8 bit unsigned integer value.
        /// </summary>
        Byte = 3,

        /// <summary>
        /// A 16 bit signed integer value.
        /// </summary>
        Int16 = 4,

        /// <summary>
        /// A 16 bit signed integer value.
        /// </summary>
        UInt16 = 5,

        /// <summary>
        /// A 32 bit signed integer value.
        /// </summary>
        Int32 = 6,

        /// <summary>
        /// A 32 bit unsigned integer value.
        /// </summary>
        UInt32 = 7,

        /// <summary>
        /// A 64 bit signed integer value.
        /// </summary>
        Int64 = 8,

        /// <summary>
        /// A 64 bit unsigned integer value.
        /// </summary>
        UInt64 = 9,

        /// <summary>
        /// An IEEE single precision (32 bit) floating point value.
        /// </summary>
        Float = 10,

        /// <summary>
        /// An IEEE double precision (64 bit) floating point value.
        /// </summary>
        Double = 11,

        /// <summary>
        /// A sequence of Unicode characters.
        /// </summary>
        String = 12,

        /// <summary>
        /// An instance in time.
        /// </summary>
        DateTime = 13,

        /// <summary>
        /// A 128-bit globally unique identifier.
        /// </summary>
        Guid = 14,

        /// <summary>
        /// A sequence of bytes.
        /// </summary>
        ByteString = 15,

        /// <summary>
        /// An XML element.
        /// </summary>
        XmlElement = 16,

        /// <summary>
        /// An identifier for a node in the address space of a UA server.
        /// </summary>
        NodeId = 17,

        /// <summary>
        /// A node id that stores the namespace URI instead of the namespace index.
        /// </summary>
        ExpandedNodeId = 18,

        /// <summary>
        /// A structured result code.
        /// </summary>
        StatusCode = 19,

        /// <summary>
        /// A string qualified with a namespace.
        /// </summary>
        QualifiedName = 20,

        /// <summary>
        /// A localized text string with an locale identifier.
        /// </summary>
        LocalizedText = 21,

        /// <summary>
        /// An opaque object with a syntax that may be unknown to the receiver.
        /// </summary>
        ExtensionObject = 22,

        /// <summary>
        /// A data value with an associated quality and timestamp.
        /// </summary>
        DataValue = 23,

        /// <summary>
        /// Any of the other built-in types.
        /// </summary>
        Variant = 24,

        /// <summary>
        /// A diagnostic information associated with a result code.
        /// </summary>
        DiagnosticInfo = 25,

        /// <remarks>
        /// The following BuiltInTypes are for coding convenience
        /// internally used in the .NET Standard library.
        /// The enumerations are not used for encoding/decoding.
        /// </remarks>

        /// <summary>
        /// Any numeric value.
        /// </summary>
        Number = 26,

        /// <summary>
        /// A signed integer.
        /// </summary>
        Integer = 27,

        /// <summary>
        /// An unsigned integer.
        /// </summary>
        UInteger = 28,

        /// <summary>
        /// An enumerated value
        /// </summary>
        Enumeration = 29
    }

    /// <summary>
    /// Stores information about a type.
    /// </summary>
    public class TypeInfo : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Constructs an unknown type.
        /// </summary>
        internal TypeInfo()
        {
            m_builtInType = BuiltInType.Null;
            m_valueRank = ValueRanks.Any;
        }

        /// <summary>
        /// Construct the object with a built-in type and a value rank.
        /// </summary>
        /// <param name="builtInType">Type of the built in.</param>
        /// <param name="valueRank">The value rank.</param>
        public TypeInfo(BuiltInType builtInType, int valueRank)
        {
            m_builtInType = builtInType;
            m_valueRank = valueRank;
        }
        #endregion

        #region Public Members
        /// <summary>
        /// Returns the data type id that describes a value.
        /// </summary>
        /// <param name="value">The value instance to check the data type.</param>
        /// <returns>An data type identifier for a node in a server's address space.</returns>
        public static NodeId GetDataTypeId(object value)
        {
            if (value == null)
            {
                return Opc.Ua.NodeId.Null;
            }

            NodeId dataTypeId = GetDataTypeId(value.GetType());

            if (dataTypeId == Opc.Ua.NodeId.Null)
            {
                Matrix matrix = value as Matrix;

                if (matrix != null)
                {
                    return GetDataTypeId(matrix.TypeInfo);
                }
            }

            return dataTypeId;
        }

        /// <summary>
        /// Returns the data type id that describes a value.
        /// </summary>
        /// <param name="type">The framework type.</param>
        /// <returns>An data type identifier for a node in a server's address space.</returns>
        public static NodeId GetDataTypeId(Type type)
        {
            TypeInfo typeInfo = TypeInfo.Construct(type);

            NodeId dataTypeId = GetDataTypeId(typeInfo);

            if (Opc.Ua.NodeId.IsNull(dataTypeId))
            {
                if (type.GetTypeInfo().IsEnum || (type.IsArray && type.GetElementType().GetTypeInfo().IsEnum))
                {
                    return DataTypes.Enumeration;
                }
            }

            return dataTypeId;
        }

        /// <summary>
        /// Returns the data type id that describes a value.
        /// </summary>
        /// <param name="typeInfo">The type info.</param>
        /// <returns>An data type identifier for a node in a server's address space.</returns>
        public static NodeId GetDataTypeId(TypeInfo typeInfo)
        {
            switch (typeInfo.BuiltInType)
            {
                case BuiltInType.Boolean: { return DataTypeIds.Boolean; }
                case BuiltInType.SByte: { return DataTypeIds.SByte; }
                case BuiltInType.Byte: { return DataTypeIds.Byte; }
                case BuiltInType.Int16: { return DataTypeIds.Int16; }
                case BuiltInType.UInt16: { return DataTypeIds.UInt16; }
                case BuiltInType.Int32: { return DataTypeIds.Int32; }
                case BuiltInType.UInt32: { return DataTypeIds.UInt32; }
                case BuiltInType.Int64: { return DataTypeIds.Int64; }
                case BuiltInType.UInt64: { return DataTypeIds.UInt64; }
                case BuiltInType.Float: { return DataTypeIds.Float; }
                case BuiltInType.Double: { return DataTypeIds.Double; }
                case BuiltInType.String: { return DataTypeIds.String; }
                case BuiltInType.DateTime: { return DataTypeIds.DateTime; }
                case BuiltInType.Guid: { return DataTypeIds.Guid; }
                case BuiltInType.ByteString: { return DataTypeIds.ByteString; }
                case BuiltInType.XmlElement: { return DataTypeIds.XmlElement; }
                case BuiltInType.NodeId: { return DataTypeIds.NodeId; }
                case BuiltInType.ExpandedNodeId: { return DataTypeIds.ExpandedNodeId; }
                case BuiltInType.StatusCode: { return DataTypeIds.StatusCode; }
                case BuiltInType.DiagnosticInfo: { return DataTypeIds.DiagnosticInfo; }
                case BuiltInType.QualifiedName: { return DataTypeIds.QualifiedName; }
                case BuiltInType.LocalizedText: { return DataTypeIds.LocalizedText; }
                case BuiltInType.ExtensionObject: { return DataTypeIds.Structure; }
                case BuiltInType.DataValue: { return DataTypeIds.DataValue; }
                case BuiltInType.Variant: { return DataTypeIds.BaseDataType; }
                case BuiltInType.Number: { return DataTypeIds.Number; }
                case BuiltInType.Integer: { return DataTypeIds.Integer; }
                case BuiltInType.UInteger: { return DataTypeIds.UInteger; }
                case BuiltInType.Enumeration: { return DataTypeIds.Enumeration; }
            }

            return Opc.Ua.NodeId.Null;
        }

        /// <summary>
        /// Returns the array rank for a value.
        /// </summary>
        /// <param name="value">The value instance to check the array rank.</param>
        /// <returns>The array rank of the <paramref name="value"/></returns>
        public static int GetValueRank(object value)
        {
            if (value == null)
            {
                return ValueRanks.Any;
            }

            TypeInfo typeInfo = TypeInfo.Construct(value);

            if (typeInfo.BuiltInType == BuiltInType.Null)
            {
                Matrix matrix = value as Matrix;

                if (matrix != null)
                {
                    return matrix.TypeInfo.ValueRank;
                }
            }

            return typeInfo.ValueRank;
        }

        /// <summary>
        /// Returns the array rank for a type.
        /// </summary>
        /// <param name="type">The framework type to check the array rank.</param>
        /// <returns>The array rank of the <paramref name="type"/> </returns>
        public static int GetValueRank(Type type)
        {
            TypeInfo typeInfo = TypeInfo.Construct(type);

            if (typeInfo.BuiltInType == BuiltInType.Null)
            {
                if (type.GetTypeInfo().IsEnum || (type.IsArray && type.GetElementType().GetTypeInfo().IsEnum))
                {
                    if (type.IsArray)
                    {
                        return ValueRanks.OneOrMoreDimensions;
                    }
                    else
                    {
                        return ValueRanks.Scalar;
                    }
                }
            }

            return typeInfo.ValueRank;
        }

        /// <summary>
        /// Returns the BuiltInType type for the DataTypeId.
        /// </summary>
        /// <param name="datatypeId">The data type identifier.</param>
        /// <returns>An <see cref="BuiltInType"/> for  <paramref name="datatypeId"/></returns>
        public static BuiltInType GetBuiltInType(NodeId datatypeId)
        {
            if (datatypeId == null || datatypeId.NamespaceIndex != 0 || datatypeId.IdType != Opc.Ua.IdType.Numeric)
            {
                return BuiltInType.Null;
            }

            return (BuiltInType)Enum.ToObject(typeof(BuiltInType), datatypeId.Identifier);
        }

        /// <summary>
        /// Returns true if the built-in type is a numeric type.
        /// </summary>
        /// <param name="builtInType">The built-in type to check.</param>
        /// <returns>
        /// True if the built-in type is a numeric type.
        /// </returns>
        public static bool IsNumericType(BuiltInType builtInType)
        {
            if (builtInType >= BuiltInType.SByte && builtInType <= BuiltInType.Double)
            {
                return true;
            }

            if (builtInType >= BuiltInType.Number && builtInType <= BuiltInType.UInteger)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Returns true if the built-in type is a type that cannot be null.
        /// </summary>
        /// <param name="builtInType">The built in type to check.</param>
        /// <returns>
        /// True if the built-in type is a type that cannot be null.
        /// </returns>
        public static bool IsValueType(BuiltInType builtInType)
        {
            if (builtInType >= BuiltInType.Boolean && builtInType <= BuiltInType.Double)
            {
                return true;
            }

            if (builtInType == BuiltInType.DateTime || builtInType == BuiltInType.Guid || builtInType == BuiltInType.StatusCode)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Returns true if a 'null' value exists for the built-in type
        /// in all data encodings.
        /// </summary>
        /// <param name="builtInType">The built in type to check.</param>
        /// <returns>
        /// True if the built-in type is a type that is nullable.
        /// </returns>
        public static bool IsEncodingNullableType(BuiltInType builtInType)
        {
            if (builtInType >= BuiltInType.Boolean && builtInType <= BuiltInType.Double)
            {
                return false;
            }

            if (builtInType == BuiltInType.DataValue || builtInType == BuiltInType.DiagnosticInfo)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Returns the BuiltInType type for the DataTypeId.
        /// </summary>
        /// <param name="datatypeId">The data type identyfier for a node in a server's address space..</param>
        /// <param name="typeTree">The type tree for a server. .</param>
        /// <returns>
        /// A <see cref="BuiltInType"/> value for <paramref name="datatypeId"/>
        /// </returns>
        public static BuiltInType GetBuiltInType(NodeId datatypeId, ITypeTable typeTree)
        {
            NodeId typeId = datatypeId;

            while (!Opc.Ua.NodeId.IsNull(typeId))
            {
                if (typeId != null && typeId.NamespaceIndex == 0 && typeId.IdType == Opc.Ua.IdType.Numeric)
                {
                    BuiltInType id = (BuiltInType)(int)(uint)typeId.Identifier;

                    if (id > BuiltInType.Null && id <= BuiltInType.Enumeration && id != BuiltInType.DiagnosticInfo)
                    {
                        return id;
                    }
                }

                if (typeTree == null)
                {
                    break;
                }

                typeId = typeTree.FindSuperType(typeId);
            }

            return BuiltInType.Null;
        }

        /// <summary>
        /// Returns the system type for the datatype.
        /// </summary>
        /// <param name="datatypeId">The datatype id.</param>
        /// <param name="factory">The factory used to store and retrieve underlying OPC UA system types.</param>
        /// <returns>The system type for the <paramref name="datatypeId"/>.</returns>
        public static Type GetSystemType(NodeId datatypeId, EncodeableFactory factory)
        {
            if (datatypeId == null)
            {
                return null;
            }

            if (datatypeId.NamespaceIndex != 0 || datatypeId.IdType != Opc.Ua.IdType.Numeric)
            {
                return factory.GetSystemType(datatypeId);
            }

            switch ((uint)datatypeId.Identifier)
            {
                case DataTypes.Boolean: { return typeof(Boolean); }
                case DataTypes.SByte: { return typeof(SByte); }
                case DataTypes.Byte: { return typeof(Byte); }
                case DataTypes.Int16: { return typeof(Int16); }
                case DataTypes.UInt16: { return typeof(UInt16); }
                case DataTypes.Int32: { return typeof(Int32); }
                case DataTypes.UInt32: { return typeof(UInt32); }
                case DataTypes.Int64: { return typeof(Int64); }
                case DataTypes.UInt64: { return typeof(UInt64); }
                case DataTypes.Float: { return typeof(Single); }
                case DataTypes.Double: { return typeof(Double); }
                case DataTypes.String: { return typeof(String); }
                case DataTypes.DateTime: { return typeof(DateTime); }
                case DataTypes.Guid: { return typeof(Uuid); }
                case DataTypes.ByteString: { return typeof(Byte[]); }
                case DataTypes.XmlElement: { return typeof(XmlElement); }
                case DataTypes.NodeId: { return typeof(NodeId); }
                case DataTypes.ExpandedNodeId: { return typeof(ExpandedNodeId); }
                case DataTypes.StatusCode: { return typeof(StatusCode); }
                case DataTypes.DiagnosticInfo: { return typeof(DiagnosticInfo); }
                case DataTypes.QualifiedName: { return typeof(QualifiedName); }
                case DataTypes.LocalizedText: { return typeof(LocalizedText); }
                case DataTypes.DataValue: { return typeof(DataValue); }
                case DataTypes.BaseDataType: { return typeof(Variant); }
                case DataTypes.Structure: { return typeof(ExtensionObject); }
                case DataTypes.Number: { return typeof(Variant); }
                case DataTypes.Integer: { return typeof(Variant); }
                case DataTypes.UInteger: { return typeof(Variant); }
                case DataTypes.Enumeration: { return typeof(Int32); }

                // subtype of DateTime
                case DataTypes.Date: 
                case DataTypes.UtcTime: goto case DataTypes.DateTime;
                // subtype of ByteString
                case DataTypes.ApplicationInstanceCertificate:
                case DataTypes.AudioDataType:
                case DataTypes.ContinuationPoint:
                case DataTypes.Image:
                case DataTypes.ImageBMP:
                case DataTypes.ImageGIF:
                case DataTypes.ImageJPG:
                case DataTypes.ImagePNG: goto case DataTypes.ByteString;
                // subtype of NodeId
                case DataTypes.SessionAuthenticationToken: goto case DataTypes.NodeId;
                // subtype of Double
                case DataTypes.Duration: goto case DataTypes.Double;
                // subtype of UInt32
                case DataTypes.IntegerId:
                case DataTypes.Index:
                case DataTypes.VersionTime:
                case DataTypes.Counter: goto case DataTypes.UInt32;
                // subtype of UInt64
                case DataTypes.BitFieldMaskDataType: goto case DataTypes.UInt64;
                // subtype of String
                case DataTypes.DateString:
                case DataTypes.DecimalString:
                case DataTypes.DurationString:
                case DataTypes.LocaleId:
                case DataTypes.NormalizedString:
                case DataTypes.NumericRange:
                case DataTypes.Time:
                case DataTypes.TimeString: goto case DataTypes.String;
            }

            return factory.GetSystemType(datatypeId);
        }

        /// <summary>
        /// A constant representing an unknown type.
        /// </summary>
        /// <value>The constant representing an unknown type.</value>
        public static TypeInfo Unknown => s_Unknown;

        /// <summary>
        /// The built-in type.
        /// </summary>
        /// <value>The type of the type represented by this instance.</value>
        public BuiltInType BuiltInType => m_builtInType;

        /// <summary>
        /// The value rank.
        /// </summary>
        /// <value>The value rank of the type represented by this instance.</value>
        public int ValueRank => m_valueRank;

        /// <summary>
        /// Returns the type info if the value is an instance of the data type with the specified value rank.
        /// </summary>
        /// <param name="value">The value instance to check.</param>
        /// <param name="expectedDataTypeId">The expected data type identifier for a node.</param>
        /// <param name="expectedValueRank">The expected value rank.</param>
        /// <param name="namespaceUris">The namespace URI's.</param>
        /// <param name="typeTree">The type tree for a server.</param>
        /// <returns>
        /// An data type info if the value is an instance of the data type with the specified value rank; otherwise <c>null</c>.
        /// </returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public static TypeInfo IsInstanceOfDataType(
            object value,
            NodeId expectedDataTypeId,
            int expectedValueRank,
            NamespaceTable namespaceUris,
            ITypeTable typeTree)
        {
            BuiltInType expectedType = BuiltInType.Null;

            // get the type info.
            TypeInfo typeInfo = Construct(value);

            if (typeInfo.BuiltInType == BuiltInType.Null)
            {
                expectedType = TypeInfo.GetBuiltInType(expectedDataTypeId, typeTree);

                // nulls allowed for all array types.
                if (expectedValueRank != ValueRanks.Scalar)
                {
                    return new TypeInfo(expectedType, ValueRanks.OneDimension);
                }

                // check if the type supports nulls.
                switch (expectedType)
                {
                    case BuiltInType.String:
                    case BuiltInType.ByteString:
                    case BuiltInType.XmlElement:
                    case BuiltInType.NodeId:
                    case BuiltInType.ExpandedNodeId:
                    case BuiltInType.LocalizedText:
                    case BuiltInType.QualifiedName:
                    case BuiltInType.DataValue:
                    case BuiltInType.Variant:
                    case BuiltInType.ExtensionObject:
                    {
                        return new TypeInfo(expectedType, ValueRanks.Scalar);
                    }
                }

                // nulls not allowed.
                return null;
            }

            // A ByteString is equivalent to an Array of Bytes.
            if (typeInfo.BuiltInType == BuiltInType.ByteString && typeInfo.ValueRank == ValueRanks.Scalar)
            {
                if (expectedValueRank == ValueRanks.OneOrMoreDimensions || expectedValueRank == ValueRanks.OneDimension)
                {
                    if (typeTree.IsTypeOf(expectedDataTypeId, DataTypes.Byte))
                    {
                        return typeInfo;
                    }

                    return null;
                }
            }

            // check the value rank.
            if (!ValueRanks.IsValid(typeInfo.ValueRank, expectedValueRank))
            {
                return null;
            }

            // check for special predefined types.
            if (expectedDataTypeId.IdType == IdType.Numeric && expectedDataTypeId.NamespaceIndex == 0)
            {
                BuiltInType actualType = typeInfo.BuiltInType;

                switch ((uint)expectedDataTypeId.Identifier)
                {
                    case DataTypes.Number:
                    {
                        switch (actualType)
                        {
                            case BuiltInType.SByte:
                            case BuiltInType.Int16:
                            case BuiltInType.Int32:
                            case BuiltInType.Int64:
                            case BuiltInType.Byte:
                            case BuiltInType.UInt16:
                            case BuiltInType.UInt32:
                            case BuiltInType.UInt64:
                            case BuiltInType.Double:
                            case BuiltInType.Float:
                            {
                                return typeInfo;
                            }

                            case BuiltInType.Variant:
                            {
                                if (typeInfo.ValueRank == ValueRanks.Scalar)
                                {
                                    return null;
                                }

                                break;
                            }

                            default:
                            {
                                return null;
                            }
                        }

                        break;
                    }

                    case DataTypes.Integer:
                    {
                        switch (actualType)
                        {
                            case BuiltInType.SByte:
                            case BuiltInType.Int16:
                            case BuiltInType.Int32:
                            case BuiltInType.Int64:
                            {
                                return typeInfo;
                            }

                            case BuiltInType.Variant:
                            {
                                if (typeInfo.ValueRank == ValueRanks.Scalar)
                                {
                                    return null;
                                }

                                break;
                            }

                            default:
                            {
                                return null;
                            }
                        }

                        break;
                    }

                    case DataTypes.UInteger:
                    {
                        switch (actualType)
                        {
                            case BuiltInType.Byte:
                            case BuiltInType.UInt16:
                            case BuiltInType.UInt32:
                            case BuiltInType.UInt64:
                            {
                                return typeInfo;
                            }

                            case BuiltInType.Variant:
                            {
                                if (typeInfo.ValueRank == ValueRanks.Scalar)
                                {
                                    return null;
                                }

                                break;
                            }

                            default:
                            {
                                return null;
                            }
                        }

                        break;
                    }

                    case DataTypes.Enumeration:
                    {
                        if (typeInfo.BuiltInType == BuiltInType.Int32)
                        {
                            return typeInfo;
                        }

                        return null;
                    }

                    case DataTypes.Structure:
                    {
                        if (typeInfo.BuiltInType == BuiltInType.ExtensionObject)
                        {
                            return typeInfo;
                        }

                        return null;
                    }

                    case DataTypes.BaseDataType:
                    {
                        if (typeInfo.BuiltInType != BuiltInType.Variant)
                        {
                            return typeInfo;
                        }

                        break;
                    }
                }
            }

            // check simple types.
            if (typeInfo.BuiltInType != BuiltInType.ExtensionObject && typeInfo.BuiltInType != BuiltInType.Variant)
            {
                if (typeTree.IsTypeOf(expectedDataTypeId, new NodeId((uint)(int)typeInfo.BuiltInType)))
                {
                    return typeInfo;
                }

                // check for enumerations.
                if (typeInfo.BuiltInType == BuiltInType.Int32)
                {
                    if (typeTree.IsTypeOf(expectedDataTypeId, DataTypes.Enumeration))
                    {
                        return typeInfo;
                    }
                }

                // check for direct subtypes of BaseDataType.
                if (GetBuiltInType(expectedDataTypeId, typeTree) == BuiltInType.Variant)
                {
                    return typeInfo;
                }

                return null;
            }


            // handle scalar.
            if (typeInfo.ValueRank < 0)
            {
                // check extension objects vs. expected type.
                if (typeInfo.BuiltInType == BuiltInType.ExtensionObject)
                {
                    expectedType = GetBuiltInType(expectedDataTypeId, typeTree);

                    if (expectedType == BuiltInType.Variant)
                    {
                        return typeInfo;
                    }

                    if (expectedType != BuiltInType.ExtensionObject)
                    {
                        return null;
                    }
                }

                // expected type is extension object so compare type tree.
                NodeId actualDataTypeId = typeInfo.GetDataTypeId(value, namespaceUris, typeTree);

                if (typeTree.IsTypeOf(actualDataTypeId, expectedDataTypeId))
                {
                    return typeInfo;
                }

                return null;
            }

            // check every element in the array or matrix.     
            Array array = value as Array;
            if (array == null)
            {
                Matrix matrix = value as Matrix;
                if (matrix != null)
                {
                    array = matrix.Elements;
                }
            }

            if (array != null)
            {
                BuiltInType expectedElementType = TypeInfo.GetBuiltInType(expectedDataTypeId, typeTree);
                BuiltInType actualElementType = GetBuiltInType(array.GetType().GetElementType().Name);
                // system type of array matches the expected type - nothing more to do.
                if (actualElementType != BuiltInType.ExtensionObject && actualElementType == expectedElementType)
                {
                    return typeInfo;
                }

                // check for variant arrays.
                if (expectedElementType == BuiltInType.Variant)
                {
                    return typeInfo;
                }

                // have to do it the hard way and check each element.
                int[] dimensions = new int[array.Rank];

                for (int ii = 0; ii < dimensions.Length; ii++)
                {
                    dimensions[ii] = array.GetLength(ii);
                }

                int[] indexes = new int[dimensions.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    int divisor = array.Length;

                    for (int jj = 0; jj < indexes.Length; jj++)
                    {
                        divisor /= dimensions[jj];
                        indexes[jj] = (ii / divisor) % dimensions[jj];
                    }

                    object element = array.GetValue(indexes);

                    if (actualElementType == BuiltInType.Variant)
                    {
                        element = ((Variant)element).Value;
                    }

                    TypeInfo elementInfo = TypeInfo.IsInstanceOfDataType(
                        element,
                        expectedDataTypeId,
                        ValueRanks.Scalar,
                        namespaceUris,
                        typeTree);

                    // give up at the first invalid element.
                    if (elementInfo == null)
                    {
                        return null;
                    }
                }

                // all elements valid.
                return typeInfo;
            }

            return null;
        }

        /// <summary>
        /// Returns the data type id that describes a value.
        /// </summary>
        /// <param name="value">The value to describe.</param>
        /// <param name="namespaceUris">The namespace uris.</param>
        /// <param name="typeTree">The type tree for a server.</param>
        /// <returns>Returns the data type identifier that describes a value.</returns>
        public NodeId GetDataTypeId(object value, NamespaceTable namespaceUris, ITypeTable typeTree)
        {
            if (BuiltInType == BuiltInType.Null)
            {
                return NodeId.Null;
            }

            if (BuiltInType == BuiltInType.ExtensionObject)
            {
                IEncodeable encodeable = value as IEncodeable;
                if (encodeable != null)
                {
                    return ExpandedNodeId.ToNodeId(encodeable.TypeId, namespaceUris);
                }

                ExtensionObject extension = value as ExtensionObject;
                if (extension != null)
                {
                    encodeable = extension.Body as IEncodeable;
                    if (encodeable != null)
                    {
                        return ExpandedNodeId.ToNodeId(encodeable.TypeId, namespaceUris);
                    }

                    return typeTree.FindDataTypeId(extension.TypeId);
                }

                return DataTypes.Structure;
            }

            return new NodeId((uint)(int)BuiltInType);
        }

        /// <summary>
        /// Returns the system type a scalar or array instance of the built-in type.
        /// </summary>
        /// <param name="builtInType">A built-in type.</param>
        /// <param name="valueRank">The value rank.</param>
        /// <returns>A system type equivalent to the built-in type.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public static Type GetSystemType(BuiltInType builtInType, int valueRank)
        {
            if (valueRank == ValueRanks.Scalar)
            {
                switch (builtInType)
                {
                    case BuiltInType.Boolean: return typeof(bool);
                    case BuiltInType.SByte: return typeof(sbyte);
                    case BuiltInType.Byte: return typeof(byte);
                    case BuiltInType.Int16: return typeof(short);
                    case BuiltInType.UInt16: return typeof(ushort);
                    case BuiltInType.Int32: return typeof(int);
                    case BuiltInType.UInt32: return typeof(uint);
                    case BuiltInType.Int64: return typeof(long);
                    case BuiltInType.UInt64: return typeof(ulong);
                    case BuiltInType.Float: return typeof(float);
                    case BuiltInType.Double: return typeof(double);
                    case BuiltInType.String: return typeof(string);
                    case BuiltInType.DateTime: return typeof(DateTime);
                    case BuiltInType.Guid: return typeof(Uuid);
                    case BuiltInType.ByteString: return typeof(byte[]);
                    case BuiltInType.XmlElement: return typeof(XmlElement);
                    case BuiltInType.NodeId: return typeof(NodeId);
                    case BuiltInType.ExpandedNodeId: return typeof(ExpandedNodeId);
                    case BuiltInType.LocalizedText: return typeof(LocalizedText);
                    case BuiltInType.QualifiedName: return typeof(QualifiedName);
                    case BuiltInType.StatusCode: return typeof(StatusCode);
                    case BuiltInType.DiagnosticInfo: return typeof(DiagnosticInfo);
                    case BuiltInType.DataValue: return typeof(DataValue);
                    case BuiltInType.Variant: return typeof(Variant);
                    case BuiltInType.ExtensionObject: return typeof(ExtensionObject);
                    case BuiltInType.Enumeration: return typeof(int);
                    case BuiltInType.Number: return typeof(Variant);
                    case BuiltInType.Integer: return typeof(Variant);
                    case BuiltInType.UInteger: return typeof(Variant);
                }
            }

            else if (valueRank == ValueRanks.OneDimension)
            {
                switch (builtInType)
                {
                    case BuiltInType.Boolean: return typeof(bool[]);
                    case BuiltInType.SByte: return typeof(sbyte[]);
                    case BuiltInType.Byte: return typeof(byte[]);
                    case BuiltInType.Int16: return typeof(short[]);
                    case BuiltInType.UInt16: return typeof(ushort[]);
                    case BuiltInType.Int32: return typeof(int[]);
                    case BuiltInType.UInt32: return typeof(uint[]);
                    case BuiltInType.Int64: return typeof(long[]);
                    case BuiltInType.UInt64: return typeof(ulong[]);
                    case BuiltInType.Float: return typeof(float[]);
                    case BuiltInType.Double: return typeof(double[]);
                    case BuiltInType.String: return typeof(string[]);
                    case BuiltInType.DateTime: return typeof(DateTime[]);
                    case BuiltInType.Guid: return typeof(Uuid[]);
                    case BuiltInType.ByteString: return typeof(byte[][]);
                    case BuiltInType.XmlElement: return typeof(XmlElement[]);
                    case BuiltInType.NodeId: return typeof(NodeId[]);
                    case BuiltInType.ExpandedNodeId: return typeof(ExpandedNodeId[]);
                    case BuiltInType.LocalizedText: return typeof(LocalizedText[]);
                    case BuiltInType.QualifiedName: return typeof(QualifiedName[]);
                    case BuiltInType.StatusCode: return typeof(StatusCode[]);
                    case BuiltInType.DiagnosticInfo: return typeof(DiagnosticInfo[]);
                    case BuiltInType.DataValue: return typeof(DataValue[]);
                    case BuiltInType.Variant: return typeof(Variant[]);
                    case BuiltInType.ExtensionObject: return typeof(ExtensionObject[]);
                    case BuiltInType.Enumeration: return typeof(int[]);
                    case BuiltInType.Number: return typeof(Variant[]);
                    case BuiltInType.Integer: return typeof(Variant[]);
                    case BuiltInType.UInteger: return typeof(Variant[]);
                }
            }

            else if (valueRank == ValueRanks.TwoDimensions)
            {
                switch (builtInType)
                {
                    case BuiltInType.Boolean: return typeof(bool[,]);
                    case BuiltInType.SByte: return typeof(sbyte[,]);
                    case BuiltInType.Byte: return typeof(byte[,]);
                    case BuiltInType.Int16: return typeof(short[,]);
                    case BuiltInType.UInt16: return typeof(ushort[,]);
                    case BuiltInType.Int32: return typeof(int[,]);
                    case BuiltInType.UInt32: return typeof(uint[,]);
                    case BuiltInType.Int64: return typeof(long[,]);
                    case BuiltInType.UInt64: return typeof(ulong[,]);
                    case BuiltInType.Float: return typeof(float[,]);
                    case BuiltInType.Double: return typeof(double[,]);
                    case BuiltInType.String: return typeof(string[,]);
                    case BuiltInType.DateTime: return typeof(DateTime[,]);
                    case BuiltInType.Guid: return typeof(Uuid[,]);
                    case BuiltInType.ByteString: return typeof(byte[,][]);
                    case BuiltInType.XmlElement: return typeof(XmlElement[,]);
                    case BuiltInType.NodeId: return typeof(NodeId[,]);
                    case BuiltInType.ExpandedNodeId: return typeof(ExpandedNodeId[,]);
                    case BuiltInType.LocalizedText: return typeof(LocalizedText[,]);
                    case BuiltInType.QualifiedName: return typeof(QualifiedName[,]);
                    case BuiltInType.StatusCode: return typeof(StatusCode[,]);
                    case BuiltInType.DiagnosticInfo: return typeof(DiagnosticInfo[,]);
                    case BuiltInType.DataValue: return typeof(DataValue[,]);
                    case BuiltInType.Variant: return typeof(Variant[,]);
                    case BuiltInType.ExtensionObject: return typeof(ExtensionObject[,]);
                    case BuiltInType.Enumeration: return typeof(int[,]);
                    case BuiltInType.Number: return typeof(Variant[,]);
                    case BuiltInType.Integer: return typeof(Variant[,]);
                    case BuiltInType.UInteger: return typeof(Variant[,]);
                }
            }

            return typeof(Variant);
        }

        /// <summary>
        /// Returns the type info for the provided value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns><see cref="TypeInfo"/> instance storing information about the <paramref name="value"/> type.</returns>
        public static TypeInfo Construct(object value)
        {
            if (value == null)
            {
                return TypeInfo.Unknown;
            }

            TypeInfo typeInfo = Construct(value.GetType());

            // check for instances of matrixes.
            if (typeInfo.BuiltInType == BuiltInType.Null)
            {
                Matrix matrix = value as Matrix;

                if (matrix != null)
                {
                    return matrix.TypeInfo;
                }
            }

            return typeInfo;
        }

        /// <summary>
        /// Returns the type info for the specified system type.
        /// </summary>
        /// <param name="systemType">The specified system (framework) type.</param>
        /// <returns><see cref="TypeInfo"/> instance storing information equivalent to the <paramref name="systemType"/> type.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public static TypeInfo Construct(Type systemType)
        {
            // check for null.
            if (systemType == null)
            {
                return TypeInfo.Unknown;
            }

            // using strings in switch statements is much faster than the typeof() operator.
            string name = systemType.Name;

            // parse array types.
            string dimensions = null;

            if (name[name.Length - 1] == ']')
            {
                int index = name.IndexOf('[');

                if (index != -1)
                {
                    dimensions = name.Substring(index);
                    name = name.Substring(0, index);
                }
            }

            // handle scalar.
            if (dimensions == null)
            {
                BuiltInType builtInType = GetBuiltInType(name);

                if (builtInType != BuiltInType.Null)
                {
                    return new TypeInfo(builtInType, ValueRanks.Scalar);
                }

                if (systemType.GetTypeInfo().IsEnum)
                {
                    return new TypeInfo(BuiltInType.Enumeration, ValueRanks.Scalar);
                }

                // check for collection.
                if (name.EndsWith("Collection", StringComparison.Ordinal))
                {
                    builtInType = GetBuiltInType(name.Substring(0, name.Length - "Collection".Length));

                    if (builtInType != BuiltInType.Null)
                    {
                        return new TypeInfo(builtInType, ValueRanks.OneDimension);
                    }

                    // check for encodeable object.
                    if (systemType.GetTypeInfo().BaseType.GetTypeInfo().IsGenericType)
                    {
                        return Construct(systemType.GetTypeInfo().BaseType);
                    }

                    return TypeInfo.Unknown;
                }

                // check for generic type.                
                if (systemType.GetTypeInfo().IsGenericType)
                {
                    Type[] argTypes = systemType.GetGenericArguments();

                    if (argTypes != null && argTypes.Length == 1)
                    {
                        TypeInfo typeInfo = Construct(argTypes[0]);

                        if (typeInfo.BuiltInType != BuiltInType.Null && typeInfo.ValueRank == ValueRanks.Scalar)
                        {
                            return new TypeInfo(typeInfo.BuiltInType, ValueRanks.OneDimension);
                        }
                    }

                    return TypeInfo.Unknown;
                }

                // check for encodeable object.
                if (typeof(IEncodeable).GetTypeInfo().IsAssignableFrom(systemType.GetTypeInfo()) || name == "IEncodeable")
                {
                    return new TypeInfo(BuiltInType.ExtensionObject, ValueRanks.Scalar);
                }

                return TypeInfo.Unknown;
            }

            // handle one dimensional array.
            if (dimensions.Length == 2)
            {
                BuiltInType builtInType = GetBuiltInType(name);

                if (builtInType == BuiltInType.Byte)
                {
                    return new TypeInfo(BuiltInType.ByteString, ValueRanks.Scalar);
                }

                if (builtInType != BuiltInType.Null)
                {
                    return new TypeInfo(builtInType, ValueRanks.OneDimension);
                }

                // check for encodeable object.
                if (typeof(IEncodeable).GetTypeInfo().IsAssignableFrom(systemType.GetElementType().GetTypeInfo()) || name == "IEncodeable")
                {
                    return new TypeInfo(BuiltInType.ExtensionObject, ValueRanks.OneDimension);
                }

                if (systemType.GetTypeInfo().GetElementType().IsEnum)
                {
                    return new TypeInfo(BuiltInType.Enumeration, ValueRanks.OneDimension);
                }

                return TypeInfo.Unknown;
            }

            // count the number of dimensions (syntax is [,] - commas+1 is the number of dimensions).
            int count = 1;

            for (int ii = 1; ii < dimensions.Length - 1; ii++)
            {
                if (dimensions[ii] == ',')
                {
                    count++;
                }
            }

            // handle simple multi-dimensional array (enclosing [] + number of commas)
            if (count + 1 == dimensions.Length)
            {
                BuiltInType builtInType = GetBuiltInType(name);

                if (builtInType != BuiltInType.Null)
                {
                    return new TypeInfo(builtInType, count);
                }

                // check for encodeable object.
                if (typeof(IEncodeable).GetTypeInfo().IsAssignableFrom(systemType.GetTypeInfo()) || name == "IEncodeable")
                {
                    return new TypeInfo(BuiltInType.ExtensionObject, count);
                }

                return TypeInfo.Unknown;
            }

            // handle multi-dimensional array of byte strings.
            if (dimensions[1] == ']')
            {
                // syntax of type is [][,,,] - adding three checks for the middle ']['
                if (name == "Byte" && count + 3 == dimensions.Length)
                {
                    return new TypeInfo(BuiltInType.ByteString, count);
                }
            }

            // unknown type.   
            return TypeInfo.Unknown;
        }

        /// <summary>
        /// Returns the default value for the specified built-in type.
        /// </summary>
        /// <param name="type">The Built-in type.</param>
        /// <returns>The default value.</returns>
        public static object GetDefaultValue(BuiltInType type)
        {
            switch (type)
            {
                case BuiltInType.Boolean: { return false; }
                case BuiltInType.SByte: { return (sbyte)0; }
                case BuiltInType.Byte: { return (byte)0; }
                case BuiltInType.Int16: { return (short)0; }
                case BuiltInType.UInt16: { return (ushort)0; }
                case BuiltInType.Int32: { return (int)0; }
                case BuiltInType.UInt32: { return (uint)0; }
                case BuiltInType.Int64: { return (long)0; }
                case BuiltInType.UInt64: { return (ulong)0; }
                case BuiltInType.Float: { return (float)0; }
                case BuiltInType.Double: { return (double)0; }
                case BuiltInType.String: { return null; }
                case BuiltInType.DateTime: { return DateTime.MinValue; }
                case BuiltInType.Guid: { return Uuid.Empty; }
                case BuiltInType.ByteString: { return null; }
                case BuiltInType.XmlElement: { return null; }
                case BuiltInType.StatusCode: { return new StatusCode(StatusCodes.Good); }
                case BuiltInType.NodeId: { return NodeId.Null; }
                case BuiltInType.ExpandedNodeId: { return ExpandedNodeId.Null; }
                case BuiltInType.QualifiedName: { return QualifiedName.Null; }
                case BuiltInType.LocalizedText: { return LocalizedText.Null; }
                case BuiltInType.Variant: { return Variant.Null; }
                case BuiltInType.DataValue: { return null; }
                case BuiltInType.Enumeration: { return (int)0; }
                case BuiltInType.Number: { return (double)0; }
                case BuiltInType.Integer: { return (long)0; }
                case BuiltInType.UInteger: { return (ulong)0; }
            }

            return null;
        }

        /// <summary>
        /// Returns the default value for the specified data type and value rank.
        /// </summary>
        /// <param name="dataType">The data type.</param>
        /// <param name="valueRank">The value rank.</param>
        /// <returns>The default value.</returns>
        public static object GetDefaultValue(NodeId dataType, int valueRank)
        {
            return GetDefaultValue(dataType, valueRank, null);
        }

        /// <summary>
        /// Returns the default value for the specified data type and value rank.
        /// </summary>
        /// <param name="dataType">The data type.</param>
        /// <param name="valueRank">The value rank.</param>
        /// <param name="typeTree">The type tree for a server.</param>
        /// <returns>A default value.</returns>
        public static object GetDefaultValue(NodeId dataType, int valueRank, ITypeTable typeTree)
        {
            if (valueRank != ValueRanks.Scalar)
            {
                return null;
            }

            BuiltInType builtInType = BuiltInType.Null;

            if (dataType != null && dataType.IdType == IdType.Numeric && dataType.NamespaceIndex == 0)
            {
                uint id = (uint)dataType.Identifier;

                // if we want an array then go into a loop
                if (id <= DataTypes.DiagnosticInfo)
                {
                    return GetDefaultValue((BuiltInType)(int)id);
                }

                switch (id)
                {
                    case DataTypes.Duration: { return (double)0; }
                    case DataTypes.Date: { return DateTime.MinValue; }
                    case DataTypes.UtcTime: { return DateTime.MinValue; }
                    case DataTypes.Counter: { return (uint)0; }
                    case DataTypes.IntegerId: { return (uint)0; }
                    case DataTypes.Number: { return (double)0; }
                    case DataTypes.UInteger: { return (ulong)0; }
                    case DataTypes.Integer: { return (long)0; }
                    case DataTypes.IdType: { return (int)IdType.Numeric; }
                    case DataTypes.NodeClass: { return (int)NodeClass.Unspecified; }
                    case DataTypes.Enumeration: { return (int)0; }
                }
            }

            builtInType = GetBuiltInType(dataType, typeTree);

            if (builtInType != BuiltInType.Null)
            {
                return GetDefaultValue(builtInType);
            }

            return null;
        }

        /// <summary>
        /// Returns the default value for the specified built-in type.
        /// </summary>
        /// <param name="type">The built-in type.</param>
        /// <param name="dimensions">The dimensions.</param>
        /// <returns>The default value for the specified built-in type</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2208:InstantiateArgumentExceptionsCorrectly"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public static Array CreateArray(BuiltInType type, params int[] dimensions)
        {
            if (dimensions == null || dimensions.Length == 0)
            {
                throw new ArgumentOutOfRangeException("Array dimensions must be specifed.");
            }

            int length = dimensions[0];

            // create one dimensional array.
            if (dimensions.Length == 1)
            {
                switch (type)
                {
                    case BuiltInType.Null: { return new object[length]; }
                    case BuiltInType.Boolean: { return new bool[length]; }
                    case BuiltInType.SByte: { return new sbyte[length]; }
                    case BuiltInType.Byte: { return new byte[length]; }
                    case BuiltInType.Int16: { return new short[length]; }
                    case BuiltInType.UInt16: { return new ushort[length]; }
                    case BuiltInType.Int32: { return new int[length]; }
                    case BuiltInType.UInt32: { return new uint[length]; }
                    case BuiltInType.Int64: { return new long[length]; }
                    case BuiltInType.UInt64: { return new ulong[length]; }
                    case BuiltInType.Float: { return new float[length]; }
                    case BuiltInType.Double: { return new double[length]; }
                    case BuiltInType.String: { return new string[length]; }
                    case BuiltInType.DateTime: { return new DateTime[length]; }
                    case BuiltInType.Guid: { return new Uuid[length]; }
                    case BuiltInType.ByteString: { return new byte[length][]; }
                    case BuiltInType.XmlElement: { return new XmlElement[length]; }
                    case BuiltInType.StatusCode: { return new StatusCode[length]; }
                    case BuiltInType.NodeId: { return new NodeId[length]; }
                    case BuiltInType.ExpandedNodeId: { return new ExpandedNodeId[length]; }
                    case BuiltInType.QualifiedName: { return new QualifiedName[length]; }
                    case BuiltInType.LocalizedText: { return new LocalizedText[length]; }
                    case BuiltInType.Variant: { return new Variant[length]; }
                    case BuiltInType.DataValue: { return new DataValue[length]; }
                    case BuiltInType.ExtensionObject: { return new ExtensionObject[length]; }
                    case BuiltInType.DiagnosticInfo: { return new DiagnosticInfo[length]; }
                    case BuiltInType.Enumeration: { return new int[length]; }
                    case BuiltInType.Number: { return new Variant[length]; }
                    case BuiltInType.Integer: { return new Variant[length]; }
                    case BuiltInType.UInteger: { return new Variant[length]; }
                }
            }

            // create higher dimension arrays.
            else
            {
                switch (type)
                {
                    case BuiltInType.Null: { return Array.CreateInstance(typeof(object), dimensions); }
                    case BuiltInType.Boolean: { return Array.CreateInstance(typeof(bool), dimensions); }
                    case BuiltInType.SByte: { return Array.CreateInstance(typeof(sbyte), dimensions); }
                    case BuiltInType.Byte: { return Array.CreateInstance(typeof(byte), dimensions); }
                    case BuiltInType.Int16: { return Array.CreateInstance(typeof(short), dimensions); }
                    case BuiltInType.UInt16: { return Array.CreateInstance(typeof(ushort), dimensions); }
                    case BuiltInType.Int32: { return Array.CreateInstance(typeof(int), dimensions); }
                    case BuiltInType.UInt32: { return Array.CreateInstance(typeof(uint), dimensions); }
                    case BuiltInType.Int64: { return Array.CreateInstance(typeof(long), dimensions); }
                    case BuiltInType.UInt64: { return Array.CreateInstance(typeof(ulong), dimensions); }
                    case BuiltInType.Float: { return Array.CreateInstance(typeof(float), dimensions); }
                    case BuiltInType.Double: { return Array.CreateInstance(typeof(double), dimensions); }
                    case BuiltInType.String: { return Array.CreateInstance(typeof(string), dimensions); }
                    case BuiltInType.DateTime: { return Array.CreateInstance(typeof(DateTime), dimensions); }
                    case BuiltInType.Guid: { return Array.CreateInstance(typeof(Uuid), dimensions); }
                    case BuiltInType.ByteString: { return Array.CreateInstance(typeof(byte[]), dimensions); }
                    case BuiltInType.XmlElement: { return Array.CreateInstance(typeof(XmlElement), dimensions); }
                    case BuiltInType.StatusCode: { return Array.CreateInstance(typeof(StatusCode), dimensions); }
                    case BuiltInType.NodeId: { return Array.CreateInstance(typeof(NodeId), dimensions); }
                    case BuiltInType.ExpandedNodeId: { return Array.CreateInstance(typeof(ExpandedNodeId), dimensions); }
                    case BuiltInType.QualifiedName: { return Array.CreateInstance(typeof(QualifiedName), dimensions); }
                    case BuiltInType.LocalizedText: { return Array.CreateInstance(typeof(LocalizedText), dimensions); }
                    case BuiltInType.Variant: { return Array.CreateInstance(typeof(Variant), dimensions); }
                    case BuiltInType.DataValue: { return Array.CreateInstance(typeof(DataValue), dimensions); }
                    case BuiltInType.ExtensionObject: { return Array.CreateInstance(typeof(ExtensionObject), dimensions); }
                    case BuiltInType.DiagnosticInfo: { return Array.CreateInstance(typeof(DiagnosticInfo), dimensions); }
                    case BuiltInType.Enumeration: { return Array.CreateInstance(typeof(int), dimensions); }
                    case BuiltInType.Number: { return Array.CreateInstance(typeof(Variant), dimensions); }
                    case BuiltInType.Integer: { return Array.CreateInstance(typeof(Variant), dimensions); }
                    case BuiltInType.UInteger: { return Array.CreateInstance(typeof(Variant), dimensions); }
                }
            }

            // should never happen.
            return null;
        }

        /// <summary>
        /// Casts a value to the specified target type.
        /// </summary>
        /// <param name="source">The instance of a source value.</param>
        /// <param name="targetType">Type of the target.</param>
        /// <returns>Return casted value.<see cref="DBNull"/></returns>
        /// <exception cref="InvalidCastException">if imposible to cast.</exception>
        public static object Cast(object source, BuiltInType targetType)
        {
            return Cast(source, TypeInfo.Construct(source), targetType);
        }

        /// <summary>
        /// Casts a value to the specified target type.
        /// </summary>
        /// <param name="source">The instance of a source value.</param>
        /// <param name="sourceType">Type of the source.</param>
        /// <param name="targetType">Type of the target.</param>
        /// <returns>Return casted value.</returns>
        /// <exception cref="InvalidCastException">if imposible to cast.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public static object Cast(object source, TypeInfo sourceType, BuiltInType targetType)
        {
            // null always casts to null.
            if (sourceType.BuiltInType == BuiltInType.Null)
            {
                return null;
            }

            // check for trivial case.
            if (sourceType.BuiltInType == targetType)
            {
                return source;
            }

            // check for trivial case.
            if (targetType == BuiltInType.Variant && sourceType.ValueRank < 0)
            {
                return new Variant(source);
            }

            // check for guid.
            if (sourceType.BuiltInType == BuiltInType.Guid)
            {
                source = Cast<Uuid>(source, sourceType, ToGuid);
            }

            switch (targetType)
            {
                case BuiltInType.Boolean: return Cast<bool>(source, sourceType, ToBoolean);
                case BuiltInType.SByte: return Cast<sbyte>(source, sourceType, ToSByte);
                case BuiltInType.Byte: return Cast<byte>(source, sourceType, ToByte);
                case BuiltInType.Int16: return Cast<short>(source, sourceType, ToInt16);
                case BuiltInType.UInt16: return Cast<ushort>(source, sourceType, ToUInt16);
                case BuiltInType.Int32: return Cast<int>(source, sourceType, ToInt32);
                case BuiltInType.UInt32: return Cast<uint>(source, sourceType, ToUInt32);
                case BuiltInType.Int64: return Cast<long>(source, sourceType, ToInt64);
                case BuiltInType.UInt64: return Cast<ulong>(source, sourceType, ToUInt64);
                case BuiltInType.Float: return Cast<float>(source, sourceType, ToFloat);
                case BuiltInType.Double: return Cast<double>(source, sourceType, ToDouble);
                case BuiltInType.String: return Cast<string>(source, sourceType, ToString);
                case BuiltInType.DateTime: return Cast<DateTime>(source, sourceType, ToDateTime);
                case BuiltInType.Guid: return Cast<Uuid>(source, sourceType, ToGuid);
                case BuiltInType.ByteString: return Cast<byte[]>(source, sourceType, ToByteString);
                case BuiltInType.NodeId: return Cast<NodeId>(source, sourceType, ToNodeId);
                case BuiltInType.ExpandedNodeId: return Cast<ExpandedNodeId>(source, sourceType, ToExpandedNodeId);
                case BuiltInType.StatusCode: return Cast<StatusCode>(source, sourceType, ToStatusCode);
                case BuiltInType.QualifiedName: return Cast<QualifiedName>(source, sourceType, ToQualifiedName);
                case BuiltInType.LocalizedText: return Cast<LocalizedText>(source, sourceType, ToLocalizedText);
                case BuiltInType.Variant: return Cast<Variant>(source, sourceType, ToVariant);
                case BuiltInType.Number: return Cast<double>(source, sourceType, ToDouble);
                case BuiltInType.Integer: return Cast<long>(source, sourceType, ToInt64);
                case BuiltInType.UInteger: return Cast<ulong>(source, sourceType, ToUInt64);
                case BuiltInType.Enumeration: return Cast<int>(source, sourceType, ToInt32);
                case BuiltInType.XmlElement: return Cast<XmlElement>(source, sourceType, ToXmlElement);
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts the array using the specified conversion function.
        /// </summary>
        /// <param name="dst">The destination array (must have the same size as the source array).</param>
        /// <param name="dstType">The data type of the elements in the destination array.</param>
        /// <param name="src">The source array.</param>
        /// <param name="srcType">The data type of the elements in the source array.</param>
        /// <param name="convertor">The handler which does the conversion.</param>
        public static void CastArray(Array dst, BuiltInType dstType, Array src, BuiltInType srcType, CastArrayElementHandler convertor)
        {
            bool isSrcVariant = src.GetType().GetElementType() == typeof(Variant);
            bool isDstVariant = dst.GetType().GetElementType() == typeof(Variant);

            // optimize performance if dealing with a one dimensional array.
            if (src.Rank == 1)
            {
                for (int ii = 0; ii < dst.Length; ii++)
                {
                    object element = src.GetValue(ii);

                    if (isSrcVariant)
                    {
                        element = ((Variant)element).Value;
                    }

                    if (convertor != null)
                    {
                        element = convertor(element, srcType, dstType);
                    }

                    if (isDstVariant)
                    {
                        element = new Variant(element);
                    }

                    dst.SetValue(element, ii);
                }

                return;
            }

            // do it the hard way for multidimensional arrays.
            int[] dimensions = new int[src.Rank];

            for (int ii = 0; ii < dimensions.Length; ii++)
            {
                dimensions[ii] = src.GetLength(ii);
            }

            int length = dst.Length;
            int[] indexes = new int[dimensions.Length];

            for (int ii = 0; ii < length; ii++)
            {
                int divisor = dst.Length;

                for (int jj = 0; jj < indexes.Length; jj++)
                {
                    divisor /= dimensions[jj];
                    indexes[jj] = (ii / divisor) % dimensions[jj];
                }

                object element = src.GetValue(indexes);

                if (element != null)
                {
                    if (isSrcVariant)
                    {
                        element = ((Variant)element).Value;
                    }

                    if (convertor != null)
                    {
                        element = convertor(element, srcType, dstType);
                    }

                    if (isDstVariant)
                    {
                        element = new Variant(element);
                    }

                    dst.SetValue(element, indexes);
                }
            }
        }

        /// <summary>
        /// Converts the array.
        /// </summary>
        /// <param name="srcArray">The source array.</param>
        /// <param name="srcType">The type of the source array.</param>
        /// <param name="dstType">The type of the converted array.</param>
        /// <param name="convertor">The handler which does the conversion.</param>
        /// <returns>The converted array.</returns>
        public static Array CastArray(Array srcArray, BuiltInType srcType, BuiltInType dstType, CastArrayElementHandler convertor)
        {
            if (srcArray == null)
            {
                return null;
            }

            int[] dimensions = new int[srcArray.Rank];

            for (int ii = 0; ii < dimensions.Length; ii++)
            {
                dimensions[ii] = srcArray.GetLength(ii);
            }

            Array dstArray = TypeInfo.CreateArray(dstType, dimensions);
            CastArray(dstArray, dstType, srcArray, srcType, convertor);

            return dstArray;
        }

        /// <summary>
        /// A delegate for a function that converts an array element.
        /// </summary>
        /// <param name="source">The element to be converted.</param>
        /// <param name="srcType">The type of the source element.</param>
        /// <param name="dstType">The type of the converted value.</param>
        /// <returns>The converted</returns>
        public delegate object CastArrayElementHandler(object source, BuiltInType srcType, BuiltInType dstType);
        #endregion

        #region Private Methods
        /// <summary>
        /// Maps the type name to a built-in type.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private static BuiltInType GetBuiltInType(string typeName)
        {
            switch (typeName)
            {
                case "Boolean": return BuiltInType.Boolean;
                case "SByte": return BuiltInType.SByte;
                case "Byte": return BuiltInType.Byte;
                case "Int16": return BuiltInType.Int16;
                case "UInt16": return BuiltInType.UInt16;
                case "Int32": return BuiltInType.Int32;
                case "UInt32": return BuiltInType.UInt32;
                case "Int64": return BuiltInType.Int64;
                case "UInt64": return BuiltInType.UInt64;
                case "Float": return BuiltInType.Float;
                case "Single": return BuiltInType.Float;
                case "Double": return BuiltInType.Double;
                case "String": return BuiltInType.String;
                case "DateTime": return BuiltInType.DateTime;
                case "Guid": return BuiltInType.Guid;
                case "Uuid": return BuiltInType.Guid;
                case "ByteString": return BuiltInType.ByteString;
                case "XmlElement": return BuiltInType.XmlElement;
                case "NodeId": return BuiltInType.NodeId;
                case "ExpandedNodeId": return BuiltInType.ExpandedNodeId;
                case "LocalizedText": return BuiltInType.LocalizedText;
                case "QualifiedName": return BuiltInType.QualifiedName;
                case "StatusCode": return BuiltInType.StatusCode;
                case "DiagnosticInfo": return BuiltInType.DiagnosticInfo;
                case "DataValue": return BuiltInType.DataValue;
                case "Variant": return BuiltInType.Variant;
                case "ExtensionObject": return BuiltInType.ExtensionObject;
                case "Object": return BuiltInType.Variant;
            }

            return BuiltInType.Null;
        }

        /// <summary>
        /// Converts a value to a Boolean
        /// </summary>
        private static bool ToBoolean(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Boolean:
                {
                    return (bool)value;
                }

                case BuiltInType.SByte: return Convert.ToBoolean((sbyte)value);
                case BuiltInType.Byte: return Convert.ToBoolean((byte)value);
                case BuiltInType.Int16: return Convert.ToBoolean((short)value);
                case BuiltInType.UInt16: return Convert.ToBoolean((ushort)value);
                case BuiltInType.Int32: return Convert.ToBoolean((int)value);
                case BuiltInType.UInt32: return Convert.ToBoolean((uint)value);
                case BuiltInType.Int64: return Convert.ToBoolean((long)value);
                case BuiltInType.UInt64: return Convert.ToBoolean((ulong)value);
                case BuiltInType.Float: return Convert.ToBoolean((float)value);
                case BuiltInType.Double: return Convert.ToBoolean((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToBoolean((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a SByte
        /// </summary>
        private static sbyte ToSByte(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.SByte:
                {
                    return (sbyte)value;
                }

                case BuiltInType.Boolean: return Convert.ToSByte((bool)value);
                case BuiltInType.Byte: return Convert.ToSByte((byte)value);
                case BuiltInType.Int16: return Convert.ToSByte((short)value);
                case BuiltInType.UInt16: return Convert.ToSByte((ushort)value);
                case BuiltInType.Int32: return Convert.ToSByte((int)value);
                case BuiltInType.UInt32: return Convert.ToSByte((uint)value);
                case BuiltInType.Int64: return Convert.ToSByte((long)value);
                case BuiltInType.UInt64: return Convert.ToSByte((ulong)value);
                case BuiltInType.Float: return Convert.ToSByte((float)value);
                case BuiltInType.Double: return Convert.ToSByte((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToSByte((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Byte
        /// </summary>
        private static byte ToByte(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Byte:
                {
                    return (byte)value;
                }

                case BuiltInType.Boolean: return Convert.ToByte((bool)value);
                case BuiltInType.SByte: return Convert.ToByte((sbyte)value);
                case BuiltInType.Int16: return Convert.ToByte((short)value);
                case BuiltInType.UInt16: return Convert.ToByte((ushort)value);
                case BuiltInType.Int32: return Convert.ToByte((int)value);
                case BuiltInType.UInt32: return Convert.ToByte((uint)value);
                case BuiltInType.Int64: return Convert.ToByte((long)value);
                case BuiltInType.UInt64: return Convert.ToByte((ulong)value);
                case BuiltInType.Float: return Convert.ToByte((float)value);
                case BuiltInType.Double: return Convert.ToByte((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToByte((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Int16
        /// </summary>
        private static short ToInt16(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Int16:
                {
                    return (short)value;
                }

                case BuiltInType.Boolean: return Convert.ToInt16((bool)value);
                case BuiltInType.SByte: return Convert.ToInt16((sbyte)value);
                case BuiltInType.Byte: return Convert.ToInt16((byte)value);
                case BuiltInType.UInt16: return Convert.ToInt16((ushort)value);
                case BuiltInType.Int32: return Convert.ToInt16((int)value);
                case BuiltInType.UInt32: return Convert.ToInt16((uint)value);
                case BuiltInType.Int64: return Convert.ToInt16((long)value);
                case BuiltInType.UInt64: return Convert.ToInt16((ulong)value);
                case BuiltInType.Float: return Convert.ToInt16((float)value);
                case BuiltInType.Double: return Convert.ToInt16((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt16((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a UInt16
        /// </summary>
        private static ushort ToUInt16(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.UInt16:
                {
                    return (ushort)value;
                }

                case BuiltInType.Boolean: return Convert.ToUInt16((bool)value);
                case BuiltInType.SByte: return Convert.ToUInt16((sbyte)value);
                case BuiltInType.Byte: return Convert.ToUInt16((byte)value);
                case BuiltInType.Int16: return Convert.ToUInt16((short)value);
                case BuiltInType.Int32: return Convert.ToUInt16((int)value);
                case BuiltInType.UInt32: return Convert.ToUInt16((uint)value);
                case BuiltInType.Int64: return Convert.ToUInt16((long)value);
                case BuiltInType.UInt64: return Convert.ToUInt16((ulong)value);
                case BuiltInType.Float: return Convert.ToUInt16((float)value);
                case BuiltInType.Double: return Convert.ToUInt16((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt16((string)value);
                }

                case BuiltInType.StatusCode:
                {
                    StatusCode code = (StatusCode)value;
                    return (ushort)(code.CodeBits >> 16);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Int32
        /// </summary>
        private static int ToInt32(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Int32:
                {
                    return (int)value;
                }

                case BuiltInType.Boolean: return Convert.ToInt32((bool)value);
                case BuiltInType.SByte: return Convert.ToInt32((sbyte)value);
                case BuiltInType.Byte: return Convert.ToInt32((byte)value);
                case BuiltInType.Int16: return Convert.ToInt32((short)value);
                case BuiltInType.UInt16: return Convert.ToInt32((ushort)value);
                case BuiltInType.UInt32: return Convert.ToInt32((uint)value);
                case BuiltInType.Int64: return Convert.ToInt32((long)value);
                case BuiltInType.UInt64: return Convert.ToInt32((ulong)value);
                case BuiltInType.Float: return Convert.ToInt32((float)value);
                case BuiltInType.Double: return Convert.ToInt32((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt32((string)value);
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToInt32(((StatusCode)value).Code);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a UInt32
        /// </summary>
        private static uint ToUInt32(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.UInt32:
                {
                    return (uint)value;
                }

                case BuiltInType.Boolean: return Convert.ToUInt32((bool)value);
                case BuiltInType.SByte: return Convert.ToUInt32((sbyte)value);
                case BuiltInType.Byte: return Convert.ToUInt32((byte)value);
                case BuiltInType.Int16: return Convert.ToUInt32((short)value);
                case BuiltInType.UInt16: return Convert.ToUInt32((ushort)value);
                case BuiltInType.Int32: return Convert.ToUInt32((int)value);
                case BuiltInType.Int64: return Convert.ToUInt32((long)value);
                case BuiltInType.UInt64: return Convert.ToUInt32((ulong)value);
                case BuiltInType.Float: return Convert.ToUInt32((float)value);
                case BuiltInType.Double: return Convert.ToUInt32((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt32((string)value);
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToUInt32(((StatusCode)value).Code);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Int64
        /// </summary>
        private static long ToInt64(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Int64:
                {
                    return (long)value;
                }

                case BuiltInType.Boolean: return Convert.ToInt64((bool)value);
                case BuiltInType.SByte: return Convert.ToInt64((sbyte)value);
                case BuiltInType.Byte: return Convert.ToInt64((byte)value);
                case BuiltInType.Int16: return Convert.ToInt64((short)value);
                case BuiltInType.UInt16: return Convert.ToInt64((ushort)value);
                case BuiltInType.Int32: return Convert.ToInt64((int)value);
                case BuiltInType.UInt32: return Convert.ToInt64((uint)value);
                case BuiltInType.UInt64: return Convert.ToInt64((ulong)value);
                case BuiltInType.Float: return Convert.ToInt64((float)value);
                case BuiltInType.Double: return Convert.ToInt64((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt64((string)value);
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToInt64(((StatusCode)value).Code);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a UInt64
        /// </summary>
        private static ulong ToUInt64(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.UInt64:
                {
                    return (ulong)value;
                }

                case BuiltInType.Boolean: return Convert.ToUInt64((bool)value);
                case BuiltInType.SByte: return Convert.ToUInt64((sbyte)value);
                case BuiltInType.Byte: return Convert.ToUInt64((byte)value);
                case BuiltInType.Int16: return Convert.ToUInt64((short)value);
                case BuiltInType.UInt16: return Convert.ToUInt64((ushort)value);
                case BuiltInType.Int32: return Convert.ToUInt64((int)value);
                case BuiltInType.UInt32: return Convert.ToUInt64((uint)value);
                case BuiltInType.Int64: return Convert.ToUInt64((long)value);
                case BuiltInType.Float: return Convert.ToUInt64((float)value);
                case BuiltInType.Double: return Convert.ToUInt64((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt64((string)value);
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToUInt64(((StatusCode)value).Code);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Float
        /// </summary>
        private static float ToFloat(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Float:
                {
                    return (float)value;
                }

                case BuiltInType.Boolean: return Convert.ToSingle((bool)value);
                case BuiltInType.SByte: return Convert.ToSingle((sbyte)value);
                case BuiltInType.Byte: return Convert.ToSingle((byte)value);
                case BuiltInType.Int16: return Convert.ToSingle((short)value);
                case BuiltInType.UInt16: return Convert.ToSingle((ushort)value);
                case BuiltInType.Int32: return Convert.ToSingle((int)value);
                case BuiltInType.UInt32: return Convert.ToSingle((uint)value);
                case BuiltInType.Int64: return Convert.ToSingle((long)value);
                case BuiltInType.UInt64: return Convert.ToSingle((ulong)value);
                case BuiltInType.Double: return Convert.ToSingle((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToSingle((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Double
        /// </summary>
        private static double ToDouble(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Double:
                {
                    return (double)value;
                }

                case BuiltInType.Boolean: return Convert.ToDouble((bool)value);
                case BuiltInType.SByte: return Convert.ToDouble((sbyte)value);
                case BuiltInType.Byte: return Convert.ToDouble((byte)value);
                case BuiltInType.Int16: return Convert.ToDouble((short)value);
                case BuiltInType.UInt16: return Convert.ToDouble((ushort)value);
                case BuiltInType.Int32: return Convert.ToDouble((int)value);
                case BuiltInType.UInt32: return Convert.ToDouble((uint)value);
                case BuiltInType.Int64: return Convert.ToDouble((long)value);
                case BuiltInType.UInt64: return Convert.ToDouble((ulong)value);
                case BuiltInType.Float: return Convert.ToDouble((float)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToDouble((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a String
        /// </summary>
        private static string ToString(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.String:
                {
                    return (string)value;
                }

                case BuiltInType.Boolean:
                {
                    return XmlConvert.ToString((bool)value);
                }

                case BuiltInType.SByte:
                {
                    return XmlConvert.ToString((sbyte)value);
                }

                case BuiltInType.Byte:
                {
                    return XmlConvert.ToString((byte)value);
                }

                case BuiltInType.Int16:
                {
                    return XmlConvert.ToString((short)value);
                }

                case BuiltInType.UInt16:
                {
                    return XmlConvert.ToString((ushort)value);
                }

                case BuiltInType.Int32:
                {
                    return XmlConvert.ToString((int)value);
                }

                case BuiltInType.UInt32:
                {
                    return XmlConvert.ToString((uint)value);
                }

                case BuiltInType.Int64:
                {
                    return XmlConvert.ToString((long)value);
                }

                case BuiltInType.UInt64:
                {
                    return XmlConvert.ToString((ulong)value);
                }

                case BuiltInType.Float:
                {
                    return XmlConvert.ToString((float)value);
                }

                case BuiltInType.Double:
                {
                    return XmlConvert.ToString((double)value);
                }

                case BuiltInType.DateTime:
                {
                    return XmlConvert.ToString((DateTime)value, XmlDateTimeSerializationMode.Unspecified);
                }

                case BuiltInType.Guid:
                {
                    return ((Uuid)value).ToString();
                }

                case BuiltInType.NodeId:
                {
                    return ((NodeId)value).ToString();
                }

                case BuiltInType.ExpandedNodeId:
                {
                    return ((ExpandedNodeId)value).ToString();
                }

                case BuiltInType.LocalizedText:
                {
                    return ((LocalizedText)value).Text;
                }

                case BuiltInType.QualifiedName:
                {
                    return ((QualifiedName)value).ToString();
                }

                case BuiltInType.XmlElement:
                {
                    return ((XmlElement)value).OuterXml;
                }

                case BuiltInType.StatusCode:
                {
                    return ((StatusCode)value).Code.ToString();
                }

                case BuiltInType.ExtensionObject:
                {
                    return ((ExtensionObject)value).ToString();
                }

                case BuiltInType.Null:
                {
                    return null;
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a DateTime
        /// </summary>
        private static DateTime ToDateTime(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.DateTime:
                {
                    return (DateTime)value;
                }

                case BuiltInType.String:
                {
                    return XmlConvert.ToDateTime((string)value, XmlDateTimeSerializationMode.Unspecified);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Guid
        /// </summary>
        private static Uuid ToGuid(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.String:
                {
                    return new Uuid((string)value);
                }

                case BuiltInType.ByteString:
                {
                    return new Uuid(new Guid((byte[])value));
                }

                case BuiltInType.Guid:
                {
                    Guid? guid = value as Guid?;

                    if (guid != null)
                    {
                        return new Uuid(guid.Value);
                    }

                    return (Uuid)value;
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a ByteString
        /// </summary>
        private static byte[] ToByteString(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.ByteString:
                {
                    return (byte[])value;
                }

                case BuiltInType.String:
                {
                    string text = (string)value;

                    if (text == null)
                    {
                        return null;
                    }

                    if (text.Length == 0)
                    {
                        return new byte[0];
                    }

                    using (System.IO.MemoryStream ostrm = new System.IO.MemoryStream())
                    {
                        byte buffer = 0;
                        bool firstByte = false;
                        const string digits = "0123456789ABCDEF";

                        for (int ii = 0; ii < text.Length; ii++)
                        {
                            if (!Char.IsWhiteSpace(text, ii) && !Char.IsLetterOrDigit(text, ii))
                            {
                                throw new FormatException("Invalid character in ByteString. " + text[ii]);
                            }

                            if (Char.IsWhiteSpace(text, ii))
                            {
                                continue;
                            }

                            int index = digits.IndexOf(Char.ToUpper(text[ii]));

                            if (index < 0)
                            {
                                throw new FormatException("Invalid character in ByteString." + text[ii]);
                            }

                            buffer <<= 4;
                            buffer += (byte)index;

                            if (firstByte)
                            {
                                ostrm.WriteByte(buffer);
                                firstByte = false;
                                continue;
                            }

                            firstByte = true;
                        }

                        if (firstByte)
                        {
                            buffer <<= 4;
                            ostrm.WriteByte(buffer);
                        }

                        // you should not access a closed stream, ever.
                        return ostrm.ToArray();
                    }
                }

                case BuiltInType.Guid:
                {
                    return ((Guid)((Uuid)value)).ToByteArray();
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a XmlElement
        /// </summary>
        private static XmlElement ToXmlElement(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.XmlElement:
                {
                    return (XmlElement)value;
                }

                case BuiltInType.String:
                {
                    XmlDocument document = new XmlDocument();
                    document.InnerXml = (string)value;
                    return document.DocumentElement;
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a NodeId
        /// </summary>
        private static NodeId ToNodeId(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.NodeId:
                {
                    return (NodeId)value;
                }

                case BuiltInType.ExpandedNodeId:
                {
                    return (NodeId)(ExpandedNodeId)value;
                }

                case BuiltInType.String:
                {
                    return NodeId.Parse((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a ExpandedNodeId
        /// </summary>
        private static ExpandedNodeId ToExpandedNodeId(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.ExpandedNodeId:
                {
                    return (ExpandedNodeId)value;
                }

                case BuiltInType.NodeId:
                {
                    return (ExpandedNodeId)(NodeId)value;
                }

                case BuiltInType.String:
                {
                    return ExpandedNodeId.Parse((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a StatusCode
        /// </summary>
        private static StatusCode ToStatusCode(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.StatusCode:
                {
                    return (StatusCode)value;
                }

                case BuiltInType.UInt16:
                {
                    uint code = Convert.ToUInt32((ushort)value);
                    code <<= 16;
                    return (StatusCode)code;
                }

                case BuiltInType.Int32:
                {
                    return (StatusCode)Convert.ToUInt32((int)value);
                }

                case BuiltInType.UInt32:
                {
                    return (StatusCode)(uint)value;
                }

                case BuiltInType.Int64:
                {
                    return (StatusCode)Convert.ToUInt32((long)value);
                }

                case BuiltInType.UInt64:
                {
                    return (StatusCode)Convert.ToUInt32((ulong)value);
                }

                case BuiltInType.String:
                {
                    string text = (string)value;

                    if (text == null)
                    {
                        return StatusCodes.Good;
                    }

                    text = text.Trim();

                    if (text.StartsWith("0x"))
                    {
                        return (StatusCode)Convert.ToUInt32(text.Substring(2), 16);
                    }

                    return (StatusCode)Convert.ToUInt32((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a QualifiedName
        /// </summary>
        private static QualifiedName ToQualifiedName(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.QualifiedName:
                {
                    return (QualifiedName)value;
                }

                case BuiltInType.String:
                {
                    return QualifiedName.Parse((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a LocalizedText
        /// </summary>
        private static LocalizedText ToLocalizedText(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.LocalizedText:
                {
                    return (LocalizedText)value;
                }

                case BuiltInType.String:
                {
                    return new LocalizedText((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Variant
        /// </summary>
        private static Variant ToVariant(object value, TypeInfo sourceType)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Delegate for a function used to cast a value to the specified type.
        /// </summary>
        private delegate T CastDelegate<T>(object value, TypeInfo sourceType);

        /// <summary>
        /// Casts a scalar or array value to the specified type.
        /// </summary>
        private static object Cast<T>(object input, TypeInfo sourceType, CastDelegate<T> handler)
        {
            if (sourceType == null)
            {
                sourceType = TypeInfo.Construct(input);
            }

            if (sourceType.ValueRank >= 0)
            {
                return Cast<T>((Array)input, sourceType, handler);
            }

            if (sourceType.BuiltInType == BuiltInType.Variant)
            {
                object value = ((Variant)input).Value;
                sourceType = TypeInfo.Construct(value);
                return handler(value, sourceType);
            }

            return handler(input, sourceType);
        }

        /// <summary>
        /// Casts an array to an array of the specified type.
        /// </summary>
        private static Array Cast<T>(Array input, TypeInfo sourceType, CastDelegate<T> handler)
        {
            if (input == null)
            {
                return null;
            }

            TypeInfo elementType = new TypeInfo(sourceType.BuiltInType, ValueRanks.Scalar);

            if (input.Rank == 1)
            {
                T[] copy = new T[input.Length];

                for (int ii = 0; ii < input.Length; ii++)
                {
                    object value = input.GetValue(ii);

                    if (value != null)
                    {
                        if (sourceType.BuiltInType == BuiltInType.Variant)
                        {
                            value = ((Variant)value).Value;
                            elementType = TypeInfo.Construct(value);
                        }

                        copy[ii] = handler(value, elementType);
                    }
                }

                return copy;
            }

            if (input.Rank == 2)
            {
                int x = input.GetLength(0);
                int y = input.GetLength(1);

                T[,] copy = new T[x, y];

                for (int ii = 0; ii < x; ii++)
                {
                    for (int jj = 0; jj < y; jj++)
                    {
                        object value = input.GetValue(ii, jj);

                        if (value != null)
                        {
                            if (sourceType.BuiltInType == BuiltInType.Variant)
                            {
                                value = ((Variant)value).Value;
                                elementType = TypeInfo.Construct(value);
                            }

                            copy[ii, jj] = handler(value, elementType);
                        }
                    }
                }

                return copy;
            }

            int[] dimensions = new int[input.Rank];

            for (int ii = 0; ii < dimensions.Length; ii++)
            {
                dimensions[ii] = input.GetLength(ii);
            }

            Array output = Array.CreateInstance(typeof(T), dimensions);

            int length = output.Length;
            int[] indexes = new int[dimensions.Length];

            for (int ii = 0; ii < length; ii++)
            {
                int divisor = output.Length;

                for (int jj = 0; jj < indexes.Length; jj++)
                {
                    divisor /= dimensions[jj];
                    indexes[jj] = (ii / divisor) % dimensions[jj];
                }

                object value = input.GetValue(indexes);

                if (value != null)
                {
                    if (sourceType.BuiltInType == BuiltInType.Variant)
                    {
                        value = ((Variant)value).Value;
                        elementType = TypeInfo.Construct(value);
                    }

                    output.SetValue(handler(value, elementType), indexes);
                }
            }

            return output;
        }
        #endregion

        #region Private Fields
        private BuiltInType m_builtInType;
        private int m_valueRank;
        private static readonly TypeInfo s_Unknown = new TypeInfo();
        #endregion

        #region Scalars Class
        /// <summary>
        /// Constants for scalar types.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        public static class Scalars
        {
            /// <summary>
            /// A boolean logic value (true or false).
            /// </summary>
            public static readonly TypeInfo Boolean = new TypeInfo(BuiltInType.Boolean, ValueRanks.Scalar);

            /// <summary>
            /// An 8 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo SByte = new TypeInfo(BuiltInType.SByte, ValueRanks.Scalar);

            /// <summary>
            /// An 8 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo Byte = new TypeInfo(BuiltInType.Byte, ValueRanks.Scalar);

            /// <summary>
            /// A 16 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int16 = new TypeInfo(BuiltInType.Int16, ValueRanks.Scalar);

            /// <summary>
            /// A 16 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo UInt16 = new TypeInfo(BuiltInType.UInt16, ValueRanks.Scalar);

            /// <summary>
            /// A 32 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int32 = new TypeInfo(BuiltInType.Int32, ValueRanks.Scalar);

            /// <summary>
            /// A 32 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo UInt32 = new TypeInfo(BuiltInType.UInt32, ValueRanks.Scalar);

            /// <summary>
            /// A 64 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int64 = new TypeInfo(BuiltInType.Int64, ValueRanks.Scalar);

            /// <summary>
            /// A 64 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo UInt64 = new TypeInfo(BuiltInType.UInt64, ValueRanks.Scalar);

            /// <summary>
            /// An IEEE single precision (32 bit) floating point value.
            /// </summary>
            public static readonly TypeInfo Float = new TypeInfo(BuiltInType.Float, ValueRanks.Scalar);

            /// <summary>
            /// An IEEE double precision (64 bit) floating point value.
            /// </summary>
            public static readonly TypeInfo Double = new TypeInfo(BuiltInType.Double, ValueRanks.Scalar);

            /// <summary>
            /// A sequence of Unicode characters.
            /// </summary>
            public static readonly TypeInfo String = new TypeInfo(BuiltInType.String, ValueRanks.Scalar);

            /// <summary>
            /// An instance in time.
            /// </summary>
            public static readonly TypeInfo DateTime = new TypeInfo(BuiltInType.DateTime, ValueRanks.Scalar);

            /// <summary>
            /// A 128-bit globally unique identifier.
            /// </summary>
            public static readonly TypeInfo Guid = new TypeInfo(BuiltInType.Guid, ValueRanks.Scalar);

            /// <summary>
            /// A sequence of bytes.
            /// </summary>
            public static readonly TypeInfo ByteString = new TypeInfo(BuiltInType.ByteString, ValueRanks.Scalar);

            /// <summary>
            /// An XML element.
            /// </summary>
            public static readonly TypeInfo XmlElement = new TypeInfo(BuiltInType.XmlElement, ValueRanks.Scalar);

            /// <summary>
            /// An identifier for a node in the address space of a UA server.
            /// </summary>
            public static readonly TypeInfo NodeId = new TypeInfo(BuiltInType.NodeId, ValueRanks.Scalar);

            /// <summary>
            /// A node id that stores the namespace URI instead of the namespace index.
            /// </summary>
            public static readonly TypeInfo ExpandedNodeId = new TypeInfo(BuiltInType.ExpandedNodeId, ValueRanks.Scalar);

            /// <summary>
            /// A structured result code.
            /// </summary>
            public static readonly TypeInfo StatusCode = new TypeInfo(BuiltInType.StatusCode, ValueRanks.Scalar);

            /// <summary>
            /// A string qualified with a namespace.
            /// </summary>
            public static readonly TypeInfo QualifiedName = new TypeInfo(BuiltInType.QualifiedName, ValueRanks.Scalar);

            /// <summary>
            /// A localized text string with an locale identifier.
            /// </summary>
            public static readonly TypeInfo LocalizedText = new TypeInfo(BuiltInType.LocalizedText, ValueRanks.Scalar);

            /// <summary>
            /// An opaque object with a syntax that may be unknown to the receiver.
            /// </summary>
            public static readonly TypeInfo ExtensionObject = new TypeInfo(BuiltInType.ExtensionObject, ValueRanks.Scalar);

            /// <summary>
            /// A data value with an associated quality and timestamp.
            /// </summary>
            public static readonly TypeInfo DataValue = new TypeInfo(BuiltInType.DataValue, ValueRanks.Scalar);

            /// <summary>
            /// Any of the other built-in types.
            /// </summary>
            public static readonly TypeInfo Variant = new TypeInfo(BuiltInType.Variant, ValueRanks.Scalar);

            /// <summary>
            /// A diagnostic information associated with a result code.
            /// </summary>
            public static readonly TypeInfo DiagnosticInfo = new TypeInfo(BuiltInType.DiagnosticInfo, ValueRanks.Scalar);
        }
        #endregion

        #region Arrays Class
        /// <summary>
        /// Constants for one dimensional array types.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        public static class Arrays
        {
            /// <summary>
            /// A boolean logic value (true or false).
            /// </summary>
            public static readonly TypeInfo Boolean = new TypeInfo(BuiltInType.Boolean, ValueRanks.OneDimension);

            /// <summary>
            /// An 8 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo SByte = new TypeInfo(BuiltInType.SByte, ValueRanks.OneDimension);

            /// <summary>
            /// An 8 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo Byte = new TypeInfo(BuiltInType.Byte, ValueRanks.OneDimension);

            /// <summary>
            /// A 16 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int16 = new TypeInfo(BuiltInType.Int16, ValueRanks.OneDimension);

            /// <summary>
            /// A 16 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo UInt16 = new TypeInfo(BuiltInType.UInt16, ValueRanks.OneDimension);

            /// <summary>
            /// A 32 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int32 = new TypeInfo(BuiltInType.Int32, ValueRanks.OneDimension);

            /// <summary>
            /// A 32 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo UInt32 = new TypeInfo(BuiltInType.UInt32, ValueRanks.OneDimension);

            /// <summary>
            /// A 64 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int64 = new TypeInfo(BuiltInType.Int64, ValueRanks.OneDimension);

            /// <summary>
            /// A 64 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo UInt64 = new TypeInfo(BuiltInType.UInt64, ValueRanks.OneDimension);

            /// <summary>
            /// An IEEE single precision (32 bit) floating point value.
            /// </summary>
            public static readonly TypeInfo Float = new TypeInfo(BuiltInType.Float, ValueRanks.OneDimension);

            /// <summary>
            /// An IEEE double precision (64 bit) floating point value.
            /// </summary>
            public static readonly TypeInfo Double = new TypeInfo(BuiltInType.Double, ValueRanks.OneDimension);

            /// <summary>
            /// A sequence of Unicode characters.
            /// </summary>
            public static readonly TypeInfo String = new TypeInfo(BuiltInType.String, ValueRanks.OneDimension);

            /// <summary>
            /// An instance in time.
            /// </summary>
            public static readonly TypeInfo DateTime = new TypeInfo(BuiltInType.DateTime, ValueRanks.OneDimension);

            /// <summary>
            /// A 128-bit globally unique identifier.
            /// </summary>
            public static readonly TypeInfo Guid = new TypeInfo(BuiltInType.Guid, ValueRanks.OneDimension);

            /// <summary>
            /// A sequence of bytes.
            /// </summary>
            public static readonly TypeInfo ByteString = new TypeInfo(BuiltInType.ByteString, ValueRanks.OneDimension);

            /// <summary>
            /// An XML element.
            /// </summary>
            public static readonly TypeInfo XmlElement = new TypeInfo(BuiltInType.XmlElement, ValueRanks.OneDimension);

            /// <summary>
            /// An identifier for a node in the address space of a UA server.
            /// </summary>
            public static readonly TypeInfo NodeId = new TypeInfo(BuiltInType.NodeId, ValueRanks.OneDimension);

            /// <summary>
            /// A node id that stores the namespace URI instead of the namespace index.
            /// </summary>
            public static readonly TypeInfo ExpandedNodeId = new TypeInfo(BuiltInType.ExpandedNodeId, ValueRanks.OneDimension);

            /// <summary>
            /// A structured result code.
            /// </summary>
            public static readonly TypeInfo StatusCode = new TypeInfo(BuiltInType.StatusCode, ValueRanks.OneDimension);

            /// <summary>
            /// A string qualified with a namespace.
            /// </summary>
            public static readonly TypeInfo QualifiedName = new TypeInfo(BuiltInType.QualifiedName, ValueRanks.OneDimension);

            /// <summary>
            /// A localized text string with an locale identifier.
            /// </summary>
            public static readonly TypeInfo LocalizedText = new TypeInfo(BuiltInType.LocalizedText, ValueRanks.OneDimension);

            /// <summary>
            /// An opaque object with a syntax that may be unknown to the receiver.
            /// </summary>
            public static readonly TypeInfo ExtensionObject = new TypeInfo(BuiltInType.ExtensionObject, ValueRanks.OneDimension);

            /// <summary>
            /// A data value with an associated quality and timestamp.
            /// </summary>
            public static readonly TypeInfo DataValue = new TypeInfo(BuiltInType.DataValue, ValueRanks.OneDimension);

            /// <summary>
            /// Any of the other built-in types.
            /// </summary>
            public static readonly TypeInfo Variant = new TypeInfo(BuiltInType.Variant, ValueRanks.OneDimension);

            /// <summary>
            /// A diagnostic information associated with a result code.
            /// </summary>
            public static readonly TypeInfo DiagnosticInfo = new TypeInfo(BuiltInType.DiagnosticInfo, ValueRanks.OneDimension);
        }
        #endregion

        #region IFormattable Members
        /// <summary>
        /// Formats the type information as a string.
        /// </summary>
        public override string ToString()
        {
            return ToString(null, null);
        }

        /// <summary>
        /// Formats the type information as a string.
        /// </summary>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                System.Text.StringBuilder buffer = new System.Text.StringBuilder();
                buffer.Append(m_builtInType);

                if (m_valueRank >= 0)
                {
                    buffer.Append("[");

                    for (int ii = 1; ii < m_valueRank; ii++)
                    {
                        buffer.Append(",");
                    }

                    buffer.Append("]");
                }

                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Determines if the specified object is equal to the object.
        /// </summary>
        /// <remarks>
        /// Determines if the specified object is equal to the object.
        /// </remarks>
        public override bool Equals(object obj)
        {
            if (Object.ReferenceEquals(this, obj))
            {
                return true;
            }

            TypeInfo typeInfo = obj as TypeInfo;
            if (typeInfo != null)
            {
                return (m_builtInType == typeInfo.BuiltInType &&
                    m_valueRank == typeInfo.ValueRank);
            }

            return false;
        }

        /// <summary>
        /// Returns a suitable hash code.
        /// </summary>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Reflection;
using System.Xml;

namespace Opc.Ua
{
    /// <summary>
    /// The set of built-in data types for UA type descriptions.
    /// </summary>
    /// <remarks>
    /// An enumeration that lists all of the built-in data types for OPC UA Type Descriptions.
    /// </remarks>
    public enum BuiltInType : int
    {
        /// <summary>
        /// An invalid or unspecified value.
        /// </summary>
        Null = 0,

        /// <summary>
        /// A boolean logic value (true or false).
        /// </summary>
        Boolean = 1,

        /// <summary>
        /// An 8 bit signed integer value.
        /// </summary>
        SByte = 2,

        /// <summary>
        /// An 8 bit unsigned integer value.
        /// </summary>
        Byte = 3,

        /// <summary>
        /// A 16 bit signed integer value.
        /// </summary>
        Int16 = 4,

        /// <summary>
        /// A 16 bit signed integer value.
        /// </summary>
        UInt16 = 5,

        /// <summary>
        /// A 32 bit signed integer value.
        /// </summary>
        Int32 = 6,

        /// <summary>
        /// A 32 bit unsigned integer value.
        /// </summary>
        UInt32 = 7,

        /// <summary>
        /// A 64 bit signed integer value.
        /// </summary>
        Int64 = 8,

        /// <summary>
        /// A 64 bit unsigned integer value.
        /// </summary>
        UInt64 = 9,

        /// <summary>
        /// An IEEE single precision (32 bit) floating point value.
        /// </summary>
        Float = 10,

        /// <summary>
        /// An IEEE double precision (64 bit) floating point value.
        /// </summary>
        Double = 11,

        /// <summary>
        /// A sequence of Unicode characters.
        /// </summary>
        String = 12,

        /// <summary>
        /// An instance in time.
        /// </summary>
        DateTime = 13,

        /// <summary>
        /// A 128-bit globally unique identifier.
        /// </summary>
        Guid = 14,

        /// <summary>
        /// A sequence of bytes.
        /// </summary>
        ByteString = 15,

        /// <summary>
        /// An XML element.
        /// </summary>
        XmlElement = 16,

        /// <summary>
        /// An identifier for a node in the address space of a UA server.
        /// </summary>
        NodeId = 17,

        /// <summary>
        /// A node id that stores the namespace URI instead of the namespace index.
        /// </summary>
        ExpandedNodeId = 18,

        /// <summary>
        /// A structured result code.
        /// </summary>
        StatusCode = 19,

        /// <summary>
        /// A string qualified with a namespace.
        /// </summary>
        QualifiedName = 20,

        /// <summary>
        /// A localized text string with an locale identifier.
        /// </summary>
        LocalizedText = 21,

        /// <summary>
        /// An opaque object with a syntax that may be unknown to the receiver.
        /// </summary>
        ExtensionObject = 22,

        /// <summary>
        /// A data value with an associated quality and timestamp.
        /// </summary>
        DataValue = 23,

        /// <summary>
        /// Any of the other built-in types.
        /// </summary>
        Variant = 24,

        /// <summary>
        /// A diagnostic information associated with a result code.
        /// </summary>
        DiagnosticInfo = 25,

        /// <remarks>
        /// The following BuiltInTypes are for coding convenience
        /// internally used in the .NET Standard library.
        /// The enumerations are not used for encoding/decoding.
        /// </remarks>

        /// <summary>
        /// Any numeric value.
        /// </summary>
        Number = 26,

        /// <summary>
        /// A signed integer.
        /// </summary>
        Integer = 27,

        /// <summary>
        /// An unsigned integer.
        /// </summary>
        UInteger = 28,

        /// <summary>
        /// An enumerated value
        /// </summary>
        Enumeration = 29
    }

    /// <summary>
    /// Stores information about a type.
    /// </summary>
    public class TypeInfo : IFormattable
    {
        #region Constructors
        /// <summary>
        /// Constructs an unknown type.
        /// </summary>
        internal TypeInfo()
        {
            m_builtInType = BuiltInType.Null;
            m_valueRank = ValueRanks.Any;
        }

        /// <summary>
        /// Construct the object with a built-in type and a value rank.
        /// </summary>
        /// <param name="builtInType">Type of the built in.</param>
        /// <param name="valueRank">The value rank.</param>
        public TypeInfo(BuiltInType builtInType, int valueRank)
        {
            m_builtInType = builtInType;
            m_valueRank = valueRank;
        }
        #endregion

        #region Public Members
        /// <summary>
        /// Returns the data type id that describes a value.
        /// </summary>
        /// <param name="value">The value instance to check the data type.</param>
        /// <returns>An data type identifier for a node in a server's address space.</returns>
        public static NodeId GetDataTypeId(object value)
        {
            if (value == null)
            {
                return Opc.Ua.NodeId.Null;
            }

            NodeId dataTypeId = GetDataTypeId(value.GetType());

            if (dataTypeId == Opc.Ua.NodeId.Null)
            {
                if (value is Matrix matrix)
                {
                    return GetDataTypeId(matrix.TypeInfo);
                }
            }

            return dataTypeId;
        }

        /// <summary>
        /// Returns the data type id that describes a value.
        /// </summary>
        /// <param name="type">The framework type.</param>
        /// <returns>An data type identifier for a node in a server's address space.</returns>
        public static NodeId GetDataTypeId(Type type)
        {
            TypeInfo typeInfo = TypeInfo.Construct(type);

            NodeId dataTypeId = GetDataTypeId(typeInfo);

            if (Opc.Ua.NodeId.IsNull(dataTypeId))
            {
                if (type.GetTypeInfo().IsEnum || (type.IsArray && type.GetElementType().GetTypeInfo().IsEnum))
                {
                    return DataTypes.Enumeration;
                }
            }

            return dataTypeId;
        }

        /// <summary>
        /// Returns the data type id that describes a value.
        /// </summary>
        /// <param name="typeInfo">The type info.</param>
        /// <returns>An data type identifier for a node in a server's address space.</returns>
        public static NodeId GetDataTypeId(TypeInfo typeInfo)
        {
            switch (typeInfo.BuiltInType)
            {
                case BuiltInType.Boolean: { return DataTypeIds.Boolean; }
                case BuiltInType.SByte: { return DataTypeIds.SByte; }
                case BuiltInType.Byte: { return DataTypeIds.Byte; }
                case BuiltInType.Int16: { return DataTypeIds.Int16; }
                case BuiltInType.UInt16: { return DataTypeIds.UInt16; }
                case BuiltInType.Int32: { return DataTypeIds.Int32; }
                case BuiltInType.UInt32: { return DataTypeIds.UInt32; }
                case BuiltInType.Int64: { return DataTypeIds.Int64; }
                case BuiltInType.UInt64: { return DataTypeIds.UInt64; }
                case BuiltInType.Float: { return DataTypeIds.Float; }
                case BuiltInType.Double: { return DataTypeIds.Double; }
                case BuiltInType.String: { return DataTypeIds.String; }
                case BuiltInType.DateTime: { return DataTypeIds.DateTime; }
                case BuiltInType.Guid: { return DataTypeIds.Guid; }
                case BuiltInType.ByteString: { return DataTypeIds.ByteString; }
                case BuiltInType.XmlElement: { return DataTypeIds.XmlElement; }
                case BuiltInType.NodeId: { return DataTypeIds.NodeId; }
                case BuiltInType.ExpandedNodeId: { return DataTypeIds.ExpandedNodeId; }
                case BuiltInType.StatusCode: { return DataTypeIds.StatusCode; }
                case BuiltInType.DiagnosticInfo: { return DataTypeIds.DiagnosticInfo; }
                case BuiltInType.QualifiedName: { return DataTypeIds.QualifiedName; }
                case BuiltInType.LocalizedText: { return DataTypeIds.LocalizedText; }
                case BuiltInType.ExtensionObject: { return DataTypeIds.Structure; }
                case BuiltInType.DataValue: { return DataTypeIds.DataValue; }
                case BuiltInType.Variant: { return DataTypeIds.BaseDataType; }
                case BuiltInType.Number: { return DataTypeIds.Number; }
                case BuiltInType.Integer: { return DataTypeIds.Integer; }
                case BuiltInType.UInteger: { return DataTypeIds.UInteger; }
                case BuiltInType.Enumeration: { return DataTypeIds.Enumeration; }
            }

            return Opc.Ua.NodeId.Null;
        }

        /// <summary>
        /// Returns the array rank for a value.
        /// </summary>
        /// <param name="value">The value instance to check the array rank.</param>
        /// <returns>The array rank of the <paramref name="value"/></returns>
        public static int GetValueRank(object value)
        {
            if (value == null)
            {
                return ValueRanks.Any;
            }

            TypeInfo typeInfo = TypeInfo.Construct(value);

            if (typeInfo.BuiltInType == BuiltInType.Null)
            {
                if (value is Matrix matrix)
                {
                    return matrix.TypeInfo.ValueRank;
                }
            }

            return typeInfo.ValueRank;
        }

        /// <summary>
        /// Returns the array rank for a type.
        /// </summary>
        /// <param name="type">The framework type to check the array rank.</param>
        /// <returns>The array rank of the <paramref name="type"/> </returns>
        public static int GetValueRank(Type type)
        {
            TypeInfo typeInfo = TypeInfo.Construct(type);

            if (typeInfo.BuiltInType == BuiltInType.Null)
            {
                if (type.GetTypeInfo().IsEnum || (type.IsArray && type.GetElementType().GetTypeInfo().IsEnum))
                {
                    if (type.IsArray)
                    {
                        return ValueRanks.OneOrMoreDimensions;
                    }
                    else
                    {
                        return ValueRanks.Scalar;
                    }
                }
            }

            return typeInfo.ValueRank;
        }

        /// <summary>
        /// Returns the BuiltInType type for the DataTypeId.
        /// </summary>
        /// <param name="datatypeId">The data type identifier.</param>
        /// <returns>An <see cref="BuiltInType"/> for  <paramref name="datatypeId"/></returns>
        public static BuiltInType GetBuiltInType(NodeId datatypeId)
        {
            if (datatypeId == null || datatypeId.NamespaceIndex != 0 || datatypeId.IdType != Opc.Ua.IdType.Numeric)
            {
                return BuiltInType.Null;
            }

            return (BuiltInType)Enum.ToObject(typeof(BuiltInType), datatypeId.Identifier);
        }

        /// <summary>
        /// Returns true if the built-in type is a numeric type.
        /// </summary>
        /// <param name="builtInType">The built-in type to check.</param>
        /// <returns>
        /// True if the built-in type is a numeric type.
        /// </returns>
        public static bool IsNumericType(BuiltInType builtInType)
        {
            if (builtInType >= BuiltInType.SByte && builtInType <= BuiltInType.Double)
            {
                return true;
            }

            if (builtInType >= BuiltInType.Number && builtInType <= BuiltInType.UInteger)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Returns true if the built-in type is a type that cannot be null.
        /// </summary>
        /// <param name="builtInType">The built in type to check.</param>
        /// <returns>
        /// True if the built-in type is a type that cannot be null.
        /// </returns>
        public static bool IsValueType(BuiltInType builtInType)
        {
            if (builtInType >= BuiltInType.Boolean && builtInType <= BuiltInType.Double)
            {
                return true;
            }

            if (builtInType == BuiltInType.DateTime || builtInType == BuiltInType.Guid || builtInType == BuiltInType.StatusCode)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Returns true if a 'null' value exists for the built-in type
        /// in all data encodings.
        /// </summary>
        /// <param name="builtInType">The built in type to check.</param>
        /// <returns>
        /// True if the built-in type is a type that is nullable.
        /// </returns>
        public static bool IsEncodingNullableType(BuiltInType builtInType)
        {
            if (builtInType >= BuiltInType.Boolean && builtInType <= BuiltInType.Double)
            {
                return false;
            }

            if (builtInType == BuiltInType.DataValue || builtInType == BuiltInType.DiagnosticInfo)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Returns the BuiltInType type for the DataTypeId.
        /// </summary>
        /// <param name="datatypeId">The data type identyfier for a node in a server's address space..</param>
        /// <param name="typeTree">The type tree for a server. .</param>
        /// <returns>
        /// A <see cref="BuiltInType"/> value for <paramref name="datatypeId"/>
        /// </returns>
        public static BuiltInType GetBuiltInType(NodeId datatypeId, ITypeTable typeTree)
        {
            NodeId typeId = datatypeId;

            while (!Opc.Ua.NodeId.IsNull(typeId))
            {
                if (typeId != null && typeId.NamespaceIndex == 0 && typeId.IdType == Opc.Ua.IdType.Numeric)
                {
                    BuiltInType id = (BuiltInType)(int)(uint)typeId.Identifier;

                    if (id > BuiltInType.Null && id <= BuiltInType.Enumeration && id != BuiltInType.DiagnosticInfo)
                    {
                        return id;
                    }
                }

                if (typeTree == null)
                {
                    break;
                }

                typeId = typeTree.FindSuperType(typeId);
            }

            return BuiltInType.Null;
        }

        /// <summary>
        /// Returns the system type for the datatype.
        /// </summary>
        /// <param name="datatypeId">The datatype id.</param>
        /// <param name="factory">The factory used to store and retrieve underlying OPC UA system types.</param>
        /// <returns>The system type for the <paramref name="datatypeId"/>.</returns>
        public static Type GetSystemType(NodeId datatypeId, EncodeableFactory factory)
        {
            if (datatypeId == null)
            {
                return null;
            }

            if (datatypeId.NamespaceIndex != 0 || datatypeId.IdType != Opc.Ua.IdType.Numeric)
            {
                return factory.GetSystemType(datatypeId);
            }

            switch ((uint)datatypeId.Identifier)
            {
                case DataTypes.Boolean: { return typeof(Boolean); }
                case DataTypes.SByte: { return typeof(SByte); }
                case DataTypes.Byte: { return typeof(Byte); }
                case DataTypes.Int16: { return typeof(Int16); }
                case DataTypes.UInt16: { return typeof(UInt16); }
                case DataTypes.Int32: { return typeof(Int32); }
                case DataTypes.UInt32: { return typeof(UInt32); }
                case DataTypes.Int64: { return typeof(Int64); }
                case DataTypes.UInt64: { return typeof(UInt64); }
                case DataTypes.Float: { return typeof(Single); }
                case DataTypes.Double: { return typeof(Double); }
                case DataTypes.String: { return typeof(String); }
                case DataTypes.DateTime: { return typeof(DateTime); }
                case DataTypes.Guid: { return typeof(Uuid); }
                case DataTypes.ByteString: { return typeof(Byte[]); }
                case DataTypes.XmlElement: { return typeof(XmlElement); }
                case DataTypes.NodeId: { return typeof(NodeId); }
                case DataTypes.ExpandedNodeId: { return typeof(ExpandedNodeId); }
                case DataTypes.StatusCode: { return typeof(StatusCode); }
                case DataTypes.DiagnosticInfo: { return typeof(DiagnosticInfo); }
                case DataTypes.QualifiedName: { return typeof(QualifiedName); }
                case DataTypes.LocalizedText: { return typeof(LocalizedText); }
                case DataTypes.DataValue: { return typeof(DataValue); }
                case DataTypes.BaseDataType: { return typeof(Variant); }
                case DataTypes.Structure: { return typeof(ExtensionObject); }
                case DataTypes.Number: { return typeof(Variant); }
                case DataTypes.Integer: { return typeof(Variant); }
                case DataTypes.UInteger: { return typeof(Variant); }
                case DataTypes.Enumeration: { return typeof(Int32); }

                // subtype of DateTime
                case DataTypes.Date: 
                case DataTypes.UtcTime: goto case DataTypes.DateTime;
                // subtype of ByteString
                case DataTypes.ApplicationInstanceCertificate:
                case DataTypes.AudioDataType:
                case DataTypes.ContinuationPoint:
                case DataTypes.Image:
                case DataTypes.ImageBMP:
                case DataTypes.ImageGIF:
                case DataTypes.ImageJPG:
                case DataTypes.ImagePNG: goto case DataTypes.ByteString;
                // subtype of NodeId
                case DataTypes.SessionAuthenticationToken: goto case DataTypes.NodeId;
                // subtype of Double
                case DataTypes.Duration: goto case DataTypes.Double;
                // subtype of UInt32
                case DataTypes.IntegerId:
                case DataTypes.Index:
                case DataTypes.VersionTime:
                case DataTypes.Counter: goto case DataTypes.UInt32;
                // subtype of UInt64
                case DataTypes.BitFieldMaskDataType: goto case DataTypes.UInt64;
                // subtype of String
                case DataTypes.DateString:
                case DataTypes.DecimalString:
                case DataTypes.DurationString:
                case DataTypes.LocaleId:
                case DataTypes.NormalizedString:
                case DataTypes.NumericRange:
                case DataTypes.Time:
                case DataTypes.TimeString: goto case DataTypes.String;
            }

            return factory.GetSystemType(datatypeId);
        }

        /// <summary>
        /// A constant representing an unknown type.
        /// </summary>
        /// <value>The constant representing an unknown type.</value>
        public static TypeInfo Unknown => s_Unknown;

        /// <summary>
        /// The built-in type.
        /// </summary>
        /// <value>The type of the type represented by this instance.</value>
        public BuiltInType BuiltInType => m_builtInType;

        /// <summary>
        /// The value rank.
        /// </summary>
        /// <value>The value rank of the type represented by this instance.</value>
        public int ValueRank => m_valueRank;

        /// <summary>
        /// Returns the type info if the value is an instance of the data type with the specified value rank.
        /// </summary>
        /// <param name="value">The value instance to check.</param>
        /// <param name="expectedDataTypeId">The expected data type identifier for a node.</param>
        /// <param name="expectedValueRank">The expected value rank.</param>
        /// <param name="namespaceUris">The namespace URI's.</param>
        /// <param name="typeTree">The type tree for a server.</param>
        /// <returns>
        /// An data type info if the value is an instance of the data type with the specified value rank; otherwise <c>null</c>.
        /// </returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public static TypeInfo IsInstanceOfDataType(
            object value,
            NodeId expectedDataTypeId,
            int expectedValueRank,
            NamespaceTable namespaceUris,
            ITypeTable typeTree)
        {
            BuiltInType expectedType = BuiltInType.Null;

            // get the type info.
            TypeInfo typeInfo = Construct(value);

            if (typeInfo.BuiltInType == BuiltInType.Null)
            {
                expectedType = TypeInfo.GetBuiltInType(expectedDataTypeId, typeTree);

                // nulls allowed for all array types.
                if (expectedValueRank != ValueRanks.Scalar)
                {
                    return new TypeInfo(expectedType, ValueRanks.OneDimension);
                }

                // check if the type supports nulls.
                switch (expectedType)
                {
                    case BuiltInType.String:
                    case BuiltInType.ByteString:
                    case BuiltInType.XmlElement:
                    case BuiltInType.NodeId:
                    case BuiltInType.ExpandedNodeId:
                    case BuiltInType.LocalizedText:
                    case BuiltInType.QualifiedName:
                    case BuiltInType.DataValue:
                    case BuiltInType.Variant:
                    case BuiltInType.ExtensionObject:
                    {
                        return new TypeInfo(expectedType, ValueRanks.Scalar);
                    }
                }

                // nulls not allowed.
                return null;
            }

            // A ByteString is equivalent to an Array of Bytes.
            if (typeInfo.BuiltInType == BuiltInType.ByteString && typeInfo.ValueRank == ValueRanks.Scalar)
            {
                if (expectedValueRank == ValueRanks.OneOrMoreDimensions || expectedValueRank == ValueRanks.OneDimension)
                {
                    if (typeTree.IsTypeOf(expectedDataTypeId, DataTypes.Byte))
                    {
                        return typeInfo;
                    }

                    return null;
                }
            }

            // check the value rank.
            if (!ValueRanks.IsValid(typeInfo.ValueRank, expectedValueRank))
            {
                return null;
            }

            // check for special predefined types.
            if (expectedDataTypeId.IdType == IdType.Numeric && expectedDataTypeId.NamespaceIndex == 0)
            {
                BuiltInType actualType = typeInfo.BuiltInType;

                switch ((uint)expectedDataTypeId.Identifier)
                {
                    case DataTypes.Number:
                    {
                        switch (actualType)
                        {
                            case BuiltInType.SByte:
                            case BuiltInType.Int16:
                            case BuiltInType.Int32:
                            case BuiltInType.Int64:
                            case BuiltInType.Byte:
                            case BuiltInType.UInt16:
                            case BuiltInType.UInt32:
                            case BuiltInType.UInt64:
                            case BuiltInType.Double:
                            case BuiltInType.Float:
                            {
                                return typeInfo;
                            }

                            case BuiltInType.Variant:
                            {
                                if (typeInfo.ValueRank == ValueRanks.Scalar)
                                {
                                    return null;
                                }

                                break;
                            }

                            default:
                            {
                                return null;
                            }
                        }

                        break;
                    }

                    case DataTypes.Integer:
                    {
                        switch (actualType)
                        {
                            case BuiltInType.SByte:
                            case BuiltInType.Int16:
                            case BuiltInType.Int32:
                            case BuiltInType.Int64:
                            {
                                return typeInfo;
                            }

                            case BuiltInType.Variant:
                            {
                                if (typeInfo.ValueRank == ValueRanks.Scalar)
                                {
                                    return null;
                                }

                                break;
                            }

                            default:
                            {
                                return null;
                            }
                        }

                        break;
                    }

                    case DataTypes.UInteger:
                    {
                        switch (actualType)
                        {
                            case BuiltInType.Byte:
                            case BuiltInType.UInt16:
                            case BuiltInType.UInt32:
                            case BuiltInType.UInt64:
                            {
                                return typeInfo;
                            }

                            case BuiltInType.Variant:
                            {
                                if (typeInfo.ValueRank == ValueRanks.Scalar)
                                {
                                    return null;
                                }

                                break;
                            }

                            default:
                            {
                                return null;
                            }
                        }

                        break;
                    }

                    case DataTypes.Enumeration:
                    {
                        if (typeInfo.BuiltInType == BuiltInType.Int32)
                        {
                            return typeInfo;
                        }

                        return null;
                    }

                    case DataTypes.Structure:
                    {
                        if (typeInfo.BuiltInType == BuiltInType.ExtensionObject)
                        {
                            return typeInfo;
                        }

                        return null;
                    }

                    case DataTypes.BaseDataType:
                    {
                        if (typeInfo.BuiltInType != BuiltInType.Variant)
                        {
                            return typeInfo;
                        }

                        break;
                    }
                }
            }

            // check simple types.
            if (typeInfo.BuiltInType != BuiltInType.ExtensionObject && typeInfo.BuiltInType != BuiltInType.Variant)
            {
                if (typeTree.IsTypeOf(expectedDataTypeId, new NodeId((uint)(int)typeInfo.BuiltInType)))
                {
                    return typeInfo;
                }

                // check for enumerations.
                if (typeInfo.BuiltInType == BuiltInType.Int32)
                {
                    if (typeTree.IsTypeOf(expectedDataTypeId, DataTypes.Enumeration))
                    {
                        return typeInfo;
                    }
                }

                // check for direct subtypes of BaseDataType.
                if (GetBuiltInType(expectedDataTypeId, typeTree) == BuiltInType.Variant)
                {
                    return typeInfo;
                }

                return null;
            }


            // handle scalar.
            if (typeInfo.ValueRank < 0)
            {
                // check extension objects vs. expected type.
                if (typeInfo.BuiltInType == BuiltInType.ExtensionObject)
                {
                    expectedType = GetBuiltInType(expectedDataTypeId, typeTree);

                    if (expectedType == BuiltInType.Variant)
                    {
                        return typeInfo;
                    }

                    if (expectedType != BuiltInType.ExtensionObject)
                    {
                        return null;
                    }
                }

                // expected type is extension object so compare type tree.
                NodeId actualDataTypeId = typeInfo.GetDataTypeId(value, namespaceUris, typeTree);

                if (typeTree.IsTypeOf(actualDataTypeId, expectedDataTypeId))
                {
                    return typeInfo;
                }

                return null;
            }
            // check every element in the array or matrix.     
            if (array == null)
            {
                if (value is Matrix matrix)
                {
                    array = matrix.Elements;
                }
            }

            if (value is Array array)
            {
                BuiltInType expectedElementType = TypeInfo.GetBuiltInType(expectedDataTypeId, typeTree);
                BuiltInType actualElementType = GetBuiltInType(array.GetType().GetElementType().Name);
                // system type of array matches the expected type - nothing more to do.
                if (actualElementType != BuiltInType.ExtensionObject && actualElementType == expectedElementType)
                {
                    return typeInfo;
                }

                // check for variant arrays.
                if (expectedElementType == BuiltInType.Variant)
                {
                    return typeInfo;
                }

                // have to do it the hard way and check each element.
                int[] dimensions = new int[array.Rank];

                for (int ii = 0; ii < dimensions.Length; ii++)
                {
                    dimensions[ii] = array.GetLength(ii);
                }

                int[] indexes = new int[dimensions.Length];

                for (int ii = 0; ii < array.Length; ii++)
                {
                    int divisor = array.Length;

                    for (int jj = 0; jj < indexes.Length; jj++)
                    {
                        divisor /= dimensions[jj];
                        indexes[jj] = (ii / divisor) % dimensions[jj];
                    }

                    object element = array.GetValue(indexes);

                    if (actualElementType == BuiltInType.Variant)
                    {
                        element = ((Variant)element).Value;
                    }

                    TypeInfo elementInfo = TypeInfo.IsInstanceOfDataType(
                        element,
                        expectedDataTypeId,
                        ValueRanks.Scalar,
                        namespaceUris,
                        typeTree);

                    // give up at the first invalid element.
                    if (elementInfo == null)
                    {
                        return null;
                    }
                }

                // all elements valid.
                return typeInfo;
            }

            return null;
        }

        /// <summary>
        /// Returns the data type id that describes a value.
        /// </summary>
        /// <param name="value">The value to describe.</param>
        /// <param name="namespaceUris">The namespace uris.</param>
        /// <param name="typeTree">The type tree for a server.</param>
        /// <returns>Returns the data type identifier that describes a value.</returns>
        public NodeId GetDataTypeId(object value, NamespaceTable namespaceUris, ITypeTable typeTree)
        {
            if (BuiltInType == BuiltInType.Null)
            {
                return NodeId.Null;
            }

            if (BuiltInType == BuiltInType.ExtensionObject)
            {
                if (value is IEncodeable encodeable)
                {
                    return ExpandedNodeId.ToNodeId(encodeable.TypeId, namespaceUris);
                }

                if (value is ExtensionObject extension)
                {
                    encodeable = extension.Body as IEncodeable;
                    if (value is IEncodeable encodeable)
                    {
                        return ExpandedNodeId.ToNodeId(encodeable.TypeId, namespaceUris);
                    }

                    return typeTree.FindDataTypeId(extension.TypeId);
                }

                return DataTypes.Structure;
            }

            return new NodeId((uint)(int)BuiltInType);
        }

        /// <summary>
        /// Returns the system type a scalar or array instance of the built-in type.
        /// </summary>
        /// <param name="builtInType">A built-in type.</param>
        /// <param name="valueRank">The value rank.</param>
        /// <returns>A system type equivalent to the built-in type.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public static Type GetSystemType(BuiltInType builtInType, int valueRank)
        {
            if (valueRank == ValueRanks.Scalar)
            {
                switch (builtInType)
                {
                    case BuiltInType.Boolean: return typeof(bool);
                    case BuiltInType.SByte: return typeof(sbyte);
                    case BuiltInType.Byte: return typeof(byte);
                    case BuiltInType.Int16: return typeof(short);
                    case BuiltInType.UInt16: return typeof(ushort);
                    case BuiltInType.Int32: return typeof(int);
                    case BuiltInType.UInt32: return typeof(uint);
                    case BuiltInType.Int64: return typeof(long);
                    case BuiltInType.UInt64: return typeof(ulong);
                    case BuiltInType.Float: return typeof(float);
                    case BuiltInType.Double: return typeof(double);
                    case BuiltInType.String: return typeof(string);
                    case BuiltInType.DateTime: return typeof(DateTime);
                    case BuiltInType.Guid: return typeof(Uuid);
                    case BuiltInType.ByteString: return typeof(byte[]);
                    case BuiltInType.XmlElement: return typeof(XmlElement);
                    case BuiltInType.NodeId: return typeof(NodeId);
                    case BuiltInType.ExpandedNodeId: return typeof(ExpandedNodeId);
                    case BuiltInType.LocalizedText: return typeof(LocalizedText);
                    case BuiltInType.QualifiedName: return typeof(QualifiedName);
                    case BuiltInType.StatusCode: return typeof(StatusCode);
                    case BuiltInType.DiagnosticInfo: return typeof(DiagnosticInfo);
                    case BuiltInType.DataValue: return typeof(DataValue);
                    case BuiltInType.Variant: return typeof(Variant);
                    case BuiltInType.ExtensionObject: return typeof(ExtensionObject);
                    case BuiltInType.Enumeration: return typeof(int);
                    case BuiltInType.Number: return typeof(Variant);
                    case BuiltInType.Integer: return typeof(Variant);
                    case BuiltInType.UInteger: return typeof(Variant);
                }
            }

            else if (valueRank == ValueRanks.OneDimension)
            {
                switch (builtInType)
                {
                    case BuiltInType.Boolean: return typeof(bool[]);
                    case BuiltInType.SByte: return typeof(sbyte[]);
                    case BuiltInType.Byte: return typeof(byte[]);
                    case BuiltInType.Int16: return typeof(short[]);
                    case BuiltInType.UInt16: return typeof(ushort[]);
                    case BuiltInType.Int32: return typeof(int[]);
                    case BuiltInType.UInt32: return typeof(uint[]);
                    case BuiltInType.Int64: return typeof(long[]);
                    case BuiltInType.UInt64: return typeof(ulong[]);
                    case BuiltInType.Float: return typeof(float[]);
                    case BuiltInType.Double: return typeof(double[]);
                    case BuiltInType.String: return typeof(string[]);
                    case BuiltInType.DateTime: return typeof(DateTime[]);
                    case BuiltInType.Guid: return typeof(Uuid[]);
                    case BuiltInType.ByteString: return typeof(byte[][]);
                    case BuiltInType.XmlElement: return typeof(XmlElement[]);
                    case BuiltInType.NodeId: return typeof(NodeId[]);
                    case BuiltInType.ExpandedNodeId: return typeof(ExpandedNodeId[]);
                    case BuiltInType.LocalizedText: return typeof(LocalizedText[]);
                    case BuiltInType.QualifiedName: return typeof(QualifiedName[]);
                    case BuiltInType.StatusCode: return typeof(StatusCode[]);
                    case BuiltInType.DiagnosticInfo: return typeof(DiagnosticInfo[]);
                    case BuiltInType.DataValue: return typeof(DataValue[]);
                    case BuiltInType.Variant: return typeof(Variant[]);
                    case BuiltInType.ExtensionObject: return typeof(ExtensionObject[]);
                    case BuiltInType.Enumeration: return typeof(int[]);
                    case BuiltInType.Number: return typeof(Variant[]);
                    case BuiltInType.Integer: return typeof(Variant[]);
                    case BuiltInType.UInteger: return typeof(Variant[]);
                }
            }

            else if (valueRank == ValueRanks.TwoDimensions)
            {
                switch (builtInType)
                {
                    case BuiltInType.Boolean: return typeof(bool[,]);
                    case BuiltInType.SByte: return typeof(sbyte[,]);
                    case BuiltInType.Byte: return typeof(byte[,]);
                    case BuiltInType.Int16: return typeof(short[,]);
                    case BuiltInType.UInt16: return typeof(ushort[,]);
                    case BuiltInType.Int32: return typeof(int[,]);
                    case BuiltInType.UInt32: return typeof(uint[,]);
                    case BuiltInType.Int64: return typeof(long[,]);
                    case BuiltInType.UInt64: return typeof(ulong[,]);
                    case BuiltInType.Float: return typeof(float[,]);
                    case BuiltInType.Double: return typeof(double[,]);
                    case BuiltInType.String: return typeof(string[,]);
                    case BuiltInType.DateTime: return typeof(DateTime[,]);
                    case BuiltInType.Guid: return typeof(Uuid[,]);
                    case BuiltInType.ByteString: return typeof(byte[,][]);
                    case BuiltInType.XmlElement: return typeof(XmlElement[,]);
                    case BuiltInType.NodeId: return typeof(NodeId[,]);
                    case BuiltInType.ExpandedNodeId: return typeof(ExpandedNodeId[,]);
                    case BuiltInType.LocalizedText: return typeof(LocalizedText[,]);
                    case BuiltInType.QualifiedName: return typeof(QualifiedName[,]);
                    case BuiltInType.StatusCode: return typeof(StatusCode[,]);
                    case BuiltInType.DiagnosticInfo: return typeof(DiagnosticInfo[,]);
                    case BuiltInType.DataValue: return typeof(DataValue[,]);
                    case BuiltInType.Variant: return typeof(Variant[,]);
                    case BuiltInType.ExtensionObject: return typeof(ExtensionObject[,]);
                    case BuiltInType.Enumeration: return typeof(int[,]);
                    case BuiltInType.Number: return typeof(Variant[,]);
                    case BuiltInType.Integer: return typeof(Variant[,]);
                    case BuiltInType.UInteger: return typeof(Variant[,]);
                }
            }

            return typeof(Variant);
        }

        /// <summary>
        /// Returns the type info for the provided value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns><see cref="TypeInfo"/> instance storing information about the <paramref name="value"/> type.</returns>
        public static TypeInfo Construct(object value)
        {
            if (value == null)
            {
                return TypeInfo.Unknown;
            }

            TypeInfo typeInfo = Construct(value.GetType());

            // check for instances of matrixes.
            if (typeInfo.BuiltInType == BuiltInType.Null)
            {
                if (value is Matrix matrix)
                {
                    return matrix.TypeInfo;
                }
            }

            return typeInfo;
        }

        /// <summary>
        /// Returns the type info for the specified system type.
        /// </summary>
        /// <param name="systemType">The specified system (framework) type.</param>
        /// <returns><see cref="TypeInfo"/> instance storing information equivalent to the <paramref name="systemType"/> type.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public static TypeInfo Construct(Type systemType)
        {
            // check for null.
            if (systemType == null)
            {
                return TypeInfo.Unknown;
            }

            // using strings in switch statements is much faster than the typeof() operator.
            string name = systemType.Name;

            // parse array types.
            string dimensions = null;

            if (name[name.Length - 1] == ']')
            {
                int index = name.IndexOf('[');

                if (index != -1)
                {
                    dimensions = name.Substring(index);
                    name = name.Substring(0, index);
                }
            }

            // handle scalar.
            if (dimensions == null)
            {
                BuiltInType builtInType = GetBuiltInType(name);

                if (builtInType != BuiltInType.Null)
                {
                    return new TypeInfo(builtInType, ValueRanks.Scalar);
                }

                if (systemType.GetTypeInfo().IsEnum)
                {
                    return new TypeInfo(BuiltInType.Enumeration, ValueRanks.Scalar);
                }

                // check for collection.
                if (name.EndsWith("Collection", StringComparison.Ordinal))
                {
                    builtInType = GetBuiltInType(name.Substring(0, name.Length - "Collection".Length));

                    if (builtInType != BuiltInType.Null)
                    {
                        return new TypeInfo(builtInType, ValueRanks.OneDimension);
                    }

                    // check for encodeable object.
                    if (systemType.GetTypeInfo().BaseType.GetTypeInfo().IsGenericType)
                    {
                        return Construct(systemType.GetTypeInfo().BaseType);
                    }

                    return TypeInfo.Unknown;
                }

                // check for generic type.                
                if (systemType.GetTypeInfo().IsGenericType)
                {
                    Type[] argTypes = systemType.GetGenericArguments();

                    if (argTypes != null && argTypes.Length == 1)
                    {
                        TypeInfo typeInfo = Construct(argTypes[0]);

                        if (typeInfo.BuiltInType != BuiltInType.Null && typeInfo.ValueRank == ValueRanks.Scalar)
                        {
                            return new TypeInfo(typeInfo.BuiltInType, ValueRanks.OneDimension);
                        }
                    }

                    return TypeInfo.Unknown;
                }

                // check for encodeable object.
                if (typeof(IEncodeable).GetTypeInfo().IsAssignableFrom(systemType.GetTypeInfo()) || name == "IEncodeable")
                {
                    return new TypeInfo(BuiltInType.ExtensionObject, ValueRanks.Scalar);
                }

                return TypeInfo.Unknown;
            }

            // handle one dimensional array.
            if (dimensions.Length == 2)
            {
                BuiltInType builtInType = GetBuiltInType(name);

                if (builtInType == BuiltInType.Byte)
                {
                    return new TypeInfo(BuiltInType.ByteString, ValueRanks.Scalar);
                }

                if (builtInType != BuiltInType.Null)
                {
                    return new TypeInfo(builtInType, ValueRanks.OneDimension);
                }

                // check for encodeable object.
                if (typeof(IEncodeable).GetTypeInfo().IsAssignableFrom(systemType.GetElementType().GetTypeInfo()) || name == "IEncodeable")
                {
                    return new TypeInfo(BuiltInType.ExtensionObject, ValueRanks.OneDimension);
                }

                if (systemType.GetTypeInfo().GetElementType().IsEnum)
                {
                    return new TypeInfo(BuiltInType.Enumeration, ValueRanks.OneDimension);
                }

                return TypeInfo.Unknown;
            }

            // count the number of dimensions (syntax is [,] - commas+1 is the number of dimensions).
            int count = 1;

            for (int ii = 1; ii < dimensions.Length - 1; ii++)
            {
                if (dimensions[ii] == ',')
                {
                    count++;
                }
            }

            // handle simple multi-dimensional array (enclosing [] + number of commas)
            if (count + 1 == dimensions.Length)
            {
                BuiltInType builtInType = GetBuiltInType(name);

                if (builtInType != BuiltInType.Null)
                {
                    return new TypeInfo(builtInType, count);
                }

                // check for encodeable object.
                if (typeof(IEncodeable).GetTypeInfo().IsAssignableFrom(systemType.GetTypeInfo()) || name == "IEncodeable")
                {
                    return new TypeInfo(BuiltInType.ExtensionObject, count);
                }

                return TypeInfo.Unknown;
            }

            // handle multi-dimensional array of byte strings.
            if (dimensions[1] == ']')
            {
                // syntax of type is [][,,,] - adding three checks for the middle ']['
                if (name == "Byte" && count + 3 == dimensions.Length)
                {
                    return new TypeInfo(BuiltInType.ByteString, count);
                }
            }

            // unknown type.   
            return TypeInfo.Unknown;
        }

        /// <summary>
        /// Returns the default value for the specified built-in type.
        /// </summary>
        /// <param name="type">The Built-in type.</param>
        /// <returns>The default value.</returns>
        public static object GetDefaultValue(BuiltInType type)
        {
            switch (type)
            {
                case BuiltInType.Boolean: { return false; }
                case BuiltInType.SByte: { return (sbyte)0; }
                case BuiltInType.Byte: { return (byte)0; }
                case BuiltInType.Int16: { return (short)0; }
                case BuiltInType.UInt16: { return (ushort)0; }
                case BuiltInType.Int32: { return (int)0; }
                case BuiltInType.UInt32: { return (uint)0; }
                case BuiltInType.Int64: { return (long)0; }
                case BuiltInType.UInt64: { return (ulong)0; }
                case BuiltInType.Float: { return (float)0; }
                case BuiltInType.Double: { return (double)0; }
                case BuiltInType.String: { return null; }
                case BuiltInType.DateTime: { return DateTime.MinValue; }
                case BuiltInType.Guid: { return Uuid.Empty; }
                case BuiltInType.ByteString: { return null; }
                case BuiltInType.XmlElement: { return null; }
                case BuiltInType.StatusCode: { return new StatusCode(StatusCodes.Good); }
                case BuiltInType.NodeId: { return NodeId.Null; }
                case BuiltInType.ExpandedNodeId: { return ExpandedNodeId.Null; }
                case BuiltInType.QualifiedName: { return QualifiedName.Null; }
                case BuiltInType.LocalizedText: { return LocalizedText.Null; }
                case BuiltInType.Variant: { return Variant.Null; }
                case BuiltInType.DataValue: { return null; }
                case BuiltInType.Enumeration: { return (int)0; }
                case BuiltInType.Number: { return (double)0; }
                case BuiltInType.Integer: { return (long)0; }
                case BuiltInType.UInteger: { return (ulong)0; }
            }

            return null;
        }

        /// <summary>
        /// Returns the default value for the specified data type and value rank.
        /// </summary>
        /// <param name="dataType">The data type.</param>
        /// <param name="valueRank">The value rank.</param>
        /// <returns>The default value.</returns>
        public static object GetDefaultValue(NodeId dataType, int valueRank)
        {
            return GetDefaultValue(dataType, valueRank, null);
        }

        /// <summary>
        /// Returns the default value for the specified data type and value rank.
        /// </summary>
        /// <param name="dataType">The data type.</param>
        /// <param name="valueRank">The value rank.</param>
        /// <param name="typeTree">The type tree for a server.</param>
        /// <returns>A default value.</returns>
        public static object GetDefaultValue(NodeId dataType, int valueRank, ITypeTable typeTree)
        {
            if (valueRank != ValueRanks.Scalar)
            {
                return null;
            }

            BuiltInType builtInType = BuiltInType.Null;

            if (dataType != null && dataType.IdType == IdType.Numeric && dataType.NamespaceIndex == 0)
            {
                uint id = (uint)dataType.Identifier;

                // if we want an array then go into a loop
                if (id <= DataTypes.DiagnosticInfo)
                {
                    return GetDefaultValue((BuiltInType)(int)id);
                }

                switch (id)
                {
                    case DataTypes.Duration: { return (double)0; }
                    case DataTypes.Date: { return DateTime.MinValue; }
                    case DataTypes.UtcTime: { return DateTime.MinValue; }
                    case DataTypes.Counter: { return (uint)0; }
                    case DataTypes.IntegerId: { return (uint)0; }
                    case DataTypes.Number: { return (double)0; }
                    case DataTypes.UInteger: { return (ulong)0; }
                    case DataTypes.Integer: { return (long)0; }
                    case DataTypes.IdType: { return (int)IdType.Numeric; }
                    case DataTypes.NodeClass: { return (int)NodeClass.Unspecified; }
                    case DataTypes.Enumeration: { return (int)0; }
                }
            }

            builtInType = GetBuiltInType(dataType, typeTree);

            if (builtInType != BuiltInType.Null)
            {
                return GetDefaultValue(builtInType);
            }

            return null;
        }

        /// <summary>
        /// Returns the default value for the specified built-in type.
        /// </summary>
        /// <param name="type">The built-in type.</param>
        /// <param name="dimensions">The dimensions.</param>
        /// <returns>The default value for the specified built-in type</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2208:InstantiateArgumentExceptionsCorrectly"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public static Array CreateArray(BuiltInType type, params int[] dimensions)
        {
            if (dimensions == null || dimensions.Length == 0)
            {
                throw new ArgumentOutOfRangeException("Array dimensions must be specifed.");
            }

            int length = dimensions[0];

            // create one dimensional array.
            if (dimensions.Length == 1)
            {
                switch (type)
                {
                    case BuiltInType.Null: { return new object[length]; }
                    case BuiltInType.Boolean: { return new bool[length]; }
                    case BuiltInType.SByte: { return new sbyte[length]; }
                    case BuiltInType.Byte: { return new byte[length]; }
                    case BuiltInType.Int16: { return new short[length]; }
                    case BuiltInType.UInt16: { return new ushort[length]; }
                    case BuiltInType.Int32: { return new int[length]; }
                    case BuiltInType.UInt32: { return new uint[length]; }
                    case BuiltInType.Int64: { return new long[length]; }
                    case BuiltInType.UInt64: { return new ulong[length]; }
                    case BuiltInType.Float: { return new float[length]; }
                    case BuiltInType.Double: { return new double[length]; }
                    case BuiltInType.String: { return new string[length]; }
                    case BuiltInType.DateTime: { return new DateTime[length]; }
                    case BuiltInType.Guid: { return new Uuid[length]; }
                    case BuiltInType.ByteString: { return new byte[length][]; }
                    case BuiltInType.XmlElement: { return new XmlElement[length]; }
                    case BuiltInType.StatusCode: { return new StatusCode[length]; }
                    case BuiltInType.NodeId: { return new NodeId[length]; }
                    case BuiltInType.ExpandedNodeId: { return new ExpandedNodeId[length]; }
                    case BuiltInType.QualifiedName: { return new QualifiedName[length]; }
                    case BuiltInType.LocalizedText: { return new LocalizedText[length]; }
                    case BuiltInType.Variant: { return new Variant[length]; }
                    case BuiltInType.DataValue: { return new DataValue[length]; }
                    case BuiltInType.ExtensionObject: { return new ExtensionObject[length]; }
                    case BuiltInType.DiagnosticInfo: { return new DiagnosticInfo[length]; }
                    case BuiltInType.Enumeration: { return new int[length]; }
                    case BuiltInType.Number: { return new Variant[length]; }
                    case BuiltInType.Integer: { return new Variant[length]; }
                    case BuiltInType.UInteger: { return new Variant[length]; }
                }
            }

            // create higher dimension arrays.
            else
            {
                switch (type)
                {
                    case BuiltInType.Null: { return Array.CreateInstance(typeof(object), dimensions); }
                    case BuiltInType.Boolean: { return Array.CreateInstance(typeof(bool), dimensions); }
                    case BuiltInType.SByte: { return Array.CreateInstance(typeof(sbyte), dimensions); }
                    case BuiltInType.Byte: { return Array.CreateInstance(typeof(byte), dimensions); }
                    case BuiltInType.Int16: { return Array.CreateInstance(typeof(short), dimensions); }
                    case BuiltInType.UInt16: { return Array.CreateInstance(typeof(ushort), dimensions); }
                    case BuiltInType.Int32: { return Array.CreateInstance(typeof(int), dimensions); }
                    case BuiltInType.UInt32: { return Array.CreateInstance(typeof(uint), dimensions); }
                    case BuiltInType.Int64: { return Array.CreateInstance(typeof(long), dimensions); }
                    case BuiltInType.UInt64: { return Array.CreateInstance(typeof(ulong), dimensions); }
                    case BuiltInType.Float: { return Array.CreateInstance(typeof(float), dimensions); }
                    case BuiltInType.Double: { return Array.CreateInstance(typeof(double), dimensions); }
                    case BuiltInType.String: { return Array.CreateInstance(typeof(string), dimensions); }
                    case BuiltInType.DateTime: { return Array.CreateInstance(typeof(DateTime), dimensions); }
                    case BuiltInType.Guid: { return Array.CreateInstance(typeof(Uuid), dimensions); }
                    case BuiltInType.ByteString: { return Array.CreateInstance(typeof(byte[]), dimensions); }
                    case BuiltInType.XmlElement: { return Array.CreateInstance(typeof(XmlElement), dimensions); }
                    case BuiltInType.StatusCode: { return Array.CreateInstance(typeof(StatusCode), dimensions); }
                    case BuiltInType.NodeId: { return Array.CreateInstance(typeof(NodeId), dimensions); }
                    case BuiltInType.ExpandedNodeId: { return Array.CreateInstance(typeof(ExpandedNodeId), dimensions); }
                    case BuiltInType.QualifiedName: { return Array.CreateInstance(typeof(QualifiedName), dimensions); }
                    case BuiltInType.LocalizedText: { return Array.CreateInstance(typeof(LocalizedText), dimensions); }
                    case BuiltInType.Variant: { return Array.CreateInstance(typeof(Variant), dimensions); }
                    case BuiltInType.DataValue: { return Array.CreateInstance(typeof(DataValue), dimensions); }
                    case BuiltInType.ExtensionObject: { return Array.CreateInstance(typeof(ExtensionObject), dimensions); }
                    case BuiltInType.DiagnosticInfo: { return Array.CreateInstance(typeof(DiagnosticInfo), dimensions); }
                    case BuiltInType.Enumeration: { return Array.CreateInstance(typeof(int), dimensions); }
                    case BuiltInType.Number: { return Array.CreateInstance(typeof(Variant), dimensions); }
                    case BuiltInType.Integer: { return Array.CreateInstance(typeof(Variant), dimensions); }
                    case BuiltInType.UInteger: { return Array.CreateInstance(typeof(Variant), dimensions); }
                }
            }

            // should never happen.
            return null;
        }

        /// <summary>
        /// Casts a value to the specified target type.
        /// </summary>
        /// <param name="source">The instance of a source value.</param>
        /// <param name="targetType">Type of the target.</param>
        /// <returns>Return casted value.<see cref="DBNull"/></returns>
        /// <exception cref="InvalidCastException">if imposible to cast.</exception>
        public static object Cast(object source, BuiltInType targetType)
        {
            return Cast(source, TypeInfo.Construct(source), targetType);
        }

        /// <summary>
        /// Casts a value to the specified target type.
        /// </summary>
        /// <param name="source">The instance of a source value.</param>
        /// <param name="sourceType">Type of the source.</param>
        /// <param name="targetType">Type of the target.</param>
        /// <returns>Return casted value.</returns>
        /// <exception cref="InvalidCastException">if imposible to cast.</exception>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public static object Cast(object source, TypeInfo sourceType, BuiltInType targetType)
        {
            // null always casts to null.
            if (sourceType.BuiltInType == BuiltInType.Null)
            {
                return null;
            }

            // check for trivial case.
            if (sourceType.BuiltInType == targetType)
            {
                return source;
            }

            // check for trivial case.
            if (targetType == BuiltInType.Variant && sourceType.ValueRank < 0)
            {
                return new Variant(source);
            }

            // check for guid.
            if (sourceType.BuiltInType == BuiltInType.Guid)
            {
                source = Cast<Uuid>(source, sourceType, ToGuid);
            }

            switch (targetType)
            {
                case BuiltInType.Boolean: return Cast<bool>(source, sourceType, ToBoolean);
                case BuiltInType.SByte: return Cast<sbyte>(source, sourceType, ToSByte);
                case BuiltInType.Byte: return Cast<byte>(source, sourceType, ToByte);
                case BuiltInType.Int16: return Cast<short>(source, sourceType, ToInt16);
                case BuiltInType.UInt16: return Cast<ushort>(source, sourceType, ToUInt16);
                case BuiltInType.Int32: return Cast<int>(source, sourceType, ToInt32);
                case BuiltInType.UInt32: return Cast<uint>(source, sourceType, ToUInt32);
                case BuiltInType.Int64: return Cast<long>(source, sourceType, ToInt64);
                case BuiltInType.UInt64: return Cast<ulong>(source, sourceType, ToUInt64);
                case BuiltInType.Float: return Cast<float>(source, sourceType, ToFloat);
                case BuiltInType.Double: return Cast<double>(source, sourceType, ToDouble);
                case BuiltInType.String: return Cast<string>(source, sourceType, ToString);
                case BuiltInType.DateTime: return Cast<DateTime>(source, sourceType, ToDateTime);
                case BuiltInType.Guid: return Cast<Uuid>(source, sourceType, ToGuid);
                case BuiltInType.ByteString: return Cast<byte[]>(source, sourceType, ToByteString);
                case BuiltInType.NodeId: return Cast<NodeId>(source, sourceType, ToNodeId);
                case BuiltInType.ExpandedNodeId: return Cast<ExpandedNodeId>(source, sourceType, ToExpandedNodeId);
                case BuiltInType.StatusCode: return Cast<StatusCode>(source, sourceType, ToStatusCode);
                case BuiltInType.QualifiedName: return Cast<QualifiedName>(source, sourceType, ToQualifiedName);
                case BuiltInType.LocalizedText: return Cast<LocalizedText>(source, sourceType, ToLocalizedText);
                case BuiltInType.Variant: return Cast<Variant>(source, sourceType, ToVariant);
                case BuiltInType.Number: return Cast<double>(source, sourceType, ToDouble);
                case BuiltInType.Integer: return Cast<long>(source, sourceType, ToInt64);
                case BuiltInType.UInteger: return Cast<ulong>(source, sourceType, ToUInt64);
                case BuiltInType.Enumeration: return Cast<int>(source, sourceType, ToInt32);
                case BuiltInType.XmlElement: return Cast<XmlElement>(source, sourceType, ToXmlElement);
            }

            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts the array using the specified conversion function.
        /// </summary>
        /// <param name="dst">The destination array (must have the same size as the source array).</param>
        /// <param name="dstType">The data type of the elements in the destination array.</param>
        /// <param name="src">The source array.</param>
        /// <param name="srcType">The data type of the elements in the source array.</param>
        /// <param name="convertor">The handler which does the conversion.</param>
        public static void CastArray(Array dst, BuiltInType dstType, Array src, BuiltInType srcType, CastArrayElementHandler convertor)
        {
            bool isSrcVariant = src.GetType().GetElementType() == typeof(Variant);
            bool isDstVariant = dst.GetType().GetElementType() == typeof(Variant);

            // optimize performance if dealing with a one dimensional array.
            if (src.Rank == 1)
            {
                for (int ii = 0; ii < dst.Length; ii++)
                {
                    object element = src.GetValue(ii);

                    if (isSrcVariant)
                    {
                        element = ((Variant)element).Value;
                    }

                    if (convertor != null)
                    {
                        element = convertor(element, srcType, dstType);
                    }

                    if (isDstVariant)
                    {
                        element = new Variant(element);
                    }

                    dst.SetValue(element, ii);
                }

                return;
            }

            // do it the hard way for multidimensional arrays.
            int[] dimensions = new int[src.Rank];

            for (int ii = 0; ii < dimensions.Length; ii++)
            {
                dimensions[ii] = src.GetLength(ii);
            }

            int length = dst.Length;
            int[] indexes = new int[dimensions.Length];

            for (int ii = 0; ii < length; ii++)
            {
                int divisor = dst.Length;

                for (int jj = 0; jj < indexes.Length; jj++)
                {
                    divisor /= dimensions[jj];
                    indexes[jj] = (ii / divisor) % dimensions[jj];
                }

                object element = src.GetValue(indexes);

                if (element != null)
                {
                    if (isSrcVariant)
                    {
                        element = ((Variant)element).Value;
                    }

                    if (convertor != null)
                    {
                        element = convertor(element, srcType, dstType);
                    }

                    if (isDstVariant)
                    {
                        element = new Variant(element);
                    }

                    dst.SetValue(element, indexes);
                }
            }
        }

        /// <summary>
        /// Converts the array.
        /// </summary>
        /// <param name="srcArray">The source array.</param>
        /// <param name="srcType">The type of the source array.</param>
        /// <param name="dstType">The type of the converted array.</param>
        /// <param name="convertor">The handler which does the conversion.</param>
        /// <returns>The converted array.</returns>
        public static Array CastArray(Array srcArray, BuiltInType srcType, BuiltInType dstType, CastArrayElementHandler convertor)
        {
            if (srcArray == null)
            {
                return null;
            }

            int[] dimensions = new int[srcArray.Rank];

            for (int ii = 0; ii < dimensions.Length; ii++)
            {
                dimensions[ii] = srcArray.GetLength(ii);
            }

            Array dstArray = TypeInfo.CreateArray(dstType, dimensions);
            CastArray(dstArray, dstType, srcArray, srcType, convertor);

            return dstArray;
        }

        /// <summary>
        /// A delegate for a function that converts an array element.
        /// </summary>
        /// <param name="source">The element to be converted.</param>
        /// <param name="srcType">The type of the source element.</param>
        /// <param name="dstType">The type of the converted value.</param>
        /// <returns>The converted</returns>
        public delegate object CastArrayElementHandler(object source, BuiltInType srcType, BuiltInType dstType);
        #endregion

        #region Private Methods
        /// <summary>
        /// Maps the type name to a built-in type.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        private static BuiltInType GetBuiltInType(string typeName)
        {
            switch (typeName)
            {
                case "Boolean": return BuiltInType.Boolean;
                case "SByte": return BuiltInType.SByte;
                case "Byte": return BuiltInType.Byte;
                case "Int16": return BuiltInType.Int16;
                case "UInt16": return BuiltInType.UInt16;
                case "Int32": return BuiltInType.Int32;
                case "UInt32": return BuiltInType.UInt32;
                case "Int64": return BuiltInType.Int64;
                case "UInt64": return BuiltInType.UInt64;
                case "Float": return BuiltInType.Float;
                case "Single": return BuiltInType.Float;
                case "Double": return BuiltInType.Double;
                case "String": return BuiltInType.String;
                case "DateTime": return BuiltInType.DateTime;
                case "Guid": return BuiltInType.Guid;
                case "Uuid": return BuiltInType.Guid;
                case "ByteString": return BuiltInType.ByteString;
                case "XmlElement": return BuiltInType.XmlElement;
                case "NodeId": return BuiltInType.NodeId;
                case "ExpandedNodeId": return BuiltInType.ExpandedNodeId;
                case "LocalizedText": return BuiltInType.LocalizedText;
                case "QualifiedName": return BuiltInType.QualifiedName;
                case "StatusCode": return BuiltInType.StatusCode;
                case "DiagnosticInfo": return BuiltInType.DiagnosticInfo;
                case "DataValue": return BuiltInType.DataValue;
                case "Variant": return BuiltInType.Variant;
                case "ExtensionObject": return BuiltInType.ExtensionObject;
                case "Object": return BuiltInType.Variant;
            }

            return BuiltInType.Null;
        }

        /// <summary>
        /// Converts a value to a Boolean
        /// </summary>
        private static bool ToBoolean(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Boolean:
                {
                    return (bool)value;
                }

                case BuiltInType.SByte: return Convert.ToBoolean((sbyte)value);
                case BuiltInType.Byte: return Convert.ToBoolean((byte)value);
                case BuiltInType.Int16: return Convert.ToBoolean((short)value);
                case BuiltInType.UInt16: return Convert.ToBoolean((ushort)value);
                case BuiltInType.Int32: return Convert.ToBoolean((int)value);
                case BuiltInType.UInt32: return Convert.ToBoolean((uint)value);
                case BuiltInType.Int64: return Convert.ToBoolean((long)value);
                case BuiltInType.UInt64: return Convert.ToBoolean((ulong)value);
                case BuiltInType.Float: return Convert.ToBoolean((float)value);
                case BuiltInType.Double: return Convert.ToBoolean((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToBoolean((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a SByte
        /// </summary>
        private static sbyte ToSByte(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.SByte:
                {
                    return (sbyte)value;
                }

                case BuiltInType.Boolean: return Convert.ToSByte((bool)value);
                case BuiltInType.Byte: return Convert.ToSByte((byte)value);
                case BuiltInType.Int16: return Convert.ToSByte((short)value);
                case BuiltInType.UInt16: return Convert.ToSByte((ushort)value);
                case BuiltInType.Int32: return Convert.ToSByte((int)value);
                case BuiltInType.UInt32: return Convert.ToSByte((uint)value);
                case BuiltInType.Int64: return Convert.ToSByte((long)value);
                case BuiltInType.UInt64: return Convert.ToSByte((ulong)value);
                case BuiltInType.Float: return Convert.ToSByte((float)value);
                case BuiltInType.Double: return Convert.ToSByte((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToSByte((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Byte
        /// </summary>
        private static byte ToByte(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Byte:
                {
                    return (byte)value;
                }

                case BuiltInType.Boolean: return Convert.ToByte((bool)value);
                case BuiltInType.SByte: return Convert.ToByte((sbyte)value);
                case BuiltInType.Int16: return Convert.ToByte((short)value);
                case BuiltInType.UInt16: return Convert.ToByte((ushort)value);
                case BuiltInType.Int32: return Convert.ToByte((int)value);
                case BuiltInType.UInt32: return Convert.ToByte((uint)value);
                case BuiltInType.Int64: return Convert.ToByte((long)value);
                case BuiltInType.UInt64: return Convert.ToByte((ulong)value);
                case BuiltInType.Float: return Convert.ToByte((float)value);
                case BuiltInType.Double: return Convert.ToByte((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToByte((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Int16
        /// </summary>
        private static short ToInt16(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Int16:
                {
                    return (short)value;
                }

                case BuiltInType.Boolean: return Convert.ToInt16((bool)value);
                case BuiltInType.SByte: return Convert.ToInt16((sbyte)value);
                case BuiltInType.Byte: return Convert.ToInt16((byte)value);
                case BuiltInType.UInt16: return Convert.ToInt16((ushort)value);
                case BuiltInType.Int32: return Convert.ToInt16((int)value);
                case BuiltInType.UInt32: return Convert.ToInt16((uint)value);
                case BuiltInType.Int64: return Convert.ToInt16((long)value);
                case BuiltInType.UInt64: return Convert.ToInt16((ulong)value);
                case BuiltInType.Float: return Convert.ToInt16((float)value);
                case BuiltInType.Double: return Convert.ToInt16((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt16((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a UInt16
        /// </summary>
        private static ushort ToUInt16(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.UInt16:
                {
                    return (ushort)value;
                }

                case BuiltInType.Boolean: return Convert.ToUInt16((bool)value);
                case BuiltInType.SByte: return Convert.ToUInt16((sbyte)value);
                case BuiltInType.Byte: return Convert.ToUInt16((byte)value);
                case BuiltInType.Int16: return Convert.ToUInt16((short)value);
                case BuiltInType.Int32: return Convert.ToUInt16((int)value);
                case BuiltInType.UInt32: return Convert.ToUInt16((uint)value);
                case BuiltInType.Int64: return Convert.ToUInt16((long)value);
                case BuiltInType.UInt64: return Convert.ToUInt16((ulong)value);
                case BuiltInType.Float: return Convert.ToUInt16((float)value);
                case BuiltInType.Double: return Convert.ToUInt16((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt16((string)value);
                }

                case BuiltInType.StatusCode:
                {
                    StatusCode code = (StatusCode)value;
                    return (ushort)(code.CodeBits >> 16);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Int32
        /// </summary>
        private static int ToInt32(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Int32:
                {
                    return (int)value;
                }

                case BuiltInType.Boolean: return Convert.ToInt32((bool)value);
                case BuiltInType.SByte: return Convert.ToInt32((sbyte)value);
                case BuiltInType.Byte: return Convert.ToInt32((byte)value);
                case BuiltInType.Int16: return Convert.ToInt32((short)value);
                case BuiltInType.UInt16: return Convert.ToInt32((ushort)value);
                case BuiltInType.UInt32: return Convert.ToInt32((uint)value);
                case BuiltInType.Int64: return Convert.ToInt32((long)value);
                case BuiltInType.UInt64: return Convert.ToInt32((ulong)value);
                case BuiltInType.Float: return Convert.ToInt32((float)value);
                case BuiltInType.Double: return Convert.ToInt32((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt32((string)value);
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToInt32(((StatusCode)value).Code);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a UInt32
        /// </summary>
        private static uint ToUInt32(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.UInt32:
                {
                    return (uint)value;
                }

                case BuiltInType.Boolean: return Convert.ToUInt32((bool)value);
                case BuiltInType.SByte: return Convert.ToUInt32((sbyte)value);
                case BuiltInType.Byte: return Convert.ToUInt32((byte)value);
                case BuiltInType.Int16: return Convert.ToUInt32((short)value);
                case BuiltInType.UInt16: return Convert.ToUInt32((ushort)value);
                case BuiltInType.Int32: return Convert.ToUInt32((int)value);
                case BuiltInType.Int64: return Convert.ToUInt32((long)value);
                case BuiltInType.UInt64: return Convert.ToUInt32((ulong)value);
                case BuiltInType.Float: return Convert.ToUInt32((float)value);
                case BuiltInType.Double: return Convert.ToUInt32((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt32((string)value);
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToUInt32(((StatusCode)value).Code);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Int64
        /// </summary>
        private static long ToInt64(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Int64:
                {
                    return (long)value;
                }

                case BuiltInType.Boolean: return Convert.ToInt64((bool)value);
                case BuiltInType.SByte: return Convert.ToInt64((sbyte)value);
                case BuiltInType.Byte: return Convert.ToInt64((byte)value);
                case BuiltInType.Int16: return Convert.ToInt64((short)value);
                case BuiltInType.UInt16: return Convert.ToInt64((ushort)value);
                case BuiltInType.Int32: return Convert.ToInt64((int)value);
                case BuiltInType.UInt32: return Convert.ToInt64((uint)value);
                case BuiltInType.UInt64: return Convert.ToInt64((ulong)value);
                case BuiltInType.Float: return Convert.ToInt64((float)value);
                case BuiltInType.Double: return Convert.ToInt64((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToInt64((string)value);
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToInt64(((StatusCode)value).Code);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a UInt64
        /// </summary>
        private static ulong ToUInt64(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.UInt64:
                {
                    return (ulong)value;
                }

                case BuiltInType.Boolean: return Convert.ToUInt64((bool)value);
                case BuiltInType.SByte: return Convert.ToUInt64((sbyte)value);
                case BuiltInType.Byte: return Convert.ToUInt64((byte)value);
                case BuiltInType.Int16: return Convert.ToUInt64((short)value);
                case BuiltInType.UInt16: return Convert.ToUInt64((ushort)value);
                case BuiltInType.Int32: return Convert.ToUInt64((int)value);
                case BuiltInType.UInt32: return Convert.ToUInt64((uint)value);
                case BuiltInType.Int64: return Convert.ToUInt64((long)value);
                case BuiltInType.Float: return Convert.ToUInt64((float)value);
                case BuiltInType.Double: return Convert.ToUInt64((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToUInt64((string)value);
                }

                case BuiltInType.StatusCode:
                {
                    return Convert.ToUInt64(((StatusCode)value).Code);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Float
        /// </summary>
        private static float ToFloat(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Float:
                {
                    return (float)value;
                }

                case BuiltInType.Boolean: return Convert.ToSingle((bool)value);
                case BuiltInType.SByte: return Convert.ToSingle((sbyte)value);
                case BuiltInType.Byte: return Convert.ToSingle((byte)value);
                case BuiltInType.Int16: return Convert.ToSingle((short)value);
                case BuiltInType.UInt16: return Convert.ToSingle((ushort)value);
                case BuiltInType.Int32: return Convert.ToSingle((int)value);
                case BuiltInType.UInt32: return Convert.ToSingle((uint)value);
                case BuiltInType.Int64: return Convert.ToSingle((long)value);
                case BuiltInType.UInt64: return Convert.ToSingle((ulong)value);
                case BuiltInType.Double: return Convert.ToSingle((double)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToSingle((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Double
        /// </summary>
        private static double ToDouble(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.Double:
                {
                    return (double)value;
                }

                case BuiltInType.Boolean: return Convert.ToDouble((bool)value);
                case BuiltInType.SByte: return Convert.ToDouble((sbyte)value);
                case BuiltInType.Byte: return Convert.ToDouble((byte)value);
                case BuiltInType.Int16: return Convert.ToDouble((short)value);
                case BuiltInType.UInt16: return Convert.ToDouble((ushort)value);
                case BuiltInType.Int32: return Convert.ToDouble((int)value);
                case BuiltInType.UInt32: return Convert.ToDouble((uint)value);
                case BuiltInType.Int64: return Convert.ToDouble((long)value);
                case BuiltInType.UInt64: return Convert.ToDouble((ulong)value);
                case BuiltInType.Float: return Convert.ToDouble((float)value);

                case BuiltInType.String:
                {
                    return XmlConvert.ToDouble((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a String
        /// </summary>
        private static string ToString(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.String:
                {
                    return (string)value;
                }

                case BuiltInType.Boolean:
                {
                    return XmlConvert.ToString((bool)value);
                }

                case BuiltInType.SByte:
                {
                    return XmlConvert.ToString((sbyte)value);
                }

                case BuiltInType.Byte:
                {
                    return XmlConvert.ToString((byte)value);
                }

                case BuiltInType.Int16:
                {
                    return XmlConvert.ToString((short)value);
                }

                case BuiltInType.UInt16:
                {
                    return XmlConvert.ToString((ushort)value);
                }

                case BuiltInType.Int32:
                {
                    return XmlConvert.ToString((int)value);
                }

                case BuiltInType.UInt32:
                {
                    return XmlConvert.ToString((uint)value);
                }

                case BuiltInType.Int64:
                {
                    return XmlConvert.ToString((long)value);
                }

                case BuiltInType.UInt64:
                {
                    return XmlConvert.ToString((ulong)value);
                }

                case BuiltInType.Float:
                {
                    return XmlConvert.ToString((float)value);
                }

                case BuiltInType.Double:
                {
                    return XmlConvert.ToString((double)value);
                }

                case BuiltInType.DateTime:
                {
                    return XmlConvert.ToString((DateTime)value, XmlDateTimeSerializationMode.Unspecified);
                }

                case BuiltInType.Guid:
                {
                    return ((Uuid)value).ToString();
                }

                case BuiltInType.NodeId:
                {
                    return ((NodeId)value).ToString();
                }

                case BuiltInType.ExpandedNodeId:
                {
                    return ((ExpandedNodeId)value).ToString();
                }

                case BuiltInType.LocalizedText:
                {
                    return ((LocalizedText)value).Text;
                }

                case BuiltInType.QualifiedName:
                {
                    return ((QualifiedName)value).ToString();
                }

                case BuiltInType.XmlElement:
                {
                    return ((XmlElement)value).OuterXml;
                }

                case BuiltInType.StatusCode:
                {
                    return ((StatusCode)value).Code.ToString();
                }

                case BuiltInType.ExtensionObject:
                {
                    return ((ExtensionObject)value).ToString();
                }

                case BuiltInType.Null:
                {
                    return null;
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a DateTime
        /// </summary>
        private static DateTime ToDateTime(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.DateTime:
                {
                    return (DateTime)value;
                }

                case BuiltInType.String:
                {
                    return XmlConvert.ToDateTime((string)value, XmlDateTimeSerializationMode.Unspecified);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Guid
        /// </summary>
        private static Uuid ToGuid(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.String:
                {
                    return new Uuid((string)value);
                }

                case BuiltInType.ByteString:
                {
                    return new Uuid(new Guid((byte[])value));
                }

                case BuiltInType.Guid:
                {
                    if (value is Guid? guid)
                    {
                        return new Uuid(guid.Value);
                    }

                    return (Uuid)value;
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a ByteString
        /// </summary>
        private static byte[] ToByteString(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.ByteString:
                {
                    return (byte[])value;
                }

                case BuiltInType.String:
                {
                    string text = (string)value;

                    if (text == null)
                    {
                        return null;
                    }

                    if (text.Length == 0)
                    {
                        return new byte[0];
                    }

                    using (System.IO.MemoryStream ostrm = new System.IO.MemoryStream())
                    {
                        byte buffer = 0;
                        bool firstByte = false;
                        const string digits = "0123456789ABCDEF";

                        for (int ii = 0; ii < text.Length; ii++)
                        {
                            if (!Char.IsWhiteSpace(text, ii) && !Char.IsLetterOrDigit(text, ii))
                            {
                                throw new FormatException("Invalid character in ByteString. " + text[ii]);
                            }

                            if (Char.IsWhiteSpace(text, ii))
                            {
                                continue;
                            }

                            int index = digits.IndexOf(Char.ToUpper(text[ii]));

                            if (index < 0)
                            {
                                throw new FormatException("Invalid character in ByteString." + text[ii]);
                            }

                            buffer <<= 4;
                            buffer += (byte)index;

                            if (firstByte)
                            {
                                ostrm.WriteByte(buffer);
                                firstByte = false;
                                continue;
                            }

                            firstByte = true;
                        }

                        if (firstByte)
                        {
                            buffer <<= 4;
                            ostrm.WriteByte(buffer);
                        }

                        // you should not access a closed stream, ever.
                        return ostrm.ToArray();
                    }
                }

                case BuiltInType.Guid:
                {
                    return ((Guid)((Uuid)value)).ToByteArray();
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a XmlElement
        /// </summary>
        private static XmlElement ToXmlElement(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.XmlElement:
                {
                    return (XmlElement)value;
                }

                case BuiltInType.String:
                {
                    XmlDocument document = new XmlDocument();
                    document.InnerXml = (string)value;
                    return document.DocumentElement;
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a NodeId
        /// </summary>
        private static NodeId ToNodeId(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.NodeId:
                {
                    return (NodeId)value;
                }

                case BuiltInType.ExpandedNodeId:
                {
                    return (NodeId)(ExpandedNodeId)value;
                }

                case BuiltInType.String:
                {
                    return NodeId.Parse((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a ExpandedNodeId
        /// </summary>
        private static ExpandedNodeId ToExpandedNodeId(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.ExpandedNodeId:
                {
                    return (ExpandedNodeId)value;
                }

                case BuiltInType.NodeId:
                {
                    return (ExpandedNodeId)(NodeId)value;
                }

                case BuiltInType.String:
                {
                    return ExpandedNodeId.Parse((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a StatusCode
        /// </summary>
        private static StatusCode ToStatusCode(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.StatusCode:
                {
                    return (StatusCode)value;
                }

                case BuiltInType.UInt16:
                {
                    uint code = Convert.ToUInt32((ushort)value);
                    code <<= 16;
                    return (StatusCode)code;
                }

                case BuiltInType.Int32:
                {
                    return (StatusCode)Convert.ToUInt32((int)value);
                }

                case BuiltInType.UInt32:
                {
                    return (StatusCode)(uint)value;
                }

                case BuiltInType.Int64:
                {
                    return (StatusCode)Convert.ToUInt32((long)value);
                }

                case BuiltInType.UInt64:
                {
                    return (StatusCode)Convert.ToUInt32((ulong)value);
                }

                case BuiltInType.String:
                {
                    string text = (string)value;

                    if (text == null)
                    {
                        return StatusCodes.Good;
                    }

                    text = text.Trim();

                    if (text.StartsWith("0x"))
                    {
                        return (StatusCode)Convert.ToUInt32(text.Substring(2), 16);
                    }

                    return (StatusCode)Convert.ToUInt32((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a QualifiedName
        /// </summary>
        private static QualifiedName ToQualifiedName(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.QualifiedName:
                {
                    return (QualifiedName)value;
                }

                case BuiltInType.String:
                {
                    return QualifiedName.Parse((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a LocalizedText
        /// </summary>
        private static LocalizedText ToLocalizedText(object value, TypeInfo sourceType)
        {
            // handle for supported conversions.
            switch (sourceType.BuiltInType)
            {
                case BuiltInType.LocalizedText:
                {
                    return (LocalizedText)value;
                }

                case BuiltInType.String:
                {
                    return new LocalizedText((string)value);
                }
            }

            // conversion not supported.
            throw new InvalidCastException();
        }

        /// <summary>
        /// Converts a value to a Variant
        /// </summary>
        private static Variant ToVariant(object value, TypeInfo sourceType)
        {
            return new Variant(value);
        }

        /// <summary>
        /// Delegate for a function used to cast a value to the specified type.
        /// </summary>
        private delegate T CastDelegate<T>(object value, TypeInfo sourceType);

        /// <summary>
        /// Casts a scalar or array value to the specified type.
        /// </summary>
        private static object Cast<T>(object input, TypeInfo sourceType, CastDelegate<T> handler)
        {
            if (sourceType == null)
            {
                sourceType = TypeInfo.Construct(input);
            }

            if (sourceType.ValueRank >= 0)
            {
                return Cast<T>((Array)input, sourceType, handler);
            }

            if (sourceType.BuiltInType == BuiltInType.Variant)
            {
                object value = ((Variant)input).Value;
                sourceType = TypeInfo.Construct(value);
                return handler(value, sourceType);
            }

            return handler(input, sourceType);
        }

        /// <summary>
        /// Casts an array to an array of the specified type.
        /// </summary>
        private static Array Cast<T>(Array input, TypeInfo sourceType, CastDelegate<T> handler)
        {
            if (input == null)
            {
                return null;
            }

            TypeInfo elementType = new TypeInfo(sourceType.BuiltInType, ValueRanks.Scalar);

            if (input.Rank == 1)
            {
                T[] copy = new T[input.Length];

                for (int ii = 0; ii < input.Length; ii++)
                {
                    object value = input.GetValue(ii);

                    if (value != null)
                    {
                        if (sourceType.BuiltInType == BuiltInType.Variant)
                        {
                            value = ((Variant)value).Value;
                            elementType = TypeInfo.Construct(value);
                        }

                        copy[ii] = handler(value, elementType);
                    }
                }

                return copy;
            }

            if (input.Rank == 2)
            {
                int x = input.GetLength(0);
                int y = input.GetLength(1);

                T[,] copy = new T[x, y];

                for (int ii = 0; ii < x; ii++)
                {
                    for (int jj = 0; jj < y; jj++)
                    {
                        object value = input.GetValue(ii, jj);

                        if (value != null)
                        {
                            if (sourceType.BuiltInType == BuiltInType.Variant)
                            {
                                value = ((Variant)value).Value;
                                elementType = TypeInfo.Construct(value);
                            }

                            copy[ii, jj] = handler(value, elementType);
                        }
                    }
                }

                return copy;
            }

            int[] dimensions = new int[input.Rank];

            for (int ii = 0; ii < dimensions.Length; ii++)
            {
                dimensions[ii] = input.GetLength(ii);
            }

            Array output = Array.CreateInstance(typeof(T), dimensions);

            int length = output.Length;
            int[] indexes = new int[dimensions.Length];

            for (int ii = 0; ii < length; ii++)
            {
                int divisor = output.Length;

                for (int jj = 0; jj < indexes.Length; jj++)
                {
                    divisor /= dimensions[jj];
                    indexes[jj] = (ii / divisor) % dimensions[jj];
                }

                object value = input.GetValue(indexes);

                if (value != null)
                {
                    if (sourceType.BuiltInType == BuiltInType.Variant)
                    {
                        value = ((Variant)value).Value;
                        elementType = TypeInfo.Construct(value);
                    }

                    output.SetValue(handler(value, elementType), indexes);
                }
            }

            return output;
        }
        #endregion

        #region Private Fields
        private BuiltInType m_builtInType;
        private int m_valueRank;
        private static readonly TypeInfo s_Unknown = new TypeInfo();
        #endregion

        #region Scalars Class
        /// <summary>
        /// Constants for scalar types.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        public static class Scalars
        {
            /// <summary>
            /// A boolean logic value (true or false).
            /// </summary>
            public static readonly TypeInfo Boolean = new TypeInfo(BuiltInType.Boolean, ValueRanks.Scalar);

            /// <summary>
            /// An 8 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo SByte = new TypeInfo(BuiltInType.SByte, ValueRanks.Scalar);

            /// <summary>
            /// An 8 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo Byte = new TypeInfo(BuiltInType.Byte, ValueRanks.Scalar);

            /// <summary>
            /// A 16 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int16 = new TypeInfo(BuiltInType.Int16, ValueRanks.Scalar);

            /// <summary>
            /// A 16 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo UInt16 = new TypeInfo(BuiltInType.UInt16, ValueRanks.Scalar);

            /// <summary>
            /// A 32 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int32 = new TypeInfo(BuiltInType.Int32, ValueRanks.Scalar);

            /// <summary>
            /// A 32 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo UInt32 = new TypeInfo(BuiltInType.UInt32, ValueRanks.Scalar);

            /// <summary>
            /// A 64 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int64 = new TypeInfo(BuiltInType.Int64, ValueRanks.Scalar);

            /// <summary>
            /// A 64 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo UInt64 = new TypeInfo(BuiltInType.UInt64, ValueRanks.Scalar);

            /// <summary>
            /// An IEEE single precision (32 bit) floating point value.
            /// </summary>
            public static readonly TypeInfo Float = new TypeInfo(BuiltInType.Float, ValueRanks.Scalar);

            /// <summary>
            /// An IEEE double precision (64 bit) floating point value.
            /// </summary>
            public static readonly TypeInfo Double = new TypeInfo(BuiltInType.Double, ValueRanks.Scalar);

            /// <summary>
            /// A sequence of Unicode characters.
            /// </summary>
            public static readonly TypeInfo String = new TypeInfo(BuiltInType.String, ValueRanks.Scalar);

            /// <summary>
            /// An instance in time.
            /// </summary>
            public static readonly TypeInfo DateTime = new TypeInfo(BuiltInType.DateTime, ValueRanks.Scalar);

            /// <summary>
            /// A 128-bit globally unique identifier.
            /// </summary>
            public static readonly TypeInfo Guid = new TypeInfo(BuiltInType.Guid, ValueRanks.Scalar);

            /// <summary>
            /// A sequence of bytes.
            /// </summary>
            public static readonly TypeInfo ByteString = new TypeInfo(BuiltInType.ByteString, ValueRanks.Scalar);

            /// <summary>
            /// An XML element.
            /// </summary>
            public static readonly TypeInfo XmlElement = new TypeInfo(BuiltInType.XmlElement, ValueRanks.Scalar);

            /// <summary>
            /// An identifier for a node in the address space of a UA server.
            /// </summary>
            public static readonly TypeInfo NodeId = new TypeInfo(BuiltInType.NodeId, ValueRanks.Scalar);

            /// <summary>
            /// A node id that stores the namespace URI instead of the namespace index.
            /// </summary>
            public static readonly TypeInfo ExpandedNodeId = new TypeInfo(BuiltInType.ExpandedNodeId, ValueRanks.Scalar);

            /// <summary>
            /// A structured result code.
            /// </summary>
            public static readonly TypeInfo StatusCode = new TypeInfo(BuiltInType.StatusCode, ValueRanks.Scalar);

            /// <summary>
            /// A string qualified with a namespace.
            /// </summary>
            public static readonly TypeInfo QualifiedName = new TypeInfo(BuiltInType.QualifiedName, ValueRanks.Scalar);

            /// <summary>
            /// A localized text string with an locale identifier.
            /// </summary>
            public static readonly TypeInfo LocalizedText = new TypeInfo(BuiltInType.LocalizedText, ValueRanks.Scalar);

            /// <summary>
            /// An opaque object with a syntax that may be unknown to the receiver.
            /// </summary>
            public static readonly TypeInfo ExtensionObject = new TypeInfo(BuiltInType.ExtensionObject, ValueRanks.Scalar);

            /// <summary>
            /// A data value with an associated quality and timestamp.
            /// </summary>
            public static readonly TypeInfo DataValue = new TypeInfo(BuiltInType.DataValue, ValueRanks.Scalar);

            /// <summary>
            /// Any of the other built-in types.
            /// </summary>
            public static readonly TypeInfo Variant = new TypeInfo(BuiltInType.Variant, ValueRanks.Scalar);

            /// <summary>
            /// A diagnostic information associated with a result code.
            /// </summary>
            public static readonly TypeInfo DiagnosticInfo = new TypeInfo(BuiltInType.DiagnosticInfo, ValueRanks.Scalar);
        }
        #endregion

        #region Arrays Class
        /// <summary>
        /// Constants for one dimensional array types.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible")]
        public static class Arrays
        {
            /// <summary>
            /// A boolean logic value (true or false).
            /// </summary>
            public static readonly TypeInfo Boolean = new TypeInfo(BuiltInType.Boolean, ValueRanks.OneDimension);

            /// <summary>
            /// An 8 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo SByte = new TypeInfo(BuiltInType.SByte, ValueRanks.OneDimension);

            /// <summary>
            /// An 8 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo Byte = new TypeInfo(BuiltInType.Byte, ValueRanks.OneDimension);

            /// <summary>
            /// A 16 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int16 = new TypeInfo(BuiltInType.Int16, ValueRanks.OneDimension);

            /// <summary>
            /// A 16 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo UInt16 = new TypeInfo(BuiltInType.UInt16, ValueRanks.OneDimension);

            /// <summary>
            /// A 32 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int32 = new TypeInfo(BuiltInType.Int32, ValueRanks.OneDimension);

            /// <summary>
            /// A 32 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo UInt32 = new TypeInfo(BuiltInType.UInt32, ValueRanks.OneDimension);

            /// <summary>
            /// A 64 bit signed integer value.
            /// </summary>
            public static readonly TypeInfo Int64 = new TypeInfo(BuiltInType.Int64, ValueRanks.OneDimension);

            /// <summary>
            /// A 64 bit unsigned integer value.
            /// </summary>
            public static readonly TypeInfo UInt64 = new TypeInfo(BuiltInType.UInt64, ValueRanks.OneDimension);

            /// <summary>
            /// An IEEE single precision (32 bit) floating point value.
            /// </summary>
            public static readonly TypeInfo Float = new TypeInfo(BuiltInType.Float, ValueRanks.OneDimension);

            /// <summary>
            /// An IEEE double precision (64 bit) floating point value.
            /// </summary>
            public static readonly TypeInfo Double = new TypeInfo(BuiltInType.Double, ValueRanks.OneDimension);

            /// <summary>
            /// A sequence of Unicode characters.
            /// </summary>
            public static readonly TypeInfo String = new TypeInfo(BuiltInType.String, ValueRanks.OneDimension);

            /// <summary>
            /// An instance in time.
            /// </summary>
            public static readonly TypeInfo DateTime = new TypeInfo(BuiltInType.DateTime, ValueRanks.OneDimension);

            /// <summary>
            /// A 128-bit globally unique identifier.
            /// </summary>
            public static readonly TypeInfo Guid = new TypeInfo(BuiltInType.Guid, ValueRanks.OneDimension);

            /// <summary>
            /// A sequence of bytes.
            /// </summary>
            public static readonly TypeInfo ByteString = new TypeInfo(BuiltInType.ByteString, ValueRanks.OneDimension);

            /// <summary>
            /// An XML element.
            /// </summary>
            public static readonly TypeInfo XmlElement = new TypeInfo(BuiltInType.XmlElement, ValueRanks.OneDimension);

            /// <summary>
            /// An identifier for a node in the address space of a UA server.
            /// </summary>
            public static readonly TypeInfo NodeId = new TypeInfo(BuiltInType.NodeId, ValueRanks.OneDimension);

            /// <summary>
            /// A node id that stores the namespace URI instead of the namespace index.
            /// </summary>
            public static readonly TypeInfo ExpandedNodeId = new TypeInfo(BuiltInType.ExpandedNodeId, ValueRanks.OneDimension);

            /// <summary>
            /// A structured result code.
            /// </summary>
            public static readonly TypeInfo StatusCode = new TypeInfo(BuiltInType.StatusCode, ValueRanks.OneDimension);

            /// <summary>
            /// A string qualified with a namespace.
            /// </summary>
            public static readonly TypeInfo QualifiedName = new TypeInfo(BuiltInType.QualifiedName, ValueRanks.OneDimension);

            /// <summary>
            /// A localized text string with an locale identifier.
            /// </summary>
            public static readonly TypeInfo LocalizedText = new TypeInfo(BuiltInType.LocalizedText, ValueRanks.OneDimension);

            /// <summary>
            /// An opaque object with a syntax that may be unknown to the receiver.
            /// </summary>
            public static readonly TypeInfo ExtensionObject = new TypeInfo(BuiltInType.ExtensionObject, ValueRanks.OneDimension);

            /// <summary>
            /// A data value with an associated quality and timestamp.
            /// </summary>
            public static readonly TypeInfo DataValue = new TypeInfo(BuiltInType.DataValue, ValueRanks.OneDimension);

            /// <summary>
            /// Any of the other built-in types.
            /// </summary>
            public static readonly TypeInfo Variant = new TypeInfo(BuiltInType.Variant, ValueRanks.OneDimension);

            /// <summary>
            /// A diagnostic information associated with a result code.
            /// </summary>
            public static readonly TypeInfo DiagnosticInfo = new TypeInfo(BuiltInType.DiagnosticInfo, ValueRanks.OneDimension);
        }
        #endregion

        #region IFormattable Members
        /// <summary>
        /// Formats the type information as a string.
        /// </summary>
        public override string ToString()
        {
            return ToString(null, null);
        }

        /// <summary>
        /// Formats the type information as a string.
        /// </summary>
        public string ToString(string format, IFormatProvider formatProvider)
        {
            if (format == null)
            {
                System.Text.StringBuilder buffer = new System.Text.StringBuilder();
                buffer.Append(m_builtInType);

                if (m_valueRank >= 0)
                {
                    buffer.Append("[");

                    for (int ii = 1; ii < m_valueRank; ii++)
                    {
                        buffer.Append(",");
                    }

                    buffer.Append("]");
                }

                return buffer.ToString();
            }

            throw new FormatException(Utils.Format("Invalid format string: '{0}'.", format));
        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Determines if the specified object is equal to the object.
        /// </summary>
        /// <remarks>
        /// Determines if the specified object is equal to the object.
        /// </remarks>
        public override bool Equals(object obj)
        {
            if (Object.ReferenceEquals(this, obj))
            {
                return true;
            }

            if (obj is TypeInfo typeInfo)
            {
                return (m_builtInType == typeInfo.BuiltInType &&
                    m_valueRank == typeInfo.ValueRank);
            }

            return false;
        }

        /// <summary>
        /// Returns a suitable hash code.
        /// </summary>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\TypeInfo.cs(847,17): error CS0841: Cannot use local variable 'array' before it is declared,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\TypeInfo.cs(851,21): error CS0841: Cannot use local variable 'array' before it is declared,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\TypeInfo.cs(942,21): error CS0841: Cannot use local variable 'encodeable' before it is declared,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\TypeInfo.cs(943,46): error CS0136: A local or parameter named 'encodeable' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Stack\Opc.Ua.Core\Types\Utils\TypeInfo.cs(2280,34): error CS8116: It is not legal to use nullable type 'Guid?' in a pattern; use the underlying type 'Guid' instead.
######################################################################


######################################################################
Nr: 28 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Client\MonitoredItem.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Runtime.Serialization;
using System.Reflection;

namespace Opc.Ua.Client
{
    /// <summary>
    /// A monitored item.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    [KnownType(typeof(DataChangeFilter))]
    [KnownType(typeof(EventFilter))]
    [KnownType(typeof(AggregateFilter))]
    public class MonitoredItem
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="MonitoredItem"/> class.
        /// </summary>
        public MonitoredItem()
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MonitoredItem"/> class.
        /// </summary>
        /// <param name="clientHandle">The client handle. The caller must ensure it uniquely identifies the monitored item.</param>
        public MonitoredItem(uint clientHandle)
        {
            Initialize();
            m_clientHandle = clientHandle;
        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="MonitoredItem"/> class.
        /// </summary>
        /// <param name="template">The template used to specify the monitoring parameters.</param>
        public MonitoredItem(MonitoredItem template) : this(template, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MonitoredItem"/> class.
        /// </summary>
        /// <param name="template">The template used to specify the monitoring parameters.</param>
        /// <param name="copyEventHandlers">if set to <c>true</c> the event handlers are copied.</param>
        public MonitoredItem(MonitoredItem template, bool copyEventHandlers) : this(template, copyEventHandlers, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MonitoredItem"/> class.
        /// </summary>
        /// <param name="template">The template used to specify the monitoring parameters.</param>
        /// <param name="copyEventHandlers">if set to <c>true</c> the event handlers are copied.</param>
        /// <param name="copyClientHandle">if set to <c>true</c> the clientHandle is of the template copied.</param>
        public MonitoredItem(MonitoredItem template, bool copyEventHandlers, bool copyClientHandle)
        {
            Initialize();

            if (template != null)
            {
                string displayName = template.DisplayName;

                if (displayName != null)
                {
                    // remove any existing numeric suffix.
                    int index = displayName.LastIndexOf(' ');

                    if (index != -1)
                    {
                        try
                        {
                            displayName = displayName.Substring(0, index);
                        }
                        catch
                        {
                            // not a numeric suffix.
                        }
                    }
                }

                m_handle             = template.m_handle;
                m_displayName        = Utils.Format("{0} {1}", displayName, m_clientHandle);
                m_startNodeId        = template.m_startNodeId;
                m_relativePath       = template.m_relativePath;
                m_attributeId        = template.m_attributeId;
                m_indexRange         = template.m_indexRange;
                m_encoding           = template.m_encoding; 
                m_monitoringMode     = template.m_monitoringMode;
                m_samplingInterval   = template.m_samplingInterval;
                m_filter             = (MonitoringFilter)Utils.Clone(template.m_filter);
                m_queueSize          = template.m_queueSize;
                m_discardOldest      = template.m_discardOldest;
                m_attributesModified = true;

                if (copyEventHandlers)
                {
                    m_Notification = template.m_Notification;
                }

                if (copyClientHandle)
                {
                    m_clientHandle = template.m_clientHandle;
                }

                // this ensures the state is consistent with the node class.
                NodeClass = template.m_nodeClass;
            }
        }
        
		/// <summary>
		/// Called by the .NET framework during deserialization.
		/// </summary>
	    [OnDeserializing]
		private void Initialize(StreamingContext context)
		{
            // object initializers are not called during deserialization.
            m_cache = new object();

            Initialize();
		}

        /// <summary>
        /// Sets the private members to default values.
        /// </summary>
        private void Initialize()
        {
            m_startNodeId          = null;
            m_relativePath         = null;
            m_clientHandle         = 0;
            m_attributeId          = Attributes.Value;
            m_indexRange           = null;
            m_encoding             = null; 
            m_monitoringMode       = MonitoringMode.Reporting;
            m_samplingInterval     = -1;
            m_filter               = null;
            m_queueSize            = 0;
            m_discardOldest        = true;
            m_attributesModified   = true;
            m_status               = new MonitoredItemStatus();

            // this ensures the state is consistent with the node class.
            NodeClass = NodeClass.Variable;

            // assign a unique handle.
            m_clientHandle = Utils.IncrementIdentifier(ref s_GlobalClientHandle);
        }
        #endregion
        
        #region Persistent Properties
        /// <summary>
        /// A display name for the monitored item.
        /// </summary>
        [DataMember(Order = 1)]
        public string DisplayName
        {
            get { return m_displayName;  }
            set { m_displayName = value; }
        }
        

        /// <summary>
        /// The start node for the browse path that identifies the node to monitor.
        /// </summary>
        [DataMember(Order = 2)]
        public NodeId StartNodeId
        {
            get { return m_startNodeId;  }
            set { m_startNodeId = value; }
        }
        
        /// <summary>
        /// The relative path from the browse path to the node to monitor.
        /// </summary>
        /// <remarks>
        /// A null or empty string specifies that the start node id should be monitored.
        /// </remarks>
        [DataMember(Order = 3)]
        public string RelativePath
        {
            get { return m_relativePath;  }
            
            set 
            {
                // clear resolved path if relative path has changed.
                if (m_relativePath != value)
                {
                    m_resolvedNodeId = null;
                }

                m_relativePath = value;
            }
        }
        
        /// <summary>
        /// The node class of the node being monitored (affects the type of filter available).
        /// </summary>
        [DataMember(Order = 4)]
        public NodeClass NodeClass
        {
            get { return m_nodeClass; }
            
            set 
            {
                if (m_nodeClass != value)
                {
                    if ((value & (NodeClass.Object | NodeClass.View)) != 0)
                    {
                        // ensure a valid event filter.
                        if (!(m_filter is EventFilter))
                        {
                            UseDefaultEventFilter();
                        }

                        // set the queue size to the default for events.
                        if (QueueSize <= 1)
                        {
                            QueueSize = Int32.MaxValue;
                        }

                        m_eventCache = new MonitoredItemEventCache(100);
                        m_attributeId = Attributes.EventNotifier;
                    }
                    else
                    {
                        // clear the filter if it is only valid for events.
                        if (m_filter is EventFilter)
                        {
                            m_filter = null;
                        }

                        // set the queue size to the default for data changes.
                        if (QueueSize == Int32.MaxValue)
                        {
                            QueueSize = 1;
                        }

                        m_dataCache = new MonitoredItemDataCache(1);
                    }
                }

                m_nodeClass = value;
            }
        }

        /// <summary>
        /// The attribute to monitor.
        /// </summary>
        [DataMember(Order = 5)]
        public uint AttributeId
        {
            get { return m_attributeId;  }
            set { m_attributeId = value; }
        }

        /// <summary>
        /// The range of array indexes to monitor.
        /// </summary>
        [DataMember(Order = 6)]
        public string IndexRange
        {
            get { return m_indexRange;  }
            set { m_indexRange = value; }
        }

        /// <summary>
        /// The encoding to use when returning notifications.
        /// </summary>
        [DataMember(Order = 7)]
        public QualifiedName Encoding
        {
            get { return m_encoding;  }
            set { m_encoding = value; }
        }

        /// <summary>
        /// The monitoring mode.
        /// </summary>
        [DataMember(Order = 8)]
        public MonitoringMode MonitoringMode
        {
            get { return m_monitoringMode;  }
            set { m_monitoringMode = value; }
        }
        
        /// <summary>
        /// The sampling interval.
        /// </summary>
        [DataMember(Order = 9)]
        public int SamplingInterval
        {
            get { return m_samplingInterval; }
            
            set 
            {
                if (m_samplingInterval != value)
                {
                    m_attributesModified = true;
                }

                m_samplingInterval = value; 
            }
        }

        /// <summary>
        /// The filter to use to select values to return.
        /// </summary>
        [DataMember(Order = 10)]
        public MonitoringFilter Filter
        {
            get { return m_filter; }
            
            set 
            {
                // validate filter against node class.
                ValidateFilter(m_nodeClass, value);

                m_attributesModified = true;
                m_filter = value; 
            }
        }

        /// <summary>
        /// The length of the queue used to buffer values.
        /// </summary>
        [DataMember(Order = 11)]
        public uint QueueSize
        {
            get { return m_queueSize; }
            
            set 
            {
                if (m_queueSize != value)
                {
                    m_attributesModified = true;
                }

                m_queueSize = value; 
            }
        }

        /// <summary>
        /// Whether to discard the oldest entries in the queue when it is full.
        /// </summary>
        [DataMember(Order = 12)]
        public bool DiscardOldest
        {
            get { return m_discardOldest; }
            
            set 
            {
                if (m_discardOldest != value)
                {
                    m_attributesModified = true;
                }

                m_discardOldest = value; 
            }
        }
        #endregion

        #region Dynamic Properties
        /// <summary>
        /// The subscription that owns the monitored item.
        /// </summary>
        public Subscription Subscription
        {
            get { return m_subscription; }
            internal set { m_subscription = value; }
        }

        /// <summary>
        /// A local handle assigned to the monitored item.
        /// </summary>
        public object Handle
        {
            get { return m_handle; }
            set { m_handle = value; }
        }

        /// <summary>
        /// Whether the item has been created on the server.
        /// </summary>
        public bool Created
        {
            get { return m_status.Created; }
        }

        /// <summary>
        /// The identifier assigned by the client.
        /// </summary>
        public uint ClientHandle
        {
            get { return m_clientHandle; }
        }

        /// <summary>
        /// The node id to monitor after applying any relative path.
        /// </summary>
        public NodeId ResolvedNodeId
        {
            get 
            {
                // just return the start id if relative path is empty.
                if (String.IsNullOrEmpty(m_relativePath))
                {
                    return m_startNodeId;
                }

                return m_resolvedNodeId;  
            }

            internal set { m_resolvedNodeId = value; }
        }

        /// <summary>
        /// Whether the monitoring attributes have been modified since the item was created.
        /// </summary>
        public bool AttributesModified
        {
            get { return m_attributesModified; }
        }

        /// <summary>
        /// The status associated with the monitored item.
        /// </summary>
        public MonitoredItemStatus Status
        {
            get { return m_status; }
        }
        #endregion

        #region Cache Related Functions
        /// <summary>
        /// Returns the queue size used by the cache.
        /// </summary>
        public int CacheQueueSize
        {
            get
            {
                lock (m_cache)
                {
                    if (m_dataCache != null)
                    {
                        return m_dataCache.QueueSize;
                    }
                    
                    if (m_eventCache != null)
                    {
                        return m_eventCache.QueueSize;
                    }

                    return 0;
                }
            }

            set
            {
                lock (m_cache)
                {
                    if (m_dataCache != null)
                    {
                        m_dataCache.SetQueueSize(value);
                    }
                    
                    if (m_eventCache != null)
                    {
                        m_eventCache.SetQueueSize(value);
                    }
                }
            }
        }
        
        /// <summary>
        /// The last value or event received from the server.
        /// </summary>
        public IEncodeable LastValue
        {
            get 
            {
                lock (m_cache)
                {
                    return m_lastNotification;
                }
            }
        }
        
        /// <summary>
        /// Read all values in the cache queue.
        /// </summary>
        public IList<DataValue> DequeueValues()
        {
            lock (m_cache)
            {
                if (m_dataCache != null)
                {
                    return m_dataCache.Publish();
                }

                return new List<DataValue>();
            }
        }
        
        /// <summary>
        /// Read all events in the cache queue.
        /// </summary>
        public IList<EventFieldList> DequeueEvents()
        {
            lock (m_cache)
            {
                if (m_eventCache != null)
                {
                    return m_eventCache.Publish();
                }

                return new List<EventFieldList>();
            }
        }
        
        /// <summary>
        /// The last message containing a notification for the item.
        /// </summary>
        public NotificationMessage LastMessage
        {
            get 
            {
                lock (m_cache)
                {
                    if (m_dataCache != null)
                    {
                        return ((MonitoredItemNotification)m_lastNotification).Message;
                    }
                
                    if (m_eventCache != null)
                    {
                        return ((EventFieldList)m_lastNotification).Message;
                    }

                    return null;
                }
            }
        }
                
        /// <summary>
        /// Raised when a new notification arrives.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1009:DeclareEventHandlersCorrectly")]
        public event MonitoredItemNotificationEventHandler Notification
        {
            add    
            {
                lock (m_cache)
                {
                    m_Notification += value;
                }
            } 
            
            remove 
            {
                lock (m_cache)
                {
                    m_Notification -= value;
                }
            }
        }

        /// <summary>
        /// Saves a data change or event in the cache.
        /// </summary>
        public void SaveValueInCache(IEncodeable newValue)
        {
            lock (m_cache)
            {
                m_lastNotification = newValue;

                if (m_dataCache != null)
                {
                    MonitoredItemNotification datachange = newValue as MonitoredItemNotification;

                    if (datachange != null)
                    {                            
                        // validate the ServerTimestamp of the notification.
                        if (datachange.Value != null && datachange.Value.ServerTimestamp > DateTime.UtcNow)
                        {
                            Utils.Trace("Received ServerTimestamp {0} is in the future for MonitoredItemId {1}", datachange.Value.ServerTimestamp.ToLocalTime(), ClientHandle);
                        }

                        // validate SourceTimestamp of the notification.
                        if (datachange.Value != null && datachange.Value.SourceTimestamp > DateTime.UtcNow)
                        {
                            Utils.Trace("Received SourceTimestamp {0} is in the future for MonitoredItemId {1}", datachange.Value.SourceTimestamp.ToLocalTime(), ClientHandle);
                        }

                        if (datachange.Value != null && datachange.Value.StatusCode.Overflow)
                        {
                            Utils.Trace("Overflow bit set for data change with ServerTimestamp {0} and value {1} for MonitoredItemId {2}", datachange.Value.ServerTimestamp.ToLocalTime(), datachange.Value.Value, ClientHandle);
                        }

                        m_dataCache.OnNotification(datachange);
                    }
                }
                
                if (m_eventCache != null)
                {
                    EventFieldList eventchange = newValue as EventFieldList;

                    m_eventCache?.OnNotification(eventchange);
                }

                if (m_Notification != null)
                {
                    m_Notification(this, new MonitoredItemNotificationEventArgs(newValue));
                }
            }
        }
        #endregion

        #region ICloneable Members
        /// <summary>
        /// Creates a deep copy of the object.
        /// </summary>
        public new object MemberwiseClone()
        {
            return new MonitoredItem(this);
        }
        #endregion
        
        #region Public Methods
        /// <summary>
        /// Sets the error status for the monitored item.
        /// </summary>
        public void SetError(ServiceResult error)
        {
            m_status.SetError(error);
        }

        /// <summary>
        /// Updates the object with the results of a translate browse path request.
        /// </summary>
        public void SetResolvePathResult( 
            BrowsePathResult          result,
            int                       index,
            DiagnosticInfoCollection  diagnosticInfos,         
            ResponseHeader            responseHeader)
        {
            ServiceResult error = null;

            if (StatusCode.IsBad(result.StatusCode))
            {
                error = ClientBase.GetResult(result.StatusCode, index, diagnosticInfos, responseHeader);
            }
            else
            {
                ResolvedNodeId = NodeId.Null;

                // update the node id.
                if (result.Targets.Count > 0)
                {
                    ResolvedNodeId = ExpandedNodeId.ToNodeId(result.Targets[0].TargetId, m_subscription.Session.NamespaceUris);
                }
            }

            m_status.SetResolvePathResult(result, error);
        }

        /// <summary>
        /// Updates the object with the results of a create monitored item request.
        /// </summary>
        public void SetCreateResult(            
            MonitoredItemCreateRequest request,
            MonitoredItemCreateResult  result,
            int                        index,
            DiagnosticInfoCollection   diagnosticInfos,            
            ResponseHeader             responseHeader)
        {
            ServiceResult error = null;

            if (StatusCode.IsBad(result.StatusCode))
            {
                error = ClientBase.GetResult(result.StatusCode, index, diagnosticInfos, responseHeader);
            }

            m_status.SetCreateResult(request, result, error);
            m_attributesModified = false;
        }
        
        /// <summary>
        /// Updates the object with the results of a modify monitored item request.
        /// </summary>
        public void SetModifyResult(            
            MonitoredItemModifyRequest request,
            MonitoredItemModifyResult  result,
            int                        index,
            DiagnosticInfoCollection   diagnosticInfos,            
            ResponseHeader             responseHeader)
        {
            ServiceResult error = null;

            if (StatusCode.IsBad(result.StatusCode))
            {
                error = ClientBase.GetResult(result.StatusCode, index, diagnosticInfos, responseHeader);
            }

            m_status.SetModifyResult(request, result, error);
            m_attributesModified = false;
        }
        
        /// <summary>
        /// Updates the object with the results of a modify monitored item request.
        /// </summary>
        public void SetDeleteResult(            
            StatusCode               result,
            int                      index,
            DiagnosticInfoCollection diagnosticInfos,            
            ResponseHeader           responseHeader)
        {
            ServiceResult error = null;

            if (StatusCode.IsBad(result))
            {
                error = ClientBase.GetResult(result, index, diagnosticInfos, responseHeader);
            }

            m_status.SetDeleteResult(error);
        }

        /// <summary>
        /// Returns the field name the specified SelectClause in the EventFilter.
        /// </summary>
        public string GetFieldName(int index)
        {
            EventFilter filter = m_filter as EventFilter;

            if (filter == null)
            {
                return null;
            }

            if (index < 0 || index >= filter.SelectClauses.Count)
            {
                return null;
            }

            return Utils.Format("{0}", SimpleAttributeOperand.Format(filter.SelectClauses[index].BrowsePath));
        }
        
        /// <summary>
        /// Returns value of the field name containing the event type.
        /// </summary>
        public object GetFieldValue(
            EventFieldList eventFields, 
            NodeId         eventTypeId, 
            string         browsePath, 
            uint           attributeId)
        {
            QualifiedNameCollection browseNames = SimpleAttributeOperand.Parse(browsePath);
            return GetFieldValue(eventFields, eventTypeId, browseNames, attributeId);
        }

        /// <summary>
        /// Returns value of the field name containing the event type.
        /// </summary>
        public object GetFieldValue(
            EventFieldList eventFields, 
            NodeId         eventTypeId, 
            QualifiedName  browseName)
        {
            QualifiedNameCollection browsePath = new QualifiedNameCollection();
            browsePath.Add(browseName);
            return GetFieldValue(eventFields, eventTypeId, browsePath, Attributes.Value);
        }

        /// <summary>
        /// Returns value of the field name containing the event type.
        /// </summary>
        public object GetFieldValue(
            EventFieldList       eventFields, 
            NodeId               eventTypeId, 
            IList<QualifiedName> browsePath, 
            uint                 attributeId)
        {
            if (eventFields == null)
            {
                return null;
            }
            
            EventFilter filter = m_filter as EventFilter;

            if (filter == null)
            {
                return null;
            }
            
            for (int ii = 0; ii < filter.SelectClauses.Count; ii++)
            {
                if (ii >= eventFields.EventFields.Count)
                {
                    return null;
                }
                
                // check for match.
                SimpleAttributeOperand clause = filter.SelectClauses[ii];

                // attribute id
                if (clause.AttributeId != attributeId)
                {
                    continue;
                }
                
                // match null browse path.
                if (browsePath == null || browsePath.Count == 0)
                {
                    if (clause.BrowsePath != null && clause.BrowsePath.Count > 0)
                    {
                        continue;
                    }
                    
                    // ignore event type id when matching null browse paths.
                    return eventFields.EventFields[ii].Value;
                }

                // match browse path.

                // event type id.
                if (clause.TypeDefinitionId != eventTypeId)
                {
                    continue;
                }

                // match element count.
                if (clause.BrowsePath.Count != browsePath.Count)
                {
                    continue;
                }
            
                // check each element.
                bool match = true;

                for (int jj = 0; jj < clause.BrowsePath.Count; jj++)
                {                    
                    if (clause.BrowsePath[jj] !=  browsePath[jj])
                    {
                        match = false;
                        break;
                    }
                }

                // check of no match.
                if (!match)
                {
                    continue;
                }
            
                // return value.
                return eventFields.EventFields[ii].Value;
            }

            // no event type in event field list.
            return null;
        }
        
        /// <summary>
        /// Returns value of the field name containing the event type.
        /// </summary>
        public INode GetEventType(EventFieldList eventFields)
        {
            // get event type.
            NodeId eventTypeId = GetFieldValue(eventFields, ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.EventType) as NodeId;

            if (eventTypeId != null && m_subscription != null && m_subscription.Session != null)
            {
                return m_subscription.Session.NodeCache.Find(eventTypeId);
            }

            // no event type in event field list.
            return null;
        }

        /// <summary>
        /// Returns value of the field name containing the event type.
        /// </summary>
        public DateTime GetEventTime(EventFieldList eventFields)
        {
            // get event time.
            DateTime? eventTime = GetFieldValue(eventFields, ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.Time) as DateTime?;

            if (eventTime != null)
            {
                return eventTime.Value;
            }

            // no event time in event field list.
            return DateTime.MinValue;
        }

        /// <summary>
        /// The service result for a data change notification.
        /// </summary>
        public static ServiceResult GetServiceResult(IEncodeable notification)
        {
            MonitoredItemNotification datachange = notification as MonitoredItemNotification;

            if (datachange == null)
            {
                return null;
            }

            NotificationMessage message = datachange.Message;

            if (message == null)
            {
                return null;
            }

            return new ServiceResult(datachange.Value.StatusCode, datachange.DiagnosticInfo, message.StringTable);
        }

        /// <summary>
        /// The service result for a field in an notification (the field must contain a Status object).
        /// </summary>
        public static ServiceResult GetServiceResult(IEncodeable notification, int index)
        {
            EventFieldList eventFields = notification as EventFieldList;

            if (eventFields == null)
            {
                return null;
            }

            NotificationMessage message = eventFields.Message;

            if (message == null)
            {
                return null;
            }

            if (index < 0 || index >= eventFields.EventFields.Count)
            {
                return null;
            }

            StatusResult status = ExtensionObject.ToEncodeable(eventFields.EventFields[index].Value as ExtensionObject) as StatusResult;

            if (status == null)
            {
                return null;
            }

            return new ServiceResult(status.StatusCode, status.DiagnosticInfo, message.StringTable);
        }
        #endregion
            
        #region Private Methods
        /// <summary>
        /// Throws an exception if the flter cannot be used with the node class.
        /// </summary>
        private void ValidateFilter(NodeClass nodeClass, MonitoringFilter filter)
        {
            if (filter == null)
            {
                return;
            }

            switch (nodeClass)
            {
                case NodeClass.Variable:
                case NodeClass.VariableType:
                {
                    if (!typeof(DataChangeFilter).IsInstanceOfType(filter))
                    {
                        m_nodeClass = NodeClass.Variable;
                    }

                    break;
                }

                case NodeClass.Object:
                case NodeClass.View:
                {
                    if (!typeof(EventFilter).IsInstanceOfType(filter))
                    {                        
                        m_nodeClass = NodeClass.Object;
                    }

                    break;
                }

                default:
                {
                    throw ServiceResultException.Create(StatusCodes.BadFilterNotAllowed, "Filters may not be specified for nodes of class '{0}'.", nodeClass);
                }
            }
        }

        /// <summary>
        /// Sets the default event filter.
        /// </summary>
        private void UseDefaultEventFilter()
        {
            EventFilter filter = filter = new EventFilter();

            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.EventId);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.EventType);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.SourceNode);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.SourceName);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.Time);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.ReceiveTime);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.LocalTime);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.Message);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.Severity);

            m_filter = filter;
        }
        #endregion
        
        #region Private Fields
        private Subscription m_subscription;
        private object m_handle;
        private string m_displayName;
        private NodeId m_startNodeId;
        private string m_relativePath;
        private NodeId m_resolvedNodeId;
        private NodeClass m_nodeClass;
        private uint m_attributeId;
        private string m_indexRange;
        private QualifiedName m_encoding;
        private MonitoringMode m_monitoringMode;
        private int m_samplingInterval;
        private MonitoringFilter m_filter;
        private uint m_queueSize;
        private bool m_discardOldest;
        private uint m_clientHandle;
        private MonitoredItemStatus m_status;
        private bool m_attributesModified;
        private static long s_GlobalClientHandle;
        
        private object m_cache = new object();
        private MonitoredItemDataCache m_dataCache;
        private MonitoredItemEventCache m_eventCache;
        private IEncodeable m_lastNotification;
        private event MonitoredItemNotificationEventHandler m_Notification;   
        #endregion
    }

    #region MonitoredItemEventArgs Class
    /// <summary>
    /// The event arguments provided when a new notification message arrives.
    /// </summary>
    public class MonitoredItemNotificationEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Creates a new instance.
        /// </summary>
        internal MonitoredItemNotificationEventArgs(IEncodeable notificationValue)
        {
            m_notificationValue = notificationValue;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// The new notification.
        /// </summary>
        public IEncodeable NotificationValue
        {
            get { return m_notificationValue; }
        }
        #endregion
        
        #region Private Fields
        private IEncodeable m_notificationValue;
        #endregion
    }
    
    /// <summary>
    /// The delegate used to receive monitored item value notifications.
    /// </summary>
    public delegate void MonitoredItemNotificationEventHandler(MonitoredItem monitoredItem, MonitoredItemNotificationEventArgs e);
    #endregion
    
    /// <summary>
    /// An item in the cache
    /// </summary>
    public class MonitoredItemDataCache
    {
        #region Constructors
        /// <summary>
        /// Constructs a cache for a monitored item.
        /// </summary>
        public MonitoredItemDataCache(int queueSize)
        {
            m_queueSize = queueSize;
            m_values = new Queue<DataValue>();
        }
        #endregion
        
        #region Public Members
        /// <summary>
        /// The size of the queue to maintain.
        /// </summary>
        public int QueueSize
        {
            get { return m_queueSize; }
        }

        /// <summary>
        /// The last value received from the server.
        /// </summary>
        public DataValue LastValue
        {
            get { return m_lastValue; }
        }
        
        /// <summary>
        /// Returns all values in the queue.
        /// </summary>
        public IList<DataValue> Publish()
        {
            DataValue[] values = new DataValue[m_values.Count];

            for (int ii = 0; ii < values.Length; ii++)
            {
                values[ii] = m_values.Dequeue();
            }

            return values;
        }

        /// <summary>
        /// Saves a notification in the cache.
        /// </summary>
        public void OnNotification(MonitoredItemNotification notification)
        {
            m_values.Enqueue(notification.Value);
            m_lastValue = notification.Value;
            
            Utils.Trace(
                "NotificationReceived: ClientHandle={0}, Value={1}", 
                notification.ClientHandle,
                m_lastValue.Value);

            while (m_values.Count > m_queueSize)
            {
                m_values.Dequeue();
            }
        }
        
        /// <summary>
        /// Changes the queue size.
        /// </summary>
        public void SetQueueSize(int queueSize)
        {
            if (queueSize == m_queueSize)
            {
                return;
            }

            if (queueSize < 1)
            {
                queueSize = 1;
            }

            m_queueSize = queueSize;

            while (m_values.Count > m_queueSize)
            {
                m_values.Dequeue();
            }
        }
        #endregion

        #region Private Fields
        private int m_queueSize;
        private DataValue m_lastValue;
        private Queue<DataValue> m_values;
        #endregion
    }
    
    /// <summary>
    /// Saves the events received from the srever.
    /// </summary>
    public class MonitoredItemEventCache
    {
        #region Constructors
        /// <summary>
        /// Constructs a cache for a monitored item.
        /// </summary>
        public MonitoredItemEventCache(int queueSize)
        {
            m_queueSize = queueSize;
            m_events = new Queue<EventFieldList>();
        }
        #endregion
        
        #region Public Members
        /// <summary>
        /// The size of the queue to maintain.
        /// </summary>
        public int QueueSize
        {
            get { return m_queueSize; }
        }

        /// <summary>
        /// The last event received.
        /// </summary>
        public EventFieldList LastEvent
        {
            get { return m_lastEvent; }
        }

        /// <summary>
        /// Returns all events in the queue.
        /// </summary>
        public IList<EventFieldList> Publish()
        {
            EventFieldList[] events = new EventFieldList[m_events.Count];

            for (int ii = 0; ii < events.Length; ii++)
            {
                events[ii] = m_events.Dequeue();
            }

            return events;
        }

        /// <summary>
        /// Saves a notification in the cache.
        /// </summary>
        public void OnNotification(EventFieldList notification)
        {
            m_events.Enqueue(notification);
            m_lastEvent = notification;

            while (m_events.Count > m_queueSize)
            {
                m_events.Dequeue();
            }
        }
        
        /// <summary>
        /// Changes the queue size.
        /// </summary>
        public void SetQueueSize(int queueSize)
        {
            if (queueSize == m_queueSize)
            {
                return;
            }

            if (queueSize < 1)
            {
                queueSize = 1;
            }

            m_queueSize = queueSize;

            while (m_events.Count > m_queueSize)
            {
                m_events.Dequeue();
            }
        }
        #endregion

        #region Private Fields
        private int m_queueSize;
        private EventFieldList m_lastEvent;
        private Queue<EventFieldList> m_events;
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Runtime.Serialization;
using System.Reflection;

namespace Opc.Ua.Client
{
    /// <summary>
    /// A monitored item.
    /// </summary>
    [DataContract(Namespace = Namespaces.OpcUaXsd)]
    [KnownType(typeof(DataChangeFilter))]
    [KnownType(typeof(EventFilter))]
    [KnownType(typeof(AggregateFilter))]
    public class MonitoredItem
    {
        #region Constructors
        /// <summary>
        /// Initializes a new instance of the <see cref="MonitoredItem"/> class.
        /// </summary>
        public MonitoredItem()
        {
            Initialize();
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MonitoredItem"/> class.
        /// </summary>
        /// <param name="clientHandle">The client handle. The caller must ensure it uniquely identifies the monitored item.</param>
        public MonitoredItem(uint clientHandle)
        {
            Initialize();
            m_clientHandle = clientHandle;
        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="MonitoredItem"/> class.
        /// </summary>
        /// <param name="template">The template used to specify the monitoring parameters.</param>
        public MonitoredItem(MonitoredItem template) : this(template, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MonitoredItem"/> class.
        /// </summary>
        /// <param name="template">The template used to specify the monitoring parameters.</param>
        /// <param name="copyEventHandlers">if set to <c>true</c> the event handlers are copied.</param>
        public MonitoredItem(MonitoredItem template, bool copyEventHandlers) : this(template, copyEventHandlers, false)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MonitoredItem"/> class.
        /// </summary>
        /// <param name="template">The template used to specify the monitoring parameters.</param>
        /// <param name="copyEventHandlers">if set to <c>true</c> the event handlers are copied.</param>
        /// <param name="copyClientHandle">if set to <c>true</c> the clientHandle is of the template copied.</param>
        public MonitoredItem(MonitoredItem template, bool copyEventHandlers, bool copyClientHandle)
        {
            Initialize();

            if (template != null)
            {
                string displayName = template.DisplayName;

                if (displayName != null)
                {
                    // remove any existing numeric suffix.
                    int index = displayName.LastIndexOf(' ');

                    if (index != -1)
                    {
                        try
                        {
                            displayName = displayName.Substring(0, index);
                        }
                        catch
                        {
                            // not a numeric suffix.
                        }
                    }
                }

                m_handle             = template.m_handle;
                m_displayName        = Utils.Format("{0} {1}", displayName, m_clientHandle);
                m_startNodeId        = template.m_startNodeId;
                m_relativePath       = template.m_relativePath;
                m_attributeId        = template.m_attributeId;
                m_indexRange         = template.m_indexRange;
                m_encoding           = template.m_encoding; 
                m_monitoringMode     = template.m_monitoringMode;
                m_samplingInterval   = template.m_samplingInterval;
                m_filter             = (MonitoringFilter)Utils.Clone(template.m_filter);
                m_queueSize          = template.m_queueSize;
                m_discardOldest      = template.m_discardOldest;
                m_attributesModified = true;

                if (copyEventHandlers)
                {
                    m_Notification = template.m_Notification;
                }

                if (copyClientHandle)
                {
                    m_clientHandle = template.m_clientHandle;
                }

                // this ensures the state is consistent with the node class.
                NodeClass = template.m_nodeClass;
            }
        }
        
		/// <summary>
		/// Called by the .NET framework during deserialization.
		/// </summary>
	    [OnDeserializing]
		private void Initialize(StreamingContext context)
		{
            // object initializers are not called during deserialization.
            m_cache = new object();

            Initialize();
		}

        /// <summary>
        /// Sets the private members to default values.
        /// </summary>
        private void Initialize()
        {
            m_startNodeId          = null;
            m_relativePath         = null;
            m_clientHandle         = 0;
            m_attributeId          = Attributes.Value;
            m_indexRange           = null;
            m_encoding             = null; 
            m_monitoringMode       = MonitoringMode.Reporting;
            m_samplingInterval     = -1;
            m_filter               = null;
            m_queueSize            = 0;
            m_discardOldest        = true;
            m_attributesModified   = true;
            m_status               = new MonitoredItemStatus();

            // this ensures the state is consistent with the node class.
            NodeClass = NodeClass.Variable;

            // assign a unique handle.
            m_clientHandle = Utils.IncrementIdentifier(ref s_GlobalClientHandle);
        }
        #endregion
        
        #region Persistent Properties
        /// <summary>
        /// A display name for the monitored item.
        /// </summary>
        [DataMember(Order = 1)]
        public string DisplayName
        {
            get { return m_displayName;  }
            set { m_displayName = value; }
        }
        

        /// <summary>
        /// The start node for the browse path that identifies the node to monitor.
        /// </summary>
        [DataMember(Order = 2)]
        public NodeId StartNodeId
        {
            get { return m_startNodeId;  }
            set { m_startNodeId = value; }
        }
        
        /// <summary>
        /// The relative path from the browse path to the node to monitor.
        /// </summary>
        /// <remarks>
        /// A null or empty string specifies that the start node id should be monitored.
        /// </remarks>
        [DataMember(Order = 3)]
        public string RelativePath
        {
            get { return m_relativePath;  }
            
            set 
            {
                // clear resolved path if relative path has changed.
                if (m_relativePath != value)
                {
                    m_resolvedNodeId = null;
                }

                m_relativePath = value;
            }
        }
        
        /// <summary>
        /// The node class of the node being monitored (affects the type of filter available).
        /// </summary>
        [DataMember(Order = 4)]
        public NodeClass NodeClass
        {
            get { return m_nodeClass; }
            
            set 
            {
                if (m_nodeClass != value)
                {
                    if ((value & (NodeClass.Object | NodeClass.View)) != 0)
                    {
                        // ensure a valid event filter.
                        if (!(m_filter is EventFilter))
                        {
                            UseDefaultEventFilter();
                        }

                        // set the queue size to the default for events.
                        if (QueueSize <= 1)
                        {
                            QueueSize = Int32.MaxValue;
                        }

                        m_eventCache = new MonitoredItemEventCache(100);
                        m_attributeId = Attributes.EventNotifier;
                    }
                    else
                    {
                        // clear the filter if it is only valid for events.
                        if (m_filter is EventFilter)
                        {
                            m_filter = null;
                        }

                        // set the queue size to the default for data changes.
                        if (QueueSize == Int32.MaxValue)
                        {
                            QueueSize = 1;
                        }

                        m_dataCache = new MonitoredItemDataCache(1);
                    }
                }

                m_nodeClass = value;
            }
        }

        /// <summary>
        /// The attribute to monitor.
        /// </summary>
        [DataMember(Order = 5)]
        public uint AttributeId
        {
            get { return m_attributeId;  }
            set { m_attributeId = value; }
        }

        /// <summary>
        /// The range of array indexes to monitor.
        /// </summary>
        [DataMember(Order = 6)]
        public string IndexRange
        {
            get { return m_indexRange;  }
            set { m_indexRange = value; }
        }

        /// <summary>
        /// The encoding to use when returning notifications.
        /// </summary>
        [DataMember(Order = 7)]
        public QualifiedName Encoding
        {
            get { return m_encoding;  }
            set { m_encoding = value; }
        }

        /// <summary>
        /// The monitoring mode.
        /// </summary>
        [DataMember(Order = 8)]
        public MonitoringMode MonitoringMode
        {
            get { return m_monitoringMode;  }
            set { m_monitoringMode = value; }
        }
        
        /// <summary>
        /// The sampling interval.
        /// </summary>
        [DataMember(Order = 9)]
        public int SamplingInterval
        {
            get { return m_samplingInterval; }
            
            set 
            {
                if (m_samplingInterval != value)
                {
                    m_attributesModified = true;
                }

                m_samplingInterval = value; 
            }
        }

        /// <summary>
        /// The filter to use to select values to return.
        /// </summary>
        [DataMember(Order = 10)]
        public MonitoringFilter Filter
        {
            get { return m_filter; }
            
            set 
            {
                // validate filter against node class.
                ValidateFilter(m_nodeClass, value);

                m_attributesModified = true;
                m_filter = value; 
            }
        }

        /// <summary>
        /// The length of the queue used to buffer values.
        /// </summary>
        [DataMember(Order = 11)]
        public uint QueueSize
        {
            get { return m_queueSize; }
            
            set 
            {
                if (m_queueSize != value)
                {
                    m_attributesModified = true;
                }

                m_queueSize = value; 
            }
        }

        /// <summary>
        /// Whether to discard the oldest entries in the queue when it is full.
        /// </summary>
        [DataMember(Order = 12)]
        public bool DiscardOldest
        {
            get { return m_discardOldest; }
            
            set 
            {
                if (m_discardOldest != value)
                {
                    m_attributesModified = true;
                }

                m_discardOldest = value; 
            }
        }
        #endregion

        #region Dynamic Properties
        /// <summary>
        /// The subscription that owns the monitored item.
        /// </summary>
        public Subscription Subscription
        {
            get { return m_subscription; }
            internal set { m_subscription = value; }
        }

        /// <summary>
        /// A local handle assigned to the monitored item.
        /// </summary>
        public object Handle
        {
            get { return m_handle; }
            set { m_handle = value; }
        }

        /// <summary>
        /// Whether the item has been created on the server.
        /// </summary>
        public bool Created
        {
            get { return m_status.Created; }
        }

        /// <summary>
        /// The identifier assigned by the client.
        /// </summary>
        public uint ClientHandle
        {
            get { return m_clientHandle; }
        }

        /// <summary>
        /// The node id to monitor after applying any relative path.
        /// </summary>
        public NodeId ResolvedNodeId
        {
            get 
            {
                // just return the start id if relative path is empty.
                if (String.IsNullOrEmpty(m_relativePath))
                {
                    return m_startNodeId;
                }

                return m_resolvedNodeId;  
            }

            internal set { m_resolvedNodeId = value; }
        }

        /// <summary>
        /// Whether the monitoring attributes have been modified since the item was created.
        /// </summary>
        public bool AttributesModified
        {
            get { return m_attributesModified; }
        }

        /// <summary>
        /// The status associated with the monitored item.
        /// </summary>
        public MonitoredItemStatus Status
        {
            get { return m_status; }
        }
        #endregion

        #region Cache Related Functions
        /// <summary>
        /// Returns the queue size used by the cache.
        /// </summary>
        public int CacheQueueSize
        {
            get
            {
                lock (m_cache)
                {
                    if (m_dataCache != null)
                    {
                        return m_dataCache.QueueSize;
                    }
                    
                    if (m_eventCache != null)
                    {
                        return m_eventCache.QueueSize;
                    }

                    return 0;
                }
            }

            set
            {
                lock (m_cache)
                {
                    if (m_dataCache != null)
                    {
                        m_dataCache.SetQueueSize(value);
                    }
                    
                    if (m_eventCache != null)
                    {
                        m_eventCache.SetQueueSize(value);
                    }
                }
            }
        }
        
        /// <summary>
        /// The last value or event received from the server.
        /// </summary>
        public IEncodeable LastValue
        {
            get 
            {
                lock (m_cache)
                {
                    return m_lastNotification;
                }
            }
        }
        
        /// <summary>
        /// Read all values in the cache queue.
        /// </summary>
        public IList<DataValue> DequeueValues()
        {
            lock (m_cache)
            {
                if (m_dataCache != null)
                {
                    return m_dataCache.Publish();
                }

                return new List<DataValue>();
            }
        }
        
        /// <summary>
        /// Read all events in the cache queue.
        /// </summary>
        public IList<EventFieldList> DequeueEvents()
        {
            lock (m_cache)
            {
                if (m_eventCache != null)
                {
                    return m_eventCache.Publish();
                }

                return new List<EventFieldList>();
            }
        }
        
        /// <summary>
        /// The last message containing a notification for the item.
        /// </summary>
        public NotificationMessage LastMessage
        {
            get 
            {
                lock (m_cache)
                {
                    if (m_dataCache != null)
                    {
                        return ((MonitoredItemNotification)m_lastNotification).Message;
                    }
                
                    if (m_eventCache != null)
                    {
                        return ((EventFieldList)m_lastNotification).Message;
                    }

                    return null;
                }
            }
        }
                
        /// <summary>
        /// Raised when a new notification arrives.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1009:DeclareEventHandlersCorrectly")]
        public event MonitoredItemNotificationEventHandler Notification
        {
            add    
            {
                lock (m_cache)
                {
                    m_Notification += value;
                }
            } 
            
            remove 
            {
                lock (m_cache)
                {
                    m_Notification -= value;
                }
            }
        }

        /// <summary>
        /// Saves a data change or event in the cache.
        /// </summary>
        public void SaveValueInCache(IEncodeable newValue)
        {
            lock (m_cache)
            {
                m_lastNotification = newValue;

                if (m_dataCache != null)
                {
                    if (newValue is MonitoredItemNotification datachange)
                    {                            
                        // validate the ServerTimestamp of the notification.
                        if (datachange.Value != null && datachange.Value.ServerTimestamp > DateTime.UtcNow)
                        {
                            Utils.Trace("Received ServerTimestamp {0} is in the future for MonitoredItemId {1}", datachange.Value.ServerTimestamp.ToLocalTime(), ClientHandle);
                        }

                        // validate SourceTimestamp of the notification.
                        if (datachange.Value != null && datachange.Value.SourceTimestamp > DateTime.UtcNow)
                        {
                            Utils.Trace("Received SourceTimestamp {0} is in the future for MonitoredItemId {1}", datachange.Value.SourceTimestamp.ToLocalTime(), ClientHandle);
                        }

                        if (datachange.Value != null && datachange.Value.StatusCode.Overflow)
                        {
                            Utils.Trace("Overflow bit set for data change with ServerTimestamp {0} and value {1} for MonitoredItemId {2}", datachange.Value.ServerTimestamp.ToLocalTime(), datachange.Value.Value, ClientHandle);
                        }

                        m_dataCache.OnNotification(datachange);
                    }
                }
                
                if (m_eventCache != null)
                {
                    EventFieldList eventchange = newValue as EventFieldList;

                    m_eventCache?.OnNotification(eventchange);
                }

                if (m_Notification != null)
                {
                    m_Notification(this, new MonitoredItemNotificationEventArgs(newValue));
                }
            }
        }
        #endregion

        #region ICloneable Members
        /// <summary>
        /// Creates a deep copy of the object.
        /// </summary>
        public new object MemberwiseClone()
        {
            return new MonitoredItem(this);
        }
        #endregion
        
        #region Public Methods
        /// <summary>
        /// Sets the error status for the monitored item.
        /// </summary>
        public void SetError(ServiceResult error)
        {
            m_status.SetError(error);
        }

        /// <summary>
        /// Updates the object with the results of a translate browse path request.
        /// </summary>
        public void SetResolvePathResult( 
            BrowsePathResult          result,
            int                       index,
            DiagnosticInfoCollection  diagnosticInfos,         
            ResponseHeader            responseHeader)
        {
            ServiceResult error = null;

            if (StatusCode.IsBad(result.StatusCode))
            {
                error = ClientBase.GetResult(result.StatusCode, index, diagnosticInfos, responseHeader);
            }
            else
            {
                ResolvedNodeId = NodeId.Null;

                // update the node id.
                if (result.Targets.Count > 0)
                {
                    ResolvedNodeId = ExpandedNodeId.ToNodeId(result.Targets[0].TargetId, m_subscription.Session.NamespaceUris);
                }
            }

            m_status.SetResolvePathResult(result, error);
        }

        /// <summary>
        /// Updates the object with the results of a create monitored item request.
        /// </summary>
        public void SetCreateResult(            
            MonitoredItemCreateRequest request,
            MonitoredItemCreateResult  result,
            int                        index,
            DiagnosticInfoCollection   diagnosticInfos,            
            ResponseHeader             responseHeader)
        {
            ServiceResult error = null;

            if (StatusCode.IsBad(result.StatusCode))
            {
                error = ClientBase.GetResult(result.StatusCode, index, diagnosticInfos, responseHeader);
            }

            m_status.SetCreateResult(request, result, error);
            m_attributesModified = false;
        }
        
        /// <summary>
        /// Updates the object with the results of a modify monitored item request.
        /// </summary>
        public void SetModifyResult(            
            MonitoredItemModifyRequest request,
            MonitoredItemModifyResult  result,
            int                        index,
            DiagnosticInfoCollection   diagnosticInfos,            
            ResponseHeader             responseHeader)
        {
            ServiceResult error = null;

            if (StatusCode.IsBad(result.StatusCode))
            {
                error = ClientBase.GetResult(result.StatusCode, index, diagnosticInfos, responseHeader);
            }

            m_status.SetModifyResult(request, result, error);
            m_attributesModified = false;
        }
        
        /// <summary>
        /// Updates the object with the results of a modify monitored item request.
        /// </summary>
        public void SetDeleteResult(            
            StatusCode               result,
            int                      index,
            DiagnosticInfoCollection diagnosticInfos,            
            ResponseHeader           responseHeader)
        {
            ServiceResult error = null;

            if (StatusCode.IsBad(result))
            {
                error = ClientBase.GetResult(result, index, diagnosticInfos, responseHeader);
            }

            m_status.SetDeleteResult(error);
        }

        /// <summary>
        /// Returns the field name the specified SelectClause in the EventFilter.
        /// </summary>
        public string GetFieldName(int index)
        {
            EventFilter filter = m_filter as EventFilter;

            if (filter == null)
            {
                return null;
            }

            if (index < 0 || index >= filter.SelectClauses.Count)
            {
                return null;
            }

            return Utils.Format("{0}", SimpleAttributeOperand.Format(filter.SelectClauses[index].BrowsePath));
        }
        
        /// <summary>
        /// Returns value of the field name containing the event type.
        /// </summary>
        public object GetFieldValue(
            EventFieldList eventFields, 
            NodeId         eventTypeId, 
            string         browsePath, 
            uint           attributeId)
        {
            QualifiedNameCollection browseNames = SimpleAttributeOperand.Parse(browsePath);
            return GetFieldValue(eventFields, eventTypeId, browseNames, attributeId);
        }

        /// <summary>
        /// Returns value of the field name containing the event type.
        /// </summary>
        public object GetFieldValue(
            EventFieldList eventFields, 
            NodeId         eventTypeId, 
            QualifiedName  browseName)
        {
            QualifiedNameCollection browsePath = new QualifiedNameCollection();
            browsePath.Add(browseName);
            return GetFieldValue(eventFields, eventTypeId, browsePath, Attributes.Value);
        }

        /// <summary>
        /// Returns value of the field name containing the event type.
        /// </summary>
        public object GetFieldValue(
            EventFieldList       eventFields, 
            NodeId               eventTypeId, 
            IList<QualifiedName> browsePath, 
            uint                 attributeId)
        {
            if (eventFields == null)
            {
                return null;
            }
            
            EventFilter filter = m_filter as EventFilter;

            if (filter == null)
            {
                return null;
            }
            
            for (int ii = 0; ii < filter.SelectClauses.Count; ii++)
            {
                if (ii >= eventFields.EventFields.Count)
                {
                    return null;
                }
                
                // check for match.
                SimpleAttributeOperand clause = filter.SelectClauses[ii];

                // attribute id
                if (clause.AttributeId != attributeId)
                {
                    continue;
                }
                
                // match null browse path.
                if (browsePath == null || browsePath.Count == 0)
                {
                    if (clause.BrowsePath != null && clause.BrowsePath.Count > 0)
                    {
                        continue;
                    }
                    
                    // ignore event type id when matching null browse paths.
                    return eventFields.EventFields[ii].Value;
                }

                // match browse path.

                // event type id.
                if (clause.TypeDefinitionId != eventTypeId)
                {
                    continue;
                }

                // match element count.
                if (clause.BrowsePath.Count != browsePath.Count)
                {
                    continue;
                }
            
                // check each element.
                bool match = true;

                for (int jj = 0; jj < clause.BrowsePath.Count; jj++)
                {                    
                    if (clause.BrowsePath[jj] !=  browsePath[jj])
                    {
                        match = false;
                        break;
                    }
                }

                // check of no match.
                if (!match)
                {
                    continue;
                }
            
                // return value.
                return eventFields.EventFields[ii].Value;
            }

            // no event type in event field list.
            return null;
        }
        
        /// <summary>
        /// Returns value of the field name containing the event type.
        /// </summary>
        public INode GetEventType(EventFieldList eventFields)
        {
            // get event type.

            if (GetFieldValue(eventFields, ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.EventType) is NodeId eventTypeId && m_subscription != null && m_subscription.Session != null)
            {
                return m_subscription.Session.NodeCache.Find(eventTypeId);
            }

            // no event type in event field list.
            return null;
        }

        /// <summary>
        /// Returns value of the field name containing the event type.
        /// </summary>
        public DateTime GetEventTime(EventFieldList eventFields)
        {
            // get event time.

            if (GetFieldValue(eventFields, ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.Time) is DateTime? eventTime)
            {
                return eventTime.Value;
            }

            // no event time in event field list.
            return DateTime.MinValue;
        }

        /// <summary>
        /// The service result for a data change notification.
        /// </summary>
        public static ServiceResult GetServiceResult(IEncodeable notification)
        {
            MonitoredItemNotification datachange = notification as MonitoredItemNotification;

            if (datachange == null)
            {
                return null;
            }

            NotificationMessage message = datachange.Message;

            if (message == null)
            {
                return null;
            }

            return new ServiceResult(datachange.Value.StatusCode, datachange.DiagnosticInfo, message.StringTable);
        }

        /// <summary>
        /// The service result for a field in an notification (the field must contain a Status object).
        /// </summary>
        public static ServiceResult GetServiceResult(IEncodeable notification, int index)
        {
            EventFieldList eventFields = notification as EventFieldList;

            if (eventFields == null)
            {
                return null;
            }

            NotificationMessage message = eventFields.Message;

            if (message == null)
            {
                return null;
            }

            if (index < 0 || index >= eventFields.EventFields.Count)
            {
                return null;
            }

            StatusResult status = ExtensionObject.ToEncodeable(eventFields.EventFields[index].Value as ExtensionObject) as StatusResult;

            if (status == null)
            {
                return null;
            }

            return new ServiceResult(status.StatusCode, status.DiagnosticInfo, message.StringTable);
        }
        #endregion
            
        #region Private Methods
        /// <summary>
        /// Throws an exception if the flter cannot be used with the node class.
        /// </summary>
        private void ValidateFilter(NodeClass nodeClass, MonitoringFilter filter)
        {
            if (filter == null)
            {
                return;
            }

            switch (nodeClass)
            {
                case NodeClass.Variable:
                case NodeClass.VariableType:
                {
                    if (!typeof(DataChangeFilter).IsInstanceOfType(filter))
                    {
                        m_nodeClass = NodeClass.Variable;
                    }

                    break;
                }

                case NodeClass.Object:
                case NodeClass.View:
                {
                    if (!typeof(EventFilter).IsInstanceOfType(filter))
                    {                        
                        m_nodeClass = NodeClass.Object;
                    }

                    break;
                }

                default:
                {
                    throw ServiceResultException.Create(StatusCodes.BadFilterNotAllowed, "Filters may not be specified for nodes of class '{0}'.", nodeClass);
                }
            }
        }

        /// <summary>
        /// Sets the default event filter.
        /// </summary>
        private void UseDefaultEventFilter()
        {
            EventFilter filter = filter = new EventFilter();

            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.EventId);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.EventType);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.SourceNode);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.SourceName);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.Time);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.ReceiveTime);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.LocalTime);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.Message);
            filter.AddSelectClause(ObjectTypes.BaseEventType, Opc.Ua.BrowseNames.Severity);

            m_filter = filter;
        }
        #endregion
        
        #region Private Fields
        private Subscription m_subscription;
        private object m_handle;
        private string m_displayName;
        private NodeId m_startNodeId;
        private string m_relativePath;
        private NodeId m_resolvedNodeId;
        private NodeClass m_nodeClass;
        private uint m_attributeId;
        private string m_indexRange;
        private QualifiedName m_encoding;
        private MonitoringMode m_monitoringMode;
        private int m_samplingInterval;
        private MonitoringFilter m_filter;
        private uint m_queueSize;
        private bool m_discardOldest;
        private uint m_clientHandle;
        private MonitoredItemStatus m_status;
        private bool m_attributesModified;
        private static long s_GlobalClientHandle;
        
        private object m_cache = new object();
        private MonitoredItemDataCache m_dataCache;
        private MonitoredItemEventCache m_eventCache;
        private IEncodeable m_lastNotification;
        private event MonitoredItemNotificationEventHandler m_Notification;   
        #endregion
    }

    #region MonitoredItemEventArgs Class
    /// <summary>
    /// The event arguments provided when a new notification message arrives.
    /// </summary>
    public class MonitoredItemNotificationEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Creates a new instance.
        /// </summary>
        internal MonitoredItemNotificationEventArgs(IEncodeable notificationValue)
        {
            m_notificationValue = notificationValue;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// The new notification.
        /// </summary>
        public IEncodeable NotificationValue
        {
            get { return m_notificationValue; }
        }
        #endregion
        
        #region Private Fields
        private IEncodeable m_notificationValue;
        #endregion
    }
    
    /// <summary>
    /// The delegate used to receive monitored item value notifications.
    /// </summary>
    public delegate void MonitoredItemNotificationEventHandler(MonitoredItem monitoredItem, MonitoredItemNotificationEventArgs e);
    #endregion
    
    /// <summary>
    /// An item in the cache
    /// </summary>
    public class MonitoredItemDataCache
    {
        #region Constructors
        /// <summary>
        /// Constructs a cache for a monitored item.
        /// </summary>
        public MonitoredItemDataCache(int queueSize)
        {
            m_queueSize = queueSize;
            m_values = new Queue<DataValue>();
        }
        #endregion
        
        #region Public Members
        /// <summary>
        /// The size of the queue to maintain.
        /// </summary>
        public int QueueSize
        {
            get { return m_queueSize; }
        }

        /// <summary>
        /// The last value received from the server.
        /// </summary>
        public DataValue LastValue
        {
            get { return m_lastValue; }
        }
        
        /// <summary>
        /// Returns all values in the queue.
        /// </summary>
        public IList<DataValue> Publish()
        {
            DataValue[] values = new DataValue[m_values.Count];

            for (int ii = 0; ii < values.Length; ii++)
            {
                values[ii] = m_values.Dequeue();
            }

            return values;
        }

        /// <summary>
        /// Saves a notification in the cache.
        /// </summary>
        public void OnNotification(MonitoredItemNotification notification)
        {
            m_values.Enqueue(notification.Value);
            m_lastValue = notification.Value;
            
            Utils.Trace(
                "NotificationReceived: ClientHandle={0}, Value={1}", 
                notification.ClientHandle,
                m_lastValue.Value);

            while (m_values.Count > m_queueSize)
            {
                m_values.Dequeue();
            }
        }
        
        /// <summary>
        /// Changes the queue size.
        /// </summary>
        public void SetQueueSize(int queueSize)
        {
            if (queueSize == m_queueSize)
            {
                return;
            }

            if (queueSize < 1)
            {
                queueSize = 1;
            }

            m_queueSize = queueSize;

            while (m_values.Count > m_queueSize)
            {
                m_values.Dequeue();
            }
        }
        #endregion

        #region Private Fields
        private int m_queueSize;
        private DataValue m_lastValue;
        private Queue<DataValue> m_values;
        #endregion
    }
    
    /// <summary>
    /// Saves the events received from the srever.
    /// </summary>
    public class MonitoredItemEventCache
    {
        #region Constructors
        /// <summary>
        /// Constructs a cache for a monitored item.
        /// </summary>
        public MonitoredItemEventCache(int queueSize)
        {
            m_queueSize = queueSize;
            m_events = new Queue<EventFieldList>();
        }
        #endregion
        
        #region Public Members
        /// <summary>
        /// The size of the queue to maintain.
        /// </summary>
        public int QueueSize
        {
            get { return m_queueSize; }
        }

        /// <summary>
        /// The last event received.
        /// </summary>
        public EventFieldList LastEvent
        {
            get { return m_lastEvent; }
        }

        /// <summary>
        /// Returns all events in the queue.
        /// </summary>
        public IList<EventFieldList> Publish()
        {
            EventFieldList[] events = new EventFieldList[m_events.Count];

            for (int ii = 0; ii < events.Length; ii++)
            {
                events[ii] = m_events.Dequeue();
            }

            return events;
        }

        /// <summary>
        /// Saves a notification in the cache.
        /// </summary>
        public void OnNotification(EventFieldList notification)
        {
            m_events.Enqueue(notification);
            m_lastEvent = notification;

            while (m_events.Count > m_queueSize)
            {
                m_events.Dequeue();
            }
        }
        
        /// <summary>
        /// Changes the queue size.
        /// </summary>
        public void SetQueueSize(int queueSize)
        {
            if (queueSize == m_queueSize)
            {
                return;
            }

            if (queueSize < 1)
            {
                queueSize = 1;
            }

            m_queueSize = queueSize;

            while (m_events.Count > m_queueSize)
            {
                m_events.Dequeue();
            }
        }
        #endregion

        #region Private Fields
        private int m_queueSize;
        private EventFieldList m_lastEvent;
        private Queue<EventFieldList> m_events;
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Client\MonitoredItem.cs(33,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Client\MonitoredItem.cs(35,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Client\MonitoredItem.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Client\MonitoredItem.cs(917,99): error CS8116: It is not legal to use nullable type 'DateTime?' in a pattern; use the underlying type 'DateTime' instead.,D:\a\1\s\Libraries\Opc.Ua.Client\MonitoredItem.cs(33,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Client\MonitoredItem.cs(35,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Libraries\Opc.Ua.Client\MonitoredItem.cs(32,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 29 - MergeSequentialChecksRewriterR2
Filepath: D:\a\1\s\Libraries\Opc.Ua.Client\Session.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Runtime.Serialization;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml;
using Opc.Ua.Security.Certificates;

namespace Opc.Ua.Client
{
    /// <summary>
    /// Manages a session with a server.
    /// </summary>
    public class Session : SessionClient, IDisposable
    {
        #region Constructors
        /// <summary>
        /// Constructs a new instance of the <see cref="Session"/> class.
        /// </summary>
        /// <param name="channel">The channel used to communicate with the server.</param>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="endpoint">The endpoint use to initialize the channel.</param>
        public Session(
            ISessionChannel channel,
            ApplicationConfiguration configuration,
            ConfiguredEndpoint endpoint)
        :
            this(channel as ITransportChannel, configuration, endpoint, null)
        {
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="Session"/> class.
        /// </summary>
        /// <param name="channel">The channel used to communicate with the server.</param>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="endpoint">The endpoint used to initialize the channel.</param>
        /// <param name="clientCertificate">The certificate to use for the client.</param>
        /// <param name="availableEndpoints">The list of available endpoints returned by server in GetEndpoints() response.</param>
        /// <param name="discoveryProfileUris">The value of profileUris used in GetEndpoints() request.</param>
        /// <remarks>
        /// The application configuration is used to look up the certificate if none is provided.
        /// The clientCertificate must have the private key. This will require that the certificate
        /// be loaded from a certicate store. Converting a DER encoded blob to a X509Certificate2
        /// will not include a private key.
        /// The <i>availableEndpoints</i> and <i>discoveryProfileUris</i> parameters are used to validate
        /// that the list of EndpointDescriptions returned at GetEndpoints matches the list returned at CreateSession.
        /// </remarks>
        public Session(
            ITransportChannel channel,
            ApplicationConfiguration configuration,
            ConfiguredEndpoint endpoint,
            X509Certificate2 clientCertificate,
            EndpointDescriptionCollection availableEndpoints = null,
            StringCollection discoveryProfileUris = null)
            :
                base(channel)
        {
            Initialize(channel, configuration, endpoint, clientCertificate);
            m_discoveryServerEndpoints = availableEndpoints;
            m_discoveryProfileUris = discoveryProfileUris;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Session"/> class.
        /// </summary>
        /// <param name="channel">The channel.</param>
        /// <param name="template">The template session.</param>
        /// <param name="copyEventHandlers">if set to <c>true</c> the event handlers are copied.</param>
        public Session(ITransportChannel channel, Session template, bool copyEventHandlers)
        :
            base(channel)
        {
            Initialize(channel, template.m_configuration, template.m_endpoint, template.m_instanceCertificate);

            m_defaultSubscription = template.m_defaultSubscription;
            m_sessionTimeout = template.m_sessionTimeout;
            m_maxRequestMessageSize = template.m_maxRequestMessageSize;
            m_preferredLocales = template.m_preferredLocales;
            m_sessionName = template.m_sessionName;
            m_handle = template.m_handle;
            m_identity = template.m_identity;
            m_keepAliveInterval = template.m_keepAliveInterval;
            m_checkDomain = template.m_checkDomain;

            if (copyEventHandlers)
            {
                m_KeepAlive = template.m_KeepAlive;
                m_Publish = template.m_Publish;
                m_PublishError = template.m_PublishError;
                m_SubscriptionsChanged = template.m_SubscriptionsChanged;
                m_SessionClosing = template.m_SessionClosing;
            }

            foreach (Subscription subscription in template.Subscriptions)
            {
                this.AddSubscription(new Subscription(subscription, copyEventHandlers));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Initializes the channel.
        /// </summary>
        private void Initialize(
            ITransportChannel channel,
            ApplicationConfiguration configuration,
            ConfiguredEndpoint endpoint,
            X509Certificate2 clientCertificate)
        {
            Initialize();

            ValidateClientConfiguration(configuration);

            // save configuration information.
            m_configuration = configuration;
            m_endpoint = endpoint;

            // update the default subscription. 
            m_defaultSubscription.MinLifetimeInterval = (uint)configuration.ClientConfiguration.MinSubscriptionLifetime;

            if (m_endpoint.Description.SecurityPolicyUri != SecurityPolicies.None)
            {
                // update client certificate.
                m_instanceCertificate = clientCertificate;

                if (clientCertificate == null)
                {
                    // load the application instance certificate.
                    if (m_configuration.SecurityConfiguration.ApplicationCertificate == null)
                    {
                        throw new ServiceResultException(
                            StatusCodes.BadConfigurationError,
                            "The client configuration does not specify an application instance certificate.");
                    }

                    m_instanceCertificate = m_configuration.SecurityConfiguration.ApplicationCertificate.Find(true).Result;

                }

                // check for valid certificate.
                if (m_instanceCertificate == null)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadConfigurationError,
                        "Cannot find the application instance certificate. Store={0}, SubjectName={1}, Thumbprint={2}.",
                        m_configuration.SecurityConfiguration.ApplicationCertificate.StorePath,
                        m_configuration.SecurityConfiguration.ApplicationCertificate.SubjectName,
                        m_configuration.SecurityConfiguration.ApplicationCertificate.Thumbprint);
                }

                // check for private key.
                if (!m_instanceCertificate.HasPrivateKey)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadConfigurationError,
                        "No private key for the application instance certificate. Subject={0}, Thumbprint={1}.",
                        m_instanceCertificate.Subject,
                        m_instanceCertificate.Thumbprint);
                }

                // load certificate chain.
                m_instanceCertificateChain = new X509Certificate2Collection(m_instanceCertificate);
                List<CertificateIdentifier> issuers = new List<CertificateIdentifier>();
                configuration.CertificateValidator.GetIssuers(m_instanceCertificate, issuers).Wait();

                for (int i = 0; i < issuers.Count; i++)
                {
                    m_instanceCertificateChain.Add(issuers[i].Certificate);
                }
            }

            // initialize the message context.
            ServiceMessageContext messageContext = channel.MessageContext;

            if (messageContext != null)
            {
                m_namespaceUris = messageContext.NamespaceUris;
                m_serverUris = messageContext.ServerUris;
                m_factory = messageContext.Factory;
            }
            else
            {
                m_namespaceUris = new NamespaceTable();
                m_serverUris = new StringTable();
                m_factory = new EncodeableFactory(EncodeableFactory.GlobalFactory);
            }

            // set the default preferred locales.
            m_preferredLocales = new string[] { CultureInfo.CurrentCulture.Name };

            // create a context to use.
            m_systemContext = new SystemContext();

            m_systemContext.SystemHandle = this;
            m_systemContext.EncodeableFactory = m_factory;
            m_systemContext.NamespaceUris = m_namespaceUris;
            m_systemContext.ServerUris = m_serverUris;
            m_systemContext.TypeTable = this.TypeTree;
            m_systemContext.PreferredLocales = null;
            m_systemContext.SessionId = null;
            m_systemContext.UserIdentity = null;
        }

        /// <summary>
        /// Sets the object members to default values.
        /// </summary>
        private void Initialize()
        {
            m_sessionTimeout = 0;
            m_namespaceUris = new NamespaceTable();
            m_serverUris = new StringTable();
            m_factory = EncodeableFactory.GlobalFactory;
            m_nodeCache = new NodeCache(this);
            m_configuration = null;
            m_instanceCertificate = null;
            m_endpoint = null;
            m_subscriptions = new List<Subscription>();
            m_dictionaries = new Dictionary<NodeId, DataDictionary>();
            m_acknowledgementsToSend = new SubscriptionAcknowledgementCollection();
            m_latestAcknowledgementsSent = new Dictionary<uint, uint>();
            m_identityHistory = new List<IUserIdentity>();
            m_outstandingRequests = new LinkedList<AsyncRequestState>();
            m_keepAliveInterval = 5000;
            m_sessionName = "";

            m_defaultSubscription = new Subscription();

            m_defaultSubscription.DisplayName = "Subscription";
            m_defaultSubscription.PublishingInterval = 1000;
            m_defaultSubscription.KeepAliveCount = 10;
            m_defaultSubscription.LifetimeCount = 1000;
            m_defaultSubscription.Priority = 255;
            m_defaultSubscription.PublishingEnabled = true;
        }

        /// <summary>
        /// Check if all required configuration fields are populated.
        /// </summary>
        private void ValidateClientConfiguration(ApplicationConfiguration configuration)
        {
            String configurationField;
            if (configuration == null)
            {
                throw new ArgumentNullException(nameof(configuration));
            }
            if (configuration.ClientConfiguration == null)
            {
                configurationField = "ClientConfiguration";
            }
            else if (configuration.SecurityConfiguration == null)
            {
                configurationField = "SecurityConfiguration";
            }
            else if (configuration.CertificateValidator == null)
            {
                configurationField = "CertificateValidator";
            }
            else
            {
                return;
            }

            throw new ServiceResultException(
                StatusCodes.BadConfigurationError,
                $"The client configuration does not specify the {configurationField}.");
        }

        /// <summary>
        /// Validates the server nonce and security parameters of user identity.
        /// </summary>
        private void ValidateServerNonce(
            IUserIdentity identity,
            byte[] serverNonce,
            string securityPolicyUri,
            byte[] previousServerNonce,
            MessageSecurityMode channelSecurityMode = MessageSecurityMode.None)
        {
            // skip validation if server nonce is not used for encryption.
            if (String.IsNullOrEmpty(securityPolicyUri) || securityPolicyUri == SecurityPolicies.None)
            {
                return;
            }

            if (identity != null && identity.TokenType != UserTokenType.Anonymous)
            {
                // the server nonce should be validated if the token includes a secret.
                if (!Utils.Nonce.ValidateNonce(serverNonce, MessageSecurityMode.SignAndEncrypt, (uint)m_configuration.SecurityConfiguration.NonceLength))
                {
                    if (channelSecurityMode == MessageSecurityMode.SignAndEncrypt ||
                        m_configuration.SecurityConfiguration.SuppressNonceValidationErrors)
                    {
                        Utils.Trace((int)Utils.TraceMasks.Security, "Warning: The server nonce has not the correct length or is not random enough. The error is suppressed by user setting or because the channel is encrypted.");
                    }
                    else
                    {
                        throw ServiceResultException.Create(StatusCodes.BadNonceInvalid, "The server nonce has not the correct length or is not random enough.");
                    }
                }

                // check that new nonce is different from the previously returned server nonce.
                if (previousServerNonce != null && Utils.CompareNonce(serverNonce, previousServerNonce))
                {
                    if (channelSecurityMode == MessageSecurityMode.SignAndEncrypt ||
                        m_configuration.SecurityConfiguration.SuppressNonceValidationErrors)
                    {
                        Utils.Trace((int)Utils.TraceMasks.Security, "Warning: The Server nonce is equal with previously returned nonce. The error is suppressed by user setting or because the channel is encrypted.");
                    }
                    else
                    {
                        throw ServiceResultException.Create(StatusCodes.BadNonceInvalid, "Server nonce is equal with previously returned nonce.");
                    }
                }
            }
        }

        #endregion

        #region IDisposable Members
        /// <summary>
        /// Closes the session and the underlying channel.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                Utils.SilentDispose(m_keepAliveTimer);
                m_keepAliveTimer = null;

                Utils.SilentDispose(m_defaultSubscription);
                m_defaultSubscription = null;

                foreach (Subscription subscription in m_subscriptions)
                {
                    Utils.SilentDispose(subscription);
                }

                m_subscriptions.Clear();
            }

            base.Dispose(disposing);
        }
        #endregion

        #region Events
        /// <summary>
        /// Raised when a keep alive arrives from the server or an error is detected.
        /// </summary>
        /// <remarks>
        /// Once a session is created a timer will periodically read the server state and current time.
        /// If this read operation succeeds this event will be raised each time the keep alive period elapses.
        /// If an error is detected (KeepAliveStopped == true) then this event will be raised as well.
        /// </remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1009:DeclareEventHandlersCorrectly")]
        public event KeepAliveEventHandler KeepAlive
        {
            add
            {
                lock (m_eventLock)
                {
                    m_KeepAlive += value;
                }
            }

            remove
            {
                lock (m_eventLock)
                {
                    m_KeepAlive -= value;
                }
            }
        }

        /// <summary>
        /// Raised when a notification message arrives in a publish response.
        /// </summary>
        /// <remarks>
        /// All publish requests are managed by the Session object. When a response arrives it is
        /// validated and passed to the appropriate Subscription object and this event is raised.
        /// </remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1009:DeclareEventHandlersCorrectly")]
        public event NotificationEventHandler Notification
        {
            add
            {
                lock (m_eventLock)
                {
                    m_Publish += value;
                }
            }

            remove
            {
                lock (m_eventLock)
                {
                    m_Publish -= value;
                }
            }
        }

        /// <summary>
        /// Raised when an exception occurs while processing a publish response.
        /// </summary>
        /// <remarks>
        /// Exceptions in a publish response are not necessarily fatal and the Session will 
        /// attempt to recover by issuing Republish requests if missing messages are detected.
        /// That said, timeout errors may be a symptom of a OperationTimeout that is too short
        /// when compared to the shortest PublishingInterval/KeepAliveCount amount the current
        /// Subscriptions. The OperationTimeout should be twice the minimum value for
        /// PublishingInterval*KeepAliveCount.
        /// </remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1009:DeclareEventHandlersCorrectly")]
        public event PublishErrorEventHandler PublishError
        {
            add
            {
                lock (m_eventLock)
                {
                    m_PublishError += value;
                }
            }

            remove
            {
                lock (m_eventLock)
                {
                    m_PublishError -= value;
                }
            }
        }

        /// <summary>
        /// Raised when a subscription is added or removed
        /// </summary>
        public event EventHandler SubscriptionsChanged
        {
            add
            {
                m_SubscriptionsChanged += value;
            }

            remove
            {
                m_SubscriptionsChanged -= value;
            }
        }

        /// <summary>
        /// Raised to indicate the session is closing.
        /// </summary>
        public event EventHandler SessionClosing
        {
            add
            {
                m_SessionClosing += value;
            }

            remove
            {
                m_SessionClosing -= value;
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets the endpoint used to connect to the server.
        /// </summary>
        public ConfiguredEndpoint ConfiguredEndpoint => m_endpoint;

        /// <summary>
        /// Gets the name assigned to the session.
        /// </summary>
        public string SessionName => m_sessionName;

        /// <summary>
        /// Gets the period for wich the server will maintain the session if there is no communication from the client.
        /// </summary>
        public double SessionTimeout => m_sessionTimeout;

        /// <summary>
        /// Gets the local handle assigned to the session
        /// </summary>
        public object Handle
        {
            get { return m_handle; }
            set { m_handle = value; }
        }

        /// <summary>
        /// Gets the user identity currently used for the session.
        /// </summary>
        public IUserIdentity Identity => m_identity;

        /// <summary>
        /// Gets a list of user identities that can be used to connect to the server.
        /// </summary>
        public IEnumerable<IUserIdentity> IdentityHistory => m_identityHistory;

        /// <summary>
        /// Gets the table of namespace uris known to the server.
        /// </summary>
        public NamespaceTable NamespaceUris => m_namespaceUris;

        /// <summary>
        /// Gest the table of remote server uris known to the server.
        /// </summary>
        public StringTable ServerUris => m_serverUris;

        /// <summary>
        /// Gets the system context for use with the session.
        /// </summary>
        public ISystemContext SystemContext => m_systemContext;

        /// <summary>
        /// Gets the factory used to create encodeable objects that the server understands.
        /// </summary>
        public EncodeableFactory Factory => m_factory;

        /// <summary>
        /// Gets the cache of the server's type tree.
        /// </summary>
        public ITypeTable TypeTree => m_nodeCache.TypeTree;

        /// <summary>
        /// Gets the cache of nodes fetched from the server.
        /// </summary>
        public NodeCache NodeCache => m_nodeCache;

        /// <summary>
        /// Gets the context to use for filter operations.
        /// </summary>
        public FilterContext FilterContext => new FilterContext(m_namespaceUris, m_nodeCache.TypeTree, m_preferredLocales);

        /// <summary>
        /// Gets the locales that the server should use when returning localized text.
        /// </summary>
        public StringCollection PreferredLocales => m_preferredLocales;

        /// <summary>
        /// Gets the data type system dictionaries in use.
        /// </summary>
        public Dictionary<NodeId, DataDictionary> DataTypeSystem => m_dictionaries;

        /// <summary>
        /// Gets the subscriptions owned by the session.
        /// </summary>
        public IEnumerable<Subscription> Subscriptions
        {
            get
            {
                lock (SyncRoot)
                {
                    return new ReadOnlyList<Subscription>(m_subscriptions);
                }
            }
        }

        /// <summary>
        /// Gets the number of subscriptions owned by the session.
        /// </summary>
        public int SubscriptionCount
        {
            get
            {
                lock (SyncRoot)
                {
                    return m_subscriptions.Count;
                }
            }
        }

        /// <summary>
        /// Gets or Sets the default subscription for the session.
        /// </summary>
        public Subscription DefaultSubscription
        {
            get { return m_defaultSubscription; }
            set { m_defaultSubscription = value; }
        }

        /// <summary>
        /// Gets or Sets how frequently the server is pinged to see if communication is still working.
        /// </summary>
        /// <remarks>
        /// This interval controls how much time elaspes before a communication error is detected.
        /// If everything is ok the KeepAlive event will be raised each time this period elapses.
        /// </remarks>
        public int KeepAliveInterval
        {
            get
            {
                return m_keepAliveInterval;
            }

            set
            {
                m_keepAliveInterval = value;
                StartKeepAliveTimer();
            }
        }

        /// <summary>
        /// Returns true if the session is not receiving keep alives.
        /// </summary>
        /// <remarks>
        /// Set to true if the server does not respond for 2 times the KeepAliveInterval.
        /// Set to false is communication recovers.
        /// </remarks>
        public bool KeepAliveStopped
        {
            get
            {
                lock (m_eventLock)
                {
                    long delta = DateTime.UtcNow.Ticks - m_lastKeepAliveTime.Ticks;

                    // add a 1000ms guard band to allow for network lag.
                    return (m_keepAliveInterval * 2) * TimeSpan.TicksPerMillisecond <= delta;
                }
            }
        }

        /// <summary>
        /// Gets the time of the last keep alive.
        /// </summary>
        public DateTime LastKeepAliveTime => m_lastKeepAliveTime;

        /// <summary>
        /// Gets the number of outstanding publish or keep alive requests.
        /// </summary>
        public int OutstandingRequestCount
        {
            get
            {
                lock (m_outstandingRequests)
                {
                    return m_outstandingRequests.Count;
                }
            }
        }

        /// <summary>
        /// Gets the number of outstanding publish or keep alive requests which appear to be missing.
        /// </summary>
        public int DefunctRequestCount
        {
            get
            {
                lock (m_outstandingRequests)
                {
                    int count = 0;

                    for (LinkedListNode<AsyncRequestState> ii = m_outstandingRequests.First; ii != null; ii = ii.Next)
                    {
                        if (ii.Value.Defunct)
                        {
                            count++;
                        }
                    }

                    return count;
                }
            }
        }

        /// <summary>
        /// Gets the number of good outstanding publish requests.
        /// </summary>
        public int GoodPublishRequestCount
        {
            get
            {
                lock (m_outstandingRequests)
                {
                    int count = 0;

                    for (LinkedListNode<AsyncRequestState> ii = m_outstandingRequests.First; ii != null; ii = ii.Next)
                    {
                        if (!ii.Value.Defunct && ii.Value.RequestTypeId == DataTypes.PublishRequest)
                        {
                            count++;
                        }
                    }

                    return count;
                }
            }
        }
        #endregion

        #region Public Static Methods
        /// <summary>
        /// Creates a new communication session with a server by invoking the CreateSession service
        /// </summary>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="endpoint">The endpoint for the server.</param>
        /// <param name="updateBeforeConnect">If set to <c>true</c> the discovery endpoint is used to update the endpoint description before connecting.</param>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The timeout period for the session.</param>
        /// <param name="identity">The identity.</param>
        /// <param name="preferredLocales">The user identity to associate with the session.</param>
        /// <returns>The new session object</returns>
        public static Task<Session> Create(
            ApplicationConfiguration configuration,
            ConfiguredEndpoint endpoint,
            bool updateBeforeConnect,
            string sessionName,
            uint sessionTimeout,
            IUserIdentity identity,
            IList<string> preferredLocales)
        {
            return Create(configuration, endpoint, updateBeforeConnect, false, sessionName, sessionTimeout, identity, preferredLocales);
        }

        /// <summary>
        /// Creates a new communication session with a server by invoking the CreateSession service
        /// </summary>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="endpoint">The endpoint for the server.</param>
        /// <param name="updateBeforeConnect">If set to <c>true</c> the discovery endpoint is used to update the endpoint description before connecting.</param>
        /// <param name="checkDomain">If set to <c>true</c> then the domain in the certificate must match the endpoint used.</param>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The timeout period for the session.</param>
        /// <param name="identity">The user identity to associate with the session.</param>
        /// <param name="preferredLocales">The preferred locales.</param>
        /// <returns>The new session object.</returns>
        public static Task<Session> Create(
            ApplicationConfiguration configuration,
            ConfiguredEndpoint endpoint,
            bool updateBeforeConnect,
            bool checkDomain,
            string sessionName,
            uint sessionTimeout,
            IUserIdentity identity,
            IList<string> preferredLocales)
        {
            return Create(configuration, null, endpoint, updateBeforeConnect, checkDomain, sessionName, sessionTimeout, identity, preferredLocales);
        }

        /// <summary>
        /// Creates a new communication session with a server using a reverse connection.
        /// </summary>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="connection">The client endpoint for the reverse connect.</param>
        /// <param name="endpoint">The endpoint for the server.</param>
        /// <param name="updateBeforeConnect">If set to <c>true</c> the discovery endpoint is used to update the endpoint description before connecting.</param>
        /// <param name="checkDomain">If set to <c>true</c> then the domain in the certificate must match the endpoint used.</param>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The timeout period for the session.</param>
        /// <param name="identity">The user identity to associate with the session.</param>
        /// <param name="preferredLocales">The preferred locales.</param>
        /// <returns>The new session object.</returns>
        public static async Task<Session> Create(
            ApplicationConfiguration configuration,
            ITransportWaitingConnection connection,
            ConfiguredEndpoint endpoint,
            bool updateBeforeConnect,
            bool checkDomain,
            string sessionName,
            uint sessionTimeout,
            IUserIdentity identity,
            IList<string> preferredLocales)
        {
            endpoint.UpdateBeforeConnect = updateBeforeConnect;

            EndpointDescription endpointDescription = endpoint.Description;

            // create the endpoint configuration (use the application configuration to provide default values).
            EndpointConfiguration endpointConfiguration = endpoint.Configuration;

            if (endpointConfiguration == null)
            {
                endpoint.Configuration = endpointConfiguration = EndpointConfiguration.Create(configuration);
            }

            // create message context.
            ServiceMessageContext messageContext = configuration.CreateMessageContext(true);

            // update endpoint description using the discovery endpoint.
            if (endpoint.UpdateBeforeConnect && connection == null)
            {
                endpoint.UpdateFromServer();
                endpointDescription = endpoint.Description;
                endpointConfiguration = endpoint.Configuration;
            }

            // checks the domains in the certificate.
            if (checkDomain &&
                endpoint.Description.ServerCertificate != null &&
                endpoint.Description.ServerCertificate.Length > 0)
            {
                configuration.CertificateValidator?.ValidateDomains(
                    new X509Certificate2(endpoint.Description.ServerCertificate),
                    endpoint);
                checkDomain = false;
            }

            X509Certificate2 clientCertificate = null;
            X509Certificate2Collection clientCertificateChain = null;
            if (endpointDescription.SecurityPolicyUri != SecurityPolicies.None)
            {
                clientCertificate = await LoadCertificate(configuration);
                clientCertificateChain = await LoadCertificateChain(configuration, clientCertificate);
            }

            // initialize the channel which will be created with the server.
            ITransportChannel channel;
            if (connection != null)
            {
                channel = SessionChannel.CreateUaBinaryChannel(
                    configuration,
                    connection,
                    endpointDescription,
                    endpointConfiguration,
                    clientCertificate,
                    clientCertificateChain,
                    messageContext);
            }
            else
            {
                channel = SessionChannel.Create(
                     configuration,
                     endpointDescription,
                     endpointConfiguration,
                     clientCertificate,
                     clientCertificateChain,
                     messageContext);
            }

            // create the session object.
            Session session = new Session(channel, configuration, endpoint, null);

            // create the session.
            try
            {
                session.Open(sessionName, sessionTimeout, identity, preferredLocales, checkDomain);
            }
            catch (Exception)
            {
                session.Dispose();
                throw;
            }

            return session;
        }

        /// <summary>
        /// Creates a new communication session with a server using a reverse connect manager.
        /// </summary>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="reverseConnectManager">The reverse connect manager for the client connection.</param>
        /// <param name="endpoint">The endpoint for the server.</param>
        /// <param name="updateBeforeConnect">If set to <c>true</c> the discovery endpoint is used to update the endpoint description before connecting.</param>
        /// <param name="checkDomain">If set to <c>true</c> then the domain in the certificate must match the endpoint used.</param>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The timeout period for the session.</param>
        /// <param name="userIdentity">The user identity to associate with the session.</param>
        /// <param name="preferredLocales">The preferred locales.</param>
        /// <param name="ct">The cancellation token.</param>
        /// <returns>The new session object.</returns>
        public static async Task<Session> Create(
            ApplicationConfiguration configuration,
            ReverseConnectManager reverseConnectManager,
            ConfiguredEndpoint endpoint,
            bool updateBeforeConnect,
            bool checkDomain,
            string sessionName,
            uint sessionTimeout,
            IUserIdentity userIdentity,
            IList<string> preferredLocales,
            CancellationToken ct = default(CancellationToken)
            )
        {
            if (reverseConnectManager == null)
            {
                return await Create(configuration, endpoint, updateBeforeConnect,
                    checkDomain, sessionName, sessionTimeout, userIdentity, preferredLocales);
            }

            ITransportWaitingConnection connection = null;
            do
            {
                connection = await reverseConnectManager.WaitForConnection(
                    endpoint.EndpointUrl,
                    endpoint.ReverseConnect.ServerUri,
                    ct);

                if (updateBeforeConnect)
                {
                    await endpoint.UpdateFromServerAsync(
                        endpoint.EndpointUrl, connection,
                        endpoint.Description.SecurityMode,
                        endpoint.Description.SecurityPolicyUri);
                    updateBeforeConnect = false;
                    connection = null;
                }
            } while (connection == null);

            return await Create(
                configuration,
                connection,
                endpoint,
                false,
                checkDomain,
                sessionName,
                sessionTimeout,
                userIdentity,
                preferredLocales);
        }

        /// <summary>
        /// Recreates a session based on a specified template.
        /// </summary>
        /// <param name="template">The Session object to use as template</param>
        /// <returns>The new session object.</returns>
        public static Session Recreate(Session template)
        {
            ServiceMessageContext messageContext = template.m_configuration.CreateMessageContext();
            messageContext.Factory = template.Factory;

            // create the channel object used to connect to the server.
            ITransportChannel channel = SessionChannel.Create(
                template.m_configuration,
                template.m_endpoint.Description,
                template.m_endpoint.Configuration,
                template.m_instanceCertificate,
                template.m_configuration.SecurityConfiguration.SendCertificateChain ?
                    template.m_instanceCertificateChain : null,
                messageContext);

            // create the session object.
            Session session = new Session(channel, template, true);

            try
            {
                // open the session.
                session.Open(
                    template.m_sessionName,
                    (uint)template.m_sessionTimeout,
                    template.m_identity,
                    template.m_preferredLocales,
                    template.m_checkDomain);

                // create the subscriptions.
                foreach (Subscription subscription in session.Subscriptions)
                {
                    subscription.Create();
                }
            }
            catch (Exception e)
            {
                session.Dispose();
                throw ServiceResultException.Create(StatusCodes.BadCommunicationError, e, "Could not recreate session. {0}", template.m_sessionName);
            }

            return session;
        }

        /// <summary>
        /// Recreates a session based on a specified template.
        /// </summary>
        /// <param name="template">The Session object to use as template</param>
        /// <param name="connection">The waiting reverse connection.</param>
        /// <returns>The new session object.</returns>
        public static Session Recreate(Session template, ITransportWaitingConnection connection)
        {
            ServiceMessageContext messageContext = template.m_configuration.CreateMessageContext();
            messageContext.Factory = template.Factory;

            // create the channel object used to connect to the server.
            ITransportChannel channel = SessionChannel.Create(
                template.m_configuration,
                connection,
                template.m_endpoint.Description,
                template.m_endpoint.Configuration,
                template.m_instanceCertificate,
                template.m_configuration.SecurityConfiguration.SendCertificateChain ?
                    template.m_instanceCertificateChain : null,
                messageContext);

            // create the session object.
            Session session = new Session(channel, template, true);

            try
            {
                // open the session.
                session.Open(
                    template.m_sessionName,
                    (uint)template.m_sessionTimeout,
                    template.m_identity,
                    template.m_preferredLocales,
                    template.m_checkDomain);

                // create the subscriptions.
                foreach (Subscription subscription in session.Subscriptions)
                {
                    subscription.Create();
                }
            }
            catch (Exception e)
            {
                session.Dispose();
                throw ServiceResultException.Create(StatusCodes.BadCommunicationError, e, "Could not recreate session. {0}", template.m_sessionName);
            }

            return session;
        }
        #endregion

        #region Delegates and Events
        /// <summary>
        /// Used to handle renews of user identity tokens before reconnect.
        /// </summary>
        public delegate IUserIdentity RenewUserIdentityEventHandler(Session session, IUserIdentity identity);

        /// <summary>
        /// Raised before a reconnect operation completes.
        /// </summary>
        public event RenewUserIdentityEventHandler RenewUserIdentity
        {
            add { m_RenewUserIdentity += value; }
            remove { m_RenewUserIdentity -= value; }
        }

        private event RenewUserIdentityEventHandler m_RenewUserIdentity;
        #endregion

        #region Public Methods
        /// <summary>
        /// Reconnects to the server after a network failure.
        /// </summary>
        public void Reconnect()
        {
            Reconnect(null);
        }

        /// <summary>
        /// Reconnects to the server after a network failure using a waiting connection.
        /// </summary>
        public void Reconnect(ITransportWaitingConnection connection)
        {
            try
            {
                lock (SyncRoot)
                {
                    // check if already connecting.
                    if (m_reconnecting)
                    {
                        Utils.Trace("Session is already attempting to reconnect.");

                        throw ServiceResultException.Create(
                            StatusCodes.BadInvalidState,
                            "Session is already attempting to reconnect.");
                    }

                    Utils.Trace("Session RECONNECT starting.");
                    m_reconnecting = true;

                    // stop keep alives.
                    if (m_keepAliveTimer != null)
                    {
                        m_keepAliveTimer.Dispose();
                        m_keepAliveTimer = null;
                    }
                }

                // create the client signature.
                byte[] dataToSign = Utils.Append(m_serverCertificate != null ? m_serverCertificate.RawData : null, m_serverNonce);
                EndpointDescription endpoint = m_endpoint.Description;
                SignatureData clientSignature = SecurityPolicies.Sign(m_instanceCertificate, endpoint.SecurityPolicyUri, dataToSign);

                // check that the user identity is supported by the endpoint.
                UserTokenPolicy identityPolicy = endpoint.FindUserTokenPolicy(m_identity.TokenType, m_identity.IssuedTokenType);

                if (identityPolicy == null)
                {
                    Utils.Trace("Endpoint does not support the user identity type provided.");

                    throw ServiceResultException.Create(
                        StatusCodes.BadUserAccessDenied,
                        "Endpoint does not support the user identity type provided.");
                }

                // select the security policy for the user token.
                string securityPolicyUri = identityPolicy.SecurityPolicyUri;

                if (String.IsNullOrEmpty(securityPolicyUri))
                {
                    securityPolicyUri = endpoint.SecurityPolicyUri;
                }

                // need to refresh the identity (reprompt for password, refresh token).
                if (m_RenewUserIdentity != null)
                {
                    m_identity = m_RenewUserIdentity(this, m_identity);
                }

                // validate server nonce and security parameters for user identity.
                ValidateServerNonce(
                    m_identity,
                    m_serverNonce,
                    securityPolicyUri,
                    m_previousServerNonce,
                    m_endpoint.Description.SecurityMode);

                // sign data with user token.
                UserIdentityToken identityToken = m_identity.GetIdentityToken();
                identityToken.PolicyId = identityPolicy.PolicyId;
                SignatureData userTokenSignature = identityToken.Sign(dataToSign, securityPolicyUri);

                // encrypt token.
                identityToken.Encrypt(m_serverCertificate, m_serverNonce, securityPolicyUri);

                // send the software certificates assigned to the client.
                SignedSoftwareCertificateCollection clientSoftwareCertificates = GetSoftwareCertificates();

                Utils.Trace("Session REPLACING channel.");

                if (connection != null)
                {
                    // check if the channel supports reconnect.
                    if ((TransportChannel.SupportedFeatures & TransportChannelFeatures.Reconnect) != 0)
                    {
                        TransportChannel.Reconnect(connection);
                    }
                    else
                    {
                        // initialize the channel which will be created with the server.
                        ITransportChannel channel = SessionChannel.Create(
                            m_configuration,
                            connection,
                            m_endpoint.Description,
                            m_endpoint.Configuration,
                            m_instanceCertificate,
                            m_configuration.SecurityConfiguration.SendCertificateChain ? m_instanceCertificateChain : null,
                            MessageContext);

                        // disposes the existing channel.
                        TransportChannel = channel;
                    }
                }
                else
                {
                    // check if the channel supports reconnect.
                    if ((TransportChannel.SupportedFeatures & TransportChannelFeatures.Reconnect) != 0)
                    {
                        TransportChannel.Reconnect();
                    }
                    else
                    {
                        // initialize the channel which will be created with the server.
                        ITransportChannel channel = SessionChannel.Create(
                            m_configuration,
                            m_endpoint.Description,
                            m_endpoint.Configuration,
                            m_instanceCertificate,
                            m_configuration.SecurityConfiguration.SendCertificateChain ? m_instanceCertificateChain : null,
                            MessageContext);

                        // disposes the existing channel.
                        TransportChannel = channel;
                    }
                }

                // reactivate session.
                byte[] serverNonce = null;
                StatusCodeCollection certificateResults = null;
                DiagnosticInfoCollection certificateDiagnosticInfos = null;

                Utils.Trace("Session RE-ACTIVATING session.");

                IAsyncResult result = BeginActivateSession(
                    null,
                    clientSignature,
                    null,
                    m_preferredLocales,
                    new ExtensionObject(identityToken),
                    userTokenSignature,
                    null,
                    null);

                if (!result.AsyncWaitHandle.WaitOne(5000))
                {
                    Utils.Trace("WARNING: ACTIVATE SESSION timed out. {1}/{0}", OutstandingRequestCount, GoodPublishRequestCount);
                }

                EndActivateSession(
                    result,
                    out serverNonce,
                    out certificateResults,
                    out certificateDiagnosticInfos);

                int publishCount = 0;

                lock (SyncRoot)
                {
                    Utils.Trace("Session RECONNECT completed successfully.");
                    m_previousServerNonce = m_serverNonce;
                    m_serverNonce = serverNonce;
                    m_reconnecting = false;
                    publishCount = m_subscriptions.Count;
                }

                // refill pipeline.
                for (int ii = 0; ii < publishCount; ii++)
                {
                    BeginPublish(OperationTimeout);
                }

                StartKeepAliveTimer();
            }
            finally
            {
                m_reconnecting = false;
            }
        }


        /// <summary>
        /// Saves all the subscriptions of the session.
        /// </summary>
        /// <param name="filePath">The file path.</param>
        public void Save(string filePath)
        {
            Save(filePath, Subscriptions);
        }

        /// <summary>
        /// Saves a set of subscriptions.
        /// </summary>
        public void Save(string filePath, IEnumerable<Subscription> subscriptions)
        {
            XmlWriterSettings settings = new XmlWriterSettings();

            settings.Indent = true;
            settings.OmitXmlDeclaration = false;
            settings.Encoding = Encoding.UTF8;

            FileStream stream = new FileStream(filePath, FileMode.Create);
            XmlWriter writer = XmlWriter.Create(stream, settings);

            SubscriptionCollection subscriptionList = new SubscriptionCollection(subscriptions);

            try
            {
                DataContractSerializer serializer = new DataContractSerializer(typeof(SubscriptionCollection));
                serializer.WriteObject(writer, subscriptionList);
            }
            finally
            {
                writer.Flush();
                writer.Dispose();
                stream.Dispose();
            }
        }


        /// <summary>
        /// Load the list of subscriptions saved in a file.
        /// </summary>
        /// <param name="filePath">The file path.</param>
        /// <returns>The list of loaded subscriptions</returns>
        public IEnumerable<Subscription> Load(string filePath)
        {
            XmlReaderSettings settings = new XmlReaderSettings();

            settings.ConformanceLevel = ConformanceLevel.Document;
            settings.CloseInput = true;

            XmlReader reader = XmlReader.Create(filePath, settings);

            try
            {
                DataContractSerializer serializer = new DataContractSerializer(typeof(SubscriptionCollection));

                SubscriptionCollection subscriptions = (SubscriptionCollection)serializer.ReadObject(reader);

                foreach (Subscription subscription in subscriptions)
                {
                    AddSubscription(subscription);
                }

                return subscriptions;
            }
            finally
            {
                reader.Dispose();
            }
        }

        /// <summary>
        /// Updates the local copy of the server's namespace uri and server uri tables.
        /// </summary>
        public void FetchNamespaceTables()
        {
            ReadValueIdCollection nodesToRead = new ReadValueIdCollection();

            // request namespace array.
            ReadValueId valueId = new ReadValueId();

            valueId.NodeId = Variables.Server_NamespaceArray;
            valueId.AttributeId = Attributes.Value;

            nodesToRead.Add(valueId);

            // request server array.
            valueId = new ReadValueId();

            valueId.NodeId = Variables.Server_ServerArray;
            valueId.AttributeId = Attributes.Value;

            nodesToRead.Add(valueId);

            // read from server.
            DataValueCollection values = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = this.Read(
                null,
                0,
                TimestampsToReturn.Both,
                nodesToRead,
                out values,
                out diagnosticInfos);

            ValidateResponse(values, nodesToRead);
            ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);

            // validate namespace array.
            ServiceResult result = ValidateDataValue(values[0], typeof(string[]), 0, diagnosticInfos, responseHeader);

            if (ServiceResult.IsBad(result))
            {
                Utils.Trace("FetchNamespaceTables: Cannot read NamespaceArray node: {0} " + result.StatusCode);
            }
            else
            {
                m_namespaceUris.Update((string[])values[0].Value);
            }

            // validate server array.
            result = ValidateDataValue(values[1], typeof(string[]), 1, diagnosticInfos, responseHeader);

            if (ServiceResult.IsBad(result))
            {
                Utils.Trace("FetchNamespaceTables: Cannot read ServerArray node: {0} " + result.StatusCode);
            }
            else
            {
                m_serverUris.Update((string[])values[1].Value);
            }
        }

        /// <summary>
        /// Updates the cache with the type and its subtypes.
        /// </summary>
        /// <remarks>
        /// This method can be used to ensure the TypeTree is populated.
        /// </remarks>
        public void FetchTypeTree(ExpandedNodeId typeId)
        {
            Node node = NodeCache.Find(typeId) as Node;

            if (node != null)
            {
                foreach (IReference reference in node.Find(ReferenceTypeIds.HasSubtype, false))
                {
                    FetchTypeTree(reference.TargetId);
                }
            }
        }

        /// <summary>
        /// Returns the available encodings for a node
        /// </summary>
        /// <param name="variableId">The variable node.</param>
        /// <returns></returns>
        public ReferenceDescriptionCollection ReadAvailableEncodings(NodeId variableId)
        {
            VariableNode variable = NodeCache.Find(variableId) as VariableNode;

            if (variable == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, "NodeId does not refer to a valid variable node.");
            }

            // no encodings available if there was a problem reading the data type for the node.
            if (NodeId.IsNull(variable.DataType))
            {
                return new ReferenceDescriptionCollection();
            }

            // no encodings for non-structures.
            if (!TypeTree.IsTypeOf(variable.DataType, DataTypes.Structure))
            {
                return new ReferenceDescriptionCollection();
            }

            // look for cached values.
            IList<INode> encodings = NodeCache.Find(variableId, ReferenceTypeIds.HasEncoding, false, true);

            if (encodings.Count > 0)
            {
                ReferenceDescriptionCollection references = new ReferenceDescriptionCollection();

                foreach (INode encoding in encodings)
                {
                    ReferenceDescription reference = new ReferenceDescription();

                    reference.ReferenceTypeId = ReferenceTypeIds.HasEncoding;
                    reference.IsForward = true;
                    reference.NodeId = encoding.NodeId;
                    reference.NodeClass = encoding.NodeClass;
                    reference.BrowseName = encoding.BrowseName;
                    reference.DisplayName = encoding.DisplayName;
                    reference.TypeDefinition = encoding.TypeDefinitionId;

                    references.Add(reference);
                }

                return references;
            }

            Browser browser = new Browser(this);

            browser.BrowseDirection = BrowseDirection.Forward;
            browser.ReferenceTypeId = ReferenceTypeIds.HasEncoding;
            browser.IncludeSubtypes = false;
            browser.NodeClassMask = 0;

            return browser.Browse(variable.DataType);
        }


        /// <summary>
        /// Returns the data description for the encoding.
        /// </summary>
        /// <param name="encodingId">The encoding Id.</param>
        /// <returns></returns>
        public ReferenceDescription FindDataDescription(NodeId encodingId)
        {
            Browser browser = new Browser(this);

            browser.BrowseDirection = BrowseDirection.Forward;
            browser.ReferenceTypeId = ReferenceTypeIds.HasDescription;
            browser.IncludeSubtypes = false;
            browser.NodeClassMask = 0;

            ReferenceDescriptionCollection references = browser.Browse(encodingId);

            if (references.Count == 0)
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, "Encoding does not refer to a valid data description.");
            }

            return references[0];
        }


        /// <summary>
        ///  Returns the data dictionary that contains the description.
        /// </summary>
        /// <param name="descriptionId">The description id.</param>
        /// <returns></returns>
        public async Task<DataDictionary> FindDataDictionary(NodeId descriptionId)
        {
            // check if the dictionary has already been loaded.
            foreach (DataDictionary dictionary in m_dictionaries.Values)
            {
                if (dictionary.Contains(descriptionId))
                {
                    return dictionary;
                }
            }

            // find the dictionary for the description.
            Browser browser = new Browser(this);

            browser.BrowseDirection = BrowseDirection.Inverse;
            browser.ReferenceTypeId = ReferenceTypeIds.HasComponent;
            browser.IncludeSubtypes = false;
            browser.NodeClassMask = 0;

            ReferenceDescriptionCollection references = browser.Browse(descriptionId);

            if (references.Count == 0)
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, "Description does not refer to a valid data dictionary.");
            }

            // load the dictionary.
            NodeId dictionaryId = ExpandedNodeId.ToNodeId(references[0].NodeId, m_namespaceUris);

            DataDictionary dictionaryToLoad = new DataDictionary(this);

            await dictionaryToLoad.Load(references[0]);

            m_dictionaries[dictionaryId] = dictionaryToLoad;

            return dictionaryToLoad;
        }

        /// <summary>
        ///  Returns the data dictionary that contains the description.
        /// </summary>
        /// <param name="dictionaryNode">The dictionary id.</param>
        /// <param name="forceReload"></param>
        /// <returns>The dictionary.</returns>
        public async Task<DataDictionary> LoadDataDictionary(ReferenceDescription dictionaryNode, bool forceReload = false)
        {
            // check if the dictionary has already been loaded.
            DataDictionary dictionary;
            NodeId dictionaryId = ExpandedNodeId.ToNodeId(dictionaryNode.NodeId, m_namespaceUris);
            if (!forceReload &&
                m_dictionaries.TryGetValue(dictionaryId, out dictionary))
            {
                return dictionary;
            }

            // load the dictionary.
            DataDictionary dictionaryToLoad = new DataDictionary(this);
            await dictionaryToLoad.Load(dictionaryId, dictionaryNode.ToString());
            m_dictionaries[dictionaryId] = dictionaryToLoad;
            return dictionaryToLoad;
        }

        /// <summary>
        /// Loads all dictionaries of the OPC binary or Xml schema type system.
        /// </summary>
        /// <param name="dataTypeSystem">The type system.</param>
        /// <returns></returns>
        public async Task<Dictionary<NodeId, DataDictionary>> LoadDataTypeSystem(NodeId dataTypeSystem = null)
        {
            if (dataTypeSystem == null)
            {
                dataTypeSystem = ObjectIds.OPCBinarySchema_TypeSystem;
            }
            else
            if (!Utils.Equals(dataTypeSystem, ObjectIds.OPCBinarySchema_TypeSystem) &&
                !Utils.Equals(dataTypeSystem, ObjectIds.XmlSchema_TypeSystem))
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, $"{nameof(dataTypeSystem)} does not refer to a valid data dictionary.");
            }

            // find the dictionary for the description.
            Browser browser = new Browser(this);

            browser.BrowseDirection = BrowseDirection.Forward;
            browser.ReferenceTypeId = ReferenceTypeIds.HasComponent;
            browser.IncludeSubtypes = false;
            browser.NodeClassMask = 0;

            ReferenceDescriptionCollection references = browser.Browse(dataTypeSystem);

            if (references.Count == 0)
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, "Type system does not contain a valid data dictionary.");
            }

            // read all type dictionaries in the type system
            foreach (var r in references)
            {
                DataDictionary dictionaryToLoad = null;
                NodeId dictionaryId = ExpandedNodeId.ToNodeId(r.NodeId, m_namespaceUris);
                if (dictionaryId.NamespaceIndex != 0 &&
                    !m_dictionaries.TryGetValue(dictionaryId, out dictionaryToLoad))
                {
                    try
                    {
                        dictionaryToLoad = new DataDictionary(this);
                        await dictionaryToLoad.Load(r);
                        m_dictionaries[dictionaryId] = dictionaryToLoad;
                    }
                    catch (Exception ex)
                    {
                        Utils.Trace("Dictionary load error for Dictionary {0} : {1}", r.NodeId, ex.Message);
                    }
                }
            }

            return m_dictionaries;
        }

        /// <summary>
        /// Reads the values for the node attributes and returns a node object.
        /// </summary>
        /// <param name="nodeId">The nodeId.</param>
        /// <returns></returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
        public Node ReadNode(NodeId nodeId)
        {
            // build list of attributes.
            var attributes = new SortedDictionary<uint, DataValue> {
                { Attributes.NodeId, null },
                { Attributes.NodeClass, null },
                { Attributes.BrowseName, null },
                { Attributes.DisplayName, null },
                { Attributes.Description, null },
                { Attributes.WriteMask, null },
                { Attributes.UserWriteMask, null },
                { Attributes.DataType, null },
                { Attributes.ValueRank, null },
                { Attributes.ArrayDimensions, null },
                { Attributes.AccessLevel, null },
                { Attributes.UserAccessLevel, null },
                { Attributes.Historizing, null },
                { Attributes.MinimumSamplingInterval, null },
                { Attributes.EventNotifier, null },
                { Attributes.Executable, null },
                { Attributes.UserExecutable, null },
                { Attributes.IsAbstract, null },
                { Attributes.InverseName, null },
                { Attributes.Symmetric, null },
                { Attributes.ContainsNoLoops, null },
                { Attributes.DataTypeDefinition, null },
                { Attributes.RolePermissions, null },
                { Attributes.UserRolePermissions, null },
                { Attributes.AccessRestrictions, null },
                { Attributes.AccessLevelEx, null }
            };

            // build list of values to read.
            ReadValueIdCollection itemsToRead = new ReadValueIdCollection();

            foreach (uint attributeId in attributes.Keys)
            {
                ReadValueId itemToRead = new ReadValueId();

                itemToRead.NodeId = nodeId;
                itemToRead.AttributeId = attributeId;

                itemsToRead.Add(itemToRead);
            }

            // read from server.
            DataValueCollection values = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = Read(
                null,
                0,
                TimestampsToReturn.Neither,
                itemsToRead,
                out values,
                out diagnosticInfos);

            ClientBase.ValidateResponse(values, itemsToRead);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, itemsToRead);

            // process results.
            int? nodeClass = null;

            for (int ii = 0; ii < itemsToRead.Count; ii++)
            {
                uint attributeId = itemsToRead[ii].AttributeId;

                // the node probably does not exist if the node class is not found.
                if (attributeId == Attributes.NodeClass)
                {
                    if (!DataValue.IsGood(values[ii]))
                    {
                        throw ServiceResultException.Create(values[ii].StatusCode, ii, diagnosticInfos, responseHeader.StringTable);
                    }

                    // check for valid node class.
                    nodeClass = values[ii].Value as int?;

                    if (nodeClass == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Node does not have a valid value for NodeClass: {0}.", values[ii].Value);
                    }
                }
                else
                {
                    if (!DataValue.IsGood(values[ii]))
                    {
                        // check for unsupported attributes.
                        if (values[ii].StatusCode == StatusCodes.BadAttributeIdInvalid)
                        {
                            continue;
                        }

                        // ignore errors on optional attributes 
                        if (StatusCode.IsBad(values[ii].StatusCode))
                        {
                            if (attributeId == Attributes.AccessRestrictions ||
                                attributeId == Attributes.Description ||
                                attributeId == Attributes.RolePermissions ||
                                attributeId == Attributes.UserRolePermissions ||
                                attributeId == Attributes.UserWriteMask ||
                                attributeId == Attributes.WriteMask)
                            {
                                continue;
                            }
                        }

                        // all supported attributes must be readable.
                        if (attributeId != Attributes.Value)
                        {
                            throw ServiceResultException.Create(values[ii].StatusCode, ii, diagnosticInfos, responseHeader.StringTable);
                        }
                    }
                }

                attributes[attributeId] = values[ii];
            }

            Node node = null;
            DataValue value = null;

            switch ((NodeClass)nodeClass.Value)
            {
                default:
                {
                    throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Node does not have a valid value for NodeClass: {0}.", nodeClass.Value);
                }

                case NodeClass.Object:
                {
                    ObjectNode objectNode = new ObjectNode();

                    value = attributes[Attributes.EventNotifier];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Object does not support the EventNotifier attribute.");
                    }

                    objectNode.EventNotifier = (byte)attributes[Attributes.EventNotifier].GetValue(typeof(byte));
                    node = objectNode;
                    break;
                }

                case NodeClass.ObjectType:
                {
                    ObjectTypeNode objectTypeNode = new ObjectTypeNode();

                    value = attributes[Attributes.IsAbstract];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "ObjectType does not support the IsAbstract attribute.");
                    }

                    objectTypeNode.IsAbstract = (bool)attributes[Attributes.IsAbstract].GetValue(typeof(bool));
                    node = objectTypeNode;
                    break;
                }

                case NodeClass.Variable:
                {
                    VariableNode variableNode = new VariableNode();

                    // DataType Attribute
                    value = attributes[Attributes.DataType];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Variable does not support the DataType attribute.");
                    }

                    variableNode.DataType = (NodeId)attributes[Attributes.DataType].GetValue(typeof(NodeId));

                    // ValueRank Attribute
                    value = attributes[Attributes.ValueRank];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Variable does not support the ValueRank attribute.");
                    }

                    variableNode.ValueRank = (int)attributes[Attributes.ValueRank].GetValue(typeof(int));

                    // ArrayDimensions Attribute
                    value = attributes[Attributes.ArrayDimensions];

                    if (value != null)
                    {
                        if (value.Value == null)
                        {
                            variableNode.ArrayDimensions = new uint[0];
                        }
                        else
                        {
                            variableNode.ArrayDimensions = (uint[])value.GetValue(typeof(uint[]));
                        }
                    }

                    // AccessLevel Attribute
                    value = attributes[Attributes.AccessLevel];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Variable does not support the AccessLevel attribute.");
                    }

                    variableNode.AccessLevel = (byte)attributes[Attributes.AccessLevel].GetValue(typeof(byte));

                    // UserAccessLevel Attribute
                    value = attributes[Attributes.UserAccessLevel];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Variable does not support the UserAccessLevel attribute.");
                    }

                    variableNode.UserAccessLevel = (byte)attributes[Attributes.UserAccessLevel].GetValue(typeof(byte));

                    // Historizing Attribute
                    value = attributes[Attributes.Historizing];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Variable does not support the Historizing attribute.");
                    }

                    variableNode.Historizing = (bool)attributes[Attributes.Historizing].GetValue(typeof(bool));

                    // MinimumSamplingInterval Attribute
                    value = attributes[Attributes.MinimumSamplingInterval];

                    if (value != null)
                    {
                        variableNode.MinimumSamplingInterval = Convert.ToDouble(attributes[Attributes.MinimumSamplingInterval].Value);
                    }

                    // AccessLevelEx Attribute
                    value = attributes[Attributes.AccessLevelEx];

                    if (value != null)
                    {
                        variableNode.AccessLevelEx = (uint)attributes[Attributes.AccessLevelEx].GetValue(typeof(uint));
                    }

                    node = variableNode;
                    break;
                }

                case NodeClass.VariableType:
                {
                    VariableTypeNode variableTypeNode = new VariableTypeNode();

                    // IsAbstract Attribute
                    value = attributes[Attributes.IsAbstract];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "VariableType does not support the IsAbstract attribute.");
                    }

                    variableTypeNode.IsAbstract = (bool)attributes[Attributes.IsAbstract].GetValue(typeof(bool));

                    // DataType Attribute
                    value = attributes[Attributes.DataType];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "VariableType does not support the DataType attribute.");
                    }

                    variableTypeNode.DataType = (NodeId)attributes[Attributes.DataType].GetValue(typeof(NodeId));

                    // ValueRank Attribute
                    value = attributes[Attributes.ValueRank];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "VariableType does not support the ValueRank attribute.");
                    }

                    variableTypeNode.ValueRank = (int)attributes[Attributes.ValueRank].GetValue(typeof(int));

                    // ArrayDimensions Attribute
                    value = attributes[Attributes.ArrayDimensions];

                    if (value != null && value.Value != null)
                    {
                        variableTypeNode.ArrayDimensions = (uint[])attributes[Attributes.ArrayDimensions].GetValue(typeof(uint[]));
                    }

                    node = variableTypeNode;
                    break;
                }

                case NodeClass.Method:
                {
                    MethodNode methodNode = new MethodNode();

                    // Executable Attribute
                    value = attributes[Attributes.Executable];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Method does not support the Executable attribute.");
                    }

                    methodNode.Executable = (bool)attributes[Attributes.Executable].GetValue(typeof(bool));

                    // UserExecutable Attribute
                    value = attributes[Attributes.UserExecutable];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Method does not support the UserExecutable attribute.");
                    }

                    methodNode.UserExecutable = (bool)attributes[Attributes.UserExecutable].GetValue(typeof(bool));

                    node = methodNode;
                    break;
                }

                case NodeClass.DataType:
                {
                    DataTypeNode dataTypeNode = new DataTypeNode();

                    // IsAbstract Attribute
                    value = attributes[Attributes.IsAbstract];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "DataType does not support the IsAbstract attribute.");
                    }

                    dataTypeNode.IsAbstract = (bool)attributes[Attributes.IsAbstract].GetValue(typeof(bool));

                    // DataTypeDefinition Attribute
                    value = attributes[Attributes.DataTypeDefinition];

                    if (value != null)
                    {
                        dataTypeNode.DataTypeDefinition = value.Value as ExtensionObject;
                    }

                    node = dataTypeNode;
                    break;
                }

                case NodeClass.ReferenceType:
                {
                    ReferenceTypeNode referenceTypeNode = new ReferenceTypeNode();

                    // IsAbstract Attribute
                    value = attributes[Attributes.IsAbstract];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "ReferenceType does not support the IsAbstract attribute.");
                    }

                    referenceTypeNode.IsAbstract = (bool)attributes[Attributes.IsAbstract].GetValue(typeof(bool));

                    // Symmetric Attribute
                    value = attributes[Attributes.Symmetric];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "ReferenceType does not support the Symmetric attribute.");
                    }

                    referenceTypeNode.Symmetric = (bool)attributes[Attributes.IsAbstract].GetValue(typeof(bool));

                    // InverseName Attribute
                    value = attributes[Attributes.InverseName];

                    if (value != null && value.Value != null)
                    {
                        referenceTypeNode.InverseName = (LocalizedText)attributes[Attributes.InverseName].GetValue(typeof(LocalizedText));
                    }

                    node = referenceTypeNode;
                    break;
                }

                case NodeClass.View:
                {
                    ViewNode viewNode = new ViewNode();

                    // EventNotifier Attribute
                    value = attributes[Attributes.EventNotifier];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "View does not support the EventNotifier attribute.");
                    }

                    viewNode.EventNotifier = (byte)attributes[Attributes.EventNotifier].GetValue(typeof(byte));

                    // ContainsNoLoops Attribute
                    value = attributes[Attributes.ContainsNoLoops];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "View does not support the ContainsNoLoops attribute.");
                    }

                    viewNode.ContainsNoLoops = (bool)attributes[Attributes.ContainsNoLoops].GetValue(typeof(bool));

                    node = viewNode;
                    break;
                }
            }

            // NodeId Attribute
            value = attributes[Attributes.NodeId];

            if (value == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Node does not support the NodeId attribute.");
            }

            node.NodeId = (NodeId)attributes[Attributes.NodeId].GetValue(typeof(NodeId));
            node.NodeClass = (NodeClass)nodeClass.Value;

            // BrowseName Attribute
            value = attributes[Attributes.BrowseName];

            if (value == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Node does not support the BrowseName attribute.");
            }

            node.BrowseName = (QualifiedName)attributes[Attributes.BrowseName].GetValue(typeof(QualifiedName));

            // DisplayName Attribute
            value = attributes[Attributes.DisplayName];

            if (value == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Node does not support the DisplayName attribute.");
            }

            node.DisplayName = (LocalizedText)attributes[Attributes.DisplayName].GetValue(typeof(LocalizedText));

            // all optional attributes follow

            // Description Attribute
            if (attributes.TryGetValue(Attributes.Description, out value) &&
                value != null && value.Value != null)
            {
                node.Description = (LocalizedText)value.GetValue(typeof(LocalizedText));
            }

            // WriteMask Attribute
            if (attributes.TryGetValue(Attributes.WriteMask, out value) &&
                value != null)
            {
                node.WriteMask = (uint)value.GetValue(typeof(uint));
            }

            // UserWriteMask Attribute
            if (attributes.TryGetValue(Attributes.UserWriteMask, out value) &&
                value != null)
            {
                node.UserWriteMask = (uint)value.GetValue(typeof(uint));
            }

            // RolePermissions Attribute
            if (attributes.TryGetValue(Attributes.RolePermissions, out value) &&
                value != null)
            {
                ExtensionObject[] rolePermissions = value.Value as ExtensionObject[];

                if (rolePermissions != null)
                {
                    node.RolePermissions = new RolePermissionTypeCollection();

                    foreach (ExtensionObject rolePermission in rolePermissions)
                    {
                        node.RolePermissions.Add(rolePermission.Body as RolePermissionType);
                    }
                }
            }

            // UserRolePermissions Attribute
            if (attributes.TryGetValue(Attributes.UserRolePermissions, out value) &&
                value != null)
            {
                ExtensionObject[] userRolePermissions = value.Value as ExtensionObject[];

                if (userRolePermissions != null)
                {
                    node.UserRolePermissions = new RolePermissionTypeCollection();

                    foreach (ExtensionObject rolePermission in userRolePermissions)
                    {
                        node.UserRolePermissions.Add(rolePermission.Body as RolePermissionType);
                    }
                }
            }

            // AccessRestrictions Attribute
            if (attributes.TryGetValue(Attributes.AccessRestrictions, out value) &&
                value != null)
            {
                node.AccessRestrictions = (ushort)value.GetValue(typeof(ushort));
            }

            return node;
        }

        /// <summary>
        /// Reads the value for a node.
        /// </summary>
        /// <param name="nodeId">The node Id.</param>
        /// <returns></returns>
        public DataValue ReadValue(NodeId nodeId)
        {
            ReadValueId itemToRead = new ReadValueId();

            itemToRead.NodeId = nodeId;
            itemToRead.AttributeId = Attributes.Value;

            ReadValueIdCollection itemsToRead = new ReadValueIdCollection();
            itemsToRead.Add(itemToRead);

            // read from server.
            DataValueCollection values = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = Read(
                null,
                0,
                TimestampsToReturn.Both,
                itemsToRead,
                out values,
                out diagnosticInfos);

            ClientBase.ValidateResponse(values, itemsToRead);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, itemsToRead);

            if (StatusCode.IsBad(values[0].StatusCode))
            {
                ServiceResult result = ClientBase.GetResult(values[0].StatusCode, 0, diagnosticInfos, responseHeader);
                throw new ServiceResultException(result);
            }

            return values[0];
        }

        /// <summary>
        /// Reads the value for a node an checks that it is the specified type.
        /// </summary>
        /// <param name="nodeId">The node id.</param>
        /// <param name="expectedType">The expected type.</param>
        /// <returns></returns>
        public object ReadValue(NodeId nodeId, Type expectedType)
        {
            DataValue dataValue = ReadValue(nodeId);

            object value = dataValue.Value;

            if (expectedType != null)
            {
                ExtensionObject extension = value as ExtensionObject;

                if (extension != null)
                {
                    value = extension.Body;
                }

                if (!expectedType.IsInstanceOfType(value))
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadTypeMismatch,
                        "Server returned value unexpected type: {0}",
                        (value != null) ? value.GetType().Name : "(null)");
                }
            }

            return value;
        }


        /// <summary>
        /// Fetches all references for the specified node.
        /// </summary>
        /// <param name="nodeId">The node id.</param>
        /// <returns></returns>
        public ReferenceDescriptionCollection FetchReferences(NodeId nodeId)
        {
            // browse for all references.
            byte[] continuationPoint;
            ReferenceDescriptionCollection descriptions;

            Browse(
                null,
                null,
                nodeId,
                0,
                BrowseDirection.Both,
                null,
                true,
                0,
                out continuationPoint,
                out descriptions);

            // process any continuation point.
            while (continuationPoint != null)
            {
                byte[] revisedContinuationPoint;
                ReferenceDescriptionCollection additionalDescriptions;

                BrowseNext(
                    null,
                    false,
                    continuationPoint,
                    out revisedContinuationPoint,
                    out additionalDescriptions);

                continuationPoint = revisedContinuationPoint;

                descriptions.AddRange(additionalDescriptions);
            }

            return descriptions;
        }

        /// <summary>
        /// Establishes a session with the server.
        /// </summary>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="identity">The user identity.</param>
        public void Open(
            string sessionName,
            IUserIdentity identity)
        {
            Open(sessionName, 0, identity, null);
        }

        /// <summary>
        /// Establishes a session with the server.
        /// </summary>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The session timeout.</param>
        /// <param name="identity">The user identity.</param>
        /// <param name="preferredLocales">The list of preferred locales.</param>
        public void Open(
            string sessionName,
            uint sessionTimeout,
            IUserIdentity identity,
            IList<string> preferredLocales)
        {
            Open(sessionName, sessionTimeout, identity, preferredLocales, true);
        }

        /// <summary>
        /// Establishes a session with the server.
        /// </summary>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The session timeout.</param>
        /// <param name="identity">The user identity.</param>
        /// <param name="preferredLocales">The list of preferred locales.</param>
        /// <param name="checkDomain">If set to <c>true</c> then the domain in the certificate must match the endpoint used.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
        public void Open(
            string sessionName,
            uint sessionTimeout,
            IUserIdentity identity,
            IList<string> preferredLocales,
            bool checkDomain)
        {
            // check connection state.
            lock (SyncRoot)
            {
                if (Connected)
                {
                    throw new ServiceResultException(StatusCodes.BadInvalidState, "Already connected to server.");
                }
            }

            string securityPolicyUri = m_endpoint.Description.SecurityPolicyUri;

            // catch security policies which are not supported by core
            if (SecurityPolicies.GetDisplayName(securityPolicyUri) == null)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadSecurityChecksFailed,
                    "The chosen security policy is not supported by the client to connect to the server.");
            }

            // get the identity token.
            if (identity == null)
            {
                identity = new UserIdentity();
            }

            // get identity token.
            UserIdentityToken identityToken = identity.GetIdentityToken();

            // check that the user identity is supported by the endpoint.
            UserTokenPolicy identityPolicy = m_endpoint.Description.FindUserTokenPolicy(identityToken.PolicyId);

            if (identityPolicy == null)
            {
                // try looking up by TokenType if the policy id was not found.
                identityPolicy = m_endpoint.Description.FindUserTokenPolicy(identity.TokenType, identity.IssuedTokenType);

                if (identityPolicy == null)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadUserAccessDenied,
                        "Endpoint does not support the user identity type provided.");
                }

                identityToken.PolicyId = identityPolicy.PolicyId;
            }

            bool requireEncryption = securityPolicyUri != SecurityPolicies.None;
            if (!requireEncryption)
            {
                requireEncryption = identityPolicy.SecurityPolicyUri != SecurityPolicies.None;
            }

            // validate the server certificate /certificate chain.
            X509Certificate2 serverCertificate = null;
            byte[] certificateData = m_endpoint.Description.ServerCertificate;

            if (certificateData != null && certificateData.Length > 0)
            {
                X509Certificate2Collection serverCertificateChain = Utils.ParseCertificateChainBlob(certificateData);

                if (serverCertificateChain.Count > 0)
                {
                    serverCertificate = serverCertificateChain[0];
                }

                if (requireEncryption)
                {
                    if (checkDomain)
                    {
                        m_configuration.CertificateValidator.Validate(serverCertificateChain, m_endpoint);
                    }
                    else
                    {
                        m_configuration.CertificateValidator.Validate(serverCertificateChain);
                    }
                    // save for reconnect
                    m_checkDomain = checkDomain;
                }
            }

            // create a nonce.
            uint length = (uint)m_configuration.SecurityConfiguration.NonceLength;
            byte[] clientNonce = Utils.Nonce.CreateNonce(length);
            NodeId sessionId = null;
            NodeId sessionCookie = null;
            byte[] serverNonce = new byte[0];
            byte[] serverCertificateData = new byte[0];
            SignatureData serverSignature = null;
            EndpointDescriptionCollection serverEndpoints = null;
            SignedSoftwareCertificateCollection serverSoftwareCertificates = null;

            // send the application instance certificate for the client.
            byte[] clientCertificateData = m_instanceCertificate != null ? m_instanceCertificate.RawData : null;
            byte[] clientCertificateChainData = null;

            if (m_instanceCertificateChain != null && m_instanceCertificateChain.Count > 0 && m_configuration.SecurityConfiguration.SendCertificateChain)
            {
                List<byte> clientCertificateChain = new List<byte>();

                for (int i = 0; i < m_instanceCertificateChain.Count; i++)
                {
                    clientCertificateChain.AddRange(m_instanceCertificateChain[i].RawData);
                }

                clientCertificateChainData = clientCertificateChain.ToArray();
            }

            ApplicationDescription clientDescription = new ApplicationDescription();

            clientDescription.ApplicationUri = m_configuration.ApplicationUri;
            clientDescription.ApplicationName = m_configuration.ApplicationName;
            clientDescription.ApplicationType = ApplicationType.Client;
            clientDescription.ProductUri = m_configuration.ProductUri;

            if (sessionTimeout == 0)
            {
                sessionTimeout = (uint)m_configuration.ClientConfiguration.DefaultSessionTimeout;
            }

            bool successCreateSession = false;
            //if security none, first try to connect without certificate
            if (m_endpoint.Description.SecurityPolicyUri == SecurityPolicies.None)
            {
                //first try to connect with client certificate NULL
                try
                {
                    CreateSession(
                        null,
                        clientDescription,
                        m_endpoint.Description.Server.ApplicationUri,
                        m_endpoint.EndpointUrl.ToString(),
                        sessionName,
                        clientNonce,
                        null,
                        sessionTimeout,
                        (uint)MessageContext.MaxMessageSize,
                        out sessionId,
                        out sessionCookie,
                        out m_sessionTimeout,
                        out serverNonce,
                        out serverCertificateData,
                        out serverEndpoints,
                        out serverSoftwareCertificates,
                        out serverSignature,
                        out m_maxRequestMessageSize);

                    successCreateSession = true;
                }
                catch (Exception ex)
                {
                    Utils.Trace("Create session failed with client certificate NULL. " + ex.Message);
                    successCreateSession = false;
                }
            }

            if (!successCreateSession)
            {
                CreateSession(
                        null,
                        clientDescription,
                        m_endpoint.Description.Server.ApplicationUri,
                        m_endpoint.EndpointUrl.ToString(),
                        sessionName,
                        clientNonce,
                        clientCertificateChainData != null ? clientCertificateChainData : clientCertificateData,
                        sessionTimeout,
                        (uint)MessageContext.MaxMessageSize,
                        out sessionId,
                        out sessionCookie,
                        out m_sessionTimeout,
                        out serverNonce,
                        out serverCertificateData,
                        out serverEndpoints,
                        out serverSoftwareCertificates,
                        out serverSignature,
                        out m_maxRequestMessageSize);
            }
            // save session id.
            lock (SyncRoot)
            {
                base.SessionCreated(sessionId, sessionCookie);
            }

            Utils.Trace("Revised session timeout value: {0}. ", m_sessionTimeout);
            Utils.Trace("Max response message size value: {0}. Max request message size: {1} ", MessageContext.MaxMessageSize, m_maxRequestMessageSize);

            //we need to call CloseSession if CreateSession was successful but some other exception is thrown
            try
            {
                // verify that the server returned the same instance certificate.
                if (serverCertificateData != null &&
                    m_endpoint.Description.ServerCertificate != null &&
                    !Utils.IsEqual(serverCertificateData, m_endpoint.Description.ServerCertificate))
                {
                    try
                    {
                        // verify for certificate chain in endpoint.
                        X509Certificate2Collection serverCertificateChain = Utils.ParseCertificateChainBlob(m_endpoint.Description.ServerCertificate);

                        if (serverCertificateChain.Count > 0 && !Utils.IsEqual(serverCertificateData, serverCertificateChain[0].RawData))
                        {
                            throw ServiceResultException.Create(
                                        StatusCodes.BadCertificateInvalid,
                                        "Server did not return the certificate used to create the secure channel.");
                        }
                    }
                    catch (Exception)
                    {
                        throw ServiceResultException.Create(
                                StatusCodes.BadCertificateInvalid,
                                "Server did not return the certificate used to create the secure channel.");
                    }
                }

                if (serverSignature == null || serverSignature.Signature == null)
                {
                    Utils.Trace("Server signature is null or empty.");

                    //throw ServiceResultException.Create(
                    //    StatusCodes.BadSecurityChecksFailed,
                    //    "Server signature is null or empty.");
                }

                if (m_discoveryServerEndpoints != null && m_discoveryServerEndpoints.Count > 0)
                {
                    // Compare EndpointDescriptions returned at GetEndpoints with values returned at CreateSession
                    EndpointDescriptionCollection expectedServerEndpoints = null;

                    if (serverEndpoints != null &&
                        m_discoveryProfileUris != null && m_discoveryProfileUris.Count > 0)
                    {
                        // Select EndpointDescriptions with a transportProfileUri that matches the
                        // profileUris specified in the original GetEndpoints() request.
                        expectedServerEndpoints = new EndpointDescriptionCollection();

                        foreach (EndpointDescription serverEndpoint in serverEndpoints)
                        {
                            if (m_discoveryProfileUris.Contains(serverEndpoint.TransportProfileUri))
                            {
                                expectedServerEndpoints.Add(serverEndpoint);
                            }
                        }
                    }
                    else
                    {
                        expectedServerEndpoints = serverEndpoints;
                    }

                    if (expectedServerEndpoints == null ||
                        m_discoveryServerEndpoints.Count != expectedServerEndpoints.Count)
                    {
                        throw ServiceResultException.Create(
                            StatusCodes.BadSecurityChecksFailed,
                            "Server did not return a number of ServerEndpoints that matches the one from GetEndpoints.");
                    }

                    for (int ii = 0; ii < expectedServerEndpoints.Count; ii++)
                    {
                        EndpointDescription serverEndpoint = expectedServerEndpoints[ii];
                        EndpointDescription expectedServerEndpoint = m_discoveryServerEndpoints[ii];

                        if (serverEndpoint.SecurityMode != expectedServerEndpoint.SecurityMode ||
                            serverEndpoint.SecurityPolicyUri != expectedServerEndpoint.SecurityPolicyUri ||
                            serverEndpoint.TransportProfileUri != expectedServerEndpoint.TransportProfileUri ||
                            serverEndpoint.SecurityLevel != expectedServerEndpoint.SecurityLevel)
                        {
                            throw ServiceResultException.Create(
                                StatusCodes.BadSecurityChecksFailed,
                                "The list of ServerEndpoints returned at CreateSession does not match the list from GetEndpoints.");
                        }

                        if (serverEndpoint.UserIdentityTokens.Count != expectedServerEndpoint.UserIdentityTokens.Count)
                        {
                            throw ServiceResultException.Create(
                                StatusCodes.BadSecurityChecksFailed,
                                "The list of ServerEndpoints returned at CreateSession does not match the one from GetEndpoints.");
                        }

                        for (int jj = 0; jj < serverEndpoint.UserIdentityTokens.Count; jj++)
                        {
                            if (!serverEndpoint.UserIdentityTokens[jj].IsEqual(expectedServerEndpoint.UserIdentityTokens[jj]))
                            {
                                throw ServiceResultException.Create(
                                StatusCodes.BadSecurityChecksFailed,
                                "The list of ServerEndpoints returned at CreateSession does not match the one from GetEndpoints.");
                            }
                        }
                    }
                }

                // find the matching description (TBD - check domains against certificate).
                bool found = false;
                Uri expectedUrl = Utils.ParseUri(m_endpoint.Description.EndpointUrl);

                if (expectedUrl != null)
                {
                    for (int ii = 0; ii < serverEndpoints.Count; ii++)
                    {
                        EndpointDescription serverEndpoint = serverEndpoints[ii];
                        Uri actualUrl = Utils.ParseUri(serverEndpoint.EndpointUrl);

                        if (actualUrl != null && actualUrl.Scheme == expectedUrl.Scheme)
                        {
                            if (serverEndpoint.SecurityPolicyUri == m_endpoint.Description.SecurityPolicyUri)
                            {
                                if (serverEndpoint.SecurityMode == m_endpoint.Description.SecurityMode)
                                {
                                    // ensure endpoint has up to date information.
                                    m_endpoint.Description.Server.ApplicationName = serverEndpoint.Server.ApplicationName;
                                    m_endpoint.Description.Server.ApplicationUri = serverEndpoint.Server.ApplicationUri;
                                    m_endpoint.Description.Server.ApplicationType = serverEndpoint.Server.ApplicationType;
                                    m_endpoint.Description.Server.ProductUri = serverEndpoint.Server.ProductUri;
                                    m_endpoint.Description.TransportProfileUri = serverEndpoint.TransportProfileUri;
                                    m_endpoint.Description.UserIdentityTokens = serverEndpoint.UserIdentityTokens;

                                    found = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                // could be a security risk.
                if (!found)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadSecurityChecksFailed,
                        "Server did not return an EndpointDescription that matched the one used to create the secure channel.");
                }

                // validate the server's signature.
                byte[] dataToSign = Utils.Append(clientCertificateData, clientNonce);

                if (!SecurityPolicies.Verify(serverCertificate, m_endpoint.Description.SecurityPolicyUri, dataToSign, serverSignature))
                {
                    // validate the signature with complete chain if the check with leaf certificate failed.
                    if (clientCertificateChainData != null)
                    {
                        dataToSign = Utils.Append(clientCertificateChainData, clientNonce);

                        if (!SecurityPolicies.Verify(serverCertificate, m_endpoint.Description.SecurityPolicyUri, dataToSign, serverSignature))
                        {
                            throw ServiceResultException.Create(
                                StatusCodes.BadApplicationSignatureInvalid,
                                "Server did not provide a correct signature for the nonce data provided by the client.");
                        }
                    }
                    else
                    {
                        throw ServiceResultException.Create(
                           StatusCodes.BadApplicationSignatureInvalid,
                           "Server did not provide a correct signature for the nonce data provided by the client.");
                    }
                }

                // get a validator to check certificates provided by server.
                CertificateValidator validator = m_configuration.CertificateValidator;

                // validate software certificates.
                List<SoftwareCertificate> softwareCertificates = new List<SoftwareCertificate>();

                foreach (SignedSoftwareCertificate signedCertificate in serverSoftwareCertificates)
                {
                    SoftwareCertificate softwareCertificate = null;

                    ServiceResult result = SoftwareCertificate.Validate(
                        validator,
                        signedCertificate.CertificateData,
                        out softwareCertificate);

                    if (ServiceResult.IsBad(result))
                    {
                        OnSoftwareCertificateError(signedCertificate, result);
                    }

                    softwareCertificates.Add(softwareCertificate);
                }

                // check if software certificates meet application requirements.
                ValidateSoftwareCertificates(softwareCertificates);

                // create the client signature.
                dataToSign = Utils.Append(serverCertificate != null ? serverCertificate.RawData : null, serverNonce);
                SignatureData clientSignature = SecurityPolicies.Sign(m_instanceCertificate, securityPolicyUri, dataToSign);

                // select the security policy for the user token.
                securityPolicyUri = identityPolicy.SecurityPolicyUri;

                if (String.IsNullOrEmpty(securityPolicyUri))
                {
                    securityPolicyUri = m_endpoint.Description.SecurityPolicyUri;
                }

                byte[] previousServerNonce = null;

                if (TransportChannel.CurrentToken != null)
                {
                    previousServerNonce = TransportChannel.CurrentToken.ServerNonce;
                }

                // validate server nonce and security parameters for user identity.
                ValidateServerNonce(
                    identity,
                    serverNonce,
                    securityPolicyUri,
                    previousServerNonce,
                    m_endpoint.Description.SecurityMode);

                // sign data with user token.
                SignatureData userTokenSignature = identityToken.Sign(dataToSign, securityPolicyUri);

                // encrypt token.
                identityToken.Encrypt(serverCertificate, serverNonce, securityPolicyUri);

                // send the software certificates assigned to the client.
                SignedSoftwareCertificateCollection clientSoftwareCertificates = GetSoftwareCertificates();

                // copy the preferred locales if provided.
                if (preferredLocales != null && preferredLocales.Count > 0)
                {
                    m_preferredLocales = new StringCollection(preferredLocales);
                }

                StatusCodeCollection certificateResults = null;
                DiagnosticInfoCollection certificateDiagnosticInfos = null;

                // activate session.
                ActivateSession(
                    null,
                    clientSignature,
                    clientSoftwareCertificates,
                    m_preferredLocales,
                    new ExtensionObject(identityToken),
                    userTokenSignature,
                    out serverNonce,
                    out certificateResults,
                    out certificateDiagnosticInfos);

                if (certificateResults != null)
                {
                    for (int i = 0; i < certificateResults.Count; i++)
                    {
                        Utils.Trace("ActivateSession result[{0}] = {1}", i, certificateResults[i]);
                    }
                }

                if (certificateResults == null || certificateResults.Count == 0)
                {
                    Utils.Trace("Empty results were received for the ActivateSession call.");
                }

                // fetch namespaces.
                FetchNamespaceTables();

                lock (SyncRoot)
                {
                    // save nonces.
                    m_sessionName = sessionName;
                    m_identity = identity;
                    m_previousServerNonce = previousServerNonce;
                    m_serverNonce = serverNonce;
                    m_serverCertificate = serverCertificate;

                    // update system context.
                    m_systemContext.PreferredLocales = m_preferredLocales;
                    m_systemContext.SessionId = this.SessionId;
                    m_systemContext.UserIdentity = identity;
                }

                // start keep alive thread.
                StartKeepAliveTimer();
            }
            catch (Exception)
            {
                try
                {
                    CloseSession(null, false);
                    CloseChannel();
                }
                catch (Exception e)
                {
                    Utils.Trace("Cleanup: CloseSession() or CloseChannel() raised exception. " + e.Message);
                }
                finally
                {
                    SessionCreated(null, null);
                }

                throw;
            }
        }

        /// <summary>
        /// Updates the preferred locales used for the session.
        /// </summary>
        /// <param name="preferredLocales">The preferred locales.</param>
        public void ChangePreferredLocales(StringCollection preferredLocales)
        {
            UpdateSession(Identity, preferredLocales);
        }

        /// <summary>
        /// Updates the user identity and/or locales used for the session.
        /// </summary>
        /// <param name="identity">The user identity.</param>
        /// <param name="preferredLocales">The preferred locales.</param>
        public void UpdateSession(IUserIdentity identity, StringCollection preferredLocales)
        {
            byte[] serverNonce = null;

            lock (SyncRoot)
            {
                // check connection state.
                if (!Connected)
                {
                    throw new ServiceResultException(StatusCodes.BadInvalidState, "Not connected to server.");
                }

                // get current nonce.
                serverNonce = m_serverNonce;

                if (preferredLocales == null)
                {
                    preferredLocales = m_preferredLocales;
                }
            }

            // get the identity token.
            UserIdentityToken identityToken = null;
            SignatureData userTokenSignature = null;

            string securityPolicyUri = m_endpoint.Description.SecurityPolicyUri;

            // create the client signature.
            byte[] dataToSign = Utils.Append(m_serverCertificate != null ? m_serverCertificate.RawData : null, serverNonce);
            SignatureData clientSignature = SecurityPolicies.Sign(m_instanceCertificate, securityPolicyUri, dataToSign);

            // choose a default token.
            if (identity == null)
            {
                identity = new UserIdentity();
            }

            // check that the user identity is supported by the endpoint.
            UserTokenPolicy identityPolicy = m_endpoint.Description.FindUserTokenPolicy(identity.TokenType, identity.IssuedTokenType);

            if (identityPolicy == null)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadUserAccessDenied,
                    "Endpoint does not support the user identity type provided.");
            }

            // select the security policy for the user token.
            securityPolicyUri = identityPolicy.SecurityPolicyUri;

            if (String.IsNullOrEmpty(securityPolicyUri))
            {
                securityPolicyUri = m_endpoint.Description.SecurityPolicyUri;
            }

            bool requireEncryption = securityPolicyUri != SecurityPolicies.None;

            // validate the server certificate before encrypting tokens.
            if (m_serverCertificate != null && requireEncryption && identity.TokenType != UserTokenType.Anonymous)
            {
                m_configuration.CertificateValidator.Validate(m_serverCertificate);
            }

            // validate server nonce and security parameters for user identity.
            ValidateServerNonce(
                identity,
                serverNonce,
                securityPolicyUri,
                m_previousServerNonce,
                m_endpoint.Description.SecurityMode);

            // sign data with user token.
            identityToken = identity.GetIdentityToken();
            identityToken.PolicyId = identityPolicy.PolicyId;
            userTokenSignature = identityToken.Sign(dataToSign, securityPolicyUri);

            // encrypt token.
            identityToken.Encrypt(m_serverCertificate, serverNonce, securityPolicyUri);

            // send the software certificates assigned to the client.
            SignedSoftwareCertificateCollection clientSoftwareCertificates = GetSoftwareCertificates();

            StatusCodeCollection certificateResults = null;
            DiagnosticInfoCollection certificateDiagnosticInfos = null;

            // activate session.
            ActivateSession(
                null,
                clientSignature,
                clientSoftwareCertificates,
                preferredLocales,
                new ExtensionObject(identityToken),
                userTokenSignature,
                out serverNonce,
                out certificateResults,
                out certificateDiagnosticInfos);

            // save nonce and new values.
            lock (SyncRoot)
            {
                if (identity != null)
                {
                    m_identity = identity;
                }

                m_previousServerNonce = m_serverNonce;
                m_serverNonce = serverNonce;
                m_preferredLocales = preferredLocales;

                // update system context.
                m_systemContext.PreferredLocales = m_preferredLocales;
                m_systemContext.SessionId = this.SessionId;
                m_systemContext.UserIdentity = identity;
            }
        }

        /// <summary>
        /// Finds the NodeIds for the components for an instance.
        /// </summary>
        public void FindComponentIds(
            NodeId instanceId,
            IList<string> componentPaths,
            out NodeIdCollection componentIds,
            out List<ServiceResult> errors)
        {
            componentIds = new NodeIdCollection();
            errors = new List<ServiceResult>();

            // build list of paths to translate.
            BrowsePathCollection pathsToTranslate = new BrowsePathCollection();

            for (int ii = 0; ii < componentPaths.Count; ii++)
            {
                BrowsePath pathToTranslate = new BrowsePath();

                pathToTranslate.StartingNode = instanceId;
                pathToTranslate.RelativePath = RelativePath.Parse(componentPaths[ii], TypeTree);

                pathsToTranslate.Add(pathToTranslate);
            }

            // translate the paths.
            BrowsePathResultCollection results = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = TranslateBrowsePathsToNodeIds(
                null,
                pathsToTranslate,
                out results,
                out diagnosticInfos);

            // verify that the server returned the correct number of results.
            ClientBase.ValidateResponse(results, pathsToTranslate);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, pathsToTranslate);

            for (int ii = 0; ii < componentPaths.Count; ii++)
            {
                componentIds.Add(NodeId.Null);
                errors.Add(ServiceResult.Good);

                // process any diagnostics associated with any error.
                if (StatusCode.IsBad(results[ii].StatusCode))
                {
                    errors[ii] = new ServiceResult(results[ii].StatusCode, ii, diagnosticInfos, responseHeader.StringTable);
                    continue;
                }

                // Expecting exact one NodeId for a local node.
                // Report an error if the server returns anything other than that.

                if (results[ii].Targets.Count == 0)
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadTargetNodeIdInvalid,
                        "Could not find target for path: {0}.",
                        componentPaths[ii]);

                    continue;
                }

                if (results[ii].Targets.Count != 1)
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadTooManyMatches,
                        "Too many matches found for path: {0}.",
                        componentPaths[ii]);

                    continue;
                }

                if (results[ii].Targets[0].RemainingPathIndex != UInt32.MaxValue)
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadTargetNodeIdInvalid,
                        "Cannot follow path to external server: {0}.",
                        componentPaths[ii]);

                    continue;
                }

                if (NodeId.IsNull(results[ii].Targets[0].TargetId))
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadUnexpectedError,
                        "Server returned a null NodeId for path: {0}.",
                        componentPaths[ii]);

                    continue;
                }

                if (results[ii].Targets[0].TargetId.IsAbsolute)
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadUnexpectedError,
                        "Server returned a remote node for path: {0}.",
                        componentPaths[ii]);

                    continue;
                }

                // suitable target found.
                componentIds[ii] = ExpandedNodeId.ToNodeId(results[ii].Targets[0].TargetId, m_namespaceUris);
            }
        }


        /// <summary>
        /// Reads the values for a set of variables.
        /// </summary>
        /// <param name="variableIds">The variable ids.</param>
        /// <param name="expectedTypes">The expected types.</param>
        /// <param name="values">The list of returned values.</param>
        /// <param name="errors">The list of returned errors.</param>
        public void ReadValues(
            IList<NodeId> variableIds,
            IList<Type> expectedTypes,
            out List<object> values,
            out List<ServiceResult> errors)
        {
            values = new List<object>();
            errors = new List<ServiceResult>();

            // build list of values to read.
            ReadValueIdCollection valuesToRead = new ReadValueIdCollection();

            for (int ii = 0; ii < variableIds.Count; ii++)
            {
                ReadValueId valueToRead = new ReadValueId();

                valueToRead.NodeId = variableIds[ii];
                valueToRead.AttributeId = Attributes.Value;
                valueToRead.IndexRange = null;
                valueToRead.DataEncoding = null;

                valuesToRead.Add(valueToRead);
            }

            // read the values.
            DataValueCollection results = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = Read(
                null,
                0,
                TimestampsToReturn.Both,
                valuesToRead,
                out results,
                out diagnosticInfos);

            // verify that the server returned the correct number of results.
            ClientBase.ValidateResponse(results, valuesToRead);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, valuesToRead);

            for (int ii = 0; ii < variableIds.Count; ii++)
            {
                values.Add(null);
                errors.Add(ServiceResult.Good);

                // process any diagnostics associated with bad or uncertain data.
                if (StatusCode.IsNotGood(results[ii].StatusCode))
                {
                    errors[ii] = new ServiceResult(results[ii].StatusCode, ii, diagnosticInfos, responseHeader.StringTable);
                    continue;
                }

                object value = results[ii].Value;

                // extract the body from extension objects.
                ExtensionObject extension = value as ExtensionObject;

                if (extension != null && extension.Body is IEncodeable)
                {
                    value = extension.Body;
                }

                // check expected type.
                if (expectedTypes[ii] != null && !expectedTypes[ii].IsInstanceOfType(value))
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadTypeMismatch,
                        "Value {0} does not have expected type: {1}.",
                        value,
                        expectedTypes[ii].Name);

                    continue;
                }

                // suitable value found.
                values[ii] = value;
            }
        }


        /// <summary>
        /// Reads the display name for a set of Nodes.
        /// </summary>
        public void ReadDisplayName(
            IList<NodeId> nodeIds,
            out List<string> displayNames,
            out List<ServiceResult> errors)
        {
            displayNames = new List<string>();
            errors = new List<ServiceResult>();

            // build list of values to read.
            ReadValueIdCollection valuesToRead = new ReadValueIdCollection();

            for (int ii = 0; ii < nodeIds.Count; ii++)
            {
                ReadValueId valueToRead = new ReadValueId();

                valueToRead.NodeId = nodeIds[ii];
                valueToRead.AttributeId = Attributes.DisplayName;
                valueToRead.IndexRange = null;
                valueToRead.DataEncoding = null;

                valuesToRead.Add(valueToRead);
            }

            // read the values.
            DataValueCollection results = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = Read(
                null,
                Int32.MaxValue,
                TimestampsToReturn.Both,
                valuesToRead,
                out results,
                out diagnosticInfos);

            // verify that the server returned the correct number of results.
            ClientBase.ValidateResponse(results, valuesToRead);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, valuesToRead);

            for (int ii = 0; ii < nodeIds.Count; ii++)
            {
                displayNames.Add(String.Empty);
                errors.Add(ServiceResult.Good);

                // process any diagnostics associated with bad or uncertain data.
                if (StatusCode.IsNotGood(results[ii].StatusCode))
                {
                    errors[ii] = new ServiceResult(results[ii].StatusCode, ii, diagnosticInfos, responseHeader.StringTable);
                    continue;
                }

                // extract the name.
                LocalizedText displayName = results[ii].GetValue<LocalizedText>(null);

                if (!LocalizedText.IsNullOrEmpty(displayName))
                {
                    displayNames[ii] = displayName.Text;
                }
            }
        }
        #endregion

        #region Close Methods
        /// <summary>
        /// Disconnects from the server and frees any network resources.
        /// </summary>
        public override StatusCode Close()
        {
            return Close(m_keepAliveInterval);
        }

        /// <summary>
        /// Disconnects from the server and frees any network resources with the specified timeout.
        /// </summary>
        public virtual StatusCode Close(int timeout)
        {
            // check if already called.
            if (Disposed)
            {
                return StatusCodes.Good;
            }

            StatusCode result = StatusCodes.Good;

            // stop the keep alive timer.
            if (m_keepAliveTimer != null)
            {
                m_keepAliveTimer.Dispose();
                m_keepAliveTimer = null;
            }

            // check if currectly connected.
            bool connected = Connected;

            // halt all background threads.
            if (connected)
            {
                if (m_SessionClosing != null)
                {
                    try
                    {
                        m_SessionClosing(this, null);
                    }
                    catch (Exception e)
                    {
                        Utils.Trace(e, "Session: Unexpected eror raising SessionClosing event.");
                    }
                }
            }

            // close the session with the server.
            if (connected && !KeepAliveStopped)
            {
                int existingTimeout = this.OperationTimeout;

                try
                {
                    // close the session and delete all subscriptions.
                    this.OperationTimeout = timeout;
                    CloseSession(null, true);
                    this.OperationTimeout = existingTimeout;

                    CloseChannel();

                    // raised notification indicating the session is closed.
                    SessionCreated(null, null);
                }
                catch (Exception e)
                {
                    // dont throw errors on disconnect, but return them
                    // so the caller can log the error.
                    if (e is ServiceResultException)
                    {
                        result = ((ServiceResultException)e).StatusCode;
                    }
                    else
                    {
                        result = StatusCodes.Bad;
                    }

                    Utils.Trace("Session close error: " + result);
                }
            }

            // clean up.
            Dispose();
            return result;
        }
        #endregion

        #region Subscription Methods
        /// <summary>
        /// Adds a subscription to the session.
        /// </summary>
        /// <param name="subscription">The subscription to add.</param>
        /// <returns></returns>
        public bool AddSubscription(Subscription subscription)
        {
            if (subscription == null) throw new ArgumentNullException(nameof(subscription));

            lock (SyncRoot)
            {
                if (m_subscriptions.Contains(subscription))
                {
                    return false;
                }

                subscription.Session = this;
                m_subscriptions.Add(subscription);
            }

            if (m_SubscriptionsChanged != null)
            {
                m_SubscriptionsChanged(this, null);
            }

            return true;
        }

        /// <summary>
        /// Removes a subscription from the session.
        /// </summary>
        /// <param name="subscription">The subscription to remove.</param>
        /// <returns></returns>
        public bool RemoveSubscription(Subscription subscription)
        {
            if (subscription == null) throw new ArgumentNullException(nameof(subscription));

            if (subscription.Created)
            {
                subscription.Delete(false);
            }

            lock (SyncRoot)
            {
                if (!m_subscriptions.Remove(subscription))
                {
                    return false;
                }

                subscription.Session = null;
            }

            if (m_SubscriptionsChanged != null)
            {
                m_SubscriptionsChanged(this, null);
            }

            return true;
        }

        /// <summary>
        /// Removes a list of subscriptions from the sessiont.
        /// </summary>
        /// <param name="subscriptions">The list of subscriptions to remove.</param>
        /// <returns></returns>
        public bool RemoveSubscriptions(IEnumerable<Subscription> subscriptions)
        {
            if (subscriptions == null) throw new ArgumentNullException(nameof(subscriptions));

            bool removed = false;
            List<Subscription> subscriptionsToDelete = new List<Subscription>();

            lock (SyncRoot)
            {
                foreach (Subscription subscription in subscriptions)
                {
                    if (m_subscriptions.Remove(subscription))
                    {
                        if (subscription.Created)
                        {
                            subscriptionsToDelete.Add(subscription);
                        }

                        removed = true;
                    }
                }
            }

            foreach (Subscription subscription in subscriptionsToDelete)
            {
                subscription.Delete(true);
            }

            if (removed)
            {
                if (m_SubscriptionsChanged != null)
                {
                    m_SubscriptionsChanged(this, null);
                }
            }

            return true;
        }
        #endregion

        #region Browse Methods
        /// <summary>
        /// Invokes the Browse service.
        /// </summary>
        /// <param name="requestHeader">The request header.</param>
        /// <param name="view">The view to browse.</param>
        /// <param name="nodeToBrowse">The node to browse.</param>
        /// <param name="maxResultsToReturn">The maximum number of returned values.</param>
        /// <param name="browseDirection">The browse direction.</param>
        /// <param name="referenceTypeId">The reference type id.</param>
        /// <param name="includeSubtypes">If set to <c>true</c> the subtypes of the ReferenceType will be included in the browse.</param>
        /// <param name="nodeClassMask">The node class mask.</param>
        /// <param name="continuationPoint">The continuation point.</param>
        /// <param name="references">The list of node references.</param>
        /// <returns></returns>
        public virtual ResponseHeader Browse(
            RequestHeader requestHeader,
            ViewDescription view,
            NodeId nodeToBrowse,
            uint maxResultsToReturn,
            BrowseDirection browseDirection,
            NodeId referenceTypeId,
            bool includeSubtypes,
            uint nodeClassMask,
            out byte[] continuationPoint,
            out ReferenceDescriptionCollection references)
        {
            BrowseDescription description = new BrowseDescription();

            description.NodeId = nodeToBrowse;
            description.BrowseDirection = browseDirection;
            description.ReferenceTypeId = referenceTypeId;
            description.IncludeSubtypes = includeSubtypes;
            description.NodeClassMask = nodeClassMask;
            description.ResultMask = (uint)BrowseResultMask.All;

            BrowseDescriptionCollection nodesToBrowse = new BrowseDescriptionCollection();
            nodesToBrowse.Add(description);

            BrowseResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = Browse(
                requestHeader,
                view,
                maxResultsToReturn,
                nodesToBrowse,
                out results,
                out diagnosticInfos);

            ClientBase.ValidateResponse(results, nodesToBrowse);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToBrowse);

            if (StatusCode.IsBad(results[0].StatusCode))
            {
                throw new ServiceResultException(new ServiceResult(results[0].StatusCode, 0, diagnosticInfos, responseHeader.StringTable));
            }

            continuationPoint = results[0].ContinuationPoint;
            references = results[0].References;

            return responseHeader;
        }

        /// <summary>
        /// Begins an asynchronous invocation of the Browse service.
        /// </summary>
        /// <param name="requestHeader">The request header.</param>
        /// <param name="view">The view to browse.</param>
        /// <param name="nodeToBrowse">The node to browse.</param>
        /// <param name="maxResultsToReturn">The maximum number of returned values..</param>
        /// <param name="browseDirection">The browse direction.</param>
        /// <param name="referenceTypeId">The reference type id.</param>
        /// <param name="includeSubtypes">If set to <c>true</c> the subtypes of the ReferenceType will be included in the browse.</param>
        /// <param name="nodeClassMask">The node class mask.</param>
        /// <param name="callback">The callback.</param>
        /// <param name="asyncState"></param>
        /// <returns></returns>
        public IAsyncResult BeginBrowse(
            RequestHeader requestHeader,
            ViewDescription view,
            NodeId nodeToBrowse,
            uint maxResultsToReturn,
            BrowseDirection browseDirection,
            NodeId referenceTypeId,
            bool includeSubtypes,
            uint nodeClassMask,
            AsyncCallback callback,
            object asyncState)
        {
            BrowseDescription description = new BrowseDescription();

            description.NodeId = nodeToBrowse;
            description.BrowseDirection = browseDirection;
            description.ReferenceTypeId = referenceTypeId;
            description.IncludeSubtypes = includeSubtypes;
            description.NodeClassMask = nodeClassMask;
            description.ResultMask = (uint)BrowseResultMask.All;

            BrowseDescriptionCollection nodesToBrowse = new BrowseDescriptionCollection();
            nodesToBrowse.Add(description);

            return BeginBrowse(
                requestHeader,
                view,
                maxResultsToReturn,
                nodesToBrowse,
                callback,
                asyncState);
        }

        /// <summary>
        /// Finishes an asynchronous invocation of the Browse service.
        /// </summary>
        /// <param name="result">The result.</param>
        /// <param name="continuationPoint">The continuation point.</param>
        /// <param name="references">The list of node references.</param>
        /// <returns></returns>
        public ResponseHeader EndBrowse(
            IAsyncResult result,
            out byte[] continuationPoint,
            out ReferenceDescriptionCollection references)
        {
            BrowseResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = EndBrowse(
                result,
                out results,
                out diagnosticInfos);

            if (results == null || results.Count != 1)
            {
                throw new ServiceResultException(StatusCodes.BadUnknownResponse);
            }

            if (StatusCode.IsBad(results[0].StatusCode))
            {
                throw new ServiceResultException(new ServiceResult(results[0].StatusCode, 0, diagnosticInfos, responseHeader.StringTable));
            }

            continuationPoint = results[0].ContinuationPoint;
            references = results[0].References;

            return responseHeader;
        }
        #endregion

        #region BrowseNext Methods
        /// <summary>
        /// Invokes the BrowseNext service.
        /// </summary>
        public virtual ResponseHeader BrowseNext(
            RequestHeader requestHeader,
            bool releaseContinuationPoint,
            byte[] continuationPoint,
            out byte[] revisedContinuationPoint,
            out ReferenceDescriptionCollection references)
        {
            ByteStringCollection continuationPoints = new ByteStringCollection();
            continuationPoints.Add(continuationPoint);

            BrowseResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = BrowseNext(
                requestHeader,
                releaseContinuationPoint,
                continuationPoints,
                out results,
                out diagnosticInfos);

            ClientBase.ValidateResponse(results, continuationPoints);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, continuationPoints);

            if (StatusCode.IsBad(results[0].StatusCode))
            {
                throw new ServiceResultException(new ServiceResult(results[0].StatusCode, 0, diagnosticInfos, responseHeader.StringTable));
            }

            revisedContinuationPoint = results[0].ContinuationPoint;
            references = results[0].References;

            return responseHeader;
        }

        /// <summary>
        /// Begins an asynchronous invocation of the BrowseNext service.
        /// </summary>
        public IAsyncResult BeginBrowseNext(
            RequestHeader requestHeader,
            bool releaseContinuationPoint,
            byte[] continuationPoint,
            AsyncCallback callback,
            object asyncState)
        {
            ByteStringCollection continuationPoints = new ByteStringCollection();
            continuationPoints.Add(continuationPoint);

            return BeginBrowseNext(
                requestHeader,
                releaseContinuationPoint,
                continuationPoints,
                callback,
                asyncState);
        }

        /// <summary>
        /// Finishes an asynchronous invocation of the BrowseNext service.
        /// </summary>
        public ResponseHeader EndBrowseNext(
            IAsyncResult result,
            out byte[] revisedContinuationPoint,
            out ReferenceDescriptionCollection references)
        {
            BrowseResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = EndBrowseNext(
                result,
                out results,
                out diagnosticInfos);

            if (results == null || results.Count != 1)
            {
                throw new ServiceResultException(StatusCodes.BadUnknownResponse);
            }

            if (StatusCode.IsBad(results[0].StatusCode))
            {
                throw new ServiceResultException(new ServiceResult(results[0].StatusCode, 0, diagnosticInfos, responseHeader.StringTable));
            }

            revisedContinuationPoint = results[0].ContinuationPoint;
            references = results[0].References;

            return responseHeader;
        }
        #endregion

        #region Call Methods
        /// <summary>
        /// Calls the specified method and returns the output arguments.
        /// </summary>
        /// <param name="objectId">The NodeId of the object that provides the method.</param>
        /// <param name="methodId">The NodeId of the method to call.</param>
        /// <param name="args">The input arguments.</param>
        /// <returns>The list of output argument values.</returns>
        public IList<object> Call(NodeId objectId, NodeId methodId, params object[] args)
        {
            VariantCollection inputArguments = new VariantCollection();

            if (args != null)
            {
                for (int ii = 0; ii < args.Length; ii++)
                {
                    inputArguments.Add(new Variant(args[ii]));
                }
            }

            CallMethodRequest request = new CallMethodRequest();

            request.ObjectId = objectId;
            request.MethodId = methodId;
            request.InputArguments = inputArguments;

            CallMethodRequestCollection requests = new CallMethodRequestCollection();
            requests.Add(request);

            CallMethodResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = Call(
                null,
                requests,
                out results,
                out diagnosticInfos);

            ClientBase.ValidateResponse(results, requests);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, requests);

            if (StatusCode.IsBad(results[0].StatusCode))
            {
                throw ServiceResultException.Create(results[0].StatusCode, 0, diagnosticInfos, responseHeader.StringTable);
            }

            List<object> outputArguments = new List<object>();

            foreach (Variant arg in results[0].OutputArguments)
            {
                outputArguments.Add(arg.Value);
            }

            return outputArguments;
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Returns the software certificates assigned to the application.
        /// </summary>
        protected virtual SignedSoftwareCertificateCollection GetSoftwareCertificates()
        {
            return new SignedSoftwareCertificateCollection();
        }

        /// <summary>
        /// Handles an error when validating the application instance certificate provided by the server.
        /// </summary>
        protected virtual void OnApplicationCertificateError(byte[] serverCertificate, ServiceResult result)
        {
            throw new ServiceResultException(result);
        }

        /// <summary>
        /// Handles an error when validating software certificates provided by the server.
        /// </summary>
        protected virtual void OnSoftwareCertificateError(SignedSoftwareCertificate signedCertificate, ServiceResult result)
        {
            throw new ServiceResultException(result);
        }

        /// <summary>
        /// Inspects the software certificates provided by the server. 
        /// </summary>
        protected virtual void ValidateSoftwareCertificates(List<SoftwareCertificate> softwareCertificates)
        {
            // always accept valid certificates.
        }

        /// <summary>
        /// Starts a timer to check that the connection to the server is still available.
        /// </summary>
        private void StartKeepAliveTimer()
        {
            int keepAliveInterval = m_keepAliveInterval;

            lock (m_eventLock)
            {
                m_serverState = ServerState.Unknown;
                m_lastKeepAliveTime = DateTime.UtcNow;
            }

            ReadValueIdCollection nodesToRead = new ReadValueIdCollection();

            // read the server state.
            ReadValueId serverState = new ReadValueId();

            serverState.NodeId = Variables.Server_ServerStatus_State;
            serverState.AttributeId = Attributes.Value;
            serverState.DataEncoding = null;
            serverState.IndexRange = null;

            nodesToRead.Add(serverState);

            // restart the publish timer.
            lock (SyncRoot)
            {
                if (m_keepAliveTimer != null)
                {
                    m_keepAliveTimer.Dispose();
                    m_keepAliveTimer = null;
                }

                // start timer.
                m_keepAliveTimer = new Timer(OnKeepAlive, nodesToRead, keepAliveInterval, keepAliveInterval);
            }

            // send initial keep alive.
            OnKeepAlive(nodesToRead);
        }

        /// <summary>
        /// Removes a completed async request.
        /// </summary>
        private AsyncRequestState RemoveRequest(IAsyncResult result, uint requestId, uint typeId)
        {
            lock (m_outstandingRequests)
            {
                for (LinkedListNode<AsyncRequestState> ii = m_outstandingRequests.First; ii != null; ii = ii.Next)
                {
                    if (Object.ReferenceEquals(result, ii.Value.Result) || (requestId == ii.Value.RequestId && typeId == ii.Value.RequestTypeId))
                    {
                        AsyncRequestState state = ii.Value;
                        m_outstandingRequests.Remove(ii);
                        return state;
                    }
                }

                return null;
            }
        }

        /// <summary>
        /// Adds a new async request.
        /// </summary>
        private void AsyncRequestStarted(IAsyncResult result, uint requestId, uint typeId)
        {
            lock (m_outstandingRequests)
            {
                // check if the request completed asynchronously.
                AsyncRequestState state = RemoveRequest(result, requestId, typeId);

                // add a new request.
                if (state == null)
                {
                    state = new AsyncRequestState();

                    state.Defunct = false;
                    state.RequestId = requestId;
                    state.RequestTypeId = typeId;
                    state.Result = result;
                    state.Timestamp = DateTime.UtcNow;

                    m_outstandingRequests.AddLast(state);
                }
            }
        }

        /// <summary>
        /// Removes a completed async request.
        /// </summary>
        private void AsyncRequestCompleted(IAsyncResult result, uint requestId, uint typeId)
        {
            lock (m_outstandingRequests)
            {
                // remove the request.
                AsyncRequestState state = RemoveRequest(result, requestId, typeId);

                if (state != null)
                {
                    // mark any old requests as default (i.e. the should have returned before this request).
                    DateTime maxAge = state.Timestamp.AddSeconds(-1);

                    for (LinkedListNode<AsyncRequestState> ii = m_outstandingRequests.First; ii != null; ii = ii.Next)
                    {
                        if (ii.Value.RequestTypeId == typeId && ii.Value.Timestamp < maxAge)
                        {
                            ii.Value.Defunct = true;
                        }
                    }
                }

                // add a dummy placeholder since the begin request has not completed yet.
                if (state == null)
                {
                    state = new AsyncRequestState();

                    state.Defunct = true;
                    state.RequestId = requestId;
                    state.RequestTypeId = typeId;
                    state.Result = result;
                    state.Timestamp = DateTime.UtcNow;

                    m_outstandingRequests.AddLast(state);
                }
            }
        }

        /// <summary>
        /// Sends a keep alive by reading from the server.
        /// </summary>
        private void OnKeepAlive(object state)
        {
            ReadValueIdCollection nodesToRead = (ReadValueIdCollection)state;

            try
            {
                // check if session has been closed.
                if (!Connected || m_keepAliveTimer == null)
                {
                    return;
                }

                // raise error if keep alives are not coming back.
                if (KeepAliveStopped)
                {
                    if (!OnKeepAliveError(ServiceResult.Create(StatusCodes.BadNoCommunication, "Server not responding to keep alive requests.")))
                    {
                        return;
                    }
                }

                RequestHeader requestHeader = new RequestHeader();

                requestHeader.RequestHandle = Utils.IncrementIdentifier(ref m_keepAliveCounter);
                requestHeader.TimeoutHint = (uint)(KeepAliveInterval * 2);
                requestHeader.ReturnDiagnostics = 0;

                IAsyncResult result = BeginRead(
                    requestHeader,
                    0,
                    TimestampsToReturn.Neither,
                    nodesToRead,
                    OnKeepAliveComplete,
                    nodesToRead);

                AsyncRequestStarted(result, requestHeader.RequestHandle, DataTypes.ReadRequest);
            }
            catch (Exception e)
            {
                Utils.Trace("Could not send keep alive request: {1} {0}", e.Message, e.GetType().FullName);
            }
        }

        /// <summary>
        /// Checks if a notification has arrived. Sends a publish if it has not.
        /// </summary>
        private void OnKeepAliveComplete(IAsyncResult result)
        {
            ReadValueIdCollection nodesToRead = (ReadValueIdCollection)result.AsyncState;

            AsyncRequestCompleted(result, 0, DataTypes.ReadRequest);

            try
            {
                // read the server status.
                DataValueCollection values = new DataValueCollection();
                DiagnosticInfoCollection diagnosticInfos = new DiagnosticInfoCollection();

                ResponseHeader responseHeader = EndRead(
                    result,
                    out values,
                    out diagnosticInfos);

                ValidateResponse(values, nodesToRead);
                ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);

                // validate value returned.
                ServiceResult error = ValidateDataValue(values[0], typeof(int), 0, diagnosticInfos, responseHeader);

                if (ServiceResult.IsBad(error))
                {
                    throw new ServiceResultException(error);
                }

                // send notification that keep alive completed.
                OnKeepAlive((ServerState)(int)values[0].Value, responseHeader.Timestamp);
            }
            catch (Exception e)
            {
                Utils.Trace("Unexpected keep alive error occurred: {0}", e.Message);
            }
        }

        /// <summary>
        /// Called when the server returns a keep alive response.
        /// </summary>
        protected virtual void OnKeepAlive(ServerState currentState, DateTime currentTime)
        {
            // restart publishing if keep alives recovered.
            if (KeepAliveStopped)
            {
                // ignore if already reconnecting.
                if (m_reconnecting)
                {
                    return;
                }

                int count = 0;

                lock (m_outstandingRequests)
                {
                    for (LinkedListNode<AsyncRequestState> ii = m_outstandingRequests.First; ii != null; ii = ii.Next)
                    {
                        if (ii.Value.RequestTypeId == DataTypes.PublishRequest)
                        {
                            ii.Value.Defunct = true;
                        }
                    }
                }

                lock (SyncRoot)
                {
                    count = m_subscriptions.Count;
                }

                while (count-- > 0)
                {
                    BeginPublish(OperationTimeout);
                }
            }

            KeepAliveEventHandler callback = null;

            lock (m_eventLock)
            {
                callback = m_KeepAlive;

                // save server state.
                m_serverState = currentState;
                m_lastKeepAliveTime = DateTime.UtcNow;
            }

            if (callback != null)
            {
                try
                {
                    callback(this, new KeepAliveEventArgs(null, currentState, currentTime));
                }
                catch (Exception e)
                {
                    Utils.Trace(e, "Session: Unexpected error invoking KeepAliveCallback.");
                }
            }
        }

        /// <summary>
        /// Called when a error occurs during a keep alive.
        /// </summary>
        protected virtual bool OnKeepAliveError(ServiceResult result)
        {
            long delta = 0;

            lock (m_eventLock)
            {
                delta = DateTime.UtcNow.Ticks - m_lastKeepAliveTime.Ticks;
            }

            Utils.Trace(
                "KEEP ALIVE LATE: {0}s, EndpointUrl={1}, RequestCount={3}/{2}",
                ((double)delta) / TimeSpan.TicksPerSecond,
                this.Endpoint.EndpointUrl,
                this.OutstandingRequestCount,
                this.GoodPublishRequestCount);

            KeepAliveEventHandler callback = null;

            lock (m_eventLock)
            {
                callback = m_KeepAlive;
            }

            if (callback != null)
            {
                try
                {
                    KeepAliveEventArgs args = new KeepAliveEventArgs(result, ServerState.Unknown, DateTime.UtcNow);
                    callback(this, args);
                    return !args.CancelKeepAlive;
                }
                catch (Exception e)
                {
                    Utils.Trace(e, "Session: Unexpected error invoking KeepAliveCallback.");
                }
            }

            return true;
        }
        #endregion

        #region Publish Methods
        /// <summary>
        /// Sends an additional publish request.
        /// </summary>
        public IAsyncResult BeginPublish(int timeout)
        {
            // do not publish if reconnecting.
            if (m_reconnecting)
            {
                Utils.Trace("Published skipped due to reconnect");
                return null;
            }

            SubscriptionAcknowledgementCollection acknowledgementsToSend = null;

            // collect the current set if acknowledgements.
            lock (SyncRoot)
            {
                acknowledgementsToSend = m_acknowledgementsToSend;
                m_acknowledgementsToSend = new SubscriptionAcknowledgementCollection();
                foreach (var toSend in acknowledgementsToSend)
                {
                    if (m_latestAcknowledgementsSent.ContainsKey(toSend.SubscriptionId))
                    {
                        m_latestAcknowledgementsSent[toSend.SubscriptionId] = toSend.SequenceNumber;
                    }
                    else
                    {
                        m_latestAcknowledgementsSent.Add(toSend.SubscriptionId, toSend.SequenceNumber);
                    }
                }
            }

            // send publish request.
            RequestHeader requestHeader = new RequestHeader();

            // ensure the publish request is discarded before the timeout occurs to ensure the channel is dropped.
            requestHeader.TimeoutHint = (uint)OperationTimeout / 2;
            requestHeader.ReturnDiagnostics = (uint)(int)ReturnDiagnostics;
            requestHeader.RequestHandle = Utils.IncrementIdentifier(ref m_publishCounter);

            AsyncRequestState state = new AsyncRequestState();

            state.RequestTypeId = DataTypes.PublishRequest;
            state.RequestId = requestHeader.RequestHandle;
            state.Timestamp = DateTime.UtcNow;

            try
            {
                IAsyncResult result = BeginPublish(
                    requestHeader,
                    acknowledgementsToSend,
                    OnPublishComplete,
                    new object[] { SessionId, acknowledgementsToSend, requestHeader });

                AsyncRequestStarted(result, requestHeader.RequestHandle, DataTypes.PublishRequest);

                Utils.Trace("PUBLISH #{0} SENT", requestHeader.RequestHandle);

                return result;
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Unexpected error sending publish request.");
                return null;
            }
        }

        /// <summary>
        /// Completes an asynchronous publish operation.
        /// </summary>
        private void OnPublishComplete(IAsyncResult result)
        {
            // extract state information.
            object[] state = (object[])result.AsyncState;
            NodeId sessionId = (NodeId)state[0];
            SubscriptionAcknowledgementCollection acknowledgementsToSend = (SubscriptionAcknowledgementCollection)state[1];
            RequestHeader requestHeader = (RequestHeader)state[2];
            bool moreNotifications;

            AsyncRequestCompleted(result, requestHeader.RequestHandle, DataTypes.PublishRequest);

            try
            {
                Utils.Trace("PUBLISH #{0} RECEIVED", requestHeader.RequestHandle);

                // complete publish.
                uint subscriptionId;
                UInt32Collection availableSequenceNumbers;
                NotificationMessage notificationMessage;
                StatusCodeCollection acknowledgeResults;
                DiagnosticInfoCollection acknowledgeDiagnosticInfos;

                ResponseHeader responseHeader = EndPublish(
                    result,
                    out subscriptionId,
                    out availableSequenceNumbers,
                    out moreNotifications,
                    out notificationMessage,
                    out acknowledgeResults,
                    out acknowledgeDiagnosticInfos);

                foreach (StatusCode code in acknowledgeResults)
                {
                    if (StatusCode.IsBad(code))
                    {
                        Utils.Trace("Error - Publish call finished. ResultCode={0}; SubscriptionId={1};", code.ToString(), subscriptionId);
                    }
                }

                // nothing more to do if session changed.
                if (sessionId != SessionId)
                {
                    Utils.Trace("Publish response discarded because session id changed: Old {0} != New {1}", sessionId, SessionId);
                    return;
                }

                Utils.Trace("NOTIFICATION RECEIVED: SubId={0}, SeqNo={1}", subscriptionId, notificationMessage.SequenceNumber);

                // process response.
                ProcessPublishResponse(
                    responseHeader,
                    subscriptionId,
                    availableSequenceNumbers,
                    moreNotifications,
                    notificationMessage);

                // nothing more to do if reconnecting.
                if (m_reconnecting)
                {
                    Utils.Trace("No new publish sent because of reconnect in progress.");
                    return;
                }
            }
            catch (Exception e)
            {
                if (m_subscriptions.Count == 0)
                {
                    // Publish responses with error should occur after deleting the last subscription.
                    Utils.Trace("Publish #{0}, Subscription count = 0, Error: {1}", requestHeader.RequestHandle, e.Message);
                }
                else
                {
                    Utils.Trace("Publish #{0}, Reconnecting={2}, Error: {1}", requestHeader.RequestHandle, e.Message, m_reconnecting);
                }

                moreNotifications = false;

                // ignore errors if reconnecting.
                if (m_reconnecting)
                {
                    Utils.Trace("Publish abandoned after error due to reconnect: {0}", e.Message);
                    return;
                }

                // nothing more to do if session changed.
                if (sessionId != SessionId)
                {
                    Utils.Trace("Publish abandoned after error because session id changed: Old {0} != New {1}", sessionId, SessionId);
                    return;
                }

                // try to acknowledge the notifications again in the next publish.
                if (acknowledgementsToSend != null)
                {
                    lock (SyncRoot)
                    {
                        m_acknowledgementsToSend.AddRange(acknowledgementsToSend);
                    }
                }

                // raise an error event.     
                ServiceResult error = new ServiceResult(e);

                if (error.Code != StatusCodes.BadNoSubscription)
                {
                    PublishErrorEventHandler callback = null;

                    lock (m_eventLock)
                    {
                        callback = m_PublishError;
                    }

                    if (callback != null)
                    {
                        try
                        {
                            callback(this, new PublishErrorEventArgs(error));
                        }
                        catch (Exception e2)
                        {
                            Utils.Trace(e2, "Session: Unexpected error invoking PublishErrorCallback.");
                        }
                    }
                }

                // don't send another publish for these errors.
                switch (error.Code)
                {
                    case StatusCodes.BadNoSubscription:
                    case StatusCodes.BadSessionClosed:
                    case StatusCodes.BadSessionIdInvalid:
                    case StatusCodes.BadTooManyPublishRequests:
                    case StatusCodes.BadServerHalted:
                    {
                        return;
                    }
                }

                Utils.Trace(e, "PUBLISH #{0} - Unhandled error during Publish.", requestHeader.RequestHandle);
            }

            int requestCount = GoodPublishRequestCount;

            if (requestCount < m_subscriptions.Count)
            {
                BeginPublish(OperationTimeout);
            }
            else
            {
                Utils.Trace("PUBLISH - Did not send another publish request. GoodPublishRequestCount={0}, Subscriptions={1}", requestCount, m_subscriptions.Count);
            }
        }

        /// <summary>
        /// Sends a republish request.
        /// </summary>
        public bool Republish(uint subscriptionId, uint sequenceNumber)
        {
            // send publish request.
            RequestHeader requestHeader = new RequestHeader();

            requestHeader.TimeoutHint = (uint)OperationTimeout;
            requestHeader.ReturnDiagnostics = (uint)(int)ReturnDiagnostics;
            requestHeader.RequestHandle = Utils.IncrementIdentifier(ref m_publishCounter);

            try
            {
                Utils.Trace("Requesting Republish for {0}-{1}", subscriptionId, sequenceNumber);

                // request republish.
                NotificationMessage notificationMessage = null;

                ResponseHeader responseHeader = Republish(
                    requestHeader,
                    subscriptionId,
                    sequenceNumber,
                    out notificationMessage);

                Utils.Trace("Received Republish for {0}-{1}", subscriptionId, sequenceNumber);

                // process response.
                ProcessPublishResponse(
                    responseHeader,
                    subscriptionId,
                    null,
                    false,
                    notificationMessage);

                return true;
            }
            catch (Exception e)
            {
                ServiceResult error = new ServiceResult(e);

                bool result = true;
                switch (error.StatusCode.Code)
                {
                    case StatusCodes.BadMessageNotAvailable:
                        Utils.Trace("Message {0}-{1} no longer available.", subscriptionId, sequenceNumber);
                        break;
                    // if encoding limits are exceeded, the issue is logged and 
                    // the published data is acknoledged to prevent the endless republish loop.
                    case StatusCodes.BadEncodingLimitsExceeded:
                        Utils.Trace(e, "Message {0}-{1} exceeded size limits, ignored.", subscriptionId, sequenceNumber);
                        var ack = new SubscriptionAcknowledgement {
                            SubscriptionId = subscriptionId,
                            SequenceNumber = sequenceNumber
                        };
                        lock (SyncRoot)
                        {
                            m_acknowledgementsToSend.Add(ack);
                        }
                        break;
                    default:
                        result = false;
                        Utils.Trace(e, "Unexpected error sending republish request.");
                        break;
                }

                PublishErrorEventHandler callback = null;

                lock (m_eventLock)
                {
                    callback = m_PublishError;
                }

                // raise an error event.
                if (callback != null)
                {
                    try
                    {
                        PublishErrorEventArgs args = new PublishErrorEventArgs(
                            error,
                            subscriptionId,
                            sequenceNumber);

                        callback(this, args);
                    }
                    catch (Exception e2)
                    {
                        Utils.Trace(e2, "Session: Unexpected error invoking PublishErrorCallback.");
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Processes the response from a publish request.
        /// </summary>
        private void ProcessPublishResponse(
            ResponseHeader responseHeader,
            uint subscriptionId,
            UInt32Collection availableSequenceNumbers,
            bool moreNotifications,
            NotificationMessage notificationMessage)
        {
            Subscription subscription = null;

            // send notification that the server is alive.
            OnKeepAlive(m_serverState, responseHeader.Timestamp);

            // collect the current set if acknowledgements.
            lock (SyncRoot)
            {
                // clear out acknowledgements for messages that the server does not have any more.
                SubscriptionAcknowledgementCollection acknowledgementsToSend = new SubscriptionAcknowledgementCollection();

                for (int ii = 0; ii < m_acknowledgementsToSend.Count; ii++)
                {
                    SubscriptionAcknowledgement acknowledgement = m_acknowledgementsToSend[ii];

                    if (acknowledgement.SubscriptionId != subscriptionId)
                    {
                        acknowledgementsToSend.Add(acknowledgement);
                    }
                    else
                    {
                        if (availableSequenceNumbers == null || availableSequenceNumbers.Contains(acknowledgement.SequenceNumber))
                        {
                            acknowledgementsToSend.Add(acknowledgement);
                        }
                    }
                }

                // create an acknowledgement to be sent back to the server.
                if (notificationMessage.NotificationData.Count > 0)
                {
                    SubscriptionAcknowledgement acknowledgement = new SubscriptionAcknowledgement();

                    acknowledgement.SubscriptionId = subscriptionId;
                    acknowledgement.SequenceNumber = notificationMessage.SequenceNumber;

                    acknowledgementsToSend.Add(acknowledgement);
                }

                uint lastSentSequenceNumber = 0;
                if (availableSequenceNumbers != null)
                {
                    foreach (uint availableSequenceNumber in availableSequenceNumbers)
                    {
                        if (m_latestAcknowledgementsSent.ContainsKey(subscriptionId))
                        {
                            lastSentSequenceNumber = m_latestAcknowledgementsSent[subscriptionId];

                            // If the last sent sequence number is uint.Max do not display the warning; the counter rolled over
                            // If the last sent sequence number is greater or equal to the available sequence number (returned by the publish), a warning must be logged.
                            if (((lastSentSequenceNumber >= availableSequenceNumber) && (lastSentSequenceNumber != uint.MaxValue)) ||
                                (lastSentSequenceNumber == availableSequenceNumber) && (lastSentSequenceNumber == uint.MaxValue))
                            {
                                Utils.Trace("Received sequence number which was already acknowledged={0}", availableSequenceNumber);
                            }
                        }
                    }
                }

                if (m_latestAcknowledgementsSent.ContainsKey(subscriptionId))
                {
                    lastSentSequenceNumber = m_latestAcknowledgementsSent[subscriptionId];

                    // If the last sent sequence number is uint.Max do not display the warning; the counter rolled over
                    // If the last sent sequence number is greater or equal to the notificationMessage's sequence number (returned by the publish), a warning must be logged.
                    if (((lastSentSequenceNumber >= notificationMessage.SequenceNumber) && (lastSentSequenceNumber != uint.MaxValue)) || (lastSentSequenceNumber == notificationMessage.SequenceNumber) && (lastSentSequenceNumber == uint.MaxValue))
                    {
                        Utils.Trace("Received sequence number which was already acknowledged={0}", notificationMessage.SequenceNumber);
                    }
                }

                if (availableSequenceNumbers != null)
                {
                    foreach (var acknowledgement in acknowledgementsToSend)
                    {
                        if (acknowledgement.SubscriptionId == subscriptionId && !availableSequenceNumbers.Contains(acknowledgement.SequenceNumber))
                        {
                            Utils.Trace("Sequence number={0} was not received in the available sequence numbers.", acknowledgement.SequenceNumber);
                        }
                    }
                }

                m_acknowledgementsToSend = acknowledgementsToSend;

                if (notificationMessage.IsEmpty)
                {
                    Utils.Trace("Empty notification message received for SessionId {0} with PublishTime {1}", SessionId, notificationMessage.PublishTime.ToLocalTime());
                }

                // find the subscription.
                foreach (Subscription current in m_subscriptions)
                {
                    if (current.Id == subscriptionId)
                    {
                        subscription = current;
                        break;
                    }
                }
            }

            // ignore messages with a subscription that has been deleted.
            if (subscription != null)
            {
                // Validate publish time and reject old values.
                if (notificationMessage.PublishTime.AddMilliseconds(subscription.CurrentPublishingInterval * subscription.CurrentLifetimeCount) < DateTime.UtcNow)
                {
                    Utils.Trace("PublishTime {0} in publish response is too old for SubscriptionId {1}.", notificationMessage.PublishTime.ToLocalTime(), subscription.Id);
                }

                // Validate publish time and reject old values.
                if (notificationMessage.PublishTime > DateTime.UtcNow.AddMilliseconds(subscription.CurrentPublishingInterval * subscription.CurrentLifetimeCount))
                {
                    Utils.Trace("PublishTime {0} in publish response is newer than actual time for SubscriptionId {1}.", notificationMessage.PublishTime.ToLocalTime(), subscription.Id);
                }

                // update subscription cache.                                 
                subscription.SaveMessageInCache(
                    availableSequenceNumbers,
                    notificationMessage,
                    responseHeader.StringTable);

                // raise the notification.
                lock (m_eventLock)
                {
                    NotificationEventArgs args = new NotificationEventArgs(subscription, notificationMessage, responseHeader.StringTable);

                    if (m_Publish != null)
                    {
                        Task.Run(() => {
                            OnRaisePublishNotification(args);
                        });
                    }
                }
            }
            else
            {
                // Delete abandoned subscription from server.
                Utils.Trace("Received Publish Response for Unknown SubscriptionId={0}", subscriptionId);

                Task.Run(() => {
                    DeleteSubscription(subscriptionId);
                });
            }
        }

        /// <summary>
        /// Raises an event indicating that publish has returned a notification.
        /// </summary>
        private void OnRaisePublishNotification(object state)
        {
            try
            {
                NotificationEventArgs args = (NotificationEventArgs)state;
                NotificationEventHandler callback = m_Publish;

                if (callback != null && args.Subscription.Id != 0)
                {
                    callback(this, args);
                }
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Session: Unexpected error while raising Notification event.");
            }
        }

        /// <summary>
        /// Invokes a DeleteSubscriptions call for the specified subscriptionId.
        /// </summary>
        private void DeleteSubscription(uint subscriptionId)
        {
            try
            {
                Utils.Trace("Deleting server subscription for SubscriptionId={0}", subscriptionId);

                // delete the subscription.
                UInt32Collection subscriptionIds = new uint[] { subscriptionId };

                StatusCodeCollection results;
                DiagnosticInfoCollection diagnosticInfos;

                ResponseHeader responseHeader = DeleteSubscriptions(
                    null,
                    subscriptionIds,
                    out results,
                    out diagnosticInfos);

                // validate response.
                ClientBase.ValidateResponse(results, subscriptionIds);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, subscriptionIds);

                if (StatusCode.IsBad(results[0]))
                {
                    throw new ServiceResultException(ClientBase.GetResult(results[0], 0, diagnosticInfos, responseHeader));
                }
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Session: Unexpected error while deleting subscription for SubscriptionId={0}.", subscriptionId);
            }
        }

        /// <summary>
        /// Load certificate chain for connection.
        /// </summary>
        private static async Task<X509Certificate2> LoadCertificate(ApplicationConfiguration configuration)
        {
            X509Certificate2 clientCertificate;
            if (configuration.SecurityConfiguration.ApplicationCertificate == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "ApplicationCertificate must be specified.");
            }

            clientCertificate = await configuration.SecurityConfiguration.ApplicationCertificate.Find(true);

            if (clientCertificate == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "ApplicationCertificate cannot be found.");
            }
            return clientCertificate;
        }


        /// <summary>
        /// Load certificate chain for connection.
        /// </summary>
        private static async Task<X509Certificate2Collection> LoadCertificateChain(ApplicationConfiguration configuration, X509Certificate2 clientCertificate)
        {
            X509Certificate2Collection clientCertificateChain = null;
            // load certificate chain.
            if (configuration.SecurityConfiguration.SendCertificateChain)
            {
                clientCertificateChain = new X509Certificate2Collection(clientCertificate);
                List<CertificateIdentifier> issuers = new List<CertificateIdentifier>();
                await configuration.CertificateValidator.GetIssuers(clientCertificate, issuers);

                for (int i = 0; i < issuers.Count; i++)
                {
                    clientCertificateChain.Add(issuers[i].Certificate);
                }
            }
            return clientCertificateChain;
        }
        #endregion

        #region Private Fields
        private SubscriptionAcknowledgementCollection m_acknowledgementsToSend;
        private Dictionary<uint, uint> m_latestAcknowledgementsSent;
        private List<Subscription> m_subscriptions;
        private Dictionary<NodeId, DataDictionary> m_dictionaries;
        private Subscription m_defaultSubscription;
        private double m_sessionTimeout;
        private uint m_maxRequestMessageSize;
        private StringCollection m_preferredLocales;
        private NamespaceTable m_namespaceUris;
        private StringTable m_serverUris;
        private EncodeableFactory m_factory;
        private SystemContext m_systemContext;
        private NodeCache m_nodeCache;
        private ApplicationConfiguration m_configuration;
        private ConfiguredEndpoint m_endpoint;
        private X509Certificate2 m_instanceCertificate;
        private X509Certificate2Collection m_instanceCertificateChain;
        private bool m_checkDomain;
        private List<IUserIdentity> m_identityHistory;

        private string m_sessionName;
        private object m_handle;
        private IUserIdentity m_identity;
        private byte[] m_serverNonce;
        private byte[] m_previousServerNonce;
        private X509Certificate2 m_serverCertificate;
        private long m_publishCounter;
        private DateTime m_lastKeepAliveTime;
        private ServerState m_serverState;
        private int m_keepAliveInterval;
        private Timer m_keepAliveTimer;
        private long m_keepAliveCounter;
        private bool m_reconnecting;
        private LinkedList<AsyncRequestState> m_outstandingRequests;

        private EndpointDescriptionCollection m_discoveryServerEndpoints;
        private StringCollection m_discoveryProfileUris;

        private class AsyncRequestState
        {
            public uint RequestTypeId;
            public uint RequestId;
            public DateTime Timestamp;
            public IAsyncResult Result;
            public bool Defunct;
        }

        private object m_eventLock = new object();
        private event KeepAliveEventHandler m_KeepAlive;
        private event NotificationEventHandler m_Publish;
        private event PublishErrorEventHandler m_PublishError;
        private event EventHandler m_SubscriptionsChanged;
        private event EventHandler m_SessionClosing;
        #endregion
    }

    #region KeepAliveEventArgs Class
    /// <summary>
    /// The event arguments provided when a keep alive response arrives.
    /// </summary>
    public class KeepAliveEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Creates a new instance.
        /// </summary>
        internal KeepAliveEventArgs(
            ServiceResult status,
            ServerState currentState,
            DateTime currentTime)
        {
            m_status = status;
            m_currentState = currentState;
            m_currentTime = currentTime;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets the status associated with the keep alive operation.
        /// </summary>
        public ServiceResult Status => m_status;

        /// <summary>
        /// Gets the current server state.
        /// </summary>
        public ServerState CurrentState => m_currentState;

        /// <summary>
        /// Gets the current server time.
        /// </summary>
        public DateTime CurrentTime => m_currentTime;

        /// <summary>
        /// Gets or sets a flag indicating whether the session should send another keep alive.
        /// </summary>
        public bool CancelKeepAlive
        {
            get { return m_cancelKeepAlive; }
            set { m_cancelKeepAlive = value; }
        }
        #endregion

        #region Private Fields
        private ServiceResult m_status;
        private ServerState m_currentState;
        private DateTime m_currentTime;
        private bool m_cancelKeepAlive;
        #endregion
    }

    /// <summary>
    /// The delegate used to receive keep alive notifications.
    /// </summary>
    public delegate void KeepAliveEventHandler(Session session, KeepAliveEventArgs e);
    #endregion

    #region NotificationEventArgs Class
    /// <summary>
    /// Represents the event arguments provided when a new notification message arrives.
    /// </summary>
    public class NotificationEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Creates a new instance.
        /// </summary>
        internal NotificationEventArgs(
            Subscription subscription,
            NotificationMessage notificationMessage,
            IList<string> stringTable)
        {
            m_subscription = subscription;
            m_notificationMessage = notificationMessage;
            m_stringTable = stringTable;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets the subscription that the notification applies to.
        /// </summary>
        public Subscription Subscription => m_subscription;

        /// <summary>
        /// Gets the notification message.
        /// </summary>
        public NotificationMessage NotificationMessage => m_notificationMessage;

        /// <summary>
        /// Gets the string table returned with the notification message.
        /// </summary>
        public IList<string> StringTable => m_stringTable;
        #endregion

        #region Private Fields
        private Subscription m_subscription;
        private NotificationMessage m_notificationMessage;
        private IList<string> m_stringTable;
        #endregion
    }

    /// <summary>
    /// The delegate used to receive publish notifications.
    /// </summary>
    public delegate void NotificationEventHandler(Session session, NotificationEventArgs e);
    #endregion

    #region PublishErrorEventArgs Class
    /// <summary>
    /// Represents the event arguments provided when a publish error occurs.
    /// </summary>
    public class PublishErrorEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Creates a new instance.
        /// </summary>
        internal PublishErrorEventArgs(ServiceResult status)
        {
            m_status = status;
        }

        /// <summary>
        /// Creates a new instance.
        /// </summary>
        internal PublishErrorEventArgs(ServiceResult status, uint subscriptionId, uint sequenceNumber)
        {
            m_status = status;
            m_subscriptionId = subscriptionId;
            m_sequenceNumber = sequenceNumber;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets the status associated with the keep alive operation.
        /// </summary>
        public ServiceResult Status => m_status;

        /// <summary>
        /// Gets the subscription with the message that could not be republished.
        /// </summary>
        public uint SubscriptionId => m_subscriptionId;

        /// <summary>
        /// Gets the sequence number for the message that could not be republished.
        /// </summary>
        public uint SequenceNumber => m_sequenceNumber;
        #endregion

        #region Private Fields
        private uint m_subscriptionId;
        private uint m_sequenceNumber;
        private ServiceResult m_status;
        #endregion
    }

    /// <summary>
    /// The delegate used to receive pubish error notifications.
    /// </summary>
    public delegate void PublishErrorEventHandler(Session session, PublishErrorEventArgs e);
    #endregion
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Runtime.Serialization;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml;
using Opc.Ua.Security.Certificates;

namespace Opc.Ua.Client
{
    /// <summary>
    /// Manages a session with a server.
    /// </summary>
    public class Session : SessionClient, IDisposable
    {
        #region Constructors
        /// <summary>
        /// Constructs a new instance of the <see cref="Session"/> class.
        /// </summary>
        /// <param name="channel">The channel used to communicate with the server.</param>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="endpoint">The endpoint use to initialize the channel.</param>
        public Session(
            ISessionChannel channel,
            ApplicationConfiguration configuration,
            ConfiguredEndpoint endpoint)
        :
            this(channel as ITransportChannel, configuration, endpoint, null)
        {
        }

        /// <summary>
        /// Constructs a new instance of the <see cref="Session"/> class.
        /// </summary>
        /// <param name="channel">The channel used to communicate with the server.</param>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="endpoint">The endpoint used to initialize the channel.</param>
        /// <param name="clientCertificate">The certificate to use for the client.</param>
        /// <param name="availableEndpoints">The list of available endpoints returned by server in GetEndpoints() response.</param>
        /// <param name="discoveryProfileUris">The value of profileUris used in GetEndpoints() request.</param>
        /// <remarks>
        /// The application configuration is used to look up the certificate if none is provided.
        /// The clientCertificate must have the private key. This will require that the certificate
        /// be loaded from a certicate store. Converting a DER encoded blob to a X509Certificate2
        /// will not include a private key.
        /// The <i>availableEndpoints</i> and <i>discoveryProfileUris</i> parameters are used to validate
        /// that the list of EndpointDescriptions returned at GetEndpoints matches the list returned at CreateSession.
        /// </remarks>
        public Session(
            ITransportChannel channel,
            ApplicationConfiguration configuration,
            ConfiguredEndpoint endpoint,
            X509Certificate2 clientCertificate,
            EndpointDescriptionCollection availableEndpoints = null,
            StringCollection discoveryProfileUris = null)
            :
                base(channel)
        {
            Initialize(channel, configuration, endpoint, clientCertificate);
            m_discoveryServerEndpoints = availableEndpoints;
            m_discoveryProfileUris = discoveryProfileUris;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="Session"/> class.
        /// </summary>
        /// <param name="channel">The channel.</param>
        /// <param name="template">The template session.</param>
        /// <param name="copyEventHandlers">if set to <c>true</c> the event handlers are copied.</param>
        public Session(ITransportChannel channel, Session template, bool copyEventHandlers)
        :
            base(channel)
        {
            Initialize(channel, template.m_configuration, template.m_endpoint, template.m_instanceCertificate);

            m_defaultSubscription = template.m_defaultSubscription;
            m_sessionTimeout = template.m_sessionTimeout;
            m_maxRequestMessageSize = template.m_maxRequestMessageSize;
            m_preferredLocales = template.m_preferredLocales;
            m_sessionName = template.m_sessionName;
            m_handle = template.m_handle;
            m_identity = template.m_identity;
            m_keepAliveInterval = template.m_keepAliveInterval;
            m_checkDomain = template.m_checkDomain;

            if (copyEventHandlers)
            {
                m_KeepAlive = template.m_KeepAlive;
                m_Publish = template.m_Publish;
                m_PublishError = template.m_PublishError;
                m_SubscriptionsChanged = template.m_SubscriptionsChanged;
                m_SessionClosing = template.m_SessionClosing;
            }

            foreach (Subscription subscription in template.Subscriptions)
            {
                this.AddSubscription(new Subscription(subscription, copyEventHandlers));
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Initializes the channel.
        /// </summary>
        private void Initialize(
            ITransportChannel channel,
            ApplicationConfiguration configuration,
            ConfiguredEndpoint endpoint,
            X509Certificate2 clientCertificate)
        {
            Initialize();

            ValidateClientConfiguration(configuration);

            // save configuration information.
            m_configuration = configuration;
            m_endpoint = endpoint;

            // update the default subscription. 
            m_defaultSubscription.MinLifetimeInterval = (uint)configuration.ClientConfiguration.MinSubscriptionLifetime;

            if (m_endpoint.Description.SecurityPolicyUri != SecurityPolicies.None)
            {
                // update client certificate.
                m_instanceCertificate = clientCertificate;

                if (clientCertificate == null)
                {
                    // load the application instance certificate.
                    if (m_configuration.SecurityConfiguration.ApplicationCertificate == null)
                    {
                        throw new ServiceResultException(
                            StatusCodes.BadConfigurationError,
                            "The client configuration does not specify an application instance certificate.");
                    }

                    m_instanceCertificate = m_configuration.SecurityConfiguration.ApplicationCertificate.Find(true).Result;

                }

                // check for valid certificate.
                if (m_instanceCertificate == null)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadConfigurationError,
                        "Cannot find the application instance certificate. Store={0}, SubjectName={1}, Thumbprint={2}.",
                        m_configuration.SecurityConfiguration.ApplicationCertificate.StorePath,
                        m_configuration.SecurityConfiguration.ApplicationCertificate.SubjectName,
                        m_configuration.SecurityConfiguration.ApplicationCertificate.Thumbprint);
                }

                // check for private key.
                if (!m_instanceCertificate.HasPrivateKey)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadConfigurationError,
                        "No private key for the application instance certificate. Subject={0}, Thumbprint={1}.",
                        m_instanceCertificate.Subject,
                        m_instanceCertificate.Thumbprint);
                }

                // load certificate chain.
                m_instanceCertificateChain = new X509Certificate2Collection(m_instanceCertificate);
                List<CertificateIdentifier> issuers = new List<CertificateIdentifier>();
                configuration.CertificateValidator.GetIssuers(m_instanceCertificate, issuers).Wait();

                for (int i = 0; i < issuers.Count; i++)
                {
                    m_instanceCertificateChain.Add(issuers[i].Certificate);
                }
            }

            // initialize the message context.
            ServiceMessageContext messageContext = channel.MessageContext;

            if (messageContext != null)
            {
                m_namespaceUris = messageContext.NamespaceUris;
                m_serverUris = messageContext.ServerUris;
                m_factory = messageContext.Factory;
            }
            else
            {
                m_namespaceUris = new NamespaceTable();
                m_serverUris = new StringTable();
                m_factory = new EncodeableFactory(EncodeableFactory.GlobalFactory);
            }

            // set the default preferred locales.
            m_preferredLocales = new string[] { CultureInfo.CurrentCulture.Name };

            // create a context to use.
            m_systemContext = new SystemContext();

            m_systemContext.SystemHandle = this;
            m_systemContext.EncodeableFactory = m_factory;
            m_systemContext.NamespaceUris = m_namespaceUris;
            m_systemContext.ServerUris = m_serverUris;
            m_systemContext.TypeTable = this.TypeTree;
            m_systemContext.PreferredLocales = null;
            m_systemContext.SessionId = null;
            m_systemContext.UserIdentity = null;
        }

        /// <summary>
        /// Sets the object members to default values.
        /// </summary>
        private void Initialize()
        {
            m_sessionTimeout = 0;
            m_namespaceUris = new NamespaceTable();
            m_serverUris = new StringTable();
            m_factory = EncodeableFactory.GlobalFactory;
            m_nodeCache = new NodeCache(this);
            m_configuration = null;
            m_instanceCertificate = null;
            m_endpoint = null;
            m_subscriptions = new List<Subscription>();
            m_dictionaries = new Dictionary<NodeId, DataDictionary>();
            m_acknowledgementsToSend = new SubscriptionAcknowledgementCollection();
            m_latestAcknowledgementsSent = new Dictionary<uint, uint>();
            m_identityHistory = new List<IUserIdentity>();
            m_outstandingRequests = new LinkedList<AsyncRequestState>();
            m_keepAliveInterval = 5000;
            m_sessionName = "";

            m_defaultSubscription = new Subscription();

            m_defaultSubscription.DisplayName = "Subscription";
            m_defaultSubscription.PublishingInterval = 1000;
            m_defaultSubscription.KeepAliveCount = 10;
            m_defaultSubscription.LifetimeCount = 1000;
            m_defaultSubscription.Priority = 255;
            m_defaultSubscription.PublishingEnabled = true;
        }

        /// <summary>
        /// Check if all required configuration fields are populated.
        /// </summary>
        private void ValidateClientConfiguration(ApplicationConfiguration configuration)
        {
            String configurationField;
            if (configuration == null)
            {
                throw new ArgumentNullException(nameof(configuration));
            }
            if (configuration.ClientConfiguration == null)
            {
                configurationField = "ClientConfiguration";
            }
            else if (configuration.SecurityConfiguration == null)
            {
                configurationField = "SecurityConfiguration";
            }
            else if (configuration.CertificateValidator == null)
            {
                configurationField = "CertificateValidator";
            }
            else
            {
                return;
            }

            throw new ServiceResultException(
                StatusCodes.BadConfigurationError,
                $"The client configuration does not specify the {configurationField}.");
        }

        /// <summary>
        /// Validates the server nonce and security parameters of user identity.
        /// </summary>
        private void ValidateServerNonce(
            IUserIdentity identity,
            byte[] serverNonce,
            string securityPolicyUri,
            byte[] previousServerNonce,
            MessageSecurityMode channelSecurityMode = MessageSecurityMode.None)
        {
            // skip validation if server nonce is not used for encryption.
            if (String.IsNullOrEmpty(securityPolicyUri) || securityPolicyUri == SecurityPolicies.None)
            {
                return;
            }

            if (identity != null && identity.TokenType != UserTokenType.Anonymous)
            {
                // the server nonce should be validated if the token includes a secret.
                if (!Utils.Nonce.ValidateNonce(serverNonce, MessageSecurityMode.SignAndEncrypt, (uint)m_configuration.SecurityConfiguration.NonceLength))
                {
                    if (channelSecurityMode == MessageSecurityMode.SignAndEncrypt ||
                        m_configuration.SecurityConfiguration.SuppressNonceValidationErrors)
                    {
                        Utils.Trace((int)Utils.TraceMasks.Security, "Warning: The server nonce has not the correct length or is not random enough. The error is suppressed by user setting or because the channel is encrypted.");
                    }
                    else
                    {
                        throw ServiceResultException.Create(StatusCodes.BadNonceInvalid, "The server nonce has not the correct length or is not random enough.");
                    }
                }

                // check that new nonce is different from the previously returned server nonce.
                if (previousServerNonce != null && Utils.CompareNonce(serverNonce, previousServerNonce))
                {
                    if (channelSecurityMode == MessageSecurityMode.SignAndEncrypt ||
                        m_configuration.SecurityConfiguration.SuppressNonceValidationErrors)
                    {
                        Utils.Trace((int)Utils.TraceMasks.Security, "Warning: The Server nonce is equal with previously returned nonce. The error is suppressed by user setting or because the channel is encrypted.");
                    }
                    else
                    {
                        throw ServiceResultException.Create(StatusCodes.BadNonceInvalid, "Server nonce is equal with previously returned nonce.");
                    }
                }
            }
        }

        #endregion

        #region IDisposable Members
        /// <summary>
        /// Closes the session and the underlying channel.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                Utils.SilentDispose(m_keepAliveTimer);
                m_keepAliveTimer = null;

                Utils.SilentDispose(m_defaultSubscription);
                m_defaultSubscription = null;

                foreach (Subscription subscription in m_subscriptions)
                {
                    Utils.SilentDispose(subscription);
                }

                m_subscriptions.Clear();
            }

            base.Dispose(disposing);
        }
        #endregion

        #region Events
        /// <summary>
        /// Raised when a keep alive arrives from the server or an error is detected.
        /// </summary>
        /// <remarks>
        /// Once a session is created a timer will periodically read the server state and current time.
        /// If this read operation succeeds this event will be raised each time the keep alive period elapses.
        /// If an error is detected (KeepAliveStopped == true) then this event will be raised as well.
        /// </remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1009:DeclareEventHandlersCorrectly")]
        public event KeepAliveEventHandler KeepAlive
        {
            add
            {
                lock (m_eventLock)
                {
                    m_KeepAlive += value;
                }
            }

            remove
            {
                lock (m_eventLock)
                {
                    m_KeepAlive -= value;
                }
            }
        }

        /// <summary>
        /// Raised when a notification message arrives in a publish response.
        /// </summary>
        /// <remarks>
        /// All publish requests are managed by the Session object. When a response arrives it is
        /// validated and passed to the appropriate Subscription object and this event is raised.
        /// </remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1009:DeclareEventHandlersCorrectly")]
        public event NotificationEventHandler Notification
        {
            add
            {
                lock (m_eventLock)
                {
                    m_Publish += value;
                }
            }

            remove
            {
                lock (m_eventLock)
                {
                    m_Publish -= value;
                }
            }
        }

        /// <summary>
        /// Raised when an exception occurs while processing a publish response.
        /// </summary>
        /// <remarks>
        /// Exceptions in a publish response are not necessarily fatal and the Session will 
        /// attempt to recover by issuing Republish requests if missing messages are detected.
        /// That said, timeout errors may be a symptom of a OperationTimeout that is too short
        /// when compared to the shortest PublishingInterval/KeepAliveCount amount the current
        /// Subscriptions. The OperationTimeout should be twice the minimum value for
        /// PublishingInterval*KeepAliveCount.
        /// </remarks>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1009:DeclareEventHandlersCorrectly")]
        public event PublishErrorEventHandler PublishError
        {
            add
            {
                lock (m_eventLock)
                {
                    m_PublishError += value;
                }
            }

            remove
            {
                lock (m_eventLock)
                {
                    m_PublishError -= value;
                }
            }
        }

        /// <summary>
        /// Raised when a subscription is added or removed
        /// </summary>
        public event EventHandler SubscriptionsChanged
        {
            add
            {
                m_SubscriptionsChanged += value;
            }

            remove
            {
                m_SubscriptionsChanged -= value;
            }
        }

        /// <summary>
        /// Raised to indicate the session is closing.
        /// </summary>
        public event EventHandler SessionClosing
        {
            add
            {
                m_SessionClosing += value;
            }

            remove
            {
                m_SessionClosing -= value;
            }
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets the endpoint used to connect to the server.
        /// </summary>
        public ConfiguredEndpoint ConfiguredEndpoint => m_endpoint;

        /// <summary>
        /// Gets the name assigned to the session.
        /// </summary>
        public string SessionName => m_sessionName;

        /// <summary>
        /// Gets the period for wich the server will maintain the session if there is no communication from the client.
        /// </summary>
        public double SessionTimeout => m_sessionTimeout;

        /// <summary>
        /// Gets the local handle assigned to the session
        /// </summary>
        public object Handle
        {
            get { return m_handle; }
            set { m_handle = value; }
        }

        /// <summary>
        /// Gets the user identity currently used for the session.
        /// </summary>
        public IUserIdentity Identity => m_identity;

        /// <summary>
        /// Gets a list of user identities that can be used to connect to the server.
        /// </summary>
        public IEnumerable<IUserIdentity> IdentityHistory => m_identityHistory;

        /// <summary>
        /// Gets the table of namespace uris known to the server.
        /// </summary>
        public NamespaceTable NamespaceUris => m_namespaceUris;

        /// <summary>
        /// Gest the table of remote server uris known to the server.
        /// </summary>
        public StringTable ServerUris => m_serverUris;

        /// <summary>
        /// Gets the system context for use with the session.
        /// </summary>
        public ISystemContext SystemContext => m_systemContext;

        /// <summary>
        /// Gets the factory used to create encodeable objects that the server understands.
        /// </summary>
        public EncodeableFactory Factory => m_factory;

        /// <summary>
        /// Gets the cache of the server's type tree.
        /// </summary>
        public ITypeTable TypeTree => m_nodeCache.TypeTree;

        /// <summary>
        /// Gets the cache of nodes fetched from the server.
        /// </summary>
        public NodeCache NodeCache => m_nodeCache;

        /// <summary>
        /// Gets the context to use for filter operations.
        /// </summary>
        public FilterContext FilterContext => new FilterContext(m_namespaceUris, m_nodeCache.TypeTree, m_preferredLocales);

        /// <summary>
        /// Gets the locales that the server should use when returning localized text.
        /// </summary>
        public StringCollection PreferredLocales => m_preferredLocales;

        /// <summary>
        /// Gets the data type system dictionaries in use.
        /// </summary>
        public Dictionary<NodeId, DataDictionary> DataTypeSystem => m_dictionaries;

        /// <summary>
        /// Gets the subscriptions owned by the session.
        /// </summary>
        public IEnumerable<Subscription> Subscriptions
        {
            get
            {
                lock (SyncRoot)
                {
                    return new ReadOnlyList<Subscription>(m_subscriptions);
                }
            }
        }

        /// <summary>
        /// Gets the number of subscriptions owned by the session.
        /// </summary>
        public int SubscriptionCount
        {
            get
            {
                lock (SyncRoot)
                {
                    return m_subscriptions.Count;
                }
            }
        }

        /// <summary>
        /// Gets or Sets the default subscription for the session.
        /// </summary>
        public Subscription DefaultSubscription
        {
            get { return m_defaultSubscription; }
            set { m_defaultSubscription = value; }
        }

        /// <summary>
        /// Gets or Sets how frequently the server is pinged to see if communication is still working.
        /// </summary>
        /// <remarks>
        /// This interval controls how much time elaspes before a communication error is detected.
        /// If everything is ok the KeepAlive event will be raised each time this period elapses.
        /// </remarks>
        public int KeepAliveInterval
        {
            get
            {
                return m_keepAliveInterval;
            }

            set
            {
                m_keepAliveInterval = value;
                StartKeepAliveTimer();
            }
        }

        /// <summary>
        /// Returns true if the session is not receiving keep alives.
        /// </summary>
        /// <remarks>
        /// Set to true if the server does not respond for 2 times the KeepAliveInterval.
        /// Set to false is communication recovers.
        /// </remarks>
        public bool KeepAliveStopped
        {
            get
            {
                lock (m_eventLock)
                {
                    long delta = DateTime.UtcNow.Ticks - m_lastKeepAliveTime.Ticks;

                    // add a 1000ms guard band to allow for network lag.
                    return (m_keepAliveInterval * 2) * TimeSpan.TicksPerMillisecond <= delta;
                }
            }
        }

        /// <summary>
        /// Gets the time of the last keep alive.
        /// </summary>
        public DateTime LastKeepAliveTime => m_lastKeepAliveTime;

        /// <summary>
        /// Gets the number of outstanding publish or keep alive requests.
        /// </summary>
        public int OutstandingRequestCount
        {
            get
            {
                lock (m_outstandingRequests)
                {
                    return m_outstandingRequests.Count;
                }
            }
        }

        /// <summary>
        /// Gets the number of outstanding publish or keep alive requests which appear to be missing.
        /// </summary>
        public int DefunctRequestCount
        {
            get
            {
                lock (m_outstandingRequests)
                {
                    int count = 0;

                    for (LinkedListNode<AsyncRequestState> ii = m_outstandingRequests.First; ii != null; ii = ii.Next)
                    {
                        if (ii.Value.Defunct)
                        {
                            count++;
                        }
                    }

                    return count;
                }
            }
        }

        /// <summary>
        /// Gets the number of good outstanding publish requests.
        /// </summary>
        public int GoodPublishRequestCount
        {
            get
            {
                lock (m_outstandingRequests)
                {
                    int count = 0;

                    for (LinkedListNode<AsyncRequestState> ii = m_outstandingRequests.First; ii != null; ii = ii.Next)
                    {
                        if (!ii.Value.Defunct && ii.Value.RequestTypeId == DataTypes.PublishRequest)
                        {
                            count++;
                        }
                    }

                    return count;
                }
            }
        }
        #endregion

        #region Public Static Methods
        /// <summary>
        /// Creates a new communication session with a server by invoking the CreateSession service
        /// </summary>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="endpoint">The endpoint for the server.</param>
        /// <param name="updateBeforeConnect">If set to <c>true</c> the discovery endpoint is used to update the endpoint description before connecting.</param>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The timeout period for the session.</param>
        /// <param name="identity">The identity.</param>
        /// <param name="preferredLocales">The user identity to associate with the session.</param>
        /// <returns>The new session object</returns>
        public static Task<Session> Create(
            ApplicationConfiguration configuration,
            ConfiguredEndpoint endpoint,
            bool updateBeforeConnect,
            string sessionName,
            uint sessionTimeout,
            IUserIdentity identity,
            IList<string> preferredLocales)
        {
            return Create(configuration, endpoint, updateBeforeConnect, false, sessionName, sessionTimeout, identity, preferredLocales);
        }

        /// <summary>
        /// Creates a new communication session with a server by invoking the CreateSession service
        /// </summary>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="endpoint">The endpoint for the server.</param>
        /// <param name="updateBeforeConnect">If set to <c>true</c> the discovery endpoint is used to update the endpoint description before connecting.</param>
        /// <param name="checkDomain">If set to <c>true</c> then the domain in the certificate must match the endpoint used.</param>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The timeout period for the session.</param>
        /// <param name="identity">The user identity to associate with the session.</param>
        /// <param name="preferredLocales">The preferred locales.</param>
        /// <returns>The new session object.</returns>
        public static Task<Session> Create(
            ApplicationConfiguration configuration,
            ConfiguredEndpoint endpoint,
            bool updateBeforeConnect,
            bool checkDomain,
            string sessionName,
            uint sessionTimeout,
            IUserIdentity identity,
            IList<string> preferredLocales)
        {
            return Create(configuration, null, endpoint, updateBeforeConnect, checkDomain, sessionName, sessionTimeout, identity, preferredLocales);
        }

        /// <summary>
        /// Creates a new communication session with a server using a reverse connection.
        /// </summary>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="connection">The client endpoint for the reverse connect.</param>
        /// <param name="endpoint">The endpoint for the server.</param>
        /// <param name="updateBeforeConnect">If set to <c>true</c> the discovery endpoint is used to update the endpoint description before connecting.</param>
        /// <param name="checkDomain">If set to <c>true</c> then the domain in the certificate must match the endpoint used.</param>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The timeout period for the session.</param>
        /// <param name="identity">The user identity to associate with the session.</param>
        /// <param name="preferredLocales">The preferred locales.</param>
        /// <returns>The new session object.</returns>
        public static async Task<Session> Create(
            ApplicationConfiguration configuration,
            ITransportWaitingConnection connection,
            ConfiguredEndpoint endpoint,
            bool updateBeforeConnect,
            bool checkDomain,
            string sessionName,
            uint sessionTimeout,
            IUserIdentity identity,
            IList<string> preferredLocales)
        {
            endpoint.UpdateBeforeConnect = updateBeforeConnect;

            EndpointDescription endpointDescription = endpoint.Description;

            // create the endpoint configuration (use the application configuration to provide default values).
            EndpointConfiguration endpointConfiguration = endpoint.Configuration;

            if (endpointConfiguration == null)
            {
                endpoint.Configuration = endpointConfiguration = EndpointConfiguration.Create(configuration);
            }

            // create message context.
            ServiceMessageContext messageContext = configuration.CreateMessageContext(true);

            // update endpoint description using the discovery endpoint.
            if (endpoint.UpdateBeforeConnect && connection == null)
            {
                endpoint.UpdateFromServer();
                endpointDescription = endpoint.Description;
                endpointConfiguration = endpoint.Configuration;
            }

            // checks the domains in the certificate.
            if (checkDomain &&
                endpoint.Description.ServerCertificate != null &&
                endpoint.Description.ServerCertificate.Length > 0)
            {
                configuration.CertificateValidator?.ValidateDomains(
                    new X509Certificate2(endpoint.Description.ServerCertificate),
                    endpoint);
                checkDomain = false;
            }

            X509Certificate2 clientCertificate = null;
            X509Certificate2Collection clientCertificateChain = null;
            if (endpointDescription.SecurityPolicyUri != SecurityPolicies.None)
            {
                clientCertificate = await LoadCertificate(configuration);
                clientCertificateChain = await LoadCertificateChain(configuration, clientCertificate);
            }

            // initialize the channel which will be created with the server.
            ITransportChannel channel;
            if (connection != null)
            {
                channel = SessionChannel.CreateUaBinaryChannel(
                    configuration,
                    connection,
                    endpointDescription,
                    endpointConfiguration,
                    clientCertificate,
                    clientCertificateChain,
                    messageContext);
            }
            else
            {
                channel = SessionChannel.Create(
                     configuration,
                     endpointDescription,
                     endpointConfiguration,
                     clientCertificate,
                     clientCertificateChain,
                     messageContext);
            }

            // create the session object.
            Session session = new Session(channel, configuration, endpoint, null);

            // create the session.
            try
            {
                session.Open(sessionName, sessionTimeout, identity, preferredLocales, checkDomain);
            }
            catch (Exception)
            {
                session.Dispose();
                throw;
            }

            return session;
        }

        /// <summary>
        /// Creates a new communication session with a server using a reverse connect manager.
        /// </summary>
        /// <param name="configuration">The configuration for the client application.</param>
        /// <param name="reverseConnectManager">The reverse connect manager for the client connection.</param>
        /// <param name="endpoint">The endpoint for the server.</param>
        /// <param name="updateBeforeConnect">If set to <c>true</c> the discovery endpoint is used to update the endpoint description before connecting.</param>
        /// <param name="checkDomain">If set to <c>true</c> then the domain in the certificate must match the endpoint used.</param>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The timeout period for the session.</param>
        /// <param name="userIdentity">The user identity to associate with the session.</param>
        /// <param name="preferredLocales">The preferred locales.</param>
        /// <param name="ct">The cancellation token.</param>
        /// <returns>The new session object.</returns>
        public static async Task<Session> Create(
            ApplicationConfiguration configuration,
            ReverseConnectManager reverseConnectManager,
            ConfiguredEndpoint endpoint,
            bool updateBeforeConnect,
            bool checkDomain,
            string sessionName,
            uint sessionTimeout,
            IUserIdentity userIdentity,
            IList<string> preferredLocales,
            CancellationToken ct = default(CancellationToken)
            )
        {
            if (reverseConnectManager == null)
            {
                return await Create(configuration, endpoint, updateBeforeConnect,
                    checkDomain, sessionName, sessionTimeout, userIdentity, preferredLocales);
            }

            ITransportWaitingConnection connection = null;
            do
            {
                connection = await reverseConnectManager.WaitForConnection(
                    endpoint.EndpointUrl,
                    endpoint.ReverseConnect.ServerUri,
                    ct);

                if (updateBeforeConnect)
                {
                    await endpoint.UpdateFromServerAsync(
                        endpoint.EndpointUrl, connection,
                        endpoint.Description.SecurityMode,
                        endpoint.Description.SecurityPolicyUri);
                    updateBeforeConnect = false;
                    connection = null;
                }
            } while (connection == null);

            return await Create(
                configuration,
                connection,
                endpoint,
                false,
                checkDomain,
                sessionName,
                sessionTimeout,
                userIdentity,
                preferredLocales);
        }

        /// <summary>
        /// Recreates a session based on a specified template.
        /// </summary>
        /// <param name="template">The Session object to use as template</param>
        /// <returns>The new session object.</returns>
        public static Session Recreate(Session template)
        {
            ServiceMessageContext messageContext = template.m_configuration.CreateMessageContext();
            messageContext.Factory = template.Factory;

            // create the channel object used to connect to the server.
            ITransportChannel channel = SessionChannel.Create(
                template.m_configuration,
                template.m_endpoint.Description,
                template.m_endpoint.Configuration,
                template.m_instanceCertificate,
                template.m_configuration.SecurityConfiguration.SendCertificateChain ?
                    template.m_instanceCertificateChain : null,
                messageContext);

            // create the session object.
            Session session = new Session(channel, template, true);

            try
            {
                // open the session.
                session.Open(
                    template.m_sessionName,
                    (uint)template.m_sessionTimeout,
                    template.m_identity,
                    template.m_preferredLocales,
                    template.m_checkDomain);

                // create the subscriptions.
                foreach (Subscription subscription in session.Subscriptions)
                {
                    subscription.Create();
                }
            }
            catch (Exception e)
            {
                session.Dispose();
                throw ServiceResultException.Create(StatusCodes.BadCommunicationError, e, "Could not recreate session. {0}", template.m_sessionName);
            }

            return session;
        }

        /// <summary>
        /// Recreates a session based on a specified template.
        /// </summary>
        /// <param name="template">The Session object to use as template</param>
        /// <param name="connection">The waiting reverse connection.</param>
        /// <returns>The new session object.</returns>
        public static Session Recreate(Session template, ITransportWaitingConnection connection)
        {
            ServiceMessageContext messageContext = template.m_configuration.CreateMessageContext();
            messageContext.Factory = template.Factory;

            // create the channel object used to connect to the server.
            ITransportChannel channel = SessionChannel.Create(
                template.m_configuration,
                connection,
                template.m_endpoint.Description,
                template.m_endpoint.Configuration,
                template.m_instanceCertificate,
                template.m_configuration.SecurityConfiguration.SendCertificateChain ?
                    template.m_instanceCertificateChain : null,
                messageContext);

            // create the session object.
            Session session = new Session(channel, template, true);

            try
            {
                // open the session.
                session.Open(
                    template.m_sessionName,
                    (uint)template.m_sessionTimeout,
                    template.m_identity,
                    template.m_preferredLocales,
                    template.m_checkDomain);

                // create the subscriptions.
                foreach (Subscription subscription in session.Subscriptions)
                {
                    subscription.Create();
                }
            }
            catch (Exception e)
            {
                session.Dispose();
                throw ServiceResultException.Create(StatusCodes.BadCommunicationError, e, "Could not recreate session. {0}", template.m_sessionName);
            }

            return session;
        }
        #endregion

        #region Delegates and Events
        /// <summary>
        /// Used to handle renews of user identity tokens before reconnect.
        /// </summary>
        public delegate IUserIdentity RenewUserIdentityEventHandler(Session session, IUserIdentity identity);

        /// <summary>
        /// Raised before a reconnect operation completes.
        /// </summary>
        public event RenewUserIdentityEventHandler RenewUserIdentity
        {
            add { m_RenewUserIdentity += value; }
            remove { m_RenewUserIdentity -= value; }
        }

        private event RenewUserIdentityEventHandler m_RenewUserIdentity;
        #endregion

        #region Public Methods
        /// <summary>
        /// Reconnects to the server after a network failure.
        /// </summary>
        public void Reconnect()
        {
            Reconnect(null);
        }

        /// <summary>
        /// Reconnects to the server after a network failure using a waiting connection.
        /// </summary>
        public void Reconnect(ITransportWaitingConnection connection)
        {
            try
            {
                lock (SyncRoot)
                {
                    // check if already connecting.
                    if (m_reconnecting)
                    {
                        Utils.Trace("Session is already attempting to reconnect.");

                        throw ServiceResultException.Create(
                            StatusCodes.BadInvalidState,
                            "Session is already attempting to reconnect.");
                    }

                    Utils.Trace("Session RECONNECT starting.");
                    m_reconnecting = true;

                    // stop keep alives.
                    if (m_keepAliveTimer != null)
                    {
                        m_keepAliveTimer.Dispose();
                        m_keepAliveTimer = null;
                    }
                }

                // create the client signature.
                byte[] dataToSign = Utils.Append(m_serverCertificate != null ? m_serverCertificate.RawData : null, m_serverNonce);
                EndpointDescription endpoint = m_endpoint.Description;
                SignatureData clientSignature = SecurityPolicies.Sign(m_instanceCertificate, endpoint.SecurityPolicyUri, dataToSign);

                // check that the user identity is supported by the endpoint.
                UserTokenPolicy identityPolicy = endpoint.FindUserTokenPolicy(m_identity.TokenType, m_identity.IssuedTokenType);

                if (identityPolicy == null)
                {
                    Utils.Trace("Endpoint does not support the user identity type provided.");

                    throw ServiceResultException.Create(
                        StatusCodes.BadUserAccessDenied,
                        "Endpoint does not support the user identity type provided.");
                }

                // select the security policy for the user token.
                string securityPolicyUri = identityPolicy.SecurityPolicyUri;

                if (String.IsNullOrEmpty(securityPolicyUri))
                {
                    securityPolicyUri = endpoint.SecurityPolicyUri;
                }

                // need to refresh the identity (reprompt for password, refresh token).
                if (m_RenewUserIdentity != null)
                {
                    m_identity = m_RenewUserIdentity(this, m_identity);
                }

                // validate server nonce and security parameters for user identity.
                ValidateServerNonce(
                    m_identity,
                    m_serverNonce,
                    securityPolicyUri,
                    m_previousServerNonce,
                    m_endpoint.Description.SecurityMode);

                // sign data with user token.
                UserIdentityToken identityToken = m_identity.GetIdentityToken();
                identityToken.PolicyId = identityPolicy.PolicyId;
                SignatureData userTokenSignature = identityToken.Sign(dataToSign, securityPolicyUri);

                // encrypt token.
                identityToken.Encrypt(m_serverCertificate, m_serverNonce, securityPolicyUri);

                // send the software certificates assigned to the client.
                SignedSoftwareCertificateCollection clientSoftwareCertificates = GetSoftwareCertificates();

                Utils.Trace("Session REPLACING channel.");

                if (connection != null)
                {
                    // check if the channel supports reconnect.
                    if ((TransportChannel.SupportedFeatures & TransportChannelFeatures.Reconnect) != 0)
                    {
                        TransportChannel.Reconnect(connection);
                    }
                    else
                    {
                        // initialize the channel which will be created with the server.
                        ITransportChannel channel = SessionChannel.Create(
                            m_configuration,
                            connection,
                            m_endpoint.Description,
                            m_endpoint.Configuration,
                            m_instanceCertificate,
                            m_configuration.SecurityConfiguration.SendCertificateChain ? m_instanceCertificateChain : null,
                            MessageContext);

                        // disposes the existing channel.
                        TransportChannel = channel;
                    }
                }
                else
                {
                    // check if the channel supports reconnect.
                    if ((TransportChannel.SupportedFeatures & TransportChannelFeatures.Reconnect) != 0)
                    {
                        TransportChannel.Reconnect();
                    }
                    else
                    {
                        // initialize the channel which will be created with the server.
                        ITransportChannel channel = SessionChannel.Create(
                            m_configuration,
                            m_endpoint.Description,
                            m_endpoint.Configuration,
                            m_instanceCertificate,
                            m_configuration.SecurityConfiguration.SendCertificateChain ? m_instanceCertificateChain : null,
                            MessageContext);

                        // disposes the existing channel.
                        TransportChannel = channel;
                    }
                }

                // reactivate session.
                byte[] serverNonce = null;
                StatusCodeCollection certificateResults = null;
                DiagnosticInfoCollection certificateDiagnosticInfos = null;

                Utils.Trace("Session RE-ACTIVATING session.");

                IAsyncResult result = BeginActivateSession(
                    null,
                    clientSignature,
                    null,
                    m_preferredLocales,
                    new ExtensionObject(identityToken),
                    userTokenSignature,
                    null,
                    null);

                if (!result.AsyncWaitHandle.WaitOne(5000))
                {
                    Utils.Trace("WARNING: ACTIVATE SESSION timed out. {1}/{0}", OutstandingRequestCount, GoodPublishRequestCount);
                }

                EndActivateSession(
                    result,
                    out serverNonce,
                    out certificateResults,
                    out certificateDiagnosticInfos);

                int publishCount = 0;

                lock (SyncRoot)
                {
                    Utils.Trace("Session RECONNECT completed successfully.");
                    m_previousServerNonce = m_serverNonce;
                    m_serverNonce = serverNonce;
                    m_reconnecting = false;
                    publishCount = m_subscriptions.Count;
                }

                // refill pipeline.
                for (int ii = 0; ii < publishCount; ii++)
                {
                    BeginPublish(OperationTimeout);
                }

                StartKeepAliveTimer();
            }
            finally
            {
                m_reconnecting = false;
            }
        }


        /// <summary>
        /// Saves all the subscriptions of the session.
        /// </summary>
        /// <param name="filePath">The file path.</param>
        public void Save(string filePath)
        {
            Save(filePath, Subscriptions);
        }

        /// <summary>
        /// Saves a set of subscriptions.
        /// </summary>
        public void Save(string filePath, IEnumerable<Subscription> subscriptions)
        {
            XmlWriterSettings settings = new XmlWriterSettings();

            settings.Indent = true;
            settings.OmitXmlDeclaration = false;
            settings.Encoding = Encoding.UTF8;

            FileStream stream = new FileStream(filePath, FileMode.Create);
            XmlWriter writer = XmlWriter.Create(stream, settings);

            SubscriptionCollection subscriptionList = new SubscriptionCollection(subscriptions);

            try
            {
                DataContractSerializer serializer = new DataContractSerializer(typeof(SubscriptionCollection));
                serializer.WriteObject(writer, subscriptionList);
            }
            finally
            {
                writer.Flush();
                writer.Dispose();
                stream.Dispose();
            }
        }


        /// <summary>
        /// Load the list of subscriptions saved in a file.
        /// </summary>
        /// <param name="filePath">The file path.</param>
        /// <returns>The list of loaded subscriptions</returns>
        public IEnumerable<Subscription> Load(string filePath)
        {
            XmlReaderSettings settings = new XmlReaderSettings();

            settings.ConformanceLevel = ConformanceLevel.Document;
            settings.CloseInput = true;

            XmlReader reader = XmlReader.Create(filePath, settings);

            try
            {
                DataContractSerializer serializer = new DataContractSerializer(typeof(SubscriptionCollection));

                SubscriptionCollection subscriptions = (SubscriptionCollection)serializer.ReadObject(reader);

                foreach (Subscription subscription in subscriptions)
                {
                    AddSubscription(subscription);
                }

                return subscriptions;
            }
            finally
            {
                reader.Dispose();
            }
        }

        /// <summary>
        /// Updates the local copy of the server's namespace uri and server uri tables.
        /// </summary>
        public void FetchNamespaceTables()
        {
            ReadValueIdCollection nodesToRead = new ReadValueIdCollection();

            // request namespace array.
            ReadValueId valueId = new ReadValueId();

            valueId.NodeId = Variables.Server_NamespaceArray;
            valueId.AttributeId = Attributes.Value;

            nodesToRead.Add(valueId);

            // request server array.
            valueId = new ReadValueId();

            valueId.NodeId = Variables.Server_ServerArray;
            valueId.AttributeId = Attributes.Value;

            nodesToRead.Add(valueId);

            // read from server.
            DataValueCollection values = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = this.Read(
                null,
                0,
                TimestampsToReturn.Both,
                nodesToRead,
                out values,
                out diagnosticInfos);

            ValidateResponse(values, nodesToRead);
            ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);

            // validate namespace array.
            ServiceResult result = ValidateDataValue(values[0], typeof(string[]), 0, diagnosticInfos, responseHeader);

            if (ServiceResult.IsBad(result))
            {
                Utils.Trace("FetchNamespaceTables: Cannot read NamespaceArray node: {0} " + result.StatusCode);
            }
            else
            {
                m_namespaceUris.Update((string[])values[0].Value);
            }

            // validate server array.
            result = ValidateDataValue(values[1], typeof(string[]), 1, diagnosticInfos, responseHeader);

            if (ServiceResult.IsBad(result))
            {
                Utils.Trace("FetchNamespaceTables: Cannot read ServerArray node: {0} " + result.StatusCode);
            }
            else
            {
                m_serverUris.Update((string[])values[1].Value);
            }
        }

        /// <summary>
        /// Updates the cache with the type and its subtypes.
        /// </summary>
        /// <remarks>
        /// This method can be used to ensure the TypeTree is populated.
        /// </remarks>
        public void FetchTypeTree(ExpandedNodeId typeId)
        {
            Node node = NodeCache.Find(typeId) as Node;

            if (node != null)
            {
                foreach (IReference reference in node.Find(ReferenceTypeIds.HasSubtype, false))
                {
                    FetchTypeTree(reference.TargetId);
                }
            }
        }

        /// <summary>
        /// Returns the available encodings for a node
        /// </summary>
        /// <param name="variableId">The variable node.</param>
        /// <returns></returns>
        public ReferenceDescriptionCollection ReadAvailableEncodings(NodeId variableId)
        {
            VariableNode variable = NodeCache.Find(variableId) as VariableNode;

            if (variable == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, "NodeId does not refer to a valid variable node.");
            }

            // no encodings available if there was a problem reading the data type for the node.
            if (NodeId.IsNull(variable.DataType))
            {
                return new ReferenceDescriptionCollection();
            }

            // no encodings for non-structures.
            if (!TypeTree.IsTypeOf(variable.DataType, DataTypes.Structure))
            {
                return new ReferenceDescriptionCollection();
            }

            // look for cached values.
            IList<INode> encodings = NodeCache.Find(variableId, ReferenceTypeIds.HasEncoding, false, true);

            if (encodings.Count > 0)
            {
                ReferenceDescriptionCollection references = new ReferenceDescriptionCollection();

                foreach (INode encoding in encodings)
                {
                    ReferenceDescription reference = new ReferenceDescription();

                    reference.ReferenceTypeId = ReferenceTypeIds.HasEncoding;
                    reference.IsForward = true;
                    reference.NodeId = encoding.NodeId;
                    reference.NodeClass = encoding.NodeClass;
                    reference.BrowseName = encoding.BrowseName;
                    reference.DisplayName = encoding.DisplayName;
                    reference.TypeDefinition = encoding.TypeDefinitionId;

                    references.Add(reference);
                }

                return references;
            }

            Browser browser = new Browser(this);

            browser.BrowseDirection = BrowseDirection.Forward;
            browser.ReferenceTypeId = ReferenceTypeIds.HasEncoding;
            browser.IncludeSubtypes = false;
            browser.NodeClassMask = 0;

            return browser.Browse(variable.DataType);
        }


        /// <summary>
        /// Returns the data description for the encoding.
        /// </summary>
        /// <param name="encodingId">The encoding Id.</param>
        /// <returns></returns>
        public ReferenceDescription FindDataDescription(NodeId encodingId)
        {
            Browser browser = new Browser(this);

            browser.BrowseDirection = BrowseDirection.Forward;
            browser.ReferenceTypeId = ReferenceTypeIds.HasDescription;
            browser.IncludeSubtypes = false;
            browser.NodeClassMask = 0;

            ReferenceDescriptionCollection references = browser.Browse(encodingId);

            if (references.Count == 0)
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, "Encoding does not refer to a valid data description.");
            }

            return references[0];
        }


        /// <summary>
        ///  Returns the data dictionary that contains the description.
        /// </summary>
        /// <param name="descriptionId">The description id.</param>
        /// <returns></returns>
        public async Task<DataDictionary> FindDataDictionary(NodeId descriptionId)
        {
            // check if the dictionary has already been loaded.
            foreach (DataDictionary dictionary in m_dictionaries.Values)
            {
                if (dictionary.Contains(descriptionId))
                {
                    return dictionary;
                }
            }

            // find the dictionary for the description.
            Browser browser = new Browser(this);

            browser.BrowseDirection = BrowseDirection.Inverse;
            browser.ReferenceTypeId = ReferenceTypeIds.HasComponent;
            browser.IncludeSubtypes = false;
            browser.NodeClassMask = 0;

            ReferenceDescriptionCollection references = browser.Browse(descriptionId);

            if (references.Count == 0)
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, "Description does not refer to a valid data dictionary.");
            }

            // load the dictionary.
            NodeId dictionaryId = ExpandedNodeId.ToNodeId(references[0].NodeId, m_namespaceUris);

            DataDictionary dictionaryToLoad = new DataDictionary(this);

            await dictionaryToLoad.Load(references[0]);

            m_dictionaries[dictionaryId] = dictionaryToLoad;

            return dictionaryToLoad;
        }

        /// <summary>
        ///  Returns the data dictionary that contains the description.
        /// </summary>
        /// <param name="dictionaryNode">The dictionary id.</param>
        /// <param name="forceReload"></param>
        /// <returns>The dictionary.</returns>
        public async Task<DataDictionary> LoadDataDictionary(ReferenceDescription dictionaryNode, bool forceReload = false)
        {
            // check if the dictionary has already been loaded.
            DataDictionary dictionary;
            NodeId dictionaryId = ExpandedNodeId.ToNodeId(dictionaryNode.NodeId, m_namespaceUris);
            if (!forceReload &&
                m_dictionaries.TryGetValue(dictionaryId, out dictionary))
            {
                return dictionary;
            }

            // load the dictionary.
            DataDictionary dictionaryToLoad = new DataDictionary(this);
            await dictionaryToLoad.Load(dictionaryId, dictionaryNode.ToString());
            m_dictionaries[dictionaryId] = dictionaryToLoad;
            return dictionaryToLoad;
        }

        /// <summary>
        /// Loads all dictionaries of the OPC binary or Xml schema type system.
        /// </summary>
        /// <param name="dataTypeSystem">The type system.</param>
        /// <returns></returns>
        public async Task<Dictionary<NodeId, DataDictionary>> LoadDataTypeSystem(NodeId dataTypeSystem = null)
        {
            if (dataTypeSystem == null)
            {
                dataTypeSystem = ObjectIds.OPCBinarySchema_TypeSystem;
            }
            else
            if (!Utils.Equals(dataTypeSystem, ObjectIds.OPCBinarySchema_TypeSystem) &&
                !Utils.Equals(dataTypeSystem, ObjectIds.XmlSchema_TypeSystem))
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, $"{nameof(dataTypeSystem)} does not refer to a valid data dictionary.");
            }

            // find the dictionary for the description.
            Browser browser = new Browser(this);

            browser.BrowseDirection = BrowseDirection.Forward;
            browser.ReferenceTypeId = ReferenceTypeIds.HasComponent;
            browser.IncludeSubtypes = false;
            browser.NodeClassMask = 0;

            ReferenceDescriptionCollection references = browser.Browse(dataTypeSystem);

            if (references.Count == 0)
            {
                throw ServiceResultException.Create(StatusCodes.BadNodeIdInvalid, "Type system does not contain a valid data dictionary.");
            }

            // read all type dictionaries in the type system
            foreach (var r in references)
            {
                DataDictionary dictionaryToLoad = null;
                NodeId dictionaryId = ExpandedNodeId.ToNodeId(r.NodeId, m_namespaceUris);
                if (dictionaryId.NamespaceIndex != 0 &&
                    !m_dictionaries.TryGetValue(dictionaryId, out dictionaryToLoad))
                {
                    try
                    {
                        dictionaryToLoad = new DataDictionary(this);
                        await dictionaryToLoad.Load(r);
                        m_dictionaries[dictionaryId] = dictionaryToLoad;
                    }
                    catch (Exception ex)
                    {
                        Utils.Trace("Dictionary load error for Dictionary {0} : {1}", r.NodeId, ex.Message);
                    }
                }
            }

            return m_dictionaries;
        }

        /// <summary>
        /// Reads the values for the node attributes and returns a node object.
        /// </summary>
        /// <param name="nodeId">The nodeId.</param>
        /// <returns></returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmaintainableCode"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
        public Node ReadNode(NodeId nodeId)
        {
            // build list of attributes.
            var attributes = new SortedDictionary<uint, DataValue> {
                { Attributes.NodeId, null },
                { Attributes.NodeClass, null },
                { Attributes.BrowseName, null },
                { Attributes.DisplayName, null },
                { Attributes.Description, null },
                { Attributes.WriteMask, null },
                { Attributes.UserWriteMask, null },
                { Attributes.DataType, null },
                { Attributes.ValueRank, null },
                { Attributes.ArrayDimensions, null },
                { Attributes.AccessLevel, null },
                { Attributes.UserAccessLevel, null },
                { Attributes.Historizing, null },
                { Attributes.MinimumSamplingInterval, null },
                { Attributes.EventNotifier, null },
                { Attributes.Executable, null },
                { Attributes.UserExecutable, null },
                { Attributes.IsAbstract, null },
                { Attributes.InverseName, null },
                { Attributes.Symmetric, null },
                { Attributes.ContainsNoLoops, null },
                { Attributes.DataTypeDefinition, null },
                { Attributes.RolePermissions, null },
                { Attributes.UserRolePermissions, null },
                { Attributes.AccessRestrictions, null },
                { Attributes.AccessLevelEx, null }
            };

            // build list of values to read.
            ReadValueIdCollection itemsToRead = new ReadValueIdCollection();

            foreach (uint attributeId in attributes.Keys)
            {
                ReadValueId itemToRead = new ReadValueId();

                itemToRead.NodeId = nodeId;
                itemToRead.AttributeId = attributeId;

                itemsToRead.Add(itemToRead);
            }

            // read from server.
            DataValueCollection values = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = Read(
                null,
                0,
                TimestampsToReturn.Neither,
                itemsToRead,
                out values,
                out diagnosticInfos);

            ClientBase.ValidateResponse(values, itemsToRead);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, itemsToRead);

            // process results.
            int? nodeClass = null;

            for (int ii = 0; ii < itemsToRead.Count; ii++)
            {
                uint attributeId = itemsToRead[ii].AttributeId;

                // the node probably does not exist if the node class is not found.
                if (attributeId == Attributes.NodeClass)
                {
                    if (!DataValue.IsGood(values[ii]))
                    {
                        throw ServiceResultException.Create(values[ii].StatusCode, ii, diagnosticInfos, responseHeader.StringTable);
                    }

                    // check for valid node class.
                    nodeClass = values[ii].Value as int?;

                    if (nodeClass == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Node does not have a valid value for NodeClass: {0}.", values[ii].Value);
                    }
                }
                else
                {
                    if (!DataValue.IsGood(values[ii]))
                    {
                        // check for unsupported attributes.
                        if (values[ii].StatusCode == StatusCodes.BadAttributeIdInvalid)
                        {
                            continue;
                        }

                        // ignore errors on optional attributes 
                        if (StatusCode.IsBad(values[ii].StatusCode))
                        {
                            if (attributeId == Attributes.AccessRestrictions ||
                                attributeId == Attributes.Description ||
                                attributeId == Attributes.RolePermissions ||
                                attributeId == Attributes.UserRolePermissions ||
                                attributeId == Attributes.UserWriteMask ||
                                attributeId == Attributes.WriteMask)
                            {
                                continue;
                            }
                        }

                        // all supported attributes must be readable.
                        if (attributeId != Attributes.Value)
                        {
                            throw ServiceResultException.Create(values[ii].StatusCode, ii, diagnosticInfos, responseHeader.StringTable);
                        }
                    }
                }

                attributes[attributeId] = values[ii];
            }

            Node node = null;
            DataValue value = null;

            switch ((NodeClass)nodeClass.Value)
            {
                default:
                {
                    throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Node does not have a valid value for NodeClass: {0}.", nodeClass.Value);
                }

                case NodeClass.Object:
                {
                    ObjectNode objectNode = new ObjectNode();

                    value = attributes[Attributes.EventNotifier];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Object does not support the EventNotifier attribute.");
                    }

                    objectNode.EventNotifier = (byte)attributes[Attributes.EventNotifier].GetValue(typeof(byte));
                    node = objectNode;
                    break;
                }

                case NodeClass.ObjectType:
                {
                    ObjectTypeNode objectTypeNode = new ObjectTypeNode();

                    value = attributes[Attributes.IsAbstract];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "ObjectType does not support the IsAbstract attribute.");
                    }

                    objectTypeNode.IsAbstract = (bool)attributes[Attributes.IsAbstract].GetValue(typeof(bool));
                    node = objectTypeNode;
                    break;
                }

                case NodeClass.Variable:
                {
                    VariableNode variableNode = new VariableNode();

                    // DataType Attribute
                    value = attributes[Attributes.DataType];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Variable does not support the DataType attribute.");
                    }

                    variableNode.DataType = (NodeId)attributes[Attributes.DataType].GetValue(typeof(NodeId));

                    // ValueRank Attribute
                    value = attributes[Attributes.ValueRank];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Variable does not support the ValueRank attribute.");
                    }

                    variableNode.ValueRank = (int)attributes[Attributes.ValueRank].GetValue(typeof(int));

                    // ArrayDimensions Attribute
                    value = attributes[Attributes.ArrayDimensions];

                    if (value != null)
                    {
                        if (value.Value == null)
                        {
                            variableNode.ArrayDimensions = new uint[0];
                        }
                        else
                        {
                            variableNode.ArrayDimensions = (uint[])value.GetValue(typeof(uint[]));
                        }
                    }

                    // AccessLevel Attribute
                    value = attributes[Attributes.AccessLevel];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Variable does not support the AccessLevel attribute.");
                    }

                    variableNode.AccessLevel = (byte)attributes[Attributes.AccessLevel].GetValue(typeof(byte));

                    // UserAccessLevel Attribute
                    value = attributes[Attributes.UserAccessLevel];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Variable does not support the UserAccessLevel attribute.");
                    }

                    variableNode.UserAccessLevel = (byte)attributes[Attributes.UserAccessLevel].GetValue(typeof(byte));

                    // Historizing Attribute
                    value = attributes[Attributes.Historizing];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Variable does not support the Historizing attribute.");
                    }

                    variableNode.Historizing = (bool)attributes[Attributes.Historizing].GetValue(typeof(bool));

                    // MinimumSamplingInterval Attribute
                    value = attributes[Attributes.MinimumSamplingInterval];

                    if (value != null)
                    {
                        variableNode.MinimumSamplingInterval = Convert.ToDouble(attributes[Attributes.MinimumSamplingInterval].Value);
                    }

                    // AccessLevelEx Attribute
                    value = attributes[Attributes.AccessLevelEx];

                    if (value != null)
                    {
                        variableNode.AccessLevelEx = (uint)attributes[Attributes.AccessLevelEx].GetValue(typeof(uint));
                    }

                    node = variableNode;
                    break;
                }

                case NodeClass.VariableType:
                {
                    VariableTypeNode variableTypeNode = new VariableTypeNode();

                    // IsAbstract Attribute
                    value = attributes[Attributes.IsAbstract];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "VariableType does not support the IsAbstract attribute.");
                    }

                    variableTypeNode.IsAbstract = (bool)attributes[Attributes.IsAbstract].GetValue(typeof(bool));

                    // DataType Attribute
                    value = attributes[Attributes.DataType];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "VariableType does not support the DataType attribute.");
                    }

                    variableTypeNode.DataType = (NodeId)attributes[Attributes.DataType].GetValue(typeof(NodeId));

                    // ValueRank Attribute
                    value = attributes[Attributes.ValueRank];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "VariableType does not support the ValueRank attribute.");
                    }

                    variableTypeNode.ValueRank = (int)attributes[Attributes.ValueRank].GetValue(typeof(int));

                    // ArrayDimensions Attribute
                    value = attributes[Attributes.ArrayDimensions];

                    if (value?.Value != null)
                    {
                        variableTypeNode.ArrayDimensions = (uint[])attributes[Attributes.ArrayDimensions].GetValue(typeof(uint[]));
                    }

                    node = variableTypeNode;
                    break;
                }

                case NodeClass.Method:
                {
                    MethodNode methodNode = new MethodNode();

                    // Executable Attribute
                    value = attributes[Attributes.Executable];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Method does not support the Executable attribute.");
                    }

                    methodNode.Executable = (bool)attributes[Attributes.Executable].GetValue(typeof(bool));

                    // UserExecutable Attribute
                    value = attributes[Attributes.UserExecutable];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Method does not support the UserExecutable attribute.");
                    }

                    methodNode.UserExecutable = (bool)attributes[Attributes.UserExecutable].GetValue(typeof(bool));

                    node = methodNode;
                    break;
                }

                case NodeClass.DataType:
                {
                    DataTypeNode dataTypeNode = new DataTypeNode();

                    // IsAbstract Attribute
                    value = attributes[Attributes.IsAbstract];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "DataType does not support the IsAbstract attribute.");
                    }

                    dataTypeNode.IsAbstract = (bool)attributes[Attributes.IsAbstract].GetValue(typeof(bool));

                    // DataTypeDefinition Attribute
                    value = attributes[Attributes.DataTypeDefinition];

                    if (value != null)
                    {
                        dataTypeNode.DataTypeDefinition = value.Value as ExtensionObject;
                    }

                    node = dataTypeNode;
                    break;
                }

                case NodeClass.ReferenceType:
                {
                    ReferenceTypeNode referenceTypeNode = new ReferenceTypeNode();

                    // IsAbstract Attribute
                    value = attributes[Attributes.IsAbstract];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "ReferenceType does not support the IsAbstract attribute.");
                    }

                    referenceTypeNode.IsAbstract = (bool)attributes[Attributes.IsAbstract].GetValue(typeof(bool));

                    // Symmetric Attribute
                    value = attributes[Attributes.Symmetric];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "ReferenceType does not support the Symmetric attribute.");
                    }

                    referenceTypeNode.Symmetric = (bool)attributes[Attributes.IsAbstract].GetValue(typeof(bool));

                    // InverseName Attribute
                    value = attributes[Attributes.InverseName];

                    if (value?.Value != null)
                    {
                        referenceTypeNode.InverseName = (LocalizedText)attributes[Attributes.InverseName].GetValue(typeof(LocalizedText));
                    }

                    node = referenceTypeNode;
                    break;
                }

                case NodeClass.View:
                {
                    ViewNode viewNode = new ViewNode();

                    // EventNotifier Attribute
                    value = attributes[Attributes.EventNotifier];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "View does not support the EventNotifier attribute.");
                    }

                    viewNode.EventNotifier = (byte)attributes[Attributes.EventNotifier].GetValue(typeof(byte));

                    // ContainsNoLoops Attribute
                    value = attributes[Attributes.ContainsNoLoops];

                    if (value == null)
                    {
                        throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "View does not support the ContainsNoLoops attribute.");
                    }

                    viewNode.ContainsNoLoops = (bool)attributes[Attributes.ContainsNoLoops].GetValue(typeof(bool));

                    node = viewNode;
                    break;
                }
            }

            // NodeId Attribute
            value = attributes[Attributes.NodeId];

            if (value == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Node does not support the NodeId attribute.");
            }

            node.NodeId = (NodeId)attributes[Attributes.NodeId].GetValue(typeof(NodeId));
            node.NodeClass = (NodeClass)nodeClass.Value;

            // BrowseName Attribute
            value = attributes[Attributes.BrowseName];

            if (value == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Node does not support the BrowseName attribute.");
            }

            node.BrowseName = (QualifiedName)attributes[Attributes.BrowseName].GetValue(typeof(QualifiedName));

            // DisplayName Attribute
            value = attributes[Attributes.DisplayName];

            if (value == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadUnexpectedError, "Node does not support the DisplayName attribute.");
            }

            node.DisplayName = (LocalizedText)attributes[Attributes.DisplayName].GetValue(typeof(LocalizedText));

            // all optional attributes follow

            // Description Attribute
            if (attributes.TryGetValue(Attributes.Description, out value) &&
                value != null && value.Value != null)
            {
                node.Description = (LocalizedText)value.GetValue(typeof(LocalizedText));
            }

            // WriteMask Attribute
            if (attributes.TryGetValue(Attributes.WriteMask, out value) &&
                value != null)
            {
                node.WriteMask = (uint)value.GetValue(typeof(uint));
            }

            // UserWriteMask Attribute
            if (attributes.TryGetValue(Attributes.UserWriteMask, out value) &&
                value != null)
            {
                node.UserWriteMask = (uint)value.GetValue(typeof(uint));
            }

            // RolePermissions Attribute
            if (attributes.TryGetValue(Attributes.RolePermissions, out value) &&
                value != null)
            {
                ExtensionObject[] rolePermissions = value.Value as ExtensionObject[];

                if (rolePermissions != null)
                {
                    node.RolePermissions = new RolePermissionTypeCollection();

                    foreach (ExtensionObject rolePermission in rolePermissions)
                    {
                        node.RolePermissions.Add(rolePermission.Body as RolePermissionType);
                    }
                }
            }

            // UserRolePermissions Attribute
            if (attributes.TryGetValue(Attributes.UserRolePermissions, out value) &&
                value != null)
            {
                ExtensionObject[] userRolePermissions = value.Value as ExtensionObject[];

                if (userRolePermissions != null)
                {
                    node.UserRolePermissions = new RolePermissionTypeCollection();

                    foreach (ExtensionObject rolePermission in userRolePermissions)
                    {
                        node.UserRolePermissions.Add(rolePermission.Body as RolePermissionType);
                    }
                }
            }

            // AccessRestrictions Attribute
            if (attributes.TryGetValue(Attributes.AccessRestrictions, out value) &&
                value != null)
            {
                node.AccessRestrictions = (ushort)value.GetValue(typeof(ushort));
            }

            return node;
        }

        /// <summary>
        /// Reads the value for a node.
        /// </summary>
        /// <param name="nodeId">The node Id.</param>
        /// <returns></returns>
        public DataValue ReadValue(NodeId nodeId)
        {
            ReadValueId itemToRead = new ReadValueId();

            itemToRead.NodeId = nodeId;
            itemToRead.AttributeId = Attributes.Value;

            ReadValueIdCollection itemsToRead = new ReadValueIdCollection();
            itemsToRead.Add(itemToRead);

            // read from server.
            DataValueCollection values = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = Read(
                null,
                0,
                TimestampsToReturn.Both,
                itemsToRead,
                out values,
                out diagnosticInfos);

            ClientBase.ValidateResponse(values, itemsToRead);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, itemsToRead);

            if (StatusCode.IsBad(values[0].StatusCode))
            {
                ServiceResult result = ClientBase.GetResult(values[0].StatusCode, 0, diagnosticInfos, responseHeader);
                throw new ServiceResultException(result);
            }

            return values[0];
        }

        /// <summary>
        /// Reads the value for a node an checks that it is the specified type.
        /// </summary>
        /// <param name="nodeId">The node id.</param>
        /// <param name="expectedType">The expected type.</param>
        /// <returns></returns>
        public object ReadValue(NodeId nodeId, Type expectedType)
        {
            DataValue dataValue = ReadValue(nodeId);

            object value = dataValue.Value;

            if (expectedType != null)
            {
                ExtensionObject extension = value as ExtensionObject;

                if (extension != null)
                {
                    value = extension.Body;
                }

                if (!expectedType.IsInstanceOfType(value))
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadTypeMismatch,
                        "Server returned value unexpected type: {0}",
                        (value != null) ? value.GetType().Name : "(null)");
                }
            }

            return value;
        }


        /// <summary>
        /// Fetches all references for the specified node.
        /// </summary>
        /// <param name="nodeId">The node id.</param>
        /// <returns></returns>
        public ReferenceDescriptionCollection FetchReferences(NodeId nodeId)
        {
            // browse for all references.
            byte[] continuationPoint;
            ReferenceDescriptionCollection descriptions;

            Browse(
                null,
                null,
                nodeId,
                0,
                BrowseDirection.Both,
                null,
                true,
                0,
                out continuationPoint,
                out descriptions);

            // process any continuation point.
            while (continuationPoint != null)
            {
                byte[] revisedContinuationPoint;
                ReferenceDescriptionCollection additionalDescriptions;

                BrowseNext(
                    null,
                    false,
                    continuationPoint,
                    out revisedContinuationPoint,
                    out additionalDescriptions);

                continuationPoint = revisedContinuationPoint;

                descriptions.AddRange(additionalDescriptions);
            }

            return descriptions;
        }

        /// <summary>
        /// Establishes a session with the server.
        /// </summary>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="identity">The user identity.</param>
        public void Open(
            string sessionName,
            IUserIdentity identity)
        {
            Open(sessionName, 0, identity, null);
        }

        /// <summary>
        /// Establishes a session with the server.
        /// </summary>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The session timeout.</param>
        /// <param name="identity">The user identity.</param>
        /// <param name="preferredLocales">The list of preferred locales.</param>
        public void Open(
            string sessionName,
            uint sessionTimeout,
            IUserIdentity identity,
            IList<string> preferredLocales)
        {
            Open(sessionName, sessionTimeout, identity, preferredLocales, true);
        }

        /// <summary>
        /// Establishes a session with the server.
        /// </summary>
        /// <param name="sessionName">The name to assign to the session.</param>
        /// <param name="sessionTimeout">The session timeout.</param>
        /// <param name="identity">The user identity.</param>
        /// <param name="preferredLocales">The list of preferred locales.</param>
        /// <param name="checkDomain">If set to <c>true</c> then the domain in the certificate must match the endpoint used.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
        public void Open(
            string sessionName,
            uint sessionTimeout,
            IUserIdentity identity,
            IList<string> preferredLocales,
            bool checkDomain)
        {
            // check connection state.
            lock (SyncRoot)
            {
                if (Connected)
                {
                    throw new ServiceResultException(StatusCodes.BadInvalidState, "Already connected to server.");
                }
            }

            string securityPolicyUri = m_endpoint.Description.SecurityPolicyUri;

            // catch security policies which are not supported by core
            if (SecurityPolicies.GetDisplayName(securityPolicyUri) == null)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadSecurityChecksFailed,
                    "The chosen security policy is not supported by the client to connect to the server.");
            }

            // get the identity token.
            if (identity == null)
            {
                identity = new UserIdentity();
            }

            // get identity token.
            UserIdentityToken identityToken = identity.GetIdentityToken();

            // check that the user identity is supported by the endpoint.
            UserTokenPolicy identityPolicy = m_endpoint.Description.FindUserTokenPolicy(identityToken.PolicyId);

            if (identityPolicy == null)
            {
                // try looking up by TokenType if the policy id was not found.
                identityPolicy = m_endpoint.Description.FindUserTokenPolicy(identity.TokenType, identity.IssuedTokenType);

                if (identityPolicy == null)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadUserAccessDenied,
                        "Endpoint does not support the user identity type provided.");
                }

                identityToken.PolicyId = identityPolicy.PolicyId;
            }

            bool requireEncryption = securityPolicyUri != SecurityPolicies.None;
            if (!requireEncryption)
            {
                requireEncryption = identityPolicy.SecurityPolicyUri != SecurityPolicies.None;
            }

            // validate the server certificate /certificate chain.
            X509Certificate2 serverCertificate = null;
            byte[] certificateData = m_endpoint.Description.ServerCertificate;

            if (certificateData != null && certificateData.Length > 0)
            {
                X509Certificate2Collection serverCertificateChain = Utils.ParseCertificateChainBlob(certificateData);

                if (serverCertificateChain.Count > 0)
                {
                    serverCertificate = serverCertificateChain[0];
                }

                if (requireEncryption)
                {
                    if (checkDomain)
                    {
                        m_configuration.CertificateValidator.Validate(serverCertificateChain, m_endpoint);
                    }
                    else
                    {
                        m_configuration.CertificateValidator.Validate(serverCertificateChain);
                    }
                    // save for reconnect
                    m_checkDomain = checkDomain;
                }
            }

            // create a nonce.
            uint length = (uint)m_configuration.SecurityConfiguration.NonceLength;
            byte[] clientNonce = Utils.Nonce.CreateNonce(length);
            NodeId sessionId = null;
            NodeId sessionCookie = null;
            byte[] serverNonce = new byte[0];
            byte[] serverCertificateData = new byte[0];
            SignatureData serverSignature = null;
            EndpointDescriptionCollection serverEndpoints = null;
            SignedSoftwareCertificateCollection serverSoftwareCertificates = null;

            // send the application instance certificate for the client.
            byte[] clientCertificateData = m_instanceCertificate != null ? m_instanceCertificate.RawData : null;
            byte[] clientCertificateChainData = null;

            if (m_instanceCertificateChain != null && m_instanceCertificateChain.Count > 0 && m_configuration.SecurityConfiguration.SendCertificateChain)
            {
                List<byte> clientCertificateChain = new List<byte>();

                for (int i = 0; i < m_instanceCertificateChain.Count; i++)
                {
                    clientCertificateChain.AddRange(m_instanceCertificateChain[i].RawData);
                }

                clientCertificateChainData = clientCertificateChain.ToArray();
            }

            ApplicationDescription clientDescription = new ApplicationDescription();

            clientDescription.ApplicationUri = m_configuration.ApplicationUri;
            clientDescription.ApplicationName = m_configuration.ApplicationName;
            clientDescription.ApplicationType = ApplicationType.Client;
            clientDescription.ProductUri = m_configuration.ProductUri;

            if (sessionTimeout == 0)
            {
                sessionTimeout = (uint)m_configuration.ClientConfiguration.DefaultSessionTimeout;
            }

            bool successCreateSession = false;
            //if security none, first try to connect without certificate
            if (m_endpoint.Description.SecurityPolicyUri == SecurityPolicies.None)
            {
                //first try to connect with client certificate NULL
                try
                {
                    CreateSession(
                        null,
                        clientDescription,
                        m_endpoint.Description.Server.ApplicationUri,
                        m_endpoint.EndpointUrl.ToString(),
                        sessionName,
                        clientNonce,
                        null,
                        sessionTimeout,
                        (uint)MessageContext.MaxMessageSize,
                        out sessionId,
                        out sessionCookie,
                        out m_sessionTimeout,
                        out serverNonce,
                        out serverCertificateData,
                        out serverEndpoints,
                        out serverSoftwareCertificates,
                        out serverSignature,
                        out m_maxRequestMessageSize);

                    successCreateSession = true;
                }
                catch (Exception ex)
                {
                    Utils.Trace("Create session failed with client certificate NULL. " + ex.Message);
                    successCreateSession = false;
                }
            }

            if (!successCreateSession)
            {
                CreateSession(
                        null,
                        clientDescription,
                        m_endpoint.Description.Server.ApplicationUri,
                        m_endpoint.EndpointUrl.ToString(),
                        sessionName,
                        clientNonce,
                        clientCertificateChainData != null ? clientCertificateChainData : clientCertificateData,
                        sessionTimeout,
                        (uint)MessageContext.MaxMessageSize,
                        out sessionId,
                        out sessionCookie,
                        out m_sessionTimeout,
                        out serverNonce,
                        out serverCertificateData,
                        out serverEndpoints,
                        out serverSoftwareCertificates,
                        out serverSignature,
                        out m_maxRequestMessageSize);
            }
            // save session id.
            lock (SyncRoot)
            {
                base.SessionCreated(sessionId, sessionCookie);
            }

            Utils.Trace("Revised session timeout value: {0}. ", m_sessionTimeout);
            Utils.Trace("Max response message size value: {0}. Max request message size: {1} ", MessageContext.MaxMessageSize, m_maxRequestMessageSize);

            //we need to call CloseSession if CreateSession was successful but some other exception is thrown
            try
            {
                // verify that the server returned the same instance certificate.
                if (serverCertificateData != null &&
                    m_endpoint.Description.ServerCertificate != null &&
                    !Utils.IsEqual(serverCertificateData, m_endpoint.Description.ServerCertificate))
                {
                    try
                    {
                        // verify for certificate chain in endpoint.
                        X509Certificate2Collection serverCertificateChain = Utils.ParseCertificateChainBlob(m_endpoint.Description.ServerCertificate);

                        if (serverCertificateChain.Count > 0 && !Utils.IsEqual(serverCertificateData, serverCertificateChain[0].RawData))
                        {
                            throw ServiceResultException.Create(
                                        StatusCodes.BadCertificateInvalid,
                                        "Server did not return the certificate used to create the secure channel.");
                        }
                    }
                    catch (Exception)
                    {
                        throw ServiceResultException.Create(
                                StatusCodes.BadCertificateInvalid,
                                "Server did not return the certificate used to create the secure channel.");
                    }
                }

                if (serverSignature == null || serverSignature.Signature == null)
                {
                    Utils.Trace("Server signature is null or empty.");

                    //throw ServiceResultException.Create(
                    //    StatusCodes.BadSecurityChecksFailed,
                    //    "Server signature is null or empty.");
                }

                if (m_discoveryServerEndpoints != null && m_discoveryServerEndpoints.Count > 0)
                {
                    // Compare EndpointDescriptions returned at GetEndpoints with values returned at CreateSession
                    EndpointDescriptionCollection expectedServerEndpoints = null;

                    if (serverEndpoints != null &&
                        m_discoveryProfileUris != null && m_discoveryProfileUris.Count > 0)
                    {
                        // Select EndpointDescriptions with a transportProfileUri that matches the
                        // profileUris specified in the original GetEndpoints() request.
                        expectedServerEndpoints = new EndpointDescriptionCollection();

                        foreach (EndpointDescription serverEndpoint in serverEndpoints)
                        {
                            if (m_discoveryProfileUris.Contains(serverEndpoint.TransportProfileUri))
                            {
                                expectedServerEndpoints.Add(serverEndpoint);
                            }
                        }
                    }
                    else
                    {
                        expectedServerEndpoints = serverEndpoints;
                    }

                    if (expectedServerEndpoints == null ||
                        m_discoveryServerEndpoints.Count != expectedServerEndpoints.Count)
                    {
                        throw ServiceResultException.Create(
                            StatusCodes.BadSecurityChecksFailed,
                            "Server did not return a number of ServerEndpoints that matches the one from GetEndpoints.");
                    }

                    for (int ii = 0; ii < expectedServerEndpoints.Count; ii++)
                    {
                        EndpointDescription serverEndpoint = expectedServerEndpoints[ii];
                        EndpointDescription expectedServerEndpoint = m_discoveryServerEndpoints[ii];

                        if (serverEndpoint.SecurityMode != expectedServerEndpoint.SecurityMode ||
                            serverEndpoint.SecurityPolicyUri != expectedServerEndpoint.SecurityPolicyUri ||
                            serverEndpoint.TransportProfileUri != expectedServerEndpoint.TransportProfileUri ||
                            serverEndpoint.SecurityLevel != expectedServerEndpoint.SecurityLevel)
                        {
                            throw ServiceResultException.Create(
                                StatusCodes.BadSecurityChecksFailed,
                                "The list of ServerEndpoints returned at CreateSession does not match the list from GetEndpoints.");
                        }

                        if (serverEndpoint.UserIdentityTokens.Count != expectedServerEndpoint.UserIdentityTokens.Count)
                        {
                            throw ServiceResultException.Create(
                                StatusCodes.BadSecurityChecksFailed,
                                "The list of ServerEndpoints returned at CreateSession does not match the one from GetEndpoints.");
                        }

                        for (int jj = 0; jj < serverEndpoint.UserIdentityTokens.Count; jj++)
                        {
                            if (!serverEndpoint.UserIdentityTokens[jj].IsEqual(expectedServerEndpoint.UserIdentityTokens[jj]))
                            {
                                throw ServiceResultException.Create(
                                StatusCodes.BadSecurityChecksFailed,
                                "The list of ServerEndpoints returned at CreateSession does not match the one from GetEndpoints.");
                            }
                        }
                    }
                }

                // find the matching description (TBD - check domains against certificate).
                bool found = false;
                Uri expectedUrl = Utils.ParseUri(m_endpoint.Description.EndpointUrl);

                if (expectedUrl != null)
                {
                    for (int ii = 0; ii < serverEndpoints.Count; ii++)
                    {
                        EndpointDescription serverEndpoint = serverEndpoints[ii];
                        Uri actualUrl = Utils.ParseUri(serverEndpoint.EndpointUrl);

                        if (actualUrl != null && actualUrl.Scheme == expectedUrl.Scheme)
                        {
                            if (serverEndpoint.SecurityPolicyUri == m_endpoint.Description.SecurityPolicyUri)
                            {
                                if (serverEndpoint.SecurityMode == m_endpoint.Description.SecurityMode)
                                {
                                    // ensure endpoint has up to date information.
                                    m_endpoint.Description.Server.ApplicationName = serverEndpoint.Server.ApplicationName;
                                    m_endpoint.Description.Server.ApplicationUri = serverEndpoint.Server.ApplicationUri;
                                    m_endpoint.Description.Server.ApplicationType = serverEndpoint.Server.ApplicationType;
                                    m_endpoint.Description.Server.ProductUri = serverEndpoint.Server.ProductUri;
                                    m_endpoint.Description.TransportProfileUri = serverEndpoint.TransportProfileUri;
                                    m_endpoint.Description.UserIdentityTokens = serverEndpoint.UserIdentityTokens;

                                    found = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                // could be a security risk.
                if (!found)
                {
                    throw ServiceResultException.Create(
                        StatusCodes.BadSecurityChecksFailed,
                        "Server did not return an EndpointDescription that matched the one used to create the secure channel.");
                }

                // validate the server's signature.
                byte[] dataToSign = Utils.Append(clientCertificateData, clientNonce);

                if (!SecurityPolicies.Verify(serverCertificate, m_endpoint.Description.SecurityPolicyUri, dataToSign, serverSignature))
                {
                    // validate the signature with complete chain if the check with leaf certificate failed.
                    if (clientCertificateChainData != null)
                    {
                        dataToSign = Utils.Append(clientCertificateChainData, clientNonce);

                        if (!SecurityPolicies.Verify(serverCertificate, m_endpoint.Description.SecurityPolicyUri, dataToSign, serverSignature))
                        {
                            throw ServiceResultException.Create(
                                StatusCodes.BadApplicationSignatureInvalid,
                                "Server did not provide a correct signature for the nonce data provided by the client.");
                        }
                    }
                    else
                    {
                        throw ServiceResultException.Create(
                           StatusCodes.BadApplicationSignatureInvalid,
                           "Server did not provide a correct signature for the nonce data provided by the client.");
                    }
                }

                // get a validator to check certificates provided by server.
                CertificateValidator validator = m_configuration.CertificateValidator;

                // validate software certificates.
                List<SoftwareCertificate> softwareCertificates = new List<SoftwareCertificate>();

                foreach (SignedSoftwareCertificate signedCertificate in serverSoftwareCertificates)
                {
                    SoftwareCertificate softwareCertificate = null;

                    ServiceResult result = SoftwareCertificate.Validate(
                        validator,
                        signedCertificate.CertificateData,
                        out softwareCertificate);

                    if (ServiceResult.IsBad(result))
                    {
                        OnSoftwareCertificateError(signedCertificate, result);
                    }

                    softwareCertificates.Add(softwareCertificate);
                }

                // check if software certificates meet application requirements.
                ValidateSoftwareCertificates(softwareCertificates);

                // create the client signature.
                dataToSign = Utils.Append(serverCertificate != null ? serverCertificate.RawData : null, serverNonce);
                SignatureData clientSignature = SecurityPolicies.Sign(m_instanceCertificate, securityPolicyUri, dataToSign);

                // select the security policy for the user token.
                securityPolicyUri = identityPolicy.SecurityPolicyUri;

                if (String.IsNullOrEmpty(securityPolicyUri))
                {
                    securityPolicyUri = m_endpoint.Description.SecurityPolicyUri;
                }

                byte[] previousServerNonce = null;

                if (TransportChannel.CurrentToken != null)
                {
                    previousServerNonce = TransportChannel.CurrentToken.ServerNonce;
                }

                // validate server nonce and security parameters for user identity.
                ValidateServerNonce(
                    identity,
                    serverNonce,
                    securityPolicyUri,
                    previousServerNonce,
                    m_endpoint.Description.SecurityMode);

                // sign data with user token.
                SignatureData userTokenSignature = identityToken.Sign(dataToSign, securityPolicyUri);

                // encrypt token.
                identityToken.Encrypt(serverCertificate, serverNonce, securityPolicyUri);

                // send the software certificates assigned to the client.
                SignedSoftwareCertificateCollection clientSoftwareCertificates = GetSoftwareCertificates();

                // copy the preferred locales if provided.
                if (preferredLocales != null && preferredLocales.Count > 0)
                {
                    m_preferredLocales = new StringCollection(preferredLocales);
                }

                StatusCodeCollection certificateResults = null;
                DiagnosticInfoCollection certificateDiagnosticInfos = null;

                // activate session.
                ActivateSession(
                    null,
                    clientSignature,
                    clientSoftwareCertificates,
                    m_preferredLocales,
                    new ExtensionObject(identityToken),
                    userTokenSignature,
                    out serverNonce,
                    out certificateResults,
                    out certificateDiagnosticInfos);

                if (certificateResults != null)
                {
                    for (int i = 0; i < certificateResults.Count; i++)
                    {
                        Utils.Trace("ActivateSession result[{0}] = {1}", i, certificateResults[i]);
                    }
                }

                if (certificateResults == null || certificateResults.Count == 0)
                {
                    Utils.Trace("Empty results were received for the ActivateSession call.");
                }

                // fetch namespaces.
                FetchNamespaceTables();

                lock (SyncRoot)
                {
                    // save nonces.
                    m_sessionName = sessionName;
                    m_identity = identity;
                    m_previousServerNonce = previousServerNonce;
                    m_serverNonce = serverNonce;
                    m_serverCertificate = serverCertificate;

                    // update system context.
                    m_systemContext.PreferredLocales = m_preferredLocales;
                    m_systemContext.SessionId = this.SessionId;
                    m_systemContext.UserIdentity = identity;
                }

                // start keep alive thread.
                StartKeepAliveTimer();
            }
            catch (Exception)
            {
                try
                {
                    CloseSession(null, false);
                    CloseChannel();
                }
                catch (Exception e)
                {
                    Utils.Trace("Cleanup: CloseSession() or CloseChannel() raised exception. " + e.Message);
                }
                finally
                {
                    SessionCreated(null, null);
                }

                throw;
            }
        }

        /// <summary>
        /// Updates the preferred locales used for the session.
        /// </summary>
        /// <param name="preferredLocales">The preferred locales.</param>
        public void ChangePreferredLocales(StringCollection preferredLocales)
        {
            UpdateSession(Identity, preferredLocales);
        }

        /// <summary>
        /// Updates the user identity and/or locales used for the session.
        /// </summary>
        /// <param name="identity">The user identity.</param>
        /// <param name="preferredLocales">The preferred locales.</param>
        public void UpdateSession(IUserIdentity identity, StringCollection preferredLocales)
        {
            byte[] serverNonce = null;

            lock (SyncRoot)
            {
                // check connection state.
                if (!Connected)
                {
                    throw new ServiceResultException(StatusCodes.BadInvalidState, "Not connected to server.");
                }

                // get current nonce.
                serverNonce = m_serverNonce;

                if (preferredLocales == null)
                {
                    preferredLocales = m_preferredLocales;
                }
            }

            // get the identity token.
            UserIdentityToken identityToken = null;
            SignatureData userTokenSignature = null;

            string securityPolicyUri = m_endpoint.Description.SecurityPolicyUri;

            // create the client signature.
            byte[] dataToSign = Utils.Append(m_serverCertificate != null ? m_serverCertificate.RawData : null, serverNonce);
            SignatureData clientSignature = SecurityPolicies.Sign(m_instanceCertificate, securityPolicyUri, dataToSign);

            // choose a default token.
            if (identity == null)
            {
                identity = new UserIdentity();
            }

            // check that the user identity is supported by the endpoint.
            UserTokenPolicy identityPolicy = m_endpoint.Description.FindUserTokenPolicy(identity.TokenType, identity.IssuedTokenType);

            if (identityPolicy == null)
            {
                throw ServiceResultException.Create(
                    StatusCodes.BadUserAccessDenied,
                    "Endpoint does not support the user identity type provided.");
            }

            // select the security policy for the user token.
            securityPolicyUri = identityPolicy.SecurityPolicyUri;

            if (String.IsNullOrEmpty(securityPolicyUri))
            {
                securityPolicyUri = m_endpoint.Description.SecurityPolicyUri;
            }

            bool requireEncryption = securityPolicyUri != SecurityPolicies.None;

            // validate the server certificate before encrypting tokens.
            if (m_serverCertificate != null && requireEncryption && identity.TokenType != UserTokenType.Anonymous)
            {
                m_configuration.CertificateValidator.Validate(m_serverCertificate);
            }

            // validate server nonce and security parameters for user identity.
            ValidateServerNonce(
                identity,
                serverNonce,
                securityPolicyUri,
                m_previousServerNonce,
                m_endpoint.Description.SecurityMode);

            // sign data with user token.
            identityToken = identity.GetIdentityToken();
            identityToken.PolicyId = identityPolicy.PolicyId;
            userTokenSignature = identityToken.Sign(dataToSign, securityPolicyUri);

            // encrypt token.
            identityToken.Encrypt(m_serverCertificate, serverNonce, securityPolicyUri);

            // send the software certificates assigned to the client.
            SignedSoftwareCertificateCollection clientSoftwareCertificates = GetSoftwareCertificates();

            StatusCodeCollection certificateResults = null;
            DiagnosticInfoCollection certificateDiagnosticInfos = null;

            // activate session.
            ActivateSession(
                null,
                clientSignature,
                clientSoftwareCertificates,
                preferredLocales,
                new ExtensionObject(identityToken),
                userTokenSignature,
                out serverNonce,
                out certificateResults,
                out certificateDiagnosticInfos);

            // save nonce and new values.
            lock (SyncRoot)
            {
                if (identity != null)
                {
                    m_identity = identity;
                }

                m_previousServerNonce = m_serverNonce;
                m_serverNonce = serverNonce;
                m_preferredLocales = preferredLocales;

                // update system context.
                m_systemContext.PreferredLocales = m_preferredLocales;
                m_systemContext.SessionId = this.SessionId;
                m_systemContext.UserIdentity = identity;
            }
        }

        /// <summary>
        /// Finds the NodeIds for the components for an instance.
        /// </summary>
        public void FindComponentIds(
            NodeId instanceId,
            IList<string> componentPaths,
            out NodeIdCollection componentIds,
            out List<ServiceResult> errors)
        {
            componentIds = new NodeIdCollection();
            errors = new List<ServiceResult>();

            // build list of paths to translate.
            BrowsePathCollection pathsToTranslate = new BrowsePathCollection();

            for (int ii = 0; ii < componentPaths.Count; ii++)
            {
                BrowsePath pathToTranslate = new BrowsePath();

                pathToTranslate.StartingNode = instanceId;
                pathToTranslate.RelativePath = RelativePath.Parse(componentPaths[ii], TypeTree);

                pathsToTranslate.Add(pathToTranslate);
            }

            // translate the paths.
            BrowsePathResultCollection results = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = TranslateBrowsePathsToNodeIds(
                null,
                pathsToTranslate,
                out results,
                out diagnosticInfos);

            // verify that the server returned the correct number of results.
            ClientBase.ValidateResponse(results, pathsToTranslate);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, pathsToTranslate);

            for (int ii = 0; ii < componentPaths.Count; ii++)
            {
                componentIds.Add(NodeId.Null);
                errors.Add(ServiceResult.Good);

                // process any diagnostics associated with any error.
                if (StatusCode.IsBad(results[ii].StatusCode))
                {
                    errors[ii] = new ServiceResult(results[ii].StatusCode, ii, diagnosticInfos, responseHeader.StringTable);
                    continue;
                }

                // Expecting exact one NodeId for a local node.
                // Report an error if the server returns anything other than that.

                if (results[ii].Targets.Count == 0)
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadTargetNodeIdInvalid,
                        "Could not find target for path: {0}.",
                        componentPaths[ii]);

                    continue;
                }

                if (results[ii].Targets.Count != 1)
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadTooManyMatches,
                        "Too many matches found for path: {0}.",
                        componentPaths[ii]);

                    continue;
                }

                if (results[ii].Targets[0].RemainingPathIndex != UInt32.MaxValue)
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadTargetNodeIdInvalid,
                        "Cannot follow path to external server: {0}.",
                        componentPaths[ii]);

                    continue;
                }

                if (NodeId.IsNull(results[ii].Targets[0].TargetId))
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadUnexpectedError,
                        "Server returned a null NodeId for path: {0}.",
                        componentPaths[ii]);

                    continue;
                }

                if (results[ii].Targets[0].TargetId.IsAbsolute)
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadUnexpectedError,
                        "Server returned a remote node for path: {0}.",
                        componentPaths[ii]);

                    continue;
                }

                // suitable target found.
                componentIds[ii] = ExpandedNodeId.ToNodeId(results[ii].Targets[0].TargetId, m_namespaceUris);
            }
        }


        /// <summary>
        /// Reads the values for a set of variables.
        /// </summary>
        /// <param name="variableIds">The variable ids.</param>
        /// <param name="expectedTypes">The expected types.</param>
        /// <param name="values">The list of returned values.</param>
        /// <param name="errors">The list of returned errors.</param>
        public void ReadValues(
            IList<NodeId> variableIds,
            IList<Type> expectedTypes,
            out List<object> values,
            out List<ServiceResult> errors)
        {
            values = new List<object>();
            errors = new List<ServiceResult>();

            // build list of values to read.
            ReadValueIdCollection valuesToRead = new ReadValueIdCollection();

            for (int ii = 0; ii < variableIds.Count; ii++)
            {
                ReadValueId valueToRead = new ReadValueId();

                valueToRead.NodeId = variableIds[ii];
                valueToRead.AttributeId = Attributes.Value;
                valueToRead.IndexRange = null;
                valueToRead.DataEncoding = null;

                valuesToRead.Add(valueToRead);
            }

            // read the values.
            DataValueCollection results = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = Read(
                null,
                0,
                TimestampsToReturn.Both,
                valuesToRead,
                out results,
                out diagnosticInfos);

            // verify that the server returned the correct number of results.
            ClientBase.ValidateResponse(results, valuesToRead);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, valuesToRead);

            for (int ii = 0; ii < variableIds.Count; ii++)
            {
                values.Add(null);
                errors.Add(ServiceResult.Good);

                // process any diagnostics associated with bad or uncertain data.
                if (StatusCode.IsNotGood(results[ii].StatusCode))
                {
                    errors[ii] = new ServiceResult(results[ii].StatusCode, ii, diagnosticInfos, responseHeader.StringTable);
                    continue;
                }

                object value = results[ii].Value;

                // extract the body from extension objects.
                ExtensionObject extension = value as ExtensionObject;

                if (extension?.Body is IEncodeable)
                {
                    value = extension.Body;
                }

                // check expected type.
                if (expectedTypes[ii] != null && !expectedTypes[ii].IsInstanceOfType(value))
                {
                    errors[ii] = ServiceResult.Create(
                        StatusCodes.BadTypeMismatch,
                        "Value {0} does not have expected type: {1}.",
                        value,
                        expectedTypes[ii].Name);

                    continue;
                }

                // suitable value found.
                values[ii] = value;
            }
        }


        /// <summary>
        /// Reads the display name for a set of Nodes.
        /// </summary>
        public void ReadDisplayName(
            IList<NodeId> nodeIds,
            out List<string> displayNames,
            out List<ServiceResult> errors)
        {
            displayNames = new List<string>();
            errors = new List<ServiceResult>();

            // build list of values to read.
            ReadValueIdCollection valuesToRead = new ReadValueIdCollection();

            for (int ii = 0; ii < nodeIds.Count; ii++)
            {
                ReadValueId valueToRead = new ReadValueId();

                valueToRead.NodeId = nodeIds[ii];
                valueToRead.AttributeId = Attributes.DisplayName;
                valueToRead.IndexRange = null;
                valueToRead.DataEncoding = null;

                valuesToRead.Add(valueToRead);
            }

            // read the values.
            DataValueCollection results = null;
            DiagnosticInfoCollection diagnosticInfos = null;

            ResponseHeader responseHeader = Read(
                null,
                Int32.MaxValue,
                TimestampsToReturn.Both,
                valuesToRead,
                out results,
                out diagnosticInfos);

            // verify that the server returned the correct number of results.
            ClientBase.ValidateResponse(results, valuesToRead);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, valuesToRead);

            for (int ii = 0; ii < nodeIds.Count; ii++)
            {
                displayNames.Add(String.Empty);
                errors.Add(ServiceResult.Good);

                // process any diagnostics associated with bad or uncertain data.
                if (StatusCode.IsNotGood(results[ii].StatusCode))
                {
                    errors[ii] = new ServiceResult(results[ii].StatusCode, ii, diagnosticInfos, responseHeader.StringTable);
                    continue;
                }

                // extract the name.
                LocalizedText displayName = results[ii].GetValue<LocalizedText>(null);

                if (!LocalizedText.IsNullOrEmpty(displayName))
                {
                    displayNames[ii] = displayName.Text;
                }
            }
        }
        #endregion

        #region Close Methods
        /// <summary>
        /// Disconnects from the server and frees any network resources.
        /// </summary>
        public override StatusCode Close()
        {
            return Close(m_keepAliveInterval);
        }

        /// <summary>
        /// Disconnects from the server and frees any network resources with the specified timeout.
        /// </summary>
        public virtual StatusCode Close(int timeout)
        {
            // check if already called.
            if (Disposed)
            {
                return StatusCodes.Good;
            }

            StatusCode result = StatusCodes.Good;

            // stop the keep alive timer.
            if (m_keepAliveTimer != null)
            {
                m_keepAliveTimer.Dispose();
                m_keepAliveTimer = null;
            }

            // check if currectly connected.
            bool connected = Connected;

            // halt all background threads.
            if (connected)
            {
                if (m_SessionClosing != null)
                {
                    try
                    {
                        m_SessionClosing(this, null);
                    }
                    catch (Exception e)
                    {
                        Utils.Trace(e, "Session: Unexpected eror raising SessionClosing event.");
                    }
                }
            }

            // close the session with the server.
            if (connected && !KeepAliveStopped)
            {
                int existingTimeout = this.OperationTimeout;

                try
                {
                    // close the session and delete all subscriptions.
                    this.OperationTimeout = timeout;
                    CloseSession(null, true);
                    this.OperationTimeout = existingTimeout;

                    CloseChannel();

                    // raised notification indicating the session is closed.
                    SessionCreated(null, null);
                }
                catch (Exception e)
                {
                    // dont throw errors on disconnect, but return them
                    // so the caller can log the error.
                    if (e is ServiceResultException)
                    {
                        result = ((ServiceResultException)e).StatusCode;
                    }
                    else
                    {
                        result = StatusCodes.Bad;
                    }

                    Utils.Trace("Session close error: " + result);
                }
            }

            // clean up.
            Dispose();
            return result;
        }
        #endregion

        #region Subscription Methods
        /// <summary>
        /// Adds a subscription to the session.
        /// </summary>
        /// <param name="subscription">The subscription to add.</param>
        /// <returns></returns>
        public bool AddSubscription(Subscription subscription)
        {
            if (subscription == null) throw new ArgumentNullException(nameof(subscription));

            lock (SyncRoot)
            {
                if (m_subscriptions.Contains(subscription))
                {
                    return false;
                }

                subscription.Session = this;
                m_subscriptions.Add(subscription);
            }

            if (m_SubscriptionsChanged != null)
            {
                m_SubscriptionsChanged(this, null);
            }

            return true;
        }

        /// <summary>
        /// Removes a subscription from the session.
        /// </summary>
        /// <param name="subscription">The subscription to remove.</param>
        /// <returns></returns>
        public bool RemoveSubscription(Subscription subscription)
        {
            if (subscription == null) throw new ArgumentNullException(nameof(subscription));

            if (subscription.Created)
            {
                subscription.Delete(false);
            }

            lock (SyncRoot)
            {
                if (!m_subscriptions.Remove(subscription))
                {
                    return false;
                }

                subscription.Session = null;
            }

            if (m_SubscriptionsChanged != null)
            {
                m_SubscriptionsChanged(this, null);
            }

            return true;
        }

        /// <summary>
        /// Removes a list of subscriptions from the sessiont.
        /// </summary>
        /// <param name="subscriptions">The list of subscriptions to remove.</param>
        /// <returns></returns>
        public bool RemoveSubscriptions(IEnumerable<Subscription> subscriptions)
        {
            if (subscriptions == null) throw new ArgumentNullException(nameof(subscriptions));

            bool removed = false;
            List<Subscription> subscriptionsToDelete = new List<Subscription>();

            lock (SyncRoot)
            {
                foreach (Subscription subscription in subscriptions)
                {
                    if (m_subscriptions.Remove(subscription))
                    {
                        if (subscription.Created)
                        {
                            subscriptionsToDelete.Add(subscription);
                        }

                        removed = true;
                    }
                }
            }

            foreach (Subscription subscription in subscriptionsToDelete)
            {
                subscription.Delete(true);
            }

            if (removed)
            {
                if (m_SubscriptionsChanged != null)
                {
                    m_SubscriptionsChanged(this, null);
                }
            }

            return true;
        }
        #endregion

        #region Browse Methods
        /// <summary>
        /// Invokes the Browse service.
        /// </summary>
        /// <param name="requestHeader">The request header.</param>
        /// <param name="view">The view to browse.</param>
        /// <param name="nodeToBrowse">The node to browse.</param>
        /// <param name="maxResultsToReturn">The maximum number of returned values.</param>
        /// <param name="browseDirection">The browse direction.</param>
        /// <param name="referenceTypeId">The reference type id.</param>
        /// <param name="includeSubtypes">If set to <c>true</c> the subtypes of the ReferenceType will be included in the browse.</param>
        /// <param name="nodeClassMask">The node class mask.</param>
        /// <param name="continuationPoint">The continuation point.</param>
        /// <param name="references">The list of node references.</param>
        /// <returns></returns>
        public virtual ResponseHeader Browse(
            RequestHeader requestHeader,
            ViewDescription view,
            NodeId nodeToBrowse,
            uint maxResultsToReturn,
            BrowseDirection browseDirection,
            NodeId referenceTypeId,
            bool includeSubtypes,
            uint nodeClassMask,
            out byte[] continuationPoint,
            out ReferenceDescriptionCollection references)
        {
            BrowseDescription description = new BrowseDescription();

            description.NodeId = nodeToBrowse;
            description.BrowseDirection = browseDirection;
            description.ReferenceTypeId = referenceTypeId;
            description.IncludeSubtypes = includeSubtypes;
            description.NodeClassMask = nodeClassMask;
            description.ResultMask = (uint)BrowseResultMask.All;

            BrowseDescriptionCollection nodesToBrowse = new BrowseDescriptionCollection();
            nodesToBrowse.Add(description);

            BrowseResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = Browse(
                requestHeader,
                view,
                maxResultsToReturn,
                nodesToBrowse,
                out results,
                out diagnosticInfos);

            ClientBase.ValidateResponse(results, nodesToBrowse);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToBrowse);

            if (StatusCode.IsBad(results[0].StatusCode))
            {
                throw new ServiceResultException(new ServiceResult(results[0].StatusCode, 0, diagnosticInfos, responseHeader.StringTable));
            }

            continuationPoint = results[0].ContinuationPoint;
            references = results[0].References;

            return responseHeader;
        }

        /// <summary>
        /// Begins an asynchronous invocation of the Browse service.
        /// </summary>
        /// <param name="requestHeader">The request header.</param>
        /// <param name="view">The view to browse.</param>
        /// <param name="nodeToBrowse">The node to browse.</param>
        /// <param name="maxResultsToReturn">The maximum number of returned values..</param>
        /// <param name="browseDirection">The browse direction.</param>
        /// <param name="referenceTypeId">The reference type id.</param>
        /// <param name="includeSubtypes">If set to <c>true</c> the subtypes of the ReferenceType will be included in the browse.</param>
        /// <param name="nodeClassMask">The node class mask.</param>
        /// <param name="callback">The callback.</param>
        /// <param name="asyncState"></param>
        /// <returns></returns>
        public IAsyncResult BeginBrowse(
            RequestHeader requestHeader,
            ViewDescription view,
            NodeId nodeToBrowse,
            uint maxResultsToReturn,
            BrowseDirection browseDirection,
            NodeId referenceTypeId,
            bool includeSubtypes,
            uint nodeClassMask,
            AsyncCallback callback,
            object asyncState)
        {
            BrowseDescription description = new BrowseDescription();

            description.NodeId = nodeToBrowse;
            description.BrowseDirection = browseDirection;
            description.ReferenceTypeId = referenceTypeId;
            description.IncludeSubtypes = includeSubtypes;
            description.NodeClassMask = nodeClassMask;
            description.ResultMask = (uint)BrowseResultMask.All;

            BrowseDescriptionCollection nodesToBrowse = new BrowseDescriptionCollection();
            nodesToBrowse.Add(description);

            return BeginBrowse(
                requestHeader,
                view,
                maxResultsToReturn,
                nodesToBrowse,
                callback,
                asyncState);
        }

        /// <summary>
        /// Finishes an asynchronous invocation of the Browse service.
        /// </summary>
        /// <param name="result">The result.</param>
        /// <param name="continuationPoint">The continuation point.</param>
        /// <param name="references">The list of node references.</param>
        /// <returns></returns>
        public ResponseHeader EndBrowse(
            IAsyncResult result,
            out byte[] continuationPoint,
            out ReferenceDescriptionCollection references)
        {
            BrowseResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = EndBrowse(
                result,
                out results,
                out diagnosticInfos);

            if (results == null || results.Count != 1)
            {
                throw new ServiceResultException(StatusCodes.BadUnknownResponse);
            }

            if (StatusCode.IsBad(results[0].StatusCode))
            {
                throw new ServiceResultException(new ServiceResult(results[0].StatusCode, 0, diagnosticInfos, responseHeader.StringTable));
            }

            continuationPoint = results[0].ContinuationPoint;
            references = results[0].References;

            return responseHeader;
        }
        #endregion

        #region BrowseNext Methods
        /// <summary>
        /// Invokes the BrowseNext service.
        /// </summary>
        public virtual ResponseHeader BrowseNext(
            RequestHeader requestHeader,
            bool releaseContinuationPoint,
            byte[] continuationPoint,
            out byte[] revisedContinuationPoint,
            out ReferenceDescriptionCollection references)
        {
            ByteStringCollection continuationPoints = new ByteStringCollection();
            continuationPoints.Add(continuationPoint);

            BrowseResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = BrowseNext(
                requestHeader,
                releaseContinuationPoint,
                continuationPoints,
                out results,
                out diagnosticInfos);

            ClientBase.ValidateResponse(results, continuationPoints);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, continuationPoints);

            if (StatusCode.IsBad(results[0].StatusCode))
            {
                throw new ServiceResultException(new ServiceResult(results[0].StatusCode, 0, diagnosticInfos, responseHeader.StringTable));
            }

            revisedContinuationPoint = results[0].ContinuationPoint;
            references = results[0].References;

            return responseHeader;
        }

        /// <summary>
        /// Begins an asynchronous invocation of the BrowseNext service.
        /// </summary>
        public IAsyncResult BeginBrowseNext(
            RequestHeader requestHeader,
            bool releaseContinuationPoint,
            byte[] continuationPoint,
            AsyncCallback callback,
            object asyncState)
        {
            ByteStringCollection continuationPoints = new ByteStringCollection();
            continuationPoints.Add(continuationPoint);

            return BeginBrowseNext(
                requestHeader,
                releaseContinuationPoint,
                continuationPoints,
                callback,
                asyncState);
        }

        /// <summary>
        /// Finishes an asynchronous invocation of the BrowseNext service.
        /// </summary>
        public ResponseHeader EndBrowseNext(
            IAsyncResult result,
            out byte[] revisedContinuationPoint,
            out ReferenceDescriptionCollection references)
        {
            BrowseResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = EndBrowseNext(
                result,
                out results,
                out diagnosticInfos);

            if (results == null || results.Count != 1)
            {
                throw new ServiceResultException(StatusCodes.BadUnknownResponse);
            }

            if (StatusCode.IsBad(results[0].StatusCode))
            {
                throw new ServiceResultException(new ServiceResult(results[0].StatusCode, 0, diagnosticInfos, responseHeader.StringTable));
            }

            revisedContinuationPoint = results[0].ContinuationPoint;
            references = results[0].References;

            return responseHeader;
        }
        #endregion

        #region Call Methods
        /// <summary>
        /// Calls the specified method and returns the output arguments.
        /// </summary>
        /// <param name="objectId">The NodeId of the object that provides the method.</param>
        /// <param name="methodId">The NodeId of the method to call.</param>
        /// <param name="args">The input arguments.</param>
        /// <returns>The list of output argument values.</returns>
        public IList<object> Call(NodeId objectId, NodeId methodId, params object[] args)
        {
            VariantCollection inputArguments = new VariantCollection();

            if (args != null)
            {
                for (int ii = 0; ii < args.Length; ii++)
                {
                    inputArguments.Add(new Variant(args[ii]));
                }
            }

            CallMethodRequest request = new CallMethodRequest();

            request.ObjectId = objectId;
            request.MethodId = methodId;
            request.InputArguments = inputArguments;

            CallMethodRequestCollection requests = new CallMethodRequestCollection();
            requests.Add(request);

            CallMethodResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = Call(
                null,
                requests,
                out results,
                out diagnosticInfos);

            ClientBase.ValidateResponse(results, requests);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, requests);

            if (StatusCode.IsBad(results[0].StatusCode))
            {
                throw ServiceResultException.Create(results[0].StatusCode, 0, diagnosticInfos, responseHeader.StringTable);
            }

            List<object> outputArguments = new List<object>();

            foreach (Variant arg in results[0].OutputArguments)
            {
                outputArguments.Add(arg.Value);
            }

            return outputArguments;
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Returns the software certificates assigned to the application.
        /// </summary>
        protected virtual SignedSoftwareCertificateCollection GetSoftwareCertificates()
        {
            return new SignedSoftwareCertificateCollection();
        }

        /// <summary>
        /// Handles an error when validating the application instance certificate provided by the server.
        /// </summary>
        protected virtual void OnApplicationCertificateError(byte[] serverCertificate, ServiceResult result)
        {
            throw new ServiceResultException(result);
        }

        /// <summary>
        /// Handles an error when validating software certificates provided by the server.
        /// </summary>
        protected virtual void OnSoftwareCertificateError(SignedSoftwareCertificate signedCertificate, ServiceResult result)
        {
            throw new ServiceResultException(result);
        }

        /// <summary>
        /// Inspects the software certificates provided by the server. 
        /// </summary>
        protected virtual void ValidateSoftwareCertificates(List<SoftwareCertificate> softwareCertificates)
        {
            // always accept valid certificates.
        }

        /// <summary>
        /// Starts a timer to check that the connection to the server is still available.
        /// </summary>
        private void StartKeepAliveTimer()
        {
            int keepAliveInterval = m_keepAliveInterval;

            lock (m_eventLock)
            {
                m_serverState = ServerState.Unknown;
                m_lastKeepAliveTime = DateTime.UtcNow;
            }

            ReadValueIdCollection nodesToRead = new ReadValueIdCollection();

            // read the server state.
            ReadValueId serverState = new ReadValueId();

            serverState.NodeId = Variables.Server_ServerStatus_State;
            serverState.AttributeId = Attributes.Value;
            serverState.DataEncoding = null;
            serverState.IndexRange = null;

            nodesToRead.Add(serverState);

            // restart the publish timer.
            lock (SyncRoot)
            {
                if (m_keepAliveTimer != null)
                {
                    m_keepAliveTimer.Dispose();
                    m_keepAliveTimer = null;
                }

                // start timer.
                m_keepAliveTimer = new Timer(OnKeepAlive, nodesToRead, keepAliveInterval, keepAliveInterval);
            }

            // send initial keep alive.
            OnKeepAlive(nodesToRead);
        }

        /// <summary>
        /// Removes a completed async request.
        /// </summary>
        private AsyncRequestState RemoveRequest(IAsyncResult result, uint requestId, uint typeId)
        {
            lock (m_outstandingRequests)
            {
                for (LinkedListNode<AsyncRequestState> ii = m_outstandingRequests.First; ii != null; ii = ii.Next)
                {
                    if (Object.ReferenceEquals(result, ii.Value.Result) || (requestId == ii.Value.RequestId && typeId == ii.Value.RequestTypeId))
                    {
                        AsyncRequestState state = ii.Value;
                        m_outstandingRequests.Remove(ii);
                        return state;
                    }
                }

                return null;
            }
        }

        /// <summary>
        /// Adds a new async request.
        /// </summary>
        private void AsyncRequestStarted(IAsyncResult result, uint requestId, uint typeId)
        {
            lock (m_outstandingRequests)
            {
                // check if the request completed asynchronously.
                AsyncRequestState state = RemoveRequest(result, requestId, typeId);

                // add a new request.
                if (state == null)
                {
                    state = new AsyncRequestState();

                    state.Defunct = false;
                    state.RequestId = requestId;
                    state.RequestTypeId = typeId;
                    state.Result = result;
                    state.Timestamp = DateTime.UtcNow;

                    m_outstandingRequests.AddLast(state);
                }
            }
        }

        /// <summary>
        /// Removes a completed async request.
        /// </summary>
        private void AsyncRequestCompleted(IAsyncResult result, uint requestId, uint typeId)
        {
            lock (m_outstandingRequests)
            {
                // remove the request.
                AsyncRequestState state = RemoveRequest(result, requestId, typeId);

                if (state != null)
                {
                    // mark any old requests as default (i.e. the should have returned before this request).
                    DateTime maxAge = state.Timestamp.AddSeconds(-1);

                    for (LinkedListNode<AsyncRequestState> ii = m_outstandingRequests.First; ii != null; ii = ii.Next)
                    {
                        if (ii.Value.RequestTypeId == typeId && ii.Value.Timestamp < maxAge)
                        {
                            ii.Value.Defunct = true;
                        }
                    }
                }

                // add a dummy placeholder since the begin request has not completed yet.
                if (state == null)
                {
                    state = new AsyncRequestState();

                    state.Defunct = true;
                    state.RequestId = requestId;
                    state.RequestTypeId = typeId;
                    state.Result = result;
                    state.Timestamp = DateTime.UtcNow;

                    m_outstandingRequests.AddLast(state);
                }
            }
        }

        /// <summary>
        /// Sends a keep alive by reading from the server.
        /// </summary>
        private void OnKeepAlive(object state)
        {
            ReadValueIdCollection nodesToRead = (ReadValueIdCollection)state;

            try
            {
                // check if session has been closed.
                if (!Connected || m_keepAliveTimer == null)
                {
                    return;
                }

                // raise error if keep alives are not coming back.
                if (KeepAliveStopped)
                {
                    if (!OnKeepAliveError(ServiceResult.Create(StatusCodes.BadNoCommunication, "Server not responding to keep alive requests.")))
                    {
                        return;
                    }
                }

                RequestHeader requestHeader = new RequestHeader();

                requestHeader.RequestHandle = Utils.IncrementIdentifier(ref m_keepAliveCounter);
                requestHeader.TimeoutHint = (uint)(KeepAliveInterval * 2);
                requestHeader.ReturnDiagnostics = 0;

                IAsyncResult result = BeginRead(
                    requestHeader,
                    0,
                    TimestampsToReturn.Neither,
                    nodesToRead,
                    OnKeepAliveComplete,
                    nodesToRead);

                AsyncRequestStarted(result, requestHeader.RequestHandle, DataTypes.ReadRequest);
            }
            catch (Exception e)
            {
                Utils.Trace("Could not send keep alive request: {1} {0}", e.Message, e.GetType().FullName);
            }
        }

        /// <summary>
        /// Checks if a notification has arrived. Sends a publish if it has not.
        /// </summary>
        private void OnKeepAliveComplete(IAsyncResult result)
        {
            ReadValueIdCollection nodesToRead = (ReadValueIdCollection)result.AsyncState;

            AsyncRequestCompleted(result, 0, DataTypes.ReadRequest);

            try
            {
                // read the server status.
                DataValueCollection values = new DataValueCollection();
                DiagnosticInfoCollection diagnosticInfos = new DiagnosticInfoCollection();

                ResponseHeader responseHeader = EndRead(
                    result,
                    out values,
                    out diagnosticInfos);

                ValidateResponse(values, nodesToRead);
                ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);

                // validate value returned.
                ServiceResult error = ValidateDataValue(values[0], typeof(int), 0, diagnosticInfos, responseHeader);

                if (ServiceResult.IsBad(error))
                {
                    throw new ServiceResultException(error);
                }

                // send notification that keep alive completed.
                OnKeepAlive((ServerState)(int)values[0].Value, responseHeader.Timestamp);
            }
            catch (Exception e)
            {
                Utils.Trace("Unexpected keep alive error occurred: {0}", e.Message);
            }
        }

        /// <summary>
        /// Called when the server returns a keep alive response.
        /// </summary>
        protected virtual void OnKeepAlive(ServerState currentState, DateTime currentTime)
        {
            // restart publishing if keep alives recovered.
            if (KeepAliveStopped)
            {
                // ignore if already reconnecting.
                if (m_reconnecting)
                {
                    return;
                }

                int count = 0;

                lock (m_outstandingRequests)
                {
                    for (LinkedListNode<AsyncRequestState> ii = m_outstandingRequests.First; ii != null; ii = ii.Next)
                    {
                        if (ii.Value.RequestTypeId == DataTypes.PublishRequest)
                        {
                            ii.Value.Defunct = true;
                        }
                    }
                }

                lock (SyncRoot)
                {
                    count = m_subscriptions.Count;
                }

                while (count-- > 0)
                {
                    BeginPublish(OperationTimeout);
                }
            }

            KeepAliveEventHandler callback = null;

            lock (m_eventLock)
            {
                callback = m_KeepAlive;

                // save server state.
                m_serverState = currentState;
                m_lastKeepAliveTime = DateTime.UtcNow;
            }

            if (callback != null)
            {
                try
                {
                    callback(this, new KeepAliveEventArgs(null, currentState, currentTime));
                }
                catch (Exception e)
                {
                    Utils.Trace(e, "Session: Unexpected error invoking KeepAliveCallback.");
                }
            }
        }

        /// <summary>
        /// Called when a error occurs during a keep alive.
        /// </summary>
        protected virtual bool OnKeepAliveError(ServiceResult result)
        {
            long delta = 0;

            lock (m_eventLock)
            {
                delta = DateTime.UtcNow.Ticks - m_lastKeepAliveTime.Ticks;
            }

            Utils.Trace(
                "KEEP ALIVE LATE: {0}s, EndpointUrl={1}, RequestCount={3}/{2}",
                ((double)delta) / TimeSpan.TicksPerSecond,
                this.Endpoint.EndpointUrl,
                this.OutstandingRequestCount,
                this.GoodPublishRequestCount);

            KeepAliveEventHandler callback = null;

            lock (m_eventLock)
            {
                callback = m_KeepAlive;
            }

            if (callback != null)
            {
                try
                {
                    KeepAliveEventArgs args = new KeepAliveEventArgs(result, ServerState.Unknown, DateTime.UtcNow);
                    callback(this, args);
                    return !args.CancelKeepAlive;
                }
                catch (Exception e)
                {
                    Utils.Trace(e, "Session: Unexpected error invoking KeepAliveCallback.");
                }
            }

            return true;
        }
        #endregion

        #region Publish Methods
        /// <summary>
        /// Sends an additional publish request.
        /// </summary>
        public IAsyncResult BeginPublish(int timeout)
        {
            // do not publish if reconnecting.
            if (m_reconnecting)
            {
                Utils.Trace("Published skipped due to reconnect");
                return null;
            }

            SubscriptionAcknowledgementCollection acknowledgementsToSend = null;

            // collect the current set if acknowledgements.
            lock (SyncRoot)
            {
                acknowledgementsToSend = m_acknowledgementsToSend;
                m_acknowledgementsToSend = new SubscriptionAcknowledgementCollection();
                foreach (var toSend in acknowledgementsToSend)
                {
                    if (m_latestAcknowledgementsSent.ContainsKey(toSend.SubscriptionId))
                    {
                        m_latestAcknowledgementsSent[toSend.SubscriptionId] = toSend.SequenceNumber;
                    }
                    else
                    {
                        m_latestAcknowledgementsSent.Add(toSend.SubscriptionId, toSend.SequenceNumber);
                    }
                }
            }

            // send publish request.
            RequestHeader requestHeader = new RequestHeader();

            // ensure the publish request is discarded before the timeout occurs to ensure the channel is dropped.
            requestHeader.TimeoutHint = (uint)OperationTimeout / 2;
            requestHeader.ReturnDiagnostics = (uint)(int)ReturnDiagnostics;
            requestHeader.RequestHandle = Utils.IncrementIdentifier(ref m_publishCounter);

            AsyncRequestState state = new AsyncRequestState();

            state.RequestTypeId = DataTypes.PublishRequest;
            state.RequestId = requestHeader.RequestHandle;
            state.Timestamp = DateTime.UtcNow;

            try
            {
                IAsyncResult result = BeginPublish(
                    requestHeader,
                    acknowledgementsToSend,
                    OnPublishComplete,
                    new object[] { SessionId, acknowledgementsToSend, requestHeader });

                AsyncRequestStarted(result, requestHeader.RequestHandle, DataTypes.PublishRequest);

                Utils.Trace("PUBLISH #{0} SENT", requestHeader.RequestHandle);

                return result;
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Unexpected error sending publish request.");
                return null;
            }
        }

        /// <summary>
        /// Completes an asynchronous publish operation.
        /// </summary>
        private void OnPublishComplete(IAsyncResult result)
        {
            // extract state information.
            object[] state = (object[])result.AsyncState;
            NodeId sessionId = (NodeId)state[0];
            SubscriptionAcknowledgementCollection acknowledgementsToSend = (SubscriptionAcknowledgementCollection)state[1];
            RequestHeader requestHeader = (RequestHeader)state[2];
            bool moreNotifications;

            AsyncRequestCompleted(result, requestHeader.RequestHandle, DataTypes.PublishRequest);

            try
            {
                Utils.Trace("PUBLISH #{0} RECEIVED", requestHeader.RequestHandle);

                // complete publish.
                uint subscriptionId;
                UInt32Collection availableSequenceNumbers;
                NotificationMessage notificationMessage;
                StatusCodeCollection acknowledgeResults;
                DiagnosticInfoCollection acknowledgeDiagnosticInfos;

                ResponseHeader responseHeader = EndPublish(
                    result,
                    out subscriptionId,
                    out availableSequenceNumbers,
                    out moreNotifications,
                    out notificationMessage,
                    out acknowledgeResults,
                    out acknowledgeDiagnosticInfos);

                foreach (StatusCode code in acknowledgeResults)
                {
                    if (StatusCode.IsBad(code))
                    {
                        Utils.Trace("Error - Publish call finished. ResultCode={0}; SubscriptionId={1};", code.ToString(), subscriptionId);
                    }
                }

                // nothing more to do if session changed.
                if (sessionId != SessionId)
                {
                    Utils.Trace("Publish response discarded because session id changed: Old {0} != New {1}", sessionId, SessionId);
                    return;
                }

                Utils.Trace("NOTIFICATION RECEIVED: SubId={0}, SeqNo={1}", subscriptionId, notificationMessage.SequenceNumber);

                // process response.
                ProcessPublishResponse(
                    responseHeader,
                    subscriptionId,
                    availableSequenceNumbers,
                    moreNotifications,
                    notificationMessage);

                // nothing more to do if reconnecting.
                if (m_reconnecting)
                {
                    Utils.Trace("No new publish sent because of reconnect in progress.");
                    return;
                }
            }
            catch (Exception e)
            {
                if (m_subscriptions.Count == 0)
                {
                    // Publish responses with error should occur after deleting the last subscription.
                    Utils.Trace("Publish #{0}, Subscription count = 0, Error: {1}", requestHeader.RequestHandle, e.Message);
                }
                else
                {
                    Utils.Trace("Publish #{0}, Reconnecting={2}, Error: {1}", requestHeader.RequestHandle, e.Message, m_reconnecting);
                }

                moreNotifications = false;

                // ignore errors if reconnecting.
                if (m_reconnecting)
                {
                    Utils.Trace("Publish abandoned after error due to reconnect: {0}", e.Message);
                    return;
                }

                // nothing more to do if session changed.
                if (sessionId != SessionId)
                {
                    Utils.Trace("Publish abandoned after error because session id changed: Old {0} != New {1}", sessionId, SessionId);
                    return;
                }

                // try to acknowledge the notifications again in the next publish.
                if (acknowledgementsToSend != null)
                {
                    lock (SyncRoot)
                    {
                        m_acknowledgementsToSend.AddRange(acknowledgementsToSend);
                    }
                }

                // raise an error event.     
                ServiceResult error = new ServiceResult(e);

                if (error.Code != StatusCodes.BadNoSubscription)
                {
                    PublishErrorEventHandler callback = null;

                    lock (m_eventLock)
                    {
                        callback = m_PublishError;
                    }

                    if (callback != null)
                    {
                        try
                        {
                            callback(this, new PublishErrorEventArgs(error));
                        }
                        catch (Exception e2)
                        {
                            Utils.Trace(e2, "Session: Unexpected error invoking PublishErrorCallback.");
                        }
                    }
                }

                // don't send another publish for these errors.
                switch (error.Code)
                {
                    case StatusCodes.BadNoSubscription:
                    case StatusCodes.BadSessionClosed:
                    case StatusCodes.BadSessionIdInvalid:
                    case StatusCodes.BadTooManyPublishRequests:
                    case StatusCodes.BadServerHalted:
                    {
                        return;
                    }
                }

                Utils.Trace(e, "PUBLISH #{0} - Unhandled error during Publish.", requestHeader.RequestHandle);
            }

            int requestCount = GoodPublishRequestCount;

            if (requestCount < m_subscriptions.Count)
            {
                BeginPublish(OperationTimeout);
            }
            else
            {
                Utils.Trace("PUBLISH - Did not send another publish request. GoodPublishRequestCount={0}, Subscriptions={1}", requestCount, m_subscriptions.Count);
            }
        }

        /// <summary>
        /// Sends a republish request.
        /// </summary>
        public bool Republish(uint subscriptionId, uint sequenceNumber)
        {
            // send publish request.
            RequestHeader requestHeader = new RequestHeader();

            requestHeader.TimeoutHint = (uint)OperationTimeout;
            requestHeader.ReturnDiagnostics = (uint)(int)ReturnDiagnostics;
            requestHeader.RequestHandle = Utils.IncrementIdentifier(ref m_publishCounter);

            try
            {
                Utils.Trace("Requesting Republish for {0}-{1}", subscriptionId, sequenceNumber);

                // request republish.
                NotificationMessage notificationMessage = null;

                ResponseHeader responseHeader = Republish(
                    requestHeader,
                    subscriptionId,
                    sequenceNumber,
                    out notificationMessage);

                Utils.Trace("Received Republish for {0}-{1}", subscriptionId, sequenceNumber);

                // process response.
                ProcessPublishResponse(
                    responseHeader,
                    subscriptionId,
                    null,
                    false,
                    notificationMessage);

                return true;
            }
            catch (Exception e)
            {
                ServiceResult error = new ServiceResult(e);

                bool result = true;
                switch (error.StatusCode.Code)
                {
                    case StatusCodes.BadMessageNotAvailable:
                        Utils.Trace("Message {0}-{1} no longer available.", subscriptionId, sequenceNumber);
                        break;
                    // if encoding limits are exceeded, the issue is logged and 
                    // the published data is acknoledged to prevent the endless republish loop.
                    case StatusCodes.BadEncodingLimitsExceeded:
                        Utils.Trace(e, "Message {0}-{1} exceeded size limits, ignored.", subscriptionId, sequenceNumber);
                        var ack = new SubscriptionAcknowledgement {
                            SubscriptionId = subscriptionId,
                            SequenceNumber = sequenceNumber
                        };
                        lock (SyncRoot)
                        {
                            m_acknowledgementsToSend.Add(ack);
                        }
                        break;
                    default:
                        result = false;
                        Utils.Trace(e, "Unexpected error sending republish request.");
                        break;
                }

                PublishErrorEventHandler callback = null;

                lock (m_eventLock)
                {
                    callback = m_PublishError;
                }

                // raise an error event.
                if (callback != null)
                {
                    try
                    {
                        PublishErrorEventArgs args = new PublishErrorEventArgs(
                            error,
                            subscriptionId,
                            sequenceNumber);

                        callback(this, args);
                    }
                    catch (Exception e2)
                    {
                        Utils.Trace(e2, "Session: Unexpected error invoking PublishErrorCallback.");
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Processes the response from a publish request.
        /// </summary>
        private void ProcessPublishResponse(
            ResponseHeader responseHeader,
            uint subscriptionId,
            UInt32Collection availableSequenceNumbers,
            bool moreNotifications,
            NotificationMessage notificationMessage)
        {
            Subscription subscription = null;

            // send notification that the server is alive.
            OnKeepAlive(m_serverState, responseHeader.Timestamp);

            // collect the current set if acknowledgements.
            lock (SyncRoot)
            {
                // clear out acknowledgements for messages that the server does not have any more.
                SubscriptionAcknowledgementCollection acknowledgementsToSend = new SubscriptionAcknowledgementCollection();

                for (int ii = 0; ii < m_acknowledgementsToSend.Count; ii++)
                {
                    SubscriptionAcknowledgement acknowledgement = m_acknowledgementsToSend[ii];

                    if (acknowledgement.SubscriptionId != subscriptionId)
                    {
                        acknowledgementsToSend.Add(acknowledgement);
                    }
                    else
                    {
                        if (availableSequenceNumbers == null || availableSequenceNumbers.Contains(acknowledgement.SequenceNumber))
                        {
                            acknowledgementsToSend.Add(acknowledgement);
                        }
                    }
                }

                // create an acknowledgement to be sent back to the server.
                if (notificationMessage.NotificationData.Count > 0)
                {
                    SubscriptionAcknowledgement acknowledgement = new SubscriptionAcknowledgement();

                    acknowledgement.SubscriptionId = subscriptionId;
                    acknowledgement.SequenceNumber = notificationMessage.SequenceNumber;

                    acknowledgementsToSend.Add(acknowledgement);
                }

                uint lastSentSequenceNumber = 0;
                if (availableSequenceNumbers != null)
                {
                    foreach (uint availableSequenceNumber in availableSequenceNumbers)
                    {
                        if (m_latestAcknowledgementsSent.ContainsKey(subscriptionId))
                        {
                            lastSentSequenceNumber = m_latestAcknowledgementsSent[subscriptionId];

                            // If the last sent sequence number is uint.Max do not display the warning; the counter rolled over
                            // If the last sent sequence number is greater or equal to the available sequence number (returned by the publish), a warning must be logged.
                            if (((lastSentSequenceNumber >= availableSequenceNumber) && (lastSentSequenceNumber != uint.MaxValue)) ||
                                (lastSentSequenceNumber == availableSequenceNumber) && (lastSentSequenceNumber == uint.MaxValue))
                            {
                                Utils.Trace("Received sequence number which was already acknowledged={0}", availableSequenceNumber);
                            }
                        }
                    }
                }

                if (m_latestAcknowledgementsSent.ContainsKey(subscriptionId))
                {
                    lastSentSequenceNumber = m_latestAcknowledgementsSent[subscriptionId];

                    // If the last sent sequence number is uint.Max do not display the warning; the counter rolled over
                    // If the last sent sequence number is greater or equal to the notificationMessage's sequence number (returned by the publish), a warning must be logged.
                    if (((lastSentSequenceNumber >= notificationMessage.SequenceNumber) && (lastSentSequenceNumber != uint.MaxValue)) || (lastSentSequenceNumber == notificationMessage.SequenceNumber) && (lastSentSequenceNumber == uint.MaxValue))
                    {
                        Utils.Trace("Received sequence number which was already acknowledged={0}", notificationMessage.SequenceNumber);
                    }
                }

                if (availableSequenceNumbers != null)
                {
                    foreach (var acknowledgement in acknowledgementsToSend)
                    {
                        if (acknowledgement.SubscriptionId == subscriptionId && !availableSequenceNumbers.Contains(acknowledgement.SequenceNumber))
                        {
                            Utils.Trace("Sequence number={0} was not received in the available sequence numbers.", acknowledgement.SequenceNumber);
                        }
                    }
                }

                m_acknowledgementsToSend = acknowledgementsToSend;

                if (notificationMessage.IsEmpty)
                {
                    Utils.Trace("Empty notification message received for SessionId {0} with PublishTime {1}", SessionId, notificationMessage.PublishTime.ToLocalTime());
                }

                // find the subscription.
                foreach (Subscription current in m_subscriptions)
                {
                    if (current.Id == subscriptionId)
                    {
                        subscription = current;
                        break;
                    }
                }
            }

            // ignore messages with a subscription that has been deleted.
            if (subscription != null)
            {
                // Validate publish time and reject old values.
                if (notificationMessage.PublishTime.AddMilliseconds(subscription.CurrentPublishingInterval * subscription.CurrentLifetimeCount) < DateTime.UtcNow)
                {
                    Utils.Trace("PublishTime {0} in publish response is too old for SubscriptionId {1}.", notificationMessage.PublishTime.ToLocalTime(), subscription.Id);
                }

                // Validate publish time and reject old values.
                if (notificationMessage.PublishTime > DateTime.UtcNow.AddMilliseconds(subscription.CurrentPublishingInterval * subscription.CurrentLifetimeCount))
                {
                    Utils.Trace("PublishTime {0} in publish response is newer than actual time for SubscriptionId {1}.", notificationMessage.PublishTime.ToLocalTime(), subscription.Id);
                }

                // update subscription cache.                                 
                subscription.SaveMessageInCache(
                    availableSequenceNumbers,
                    notificationMessage,
                    responseHeader.StringTable);

                // raise the notification.
                lock (m_eventLock)
                {
                    NotificationEventArgs args = new NotificationEventArgs(subscription, notificationMessage, responseHeader.StringTable);

                    if (m_Publish != null)
                    {
                        Task.Run(() => {
                            OnRaisePublishNotification(args);
                        });
                    }
                }
            }
            else
            {
                // Delete abandoned subscription from server.
                Utils.Trace("Received Publish Response for Unknown SubscriptionId={0}", subscriptionId);

                Task.Run(() => {
                    DeleteSubscription(subscriptionId);
                });
            }
        }

        /// <summary>
        /// Raises an event indicating that publish has returned a notification.
        /// </summary>
        private void OnRaisePublishNotification(object state)
        {
            try
            {
                NotificationEventArgs args = (NotificationEventArgs)state;
                NotificationEventHandler callback = m_Publish;

                if (callback != null && args.Subscription.Id != 0)
                {
                    callback(this, args);
                }
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Session: Unexpected error while raising Notification event.");
            }
        }

        /// <summary>
        /// Invokes a DeleteSubscriptions call for the specified subscriptionId.
        /// </summary>
        private void DeleteSubscription(uint subscriptionId)
        {
            try
            {
                Utils.Trace("Deleting server subscription for SubscriptionId={0}", subscriptionId);

                // delete the subscription.
                UInt32Collection subscriptionIds = new uint[] { subscriptionId };

                StatusCodeCollection results;
                DiagnosticInfoCollection diagnosticInfos;

                ResponseHeader responseHeader = DeleteSubscriptions(
                    null,
                    subscriptionIds,
                    out results,
                    out diagnosticInfos);

                // validate response.
                ClientBase.ValidateResponse(results, subscriptionIds);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, subscriptionIds);

                if (StatusCode.IsBad(results[0]))
                {
                    throw new ServiceResultException(ClientBase.GetResult(results[0], 0, diagnosticInfos, responseHeader));
                }
            }
            catch (Exception e)
            {
                Utils.Trace(e, "Session: Unexpected error while deleting subscription for SubscriptionId={0}.", subscriptionId);
            }
        }

        /// <summary>
        /// Load certificate chain for connection.
        /// </summary>
        private static async Task<X509Certificate2> LoadCertificate(ApplicationConfiguration configuration)
        {
            X509Certificate2 clientCertificate;
            if (configuration.SecurityConfiguration.ApplicationCertificate == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "ApplicationCertificate must be specified.");
            }

            clientCertificate = await configuration.SecurityConfiguration.ApplicationCertificate.Find(true);

            if (clientCertificate == null)
            {
                throw ServiceResultException.Create(StatusCodes.BadConfigurationError, "ApplicationCertificate cannot be found.");
            }
            return clientCertificate;
        }


        /// <summary>
        /// Load certificate chain for connection.
        /// </summary>
        private static async Task<X509Certificate2Collection> LoadCertificateChain(ApplicationConfiguration configuration, X509Certificate2 clientCertificate)
        {
            X509Certificate2Collection clientCertificateChain = null;
            // load certificate chain.
            if (configuration.SecurityConfiguration.SendCertificateChain)
            {
                clientCertificateChain = new X509Certificate2Collection(clientCertificate);
                List<CertificateIdentifier> issuers = new List<CertificateIdentifier>();
                await configuration.CertificateValidator.GetIssuers(clientCertificate, issuers);

                for (int i = 0; i < issuers.Count; i++)
                {
                    clientCertificateChain.Add(issuers[i].Certificate);
                }
            }
            return clientCertificateChain;
        }
        #endregion

        #region Private Fields
        private SubscriptionAcknowledgementCollection m_acknowledgementsToSend;
        private Dictionary<uint, uint> m_latestAcknowledgementsSent;
        private List<Subscription> m_subscriptions;
        private Dictionary<NodeId, DataDictionary> m_dictionaries;
        private Subscription m_defaultSubscription;
        private double m_sessionTimeout;
        private uint m_maxRequestMessageSize;
        private StringCollection m_preferredLocales;
        private NamespaceTable m_namespaceUris;
        private StringTable m_serverUris;
        private EncodeableFactory m_factory;
        private SystemContext m_systemContext;
        private NodeCache m_nodeCache;
        private ApplicationConfiguration m_configuration;
        private ConfiguredEndpoint m_endpoint;
        private X509Certificate2 m_instanceCertificate;
        private X509Certificate2Collection m_instanceCertificateChain;
        private bool m_checkDomain;
        private List<IUserIdentity> m_identityHistory;

        private string m_sessionName;
        private object m_handle;
        private IUserIdentity m_identity;
        private byte[] m_serverNonce;
        private byte[] m_previousServerNonce;
        private X509Certificate2 m_serverCertificate;
        private long m_publishCounter;
        private DateTime m_lastKeepAliveTime;
        private ServerState m_serverState;
        private int m_keepAliveInterval;
        private Timer m_keepAliveTimer;
        private long m_keepAliveCounter;
        private bool m_reconnecting;
        private LinkedList<AsyncRequestState> m_outstandingRequests;

        private EndpointDescriptionCollection m_discoveryServerEndpoints;
        private StringCollection m_discoveryProfileUris;

        private class AsyncRequestState
        {
            public uint RequestTypeId;
            public uint RequestId;
            public DateTime Timestamp;
            public IAsyncResult Result;
            public bool Defunct;
        }

        private object m_eventLock = new object();
        private event KeepAliveEventHandler m_KeepAlive;
        private event NotificationEventHandler m_Publish;
        private event PublishErrorEventHandler m_PublishError;
        private event EventHandler m_SubscriptionsChanged;
        private event EventHandler m_SessionClosing;
        #endregion
    }

    #region KeepAliveEventArgs Class
    /// <summary>
    /// The event arguments provided when a keep alive response arrives.
    /// </summary>
    public class KeepAliveEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Creates a new instance.
        /// </summary>
        internal KeepAliveEventArgs(
            ServiceResult status,
            ServerState currentState,
            DateTime currentTime)
        {
            m_status = status;
            m_currentState = currentState;
            m_currentTime = currentTime;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets the status associated with the keep alive operation.
        /// </summary>
        public ServiceResult Status => m_status;

        /// <summary>
        /// Gets the current server state.
        /// </summary>
        public ServerState CurrentState => m_currentState;

        /// <summary>
        /// Gets the current server time.
        /// </summary>
        public DateTime CurrentTime => m_currentTime;

        /// <summary>
        /// Gets or sets a flag indicating whether the session should send another keep alive.
        /// </summary>
        public bool CancelKeepAlive
        {
            get { return m_cancelKeepAlive; }
            set { m_cancelKeepAlive = value; }
        }
        #endregion

        #region Private Fields
        private ServiceResult m_status;
        private ServerState m_currentState;
        private DateTime m_currentTime;
        private bool m_cancelKeepAlive;
        #endregion
    }

    /// <summary>
    /// The delegate used to receive keep alive notifications.
    /// </summary>
    public delegate void KeepAliveEventHandler(Session session, KeepAliveEventArgs e);
    #endregion

    #region NotificationEventArgs Class
    /// <summary>
    /// Represents the event arguments provided when a new notification message arrives.
    /// </summary>
    public class NotificationEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Creates a new instance.
        /// </summary>
        internal NotificationEventArgs(
            Subscription subscription,
            NotificationMessage notificationMessage,
            IList<string> stringTable)
        {
            m_subscription = subscription;
            m_notificationMessage = notificationMessage;
            m_stringTable = stringTable;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets the subscription that the notification applies to.
        /// </summary>
        public Subscription Subscription => m_subscription;

        /// <summary>
        /// Gets the notification message.
        /// </summary>
        public NotificationMessage NotificationMessage => m_notificationMessage;

        /// <summary>
        /// Gets the string table returned with the notification message.
        /// </summary>
        public IList<string> StringTable => m_stringTable;
        #endregion

        #region Private Fields
        private Subscription m_subscription;
        private NotificationMessage m_notificationMessage;
        private IList<string> m_stringTable;
        #endregion
    }

    /// <summary>
    /// The delegate used to receive publish notifications.
    /// </summary>
    public delegate void NotificationEventHandler(Session session, NotificationEventArgs e);
    #endregion

    #region PublishErrorEventArgs Class
    /// <summary>
    /// Represents the event arguments provided when a publish error occurs.
    /// </summary>
    public class PublishErrorEventArgs : EventArgs
    {
        #region Constructors
        /// <summary>
        /// Creates a new instance.
        /// </summary>
        internal PublishErrorEventArgs(ServiceResult status)
        {
            m_status = status;
        }

        /// <summary>
        /// Creates a new instance.
        /// </summary>
        internal PublishErrorEventArgs(ServiceResult status, uint subscriptionId, uint sequenceNumber)
        {
            m_status = status;
            m_subscriptionId = subscriptionId;
            m_sequenceNumber = sequenceNumber;
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets the status associated with the keep alive operation.
        /// </summary>
        public ServiceResult Status => m_status;

        /// <summary>
        /// Gets the subscription with the message that could not be republished.
        /// </summary>
        public uint SubscriptionId => m_subscriptionId;

        /// <summary>
        /// Gets the sequence number for the message that could not be republished.
        /// </summary>
        public uint SequenceNumber => m_sequenceNumber;
        #endregion

        #region Private Fields
        private uint m_subscriptionId;
        private uint m_sequenceNumber;
        private ServiceResult m_status;
        #endregion
    }

    /// <summary>
    /// The delegate used to receive pubish error notifications.
    /// </summary>
    public delegate void PublishErrorEventHandler(Session session, PublishErrorEventArgs e);
    #endregion
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Client\Session.cs(40,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Client\Session.cs(3095,40): error CS8059: Feature 'type pattern' is not available in C# 6. Please use language version 9.0 or greater.,D:\a\1\s\Libraries\Opc.Ua.Client\Session.cs(40,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 30 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.Client.ComplexTypes\ComplexTypeSystem.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Xml;
using static Opc.Ua.Utils;

namespace Opc.Ua.Client.ComplexTypes
{
    /// <summary>
    /// Manages the custom types of a server for a client session.
    /// Loads the custom types into the type factory
    /// of a client session, to allow for decoding and encoding
    /// of custom enumeration types and structured types.
    /// </summary>
    /// <remarks>
    /// Support for V1.03 dictionaries and all V1.04 data type definitions
    /// with the following known restrictions:
    /// - Support only for V1.03 structured types which can be mapped to the V1.04
    /// structured type definition. Unsupported V1.03 types are ignored.
    /// - V1.04 OptionSet does not create the enumeration flags. 
    /// </remarks>
    public class ComplexTypeSystem
    {

        #region Constructors
        /// <summary>
        /// Initializes the type system with a session to load the custom types.
        /// </summary>
        public ComplexTypeSystem(Session session)
        {
            Initialize(session, new ComplexTypeBuilderFactory());
        }

        /// <summary>
        /// Initializes the type system with a session to load the custom types
        /// and a customized type builder factory
        /// </summary>
        public ComplexTypeSystem(
            Session session,
            IComplexTypeFactory complexTypeBuilderFactory)
        {
            Initialize(session, complexTypeBuilderFactory);
        }

        private void Initialize(
            Session session,
            IComplexTypeFactory complexTypeBuilderFactory)
        {
            m_session = session;
            m_complexTypeBuilderFactory = complexTypeBuilderFactory;
        }
        #endregion

        #region Public Members
        /// <summary>
        /// Load a single custom type with subtypes.
        /// </summary>
        /// <remarks>
        /// Uses inverse references on the server to find the super type(s).
        /// If the new structure contains a type dependency to a yet
        /// unknown type, it loads also the dependent type(s).
        /// For servers without DataTypeDefinition support all
        /// custom types are loaded.
        /// </remarks>
        public async Task<Type> LoadType(ExpandedNodeId nodeId, bool subTypes = false, bool throwOnError = false)
        {
            try
            {
                var subTypeNodes = LoadDataTypes(nodeId, subTypes, true);
                var subTypeNodesWithoutKnownTypes = RemoveKnownTypes(subTypeNodes);

                if (subTypeNodesWithoutKnownTypes.Count > 0)
                {
                    IList<INode> serverEnumTypes = new List<INode>();
                    IList<INode> serverStructTypes = new List<INode>();
                    foreach (var node in subTypeNodesWithoutKnownTypes)
                    {
                        AddEnumerationOrStructureType(node, serverEnumTypes, serverStructTypes);
                    }

                    // load server types
                    if (DisableDataTypeDefinition || !LoadBaseDataTypes(serverEnumTypes, serverStructTypes))
                    {
                        if (!DisableDataTypeDictionary)
                        {
                            await LoadDictionaryDataTypes(serverEnumTypes, serverStructTypes, false).ConfigureAwait(false);
                        }
                    }
                }
                return GetSystemType(nodeId);
            }
            catch (ServiceResultException sre)
            {
                Utils.Trace(sre, "Failed to load the custom type {0}.", nodeId);
                if (throwOnError)
                {
                    throw;
                }
                return null;
            }
        }

        /// <summary>
        /// Load all custom types of a namespace.
        /// </summary>
        /// <remarks>
        /// If a new type in the namespace contains a type dependency to an
        /// unknown type in another namespace, it loads also the dependent type(s).
        /// For servers without DataTypeDefinition support all
        /// custom types are loaded.
        /// </remarks>
        public async Task<bool> LoadNamespace(string nameSpace, bool throwOnError = false)
        {
            try
            {
                int index = m_session.NamespaceUris.GetIndex(nameSpace);
                if (index < 0)
                {
                    throw new ServiceResultException($"Bad argument {nameSpace}. Namespace not found.");
                }
                ushort nameSpaceIndex = (ushort)index;
                var serverEnumTypes = LoadDataTypes(DataTypeIds.Enumeration);
                var serverStructTypes = LoadDataTypes(DataTypeIds.Structure, true);
                // filter for namespace
                serverEnumTypes = serverEnumTypes.Where(rd => rd.NodeId.NamespaceIndex == nameSpaceIndex).ToList();
                serverStructTypes = serverStructTypes.Where(rd => rd.NodeId.NamespaceIndex == nameSpaceIndex).ToList();
                // load types
                if (DisableDataTypeDefinition || !LoadBaseDataTypes(serverEnumTypes, serverStructTypes))
                {
                    if (DisableDataTypeDictionary)
                    {
                        return false;
                    }
                    return await LoadDictionaryDataTypes(serverEnumTypes, serverStructTypes, false).ConfigureAwait(false);
                }
                return true;
            }
            catch (ServiceResultException sre)
            {
                Utils.Trace(sre, $"Failed to load the custom type dictionary.");
                if (throwOnError)
                {
                    throw;
                }
                return false;
            }
        }

        /// <summary>
        /// Load all custom types from a server into the session system type factory.
        /// </summary>
        /// <remarks>
        /// The loader follows the following strategy:
        /// - Load all DataType nodes of the Enumeration subtypes.
        /// - Load all DataType nodes of the Structure subtypes.
        /// - Create all enumerated custom types using the DataTypeDefinion attribute, if available.
        /// - Create all remaining enumerated custom types using the EnumValues or EnumStrings property, if available.
        /// - Create all structured types using the DataTypeDefinion attribute, if available.
        /// if there are type definitions remaining
        /// - Load the binary schema dictionaries with type definitions.
        /// - Create all remaining enumerated custom types using the dictionaries.
        /// - Convert all structured types in the dictionaries to the DataTypeDefinion attribute, if possible.
        /// - Create all structured types from the dictionaries using the converted DataTypeDefinion attribute..
        /// </remarks>
        public async Task<bool> Load(bool onlyEnumTypes = false, bool throwOnError = false)
        {
            try
            {
                // load server types
                IList<INode> serverEnumTypes = LoadDataTypes(DataTypeIds.Enumeration);
                IList<INode> serverStructTypes = onlyEnumTypes ? new List<INode>() : LoadDataTypes(DataTypeIds.Structure, true);
                if (DisableDataTypeDefinition || !LoadBaseDataTypes(serverEnumTypes, serverStructTypes))
                {
                    if (DisableDataTypeDictionary)
                    {
                        return false;
                    }
                    return await LoadDictionaryDataTypes(serverEnumTypes, serverStructTypes, true).ConfigureAwait(false);
                }
                return true;
            }
            catch (ServiceResultException sre)
            {
                Utils.Trace(sre, $"Failed to load the custom type dictionary.");
                if (throwOnError)
                {
                    throw;
                }
                return false;
            }
        }

        /// <summary>
        /// Get the types defined in this type system.
        /// </summary>
        public Type[] GetDefinedTypes()
        {
            return m_complexTypeBuilderFactory.GetTypes();
        }
        #endregion

        #region Internal Properties
        /// <summary>
        /// Disable the use of DataTypeDefinition to create the complex type definition.
        /// </summary>
        internal bool DisableDataTypeDefinition { get; set; } = false;

        /// <summary>
        /// Disable the use of DataType Dictinaries to create the complex type definition.
        /// </summary>
        internal bool DisableDataTypeDictionary { get; set; } = false;
        #endregion

        #region Private Members
        /// <summary>
        /// Load listed custom types from dictionaries
        /// into the sessions system type factory.
        /// </summary>
        /// <remarks>
        /// Loads all custom types at this time to avoid
        /// complexity when resolving type dependencies.
        /// </remarks>
        private async Task<bool> LoadDictionaryDataTypes(
            IList<INode> serverEnumTypes,
            IList<INode> serverStructTypes,
            bool fullTypeList
            )
        {
            // build a type dictionary with all known new types
            var allEnumTypes = fullTypeList ? serverEnumTypes : LoadDataTypes(DataTypeIds.Enumeration);
            var typeDictionary = new Dictionary<XmlQualifiedName, NodeId>();

            // strip known types from list
            serverEnumTypes = RemoveKnownTypes(allEnumTypes);

            // load the binary schema dictionaries from the server
            var typeSystem = await m_session.LoadDataTypeSystem().ConfigureAwait(false);

            // sort dictionaries with import dependencies to the end of the list
            var sortedTypeSystem = typeSystem.OrderBy(t => t.Value.TypeDictionary?.Import?.Count()).ToList();

            bool allTypesLoaded = true;

            // create custom types for all dictionaries
            foreach (var dictionaryId in sortedTypeSystem)
            {
                try
                {
                    var dictionary = dictionaryId.Value;
                    if (dictionary.TypeDictionary == null ||
                        dictionary.TypeDictionary.Items == null)
                    {
                        continue;
                    }
                    var targetDictionaryNamespace = dictionary.TypeDictionary.TargetNamespace;
                    var targetNamespaceIndex = m_session.NamespaceUris.GetIndex(targetDictionaryNamespace);
                    var structureList = new List<Schema.Binary.TypeDescription>();
                    var enumList = new List<Opc.Ua.Schema.Binary.TypeDescription>();

                    // split into enumeration and structure types and sort
                    // types with dependencies to the end of the list.
                    SplitAndSortDictionary(dictionary, structureList, enumList);

                    // create assembly for all types in the same module
                    var complexTypeBuilder = m_complexTypeBuilderFactory.Create(
                        targetDictionaryNamespace,
                        targetNamespaceIndex,
                        dictionary.Name);

                    // Add all unknown enumeration types in dictionary
                    AddEnumTypes(complexTypeBuilder, typeDictionary, enumList, allEnumTypes, serverEnumTypes);

                    // handle structures
                    int lastStructureCount = 0;
                    while (structureList.Count > 0 &&
                        structureList.Count != lastStructureCount)
                    {
                        lastStructureCount = structureList.Count;
                        var retryStructureList = new List<Schema.Binary.TypeDescription>();
                        // build structured types
                        foreach (var item in structureList)
                        {
                            if (item is Opc.Ua.Schema.Binary.StructuredType structuredObject)
                            {   // note: the BrowseName contains the actual Value string of the DataType node.
                                var nodeId = dictionary.DataTypes.FirstOrDefault(d => d.Value.BrowseName.Name == item.Name).Value;
                                if (nodeId == null)
                                {
                                    Utils.Trace(TraceMasks.Error, $"Skip the type definition of {item.Name} because the data type node was not found.");
                                    continue;
                                }

                                // find the data type node and the binary encoding id
                                ExpandedNodeId typeId;
                                ExpandedNodeId binaryEncodingId;
                                DataTypeNode dataTypeNode;
                                bool newTypeDescription = BrowseTypeIdsForDictionaryComponent(
                                    ExpandedNodeId.ToNodeId(nodeId.NodeId, m_session.NamespaceUris),
                                    out typeId,
                                    out binaryEncodingId,
                                    out dataTypeNode);

                                if (!newTypeDescription)
                                {
                                    Utils.Trace(TraceMasks.Error, $"Skip the type definition of {item.Name} because the data type node was not found.");
                                    continue;
                                }

                                if (GetSystemType(typeId) != null)
                                {
                                    var qName = structuredObject.QName ?? new XmlQualifiedName(structuredObject.Name, targetDictionaryNamespace);
                                    typeDictionary[qName] = ExpandedNodeId.ToNodeId(typeId, m_session.NamespaceUris);
                                    Utils.Trace(TraceMasks.Information, $"Skip the type definition of {item.Name} because the type already exists.");
                                    continue;
                                }

                                // Use DataTypeDefinition attribute, if available (>=V1.04)
                                StructureDefinition structureDefinition = null;
                                if (!DisableDataTypeDefinition)
                                {
                                    structureDefinition = GetStructureDefinition(dataTypeNode);
                                }
                                if (structureDefinition == null)
                                {
                                    try
                                    {
                                        // convert the binary schema description to a StructureDefinition
                                        structureDefinition = structuredObject.ToStructureDefinition(
                                            binaryEncodingId,
                                            typeDictionary,
                                            m_session.NamespaceUris);
                                    }
                                    catch (DataTypeNotFoundException typeNotFoundException)
                                    {
                                        Utils.Trace(typeNotFoundException,
                                            $"Skipped the type definition of {item.Name}. Retry in next round.");
                                        retryStructureList.Add(item);
                                        continue;
                                    }
                                    catch (DataTypeNotSupportedException typeNotSupportedException)
                                    {
                                        Utils.Trace(typeNotSupportedException,
                                            $"Skipped the type definition of {item.Name} because it is not supported.");
                                        continue;
                                    }
                                    catch (ServiceResultException sre)
                                    {
                                        Utils.Trace(sre, $"Skip the type definition of {item.Name}.");
                                        continue;
                                    }
                                }

                                Type complexType = null;
                                if (structureDefinition != null)
                                {
                                    var encodingIds = BrowseForEncodings(typeId, m_supportedEncodings,
                                        out binaryEncodingId, out ExpandedNodeId xmlEncodingId);
                                    try
                                    {
                                        // build the actual .Net structured type in assembly
                                        complexType = AddStructuredType(
                                            complexTypeBuilder,
                                            structureDefinition,
                                            dataTypeNode.BrowseName,
                                            typeId,
                                            binaryEncodingId,
                                            xmlEncodingId
                                            );
                                    }
                                    catch (DataTypeNotFoundException typeNotFoundException)
                                    {
                                        Utils.Trace(typeNotFoundException,
                                            $"Skipped the type definition of {item.Name}. Retry in next round.");
                                        retryStructureList.Add(item);
                                        continue;
                                    }
                                    catch (DataTypeNotSupportedException typeNotSupportedException)
                                    {
                                        Utils.Trace(typeNotSupportedException,
                                            $"Skipped the type definition of {item.Name} because it is not supported.");
                                        continue;
                                    }

                                    // Add new type to factory
                                    if (complexType != null)
                                    {
                                        // match namespace and add new type to type factory
                                        foreach (var encodingId in encodingIds)
                                        {
                                            AddEncodeableType(encodingId, complexType);
                                        }
                                        AddEncodeableType(typeId, complexType);
                                        var qName = structuredObject.QName ?? new XmlQualifiedName(structuredObject.Name, targetDictionaryNamespace);
                                        typeDictionary[qName] = ExpandedNodeId.ToNodeId(typeId, m_session.NamespaceUris);
                                    }
                                }

                                if (complexType == null)
                                {
                                    retryStructureList.Add(item);
                                    Utils.Trace(TraceMasks.Error, $"Skipped the type definition of {item.Name}. Retry in next round.");
                                }
                            }
                        }
                        structureList = retryStructureList;
                    }
                    allTypesLoaded = allTypesLoaded && structureList.Count == 0;
                }
                catch (ServiceResultException sre)
                {
                    Utils.Trace(sre,
                        $"Unexpected error processing {dictionaryId.Value.Name}.");
                }
            }
            return allTypesLoaded;
        }

        /// <summary>
        /// Load all custom types with DataTypeDefinition into the type factory.
        /// </summary>
        /// <returns>true if all types were loaded, false otherwise</returns>
        private bool LoadBaseDataTypes(
            IList<INode> serverEnumTypes,
            IList<INode> serverStructTypes
            )
        {
            bool repeatDataTypeLoad = false; ;
            IList<INode> enumTypesToDoList = new List<INode>();
            IList<INode> structTypesToDoList = new List<INode>();

            do
            {
                // strip known types
                serverEnumTypes = RemoveKnownTypes(serverEnumTypes);
                serverStructTypes = RemoveKnownTypes(serverStructTypes);

                repeatDataTypeLoad = false;
                try
                {
                    enumTypesToDoList = LoadBaseEnumDataTypes(serverEnumTypes);
                    structTypesToDoList = LoadBaseStructureDataTypes(serverStructTypes);
                }
                catch (DataTypeNotFoundException dtnfex)
                {
                    // add missing type to list
                    var dataTypeNode = m_session.NodeCache.Find(dtnfex.nodeId);
                    if (dataTypeNode != null)
                    {
                        AddEnumerationOrStructureType(dataTypeNode, serverEnumTypes, serverStructTypes);
                        repeatDataTypeLoad = true;
                    }
                }
            } while (repeatDataTypeLoad);

            // all types loaded
            return enumTypesToDoList.Count == 0 && structTypesToDoList.Count == 0;
        }

        /// <summary>
        /// Load all custom types with DataTypeDefinition into the type factory.
        /// </summary>
        /// <returns>true if all types were loaded, false otherwise</returns>
        private IList<INode> LoadBaseEnumDataTypes(
            IList<INode> serverEnumTypes
            )
        {
            // strip known types
            serverEnumTypes = RemoveKnownTypes(serverEnumTypes);

            // add new enum Types for all namespaces
            var enumTypesToDoList = new List<INode>();
            int namespaceCount = m_session.NamespaceUris.Count;

            // create enumeration types for all namespaces
            for (uint i = 0; i < namespaceCount; i++)
            {
                IComplexTypeBuilder complexTypeBuilder = null;
                var enumTypes = serverEnumTypes.Where(node => node.NodeId.NamespaceIndex == i).ToList();
                if (enumTypes.Count != 0)
                {
                    if (complexTypeBuilder == null)
                    {
                        string targetNamespace = m_session.NamespaceUris.GetString(i);
                        complexTypeBuilder = m_complexTypeBuilderFactory.Create(
                            targetNamespace,
                            (int)i);
                    }
                    foreach (var enumType in enumTypes)
                    {
                        var newType = AddEnumType(complexTypeBuilder, enumType as DataTypeNode);
                        if (newType != null)
                        {
                            // match namespace and add to type factory
                            AddEncodeableType(enumType.NodeId, newType);
                        }
                        else
                        {
                            enumTypesToDoList.Add(enumType);
                        }
                    }
                }
            }

            // all types loaded, return remaining
            return enumTypesToDoList;
        }

        /// <summary>
        /// Load all structure custom types with DataTypeDefinition into the type factory.
        /// </summary>
        /// <returns>true if all types were loaded, false otherwise</returns>
        private IList<INode> LoadBaseStructureDataTypes(
            IList<INode> serverStructTypes
            )
        {
            // strip known types
            serverStructTypes = RemoveKnownTypes(serverStructTypes);

            // add new enum Types for all namespaces
            int namespaceCount = m_session.NamespaceUris.Count;

            bool retryAddStructType;
            var structTypesToDoList = new List<INode>();
            var structTypesWorkList = serverStructTypes;

            // create structured types for all namespaces
            do
            {
                retryAddStructType = false;
                for (uint i = 0; i < namespaceCount; i++)
                {
                    IComplexTypeBuilder complexTypeBuilder = null;
                    var structTypes = structTypesWorkList.Where(node => node.NodeId.NamespaceIndex == i).ToList();
                    if (structTypes.Count != 0)
                    {
                        if (complexTypeBuilder == null)
                        {
                            string targetNamespace = m_session.NamespaceUris.GetString(i);
                            complexTypeBuilder = m_complexTypeBuilderFactory.Create(
                                targetNamespace,
                                (int)i);
                        }
                        foreach (INode structType in structTypes)
                        {
                            Type newType = null;
                            if (!(structType is DataTypeNode dataTypeNode))
                            {
                                continue;
                            }
                            var structureDefinition = GetStructureDefinition(dataTypeNode);
                            if (structureDefinition != null)
                            {
                                var encodingIds = BrowseForEncodings(structType.NodeId, m_supportedEncodings,
                                    out ExpandedNodeId binaryEncodingId, out ExpandedNodeId xmlEncodingId);
                                try
                                {
                                    newType = AddStructuredType(
                                        complexTypeBuilder,
                                        structureDefinition,
                                        dataTypeNode.BrowseName,
                                        structType.NodeId,
                                        binaryEncodingId,
                                        xmlEncodingId
                                        );
                                }
                                catch (DataTypeNotFoundException dtnfex)
                                {
                                    var typeMatch = structTypesWorkList.FirstOrDefault(n => n.NodeId == dtnfex.nodeId);
                                    if (typeMatch == null)
                                    {
                                        throw;
                                    }
                                    else
                                    {   // known missing type, retry on next round
                                        Utils.Trace(dtnfex, "Skipped the type definition of {0}. Retry in next round.", dataTypeNode.BrowseName.Name);
                                        retryAddStructType = true;
                                    }
                                }
                                catch (DataTypeNotSupportedException dtnsex)
                                {
                                    Utils.Trace(dtnsex, "Skipped the type definition of {0} because it is not supported.", dataTypeNode.BrowseName.Name);
                                    continue;
                                }
                                catch
                                {
                                    // creating the new type failed, likely a missing dependency, retry later
                                    retryAddStructType = true;
                                }
                                if (newType != null)
                                {
                                    foreach (var encodingId in encodingIds)
                                    {
                                        AddEncodeableType(encodingId, newType);
                                    }
                                    AddEncodeableType(structType.NodeId, newType);
                                }
                            }
                            if (newType == null)
                            {
                                structTypesToDoList.Add(structType);
                            }
                        }
                    }
                }
                // due to type dependencies, retry missing types until there is no more progress
                if (retryAddStructType &&
                    structTypesWorkList.Count != structTypesToDoList.Count)
                {
                    structTypesWorkList = structTypesToDoList;
                    structTypesToDoList = new List<INode>();
                }
            } while (retryAddStructType);

            // all types loaded
            return structTypesToDoList;
        }

        /// <summary>
        /// Return the structure definition from a DataTypeDefinition
        /// </summary>
        private StructureDefinition GetStructureDefinition(DataTypeNode dataTypeNode)
        {
            if (dataTypeNode.DataTypeDefinition?.Body is StructureDefinition structureDefinition)
            {
                // Validate the DataTypeDefinition structure,
                // but not if the type is supported
                if (structureDefinition.Fields == null ||
                    structureDefinition.BaseDataType.IsNullNodeId ||
                    structureDefinition.BinaryEncodingId.IsNull)
                {
                    return null;
                }
                // Validate the structure according to Part3, Table 36
                foreach (var field in structureDefinition.Fields)
                {
                    // validate if the DataTypeDefinition is correctly
                    // filled out, some servers don't do it yet...
                    if (field.BinaryEncodingId.IsNull ||
                        field.DataType.IsNullNodeId ||
                        field.TypeId.IsNull ||
                        field.Name == null)
                    {
                        return null;
                    }
                    if (!(field.ValueRank == -1 ||
                        field.ValueRank >= 1))
                    {
                        return null;
                    }
                    if (structureDefinition.StructureType == StructureType.Structure &&
                        field.IsOptional)
                    {
                        return null;
                    }
                }
                return structureDefinition;
            }
            return null;

        }

        /// <summary>
        /// Helper to ensure the expanded nodeId contains a valid namespaceUri.
        /// </summary>
        /// <param name="expandedNodeId">The expanded nodeId.</param>
        /// <returns>The normalized expanded nodeId.</returns>
        private ExpandedNodeId NormalizeExpandedNodeId(ExpandedNodeId expandedNodeId)
        {
            var nodeId = ExpandedNodeId.ToNodeId(expandedNodeId, m_session.NamespaceUris);
            return NodeId.ToExpandedNodeId(nodeId, m_session.NamespaceUris);
        }

        /// <summary>
        /// Browse for the type and encoding id for a dictionary component.
        /// </summary>
        /// <remarks>
        /// According to Part 5 Annex D, servers shall provide the bi-directional
        /// references between data types, data type encodings, data type description
        /// and data type dictionary.
        /// To find the typeId and encodingId for a dictionary type definition:
        /// i) inverse browse the description to get the encodingid
        /// ii) from the description inverse browse for encoding 
        /// to get the subtype typeid 
        /// iii) load the DataType node 
        /// </remarks>
        /// <param name="nodeId"></param>
        /// <param name="typeId"></param>
        /// <param name="encodingId"></param>
        /// <param name="dataTypeNode"></param>
        /// <returns>true if successful, false otherwise</returns>
        private bool BrowseTypeIdsForDictionaryComponent(
            NodeId nodeId,
            out ExpandedNodeId typeId,
            out ExpandedNodeId encodingId,
            out DataTypeNode dataTypeNode)
        {
            typeId = ExpandedNodeId.Null;
            encodingId = ExpandedNodeId.Null;
            dataTypeNode = null;

            var references = m_session.NodeCache.FindReferences(
                nodeId,
                ReferenceTypeIds.HasDescription,
                true,
                false
                );

            if (references.Count == 1)
            {
                encodingId = references[0].NodeId;
                references = m_session.NodeCache.FindReferences(
                    encodingId,
                    ReferenceTypeIds.HasEncoding,
                    true,
                    false
                    );
                encodingId = NormalizeExpandedNodeId(encodingId);

                if (references.Count == 1)
                {
                    typeId = references[0].NodeId;
                    dataTypeNode = m_session.NodeCache.Find(typeId) as DataTypeNode;
                    typeId = NormalizeExpandedNodeId(typeId);
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Browse for the property.
        /// </summary>
        /// <remarks>
        /// Browse for property (type description) of an enum datatype.
        /// </remarks>
        /// <param name="nodeId"></param>
        /// <returns></returns>
        private INode BrowseForSingleProperty(
            ExpandedNodeId nodeId)
        {
            var references = m_session.NodeCache.FindReferences(
                nodeId,
                ReferenceTypeIds.HasProperty,
                false,
                false
                );
            return references.FirstOrDefault();
        }

        /// <summary>
        /// Browse for the encodings of a type.
        /// </summary>
        /// <remarks>
        /// Browse for binary encoding of a structure datatype.
        /// </remarks>
        private IList<NodeId> BrowseForEncodings(
            ExpandedNodeId nodeId,
            string[] supportedEncodings,
            out ExpandedNodeId binaryEncodingId,
            out ExpandedNodeId xmlEncodingId)
        {
            var references = m_session.NodeCache.FindReferences(
                nodeId,
                ReferenceTypeIds.HasEncoding,
                false,
                false
                );
            binaryEncodingId = references.FirstOrDefault(r => r.BrowseName.Name == BrowseNames.DefaultBinary)?.NodeId;
            binaryEncodingId = NormalizeExpandedNodeId(binaryEncodingId);
            xmlEncodingId = references.FirstOrDefault(r => r.BrowseName.Name == BrowseNames.DefaultXml)?.NodeId;
            xmlEncodingId = NormalizeExpandedNodeId(xmlEncodingId);
            return references.Where(r => supportedEncodings.Contains(r.BrowseName.Name))
                .Select(r => ExpandedNodeId.ToNodeId(r.NodeId, m_session.NamespaceUris)).ToList();
        }

        /// <summary>
        /// Load all subTypes and optionally nested subtypes of a type definition.
        /// Filter for all subtypes or only subtypes outside the default namespace.
        /// </summary>
        private IList<INode> LoadDataTypes(
            ExpandedNodeId dataType,
            bool nestedSubTypes = false,
            bool addRootNode = false,
            bool filterUATypes = true)
        {
            var result = new List<INode>();
            var nodesToBrowse = new ExpandedNodeIdCollection {
                dataType
            };

            if (addRootNode)
            {
                var rootNode = m_session.NodeCache.Find(dataType);
                if (!(rootNode is DataTypeNode))
                {
                    throw new ServiceResultException("Root Node is not a DataType node.");
                }
                result.Add(rootNode);
            }

            while (nodesToBrowse.Count > 0)
            {
                var nextNodesToBrowse = new ExpandedNodeIdCollection();
                foreach (var node in nodesToBrowse)
                {
                    var response = m_session.NodeCache.FindReferences(
                        node,
                        ReferenceTypeIds.HasSubtype,
                        false,
                        false);

                    if (nestedSubTypes)
                    {
                        nextNodesToBrowse.AddRange(response.Select(r => r.NodeId).ToList());
                    }
                    if (filterUATypes)
                    {
                        // filter out default namespace
                        result.AddRange(response.Where(rd => rd.NodeId.NamespaceIndex != 0));
                    }
                    else
                    {
                        result.AddRange(response);
                    }
                }
                nodesToBrowse = nextNodesToBrowse;
            }

            return result;
        }

        /// <summary>
        /// Add data type to enumeration or structure base type list depending on supertype.
        /// </summary>
        private void AddEnumerationOrStructureType(INode dataTypeNode, IList<INode> serverEnumTypes, IList<INode> serverStructTypes)
        {
            NodeId superType = ExpandedNodeId.ToNodeId(dataTypeNode.NodeId, m_session.NamespaceUris);
            do
            {
                superType = m_session.NodeCache.FindSuperType(superType);
                if (superType.IsNullNodeId)
                {
                    throw new ServiceResultException(StatusCodes.BadNodeIdInvalid, $"SuperType for {dataTypeNode.NodeId} not found.");
                }
                if (superType == DataTypeIds.Enumeration)
                {
                    serverEnumTypes.Insert(0, dataTypeNode);
                    break;
                }
                else if (superType == DataTypeIds.Structure)
                {
                    serverStructTypes.Insert(0, dataTypeNode);
                    break;
                }
                else if (TypeInfo.GetBuiltInType(superType) != BuiltInType.Null)
                {
                    break;
                }
            } while (true);
        }

        /// <summary>
        /// Remove all known types in the type factory from a list of DataType nodes.
        /// </summary>
        private IList<INode> RemoveKnownTypes(IList<INode> nodeList)
        {
            return nodeList.Where(
                node => GetSystemType(node.NodeId) == null).ToList();
        }

        /// <summary>
        /// Get the factory system type for an expanded node id.
        /// </summary>
        private Type GetSystemType(ExpandedNodeId nodeId)
        {
            if (!nodeId.IsAbsolute)
            {
                nodeId = NormalizeExpandedNodeId(nodeId);
            }
            return m_session.Factory.GetSystemType(nodeId);
        }

        /// <summary>
        /// Add an enum type defined in a binary schema dictionary.
        /// </summary>
        private void AddEnumTypes(
            IComplexTypeBuilder complexTypeBuilder,
            Dictionary<XmlQualifiedName, NodeId> typeDictionary,
            IList<Opc.Ua.Schema.Binary.TypeDescription> enumList,
            IList<INode> allEnumerationTypes,
            IList<INode> enumerationTypes
            )
        {
            foreach (var item in enumList)
            {
                Type newType = null;
                DataTypeNode enumDescription = null;
                DataTypeNode enumType = enumerationTypes.FirstOrDefault(node =>
                    node.BrowseName.Name == item.Name &&
                    (node.BrowseName.NamespaceIndex == complexTypeBuilder.TargetNamespaceIndex ||
                    complexTypeBuilder.TargetNamespaceIndex == -1))
                    as DataTypeNode;
                if (enumType != null)
                {
                    enumDescription = enumType;
                    // try dictionary enum definition
                    var enumeratedObject = item as Schema.Binary.EnumeratedType;
                    if (enumeratedObject != null)
                    {
                        // 1. use Dictionary entry
                        newType = complexTypeBuilder.AddEnumType(enumeratedObject);
                    }
                    if (newType == null)
                    {
                        var dataType = m_session.NodeCache.Find(enumType.NodeId) as DataTypeNode;
                        if (dataType != null)
                        {
                            if (dataType.DataTypeDefinition != null)
                            {
                                // 2. use DataTypeDefinition 
                                newType = complexTypeBuilder.AddEnumType(enumType.BrowseName.Name, dataType.DataTypeDefinition);
                            }
                            else
                            {
                                // browse for EnumFields or EnumStrings property
                                var property = BrowseForSingleProperty(enumType.NodeId);
                                var enumArray = m_session.ReadValue(
                                    ExpandedNodeId.ToNodeId(property.NodeId, m_session.NamespaceUris));
                                if (enumArray.Value is ExtensionObject[])
                                {
                                    // 3. use EnumValues
                                    newType = complexTypeBuilder.AddEnumType(enumType.BrowseName.Name, (ExtensionObject[])enumArray.Value);
                                }
                                else if (enumArray.Value is LocalizedText[])
                                {
                                    // 4. use EnumStrings
                                    newType = complexTypeBuilder.AddEnumType(enumType.BrowseName.Name, (LocalizedText[])enumArray.Value);
                                }
                            }
                        }
                    }
                }
                else
                {
                    enumDescription = allEnumerationTypes.FirstOrDefault(node =>
                        node.BrowseName.Name == item.Name &&
                        (node.BrowseName.NamespaceIndex == complexTypeBuilder.TargetNamespaceIndex ||
                        complexTypeBuilder.TargetNamespaceIndex == -1))                        as DataTypeNode;
                }
                if (enumDescription != null)
                {
                    var qName = new XmlQualifiedName(item.Name, complexTypeBuilder.TargetNamespace);
                    typeDictionary[qName] = enumDescription.NodeId;
                }
                if (newType != null)
                {
                    // match namespace and add to type factory
                    AddEncodeableType(enumType.NodeId, newType);
                }
            }
        }

        /// <summary>
        /// Helper to add new type with absolute ExpandedNodeId.
        /// </summary>
        private void AddEncodeableType(ExpandedNodeId nodeId, Type type)
        {
            if (NodeId.IsNull(nodeId) || type == null)
            {
                return;
            }
            var internalNodeId = NormalizeExpandedNodeId(nodeId);
            Utils.TraceDebug($"Adding Type {type.FullName} as: {internalNodeId.ToString()}");
            m_session.Factory.AddEncodeableType(internalNodeId, type);
        }

        /// <summary>
        /// Add an enum type defined in a DataType node.
        /// </summary>
        private Type AddEnumType(
            IComplexTypeBuilder complexTypeBuilder,
            DataTypeNode enumTypeNode
            )
        {
            Type newType = null;
            if (enumTypeNode != null)
            {
                QualifiedName name = enumTypeNode.BrowseName;
                if (enumTypeNode.DataTypeDefinition != null)
                {
                    // 1. use DataTypeDefinition 
                    newType = complexTypeBuilder.AddEnumType(name, enumTypeNode.DataTypeDefinition);
                }
                else
                {
                    // browse for EnumFields or EnumStrings property
                    var property = BrowseForSingleProperty(enumTypeNode.NodeId);
                    if (property != null)
                    {
                        var enumArray = m_session.ReadValue(
                            ExpandedNodeId.ToNodeId(property.NodeId,
                            m_session.NamespaceUris));
                        if (enumArray.Value is ExtensionObject[])
                        {
                            // 2. use EnumValues
                            newType = complexTypeBuilder.AddEnumType(name, (ExtensionObject[])enumArray.Value);
                        }
                        else if (enumArray.Value is LocalizedText[])
                        {
                            // 3. use EnumStrings
                            newType = complexTypeBuilder.AddEnumType(name, (LocalizedText[])enumArray.Value);
                        }
                    }
                }
            }
            return newType;
        }

        /// <summary>
        /// Add structured type to assembly with StructureDefinition.
        /// </summary>
        private Type AddStructuredType(
            IComplexTypeBuilder complexTypeBuilder,
            StructureDefinition structureDefinition,
            QualifiedName typeName,
            ExpandedNodeId complexTypeId,
            ExpandedNodeId binaryEncodingId,
            ExpandedNodeId xmlEncodingId
            )
        {
            // check all types
            var typeList = new List<Type>();
            foreach (StructureField field in structureDefinition.Fields)
            {
                var newType = GetFieldType(field);
                if (newType == null)
                {
                    throw new DataTypeNotFoundException(field.DataType);
                }
                typeList.Add(newType);
            }

            var fieldBuilder = complexTypeBuilder.AddStructuredType(
                typeName,
                structureDefinition
                );

            fieldBuilder.AddTypeIdAttribute(complexTypeId, binaryEncodingId, xmlEncodingId);

            int order = 1;
            var typeListEnumerator = typeList.GetEnumerator();
            foreach (StructureField field in structureDefinition.Fields)
            {
                typeListEnumerator.MoveNext();
                fieldBuilder.AddField(field, typeListEnumerator.Current, order);
                order++;
            }

            return fieldBuilder.CreateType();
        }

        /// <summary>
        /// Determine the type of a field in a StructureField definition.
        /// </summary>
        private Type GetFieldType(StructureField field)
        {
            Type collectionType = null;

            if (field.ValueRank != ValueRanks.Scalar &&
                field.ValueRank != ValueRanks.OneDimension)
            {
                throw new DataTypeNotSupportedException(field.DataType, $"The ValueRank {field.ValueRank} is not supported.");
            }

            Type fieldType = field.DataType.NamespaceIndex == 0 ?
                Opc.Ua.TypeInfo.GetSystemType(field.DataType, m_session.Factory) :
                GetSystemType(field.DataType);
            if (fieldType == null)
            {
                var superType = GetBuiltInSuperType(field.DataType);
                if (superType != null &&
                    !superType.IsNullNodeId)
                {
                    field.DataType = superType;
                    return GetFieldType(field);
                }
                return null;
            }

            if (field.DataType.NamespaceIndex == 0)
            {
                if (field.ValueRank == ValueRanks.OneDimension)
                {
                    if (fieldType == typeof(Byte[]))
                    {
                        collectionType = typeof(ByteStringCollection);
                    }
                    else if (fieldType == typeof(Single))
                    {
                        collectionType = typeof(FloatCollection);
                    }
                    else
                    {
                        var assemblyQualifiedName = typeof(StatusCode).Assembly;
                        String collectionClassName = "Opc.Ua." + fieldType.Name + "Collection, " + assemblyQualifiedName;
                        collectionType = Type.GetType(collectionClassName);
                    }
                }
            }
            else
            {
                if (field.ValueRank == ValueRanks.OneDimension)
                {
                    String collectionClassName = (fieldType.Namespace != null) ? fieldType.Namespace + "." : "";
                    collectionClassName += fieldType.Name + "Collection, " + fieldType.Assembly;
                    collectionType = Type.GetType(collectionClassName);
                }
            }

            if (field.ValueRank == ValueRanks.OneDimension)
            {
                fieldType = collectionType ?? fieldType.MakeArrayType();
            }

            return fieldType;
        }

        /// <summary>
        /// Find superType for a datatype.
        /// </summary>
        private NodeId GetBuiltInSuperType(NodeId dataType)
        {
            var superType = dataType;
            do
            {
                superType = m_session.NodeCache.FindSuperType(superType);
                if (superType == null ||
                    superType.IsNullNodeId)
                {
                    return null;
                }
                if (superType.NamespaceIndex == 0)
                {
                    if (superType == DataTypeIds.Enumeration ||
                        superType == DataTypeIds.Structure)
                    {
                        return null;
                    }
                    break;
                }
            } while (true);
            return superType;
        }

        /// <summary>
        /// Split the dictionary types into a list of structures and enumerations.
        /// Sort the structures by dependencies, with structures with dependent
        /// types at the end of the list, so they can be added to the factory in order.
        /// </summary>
        private void SplitAndSortDictionary(
                DataDictionary dictionary,
                List<Schema.Binary.TypeDescription> structureList,
                List<Schema.Binary.TypeDescription> enumList
                )
        {
            foreach (var item in dictionary.TypeDictionary.Items)
            {
                if (item is Opc.Ua.Schema.Binary.StructuredType structuredObject)
                {
                    var dependentFields = structuredObject.Field.Where(f => f.TypeName.Namespace == dictionary.TypeDictionary.TargetNamespace);
                    if (!dependentFields.Any())
                    {
                        structureList.Insert(0, structuredObject);
                    }
                    else
                    {
                        structureList.Add(structuredObject);
                    }
                }
                else if (item is Opc.Ua.Schema.Binary.EnumeratedType)
                {
                    enumList.Add(item);
                }
                else if (item is Opc.Ua.Schema.Binary.OpaqueType)
                {
                    // TODO: Opaque types not supported yet
                }
                else
                {
                    throw new ServiceResultException(StatusCodes.BadUnexpectedError, $"Unexpected Type in binary schema: {item.GetType().Name}.");
                }
            }
        }
        #endregion

        #region Private Fields
        private Session m_session;
        private IComplexTypeFactory m_complexTypeBuilderFactory;
        private string[] m_supportedEncodings = new string[] { BrowseNames.DefaultBinary, BrowseNames.DefaultXml, BrowseNames.DefaultJson };
        private const string kOpcComplexTypesPrefix = "Opc.Ua.ComplexTypes.";
        #endregion
    }
}//namespace

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Xml;
using static Opc.Ua.Utils;

namespace Opc.Ua.Client.ComplexTypes
{
    /// <summary>
    /// Manages the custom types of a server for a client session.
    /// Loads the custom types into the type factory
    /// of a client session, to allow for decoding and encoding
    /// of custom enumeration types and structured types.
    /// </summary>
    /// <remarks>
    /// Support for V1.03 dictionaries and all V1.04 data type definitions
    /// with the following known restrictions:
    /// - Support only for V1.03 structured types which can be mapped to the V1.04
    /// structured type definition. Unsupported V1.03 types are ignored.
    /// - V1.04 OptionSet does not create the enumeration flags. 
    /// </remarks>
    public class ComplexTypeSystem
    {

        #region Constructors
        /// <summary>
        /// Initializes the type system with a session to load the custom types.
        /// </summary>
        public ComplexTypeSystem(Session session)
        {
            Initialize(session, new ComplexTypeBuilderFactory());
        }

        /// <summary>
        /// Initializes the type system with a session to load the custom types
        /// and a customized type builder factory
        /// </summary>
        public ComplexTypeSystem(
            Session session,
            IComplexTypeFactory complexTypeBuilderFactory)
        {
            Initialize(session, complexTypeBuilderFactory);
        }

        private void Initialize(
            Session session,
            IComplexTypeFactory complexTypeBuilderFactory)
        {
            m_session = session;
            m_complexTypeBuilderFactory = complexTypeBuilderFactory;
        }
        #endregion

        #region Public Members
        /// <summary>
        /// Load a single custom type with subtypes.
        /// </summary>
        /// <remarks>
        /// Uses inverse references on the server to find the super type(s).
        /// If the new structure contains a type dependency to a yet
        /// unknown type, it loads also the dependent type(s).
        /// For servers without DataTypeDefinition support all
        /// custom types are loaded.
        /// </remarks>
        public async Task<Type> LoadType(ExpandedNodeId nodeId, bool subTypes = false, bool throwOnError = false)
        {
            try
            {
                var subTypeNodes = LoadDataTypes(nodeId, subTypes, true);
                var subTypeNodesWithoutKnownTypes = RemoveKnownTypes(subTypeNodes);

                if (subTypeNodesWithoutKnownTypes.Count > 0)
                {
                    IList<INode> serverEnumTypes = new List<INode>();
                    IList<INode> serverStructTypes = new List<INode>();
                    foreach (var node in subTypeNodesWithoutKnownTypes)
                    {
                        AddEnumerationOrStructureType(node, serverEnumTypes, serverStructTypes);
                    }

                    // load server types
                    if (DisableDataTypeDefinition || !LoadBaseDataTypes(serverEnumTypes, serverStructTypes))
                    {
                        if (!DisableDataTypeDictionary)
                        {
                            await LoadDictionaryDataTypes(serverEnumTypes, serverStructTypes, false).ConfigureAwait(false);
                        }
                    }
                }
                return GetSystemType(nodeId);
            }
            catch (ServiceResultException sre)
            {
                Utils.Trace(sre, "Failed to load the custom type {0}.", nodeId);
                if (throwOnError)
                {
                    throw;
                }
                return null;
            }
        }

        /// <summary>
        /// Load all custom types of a namespace.
        /// </summary>
        /// <remarks>
        /// If a new type in the namespace contains a type dependency to an
        /// unknown type in another namespace, it loads also the dependent type(s).
        /// For servers without DataTypeDefinition support all
        /// custom types are loaded.
        /// </remarks>
        public async Task<bool> LoadNamespace(string nameSpace, bool throwOnError = false)
        {
            try
            {
                int index = m_session.NamespaceUris.GetIndex(nameSpace);
                if (index < 0)
                {
                    throw new ServiceResultException($"Bad argument {nameSpace}. Namespace not found.");
                }
                ushort nameSpaceIndex = (ushort)index;
                var serverEnumTypes = LoadDataTypes(DataTypeIds.Enumeration);
                var serverStructTypes = LoadDataTypes(DataTypeIds.Structure, true);
                // filter for namespace
                serverEnumTypes = serverEnumTypes.Where(rd => rd.NodeId.NamespaceIndex == nameSpaceIndex).ToList();
                serverStructTypes = serverStructTypes.Where(rd => rd.NodeId.NamespaceIndex == nameSpaceIndex).ToList();
                // load types
                if (DisableDataTypeDefinition || !LoadBaseDataTypes(serverEnumTypes, serverStructTypes))
                {
                    if (DisableDataTypeDictionary)
                    {
                        return false;
                    }
                    return await LoadDictionaryDataTypes(serverEnumTypes, serverStructTypes, false).ConfigureAwait(false);
                }
                return true;
            }
            catch (ServiceResultException sre)
            {
                Utils.Trace(sre, $"Failed to load the custom type dictionary.");
                if (throwOnError)
                {
                    throw;
                }
                return false;
            }
        }

        /// <summary>
        /// Load all custom types from a server into the session system type factory.
        /// </summary>
        /// <remarks>
        /// The loader follows the following strategy:
        /// - Load all DataType nodes of the Enumeration subtypes.
        /// - Load all DataType nodes of the Structure subtypes.
        /// - Create all enumerated custom types using the DataTypeDefinion attribute, if available.
        /// - Create all remaining enumerated custom types using the EnumValues or EnumStrings property, if available.
        /// - Create all structured types using the DataTypeDefinion attribute, if available.
        /// if there are type definitions remaining
        /// - Load the binary schema dictionaries with type definitions.
        /// - Create all remaining enumerated custom types using the dictionaries.
        /// - Convert all structured types in the dictionaries to the DataTypeDefinion attribute, if possible.
        /// - Create all structured types from the dictionaries using the converted DataTypeDefinion attribute..
        /// </remarks>
        public async Task<bool> Load(bool onlyEnumTypes = false, bool throwOnError = false)
        {
            try
            {
                // load server types
                IList<INode> serverEnumTypes = LoadDataTypes(DataTypeIds.Enumeration);
                IList<INode> serverStructTypes = onlyEnumTypes ? new List<INode>() : LoadDataTypes(DataTypeIds.Structure, true);
                if (DisableDataTypeDefinition || !LoadBaseDataTypes(serverEnumTypes, serverStructTypes))
                {
                    if (DisableDataTypeDictionary)
                    {
                        return false;
                    }
                    return await LoadDictionaryDataTypes(serverEnumTypes, serverStructTypes, true).ConfigureAwait(false);
                }
                return true;
            }
            catch (ServiceResultException sre)
            {
                Utils.Trace(sre, $"Failed to load the custom type dictionary.");
                if (throwOnError)
                {
                    throw;
                }
                return false;
            }
        }

        /// <summary>
        /// Get the types defined in this type system.
        /// </summary>
        public Type[] GetDefinedTypes()
        {
            return m_complexTypeBuilderFactory.GetTypes();
        }
        #endregion

        #region Internal Properties
        /// <summary>
        /// Disable the use of DataTypeDefinition to create the complex type definition.
        /// </summary>
        internal bool DisableDataTypeDefinition { get; set; } = false;

        /// <summary>
        /// Disable the use of DataType Dictinaries to create the complex type definition.
        /// </summary>
        internal bool DisableDataTypeDictionary { get; set; } = false;
        #endregion

        #region Private Members
        /// <summary>
        /// Load listed custom types from dictionaries
        /// into the sessions system type factory.
        /// </summary>
        /// <remarks>
        /// Loads all custom types at this time to avoid
        /// complexity when resolving type dependencies.
        /// </remarks>
        private async Task<bool> LoadDictionaryDataTypes(
            IList<INode> serverEnumTypes,
            IList<INode> serverStructTypes,
            bool fullTypeList
            )
        {
            // build a type dictionary with all known new types
            var allEnumTypes = fullTypeList ? serverEnumTypes : LoadDataTypes(DataTypeIds.Enumeration);
            var typeDictionary = new Dictionary<XmlQualifiedName, NodeId>();

            // strip known types from list
            serverEnumTypes = RemoveKnownTypes(allEnumTypes);

            // load the binary schema dictionaries from the server
            var typeSystem = await m_session.LoadDataTypeSystem().ConfigureAwait(false);

            // sort dictionaries with import dependencies to the end of the list
            var sortedTypeSystem = typeSystem.OrderBy(t => t.Value.TypeDictionary?.Import?.Count()).ToList();

            bool allTypesLoaded = true;

            // create custom types for all dictionaries
            foreach (var dictionaryId in sortedTypeSystem)
            {
                try
                {
                    var dictionary = dictionaryId.Value;
                    if (dictionary.TypeDictionary == null ||
                        dictionary.TypeDictionary.Items == null)
                    {
                        continue;
                    }
                    var targetDictionaryNamespace = dictionary.TypeDictionary.TargetNamespace;
                    var targetNamespaceIndex = m_session.NamespaceUris.GetIndex(targetDictionaryNamespace);
                    var structureList = new List<Schema.Binary.TypeDescription>();
                    var enumList = new List<Opc.Ua.Schema.Binary.TypeDescription>();

                    // split into enumeration and structure types and sort
                    // types with dependencies to the end of the list.
                    SplitAndSortDictionary(dictionary, structureList, enumList);

                    // create assembly for all types in the same module
                    var complexTypeBuilder = m_complexTypeBuilderFactory.Create(
                        targetDictionaryNamespace,
                        targetNamespaceIndex,
                        dictionary.Name);

                    // Add all unknown enumeration types in dictionary
                    AddEnumTypes(complexTypeBuilder, typeDictionary, enumList, allEnumTypes, serverEnumTypes);

                    // handle structures
                    int lastStructureCount = 0;
                    while (structureList.Count > 0 &&
                        structureList.Count != lastStructureCount)
                    {
                        lastStructureCount = structureList.Count;
                        var retryStructureList = new List<Schema.Binary.TypeDescription>();
                        // build structured types
                        foreach (var item in structureList)
                        {
                            if (item is Opc.Ua.Schema.Binary.StructuredType structuredObject)
                            {   // note: the BrowseName contains the actual Value string of the DataType node.
                                var nodeId = dictionary.DataTypes.FirstOrDefault(d => d.Value.BrowseName.Name == item.Name).Value;
                                if (nodeId == null)
                                {
                                    Utils.Trace(TraceMasks.Error, $"Skip the type definition of {item.Name} because the data type node was not found.");
                                    continue;
                                }

                                // find the data type node and the binary encoding id
                                ExpandedNodeId typeId;
                                ExpandedNodeId binaryEncodingId;
                                DataTypeNode dataTypeNode;
                                bool newTypeDescription = BrowseTypeIdsForDictionaryComponent(
                                    ExpandedNodeId.ToNodeId(nodeId.NodeId, m_session.NamespaceUris),
                                    out typeId,
                                    out binaryEncodingId,
                                    out dataTypeNode);

                                if (!newTypeDescription)
                                {
                                    Utils.Trace(TraceMasks.Error, $"Skip the type definition of {item.Name} because the data type node was not found.");
                                    continue;
                                }

                                if (GetSystemType(typeId) != null)
                                {
                                    var qName = structuredObject.QName ?? new XmlQualifiedName(structuredObject.Name, targetDictionaryNamespace);
                                    typeDictionary[qName] = ExpandedNodeId.ToNodeId(typeId, m_session.NamespaceUris);
                                    Utils.Trace(TraceMasks.Information, $"Skip the type definition of {item.Name} because the type already exists.");
                                    continue;
                                }

                                // Use DataTypeDefinition attribute, if available (>=V1.04)
                                StructureDefinition structureDefinition = null;
                                if (!DisableDataTypeDefinition)
                                {
                                    structureDefinition = GetStructureDefinition(dataTypeNode);
                                }
                                if (structureDefinition == null)
                                {
                                    try
                                    {
                                        // convert the binary schema description to a StructureDefinition
                                        structureDefinition = structuredObject.ToStructureDefinition(
                                            binaryEncodingId,
                                            typeDictionary,
                                            m_session.NamespaceUris);
                                    }
                                    catch (DataTypeNotFoundException typeNotFoundException)
                                    {
                                        Utils.Trace(typeNotFoundException,
                                            $"Skipped the type definition of {item.Name}. Retry in next round.");
                                        retryStructureList.Add(item);
                                        continue;
                                    }
                                    catch (DataTypeNotSupportedException typeNotSupportedException)
                                    {
                                        Utils.Trace(typeNotSupportedException,
                                            $"Skipped the type definition of {item.Name} because it is not supported.");
                                        continue;
                                    }
                                    catch (ServiceResultException sre)
                                    {
                                        Utils.Trace(sre, $"Skip the type definition of {item.Name}.");
                                        continue;
                                    }
                                }

                                Type complexType = null;
                                if (structureDefinition != null)
                                {
                                    var encodingIds = BrowseForEncodings(typeId, m_supportedEncodings,
                                        out binaryEncodingId, out ExpandedNodeId xmlEncodingId);
                                    try
                                    {
                                        // build the actual .Net structured type in assembly
                                        complexType = AddStructuredType(
                                            complexTypeBuilder,
                                            structureDefinition,
                                            dataTypeNode.BrowseName,
                                            typeId,
                                            binaryEncodingId,
                                            xmlEncodingId
                                            );
                                    }
                                    catch (DataTypeNotFoundException typeNotFoundException)
                                    {
                                        Utils.Trace(typeNotFoundException,
                                            $"Skipped the type definition of {item.Name}. Retry in next round.");
                                        retryStructureList.Add(item);
                                        continue;
                                    }
                                    catch (DataTypeNotSupportedException typeNotSupportedException)
                                    {
                                        Utils.Trace(typeNotSupportedException,
                                            $"Skipped the type definition of {item.Name} because it is not supported.");
                                        continue;
                                    }

                                    // Add new type to factory
                                    if (complexType != null)
                                    {
                                        // match namespace and add new type to type factory
                                        foreach (var encodingId in encodingIds)
                                        {
                                            AddEncodeableType(encodingId, complexType);
                                        }
                                        AddEncodeableType(typeId, complexType);
                                        var qName = structuredObject.QName ?? new XmlQualifiedName(structuredObject.Name, targetDictionaryNamespace);
                                        typeDictionary[qName] = ExpandedNodeId.ToNodeId(typeId, m_session.NamespaceUris);
                                    }
                                }

                                if (complexType == null)
                                {
                                    retryStructureList.Add(item);
                                    Utils.Trace(TraceMasks.Error, $"Skipped the type definition of {item.Name}. Retry in next round.");
                                }
                            }
                        }
                        structureList = retryStructureList;
                    }
                    allTypesLoaded = allTypesLoaded && structureList.Count == 0;
                }
                catch (ServiceResultException sre)
                {
                    Utils.Trace(sre,
                        $"Unexpected error processing {dictionaryId.Value.Name}.");
                }
            }
            return allTypesLoaded;
        }

        /// <summary>
        /// Load all custom types with DataTypeDefinition into the type factory.
        /// </summary>
        /// <returns>true if all types were loaded, false otherwise</returns>
        private bool LoadBaseDataTypes(
            IList<INode> serverEnumTypes,
            IList<INode> serverStructTypes
            )
        {
            bool repeatDataTypeLoad = false; ;
            IList<INode> enumTypesToDoList = new List<INode>();
            IList<INode> structTypesToDoList = new List<INode>();

            do
            {
                // strip known types
                serverEnumTypes = RemoveKnownTypes(serverEnumTypes);
                serverStructTypes = RemoveKnownTypes(serverStructTypes);

                repeatDataTypeLoad = false;
                try
                {
                    enumTypesToDoList = LoadBaseEnumDataTypes(serverEnumTypes);
                    structTypesToDoList = LoadBaseStructureDataTypes(serverStructTypes);
                }
                catch (DataTypeNotFoundException dtnfex)
                {
                    // add missing type to list
                    var dataTypeNode = m_session.NodeCache.Find(dtnfex.nodeId);
                    if (dataTypeNode != null)
                    {
                        AddEnumerationOrStructureType(dataTypeNode, serverEnumTypes, serverStructTypes);
                        repeatDataTypeLoad = true;
                    }
                }
            } while (repeatDataTypeLoad);

            // all types loaded
            return enumTypesToDoList.Count == 0 && structTypesToDoList.Count == 0;
        }

        /// <summary>
        /// Load all custom types with DataTypeDefinition into the type factory.
        /// </summary>
        /// <returns>true if all types were loaded, false otherwise</returns>
        private IList<INode> LoadBaseEnumDataTypes(
            IList<INode> serverEnumTypes
            )
        {
            // strip known types
            serverEnumTypes = RemoveKnownTypes(serverEnumTypes);

            // add new enum Types for all namespaces
            var enumTypesToDoList = new List<INode>();
            int namespaceCount = m_session.NamespaceUris.Count;

            // create enumeration types for all namespaces
            for (uint i = 0; i < namespaceCount; i++)
            {
                IComplexTypeBuilder complexTypeBuilder = null;
                var enumTypes = serverEnumTypes.Where(node => node.NodeId.NamespaceIndex == i).ToList();
                if (enumTypes.Count != 0)
                {
                    if (complexTypeBuilder == null)
                    {
                        string targetNamespace = m_session.NamespaceUris.GetString(i);
                        complexTypeBuilder = m_complexTypeBuilderFactory.Create(
                            targetNamespace,
                            (int)i);
                    }
                    foreach (var enumType in enumTypes)
                    {
                        var newType = AddEnumType(complexTypeBuilder, enumType as DataTypeNode);
                        if (newType != null)
                        {
                            // match namespace and add to type factory
                            AddEncodeableType(enumType.NodeId, newType);
                        }
                        else
                        {
                            enumTypesToDoList.Add(enumType);
                        }
                    }
                }
            }

            // all types loaded, return remaining
            return enumTypesToDoList;
        }

        /// <summary>
        /// Load all structure custom types with DataTypeDefinition into the type factory.
        /// </summary>
        /// <returns>true if all types were loaded, false otherwise</returns>
        private IList<INode> LoadBaseStructureDataTypes(
            IList<INode> serverStructTypes
            )
        {
            // strip known types
            serverStructTypes = RemoveKnownTypes(serverStructTypes);

            // add new enum Types for all namespaces
            int namespaceCount = m_session.NamespaceUris.Count;

            bool retryAddStructType;
            var structTypesToDoList = new List<INode>();
            var structTypesWorkList = serverStructTypes;

            // create structured types for all namespaces
            do
            {
                retryAddStructType = false;
                for (uint i = 0; i < namespaceCount; i++)
                {
                    IComplexTypeBuilder complexTypeBuilder = null;
                    var structTypes = structTypesWorkList.Where(node => node.NodeId.NamespaceIndex == i).ToList();
                    if (structTypes.Count != 0)
                    {
                        if (complexTypeBuilder == null)
                        {
                            string targetNamespace = m_session.NamespaceUris.GetString(i);
                            complexTypeBuilder = m_complexTypeBuilderFactory.Create(
                                targetNamespace,
                                (int)i);
                        }
                        foreach (INode structType in structTypes)
                        {
                            Type newType = null;
                            if (!(structType is DataTypeNode dataTypeNode))
                            {
                                continue;
                            }
                            var structureDefinition = GetStructureDefinition(dataTypeNode);
                            if (structureDefinition != null)
                            {
                                var encodingIds = BrowseForEncodings(structType.NodeId, m_supportedEncodings,
                                    out ExpandedNodeId binaryEncodingId, out ExpandedNodeId xmlEncodingId);
                                try
                                {
                                    newType = AddStructuredType(
                                        complexTypeBuilder,
                                        structureDefinition,
                                        dataTypeNode.BrowseName,
                                        structType.NodeId,
                                        binaryEncodingId,
                                        xmlEncodingId
                                        );
                                }
                                catch (DataTypeNotFoundException dtnfex)
                                {
                                    var typeMatch = structTypesWorkList.FirstOrDefault(n => n.NodeId == dtnfex.nodeId);
                                    if (typeMatch == null)
                                    {
                                        throw;
                                    }
                                    else
                                    {   // known missing type, retry on next round
                                        Utils.Trace(dtnfex, "Skipped the type definition of {0}. Retry in next round.", dataTypeNode.BrowseName.Name);
                                        retryAddStructType = true;
                                    }
                                }
                                catch (DataTypeNotSupportedException dtnsex)
                                {
                                    Utils.Trace(dtnsex, "Skipped the type definition of {0} because it is not supported.", dataTypeNode.BrowseName.Name);
                                    continue;
                                }
                                catch
                                {
                                    // creating the new type failed, likely a missing dependency, retry later
                                    retryAddStructType = true;
                                }
                                if (newType != null)
                                {
                                    foreach (var encodingId in encodingIds)
                                    {
                                        AddEncodeableType(encodingId, newType);
                                    }
                                    AddEncodeableType(structType.NodeId, newType);
                                }
                            }
                            if (newType == null)
                            {
                                structTypesToDoList.Add(structType);
                            }
                        }
                    }
                }
                // due to type dependencies, retry missing types until there is no more progress
                if (retryAddStructType &&
                    structTypesWorkList.Count != structTypesToDoList.Count)
                {
                    structTypesWorkList = structTypesToDoList;
                    structTypesToDoList = new List<INode>();
                }
            } while (retryAddStructType);

            // all types loaded
            return structTypesToDoList;
        }

        /// <summary>
        /// Return the structure definition from a DataTypeDefinition
        /// </summary>
        private StructureDefinition GetStructureDefinition(DataTypeNode dataTypeNode)
        {
            if (dataTypeNode.DataTypeDefinition?.Body is StructureDefinition structureDefinition)
            {
                // Validate the DataTypeDefinition structure,
                // but not if the type is supported
                if (structureDefinition.Fields == null ||
                    structureDefinition.BaseDataType.IsNullNodeId ||
                    structureDefinition.BinaryEncodingId.IsNull)
                {
                    return null;
                }
                // Validate the structure according to Part3, Table 36
                foreach (var field in structureDefinition.Fields)
                {
                    // validate if the DataTypeDefinition is correctly
                    // filled out, some servers don't do it yet...
                    if (field.BinaryEncodingId.IsNull ||
                        field.DataType.IsNullNodeId ||
                        field.TypeId.IsNull ||
                        field.Name == null)
                    {
                        return null;
                    }
                    if (!(field.ValueRank == -1 ||
                        field.ValueRank >= 1))
                    {
                        return null;
                    }
                    if (structureDefinition.StructureType == StructureType.Structure &&
                        field.IsOptional)
                    {
                        return null;
                    }
                }
                return structureDefinition;
            }
            return null;

        }

        /// <summary>
        /// Helper to ensure the expanded nodeId contains a valid namespaceUri.
        /// </summary>
        /// <param name="expandedNodeId">The expanded nodeId.</param>
        /// <returns>The normalized expanded nodeId.</returns>
        private ExpandedNodeId NormalizeExpandedNodeId(ExpandedNodeId expandedNodeId)
        {
            var nodeId = ExpandedNodeId.ToNodeId(expandedNodeId, m_session.NamespaceUris);
            return NodeId.ToExpandedNodeId(nodeId, m_session.NamespaceUris);
        }

        /// <summary>
        /// Browse for the type and encoding id for a dictionary component.
        /// </summary>
        /// <remarks>
        /// According to Part 5 Annex D, servers shall provide the bi-directional
        /// references between data types, data type encodings, data type description
        /// and data type dictionary.
        /// To find the typeId and encodingId for a dictionary type definition:
        /// i) inverse browse the description to get the encodingid
        /// ii) from the description inverse browse for encoding 
        /// to get the subtype typeid 
        /// iii) load the DataType node 
        /// </remarks>
        /// <param name="nodeId"></param>
        /// <param name="typeId"></param>
        /// <param name="encodingId"></param>
        /// <param name="dataTypeNode"></param>
        /// <returns>true if successful, false otherwise</returns>
        private bool BrowseTypeIdsForDictionaryComponent(
            NodeId nodeId,
            out ExpandedNodeId typeId,
            out ExpandedNodeId encodingId,
            out DataTypeNode dataTypeNode)
        {
            typeId = ExpandedNodeId.Null;
            encodingId = ExpandedNodeId.Null;
            dataTypeNode = null;

            var references = m_session.NodeCache.FindReferences(
                nodeId,
                ReferenceTypeIds.HasDescription,
                true,
                false
                );

            if (references.Count == 1)
            {
                encodingId = references[0].NodeId;
                references = m_session.NodeCache.FindReferences(
                    encodingId,
                    ReferenceTypeIds.HasEncoding,
                    true,
                    false
                    );
                encodingId = NormalizeExpandedNodeId(encodingId);

                if (references.Count == 1)
                {
                    typeId = references[0].NodeId;
                    dataTypeNode = m_session.NodeCache.Find(typeId) as DataTypeNode;
                    typeId = NormalizeExpandedNodeId(typeId);
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Browse for the property.
        /// </summary>
        /// <remarks>
        /// Browse for property (type description) of an enum datatype.
        /// </remarks>
        /// <param name="nodeId"></param>
        /// <returns></returns>
        private INode BrowseForSingleProperty(
            ExpandedNodeId nodeId)
        {
            var references = m_session.NodeCache.FindReferences(
                nodeId,
                ReferenceTypeIds.HasProperty,
                false,
                false
                );
            return references.FirstOrDefault();
        }

        /// <summary>
        /// Browse for the encodings of a type.
        /// </summary>
        /// <remarks>
        /// Browse for binary encoding of a structure datatype.
        /// </remarks>
        private IList<NodeId> BrowseForEncodings(
            ExpandedNodeId nodeId,
            string[] supportedEncodings,
            out ExpandedNodeId binaryEncodingId,
            out ExpandedNodeId xmlEncodingId)
        {
            var references = m_session.NodeCache.FindReferences(
                nodeId,
                ReferenceTypeIds.HasEncoding,
                false,
                false
                );
            binaryEncodingId = references.FirstOrDefault(r => r.BrowseName.Name == BrowseNames.DefaultBinary)?.NodeId;
            binaryEncodingId = NormalizeExpandedNodeId(binaryEncodingId);
            xmlEncodingId = references.FirstOrDefault(r => r.BrowseName.Name == BrowseNames.DefaultXml)?.NodeId;
            xmlEncodingId = NormalizeExpandedNodeId(xmlEncodingId);
            return references.Where(r => supportedEncodings.Contains(r.BrowseName.Name))
                .Select(r => ExpandedNodeId.ToNodeId(r.NodeId, m_session.NamespaceUris)).ToList();
        }

        /// <summary>
        /// Load all subTypes and optionally nested subtypes of a type definition.
        /// Filter for all subtypes or only subtypes outside the default namespace.
        /// </summary>
        private IList<INode> LoadDataTypes(
            ExpandedNodeId dataType,
            bool nestedSubTypes = false,
            bool addRootNode = false,
            bool filterUATypes = true)
        {
            var result = new List<INode>();
            var nodesToBrowse = new ExpandedNodeIdCollection {
                dataType
            };

            if (addRootNode)
            {
                var rootNode = m_session.NodeCache.Find(dataType);
                if (!(rootNode is DataTypeNode))
                {
                    throw new ServiceResultException("Root Node is not a DataType node.");
                }
                result.Add(rootNode);
            }

            while (nodesToBrowse.Count > 0)
            {
                var nextNodesToBrowse = new ExpandedNodeIdCollection();
                foreach (var node in nodesToBrowse)
                {
                    var response = m_session.NodeCache.FindReferences(
                        node,
                        ReferenceTypeIds.HasSubtype,
                        false,
                        false);

                    if (nestedSubTypes)
                    {
                        nextNodesToBrowse.AddRange(response.Select(r => r.NodeId).ToList());
                    }
                    if (filterUATypes)
                    {
                        // filter out default namespace
                        result.AddRange(response.Where(rd => rd.NodeId.NamespaceIndex != 0));
                    }
                    else
                    {
                        result.AddRange(response);
                    }
                }
                nodesToBrowse = nextNodesToBrowse;
            }

            return result;
        }

        /// <summary>
        /// Add data type to enumeration or structure base type list depending on supertype.
        /// </summary>
        private void AddEnumerationOrStructureType(INode dataTypeNode, IList<INode> serverEnumTypes, IList<INode> serverStructTypes)
        {
            NodeId superType = ExpandedNodeId.ToNodeId(dataTypeNode.NodeId, m_session.NamespaceUris);
            do
            {
                superType = m_session.NodeCache.FindSuperType(superType);
                if (superType.IsNullNodeId)
                {
                    throw new ServiceResultException(StatusCodes.BadNodeIdInvalid, $"SuperType for {dataTypeNode.NodeId} not found.");
                }
                if (superType == DataTypeIds.Enumeration)
                {
                    serverEnumTypes.Insert(0, dataTypeNode);
                    break;
                }
                else if (superType == DataTypeIds.Structure)
                {
                    serverStructTypes.Insert(0, dataTypeNode);
                    break;
                }
                else if (TypeInfo.GetBuiltInType(superType) != BuiltInType.Null)
                {
                    break;
                }
            } while (true);
        }

        /// <summary>
        /// Remove all known types in the type factory from a list of DataType nodes.
        /// </summary>
        private IList<INode> RemoveKnownTypes(IList<INode> nodeList)
        {
            return nodeList.Where(
                node => GetSystemType(node.NodeId) == null).ToList();
        }

        /// <summary>
        /// Get the factory system type for an expanded node id.
        /// </summary>
        private Type GetSystemType(ExpandedNodeId nodeId)
        {
            if (!nodeId.IsAbsolute)
            {
                nodeId = NormalizeExpandedNodeId(nodeId);
            }
            return m_session.Factory.GetSystemType(nodeId);
        }

        /// <summary>
        /// Add an enum type defined in a binary schema dictionary.
        /// </summary>
        private void AddEnumTypes(
            IComplexTypeBuilder complexTypeBuilder,
            Dictionary<XmlQualifiedName, NodeId> typeDictionary,
            IList<Opc.Ua.Schema.Binary.TypeDescription> enumList,
            IList<INode> allEnumerationTypes,
            IList<INode> enumerationTypes
            )
        {
            foreach (var item in enumList)
            {
                Type newType = null;
                DataTypeNode enumDescription = null;

                if (enumerationTypes.FirstOrDefault(node =>
                    node.BrowseName.Name == item.Name &&
                    (node.BrowseName.NamespaceIndex == complexTypeBuilder.TargetNamespaceIndex ||
                    complexTypeBuilder.TargetNamespaceIndex == -1)) is DataTypeNode enumType)
                {
                    enumDescription = enumType;
                    // try dictionary enum definition
                    if (item is Schema.Binary.EnumeratedType enumeratedObject)
                    {
                        // 1. use Dictionary entry
                        newType = complexTypeBuilder.AddEnumType(enumeratedObject);
                    }
                    if (newType == null)
                    {
                        if (m_session.NodeCache.Find(enumType.NodeId) is DataTypeNode dataType)
                        {
                            if (dataType.DataTypeDefinition != null)
                            {
                                // 2. use DataTypeDefinition 
                                newType = complexTypeBuilder.AddEnumType(enumType.BrowseName.Name, dataType.DataTypeDefinition);
                            }
                            else
                            {
                                // browse for EnumFields or EnumStrings property
                                var property = BrowseForSingleProperty(enumType.NodeId);
                                var enumArray = m_session.ReadValue(
                                    ExpandedNodeId.ToNodeId(property.NodeId, m_session.NamespaceUris));
                                if (enumArray.Value is ExtensionObject[])
                                {
                                    // 3. use EnumValues
                                    newType = complexTypeBuilder.AddEnumType(enumType.BrowseName.Name, (ExtensionObject[])enumArray.Value);
                                }
                                else if (enumArray.Value is LocalizedText[])
                                {
                                    // 4. use EnumStrings
                                    newType = complexTypeBuilder.AddEnumType(enumType.BrowseName.Name, (LocalizedText[])enumArray.Value);
                                }
                            }
                        }
                    }
                }
                else
                {
                    enumDescription = allEnumerationTypes.FirstOrDefault(node =>
                        node.BrowseName.Name == item.Name &&
                        (node.BrowseName.NamespaceIndex == complexTypeBuilder.TargetNamespaceIndex ||
                        complexTypeBuilder.TargetNamespaceIndex == -1))                        as DataTypeNode;
                }
                if (enumDescription != null)
                {
                    var qName = new XmlQualifiedName(item.Name, complexTypeBuilder.TargetNamespace);
                    typeDictionary[qName] = enumDescription.NodeId;
                }
                if (newType != null)
                {
                    // match namespace and add to type factory
                    AddEncodeableType(enumType.NodeId, newType);
                }
            }
        }

        /// <summary>
        /// Helper to add new type with absolute ExpandedNodeId.
        /// </summary>
        private void AddEncodeableType(ExpandedNodeId nodeId, Type type)
        {
            if (NodeId.IsNull(nodeId) || type == null)
            {
                return;
            }
            var internalNodeId = NormalizeExpandedNodeId(nodeId);
            Utils.TraceDebug($"Adding Type {type.FullName} as: {internalNodeId.ToString()}");
            m_session.Factory.AddEncodeableType(internalNodeId, type);
        }

        /// <summary>
        /// Add an enum type defined in a DataType node.
        /// </summary>
        private Type AddEnumType(
            IComplexTypeBuilder complexTypeBuilder,
            DataTypeNode enumTypeNode
            )
        {
            Type newType = null;
            if (enumTypeNode != null)
            {
                QualifiedName name = enumTypeNode.BrowseName;
                if (enumTypeNode.DataTypeDefinition != null)
                {
                    // 1. use DataTypeDefinition 
                    newType = complexTypeBuilder.AddEnumType(name, enumTypeNode.DataTypeDefinition);
                }
                else
                {
                    // browse for EnumFields or EnumStrings property
                    var property = BrowseForSingleProperty(enumTypeNode.NodeId);
                    if (property != null)
                    {
                        var enumArray = m_session.ReadValue(
                            ExpandedNodeId.ToNodeId(property.NodeId,
                            m_session.NamespaceUris));
                        if (enumArray.Value is ExtensionObject[])
                        {
                            // 2. use EnumValues
                            newType = complexTypeBuilder.AddEnumType(name, (ExtensionObject[])enumArray.Value);
                        }
                        else if (enumArray.Value is LocalizedText[])
                        {
                            // 3. use EnumStrings
                            newType = complexTypeBuilder.AddEnumType(name, (LocalizedText[])enumArray.Value);
                        }
                    }
                }
            }
            return newType;
        }

        /// <summary>
        /// Add structured type to assembly with StructureDefinition.
        /// </summary>
        private Type AddStructuredType(
            IComplexTypeBuilder complexTypeBuilder,
            StructureDefinition structureDefinition,
            QualifiedName typeName,
            ExpandedNodeId complexTypeId,
            ExpandedNodeId binaryEncodingId,
            ExpandedNodeId xmlEncodingId
            )
        {
            // check all types
            var typeList = new List<Type>();
            foreach (StructureField field in structureDefinition.Fields)
            {
                var newType = GetFieldType(field);
                if (newType == null)
                {
                    throw new DataTypeNotFoundException(field.DataType);
                }
                typeList.Add(newType);
            }

            var fieldBuilder = complexTypeBuilder.AddStructuredType(
                typeName,
                structureDefinition
                );

            fieldBuilder.AddTypeIdAttribute(complexTypeId, binaryEncodingId, xmlEncodingId);

            int order = 1;
            var typeListEnumerator = typeList.GetEnumerator();
            foreach (StructureField field in structureDefinition.Fields)
            {
                typeListEnumerator.MoveNext();
                fieldBuilder.AddField(field, typeListEnumerator.Current, order);
                order++;
            }

            return fieldBuilder.CreateType();
        }

        /// <summary>
        /// Determine the type of a field in a StructureField definition.
        /// </summary>
        private Type GetFieldType(StructureField field)
        {
            Type collectionType = null;

            if (field.ValueRank != ValueRanks.Scalar &&
                field.ValueRank != ValueRanks.OneDimension)
            {
                throw new DataTypeNotSupportedException(field.DataType, $"The ValueRank {field.ValueRank} is not supported.");
            }

            Type fieldType = field.DataType.NamespaceIndex == 0 ?
                Opc.Ua.TypeInfo.GetSystemType(field.DataType, m_session.Factory) :
                GetSystemType(field.DataType);
            if (fieldType == null)
            {
                var superType = GetBuiltInSuperType(field.DataType);
                if (superType != null &&
                    !superType.IsNullNodeId)
                {
                    field.DataType = superType;
                    return GetFieldType(field);
                }
                return null;
            }

            if (field.DataType.NamespaceIndex == 0)
            {
                if (field.ValueRank == ValueRanks.OneDimension)
                {
                    if (fieldType == typeof(Byte[]))
                    {
                        collectionType = typeof(ByteStringCollection);
                    }
                    else if (fieldType == typeof(Single))
                    {
                        collectionType = typeof(FloatCollection);
                    }
                    else
                    {
                        var assemblyQualifiedName = typeof(StatusCode).Assembly;
                        String collectionClassName = "Opc.Ua." + fieldType.Name + "Collection, " + assemblyQualifiedName;
                        collectionType = Type.GetType(collectionClassName);
                    }
                }
            }
            else
            {
                if (field.ValueRank == ValueRanks.OneDimension)
                {
                    String collectionClassName = (fieldType.Namespace != null) ? fieldType.Namespace + "." : "";
                    collectionClassName += fieldType.Name + "Collection, " + fieldType.Assembly;
                    collectionType = Type.GetType(collectionClassName);
                }
            }

            if (field.ValueRank == ValueRanks.OneDimension)
            {
                fieldType = collectionType ?? fieldType.MakeArrayType();
            }

            return fieldType;
        }

        /// <summary>
        /// Find superType for a datatype.
        /// </summary>
        private NodeId GetBuiltInSuperType(NodeId dataType)
        {
            var superType = dataType;
            do
            {
                superType = m_session.NodeCache.FindSuperType(superType);
                if (superType == null ||
                    superType.IsNullNodeId)
                {
                    return null;
                }
                if (superType.NamespaceIndex == 0)
                {
                    if (superType == DataTypeIds.Enumeration ||
                        superType == DataTypeIds.Structure)
                    {
                        return null;
                    }
                    break;
                }
            } while (true);
            return superType;
        }

        /// <summary>
        /// Split the dictionary types into a list of structures and enumerations.
        /// Sort the structures by dependencies, with structures with dependent
        /// types at the end of the list, so they can be added to the factory in order.
        /// </summary>
        private void SplitAndSortDictionary(
                DataDictionary dictionary,
                List<Schema.Binary.TypeDescription> structureList,
                List<Schema.Binary.TypeDescription> enumList
                )
        {
            foreach (var item in dictionary.TypeDictionary.Items)
            {
                if (item is Opc.Ua.Schema.Binary.StructuredType structuredObject)
                {
                    var dependentFields = structuredObject.Field.Where(f => f.TypeName.Namespace == dictionary.TypeDictionary.TargetNamespace);
                    if (!dependentFields.Any())
                    {
                        structureList.Insert(0, structuredObject);
                    }
                    else
                    {
                        structureList.Add(structuredObject);
                    }
                }
                else if (item is Opc.Ua.Schema.Binary.EnumeratedType)
                {
                    enumList.Add(item);
                }
                else if (item is Opc.Ua.Schema.Binary.OpaqueType)
                {
                    // TODO: Opaque types not supported yet
                }
                else
                {
                    throw new ServiceResultException(StatusCodes.BadUnexpectedError, $"Unexpected Type in binary schema: {item.GetType().Name}.");
                }
            }
        }
        #endregion

        #region Private Fields
        private Session m_session;
        private IComplexTypeFactory m_complexTypeBuilderFactory;
        private string[] m_supportedEncodings = new string[] { BrowseNames.DefaultBinary, BrowseNames.DefaultXml, BrowseNames.DefaultJson };
        private const string kOpcComplexTypesPrefix = "Opc.Ua.ComplexTypes.";
        #endregion
    }
}//namespace

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.Client.ComplexTypes\ComplexTypeSystem.cs(985,39): error CS0165: Use of unassigned local variable 'enumType'
######################################################################


######################################################################
Nr: 31 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Applications\ReferenceServer\ReferenceServer.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using Opc.Ua;
using Opc.Ua.Server;

namespace Quickstarts.ReferenceServer
{
    /// <summary>
    /// Implements a basic Quickstart Server.
    /// </summary>
    /// <remarks>
    /// Each server instance must have one instance of a StandardServer object which is
    /// responsible for reading the configuration file, creating the endpoints and dispatching
    /// incoming requests to the appropriate handler.
    /// 
    /// This sub-class specifies non-configurable metadata such as Product Name and initializes
    /// the EmptyNodeManager which provides access to the data exposed by the Server.
    /// </remarks>
    public partial class ReferenceServer : ReverseConnectServer
    {
        #region Overridden Methods
        /// <summary>
        /// Creates the node managers for the server.
        /// </summary>
        /// <remarks>
        /// This method allows the sub-class create any additional node managers which it uses. The SDK
        /// always creates a CoreNodeManager which handles the built-in nodes defined by the specification.
        /// Any additional NodeManagers are expected to handle application specific nodes.
        /// </remarks>
        protected override MasterNodeManager CreateMasterNodeManager(IServerInternal server, ApplicationConfiguration configuration)
        {
            Utils.Trace("Creating the Node Managers.");

            List<INodeManager> nodeManagers = new List<INodeManager>();

            // create the custom node managers.
            nodeManagers.Add(new ReferenceNodeManager(server, configuration));

            // create master node manager.
            return new MasterNodeManager(server, configuration, null, nodeManagers.ToArray());
        }

        /// <summary>
        /// Loads the non-configurable properties for the application.
        /// </summary>
        /// <remarks>
        /// These properties are exposed by the server but cannot be changed by administrators.
        /// </remarks>
        protected override ServerProperties LoadServerProperties()
        {
            ServerProperties properties = new ServerProperties();

            properties.ManufacturerName = "OPC Foundation";
            properties.ProductName = "Quickstart Reference Server";
            properties.ProductUri = "http://opcfoundation.org/Quickstart/ReferenceServer/v1.04";
            properties.SoftwareVersion = Utils.GetAssemblySoftwareVersion();
            properties.BuildNumber = Utils.GetAssemblyBuildNumber();
            properties.BuildDate = Utils.GetAssemblyTimestamp();

            return properties;
        }

        /// <summary>
        /// Creates the resource manager for the server.
        /// </summary>
        protected override ResourceManager CreateResourceManager(IServerInternal server, ApplicationConfiguration configuration)
        {
            ResourceManager resourceManager = new ResourceManager(server, configuration);

            System.Reflection.FieldInfo[] fields = typeof(StatusCodes).GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);

            foreach (System.Reflection.FieldInfo field in fields)
            {
                uint? id = field.GetValue(typeof(StatusCodes)) as uint?;

                if (id != null)
                {
                    resourceManager.Add(id.Value, "en-US", field.Name);
                }
            }

            return resourceManager;
        }

        /// <summary>
        /// Initializes the server before it starts up.
        /// </summary>
        /// <remarks>
        /// This method is called before any startup processing occurs. The sub-class may update the 
        /// configuration object or do any other application specific startup tasks.
        /// </remarks>
        protected override void OnServerStarting(ApplicationConfiguration configuration)
        {
            Utils.Trace("The server is starting.");

            base.OnServerStarting(configuration);

            // it is up to the application to decide how to validate user identity tokens.
            // this function creates validator for X509 identity tokens.
            CreateUserIdentityValidators(configuration);
        }

        /// <summary>
        /// Called after the server has been started.
        /// </summary>
        protected override void OnServerStarted(IServerInternal server)
        {
            base.OnServerStarted(server);

            // request notifications when the user identity is changed. all valid users are accepted by default.
            server.SessionManager.ImpersonateUser += new ImpersonateEventHandler(SessionManager_ImpersonateUser);

            try
            {
                // allow a faster sampling interval for CurrentTime node.
                ServerInternal.Status.Variable.CurrentTime.MinimumSamplingInterval = 250;
            }
            catch
            { }

        }
        #endregion

        #region User Validation Functions
        /// <summary>
        /// Creates the objects used to validate the user identity tokens supported by the server.
        /// </summary>
        private void CreateUserIdentityValidators(ApplicationConfiguration configuration)
        {
            for (int ii = 0; ii < configuration.ServerConfiguration.UserTokenPolicies.Count; ii++)
            {
                UserTokenPolicy policy = configuration.ServerConfiguration.UserTokenPolicies[ii];

                // create a validator for a certificate token policy.
                if (policy.TokenType == UserTokenType.Certificate)
                {
                    // check if user certificate trust lists are specified in configuration.
                    if (configuration.SecurityConfiguration.TrustedUserCertificates != null &&
                        configuration.SecurityConfiguration.UserIssuerCertificates != null)
                    {
                        CertificateValidator certificateValidator = new CertificateValidator();
                        certificateValidator.Update(configuration.SecurityConfiguration).Wait();
                        certificateValidator.Update(configuration.SecurityConfiguration.UserIssuerCertificates,
                            configuration.SecurityConfiguration.TrustedUserCertificates,
                            configuration.SecurityConfiguration.RejectedCertificateStore);

                        // set custom validator for user certificates.
                        m_userCertificateValidator = certificateValidator.GetChannelValidator();
                    }
                }
            }
        }

        /// <summary>
        /// Called when a client tries to change its user identity.
        /// </summary>
        private void SessionManager_ImpersonateUser(Session session, ImpersonateEventArgs args)
        {
            // check for a user name token.
            UserNameIdentityToken userNameToken = args.NewIdentity as UserNameIdentityToken;

            if (userNameToken != null)
            {
                args.Identity = VerifyPassword(userNameToken);

                // set AuthenticatedUser role for accepted user/password authentication
                args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_AuthenticatedUser);

                if (args.Identity is SystemConfigurationIdentity)
                {
                    // set ConfigureAdmin role for user with permission to configure server
                    args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_ConfigureAdmin);
                    args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_SecurityAdmin);
                }

                return;
            }

            // check for x509 user token.
            X509IdentityToken x509Token = args.NewIdentity as X509IdentityToken;

            if (x509Token != null)
            {
                VerifyUserTokenCertificate(x509Token.Certificate);
                args.Identity = new UserIdentity(x509Token);
                Utils.Trace("X509 Token Accepted: {0}", args.Identity.DisplayName);

                // set AuthenticatedUser role for accepted certificate authentication
                args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_AuthenticatedUser);

                return;
            }

            // allow anonymous authentication and set Anonymous role for this authentication
            args.Identity = new UserIdentity();
            args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_Anonymous);
        }

        /// <summary>
        /// Validates the password for a username token.
        /// </summary>
        private IUserIdentity VerifyPassword(UserNameIdentityToken userNameToken)
        {
            var userName = userNameToken.UserName;
            var password = userNameToken.DecryptedPassword;
            if (String.IsNullOrEmpty(userName))
            {
                // an empty username is not accepted.
                throw ServiceResultException.Create(StatusCodes.BadIdentityTokenInvalid,
                    "Security token is not a valid username token. An empty username is not accepted.");
            }

            if (String.IsNullOrEmpty(password))
            {
                // an empty password is not accepted.
                throw ServiceResultException.Create(StatusCodes.BadIdentityTokenRejected,
                    "Security token is not a valid username token. An empty password is not accepted.");
            }

            // User with permission to configure server
            if (userName == "sysadmin" && password == "demo")
            {
                return new SystemConfigurationIdentity(new UserIdentity(userNameToken));
            }

            // standard users for CTT verification
            if (!((userName == "user1" && password == "password") ||
                (userName == "user2" && password == "password1")))
            {
                // construct translation object with default text.
                TranslationInfo info = new TranslationInfo(
                    "InvalidPassword",
                    "en-US",
                    "Invalid username or password.",
                    userName);

                // create an exception with a vendor defined sub-code.
                throw new ServiceResultException(new ServiceResult(
                    StatusCodes.BadUserAccessDenied,
                    "InvalidPassword",
                    LoadServerProperties().ProductUri,
                    new LocalizedText(info)));
            }

            return new UserIdentity(userNameToken);
        }

        /// <summary>
        /// Verifies that a certificate user token is trusted.
        /// </summary>
        private void VerifyUserTokenCertificate(X509Certificate2 certificate)
        {
            try
            {
                if (m_userCertificateValidator != null)
                {
                    m_userCertificateValidator.Validate(certificate);
                }
                else
                {
                    CertificateValidator.Validate(certificate);
                }
            }
            catch (Exception e)
            {
                TranslationInfo info;
                StatusCode result = StatusCodes.BadIdentityTokenRejected;
                ServiceResultException se = e as ServiceResultException;
                if (se != null && se.StatusCode == StatusCodes.BadCertificateUseNotAllowed)
                {
                    info = new TranslationInfo(
                        "InvalidCertificate",
                        "en-US",
                        "'{0}' is an invalid user certificate.",
                        certificate.Subject);

                    result = StatusCodes.BadIdentityTokenInvalid;
                }
                else
                {
                    // construct translation object with default text.
                    info = new TranslationInfo(
                        "UntrustedCertificate",
                        "en-US",
                        "'{0}' is not a trusted user certificate.",
                        certificate.Subject);
                }

                // create an exception with a vendor defined sub-code.
                throw new ServiceResultException(new ServiceResult(
                    result,
                    info.Key,
                    LoadServerProperties().ProductUri,
                    new LocalizedText(info)));
            }
        }
        #endregion

        #region Private Fields
        private ICertificateValidator m_userCertificateValidator;
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using Opc.Ua;
using Opc.Ua.Server;

namespace Quickstarts.ReferenceServer
{
    /// <summary>
    /// Implements a basic Quickstart Server.
    /// </summary>
    /// <remarks>
    /// Each server instance must have one instance of a StandardServer object which is
    /// responsible for reading the configuration file, creating the endpoints and dispatching
    /// incoming requests to the appropriate handler.
    /// 
    /// This sub-class specifies non-configurable metadata such as Product Name and initializes
    /// the EmptyNodeManager which provides access to the data exposed by the Server.
    /// </remarks>
    public partial class ReferenceServer : ReverseConnectServer
    {
        #region Overridden Methods
        /// <summary>
        /// Creates the node managers for the server.
        /// </summary>
        /// <remarks>
        /// This method allows the sub-class create any additional node managers which it uses. The SDK
        /// always creates a CoreNodeManager which handles the built-in nodes defined by the specification.
        /// Any additional NodeManagers are expected to handle application specific nodes.
        /// </remarks>
        protected override MasterNodeManager CreateMasterNodeManager(IServerInternal server, ApplicationConfiguration configuration)
        {
            Utils.Trace("Creating the Node Managers.");

            List<INodeManager> nodeManagers = new List<INodeManager>();

            // create the custom node managers.
            nodeManagers.Add(new ReferenceNodeManager(server, configuration));

            // create master node manager.
            return new MasterNodeManager(server, configuration, null, nodeManagers.ToArray());
        }

        /// <summary>
        /// Loads the non-configurable properties for the application.
        /// </summary>
        /// <remarks>
        /// These properties are exposed by the server but cannot be changed by administrators.
        /// </remarks>
        protected override ServerProperties LoadServerProperties()
        {
            ServerProperties properties = new ServerProperties();

            properties.ManufacturerName = "OPC Foundation";
            properties.ProductName = "Quickstart Reference Server";
            properties.ProductUri = "http://opcfoundation.org/Quickstart/ReferenceServer/v1.04";
            properties.SoftwareVersion = Utils.GetAssemblySoftwareVersion();
            properties.BuildNumber = Utils.GetAssemblyBuildNumber();
            properties.BuildDate = Utils.GetAssemblyTimestamp();

            return properties;
        }

        /// <summary>
        /// Creates the resource manager for the server.
        /// </summary>
        protected override ResourceManager CreateResourceManager(IServerInternal server, ApplicationConfiguration configuration)
        {
            ResourceManager resourceManager = new ResourceManager(server, configuration);

            System.Reflection.FieldInfo[] fields = typeof(StatusCodes).GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);

            foreach (System.Reflection.FieldInfo field in fields)
            {
                if (field.GetValue(typeof(StatusCodes)) is uint? id)
                {
                    resourceManager.Add(id.Value, "en-US", field.Name);
                }
            }

            return resourceManager;
        }

        /// <summary>
        /// Initializes the server before it starts up.
        /// </summary>
        /// <remarks>
        /// This method is called before any startup processing occurs. The sub-class may update the 
        /// configuration object or do any other application specific startup tasks.
        /// </remarks>
        protected override void OnServerStarting(ApplicationConfiguration configuration)
        {
            Utils.Trace("The server is starting.");

            base.OnServerStarting(configuration);

            // it is up to the application to decide how to validate user identity tokens.
            // this function creates validator for X509 identity tokens.
            CreateUserIdentityValidators(configuration);
        }

        /// <summary>
        /// Called after the server has been started.
        /// </summary>
        protected override void OnServerStarted(IServerInternal server)
        {
            base.OnServerStarted(server);

            // request notifications when the user identity is changed. all valid users are accepted by default.
            server.SessionManager.ImpersonateUser += new ImpersonateEventHandler(SessionManager_ImpersonateUser);

            try
            {
                // allow a faster sampling interval for CurrentTime node.
                ServerInternal.Status.Variable.CurrentTime.MinimumSamplingInterval = 250;
            }
            catch
            { }

        }
        #endregion

        #region User Validation Functions
        /// <summary>
        /// Creates the objects used to validate the user identity tokens supported by the server.
        /// </summary>
        private void CreateUserIdentityValidators(ApplicationConfiguration configuration)
        {
            for (int ii = 0; ii < configuration.ServerConfiguration.UserTokenPolicies.Count; ii++)
            {
                UserTokenPolicy policy = configuration.ServerConfiguration.UserTokenPolicies[ii];

                // create a validator for a certificate token policy.
                if (policy.TokenType == UserTokenType.Certificate)
                {
                    // check if user certificate trust lists are specified in configuration.
                    if (configuration.SecurityConfiguration.TrustedUserCertificates != null &&
                        configuration.SecurityConfiguration.UserIssuerCertificates != null)
                    {
                        CertificateValidator certificateValidator = new CertificateValidator();
                        certificateValidator.Update(configuration.SecurityConfiguration).Wait();
                        certificateValidator.Update(configuration.SecurityConfiguration.UserIssuerCertificates,
                            configuration.SecurityConfiguration.TrustedUserCertificates,
                            configuration.SecurityConfiguration.RejectedCertificateStore);

                        // set custom validator for user certificates.
                        m_userCertificateValidator = certificateValidator.GetChannelValidator();
                    }
                }
            }
        }

        /// <summary>
        /// Called when a client tries to change its user identity.
        /// </summary>
        private void SessionManager_ImpersonateUser(Session session, ImpersonateEventArgs args)
        {
            // check for a user name token.

            if (args.NewIdentity is UserNameIdentityToken userNameToken)
            {
                args.Identity = VerifyPassword(userNameToken);

                // set AuthenticatedUser role for accepted user/password authentication
                args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_AuthenticatedUser);

                if (args.Identity is SystemConfigurationIdentity)
                {
                    // set ConfigureAdmin role for user with permission to configure server
                    args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_ConfigureAdmin);
                    args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_SecurityAdmin);
                }

                return;
            }

            // check for x509 user token.

            if (args.NewIdentity is X509IdentityToken x509Token)
            {
                VerifyUserTokenCertificate(x509Token.Certificate);
                args.Identity = new UserIdentity(x509Token);
                Utils.Trace("X509 Token Accepted: {0}", args.Identity.DisplayName);

                // set AuthenticatedUser role for accepted certificate authentication
                args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_AuthenticatedUser);

                return;
            }

            // allow anonymous authentication and set Anonymous role for this authentication
            args.Identity = new UserIdentity();
            args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_Anonymous);
        }

        /// <summary>
        /// Validates the password for a username token.
        /// </summary>
        private IUserIdentity VerifyPassword(UserNameIdentityToken userNameToken)
        {
            var userName = userNameToken.UserName;
            var password = userNameToken.DecryptedPassword;
            if (String.IsNullOrEmpty(userName))
            {
                // an empty username is not accepted.
                throw ServiceResultException.Create(StatusCodes.BadIdentityTokenInvalid,
                    "Security token is not a valid username token. An empty username is not accepted.");
            }

            if (String.IsNullOrEmpty(password))
            {
                // an empty password is not accepted.
                throw ServiceResultException.Create(StatusCodes.BadIdentityTokenRejected,
                    "Security token is not a valid username token. An empty password is not accepted.");
            }

            // User with permission to configure server
            if (userName == "sysadmin" && password == "demo")
            {
                return new SystemConfigurationIdentity(new UserIdentity(userNameToken));
            }

            // standard users for CTT verification
            if (!((userName == "user1" && password == "password") ||
                (userName == "user2" && password == "password1")))
            {
                // construct translation object with default text.
                TranslationInfo info = new TranslationInfo(
                    "InvalidPassword",
                    "en-US",
                    "Invalid username or password.",
                    userName);

                // create an exception with a vendor defined sub-code.
                throw new ServiceResultException(new ServiceResult(
                    StatusCodes.BadUserAccessDenied,
                    "InvalidPassword",
                    LoadServerProperties().ProductUri,
                    new LocalizedText(info)));
            }

            return new UserIdentity(userNameToken);
        }

        /// <summary>
        /// Verifies that a certificate user token is trusted.
        /// </summary>
        private void VerifyUserTokenCertificate(X509Certificate2 certificate)
        {
            try
            {
                if (m_userCertificateValidator != null)
                {
                    m_userCertificateValidator.Validate(certificate);
                }
                else
                {
                    CertificateValidator.Validate(certificate);
                }
            }
            catch (Exception e)
            {
                TranslationInfo info;
                StatusCode result = StatusCodes.BadIdentityTokenRejected;

                if (e is ServiceResultException se && se.StatusCode == StatusCodes.BadCertificateUseNotAllowed)
                {
                    info = new TranslationInfo(
                        "InvalidCertificate",
                        "en-US",
                        "'{0}' is an invalid user certificate.",
                        certificate.Subject);

                    result = StatusCodes.BadIdentityTokenInvalid;
                }
                else
                {
                    // construct translation object with default text.
                    info = new TranslationInfo(
                        "UntrustedCertificate",
                        "en-US",
                        "'{0}' is not a trusted user certificate.",
                        certificate.Subject);
                }

                // create an exception with a vendor defined sub-code.
                throw new ServiceResultException(new ServiceResult(
                    result,
                    info.Key,
                    LoadServerProperties().ProductUri,
                    new LocalizedText(info)));
            }
        }
        #endregion

        #region Private Fields
        private ICertificateValidator m_userCertificateValidator;
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Applications\ReferenceServer\ReferenceServer.cs(104,60): error CS8116: It is not legal to use nullable type 'uint?' in a pattern; use the underlying type 'uint' instead.
######################################################################


######################################################################
Nr: 32 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;


namespace Opc.Ua.Client.Controls
{
    /// <summary>
    /// Displays a list of attributes and their values.
    /// </summary>
    public partial class AttributeListCtrl : Opc.Ua.Client.Controls.BaseListCtrl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AttributeListCtrl"/> class.
        /// </summary>
        public AttributeListCtrl()
        {
            InitializeComponent();
			SetColumns(m_ColumnNames);
        }

        #region Private Fields
        private Session m_session;
       
		// The columns to display in the control.		
		private readonly object[][] m_ColumnNames = new object[][]
		{
			new object[] { "Name",  HorizontalAlignment.Left, null },  
			new object[] { "Value", HorizontalAlignment.Left, null }
		};

        private class ItemInfo
        {
            public NodeId NodeId;
            public uint AttributeId;
            public string Name;
            public DataValue Value;
        }
		#endregion
            
        /// <summary>
        /// Initializes the control with a set of items.
        /// </summary>
        public void Initialize(Session session, ExpandedNodeId nodeId)
        {
            ItemsLV.Items.Clear();
            m_session = session;

            if (m_session == null)
            {
                return;
            }

            ILocalNode node = m_session.NodeCache.Find(nodeId) as ILocalNode;

            if (node == null)
            {
                return;
            }

            uint[] attributesIds = Attributes.GetIdentifiers();

            for (int ii = 0; ii < attributesIds.Length; ii++)
            {
                uint attributesId = attributesIds[ii];

                if (!node.SupportsAttribute(attributesId))
                {
                    continue;
                }

                ItemInfo info = new ItemInfo();

                info.NodeId = node.NodeId;
                info.AttributeId = attributesId;
                info.Name = Attributes.GetBrowseName(attributesId);
                info.Value = new DataValue(StatusCodes.BadWaitingForInitialData);
                
                ServiceResult result = node.Read(null, attributesId, info.Value);

                if (ServiceResult.IsBad(result))
                {
                    info.Value = new DataValue(result.StatusCode);
                }

                AddItem(info);
            }

            IList<IReference> references = node.References.Find(ReferenceTypes.HasProperty, false, true, m_session.TypeTree);

            for (int ii = 0; ii < references.Count; ii++)
            {
                IReference reference = references[ii];

                ILocalNode property = m_session.NodeCache.Find(reference.TargetId) as ILocalNode;

                if (property == null)
                {
                    return;
                }

                ItemInfo info = new ItemInfo();

                info.NodeId = property.NodeId;
                info.AttributeId = Attributes.Value;
                info.Name = Utils.Format("{0}", property.DisplayName);
                info.Value = new DataValue(StatusCodes.BadWaitingForInitialData);
                
                ServiceResult result = property.Read(null, Attributes.Value, info.Value);

                if (ServiceResult.IsBad(result))
                {
                    info.Value = new DataValue(result.StatusCode);
                }

                AddItem(info);
            }

            UpdateValues();
        }

        /// <summary>
        /// Updates the values from the server.
        /// </summary>
        private void UpdateValues()
        {
            ReadValueIdCollection valuesToRead = new ReadValueIdCollection();

            foreach (ListViewItem item in ItemsLV.Items)
            {
                ItemInfo info = item.Tag as ItemInfo;

			    if (info == null)
			    {
                    continue;
                }

                ReadValueId valueToRead = new ReadValueId();

                valueToRead.NodeId = info.NodeId;
                valueToRead.AttributeId = info.AttributeId;
                valueToRead.Handle = item;

                valuesToRead.Add(valueToRead);
            }

            DataValueCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            m_session.Read(
                null,
                0,
                TimestampsToReturn.Neither,
                valuesToRead,
                out results,
                out diagnosticInfos);

            ClientBase.ValidateResponse(results, valuesToRead);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, valuesToRead);

            for (int ii = 0; ii < valuesToRead.Count; ii++)
            {
                ListViewItem item = (ListViewItem)valuesToRead[ii].Handle;
                ItemInfo info = (ItemInfo)item.Tag;
                info.Value = results[ii];
                UpdateItem(item, info);
            }

            AdjustColumns();
        }
        
        /// <summary>
        /// Formats the value of an attribute.
        /// </summary>
        private string FormatAttributeValue(uint attributeId, object value)
        {
            switch (attributeId)
            {
                case Attributes.NodeClass:
                {
                    if (value != null)
                    {
                        return String.Format("{0}", Enum.ToObject(typeof(NodeClass), value));
                    }

                    return "(null)";
                }
                    
                case Attributes.DataType:
                {
                    NodeId datatypeId = value as NodeId;

                    if (datatypeId != null)
                    {
                        INode datatype = m_session.NodeCache.Find(datatypeId);

                        if (datatype != null)
                        {
                            return String.Format("{0}", datatype.DisplayName.Text);
                        }
                        else
                        {
                            return String.Format("{0}", datatypeId);
                        }
                    }
                
                    return String.Format("{0}", value);
                }
                      
                case Attributes.ValueRank:
                {
                    int? valueRank = value as int?;

                    if (valueRank != null)
                    {
                        switch (valueRank.Value)
                        {
                            case ValueRanks.Scalar:              return "Scalar";
                            case ValueRanks.OneDimension:        return "OneDimension";
                            case ValueRanks.OneOrMoreDimensions: return "OneOrMoreDimensions";
                            case ValueRanks.Any:                 return "Any";

                            default:
                            {
                                return String.Format("{0}", valueRank.Value);
                            }
                        }                            
                    }

                    return String.Format("{0}", value);
                }
                      
                case Attributes.MinimumSamplingInterval:
                {
                    double? minimumSamplingInterval = value as double?;

                    if (minimumSamplingInterval != null)
                    {
                        if (minimumSamplingInterval.Value == MinimumSamplingIntervals.Indeterminate)
                        {
                            return "Indeterminate";
                        }

                        else if (minimumSamplingInterval.Value == MinimumSamplingIntervals.Continuous)
                        {
                            return "Continuous";
                        }

                       return String.Format("{0}", minimumSamplingInterval.Value);
                    }

                    return String.Format("{0}", value);
                }

                case Attributes.AccessLevel:
                case Attributes.UserAccessLevel:
                {
                    byte accessLevel = Convert.ToByte(value);

                    StringBuilder bits = new StringBuilder();

                    if ((accessLevel & AccessLevels.CurrentRead) != 0)
                    {
                        bits.Append("Readable");
                    }
                    
                    if ((accessLevel & AccessLevels.CurrentWrite) != 0)
                    {
                        if (bits.Length > 0)
                        {
                            bits.Append(" | ");
                        }
                           
                        bits.Append("Writeable");
                    }
                    
                    if ((accessLevel & AccessLevels.HistoryRead) != 0)
                    {
                        if (bits.Length > 0)
                        {
                            bits.Append(" | ");
                        }
                           
                        bits.Append("History Read");
                    }
                    
                    if ((accessLevel & AccessLevels.HistoryWrite) != 0)
                    {
                        if (bits.Length > 0)
                        {
                            bits.Append(" | ");
                        }
                           
                        bits.Append("History Update");
                    }
                    
                    if (bits.Length == 0)
                    {
                        bits.Append("No Access");
                    }

                    return String.Format("{0}", bits);
                }
               
                case Attributes.EventNotifier:
                {
                    byte notifier = Convert.ToByte(value);

                    StringBuilder bits = new StringBuilder();

                    if ((notifier & EventNotifiers.SubscribeToEvents) != 0)
                    {
                        bits.Append("Subscribe");
                    }
                    
                    if ((notifier & EventNotifiers.HistoryRead) != 0)
                    {
                        if (bits.Length > 0)
                        {
                            bits.Append(" | ");
                        }
                           
                        bits.Append("History");
                    }
                    
                    if ((notifier & EventNotifiers.HistoryWrite) != 0)
                    {
                        if (bits.Length > 0)
                        {
                            bits.Append(" | ");
                        }
                           
                        bits.Append("History Update");
                    }
                    
                    if (bits.Length == 0)
                    {
                        bits.Append("No Access");
                    }

                    return String.Format("{0}", bits);
                }

                default:
                {
                    return String.Format("{0}", value);
                }
            }
        }

        #region Overridden Methods
        /// <see cref="Opc.Ua.Client.Controls.BaseListCtrl.UpdateItem(ListViewItem,object)" />
        protected override void UpdateItem(ListViewItem listItem, object item)
        {
            ItemInfo info = item as ItemInfo;

			if (info == null)
			{
				base.UpdateItem(listItem, item);
				return;
			}
            
			listItem.SubItems[0].Text = Utils.Format("{0}", info.Name);

            if (StatusCode.IsBad(info.Value.StatusCode))
            {
			    listItem.SubItems[1].Text = Utils.Format("{0}", info.Value.StatusCode);
            }
            else
            {
			    listItem.SubItems[1].Text = FormatAttributeValue(info.AttributeId, info.Value.Value);
            }

            if (info.AttributeId != Attributes.Value)
            {
                listItem.ImageKey = GuiUtils.Icons.Attribute;
            }
            else
            {
                listItem.ImageKey = GuiUtils.Icons.Property;
            }

			listItem.Tag = info;
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;


namespace Opc.Ua.Client.Controls
{
    /// <summary>
    /// Displays a list of attributes and their values.
    /// </summary>
    public partial class AttributeListCtrl : Opc.Ua.Client.Controls.BaseListCtrl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AttributeListCtrl"/> class.
        /// </summary>
        public AttributeListCtrl()
        {
            InitializeComponent();
			SetColumns(m_ColumnNames);
        }

        #region Private Fields
        private Session m_session;
       
		// The columns to display in the control.		
		private readonly object[][] m_ColumnNames = new object[][]
		{
			new object[] { "Name",  HorizontalAlignment.Left, null },  
			new object[] { "Value", HorizontalAlignment.Left, null }
		};

        private class ItemInfo
        {
            public NodeId NodeId;
            public uint AttributeId;
            public string Name;
            public DataValue Value;
        }
		#endregion
            
        /// <summary>
        /// Initializes the control with a set of items.
        /// </summary>
        public void Initialize(Session session, ExpandedNodeId nodeId)
        {
            ItemsLV.Items.Clear();
            m_session = session;

            if (m_session == null)
            {
                return;
            }

            ILocalNode node = m_session.NodeCache.Find(nodeId) as ILocalNode;

            if (node == null)
            {
                return;
            }

            uint[] attributesIds = Attributes.GetIdentifiers();

            for (int ii = 0; ii < attributesIds.Length; ii++)
            {
                uint attributesId = attributesIds[ii];

                if (!node.SupportsAttribute(attributesId))
                {
                    continue;
                }

                ItemInfo info = new ItemInfo();

                info.NodeId = node.NodeId;
                info.AttributeId = attributesId;
                info.Name = Attributes.GetBrowseName(attributesId);
                info.Value = new DataValue(StatusCodes.BadWaitingForInitialData);
                
                ServiceResult result = node.Read(null, attributesId, info.Value);

                if (ServiceResult.IsBad(result))
                {
                    info.Value = new DataValue(result.StatusCode);
                }

                AddItem(info);
            }

            IList<IReference> references = node.References.Find(ReferenceTypes.HasProperty, false, true, m_session.TypeTree);

            for (int ii = 0; ii < references.Count; ii++)
            {
                IReference reference = references[ii];

                ILocalNode property = m_session.NodeCache.Find(reference.TargetId) as ILocalNode;

                if (property == null)
                {
                    return;
                }

                ItemInfo info = new ItemInfo();

                info.NodeId = property.NodeId;
                info.AttributeId = Attributes.Value;
                info.Name = Utils.Format("{0}", property.DisplayName);
                info.Value = new DataValue(StatusCodes.BadWaitingForInitialData);
                
                ServiceResult result = property.Read(null, Attributes.Value, info.Value);

                if (ServiceResult.IsBad(result))
                {
                    info.Value = new DataValue(result.StatusCode);
                }

                AddItem(info);
            }

            UpdateValues();
        }

        /// <summary>
        /// Updates the values from the server.
        /// </summary>
        private void UpdateValues()
        {
            ReadValueIdCollection valuesToRead = new ReadValueIdCollection();

            foreach (ListViewItem item in ItemsLV.Items)
            {
                ItemInfo info = item.Tag as ItemInfo;

			    if (info == null)
			    {
                    continue;
                }

                ReadValueId valueToRead = new ReadValueId();

                valueToRead.NodeId = info.NodeId;
                valueToRead.AttributeId = info.AttributeId;
                valueToRead.Handle = item;

                valuesToRead.Add(valueToRead);
            }

            DataValueCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            m_session.Read(
                null,
                0,
                TimestampsToReturn.Neither,
                valuesToRead,
                out results,
                out diagnosticInfos);

            ClientBase.ValidateResponse(results, valuesToRead);
            ClientBase.ValidateDiagnosticInfos(diagnosticInfos, valuesToRead);

            for (int ii = 0; ii < valuesToRead.Count; ii++)
            {
                ListViewItem item = (ListViewItem)valuesToRead[ii].Handle;
                ItemInfo info = (ItemInfo)item.Tag;
                info.Value = results[ii];
                UpdateItem(item, info);
            }

            AdjustColumns();
        }
        
        /// <summary>
        /// Formats the value of an attribute.
        /// </summary>
        private string FormatAttributeValue(uint attributeId, object value)
        {
            switch (attributeId)
            {
                case Attributes.NodeClass:
                {
                    if (value != null)
                    {
                        return String.Format("{0}", Enum.ToObject(typeof(NodeClass), value));
                    }

                    return "(null)";
                }
                    
                case Attributes.DataType:
                {
                    if (value is NodeId datatypeId)
                    {
                        INode datatype = m_session.NodeCache.Find(datatypeId);

                        if (datatype != null)
                        {
                            return String.Format("{0}", datatype.DisplayName.Text);
                        }
                        else
                        {
                            return String.Format("{0}", datatypeId);
                        }
                    }
                
                    return String.Format("{0}", value);
                }
                      
                case Attributes.ValueRank:
                {
                    if (value is int? valueRank)
                    {
                        switch (valueRank.Value)
                        {
                            case ValueRanks.Scalar:              return "Scalar";
                            case ValueRanks.OneDimension:        return "OneDimension";
                            case ValueRanks.OneOrMoreDimensions: return "OneOrMoreDimensions";
                            case ValueRanks.Any:                 return "Any";

                            default:
                            {
                                return String.Format("{0}", valueRank.Value);
                            }
                        }                            
                    }

                    return String.Format("{0}", value);
                }
                      
                case Attributes.MinimumSamplingInterval:
                {
                    if (value is double? minimumSamplingInterval)
                    {
                        if (minimumSamplingInterval.Value == MinimumSamplingIntervals.Indeterminate)
                        {
                            return "Indeterminate";
                        }

                        else if (minimumSamplingInterval.Value == MinimumSamplingIntervals.Continuous)
                        {
                            return "Continuous";
                        }

                       return String.Format("{0}", minimumSamplingInterval.Value);
                    }

                    return String.Format("{0}", value);
                }

                case Attributes.AccessLevel:
                case Attributes.UserAccessLevel:
                {
                    byte accessLevel = Convert.ToByte(value);

                    StringBuilder bits = new StringBuilder();

                    if ((accessLevel & AccessLevels.CurrentRead) != 0)
                    {
                        bits.Append("Readable");
                    }
                    
                    if ((accessLevel & AccessLevels.CurrentWrite) != 0)
                    {
                        if (bits.Length > 0)
                        {
                            bits.Append(" | ");
                        }
                           
                        bits.Append("Writeable");
                    }
                    
                    if ((accessLevel & AccessLevels.HistoryRead) != 0)
                    {
                        if (bits.Length > 0)
                        {
                            bits.Append(" | ");
                        }
                           
                        bits.Append("History Read");
                    }
                    
                    if ((accessLevel & AccessLevels.HistoryWrite) != 0)
                    {
                        if (bits.Length > 0)
                        {
                            bits.Append(" | ");
                        }
                           
                        bits.Append("History Update");
                    }
                    
                    if (bits.Length == 0)
                    {
                        bits.Append("No Access");
                    }

                    return String.Format("{0}", bits);
                }
               
                case Attributes.EventNotifier:
                {
                    byte notifier = Convert.ToByte(value);

                    StringBuilder bits = new StringBuilder();

                    if ((notifier & EventNotifiers.SubscribeToEvents) != 0)
                    {
                        bits.Append("Subscribe");
                    }
                    
                    if ((notifier & EventNotifiers.HistoryRead) != 0)
                    {
                        if (bits.Length > 0)
                        {
                            bits.Append(" | ");
                        }
                           
                        bits.Append("History");
                    }
                    
                    if ((notifier & EventNotifiers.HistoryWrite) != 0)
                    {
                        if (bits.Length > 0)
                        {
                            bits.Append(" | ");
                        }
                           
                        bits.Append("History Update");
                    }
                    
                    if (bits.Length == 0)
                    {
                        bits.Append("No Access");
                    }

                    return String.Format("{0}", bits);
                }

                default:
                {
                    return String.Format("{0}", value);
                }
            }
        }

        #region Overridden Methods
        /// <see cref="Opc.Ua.Client.Controls.BaseListCtrl.UpdateItem(ListViewItem,object)" />
        protected override void UpdateItem(ListViewItem listItem, object item)
        {
            ItemInfo info = item as ItemInfo;

			if (info == null)
			{
				base.UpdateItem(listItem, item);
				return;
			}
            
			listItem.SubItems[0].Text = Utils.Format("{0}", info.Name);

            if (StatusCode.IsBad(info.Value.StatusCode))
            {
			    listItem.SubItems[1].Text = Utils.Format("{0}", info.Value.StatusCode);
            }
            else
            {
			    listItem.SubItems[1].Text = FormatAttributeValue(info.AttributeId, info.Value.Value);
            }

            if (info.AttributeId != Attributes.Value)
            {
                listItem.ImageKey = GuiUtils.Icons.Attribute;
            }
            else
            {
                listItem.ImageKey = GuiUtils.Icons.Property;
            }

			listItem.Tag = info;
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs(240,34): error CS8116: It is not legal to use nullable type 'int?' in a pattern; use the underlying type 'int' instead.,D:\a\1\s\Applications\ClientControls.Net4\Browse\AttributeListCtrl.cs(261,34): error CS8116: It is not legal to use nullable type 'double?' in a pattern; use the underlying type 'double' instead.
######################################################################


######################################################################
Nr: 33 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Applications\ClientControls.Net4\ClientUtils.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;

namespace Opc.Ua.Client.Controls
{
    /// <summary>
    /// Defines numerous re-useable utility functions.
    /// </summary>
    public partial class ClientUtils
    {
        /// <summary>
        /// Handles an exception.
        /// </summary>
        public static void HandleException(string caption, Exception e)
        {
            ExceptionDlg.Show(caption, e);
        }

        /// <summary>
        /// Returns the application icon.
        /// </summary>
        public static System.Drawing.Icon GetAppIcon()
        {
            try
            {
                return new Icon("App.ico");
            }
            catch (Exception)
            {
                return null;
            }
        }

        #region DisplayText Lookup
        /// <summary>
        /// Gets the display text for the access level attribute.
        /// </summary>
        /// <param name="accessLevel">The access level.</param>
        /// <returns>The access level formatted as a string.</returns>
        public static string GetAccessLevelDisplayText(byte accessLevel)
        {
            StringBuilder buffer = new StringBuilder();

            if (accessLevel == AccessLevels.None)
            {
                buffer.Append("None");
            }

            if ((accessLevel & AccessLevels.CurrentRead) == AccessLevels.CurrentRead)
            {
                buffer.Append("Read");
            }

            if ((accessLevel & AccessLevels.CurrentWrite) == AccessLevels.CurrentWrite)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("Write");
            }

            if ((accessLevel & AccessLevels.HistoryRead) == AccessLevels.HistoryRead)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("HistoryRead");
            }

            if ((accessLevel & AccessLevels.HistoryWrite) == AccessLevels.HistoryWrite)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("HistoryWrite");
            }

            if ((accessLevel & AccessLevels.SemanticChange) == AccessLevels.SemanticChange)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("SemanticChange");
            }

            return buffer.ToString();
        }

        /// <summary>
        /// Gets the display text for the event notifier attribute.
        /// </summary>
        /// <param name="eventNotifier">The event notifier.</param>
        /// <returns>The event notifier formatted as a string.</returns>
        public static string GetEventNotifierDisplayText(byte eventNotifier)
        {
            StringBuilder buffer = new StringBuilder();

            if (eventNotifier == EventNotifiers.None)
            {
                buffer.Append("None");
            }

            if ((eventNotifier & EventNotifiers.SubscribeToEvents) == EventNotifiers.SubscribeToEvents)
            {
                buffer.Append("Subscribe");
            }

            if ((eventNotifier & EventNotifiers.HistoryRead) == EventNotifiers.HistoryRead)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("HistoryRead");
            }

            if ((eventNotifier & EventNotifiers.HistoryWrite) == EventNotifiers.HistoryWrite)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("HistoryWrite");
            }

            return buffer.ToString();
        }

        /// <summary>
        /// Gets the display text for the value rank attribute.
        /// </summary>
        /// <param name="valueRank">The value rank.</param>
        /// <returns>The value rank formatted as a string.</returns>
        public static string GetValueRankDisplayText(int valueRank)
        {
            switch (valueRank)
            {
                case ValueRanks.Any: return "Any";
                case ValueRanks.Scalar: return "Scalar";
                case ValueRanks.ScalarOrOneDimension: return "ScalarOrOneDimension";
                case ValueRanks.OneOrMoreDimensions: return "OneOrMoreDimensions";
                case ValueRanks.OneDimension: return "OneDimension";
                case ValueRanks.TwoDimensions: return "TwoDimensions";
            }

            return valueRank.ToString();
        }

        /// <summary>
        /// Gets the display text for the specified attribute.
        /// </summary>
        /// <param name="session">The currently active session.</param>
        /// <param name="attributeId">The id of the attribute.</param>
        /// <param name="value">The value of the attribute.</param>
        /// <returns>The attribute formatted as a string.</returns>
        public static string GetAttributeDisplayText(Session session, uint attributeId, Variant value)
        {
            if (value == Variant.Null)
            {
                return String.Empty;
            }

            switch (attributeId)
            {
                case Attributes.AccessLevel:
                case Attributes.UserAccessLevel:
                    {
                        byte? field = value.Value as byte?;

                        if (field != null)
                        {
                            return GetAccessLevelDisplayText(field.Value);
                        }

                        break;
                    }

                case Attributes.EventNotifier:
                    {
                        byte? field = value.Value as byte?;

                        if (field != null)
                        {
                            return GetEventNotifierDisplayText(field.Value);
                        }

                        break;
                    }

                case Attributes.DataType:
                    {
                        return session.NodeCache.GetDisplayText(value.Value as NodeId);
                    }

                case Attributes.ValueRank:
                    {
                        int? field = value.Value as int?;

                        if (field != null)
                        {
                            return GetValueRankDisplayText(field.Value);
                        }

                        break;
                    }

                case Attributes.NodeClass:
                    {
                        int? field = value.Value as int?;

                        if (field != null)
                        {
                            return ((NodeClass)field.Value).ToString();
                        }

                        break;
                    }

                case Attributes.NodeId:
                    {
                        NodeId field = value.Value as NodeId;

                        if (!NodeId.IsNull(field))
                        {
                            return field.ToString();
                        }

                        return "Null";
                    }

                case Attributes.DataTypeDefinition:
                    {
                        ExtensionObject field = value.Value as ExtensionObject;
                        if (field != null)
                        {
                            return field.ToString();
                        }
                        break;
                    }
            }

            // check for byte strings.
            if (value.Value is byte[])
            {
                return Utils.ToHexString(value.Value as byte[]);
            }

            // use default format.
            return value.ToString();
        }
        #endregion

        #region Browse
        /// <summary>
        /// Browses the address space and returns the references found.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="nodesToBrowse">The set of browse operations to perform.</param>
        /// <param name="throwOnError">if set to <c>true</c> a exception will be thrown on an error.</param>
        /// <returns>
        /// The references found. Null if an error occurred.
        /// </returns>
        public static ReferenceDescriptionCollection Browse(Session session, BrowseDescriptionCollection nodesToBrowse, bool throwOnError)
        {
            return Browse(session, null, nodesToBrowse, throwOnError);
        }

        /// <summary>
        /// Browses the address space and returns the references found.
        /// </summary>
        public static ReferenceDescriptionCollection Browse(Session session, ViewDescription view, BrowseDescriptionCollection nodesToBrowse, bool throwOnError)
        {
            try
            {
                ReferenceDescriptionCollection references = new ReferenceDescriptionCollection();
                BrowseDescriptionCollection unprocessedOperations = new BrowseDescriptionCollection();

                while (nodesToBrowse.Count > 0)
                {
                    // start the browse operation.
                    BrowseResultCollection results = null;
                    DiagnosticInfoCollection diagnosticInfos = null;

                    session.Browse(
                        null,
                        view,
                        0,
                        nodesToBrowse,
                        out results,
                        out diagnosticInfos);

                    ClientBase.ValidateResponse(results, nodesToBrowse);
                    ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToBrowse);

                    ByteStringCollection continuationPoints = new ByteStringCollection();

                    for (int ii = 0; ii < nodesToBrowse.Count; ii++)
                    {
                        // check for error.
                        if (StatusCode.IsBad(results[ii].StatusCode))
                        {
                            // this error indicates that the server does not have enough simultaneously active 
                            // continuation points. This request will need to be resent after the other operations
                            // have been completed and their continuation points released.
                            if (results[ii].StatusCode == StatusCodes.BadNoContinuationPoints)
                            {
                                unprocessedOperations.Add(nodesToBrowse[ii]);
                            }

                            continue;
                        }

                        // check if all references have been fetched.
                        if (results[ii].References.Count == 0)
                        {
                            continue;
                        }

                        // save results.
                        references.AddRange(results[ii].References);

                        // check for continuation point.
                        if (results[ii].ContinuationPoint != null)
                        {
                            continuationPoints.Add(results[ii].ContinuationPoint);
                        }
                    }

                    // process continuation points.
                    ByteStringCollection revisedContiuationPoints = new ByteStringCollection();

                    while (continuationPoints.Count > 0)
                    {
                        // continue browse operation.
                        session.BrowseNext(
                            null,
                            false,
                            continuationPoints,
                            out results,
                            out diagnosticInfos);

                        ClientBase.ValidateResponse(results, continuationPoints);
                        ClientBase.ValidateDiagnosticInfos(diagnosticInfos, continuationPoints);

                        for (int ii = 0; ii < continuationPoints.Count; ii++)
                        {
                            // check for error.
                            if (StatusCode.IsBad(results[ii].StatusCode))
                            {
                                continue;
                            }

                            // check if all references have been fetched.
                            if (results[ii].References.Count == 0)
                            {
                                continue;
                            }

                            // save results.
                            references.AddRange(results[ii].References);

                            // check for continuation point.
                            if (results[ii].ContinuationPoint != null)
                            {
                                revisedContiuationPoints.Add(results[ii].ContinuationPoint);
                            }
                        }

                        // check if browsing must continue;
                        revisedContiuationPoints = continuationPoints;
                    }

                    // check if unprocessed results exist.
                    nodesToBrowse = unprocessedOperations;
                }

                // return complete list.
                return references;
            }
            catch (Exception exception)
            {
                if (throwOnError)
                {
                    throw new ServiceResultException(exception, StatusCodes.BadUnexpectedError);
                }

                return null;
            }
        }

        /// <summary>
        /// Browses the address space and returns the references found.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="nodeToBrowse">The NodeId for the starting node.</param>
        /// <param name="throwOnError">if set to <c>true</c> a exception will be thrown on an error.</param>
        /// <returns>
        /// The references found. Null if an error occurred.
        /// </returns>
        public static ReferenceDescriptionCollection Browse(Session session, BrowseDescription nodeToBrowse, bool throwOnError)
        {
            return Browse(session, null, nodeToBrowse, throwOnError);
        }

        /// <summary>
        /// Browses the address space and returns the references found.
        /// </summary>
        public static ReferenceDescriptionCollection Browse(Session session, ViewDescription view, BrowseDescription nodeToBrowse, bool throwOnError)
        {
            try
            {
                ReferenceDescriptionCollection references = new ReferenceDescriptionCollection();

                // construct browse request.
                BrowseDescriptionCollection nodesToBrowse = new BrowseDescriptionCollection();
                nodesToBrowse.Add(nodeToBrowse);

                // start the browse operation.
                BrowseResultCollection results = null;
                DiagnosticInfoCollection diagnosticInfos = null;

                session.Browse(
                    null,
                    view,
                    0,
                    nodesToBrowse,
                    out results,
                    out diagnosticInfos);

                ClientBase.ValidateResponse(results, nodesToBrowse);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToBrowse);

                do
                {
                    // check for error.
                    if (StatusCode.IsBad(results[0].StatusCode))
                    {
                        throw new ServiceResultException(results[0].StatusCode);
                    }

                    // process results.
                    for (int ii = 0; ii < results[0].References.Count; ii++)
                    {
                        references.Add(results[0].References[ii]);
                    }

                    // check if all references have been fetched.
                    if (results[0].References.Count == 0 || results[0].ContinuationPoint == null)
                    {
                        break;
                    }

                    // continue browse operation.
                    ByteStringCollection continuationPoints = new ByteStringCollection();
                    continuationPoints.Add(results[0].ContinuationPoint);

                    session.BrowseNext(
                        null,
                        false,
                        continuationPoints,
                        out results,
                        out diagnosticInfos);

                    ClientBase.ValidateResponse(results, continuationPoints);
                    ClientBase.ValidateDiagnosticInfos(diagnosticInfos, continuationPoints);
                }
                while (true);

                //return complete list.
                return references;
            }
            catch (Exception exception)
            {
                if (throwOnError)
                {
                    throw new ServiceResultException(exception, StatusCodes.BadUnexpectedError);
                }

                return null;
            }
        }

        /// <summary>
        /// Browses the address space and returns all of the supertypes of the specified type node.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="typeId">The NodeId for a type node in the address space.</param>
        /// <param name="throwOnError">if set to <c>true</c> a exception will be thrown on an error.</param>
        /// <returns>
        /// The references found. Null if an error occurred.
        /// </returns>
        public static ReferenceDescriptionCollection BrowseSuperTypes(Session session, NodeId typeId, bool throwOnError)
        {
            ReferenceDescriptionCollection supertypes = new ReferenceDescriptionCollection();

            try
            {
                // find all of the children of the field.
                BrowseDescription nodeToBrowse = new BrowseDescription();

                nodeToBrowse.NodeId = typeId;
                nodeToBrowse.BrowseDirection = BrowseDirection.Inverse;
                nodeToBrowse.ReferenceTypeId = ReferenceTypeIds.HasSubtype;
                nodeToBrowse.IncludeSubtypes = false; // more efficient to use IncludeSubtypes=False when possible.
                nodeToBrowse.NodeClassMask = 0; // the HasSubtype reference already restricts the targets to Types. 
                nodeToBrowse.ResultMask = (uint)BrowseResultMask.All;

                ReferenceDescriptionCollection references = Browse(session, nodeToBrowse, throwOnError);

                while (references != null && references.Count > 0)
                {
                    // should never be more than one supertype.
                    supertypes.Add(references[0]);

                    // only follow references within this server.
                    if (references[0].NodeId.IsAbsolute)
                    {
                        break;
                    }

                    // get the references for the next level up.
                    nodeToBrowse.NodeId = (NodeId)references[0].NodeId;
                    references = Browse(session, nodeToBrowse, throwOnError);
                }

                // return complete list.
                return supertypes;
            }
            catch (Exception exception)
            {
                if (throwOnError)
                {
                    throw new ServiceResultException(exception, StatusCodes.BadUnexpectedError);
                }

                return null;
            }
        }

        /// <summary>
        /// Returns the node ids for a set of relative paths.
        /// </summary>
        /// <param name="session">An open session with the server to use.</param>
        /// <param name="startNodeId">The starting node for the relative paths.</param>
        /// <param name="namespacesUris">The namespace URIs referenced by the relative paths.</param>
        /// <param name="relativePaths">The relative paths.</param>
        /// <returns>A collection of local nodes.</returns>
        public static List<NodeId> TranslateBrowsePaths(
            Session session,
            NodeId startNodeId,
            NamespaceTable namespacesUris,
            params string[] relativePaths)
        {
            // build the list of browse paths to follow by parsing the relative paths.
            BrowsePathCollection browsePaths = new BrowsePathCollection();

            if (relativePaths != null)
            {
                for (int ii = 0; ii < relativePaths.Length; ii++)
                {
                    BrowsePath browsePath = new BrowsePath();

                    // The relative paths used indexes in the namespacesUris table. These must be 
                    // converted to indexes used by the server. An error occurs if the relative path
                    // refers to a namespaceUri that the server does not recognize.

                    // The relative paths may refer to ReferenceType by their BrowseName. The TypeTree object
                    // allows the parser to look up the server's NodeId for the ReferenceType.

                    browsePath.RelativePath = RelativePath.Parse(
                        relativePaths[ii],
                        session.TypeTree,
                        namespacesUris,
                        session.NamespaceUris);

                    browsePath.StartingNode = startNodeId;

                    browsePaths.Add(browsePath);
                }
            }

            // make the call to the server.
            BrowsePathResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = session.TranslateBrowsePathsToNodeIds(
                null,
                browsePaths,
                out results,
                out diagnosticInfos);

            // ensure that the server returned valid results.
            Session.ValidateResponse(results, browsePaths);
            Session.ValidateDiagnosticInfos(diagnosticInfos, browsePaths);

            // collect the list of node ids found.
            List<NodeId> nodes = new List<NodeId>();

            for (int ii = 0; ii < results.Count; ii++)
            {
                // check if the start node actually exists.
                if (StatusCode.IsBad(results[ii].StatusCode))
                {
                    nodes.Add(null);
                    continue;
                }

                // an empty list is returned if no node was found.
                if (results[ii].Targets.Count == 0)
                {
                    nodes.Add(null);
                    continue;
                }

                // Multiple matches are possible, however, the node that matches the type model is the
                // one we are interested in here. The rest can be ignored.
                BrowsePathTarget target = results[ii].Targets[0];

                if (target.RemainingPathIndex != UInt32.MaxValue)
                {
                    nodes.Add(null);
                    continue;
                }

                // The targetId is an ExpandedNodeId because it could be node in another server. 
                // The ToNodeId function is used to convert a local NodeId stored in a ExpandedNodeId to a NodeId.
                nodes.Add(ExpandedNodeId.ToNodeId(target.TargetId, session.NamespaceUris));
            }

            // return whatever was found.
            return nodes;
        }
        #endregion

        #region Events
        /// <summary>
        /// Finds the type of the event for the notification.
        /// </summary>
        /// <param name="monitoredItem">The monitored item.</param>
        /// <param name="notification">The notification.</param>
        /// <returns>The NodeId of the EventType.</returns>
        public static NodeId FindEventType(MonitoredItem monitoredItem, EventFieldList notification)
        {
            EventFilter filter = monitoredItem.Status.Filter as EventFilter;

            if (filter != null)
            {
                for (int ii = 0; ii < filter.SelectClauses.Count; ii++)
                {
                    SimpleAttributeOperand clause = filter.SelectClauses[ii];

                    if (clause.BrowsePath.Count == 1 && clause.BrowsePath[0] == BrowseNames.EventType)
                    {
                        return notification.EventFields[ii].Value as NodeId;
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// Constructs an event object from a notification.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="monitoredItem">The monitored item that produced the notification.</param>
        /// <param name="notification">The notification.</param>
        /// <param name="knownEventTypes">The known event types.</param>
        /// <param name="eventTypeMappings">Mapping between event types and known event types.</param>
        /// <returns>
        /// The event object. Null if the notification is not a valid event type.
        /// </returns>
        public static BaseEventState ConstructEvent(
            Session session,
            MonitoredItem monitoredItem,
            EventFieldList notification,
            Dictionary<NodeId, Type> knownEventTypes,
            Dictionary<NodeId, NodeId> eventTypeMappings)
        {
            // find the event type.
            NodeId eventTypeId = FindEventType(monitoredItem, notification);

            if (eventTypeId == null)
            {
                return null;
            }

            // look up the known event type.
            Type knownType = null;
            NodeId knownTypeId = null;

            if (eventTypeMappings.TryGetValue(eventTypeId, out knownTypeId))
            {
                knownType = knownEventTypes[knownTypeId];
            }

            // try again.
            if (knownType == null)
            {
                if (knownEventTypes.TryGetValue(eventTypeId, out knownType))
                {
                    knownTypeId = eventTypeId;
                    eventTypeMappings.Add(eventTypeId, eventTypeId);
                }
            }

            // try mapping it to a known type.
            if (knownType == null)
            {
                // browse for the supertypes of the event type.
                ReferenceDescriptionCollection supertypes = ClientUtils.BrowseSuperTypes(session, eventTypeId, false);

                // can't do anything with unknown types.
                if (supertypes == null)
                {
                    return null;
                }

                // find the first supertype that matches a known event type.
                for (int ii = 0; ii < supertypes.Count; ii++)
                {
                    NodeId superTypeId = (NodeId)supertypes[ii].NodeId;

                    if (knownEventTypes.TryGetValue(superTypeId, out knownType))
                    {
                        knownTypeId = superTypeId;
                        eventTypeMappings.Add(eventTypeId, superTypeId);
                    }

                    if (knownTypeId != null)
                    {
                        break;
                    }
                }

                // can't do anything with unknown types.
                if (knownTypeId == null)
                {
                    return null;
                }
            }

            // construct the event based on the known event type.
            BaseEventState e = (BaseEventState)Activator.CreateInstance(knownType, new object[] { (NodeState)null });

            // get the filter which defines the contents of the notification.
            EventFilter filter = monitoredItem.Status.Filter as EventFilter;

            // initialize the event with the values in the notification.
            e.Update(session.SystemContext, filter.SelectClauses, notification);

            // save the orginal notification.
            e.Handle = notification;

            return e;
        }
        #endregion


        #region Type Model Browsing
        /// <summary>
        /// Collects the instance declarations for a type.
        /// </summary>
        public static List<InstanceDeclaration> CollectInstanceDeclarationsForType(Session session, NodeId typeId)
        {
            return CollectInstanceDeclarationsForType(session, typeId, true);
        }

        /// <summary>
        /// Collects the instance declarations for a type.
        /// </summary>
        public static List<InstanceDeclaration> CollectInstanceDeclarationsForType(Session session, NodeId typeId, bool includeSupertypes)
        {
            // process the types starting from the top of the tree.
            List<InstanceDeclaration> instances = new List<InstanceDeclaration>();
            Dictionary<string, InstanceDeclaration> map = new Dictionary<string, InstanceDeclaration>();

            // get the supertypes.
            if (includeSupertypes)
            {
                ReferenceDescriptionCollection supertypes = ClientUtils.BrowseSuperTypes(session, typeId, false);

                if (supertypes != null)
                {
                    for (int ii = supertypes.Count - 1; ii >= 0; ii--)
                    {
                        CollectInstanceDeclarations(session, (NodeId)supertypes[ii].NodeId, null, instances, map);
                    }
                }
            }

            // collect the fields for the selected type.
            CollectInstanceDeclarations(session, typeId, null, instances, map);

            // return the complete list.
            return instances;
        }

        /// <summary>
        /// Collects the fields for the instance node.
        /// </summary>
        private static void CollectInstanceDeclarations(
            Session session,
            NodeId typeId,
            InstanceDeclaration parent,
            List<InstanceDeclaration> instances,
            IDictionary<string, InstanceDeclaration> map)
        {
            // find the children.
            BrowseDescription nodeToBrowse = new BrowseDescription();

            if (parent == null)
            {
                nodeToBrowse.NodeId = typeId;
            }
            else
            {
                nodeToBrowse.NodeId = parent.NodeId;
            }

            nodeToBrowse.BrowseDirection = BrowseDirection.Forward;
            nodeToBrowse.ReferenceTypeId = ReferenceTypeIds.HasChild;
            nodeToBrowse.IncludeSubtypes = true;
            nodeToBrowse.NodeClassMask = (uint)(NodeClass.Object | NodeClass.Variable | NodeClass.Method);
            nodeToBrowse.ResultMask = (uint)BrowseResultMask.All;

            // ignore any browsing errors.
            ReferenceDescriptionCollection references = ClientUtils.Browse(session, nodeToBrowse, false);

            if (references == null)
            {
                return;
            }

            // process the children.
            List<NodeId> nodeIds = new List<NodeId>();
            List<InstanceDeclaration> children = new List<InstanceDeclaration>();

            for (int ii = 0; ii < references.Count; ii++)
            {
                ReferenceDescription reference = references[ii];

                if (reference.NodeId.IsAbsolute)
                {
                    continue;
                }

                // create a new declaration.
                InstanceDeclaration child = new InstanceDeclaration();

                child.RootTypeId = typeId;
                child.NodeId = (NodeId)reference.NodeId;
                child.BrowseName = reference.BrowseName;
                child.NodeClass = reference.NodeClass;

                if (!LocalizedText.IsNullOrEmpty(reference.DisplayName))
                {
                    child.DisplayName = reference.DisplayName.Text;
                }
                else
                {
                    child.DisplayName = reference.BrowseName.Name;
                }

                if (parent != null)
                {
                    child.BrowsePath = new QualifiedNameCollection(parent.BrowsePath);
                    child.BrowsePathDisplayText = Utils.Format("{0}/{1}", parent.BrowsePathDisplayText, reference.BrowseName);
                    child.DisplayPath = Utils.Format("{0}/{1}", parent.DisplayPath, reference.DisplayName);
                }
                else
                {
                    child.BrowsePath = new QualifiedNameCollection();
                    child.BrowsePathDisplayText = Utils.Format("{0}", reference.BrowseName);
                    child.DisplayPath = Utils.Format("{0}", reference.DisplayName);
                }

                child.BrowsePath.Add(reference.BrowseName);

                // check if reading an overridden declaration.
                InstanceDeclaration overriden = null;

                if (map.TryGetValue(child.BrowsePathDisplayText, out overriden))
                {
                    child.OverriddenDeclaration = overriden;
                }

                map[child.BrowsePathDisplayText] = child;

                // add to list.
                children.Add(child);
                nodeIds.Add(child.NodeId);
            }

            // check if nothing more to do.
            if (children.Count == 0)
            {
                return;
            }

            // find the modelling rules.
            List<NodeId> modellingRules = FindTargetOfReference(session, nodeIds, Opc.Ua.ReferenceTypeIds.HasModellingRule, false);

            if (modellingRules != null)
            {
                for (int ii = 0; ii < nodeIds.Count; ii++)
                {
                    children[ii].ModellingRule = modellingRules[ii];

                    // if the modelling rule is null then the instance is not part of the type declaration.
                    if (NodeId.IsNull(modellingRules[ii]))
                    {
                        map.Remove(children[ii].BrowsePathDisplayText);
                    }
                }
            }

            // update the descriptions.
            UpdateInstanceDescriptions(session, children, false);

            // recusively collect instance declarations for the tree below.
            for (int ii = 0; ii < children.Count; ii++)
            {
                if (!NodeId.IsNull(children[ii].ModellingRule))
                {
                    instances.Add(children[ii]);
                    CollectInstanceDeclarations(session, typeId, children[ii], instances, map);
                }
            }
        }

        /// <summary>
        /// Finds the targets for the specified reference.
        /// </summary>
        private static List<NodeId> FindTargetOfReference(Session session, List<NodeId> nodeIds, NodeId referenceTypeId, bool throwOnError)
        {
            try
            {
                // construct browse request.
                BrowseDescriptionCollection nodesToBrowse = new BrowseDescriptionCollection();

                for (int ii = 0; ii < nodeIds.Count; ii++)
                {
                    BrowseDescription nodeToBrowse = new BrowseDescription();
                    nodeToBrowse.NodeId = nodeIds[ii];
                    nodeToBrowse.BrowseDirection = BrowseDirection.Forward;
                    nodeToBrowse.ReferenceTypeId = referenceTypeId;
                    nodeToBrowse.IncludeSubtypes = false;
                    nodeToBrowse.NodeClassMask = 0;
                    nodeToBrowse.ResultMask = (uint)BrowseResultMask.None;
                    nodesToBrowse.Add(nodeToBrowse);
                }

                // start the browse operation.
                BrowseResultCollection results = null;
                DiagnosticInfoCollection diagnosticInfos = null;

                session.Browse(
                    null,
                    null,
                    1,
                    nodesToBrowse,
                    out results,
                    out diagnosticInfos);

                ClientBase.ValidateResponse(results, nodesToBrowse);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToBrowse);

                List<NodeId> targetIds = new List<NodeId>();
                ByteStringCollection continuationPoints = new ByteStringCollection();

                for (int ii = 0; ii < nodeIds.Count; ii++)
                {
                    targetIds.Add(null);

                    // check for error.
                    if (StatusCode.IsBad(results[ii].StatusCode))
                    {
                        continue;
                    }

                    // check for continuation point.
                    if (results[ii].ContinuationPoint != null && results[ii].ContinuationPoint.Length > 0)
                    {
                        continuationPoints.Add(results[ii].ContinuationPoint);
                    }

                    // get the node id.
                    if (results[ii].References.Count > 0)
                    {
                        if (NodeId.IsNull(results[ii].References[0].NodeId) || results[ii].References[0].NodeId.IsAbsolute)
                        {
                            continue;
                        }

                        targetIds[ii] = (NodeId)results[ii].References[0].NodeId;
                    }
                }

                // release continuation points.
                if (continuationPoints.Count > 0)
                {
                    session.BrowseNext(
                        null,
                        true,
                        continuationPoints,
                        out results,
                        out diagnosticInfos);

                    ClientBase.ValidateResponse(results, nodesToBrowse);
                    ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToBrowse);
                }

                //return complete list.
                return targetIds;
            }
            catch (Exception exception)
            {
                if (throwOnError)
                {
                    throw new ServiceResultException(exception, StatusCodes.BadUnexpectedError);
                }

                return null;
            }
        }

        /// <summary>
        /// Finds the targets for the specified reference.
        /// </summary>
        private static void UpdateInstanceDescriptions(Session session, List<InstanceDeclaration> instances, bool throwOnError)
        {
            try
            {
                ReadValueIdCollection nodesToRead = new ReadValueIdCollection();

                for (int ii = 0; ii < instances.Count; ii++)
                {
                    ReadValueId nodeToRead = new ReadValueId();
                    nodeToRead.NodeId = instances[ii].NodeId;
                    nodeToRead.AttributeId = Attributes.Description;
                    nodesToRead.Add(nodeToRead);

                    nodeToRead = new ReadValueId();
                    nodeToRead.NodeId = instances[ii].NodeId;
                    nodeToRead.AttributeId = Attributes.DataType;
                    nodesToRead.Add(nodeToRead);

                    nodeToRead = new ReadValueId();
                    nodeToRead.NodeId = instances[ii].NodeId;
                    nodeToRead.AttributeId = Attributes.ValueRank;
                    nodesToRead.Add(nodeToRead);
                }

                // start the browse operation.
                DataValueCollection results = null;
                DiagnosticInfoCollection diagnosticInfos = null;

                session.Read(
                    null,
                    0,
                    TimestampsToReturn.Neither,
                    nodesToRead,
                    out results,
                    out diagnosticInfos);

                ClientBase.ValidateResponse(results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);

                // update the instances.
                for (int ii = 0; ii < nodesToRead.Count; ii += 3)
                {
                    InstanceDeclaration instance = instances[ii / 3];

                    instance.Description = results[ii].GetValue<LocalizedText>(LocalizedText.Null).Text;
                    instance.DataType = results[ii + 1].GetValue<NodeId>(NodeId.Null);
                    instance.ValueRank = results[ii + 2].GetValue<int>(ValueRanks.Any);

                    if (!NodeId.IsNull(instance.DataType))
                    {
                        instance.BuiltInType = DataTypes.GetBuiltInType(instance.DataType, session.TypeTree);
                        instance.DataTypeDisplayText = session.NodeCache.GetDisplayText(instance.DataType);

                        if (instance.ValueRank >= 0)
                        {
                            instance.DataTypeDisplayText += "[]";
                        }
                    }
                }
            }
            catch (Exception exception)
            {
                if (throwOnError)
                {
                    throw new ServiceResultException(exception, StatusCodes.BadUnexpectedError);
                }
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Collects the fields for the type.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="typeId">The type id.</param>
        /// <param name="fields">The fields.</param>
        /// <param name="fieldNodeIds">The node id for the declaration of the field.</param>
        private static void CollectFieldsForType(Session session, NodeId typeId, SimpleAttributeOperandCollection fields, List<NodeId> fieldNodeIds)
        {
            // get the supertypes.
            ReferenceDescriptionCollection supertypes = ClientUtils.BrowseSuperTypes(session, typeId, false);

            if (supertypes == null)
            {
                return;
            }

            // process the types starting from the top of the tree.
            Dictionary<NodeId, QualifiedNameCollection> foundNodes = new Dictionary<NodeId, QualifiedNameCollection>();
            QualifiedNameCollection parentPath = new QualifiedNameCollection();

            for (int ii = supertypes.Count - 1; ii >= 0; ii--)
            {
                CollectFields(session, (NodeId)supertypes[ii].NodeId, parentPath, fields, fieldNodeIds, foundNodes);
            }

            // collect the fields for the selected type.
            CollectFields(session, typeId, parentPath, fields, fieldNodeIds, foundNodes);
        }

        /// <summary>
        /// Collects the fields for the instance.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="instanceId">The instance id.</param>
        /// <param name="fields">The fields.</param>
        /// <param name="fieldNodeIds">The node id for the declaration of the field.</param>
        private static void CollectFieldsForInstance(Session session, NodeId instanceId, SimpleAttributeOperandCollection fields, List<NodeId> fieldNodeIds)
        {
            Dictionary<NodeId, QualifiedNameCollection> foundNodes = new Dictionary<NodeId, QualifiedNameCollection>();
            QualifiedNameCollection parentPath = new QualifiedNameCollection();
            CollectFields(session, instanceId, parentPath, fields, fieldNodeIds, foundNodes);
        }

        /// <summary>
        /// Collects the fields for the instance node.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="nodeId">The node id.</param>
        /// <param name="parentPath">The parent path.</param>
        /// <param name="fields">The event fields.</param>
        /// <param name="fieldNodeIds">The node id for the declaration of the field.</param>
        /// <param name="foundNodes">The table of found nodes.</param>
        private static void CollectFields(
            Session session,
            NodeId nodeId,
            QualifiedNameCollection parentPath,
            SimpleAttributeOperandCollection fields,
            List<NodeId> fieldNodeIds,
            Dictionary<NodeId, QualifiedNameCollection> foundNodes)
        {
            // find all of the children of the field.
            BrowseDescription nodeToBrowse = new BrowseDescription();

            nodeToBrowse.NodeId = nodeId;
            nodeToBrowse.BrowseDirection = BrowseDirection.Forward;
            nodeToBrowse.ReferenceTypeId = ReferenceTypeIds.Aggregates;
            nodeToBrowse.IncludeSubtypes = true;
            nodeToBrowse.NodeClassMask = (uint)(NodeClass.Object | NodeClass.Variable);
            nodeToBrowse.ResultMask = (uint)BrowseResultMask.All;

            ReferenceDescriptionCollection children = ClientUtils.Browse(session, nodeToBrowse, false);

            if (children == null)
            {
                return;
            }

            // process the children.
            for (int ii = 0; ii < children.Count; ii++)
            {
                ReferenceDescription child = children[ii];

                if (child.NodeId.IsAbsolute)
                {
                    continue;
                }

                // construct browse path.
                QualifiedNameCollection browsePath = new QualifiedNameCollection(parentPath);
                browsePath.Add(child.BrowseName);

                // check if the browse path is already in the list.
                int index = ContainsPath(fields, browsePath);

                if (index < 0)
                {
                    SimpleAttributeOperand field = new SimpleAttributeOperand();

                    field.TypeDefinitionId = ObjectTypeIds.BaseEventType;
                    field.BrowsePath = browsePath;
                    field.AttributeId = (child.NodeClass == NodeClass.Variable) ? Attributes.Value : Attributes.NodeId;

                    fields.Add(field);
                    fieldNodeIds.Add((NodeId)child.NodeId);
                }

                // recusively find all of the children.
                NodeId targetId = (NodeId)child.NodeId;

                // need to guard against loops.
                if (!foundNodes.ContainsKey(targetId))
                {
                    foundNodes.Add(targetId, browsePath);
                    CollectFields(session, (NodeId)child.NodeId, browsePath, fields, fieldNodeIds, foundNodes);
                }
            }
        }

        /// <summary>
        /// Determines whether the specified select clause contains the browse path.
        /// </summary>
        /// <param name="selectClause">The select clause.</param>
        /// <param name="browsePath">The browse path.</param>
        /// <returns>
        /// 	<c>true</c> if the specified select clause contains path; otherwise, <c>false</c>.
        /// </returns>
        private static int ContainsPath(SimpleAttributeOperandCollection selectClause, QualifiedNameCollection browsePath)
        {
            for (int ii = 0; ii < selectClause.Count; ii++)
            {
                SimpleAttributeOperand field = selectClause[ii];

                if (field.BrowsePath.Count != browsePath.Count)
                {
                    continue;
                }

                bool match = true;

                for (int jj = 0; jj < field.BrowsePath.Count; jj++)
                {
                    if (field.BrowsePath[jj] != browsePath[jj])
                    {
                        match = false;
                        break;
                    }
                }

                if (match)
                {
                    return ii;
                }
            }

            return -1;
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Text;

namespace Opc.Ua.Client.Controls
{
    /// <summary>
    /// Defines numerous re-useable utility functions.
    /// </summary>
    public partial class ClientUtils
    {
        /// <summary>
        /// Handles an exception.
        /// </summary>
        public static void HandleException(string caption, Exception e)
        {
            ExceptionDlg.Show(caption, e);
        }

        /// <summary>
        /// Returns the application icon.
        /// </summary>
        public static System.Drawing.Icon GetAppIcon()
        {
            try
            {
                return new Icon("App.ico");
            }
            catch (Exception)
            {
                return null;
            }
        }

        #region DisplayText Lookup
        /// <summary>
        /// Gets the display text for the access level attribute.
        /// </summary>
        /// <param name="accessLevel">The access level.</param>
        /// <returns>The access level formatted as a string.</returns>
        public static string GetAccessLevelDisplayText(byte accessLevel)
        {
            StringBuilder buffer = new StringBuilder();

            if (accessLevel == AccessLevels.None)
            {
                buffer.Append("None");
            }

            if ((accessLevel & AccessLevels.CurrentRead) == AccessLevels.CurrentRead)
            {
                buffer.Append("Read");
            }

            if ((accessLevel & AccessLevels.CurrentWrite) == AccessLevels.CurrentWrite)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("Write");
            }

            if ((accessLevel & AccessLevels.HistoryRead) == AccessLevels.HistoryRead)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("HistoryRead");
            }

            if ((accessLevel & AccessLevels.HistoryWrite) == AccessLevels.HistoryWrite)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("HistoryWrite");
            }

            if ((accessLevel & AccessLevels.SemanticChange) == AccessLevels.SemanticChange)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("SemanticChange");
            }

            return buffer.ToString();
        }

        /// <summary>
        /// Gets the display text for the event notifier attribute.
        /// </summary>
        /// <param name="eventNotifier">The event notifier.</param>
        /// <returns>The event notifier formatted as a string.</returns>
        public static string GetEventNotifierDisplayText(byte eventNotifier)
        {
            StringBuilder buffer = new StringBuilder();

            if (eventNotifier == EventNotifiers.None)
            {
                buffer.Append("None");
            }

            if ((eventNotifier & EventNotifiers.SubscribeToEvents) == EventNotifiers.SubscribeToEvents)
            {
                buffer.Append("Subscribe");
            }

            if ((eventNotifier & EventNotifiers.HistoryRead) == EventNotifiers.HistoryRead)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("HistoryRead");
            }

            if ((eventNotifier & EventNotifiers.HistoryWrite) == EventNotifiers.HistoryWrite)
            {
                if (buffer.Length > 0)
                {
                    buffer.Append(" | ");
                }

                buffer.Append("HistoryWrite");
            }

            return buffer.ToString();
        }

        /// <summary>
        /// Gets the display text for the value rank attribute.
        /// </summary>
        /// <param name="valueRank">The value rank.</param>
        /// <returns>The value rank formatted as a string.</returns>
        public static string GetValueRankDisplayText(int valueRank)
        {
            switch (valueRank)
            {
                case ValueRanks.Any: return "Any";
                case ValueRanks.Scalar: return "Scalar";
                case ValueRanks.ScalarOrOneDimension: return "ScalarOrOneDimension";
                case ValueRanks.OneOrMoreDimensions: return "OneOrMoreDimensions";
                case ValueRanks.OneDimension: return "OneDimension";
                case ValueRanks.TwoDimensions: return "TwoDimensions";
            }

            return valueRank.ToString();
        }

        /// <summary>
        /// Gets the display text for the specified attribute.
        /// </summary>
        /// <param name="session">The currently active session.</param>
        /// <param name="attributeId">The id of the attribute.</param>
        /// <param name="value">The value of the attribute.</param>
        /// <returns>The attribute formatted as a string.</returns>
        public static string GetAttributeDisplayText(Session session, uint attributeId, Variant value)
        {
            if (value == Variant.Null)
            {
                return String.Empty;
            }

            switch (attributeId)
            {
                case Attributes.AccessLevel:
                case Attributes.UserAccessLevel:
                    {
                        if (value.Value is byte? field)
                        {
                            return GetAccessLevelDisplayText(field.Value);
                        }

                        break;
                    }

                case Attributes.EventNotifier:
                    {
                        if (value.Value is byte? field)
                        {
                            return GetEventNotifierDisplayText(field.Value);
                        }

                        break;
                    }

                case Attributes.DataType:
                    {
                        return session.NodeCache.GetDisplayText(value.Value as NodeId);
                    }

                case Attributes.ValueRank:
                    {
                        if (value.Value is byte? field)
                        {
                            return GetValueRankDisplayText(field.Value);
                        }

                        break;
                    }

                case Attributes.NodeClass:
                    {
                        if (value.Value is byte? field)
                        {
                            return ((NodeClass)field.Value).ToString();
                        }

                        break;
                    }

                case Attributes.NodeId:
                    {

                        if (!NodeId.IsNull(field))
                        {
                            return field.ToString();
                        }

                        return "Null";
                    }

                case Attributes.DataTypeDefinition:
                    {
                        if (value.Value is byte? field)
                        {
                            return field.ToString();
                        }
                        break;
                    }
            }

            // check for byte strings.
            if (value.Value is byte[])
            {
                return Utils.ToHexString(value.Value as byte[]);
            }

            // use default format.
            return value.ToString();
        }
        #endregion

        #region Browse
        /// <summary>
        /// Browses the address space and returns the references found.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="nodesToBrowse">The set of browse operations to perform.</param>
        /// <param name="throwOnError">if set to <c>true</c> a exception will be thrown on an error.</param>
        /// <returns>
        /// The references found. Null if an error occurred.
        /// </returns>
        public static ReferenceDescriptionCollection Browse(Session session, BrowseDescriptionCollection nodesToBrowse, bool throwOnError)
        {
            return Browse(session, null, nodesToBrowse, throwOnError);
        }

        /// <summary>
        /// Browses the address space and returns the references found.
        /// </summary>
        public static ReferenceDescriptionCollection Browse(Session session, ViewDescription view, BrowseDescriptionCollection nodesToBrowse, bool throwOnError)
        {
            try
            {
                ReferenceDescriptionCollection references = new ReferenceDescriptionCollection();
                BrowseDescriptionCollection unprocessedOperations = new BrowseDescriptionCollection();

                while (nodesToBrowse.Count > 0)
                {
                    // start the browse operation.
                    BrowseResultCollection results = null;
                    DiagnosticInfoCollection diagnosticInfos = null;

                    session.Browse(
                        null,
                        view,
                        0,
                        nodesToBrowse,
                        out results,
                        out diagnosticInfos);

                    ClientBase.ValidateResponse(results, nodesToBrowse);
                    ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToBrowse);

                    ByteStringCollection continuationPoints = new ByteStringCollection();

                    for (int ii = 0; ii < nodesToBrowse.Count; ii++)
                    {
                        // check for error.
                        if (StatusCode.IsBad(results[ii].StatusCode))
                        {
                            // this error indicates that the server does not have enough simultaneously active 
                            // continuation points. This request will need to be resent after the other operations
                            // have been completed and their continuation points released.
                            if (results[ii].StatusCode == StatusCodes.BadNoContinuationPoints)
                            {
                                unprocessedOperations.Add(nodesToBrowse[ii]);
                            }

                            continue;
                        }

                        // check if all references have been fetched.
                        if (results[ii].References.Count == 0)
                        {
                            continue;
                        }

                        // save results.
                        references.AddRange(results[ii].References);

                        // check for continuation point.
                        if (results[ii].ContinuationPoint != null)
                        {
                            continuationPoints.Add(results[ii].ContinuationPoint);
                        }
                    }

                    // process continuation points.
                    ByteStringCollection revisedContiuationPoints = new ByteStringCollection();

                    while (continuationPoints.Count > 0)
                    {
                        // continue browse operation.
                        session.BrowseNext(
                            null,
                            false,
                            continuationPoints,
                            out results,
                            out diagnosticInfos);

                        ClientBase.ValidateResponse(results, continuationPoints);
                        ClientBase.ValidateDiagnosticInfos(diagnosticInfos, continuationPoints);

                        for (int ii = 0; ii < continuationPoints.Count; ii++)
                        {
                            // check for error.
                            if (StatusCode.IsBad(results[ii].StatusCode))
                            {
                                continue;
                            }

                            // check if all references have been fetched.
                            if (results[ii].References.Count == 0)
                            {
                                continue;
                            }

                            // save results.
                            references.AddRange(results[ii].References);

                            // check for continuation point.
                            if (results[ii].ContinuationPoint != null)
                            {
                                revisedContiuationPoints.Add(results[ii].ContinuationPoint);
                            }
                        }

                        // check if browsing must continue;
                        revisedContiuationPoints = continuationPoints;
                    }

                    // check if unprocessed results exist.
                    nodesToBrowse = unprocessedOperations;
                }

                // return complete list.
                return references;
            }
            catch (Exception exception)
            {
                if (throwOnError)
                {
                    throw new ServiceResultException(exception, StatusCodes.BadUnexpectedError);
                }

                return null;
            }
        }

        /// <summary>
        /// Browses the address space and returns the references found.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="nodeToBrowse">The NodeId for the starting node.</param>
        /// <param name="throwOnError">if set to <c>true</c> a exception will be thrown on an error.</param>
        /// <returns>
        /// The references found. Null if an error occurred.
        /// </returns>
        public static ReferenceDescriptionCollection Browse(Session session, BrowseDescription nodeToBrowse, bool throwOnError)
        {
            return Browse(session, null, nodeToBrowse, throwOnError);
        }

        /// <summary>
        /// Browses the address space and returns the references found.
        /// </summary>
        public static ReferenceDescriptionCollection Browse(Session session, ViewDescription view, BrowseDescription nodeToBrowse, bool throwOnError)
        {
            try
            {
                ReferenceDescriptionCollection references = new ReferenceDescriptionCollection();

                // construct browse request.
                BrowseDescriptionCollection nodesToBrowse = new BrowseDescriptionCollection();
                nodesToBrowse.Add(nodeToBrowse);

                // start the browse operation.
                BrowseResultCollection results = null;
                DiagnosticInfoCollection diagnosticInfos = null;

                session.Browse(
                    null,
                    view,
                    0,
                    nodesToBrowse,
                    out results,
                    out diagnosticInfos);

                ClientBase.ValidateResponse(results, nodesToBrowse);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToBrowse);

                do
                {
                    // check for error.
                    if (StatusCode.IsBad(results[0].StatusCode))
                    {
                        throw new ServiceResultException(results[0].StatusCode);
                    }

                    // process results.
                    for (int ii = 0; ii < results[0].References.Count; ii++)
                    {
                        references.Add(results[0].References[ii]);
                    }

                    // check if all references have been fetched.
                    if (results[0].References.Count == 0 || results[0].ContinuationPoint == null)
                    {
                        break;
                    }

                    // continue browse operation.
                    ByteStringCollection continuationPoints = new ByteStringCollection();
                    continuationPoints.Add(results[0].ContinuationPoint);

                    session.BrowseNext(
                        null,
                        false,
                        continuationPoints,
                        out results,
                        out diagnosticInfos);

                    ClientBase.ValidateResponse(results, continuationPoints);
                    ClientBase.ValidateDiagnosticInfos(diagnosticInfos, continuationPoints);
                }
                while (true);

                //return complete list.
                return references;
            }
            catch (Exception exception)
            {
                if (throwOnError)
                {
                    throw new ServiceResultException(exception, StatusCodes.BadUnexpectedError);
                }

                return null;
            }
        }

        /// <summary>
        /// Browses the address space and returns all of the supertypes of the specified type node.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="typeId">The NodeId for a type node in the address space.</param>
        /// <param name="throwOnError">if set to <c>true</c> a exception will be thrown on an error.</param>
        /// <returns>
        /// The references found. Null if an error occurred.
        /// </returns>
        public static ReferenceDescriptionCollection BrowseSuperTypes(Session session, NodeId typeId, bool throwOnError)
        {
            ReferenceDescriptionCollection supertypes = new ReferenceDescriptionCollection();

            try
            {
                // find all of the children of the field.
                BrowseDescription nodeToBrowse = new BrowseDescription();

                nodeToBrowse.NodeId = typeId;
                nodeToBrowse.BrowseDirection = BrowseDirection.Inverse;
                nodeToBrowse.ReferenceTypeId = ReferenceTypeIds.HasSubtype;
                nodeToBrowse.IncludeSubtypes = false; // more efficient to use IncludeSubtypes=False when possible.
                nodeToBrowse.NodeClassMask = 0; // the HasSubtype reference already restricts the targets to Types. 
                nodeToBrowse.ResultMask = (uint)BrowseResultMask.All;

                ReferenceDescriptionCollection references = Browse(session, nodeToBrowse, throwOnError);

                while (references != null && references.Count > 0)
                {
                    // should never be more than one supertype.
                    supertypes.Add(references[0]);

                    // only follow references within this server.
                    if (references[0].NodeId.IsAbsolute)
                    {
                        break;
                    }

                    // get the references for the next level up.
                    nodeToBrowse.NodeId = (NodeId)references[0].NodeId;
                    references = Browse(session, nodeToBrowse, throwOnError);
                }

                // return complete list.
                return supertypes;
            }
            catch (Exception exception)
            {
                if (throwOnError)
                {
                    throw new ServiceResultException(exception, StatusCodes.BadUnexpectedError);
                }

                return null;
            }
        }

        /// <summary>
        /// Returns the node ids for a set of relative paths.
        /// </summary>
        /// <param name="session">An open session with the server to use.</param>
        /// <param name="startNodeId">The starting node for the relative paths.</param>
        /// <param name="namespacesUris">The namespace URIs referenced by the relative paths.</param>
        /// <param name="relativePaths">The relative paths.</param>
        /// <returns>A collection of local nodes.</returns>
        public static List<NodeId> TranslateBrowsePaths(
            Session session,
            NodeId startNodeId,
            NamespaceTable namespacesUris,
            params string[] relativePaths)
        {
            // build the list of browse paths to follow by parsing the relative paths.
            BrowsePathCollection browsePaths = new BrowsePathCollection();

            if (relativePaths != null)
            {
                for (int ii = 0; ii < relativePaths.Length; ii++)
                {
                    BrowsePath browsePath = new BrowsePath();

                    // The relative paths used indexes in the namespacesUris table. These must be 
                    // converted to indexes used by the server. An error occurs if the relative path
                    // refers to a namespaceUri that the server does not recognize.

                    // The relative paths may refer to ReferenceType by their BrowseName. The TypeTree object
                    // allows the parser to look up the server's NodeId for the ReferenceType.

                    browsePath.RelativePath = RelativePath.Parse(
                        relativePaths[ii],
                        session.TypeTree,
                        namespacesUris,
                        session.NamespaceUris);

                    browsePath.StartingNode = startNodeId;

                    browsePaths.Add(browsePath);
                }
            }

            // make the call to the server.
            BrowsePathResultCollection results;
            DiagnosticInfoCollection diagnosticInfos;

            ResponseHeader responseHeader = session.TranslateBrowsePathsToNodeIds(
                null,
                browsePaths,
                out results,
                out diagnosticInfos);

            // ensure that the server returned valid results.
            Session.ValidateResponse(results, browsePaths);
            Session.ValidateDiagnosticInfos(diagnosticInfos, browsePaths);

            // collect the list of node ids found.
            List<NodeId> nodes = new List<NodeId>();

            for (int ii = 0; ii < results.Count; ii++)
            {
                // check if the start node actually exists.
                if (StatusCode.IsBad(results[ii].StatusCode))
                {
                    nodes.Add(null);
                    continue;
                }

                // an empty list is returned if no node was found.
                if (results[ii].Targets.Count == 0)
                {
                    nodes.Add(null);
                    continue;
                }

                // Multiple matches are possible, however, the node that matches the type model is the
                // one we are interested in here. The rest can be ignored.
                BrowsePathTarget target = results[ii].Targets[0];

                if (target.RemainingPathIndex != UInt32.MaxValue)
                {
                    nodes.Add(null);
                    continue;
                }

                // The targetId is an ExpandedNodeId because it could be node in another server. 
                // The ToNodeId function is used to convert a local NodeId stored in a ExpandedNodeId to a NodeId.
                nodes.Add(ExpandedNodeId.ToNodeId(target.TargetId, session.NamespaceUris));
            }

            // return whatever was found.
            return nodes;
        }
        #endregion

        #region Events
        /// <summary>
        /// Finds the type of the event for the notification.
        /// </summary>
        /// <param name="monitoredItem">The monitored item.</param>
        /// <param name="notification">The notification.</param>
        /// <returns>The NodeId of the EventType.</returns>
        public static NodeId FindEventType(MonitoredItem monitoredItem, EventFieldList notification)
        {
            if (monitoredItem.Status.Filter is EventFilter filter)
            {
                for (int ii = 0; ii < filter.SelectClauses.Count; ii++)
                {
                    SimpleAttributeOperand clause = filter.SelectClauses[ii];

                    if (clause.BrowsePath.Count == 1 && clause.BrowsePath[0] == BrowseNames.EventType)
                    {
                        return notification.EventFields[ii].Value as NodeId;
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// Constructs an event object from a notification.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="monitoredItem">The monitored item that produced the notification.</param>
        /// <param name="notification">The notification.</param>
        /// <param name="knownEventTypes">The known event types.</param>
        /// <param name="eventTypeMappings">Mapping between event types and known event types.</param>
        /// <returns>
        /// The event object. Null if the notification is not a valid event type.
        /// </returns>
        public static BaseEventState ConstructEvent(
            Session session,
            MonitoredItem monitoredItem,
            EventFieldList notification,
            Dictionary<NodeId, Type> knownEventTypes,
            Dictionary<NodeId, NodeId> eventTypeMappings)
        {
            // find the event type.
            NodeId eventTypeId = FindEventType(monitoredItem, notification);

            if (eventTypeId == null)
            {
                return null;
            }

            // look up the known event type.
            Type knownType = null;
            NodeId knownTypeId = null;

            if (eventTypeMappings.TryGetValue(eventTypeId, out knownTypeId))
            {
                knownType = knownEventTypes[knownTypeId];
            }

            // try again.
            if (knownType == null)
            {
                if (knownEventTypes.TryGetValue(eventTypeId, out knownType))
                {
                    knownTypeId = eventTypeId;
                    eventTypeMappings.Add(eventTypeId, eventTypeId);
                }
            }

            // try mapping it to a known type.
            if (knownType == null)
            {
                // browse for the supertypes of the event type.
                ReferenceDescriptionCollection supertypes = ClientUtils.BrowseSuperTypes(session, eventTypeId, false);

                // can't do anything with unknown types.
                if (supertypes == null)
                {
                    return null;
                }

                // find the first supertype that matches a known event type.
                for (int ii = 0; ii < supertypes.Count; ii++)
                {
                    NodeId superTypeId = (NodeId)supertypes[ii].NodeId;

                    if (knownEventTypes.TryGetValue(superTypeId, out knownType))
                    {
                        knownTypeId = superTypeId;
                        eventTypeMappings.Add(eventTypeId, superTypeId);
                    }

                    if (knownTypeId != null)
                    {
                        break;
                    }
                }

                // can't do anything with unknown types.
                if (knownTypeId == null)
                {
                    return null;
                }
            }

            // construct the event based on the known event type.
            BaseEventState e = (BaseEventState)Activator.CreateInstance(knownType, new object[] { (NodeState)null });

            // get the filter which defines the contents of the notification.
            EventFilter filter = monitoredItem.Status.Filter as EventFilter;

            // initialize the event with the values in the notification.
            e.Update(session.SystemContext, filter.SelectClauses, notification);

            // save the orginal notification.
            e.Handle = notification;

            return e;
        }
        #endregion


        #region Type Model Browsing
        /// <summary>
        /// Collects the instance declarations for a type.
        /// </summary>
        public static List<InstanceDeclaration> CollectInstanceDeclarationsForType(Session session, NodeId typeId)
        {
            return CollectInstanceDeclarationsForType(session, typeId, true);
        }

        /// <summary>
        /// Collects the instance declarations for a type.
        /// </summary>
        public static List<InstanceDeclaration> CollectInstanceDeclarationsForType(Session session, NodeId typeId, bool includeSupertypes)
        {
            // process the types starting from the top of the tree.
            List<InstanceDeclaration> instances = new List<InstanceDeclaration>();
            Dictionary<string, InstanceDeclaration> map = new Dictionary<string, InstanceDeclaration>();

            // get the supertypes.
            if (includeSupertypes)
            {
                ReferenceDescriptionCollection supertypes = ClientUtils.BrowseSuperTypes(session, typeId, false);

                if (supertypes != null)
                {
                    for (int ii = supertypes.Count - 1; ii >= 0; ii--)
                    {
                        CollectInstanceDeclarations(session, (NodeId)supertypes[ii].NodeId, null, instances, map);
                    }
                }
            }

            // collect the fields for the selected type.
            CollectInstanceDeclarations(session, typeId, null, instances, map);

            // return the complete list.
            return instances;
        }

        /// <summary>
        /// Collects the fields for the instance node.
        /// </summary>
        private static void CollectInstanceDeclarations(
            Session session,
            NodeId typeId,
            InstanceDeclaration parent,
            List<InstanceDeclaration> instances,
            IDictionary<string, InstanceDeclaration> map)
        {
            // find the children.
            BrowseDescription nodeToBrowse = new BrowseDescription();

            if (parent == null)
            {
                nodeToBrowse.NodeId = typeId;
            }
            else
            {
                nodeToBrowse.NodeId = parent.NodeId;
            }

            nodeToBrowse.BrowseDirection = BrowseDirection.Forward;
            nodeToBrowse.ReferenceTypeId = ReferenceTypeIds.HasChild;
            nodeToBrowse.IncludeSubtypes = true;
            nodeToBrowse.NodeClassMask = (uint)(NodeClass.Object | NodeClass.Variable | NodeClass.Method);
            nodeToBrowse.ResultMask = (uint)BrowseResultMask.All;

            // ignore any browsing errors.
            ReferenceDescriptionCollection references = ClientUtils.Browse(session, nodeToBrowse, false);

            if (references == null)
            {
                return;
            }

            // process the children.
            List<NodeId> nodeIds = new List<NodeId>();
            List<InstanceDeclaration> children = new List<InstanceDeclaration>();

            for (int ii = 0; ii < references.Count; ii++)
            {
                ReferenceDescription reference = references[ii];

                if (reference.NodeId.IsAbsolute)
                {
                    continue;
                }

                // create a new declaration.
                InstanceDeclaration child = new InstanceDeclaration();

                child.RootTypeId = typeId;
                child.NodeId = (NodeId)reference.NodeId;
                child.BrowseName = reference.BrowseName;
                child.NodeClass = reference.NodeClass;

                if (!LocalizedText.IsNullOrEmpty(reference.DisplayName))
                {
                    child.DisplayName = reference.DisplayName.Text;
                }
                else
                {
                    child.DisplayName = reference.BrowseName.Name;
                }

                if (parent != null)
                {
                    child.BrowsePath = new QualifiedNameCollection(parent.BrowsePath);
                    child.BrowsePathDisplayText = Utils.Format("{0}/{1}", parent.BrowsePathDisplayText, reference.BrowseName);
                    child.DisplayPath = Utils.Format("{0}/{1}", parent.DisplayPath, reference.DisplayName);
                }
                else
                {
                    child.BrowsePath = new QualifiedNameCollection();
                    child.BrowsePathDisplayText = Utils.Format("{0}", reference.BrowseName);
                    child.DisplayPath = Utils.Format("{0}", reference.DisplayName);
                }

                child.BrowsePath.Add(reference.BrowseName);

                // check if reading an overridden declaration.
                InstanceDeclaration overriden = null;

                if (map.TryGetValue(child.BrowsePathDisplayText, out overriden))
                {
                    child.OverriddenDeclaration = overriden;
                }

                map[child.BrowsePathDisplayText] = child;

                // add to list.
                children.Add(child);
                nodeIds.Add(child.NodeId);
            }

            // check if nothing more to do.
            if (children.Count == 0)
            {
                return;
            }

            // find the modelling rules.
            List<NodeId> modellingRules = FindTargetOfReference(session, nodeIds, Opc.Ua.ReferenceTypeIds.HasModellingRule, false);

            if (modellingRules != null)
            {
                for (int ii = 0; ii < nodeIds.Count; ii++)
                {
                    children[ii].ModellingRule = modellingRules[ii];

                    // if the modelling rule is null then the instance is not part of the type declaration.
                    if (NodeId.IsNull(modellingRules[ii]))
                    {
                        map.Remove(children[ii].BrowsePathDisplayText);
                    }
                }
            }

            // update the descriptions.
            UpdateInstanceDescriptions(session, children, false);

            // recusively collect instance declarations for the tree below.
            for (int ii = 0; ii < children.Count; ii++)
            {
                if (!NodeId.IsNull(children[ii].ModellingRule))
                {
                    instances.Add(children[ii]);
                    CollectInstanceDeclarations(session, typeId, children[ii], instances, map);
                }
            }
        }

        /// <summary>
        /// Finds the targets for the specified reference.
        /// </summary>
        private static List<NodeId> FindTargetOfReference(Session session, List<NodeId> nodeIds, NodeId referenceTypeId, bool throwOnError)
        {
            try
            {
                // construct browse request.
                BrowseDescriptionCollection nodesToBrowse = new BrowseDescriptionCollection();

                for (int ii = 0; ii < nodeIds.Count; ii++)
                {
                    BrowseDescription nodeToBrowse = new BrowseDescription();
                    nodeToBrowse.NodeId = nodeIds[ii];
                    nodeToBrowse.BrowseDirection = BrowseDirection.Forward;
                    nodeToBrowse.ReferenceTypeId = referenceTypeId;
                    nodeToBrowse.IncludeSubtypes = false;
                    nodeToBrowse.NodeClassMask = 0;
                    nodeToBrowse.ResultMask = (uint)BrowseResultMask.None;
                    nodesToBrowse.Add(nodeToBrowse);
                }

                // start the browse operation.
                BrowseResultCollection results = null;
                DiagnosticInfoCollection diagnosticInfos = null;

                session.Browse(
                    null,
                    null,
                    1,
                    nodesToBrowse,
                    out results,
                    out diagnosticInfos);

                ClientBase.ValidateResponse(results, nodesToBrowse);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToBrowse);

                List<NodeId> targetIds = new List<NodeId>();
                ByteStringCollection continuationPoints = new ByteStringCollection();

                for (int ii = 0; ii < nodeIds.Count; ii++)
                {
                    targetIds.Add(null);

                    // check for error.
                    if (StatusCode.IsBad(results[ii].StatusCode))
                    {
                        continue;
                    }

                    // check for continuation point.
                    if (results[ii].ContinuationPoint != null && results[ii].ContinuationPoint.Length > 0)
                    {
                        continuationPoints.Add(results[ii].ContinuationPoint);
                    }

                    // get the node id.
                    if (results[ii].References.Count > 0)
                    {
                        if (NodeId.IsNull(results[ii].References[0].NodeId) || results[ii].References[0].NodeId.IsAbsolute)
                        {
                            continue;
                        }

                        targetIds[ii] = (NodeId)results[ii].References[0].NodeId;
                    }
                }

                // release continuation points.
                if (continuationPoints.Count > 0)
                {
                    session.BrowseNext(
                        null,
                        true,
                        continuationPoints,
                        out results,
                        out diagnosticInfos);

                    ClientBase.ValidateResponse(results, nodesToBrowse);
                    ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToBrowse);
                }

                //return complete list.
                return targetIds;
            }
            catch (Exception exception)
            {
                if (throwOnError)
                {
                    throw new ServiceResultException(exception, StatusCodes.BadUnexpectedError);
                }

                return null;
            }
        }

        /// <summary>
        /// Finds the targets for the specified reference.
        /// </summary>
        private static void UpdateInstanceDescriptions(Session session, List<InstanceDeclaration> instances, bool throwOnError)
        {
            try
            {
                ReadValueIdCollection nodesToRead = new ReadValueIdCollection();

                for (int ii = 0; ii < instances.Count; ii++)
                {
                    ReadValueId nodeToRead = new ReadValueId();
                    nodeToRead.NodeId = instances[ii].NodeId;
                    nodeToRead.AttributeId = Attributes.Description;
                    nodesToRead.Add(nodeToRead);

                    nodeToRead = new ReadValueId();
                    nodeToRead.NodeId = instances[ii].NodeId;
                    nodeToRead.AttributeId = Attributes.DataType;
                    nodesToRead.Add(nodeToRead);

                    nodeToRead = new ReadValueId();
                    nodeToRead.NodeId = instances[ii].NodeId;
                    nodeToRead.AttributeId = Attributes.ValueRank;
                    nodesToRead.Add(nodeToRead);
                }

                // start the browse operation.
                DataValueCollection results = null;
                DiagnosticInfoCollection diagnosticInfos = null;

                session.Read(
                    null,
                    0,
                    TimestampsToReturn.Neither,
                    nodesToRead,
                    out results,
                    out diagnosticInfos);

                ClientBase.ValidateResponse(results, nodesToRead);
                ClientBase.ValidateDiagnosticInfos(diagnosticInfos, nodesToRead);

                // update the instances.
                for (int ii = 0; ii < nodesToRead.Count; ii += 3)
                {
                    InstanceDeclaration instance = instances[ii / 3];

                    instance.Description = results[ii].GetValue<LocalizedText>(LocalizedText.Null).Text;
                    instance.DataType = results[ii + 1].GetValue<NodeId>(NodeId.Null);
                    instance.ValueRank = results[ii + 2].GetValue<int>(ValueRanks.Any);

                    if (!NodeId.IsNull(instance.DataType))
                    {
                        instance.BuiltInType = DataTypes.GetBuiltInType(instance.DataType, session.TypeTree);
                        instance.DataTypeDisplayText = session.NodeCache.GetDisplayText(instance.DataType);

                        if (instance.ValueRank >= 0)
                        {
                            instance.DataTypeDisplayText += "[]";
                        }
                    }
                }
            }
            catch (Exception exception)
            {
                if (throwOnError)
                {
                    throw new ServiceResultException(exception, StatusCodes.BadUnexpectedError);
                }
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Collects the fields for the type.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="typeId">The type id.</param>
        /// <param name="fields">The fields.</param>
        /// <param name="fieldNodeIds">The node id for the declaration of the field.</param>
        private static void CollectFieldsForType(Session session, NodeId typeId, SimpleAttributeOperandCollection fields, List<NodeId> fieldNodeIds)
        {
            // get the supertypes.
            ReferenceDescriptionCollection supertypes = ClientUtils.BrowseSuperTypes(session, typeId, false);

            if (supertypes == null)
            {
                return;
            }

            // process the types starting from the top of the tree.
            Dictionary<NodeId, QualifiedNameCollection> foundNodes = new Dictionary<NodeId, QualifiedNameCollection>();
            QualifiedNameCollection parentPath = new QualifiedNameCollection();

            for (int ii = supertypes.Count - 1; ii >= 0; ii--)
            {
                CollectFields(session, (NodeId)supertypes[ii].NodeId, parentPath, fields, fieldNodeIds, foundNodes);
            }

            // collect the fields for the selected type.
            CollectFields(session, typeId, parentPath, fields, fieldNodeIds, foundNodes);
        }

        /// <summary>
        /// Collects the fields for the instance.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="instanceId">The instance id.</param>
        /// <param name="fields">The fields.</param>
        /// <param name="fieldNodeIds">The node id for the declaration of the field.</param>
        private static void CollectFieldsForInstance(Session session, NodeId instanceId, SimpleAttributeOperandCollection fields, List<NodeId> fieldNodeIds)
        {
            Dictionary<NodeId, QualifiedNameCollection> foundNodes = new Dictionary<NodeId, QualifiedNameCollection>();
            QualifiedNameCollection parentPath = new QualifiedNameCollection();
            CollectFields(session, instanceId, parentPath, fields, fieldNodeIds, foundNodes);
        }

        /// <summary>
        /// Collects the fields for the instance node.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="nodeId">The node id.</param>
        /// <param name="parentPath">The parent path.</param>
        /// <param name="fields">The event fields.</param>
        /// <param name="fieldNodeIds">The node id for the declaration of the field.</param>
        /// <param name="foundNodes">The table of found nodes.</param>
        private static void CollectFields(
            Session session,
            NodeId nodeId,
            QualifiedNameCollection parentPath,
            SimpleAttributeOperandCollection fields,
            List<NodeId> fieldNodeIds,
            Dictionary<NodeId, QualifiedNameCollection> foundNodes)
        {
            // find all of the children of the field.
            BrowseDescription nodeToBrowse = new BrowseDescription();

            nodeToBrowse.NodeId = nodeId;
            nodeToBrowse.BrowseDirection = BrowseDirection.Forward;
            nodeToBrowse.ReferenceTypeId = ReferenceTypeIds.Aggregates;
            nodeToBrowse.IncludeSubtypes = true;
            nodeToBrowse.NodeClassMask = (uint)(NodeClass.Object | NodeClass.Variable);
            nodeToBrowse.ResultMask = (uint)BrowseResultMask.All;

            ReferenceDescriptionCollection children = ClientUtils.Browse(session, nodeToBrowse, false);

            if (children == null)
            {
                return;
            }

            // process the children.
            for (int ii = 0; ii < children.Count; ii++)
            {
                ReferenceDescription child = children[ii];

                if (child.NodeId.IsAbsolute)
                {
                    continue;
                }

                // construct browse path.
                QualifiedNameCollection browsePath = new QualifiedNameCollection(parentPath);
                browsePath.Add(child.BrowseName);

                // check if the browse path is already in the list.
                int index = ContainsPath(fields, browsePath);

                if (index < 0)
                {
                    SimpleAttributeOperand field = new SimpleAttributeOperand();

                    field.TypeDefinitionId = ObjectTypeIds.BaseEventType;
                    field.BrowsePath = browsePath;
                    field.AttributeId = (child.NodeClass == NodeClass.Variable) ? Attributes.Value : Attributes.NodeId;

                    fields.Add(field);
                    fieldNodeIds.Add((NodeId)child.NodeId);
                }

                // recusively find all of the children.
                NodeId targetId = (NodeId)child.NodeId;

                // need to guard against loops.
                if (!foundNodes.ContainsKey(targetId))
                {
                    foundNodes.Add(targetId, browsePath);
                    CollectFields(session, (NodeId)child.NodeId, browsePath, fields, fieldNodeIds, foundNodes);
                }
            }
        }

        /// <summary>
        /// Determines whether the specified select clause contains the browse path.
        /// </summary>
        /// <param name="selectClause">The select clause.</param>
        /// <param name="browsePath">The browse path.</param>
        /// <returns>
        /// 	<c>true</c> if the specified select clause contains path; otherwise, <c>false</c>.
        /// </returns>
        private static int ContainsPath(SimpleAttributeOperandCollection selectClause, QualifiedNameCollection browsePath)
        {
            for (int ii = 0; ii < selectClause.Count; ii++)
            {
                SimpleAttributeOperand field = selectClause[ii];

                if (field.BrowsePath.Count != browsePath.Count)
                {
                    continue;
                }

                bool match = true;

                for (int jj = 0; jj < field.BrowsePath.Count; jj++)
                {
                    if (field.BrowsePath[jj] != browsePath[jj])
                    {
                        match = false;
                        break;
                    }
                }

                if (match)
                {
                    return ii;
                }
            }

            return -1;
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Applications\ClientControls.Net4\ClientUtils.cs(209,44): error CS8116: It is not legal to use nullable type 'byte?' in a pattern; use the underlying type 'byte' instead.,D:\a\1\s\Applications\ClientControls.Net4\ClientUtils.cs(219,44): error CS8116: It is not legal to use nullable type 'byte?' in a pattern; use the underlying type 'byte' instead.,D:\a\1\s\Applications\ClientControls.Net4\ClientUtils.cs(234,44): error CS8116: It is not legal to use nullable type 'byte?' in a pattern; use the underlying type 'byte' instead.,D:\a\1\s\Applications\ClientControls.Net4\ClientUtils.cs(244,44): error CS8116: It is not legal to use nullable type 'byte?' in a pattern; use the underlying type 'byte' instead.,D:\a\1\s\Applications\ClientControls.Net4\ClientUtils.cs(255,44): error CS0103: The name 'field' does not exist in the current context,D:\a\1\s\Applications\ClientControls.Net4\ClientUtils.cs(257,36): error CS0103: The name 'field' does not exist in the current context,D:\a\1\s\Applications\ClientControls.Net4\ClientUtils.cs(265,44): error CS8116: It is not legal to use nullable type 'byte?' in a pattern; use the underlying type 'byte' instead.
######################################################################


######################################################################
Nr: 34 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Xml;
using System.Reflection;

namespace Opc.Ua.Client.Controls.Common
{
    /// <summary>
    /// Allows the user to edit a complex value.
    /// </summary>
    public partial class EditComplexValueCtrl : UserControl
    {
        /// <summary>
        /// Constructs the object.
        /// </summary>
        public EditComplexValueCtrl()
        {
            InitializeComponent();
            MaxDisplayTextLength = 100;
            ValuesDV.AutoGenerateColumns = false;
            ImageList = new ClientUtils().ImageList;

            m_dataset = new DataSet();
            m_dataset.Tables.Add("Values");

            m_dataset.Tables[0].Columns.Add("AccessInfo", typeof(AccessInfo));
            m_dataset.Tables[0].Columns.Add("Name", typeof(string));
            m_dataset.Tables[0].Columns.Add("DataType", typeof(string));
            m_dataset.Tables[0].Columns.Add("Value", typeof(string));
            m_dataset.Tables[0].Columns.Add("Icon", typeof(Image));

            ValuesDV.DataSource = m_dataset.Tables[0];
        }

        #region Private Fields
        private DataSet m_dataset;
        private Session m_session;
        private AccessInfo m_value;
        private bool m_readOnly;
        private int m_maxDisplayTextLength;
        private event EventHandler m_ValueChanged;
        #endregion

        private class AccessInfo
        {
            public AccessInfo Parent { get; set; }
            public PropertyInfo PropertyInfo { get; set; }
            public int[] Indexes;
            public TypeInfo TypeInfo;
            public object Value;
            public string Name;
        }

        #region Public Members
        /// <summary>
        /// The maximum length of a value string displayed in a column.
        /// </summary>
        [DefaultValue(100)]
        public int MaxDisplayTextLength
        {
            get
            {
                return m_maxDisplayTextLength;
            }

            set
            {
                if (value < 20)
                {
                    m_maxDisplayTextLength = 20;
                }

                m_maxDisplayTextLength = value;
            }
        }

        /// <summary>
        /// Returns true if the Back command can be called.
        /// </summary>
        public bool CanGoBack
        {
            get
            {
                return (NavigationMENU.Items.Count > 1);
            }
        }

        /// <summary>
        /// Returns true if the ArraySize can be changed.
        /// </summary>
        public bool CanSetArraySize
        {
            get
            {
                if (m_readOnly)
                {
                    return false;
                }

                AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;

                if (info != null)
                {
                    return info.TypeInfo.ValueRank >= 0;
                }

                return false;
            }
        }

        /// <summary>
        /// Returns true if the data type can be changed.
        /// </summary>
        public bool CanChangeType
        {
            get
            {
                if (m_readOnly)
                {
                    return false;
                }

                if (NavigationMENU.Items.Count > 0)
                {
                    AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;

                    if (info != null)
                    {
                        return info.Parent != null && info.Parent.TypeInfo != null && info.Parent.TypeInfo.BuiltInType == BuiltInType.Variant;
                    }
                }

                return false;
            }
        }

        /// <summary>
        /// Returns the current data type.
        /// </summary>
        public BuiltInType CurrentType
        {
            get
            {
                if (NavigationMENU.Items.Count > 0)
                {
                    AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;

                    if (info != null)
                    {
                        Variant? value = info.Value as Variant?;

                        if (value != null && value.Value.TypeInfo != null)
                        {
                            return value.Value.TypeInfo.BuiltInType;
                        }

                        return info.TypeInfo.BuiltInType;
                    }
                }

                return BuiltInType.Variant;
            }
        }

        /// <summary>
        /// Raised when the value is changed.
        /// </summary>
        public event EventHandler ValueChanged
        {
            add { m_ValueChanged += value; }
            remove { m_ValueChanged -= value; }
        }

        /// <summary>
        /// Changes the session used for editing the value.
        /// </summary>
        public void ChangeSession(Session session)
        {
            m_session = session;
        }

        /// <summary>
        /// Moves the displayed value back.
        /// </summary>
        public void Back()
        {
            if (!CanGoBack)
            {
                return;
            } 
            
            NavigationMENU_Click(NavigationMENU.Items[NavigationMENU.Items.Count - 2], null);
        }


        /// <summary>
        /// Changes the array size.
        /// </summary>
        public void SetArraySize()
        {
            if (!CanSetArraySize)
            {
                return;
            }

            EndEdit();

            AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;

            TypeInfo currentType = info.TypeInfo;
            object currentValue = info.Value;

            if (info.Value is Variant)
            {
                Variant variant = (Variant)info.Value;
                currentValue = variant.Value;

                if (currentValue != null)
                {
                    currentType = variant.TypeInfo;

                    if (currentType == null)
                    {
                        currentType = TypeInfo.Construct(currentValue);
                    }
                }
            }

            int[] dimensions = null;

            Array array = currentValue as Array;

            if (array != null)
            {
                dimensions = new int[array.Rank];

                for (int ii = 0; ii < array.Rank; ii++)
                {
                    dimensions[ii] = array.GetLength(ii);
                }
            }

            IList list = currentValue as IList;

            if (array == null && list != null)
            {
                dimensions = new int[1];
                dimensions[0] = list.Count;
            }

            Matrix matrix = currentValue as Matrix;

            if (matrix != null)
            {
                dimensions = matrix.Dimensions;
                array = matrix.ToArray();
            }

            SetTypeDlg.SetTypeResult result = new SetTypeDlg().ShowDialog(currentType, dimensions);

            if (result == null)
            {
                return;
            }

            // convert to new type.
            object newValue = currentValue;

            if (result.ArrayDimensions == null || result.ArrayDimensions.Length < 1)
            {
                newValue = Convert(currentValue, currentType, result.TypeInfo, result.UseDefaultOnError);
            }
            else
            {
                if (array == null && list != null)
                {
                    Type elementType = GetListElementType(list);

                    for (int ii = result.ArrayDimensions[0]; ii < list.Count; ii++)
                    {
                        list.RemoveAt(ii);
                    }

                    for (int ii = list.Count; ii < result.ArrayDimensions[0]; ii++)
                    {
                        list.Add(Activator.CreateInstance(elementType));
                    }

                    newValue = list;
                }

                if (array != null)
                {
                    Array newArray = null;

                    if (currentValue is Array)
                    {
                        newArray = Array.CreateInstance(currentValue.GetType().GetElementType(), result.ArrayDimensions);
                    }
                    else
                    {
                        newArray = TypeInfo.CreateArray(result.TypeInfo.BuiltInType, result.ArrayDimensions);
                    }

                    int maxCount = result.ArrayDimensions[0];

                    for (int ii = 1; ii < result.ArrayDimensions.Length; ii++)
                    {
                        maxCount *= result.ArrayDimensions[ii];
                    }

                    int count = 0;

                    foreach (object element in array)
                    {
                        if (maxCount <= count)
                        {
                            break;
                        }

                        object newElement = Convert(element, currentType, result.TypeInfo, result.UseDefaultOnError);
                        int[] indexes = GetIndexFromCount(count++, result.ArrayDimensions);
                        newArray.SetValue(newElement, indexes);
                    }

                    newValue = newArray;
                }
            }

            NavigationMENU.Items.RemoveAt(NavigationMENU.Items.Count - 1);

            info.TypeInfo = result.TypeInfo;
            info.Value = newValue;
            ShowValue(info);
        }

        /// <summary>
        /// Changes the data type.
        /// </summary>
        public void SetType(BuiltInType builtInType)
        {
            if (!CanChangeType)
            {
                return;
            }
            
            AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;

            TypeInfo currentType = info.TypeInfo;
            object currentValue = info.Value;

            try
            {
                EndEdit();
                currentValue = info.Value;
            }
            catch (Exception)
            {
                currentValue = TypeInfo.GetDefaultValue(currentType.BuiltInType);
            }

            if (info.Value is Variant)
            {
                Variant variant = (Variant)info.Value;
                currentValue = variant.Value;

                if (currentValue != null)
                {
                    currentType = variant.TypeInfo;

                    if (currentType == null)
                    {
                        currentType = TypeInfo.Construct(currentValue);
                    }
                }
            }
            
            TypeInfo targetType = new TypeInfo(builtInType, currentType.ValueRank);
            object newValue  = Convert(currentValue, currentType, targetType, true);

            NavigationMENU.Items.RemoveAt(NavigationMENU.Items.Count - 1);

            info.TypeInfo = targetType;
            info.Value = newValue;
            ShowValueNoNotify(info);
        }

        /// <summary>
        /// Converts the old type to the new type.
        /// </summary>
        private object Convert(object oldValue, TypeInfo oldType, TypeInfo newType, bool useDefaultOnError)
        {
            object newValue = oldValue;

            if (oldType.BuiltInType != newType.BuiltInType)
            {
                try
                {
                    newValue = TypeInfo.Cast(oldValue, oldType, newType.BuiltInType);
                }
                catch (Exception e)
                {
                    if (!useDefaultOnError)
                    {
                        throw new FormatException("Could not cast value to requested type.", e);
                    }

                    newValue = TypeInfo.GetDefaultValue(newType.BuiltInType);
                }
            }

            return newValue;
        }

        /// <summary>
        /// Displays the value in the control.
        /// </summary>
        public void ShowValue(
            NodeId nodeId,
            uint attributeId,
            string name, 
            object value, 
            bool readOnly)
        {
            m_readOnly = readOnly;
            NavigationMENU.Items.Clear();

            if (m_readOnly)
            {
                ValuesDV.EditMode = DataGridViewEditMode.EditProgrammatically;
                TextValueTB.ReadOnly = true;
            }

            Type type = null;

            // determine the expected data type for non-value attributes.
            if (attributeId != 0 && attributeId != Attributes.Value)
            {
                BuiltInType builtInType = TypeInfo.GetBuiltInType(Attributes.GetDataTypeId(attributeId));
                int valueRank = Attributes.GetValueRank(attributeId);
                type = TypeInfo.GetSystemType(builtInType, valueRank);
            }

            // determine the expected data type for value attributes.
            else if (!NodeId.IsNull(nodeId))
            {
                IVariableBase variable = m_session.NodeCache.Find(nodeId) as IVariableBase;

                if (variable != null)
                {
                    BuiltInType builtInType = TypeInfo.GetBuiltInType(variable.DataType, m_session.TypeTree);
                    int valueRank = variable.ValueRank;
                    type = TypeInfo.GetSystemType(builtInType, valueRank);

                    if (builtInType == BuiltInType.ExtensionObject && valueRank < 0)
                    {
                        type = TypeInfo.GetSystemType(variable.DataType, m_session.Factory);
                    }
                }
            }

            // use the value.
            else if (value != null)
            {
                type = value.GetType();
            }

            // go with default.
            else
            {
                type = typeof(string);
            }

            // assign a name.
            if (String.IsNullOrEmpty(name))
            {
                if (attributeId != 0)
                {
                    name = Attributes.GetBrowseName(attributeId);
                }
                else
                {
                    name = type.Name;
                }
            }

            AccessInfo info = new AccessInfo();
            info.Value = Utils.Clone(value);
            info.TypeInfo = TypeInfo.Construct(type);

            if (value == null && info.TypeInfo.ValueRank < 0)
            {
                info.Value = TypeInfo.GetDefaultValue(info.TypeInfo.BuiltInType);
            }

            info.Name = name;
            m_value = info;

            ShowValue(info);
        }

        /// <summary>
        /// Displays the value in the control.
        /// </summary>
        public void ShowValue(
            string name,
            NodeId dataType,
            int valueRank,
            object value)
        {
            if (value == null && m_session != null)
            {
                BuiltInType builtInType = TypeInfo.GetBuiltInType(dataType, m_session.TypeTree);

                if (builtInType == BuiltInType.ExtensionObject)
                {
                    Type type = m_session.Factory.GetSystemType(dataType);

                    if (type != null)
                    {
                        if (valueRank < 0)
                        {
                            value = Activator.CreateInstance(type);
                        }
                        else
                        {
                            value = Array.CreateInstance(type, new int[valueRank]);
                        }
                    }
                }
                else
                {
                    value = TypeInfo.GetDefaultValue(dataType, valueRank, m_session.TypeTree);
                }
            }

            ShowValue(null, name, value);
        }

        /// <summary>
        /// Displays the value in the control.
        /// </summary>
        public void ShowValue(
            TypeInfo expectedType,
            string name,
            object value)
        {
            m_readOnly = false;
            NavigationMENU.Items.Clear();

            // assign a type.
            if (expectedType == null)
            {
                if (value == null)
                {
                    expectedType = TypeInfo.Scalars.String;
                }
                else
                {
                    expectedType = TypeInfo.Construct(value);
                }
            }

            // assign a name.
            if (String.IsNullOrEmpty(name))
            {
                name = expectedType.ToString();
            }
            
            AccessInfo info = new AccessInfo();
            info.Value = Utils.Clone(value);
            info.TypeInfo = expectedType;

            if (value == null && info.TypeInfo.ValueRank < 0)
            {
                info.Value = TypeInfo.GetDefaultValue(info.TypeInfo.BuiltInType);
            }

            // ensure value is the target type.
            info.Value = TypeInfo.Cast(info.Value, expectedType.BuiltInType);

            info.Name = name;
            m_value = info;

            ShowValue(info);
        }

        /// <summary>
        /// Returns the edited value.
        /// </summary>
        public object GetValue()
        {
            return m_value.Value;
        }

        /// <summary>
        /// Validates the value currently being edited.
        /// </summary>
        public void EndEdit()
        {
            if (NavigationMENU.Items.Count < 1)
            {
                return;
            }

            if (!TextValueTB.Visible)
            {
                ValuesDV.EndEdit();
                return;
            }

            AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;
            object newValue = TypeInfo.Cast(TextValueTB.Text, info.TypeInfo.BuiltInType);
            info.Value = newValue;
            UpdateParent(info);
        }

        /// <summary>
        /// Displays the value in the control.
        /// </summary>
        private void ShowValue(AccessInfo parent)
        {
            ShowValueNoNotify(parent);

            if (m_ValueChanged != null)
            {
                m_ValueChanged(this, null);
            }
        }

        /// <summary>
        /// Displays the value in the control.
        /// </summary>
        private void ShowValueNoNotify(AccessInfo parent)
        {
            m_dataset.Tables[0].Clear();
            ValuesDV.Visible = true;
            TextValueTB.Visible = false;

            ToolStripItem item = NavigationMENU.Items.Add(parent.Name);
            item.Click += new EventHandler(NavigationMENU_Click);
            item.Tag = parent;

            TypeInfo typeInfo = parent.TypeInfo;
            object value = parent.Value;

            if (value is Variant variant)
            {
                value = variant.Value;

                if (value != null)
                {
                    parent.TypeInfo = typeInfo = variant.TypeInfo;

                    if (typeInfo == null)
                    {
                        parent.TypeInfo = typeInfo = TypeInfo.Construct(value);
                    }
                }
            }

            if (typeInfo.ValueRank >= 0)
            {
                Matrix matrix = value as Matrix;

                if (matrix != null)
                {
                    value = matrix.ToArray();
                }

                System.Collections.IEnumerable enumerable = value as System.Collections.IEnumerable;

                if (enumerable != null)
                {
                    // get the dimensions of any array.
                    int[] dimensions = null;

                    // calculate them.
                    if (matrix == null)
                    {
                        Array array = enumerable as Array;

                        if (array != null)
                        {
                            dimensions = new int[array.Rank];

                            for (int ii = 0; ii < array.Rank; ii++)
                            {
                                dimensions[ii] = array.GetLength(ii);
                            }
                        }
                        else
                        {
                            dimensions = new int[1];
                            System.Collections.IList list = enumerable as System.Collections.IList;

                            if (list != null)
                            {
                                dimensions[0] = list.Count;
                            }
                        }
                    }

                    // get them from the matrix.
                    else
                    {
                        dimensions = matrix.Dimensions;
                    }

                    // display the array elements.
                    int count = 0;
                    TypeInfo elementType = new TypeInfo(typeInfo.BuiltInType, ValueRanks.Scalar);

                    ValuesDV.Visible = true;
                    TextValueTB.Visible = false;

                    foreach (object element in enumerable)
                    {
                        int[] indexes = GetIndexFromCount(count++, dimensions);

                        AccessInfo info = new AccessInfo();
                        info.Parent = parent;
                        info.Indexes = indexes;
                        info.TypeInfo = elementType;
                        info.Value = element;

                        ShowIndexedValue(info);
                    }
                }

                return;
            }

            // check for null.
            if (value == null)
            {
                if (parent.Parent != null && parent.Parent.Value is Array)
                {
                    parent.Value = value = Activator.CreateInstance(parent.Parent.Value.GetType().GetElementType());
                }
                else if (parent.Parent != null && parent.PropertyInfo != null)
                {
                    parent.Value = value = Activator.CreateInstance(parent.PropertyInfo.PropertyType);
                }
                else
                {
                    ShowTextValue(value, parent.TypeInfo);
                    return;
                }
            }

            object structure = value;

            // check for extension object.
            ExtensionObject extension = structure as ExtensionObject;

            if (extension != null)
            {
                structure = extension.Body;
            }

            // check for XmlElements.
            if (structure is XmlElement xmlElement)
            {
                ShowTextValue(xmlElement);
                return;
            }

            // check for ByteString.
            if (structure is byte[] bytes)
            {
                ShowTextValue(bytes);
                return;
            }

            // check for NodeId.
            if (structure is NodeId nodeId)
            {
                ShowTextValue(nodeId.ToString());
                return;
            }

            // check for ExpandedNodeId.
            if (structure is ExpandedNodeId expandedNodeId)
            {
                ShowTextValue(expandedNodeId.ToString());
                return;
            }

            // check for QualifiedName.
            if (structure is QualifiedName qualifiedName)
            {
                ShowTextValue(qualifiedName.ToString());
                return;
            }

            // check for Guid.
            if (structure is Guid guid)
            {
                ShowTextValue(guid.ToString());
                return;
            }

            // check for Uuid.
            if (structure is Uuid uuid)
            {
                ShowTextValue(uuid.ToString());
                return;
            }

            // check for StatusCode.
            if (structure is StatusCode statusCode)
            {
                ShowTextValue(Utils.Format("0x{0:X8}", statusCode.Code));
                return;
            }

            ValuesDV.Visible = true;
            TextValueTB.Visible = false;

            // use reflection to display the properties of the structure.
            bool isStructure = false;
            PropertyInfo[] properties = structure.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            foreach (PropertyInfo property in properties)
            {
                if (property.GetIndexParameters().Length > 0)
                {
                    continue;
                }

                object element = property.GetValue(structure, null);

                string name = null;

                foreach (object attribute in property.GetCustomAttributes(true))
                {
                    if (typeof(System.Runtime.Serialization.DataMemberAttribute).IsInstanceOfType(attribute))
                    {
                        name = ((System.Runtime.Serialization.DataMemberAttribute)attribute).Name;

                        if (name == null)
                        {
                            name = property.Name;
                        }

                        break;
                    }
                }

                if (name == null)
                {
                    continue;
                }

                AccessInfo info = new AccessInfo();
                info.Parent = parent;
                info.PropertyInfo = property;
                info.TypeInfo = TypeInfo.Construct(property.PropertyType);
                info.Value = element;
                info.Name = name;

                ShowNamedValue(info);
                isStructure = true;
            }

            if (!isStructure)
            {
                ShowTextValue(parent.Value, parent.TypeInfo);
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Returns the index based on the current count.
        /// </summary>
        private int[] GetIndexFromCount(int count, int[] dimensions)
        {
            int[] indexes = new int[(dimensions != null) ? dimensions.Length : 1];

            for (int ii = indexes.Length - 1; ii >= 0; ii--)
            {
                indexes[ii] = count % dimensions[ii];
                count /= dimensions[ii];
            }

            return indexes;
        }

        /// <summary>
        /// Adds the value at an array index to the control.
        /// </summary>
        private void ShowIndexedValue(AccessInfo info)
        {
            DataRow row = m_dataset.Tables[0].NewRow();

            StringBuilder buffer = new StringBuilder();
            buffer.Append("[");

            if (info.Indexes != null)
            {
                for (int ii = 0; ii < info.Indexes.Length; ii++)
                {
                    if (ii > 0)
                    {
                        buffer.Append(",");
                    }

                    buffer.Append(info.Indexes[ii]);
                }
            }

            buffer.Append("]");
            info.Name = buffer.ToString();

            row[0] = info;
            row[1] = info.Name;
            row[2] = GetDataTypeString(info);
            row[3] = ValueToString(info.Value, info.TypeInfo);
            row[4] = ImageList.Images[ClientUtils.GetImageIndex(Attributes.Value, info.Value)];

            m_dataset.Tables[0].Rows.Add(row);
        }

        /// <summary>
        /// Returns the element type for a list.
        /// </summary>
        private Type GetListElementType(IList list)
        {
            if (list != null)
            {
                for (Type type = list.GetType(); type != null; type = type.BaseType)
                {
                    if (type.IsGenericType)
                    {
                        Type[] argTypes = type.GetGenericArguments();

                        if (argTypes.Length > 0)
                        {
                            return argTypes[0];
                        }
                    }
                }
            }

            return typeof(object);
        }

        /// <summary>
        /// Returns the data type of the value.
        /// </summary>
        private Type GetDataType(AccessInfo accessInfo)
        {
            if (accessInfo == null || accessInfo.TypeInfo == null)
            {
                return null;
            }

            if (accessInfo.TypeInfo.BuiltInType == BuiltInType.ExtensionObject)
            {
                if (accessInfo.Value != null)
                {
                    return accessInfo.Value.GetType();
                }

                if (accessInfo.PropertyInfo != null)
                {
                    return accessInfo.PropertyInfo.PropertyType;
                }

                if (accessInfo.Parent != null)
                {
                    if (accessInfo.Parent.Value is Array)
                    {
                        Array array = (Array)accessInfo.Parent.Value;
                        return array.GetType().GetElementType();
                    }

                    if (accessInfo.Parent.Value is IList)
                    {
                        IList list = (IList)accessInfo.Parent.Value;
                        return GetListElementType(list);
                    }
                }
            }

            return TypeInfo.GetSystemType(accessInfo.TypeInfo.BuiltInType, accessInfo.TypeInfo.ValueRank);
        }

        /// <summary>
        /// Returns the data type of the value.
        /// </summary>
        private string GetDataTypeString(AccessInfo accessInfo)
        {
            Type type = GetDataType(accessInfo);

            if (type == null)
            {
                return accessInfo.TypeInfo.ToString();
            }

            return type.Name;
        }

        /// <summary>
        /// Adds the value with the specified name to the control.
        /// </summary>
        private void ShowNamedValue(AccessInfo info)
        {
            DataRow row = m_dataset.Tables[0].NewRow();

            row[0] = info;
            row[1] = (info.Name != null) ? info.Name : "unknown";
            row[2] = GetDataTypeString(info);
            row[3] = ValueToString(info.Value, info.TypeInfo);
            row[4] = ImageList.Images[ClientUtils.GetImageIndex(Attributes.Value, info.Value)];

            m_dataset.Tables[0].Rows.Add(row);
        }

        /// <summary>
        /// Displays a value in the control.
        /// </summary>
        private void ShowTextValue(object value, TypeInfo typeInfo)
        {
            switch (typeInfo.BuiltInType)
            {
                case BuiltInType.ByteString:
                {
                    ShowTextValue((byte[])value);
                    break;
                }

                case BuiltInType.XmlElement:
                {
                    ShowTextValue((XmlElement)value);
                    break;
                }

                case BuiltInType.String:
                {
                    ShowTextValue((string)value);
                    break;
                }

                default:
                {
                    ShowTextValue(ValueToString(value, typeInfo));
                    break;
                }
            }
        }

        /// <summary>
        /// Displays a string in the control.
        /// </summary>
        private void ShowTextValue(string value)
        {
            ValuesDV.Visible = false;
            TextValueTB.Visible = true;

            if (value != null && value.Length > MaxDisplayTextLength)
            {
                TextValueTB.ScrollBars = ScrollBars.Both;
            }
            else
            {
                TextValueTB.ScrollBars = ScrollBars.None;
            }

            TextValueTB.Font = new Font("Segoe UI", TextValueTB.Font.Size);
            TextValueTB.Text = value;
        }

        /// <summary>
        /// Displays a complete byte string in the control.
        /// </summary>
        private void ShowTextValue(byte[] value)
        {
            ValuesDV.Visible = false;
            TextValueTB.Visible = true;

            StringBuilder buffer = new StringBuilder();

            if (value != null)
            {
                for (int ii = 0; ii < value.Length; ii++)
                {
                    if (buffer.Length > 0 && (ii % 30) == 0)
                    {
                        buffer.Append("\r\n");
                    }

                    buffer.AppendFormat("{0:X2} ", value[ii]);
                }
            }

            TextValueTB.Font = new Font("Courier New", TextValueTB.Font.Size);
            TextValueTB.Text = buffer.ToString();
        }

        /// <summary>
        /// Displays a complete XML element in the control.
        /// </summary>
        private void ShowTextValue(XmlElement value)
        {
            ValuesDV.Visible = false;
            TextValueTB.Visible = true;

            StringBuilder buffer = new StringBuilder();

            if (value != null)
            {
                XmlWriterSettings settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.OmitXmlDeclaration = true;
                settings.NewLineHandling = NewLineHandling.Replace;
                settings.NewLineChars = "\r\n";
                settings.IndentChars = "    ";

                using (XmlWriter writer = XmlWriter.Create(buffer, settings))
                {
                    using (XmlNodeReader reader = new XmlNodeReader(value))
                    {
                        writer.WriteNode(reader, false);
                    }
                }
            }

            TextValueTB.Font = new Font("Courier New", TextValueTB.Font.Size);
            TextValueTB.Text = buffer.ToString();
        }

        /// <summary>
        /// Converts a value to a string for display in the grid.
        /// </summary>
        private string ValueToString(object value, TypeInfo typeInfo)
        {
            if (value == null)
            {
                return String.Empty;
            }

            if (value is Variant variant)
            {
                value = variant.Value;

                if (value != null)
                {
                    typeInfo = variant.TypeInfo;

                    if (typeInfo == null)
                    {
                        typeInfo = TypeInfo.Construct(value);
                    }
                }
            }

            if (typeInfo.ValueRank >= 0)
            {
                StringBuilder buffer = new StringBuilder();

                System.Collections.IEnumerable enumerable = value as System.Collections.IEnumerable;

                if (enumerable != null)
                {
                    buffer.Append("{ ");

                    foreach (object element in enumerable)
                    {
                        if (buffer.Length > 2)
                        {
                            buffer.Append(" | ");
                        }

                        if (buffer.Length > MaxDisplayTextLength)
                        {
                            buffer.Append("...");
                            break;
                        }

                        buffer.Append(ValueToString(element, new TypeInfo(typeInfo.BuiltInType, ValueRanks.Scalar)));
                    }

                    buffer.Append(" }");
                }

                return buffer.ToString();
            }

            switch (typeInfo.BuiltInType)
            {
                case BuiltInType.String:
                {
                    string text = (string)value;

                    if (text != null && text.Length > MaxDisplayTextLength)
                    {
                        return text.Substring(0, MaxDisplayTextLength) + "...";
                    }

                    return text;
                }

                case BuiltInType.ByteString:
                {
                    StringBuilder buffer = new StringBuilder();

                    byte[] bytes = (byte[])value;

                    for (int ii = 0; ii < bytes.Length; ii++)
                    {
                        if (buffer.Length > MaxDisplayTextLength)
                        {
                            buffer.Append("...");
                            break;
                        }

                        buffer.AppendFormat("{0:X2}", bytes[ii]);
                    }

                    return buffer.ToString();
                }

                case BuiltInType.Enumeration:
                {
                    return ((int)value).ToString();
                }

                case BuiltInType.ExtensionObject:
                {
                    string text = null;

                    ExtensionObject extension = value as ExtensionObject;

                    if (extension != null)
                    {
                        if (extension.Body is byte[])
                        {
                            return ValueToString(extension.Body, new TypeInfo(BuiltInType.ByteString, ValueRanks.Scalar));
                        }

                        if (extension.Body is XmlElement)
                        {
                            return ValueToString(extension.Body, new TypeInfo(BuiltInType.XmlElement, ValueRanks.Scalar));
                        }

                        if (extension.Body is IEncodeable)
                        {
                            text = new Variant(extension).ToString();
                        }
                    }

                    if (text == null)
                    {
                        IEncodeable encodeable = value as IEncodeable;

                        if (encodeable != null)
                        {
                            text = new Variant(encodeable).ToString();
                        }
                    }

                    if (text != null && text.Length > MaxDisplayTextLength)
                    {
                        return text.Substring(0, MaxDisplayTextLength) + "...";
                    }

                    return text;
                }
            }

            return (string)TypeInfo.Cast(value, BuiltInType.String);
        }

        /// <summary>
        /// Whether the value can be edited in the grid view.
        /// </summary>
        private bool IsSimpleValue(AccessInfo info)
        {
            if (info == null || info.TypeInfo == null)
            {
                return true;
            }

            TypeInfo typeInfo = info.TypeInfo;
            object value = info.Value;

            if (value is Variant)
            {
                Variant variant = (Variant)info.Value;
                typeInfo = variant.TypeInfo;
                value = variant.Value;

                if (typeInfo == null)
                {
                    typeInfo = TypeInfo.Construct(value);
                }
            }

            if (typeInfo.ValueRank >= 0)
            {
                return false;
            }
            
            switch (typeInfo.BuiltInType)
            {
                case BuiltInType.String:
                {
                    string text = value as string;

                    if (text != null && text.Length >= MaxDisplayTextLength)
                    {
                        return false;
                    }

                    return true;
                }

                case BuiltInType.ByteString:
                case BuiltInType.XmlElement:
                case BuiltInType.QualifiedName:
                case BuiltInType.LocalizedText:
                case BuiltInType.DataValue:
                case BuiltInType.ExtensionObject:
                {
                    return false;
                }
            }

            return true;
        }
        #endregion

        private void NavigationMENU_Click(object sender, EventArgs e)
        {
            try
            {
                EndEdit();

                ToolStripItem item = sender as ToolStripItem;

                if (item != null)
                {
                    // remove all menu items appearing after the selected item.
                    for (int ii = NavigationMENU.Items.Count-1; ii >= 0; ii--)
                    {
                        ToolStripItem target = NavigationMENU.Items[ii];
                        NavigationMENU.Items.Remove(target);

                        if (Object.ReferenceEquals(target, item))
                        {
                            break;
                        }
                    }

                    // show the current value.
                    AccessInfo info = (AccessInfo)item.Tag;
                    ShowValue(info);
                }
            }
            catch (Exception exception)
            {
                ClientUtils.HandleException(this.Text, exception);
            }
        }

        private void ValuesDV_DoubleClick(object sender, EventArgs e)
        {
            try
            {
                foreach (DataGridViewCell cell in ValuesDV.SelectedCells)
                {
                    DataRowView source = ValuesDV.Rows[cell.RowIndex].DataBoundItem as DataRowView;

                    if (cell.ColumnIndex == 3)
                    {
                        AccessInfo info = (AccessInfo)source.Row[0];
                        ShowValue(info);
                    }
                    
                    break;
                }
            }
            catch (Exception exception)
            {
                ClientUtils.HandleException(this.Text, exception);
            }
        }

        private void ValuesDV_CellValidating(object sender, DataGridViewCellValidatingEventArgs e)
        {
            try
            {
                if (this.Visible && e.ColumnIndex == 3)
                {
                    DataRowView source = ValuesDV.Rows[e.RowIndex].DataBoundItem as DataRowView;
                    AccessInfo info = (AccessInfo)source.Row[0];

                    if (IsSimpleValue(info))
                    {
                        TypeInfo.Cast(e.FormattedValue, info.TypeInfo.BuiltInType);
                    }
                }
            }
            catch (Exception exception)
            {
                ClientUtils.HandleException(this.Text, exception);
                e.Cancel = true;
            }
        }

        private void ValuesDV_CellValueChanged(object sender, DataGridViewCellEventArgs e)
        {
            try
            {
                if (this.Visible && e.RowIndex >= 0 && e.ColumnIndex == 3)
                {
                    DataRowView source = ValuesDV.Rows[e.RowIndex].DataBoundItem as DataRowView;
                    AccessInfo info = (AccessInfo)source.Row[0];

                    if (IsSimpleValue(info))
                    {
                        object newValue = TypeInfo.Cast((string)source.Row[3], info.TypeInfo.BuiltInType);
                        info.Value = newValue;
                        UpdateParent(info);
                    }
                }
            }
            catch (Exception exception)
            {
                ClientUtils.HandleException(this.Text, exception);
            }
        }

        /// <summary>
        /// Recusivesly updates the parent values.
        /// </summary>
        private void UpdateParent(AccessInfo info)
        {
            if (info.Parent == null)
            {
                return;
            }

            object parentValue = info.Parent.Value;

            if (info.Parent.TypeInfo.BuiltInType == BuiltInType.Variant && info.Parent.TypeInfo.ValueRank < 0)
            {
                parentValue = ((Variant)info.Parent.Value).Value;
            }

            if (info.PropertyInfo != null && info.Parent.TypeInfo.ValueRank < 0)
            {
                ExtensionObject extension = parentValue as ExtensionObject;

                if (extension != null)
                {
                    parentValue = extension.Body;
                }

                info.PropertyInfo.SetValue(parentValue, info.Value, null);
            }

            else if (info.Indexes != null)
            {
                int[] indexes = info.Indexes;
                Array array = parentValue as Array;

                Matrix matrix = parentValue as Matrix;

                if (matrix != null)
                {
                    int count = 0;
                    int block = 1;

                    for (int ii = info.Indexes.Length-1; ii >= 0 ; ii--)
                    {
                        count += info.Indexes[ii] * block;
                        block *= matrix.Dimensions[ii];
                    }

                    array = matrix.Elements;
                    indexes = new int[] { count };
                }

                if (array != null)
                {
                    if (info.Parent.TypeInfo.BuiltInType == BuiltInType.Variant && info.Parent.TypeInfo.ValueRank >= 0)
                    {
                        array.SetValue(new Variant(info.Value), indexes);
                    }
                    else
                    {
                        array.SetValue(info.Value, indexes);
                    }
                }
                else
                {
                    IList list = parentValue as IList;

                    if (info.Parent.TypeInfo.BuiltInType == BuiltInType.Variant && info.Parent.TypeInfo.ValueRank >= 0)
                    {
                        list[indexes[0]] = new Variant(info.Value);
                    }
                    else
                    {
                        list[indexes[0]] = info.Value;
                    }
                }
            }

            if (info.Parent != null)
            {
                UpdateParent(info.Parent);
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Xml;
using System.Reflection;

namespace Opc.Ua.Client.Controls.Common
{
    /// <summary>
    /// Allows the user to edit a complex value.
    /// </summary>
    public partial class EditComplexValueCtrl : UserControl
    {
        /// <summary>
        /// Constructs the object.
        /// </summary>
        public EditComplexValueCtrl()
        {
            InitializeComponent();
            MaxDisplayTextLength = 100;
            ValuesDV.AutoGenerateColumns = false;
            ImageList = new ClientUtils().ImageList;

            m_dataset = new DataSet();
            m_dataset.Tables.Add("Values");

            m_dataset.Tables[0].Columns.Add("AccessInfo", typeof(AccessInfo));
            m_dataset.Tables[0].Columns.Add("Name", typeof(string));
            m_dataset.Tables[0].Columns.Add("DataType", typeof(string));
            m_dataset.Tables[0].Columns.Add("Value", typeof(string));
            m_dataset.Tables[0].Columns.Add("Icon", typeof(Image));

            ValuesDV.DataSource = m_dataset.Tables[0];
        }

        #region Private Fields
        private DataSet m_dataset;
        private Session m_session;
        private AccessInfo m_value;
        private bool m_readOnly;
        private int m_maxDisplayTextLength;
        private event EventHandler m_ValueChanged;
        #endregion

        private class AccessInfo
        {
            public AccessInfo Parent { get; set; }
            public PropertyInfo PropertyInfo { get; set; }
            public int[] Indexes;
            public TypeInfo TypeInfo;
            public object Value;
            public string Name;
        }

        #region Public Members
        /// <summary>
        /// The maximum length of a value string displayed in a column.
        /// </summary>
        [DefaultValue(100)]
        public int MaxDisplayTextLength
        {
            get
            {
                return m_maxDisplayTextLength;
            }

            set
            {
                if (value < 20)
                {
                    m_maxDisplayTextLength = 20;
                }

                m_maxDisplayTextLength = value;
            }
        }

        /// <summary>
        /// Returns true if the Back command can be called.
        /// </summary>
        public bool CanGoBack
        {
            get
            {
                return (NavigationMENU.Items.Count > 1);
            }
        }

        /// <summary>
        /// Returns true if the ArraySize can be changed.
        /// </summary>
        public bool CanSetArraySize
        {
            get
            {
                if (m_readOnly)
                {
                    return false;
                }

                AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;

                if (info != null)
                {
                    return info.TypeInfo.ValueRank >= 0;
                }

                return false;
            }
        }

        /// <summary>
        /// Returns true if the data type can be changed.
        /// </summary>
        public bool CanChangeType
        {
            get
            {
                if (m_readOnly)
                {
                    return false;
                }

                if (NavigationMENU.Items.Count > 0)
                {
                    AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;

                    if (info != null)
                    {
                        return info.Parent != null && info.Parent.TypeInfo != null && info.Parent.TypeInfo.BuiltInType == BuiltInType.Variant;
                    }
                }

                return false;
            }
        }

        /// <summary>
        /// Returns the current data type.
        /// </summary>
        public BuiltInType CurrentType
        {
            get
            {
                if (NavigationMENU.Items.Count > 0)
                {
                    AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;

                    if (info != null)
                    {
                        Variant? value = info.Value as Variant?;

                        if (value != null && value.Value.TypeInfo != null)
                        {
                            return value.Value.TypeInfo.BuiltInType;
                        }

                        return info.TypeInfo.BuiltInType;
                    }
                }

                return BuiltInType.Variant;
            }
        }

        /// <summary>
        /// Raised when the value is changed.
        /// </summary>
        public event EventHandler ValueChanged
        {
            add { m_ValueChanged += value; }
            remove { m_ValueChanged -= value; }
        }

        /// <summary>
        /// Changes the session used for editing the value.
        /// </summary>
        public void ChangeSession(Session session)
        {
            m_session = session;
        }

        /// <summary>
        /// Moves the displayed value back.
        /// </summary>
        public void Back()
        {
            if (!CanGoBack)
            {
                return;
            } 
            
            NavigationMENU_Click(NavigationMENU.Items[NavigationMENU.Items.Count - 2], null);
        }


        /// <summary>
        /// Changes the array size.
        /// </summary>
        public void SetArraySize()
        {
            if (!CanSetArraySize)
            {
                return;
            }

            EndEdit();

            AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;

            TypeInfo currentType = info.TypeInfo;
            object currentValue = info.Value;

            if (info.Value is Variant)
            {
                Variant variant = (Variant)info.Value;
                currentValue = variant.Value;

                if (currentValue != null)
                {
                    currentType = variant.TypeInfo;

                    if (currentType == null)
                    {
                        currentType = TypeInfo.Construct(currentValue);
                    }
                }
            }

            int[] dimensions = null;

            if (currentValue is Array array)
            {
                dimensions = new int[array.Rank];

                for (int ii = 0; ii < array.Rank; ii++)
                {
                    dimensions[ii] = array.GetLength(ii);
                }
            }

            if (array == null && currentValue is IList list)
            {
                dimensions = new int[1];
                dimensions[0] = list.Count;
            }

            if (currentValue is Matrix matrix)
            {
                dimensions = matrix.Dimensions;
                array = matrix.ToArray();
            }

            SetTypeDlg.SetTypeResult result = new SetTypeDlg().ShowDialog(currentType, dimensions);

            if (result == null)
            {
                return;
            }

            // convert to new type.
            object newValue = currentValue;

            if (result.ArrayDimensions == null || result.ArrayDimensions.Length < 1)
            {
                newValue = Convert(currentValue, currentType, result.TypeInfo, result.UseDefaultOnError);
            }
            else
            {
                if (array == null && currentValue is IList list)
                {
                    Type elementType = GetListElementType(list);

                    for (int ii = result.ArrayDimensions[0]; ii < list.Count; ii++)
                    {
                        list.RemoveAt(ii);
                    }

                    for (int ii = list.Count; ii < result.ArrayDimensions[0]; ii++)
                    {
                        list.Add(Activator.CreateInstance(elementType));
                    }

                    newValue = list;
                }

                if (currentValue is Array array)
                {
                    Array newArray = null;

                    if (currentValue is Array)
                    {
                        newArray = Array.CreateInstance(currentValue.GetType().GetElementType(), result.ArrayDimensions);
                    }
                    else
                    {
                        newArray = TypeInfo.CreateArray(result.TypeInfo.BuiltInType, result.ArrayDimensions);
                    }

                    int maxCount = result.ArrayDimensions[0];

                    for (int ii = 1; ii < result.ArrayDimensions.Length; ii++)
                    {
                        maxCount *= result.ArrayDimensions[ii];
                    }

                    int count = 0;

                    foreach (object element in array)
                    {
                        if (maxCount <= count)
                        {
                            break;
                        }

                        object newElement = Convert(element, currentType, result.TypeInfo, result.UseDefaultOnError);
                        int[] indexes = GetIndexFromCount(count++, result.ArrayDimensions);
                        newArray.SetValue(newElement, indexes);
                    }

                    newValue = newArray;
                }
            }

            NavigationMENU.Items.RemoveAt(NavigationMENU.Items.Count - 1);

            info.TypeInfo = result.TypeInfo;
            info.Value = newValue;
            ShowValue(info);
        }

        /// <summary>
        /// Changes the data type.
        /// </summary>
        public void SetType(BuiltInType builtInType)
        {
            if (!CanChangeType)
            {
                return;
            }
            
            AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;

            TypeInfo currentType = info.TypeInfo;
            object currentValue = info.Value;

            try
            {
                EndEdit();
                currentValue = info.Value;
            }
            catch (Exception)
            {
                currentValue = TypeInfo.GetDefaultValue(currentType.BuiltInType);
            }

            if (info.Value is Variant)
            {
                Variant variant = (Variant)info.Value;
                currentValue = variant.Value;

                if (currentValue != null)
                {
                    currentType = variant.TypeInfo;

                    if (currentType == null)
                    {
                        currentType = TypeInfo.Construct(currentValue);
                    }
                }
            }
            
            TypeInfo targetType = new TypeInfo(builtInType, currentType.ValueRank);
            object newValue  = Convert(currentValue, currentType, targetType, true);

            NavigationMENU.Items.RemoveAt(NavigationMENU.Items.Count - 1);

            info.TypeInfo = targetType;
            info.Value = newValue;
            ShowValueNoNotify(info);
        }

        /// <summary>
        /// Converts the old type to the new type.
        /// </summary>
        private object Convert(object oldValue, TypeInfo oldType, TypeInfo newType, bool useDefaultOnError)
        {
            object newValue = oldValue;

            if (oldType.BuiltInType != newType.BuiltInType)
            {
                try
                {
                    newValue = TypeInfo.Cast(oldValue, oldType, newType.BuiltInType);
                }
                catch (Exception e)
                {
                    if (!useDefaultOnError)
                    {
                        throw new FormatException("Could not cast value to requested type.", e);
                    }

                    newValue = TypeInfo.GetDefaultValue(newType.BuiltInType);
                }
            }

            return newValue;
        }

        /// <summary>
        /// Displays the value in the control.
        /// </summary>
        public void ShowValue(
            NodeId nodeId,
            uint attributeId,
            string name, 
            object value, 
            bool readOnly)
        {
            m_readOnly = readOnly;
            NavigationMENU.Items.Clear();

            if (m_readOnly)
            {
                ValuesDV.EditMode = DataGridViewEditMode.EditProgrammatically;
                TextValueTB.ReadOnly = true;
            }

            Type type = null;

            // determine the expected data type for non-value attributes.
            if (attributeId != 0 && attributeId != Attributes.Value)
            {
                BuiltInType builtInType = TypeInfo.GetBuiltInType(Attributes.GetDataTypeId(attributeId));
                int valueRank = Attributes.GetValueRank(attributeId);
                type = TypeInfo.GetSystemType(builtInType, valueRank);
            }

            // determine the expected data type for value attributes.
            else if (!NodeId.IsNull(nodeId))
            {
                if (m_session.NodeCache.Find(nodeId) is IVariableBase variable)
                {
                    BuiltInType builtInType = TypeInfo.GetBuiltInType(variable.DataType, m_session.TypeTree);
                    int valueRank = variable.ValueRank;
                    type = TypeInfo.GetSystemType(builtInType, valueRank);

                    if (builtInType == BuiltInType.ExtensionObject && valueRank < 0)
                    {
                        type = TypeInfo.GetSystemType(variable.DataType, m_session.Factory);
                    }
                }
            }

            // use the value.
            else if (value != null)
            {
                type = value.GetType();
            }

            // go with default.
            else
            {
                type = typeof(string);
            }

            // assign a name.
            if (String.IsNullOrEmpty(name))
            {
                if (attributeId != 0)
                {
                    name = Attributes.GetBrowseName(attributeId);
                }
                else
                {
                    name = type.Name;
                }
            }

            AccessInfo info = new AccessInfo();
            info.Value = Utils.Clone(value);
            info.TypeInfo = TypeInfo.Construct(type);

            if (value == null && info.TypeInfo.ValueRank < 0)
            {
                info.Value = TypeInfo.GetDefaultValue(info.TypeInfo.BuiltInType);
            }

            info.Name = name;
            m_value = info;

            ShowValue(info);
        }

        /// <summary>
        /// Displays the value in the control.
        /// </summary>
        public void ShowValue(
            string name,
            NodeId dataType,
            int valueRank,
            object value)
        {
            if (value == null && m_session != null)
            {
                BuiltInType builtInType = TypeInfo.GetBuiltInType(dataType, m_session.TypeTree);

                if (builtInType == BuiltInType.ExtensionObject)
                {
                    Type type = m_session.Factory.GetSystemType(dataType);

                    if (type != null)
                    {
                        if (valueRank < 0)
                        {
                            value = Activator.CreateInstance(type);
                        }
                        else
                        {
                            value = Array.CreateInstance(type, new int[valueRank]);
                        }
                    }
                }
                else
                {
                    value = TypeInfo.GetDefaultValue(dataType, valueRank, m_session.TypeTree);
                }
            }

            ShowValue(null, name, value);
        }

        /// <summary>
        /// Displays the value in the control.
        /// </summary>
        public void ShowValue(
            TypeInfo expectedType,
            string name,
            object value)
        {
            m_readOnly = false;
            NavigationMENU.Items.Clear();

            // assign a type.
            if (expectedType == null)
            {
                if (value == null)
                {
                    expectedType = TypeInfo.Scalars.String;
                }
                else
                {
                    expectedType = TypeInfo.Construct(value);
                }
            }

            // assign a name.
            if (String.IsNullOrEmpty(name))
            {
                name = expectedType.ToString();
            }
            
            AccessInfo info = new AccessInfo();
            info.Value = Utils.Clone(value);
            info.TypeInfo = expectedType;

            if (value == null && info.TypeInfo.ValueRank < 0)
            {
                info.Value = TypeInfo.GetDefaultValue(info.TypeInfo.BuiltInType);
            }

            // ensure value is the target type.
            info.Value = TypeInfo.Cast(info.Value, expectedType.BuiltInType);

            info.Name = name;
            m_value = info;

            ShowValue(info);
        }

        /// <summary>
        /// Returns the edited value.
        /// </summary>
        public object GetValue()
        {
            return m_value.Value;
        }

        /// <summary>
        /// Validates the value currently being edited.
        /// </summary>
        public void EndEdit()
        {
            if (NavigationMENU.Items.Count < 1)
            {
                return;
            }

            if (!TextValueTB.Visible)
            {
                ValuesDV.EndEdit();
                return;
            }

            AccessInfo info = NavigationMENU.Items[NavigationMENU.Items.Count - 1].Tag as AccessInfo;
            object newValue = TypeInfo.Cast(TextValueTB.Text, info.TypeInfo.BuiltInType);
            info.Value = newValue;
            UpdateParent(info);
        }

        /// <summary>
        /// Displays the value in the control.
        /// </summary>
        private void ShowValue(AccessInfo parent)
        {
            ShowValueNoNotify(parent);

            if (m_ValueChanged != null)
            {
                m_ValueChanged(this, null);
            }
        }

        /// <summary>
        /// Displays the value in the control.
        /// </summary>
        private void ShowValueNoNotify(AccessInfo parent)
        {
            m_dataset.Tables[0].Clear();
            ValuesDV.Visible = true;
            TextValueTB.Visible = false;

            ToolStripItem item = NavigationMENU.Items.Add(parent.Name);
            item.Click += new EventHandler(NavigationMENU_Click);
            item.Tag = parent;

            TypeInfo typeInfo = parent.TypeInfo;
            object value = parent.Value;

            if (value is Variant variant)
            {
                value = variant.Value;

                if (value != null)
                {
                    parent.TypeInfo = typeInfo = variant.TypeInfo;

                    if (typeInfo == null)
                    {
                        parent.TypeInfo = typeInfo = TypeInfo.Construct(value);
                    }
                }
            }

            if (typeInfo.ValueRank >= 0)
            {
                if (value is Matrix matrix)
                {
                    value = matrix.ToArray();
                }

                if (value is System.Collections.IEnumerable enumerable)
                {
                    // get the dimensions of any array.
                    int[] dimensions = null;

                    // calculate them.
                    if (matrix == null)
                    {
                        if (enumerable is Array array)
                        {
                            dimensions = new int[array.Rank];

                            for (int ii = 0; ii < array.Rank; ii++)
                            {
                                dimensions[ii] = array.GetLength(ii);
                            }
                        }
                        else
                        {
                            dimensions = new int[1];

                            if (enumerable is System.Collections.IList list)
                            {
                                dimensions[0] = list.Count;
                            }
                        }
                    }

                    // get them from the matrix.
                    else
                    {
                        dimensions = matrix.Dimensions;
                    }

                    // display the array elements.
                    int count = 0;
                    TypeInfo elementType = new TypeInfo(typeInfo.BuiltInType, ValueRanks.Scalar);

                    ValuesDV.Visible = true;
                    TextValueTB.Visible = false;

                    foreach (object element in enumerable)
                    {
                        int[] indexes = GetIndexFromCount(count++, dimensions);

                        AccessInfo info = new AccessInfo();
                        info.Parent = parent;
                        info.Indexes = indexes;
                        info.TypeInfo = elementType;
                        info.Value = element;

                        ShowIndexedValue(info);
                    }
                }

                return;
            }

            // check for null.
            if (value == null)
            {
                if (parent.Parent != null && parent.Parent.Value is Array)
                {
                    parent.Value = value = Activator.CreateInstance(parent.Parent.Value.GetType().GetElementType());
                }
                else if (parent.Parent != null && parent.PropertyInfo != null)
                {
                    parent.Value = value = Activator.CreateInstance(parent.PropertyInfo.PropertyType);
                }
                else
                {
                    ShowTextValue(value, parent.TypeInfo);
                    return;
                }
            }

            object structure = value;

            // check for extension object.

            if (structure is ExtensionObject extension)
            {
                structure = extension.Body;
            }

            // check for XmlElements.
            if (structure is XmlElement xmlElement)
            {
                ShowTextValue(xmlElement);
                return;
            }

            // check for ByteString.
            if (structure is byte[] bytes)
            {
                ShowTextValue(bytes);
                return;
            }

            // check for NodeId.
            if (structure is NodeId nodeId)
            {
                ShowTextValue(nodeId.ToString());
                return;
            }

            // check for ExpandedNodeId.
            if (structure is ExpandedNodeId expandedNodeId)
            {
                ShowTextValue(expandedNodeId.ToString());
                return;
            }

            // check for QualifiedName.
            if (structure is QualifiedName qualifiedName)
            {
                ShowTextValue(qualifiedName.ToString());
                return;
            }

            // check for Guid.
            if (structure is Guid guid)
            {
                ShowTextValue(guid.ToString());
                return;
            }

            // check for Uuid.
            if (structure is Uuid uuid)
            {
                ShowTextValue(uuid.ToString());
                return;
            }

            // check for StatusCode.
            if (structure is StatusCode statusCode)
            {
                ShowTextValue(Utils.Format("0x{0:X8}", statusCode.Code));
                return;
            }

            ValuesDV.Visible = true;
            TextValueTB.Visible = false;

            // use reflection to display the properties of the structure.
            bool isStructure = false;
            PropertyInfo[] properties = structure.GetType().GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

            foreach (PropertyInfo property in properties)
            {
                if (property.GetIndexParameters().Length > 0)
                {
                    continue;
                }

                object element = property.GetValue(structure, null);

                string name = null;

                foreach (object attribute in property.GetCustomAttributes(true))
                {
                    if (typeof(System.Runtime.Serialization.DataMemberAttribute).IsInstanceOfType(attribute))
                    {
                        name = ((System.Runtime.Serialization.DataMemberAttribute)attribute).Name;

                        if (name == null)
                        {
                            name = property.Name;
                        }

                        break;
                    }
                }

                if (name == null)
                {
                    continue;
                }

                AccessInfo info = new AccessInfo();
                info.Parent = parent;
                info.PropertyInfo = property;
                info.TypeInfo = TypeInfo.Construct(property.PropertyType);
                info.Value = element;
                info.Name = name;

                ShowNamedValue(info);
                isStructure = true;
            }

            if (!isStructure)
            {
                ShowTextValue(parent.Value, parent.TypeInfo);
            }
        }
        #endregion

        #region Private Methods
        /// <summary>
        /// Returns the index based on the current count.
        /// </summary>
        private int[] GetIndexFromCount(int count, int[] dimensions)
        {
            int[] indexes = new int[(dimensions != null) ? dimensions.Length : 1];

            for (int ii = indexes.Length - 1; ii >= 0; ii--)
            {
                indexes[ii] = count % dimensions[ii];
                count /= dimensions[ii];
            }

            return indexes;
        }

        /// <summary>
        /// Adds the value at an array index to the control.
        /// </summary>
        private void ShowIndexedValue(AccessInfo info)
        {
            DataRow row = m_dataset.Tables[0].NewRow();

            StringBuilder buffer = new StringBuilder();
            buffer.Append("[");

            if (info.Indexes != null)
            {
                for (int ii = 0; ii < info.Indexes.Length; ii++)
                {
                    if (ii > 0)
                    {
                        buffer.Append(",");
                    }

                    buffer.Append(info.Indexes[ii]);
                }
            }

            buffer.Append("]");
            info.Name = buffer.ToString();

            row[0] = info;
            row[1] = info.Name;
            row[2] = GetDataTypeString(info);
            row[3] = ValueToString(info.Value, info.TypeInfo);
            row[4] = ImageList.Images[ClientUtils.GetImageIndex(Attributes.Value, info.Value)];

            m_dataset.Tables[0].Rows.Add(row);
        }

        /// <summary>
        /// Returns the element type for a list.
        /// </summary>
        private Type GetListElementType(IList list)
        {
            if (list != null)
            {
                for (Type type = list.GetType(); type != null; type = type.BaseType)
                {
                    if (type.IsGenericType)
                    {
                        Type[] argTypes = type.GetGenericArguments();

                        if (argTypes.Length > 0)
                        {
                            return argTypes[0];
                        }
                    }
                }
            }

            return typeof(object);
        }

        /// <summary>
        /// Returns the data type of the value.
        /// </summary>
        private Type GetDataType(AccessInfo accessInfo)
        {
            if (accessInfo == null || accessInfo.TypeInfo == null)
            {
                return null;
            }

            if (accessInfo.TypeInfo.BuiltInType == BuiltInType.ExtensionObject)
            {
                if (accessInfo.Value != null)
                {
                    return accessInfo.Value.GetType();
                }

                if (accessInfo.PropertyInfo != null)
                {
                    return accessInfo.PropertyInfo.PropertyType;
                }

                if (accessInfo.Parent != null)
                {
                    if (accessInfo.Parent.Value is Array)
                    {
                        Array array = (Array)accessInfo.Parent.Value;
                        return array.GetType().GetElementType();
                    }

                    if (accessInfo.Parent.Value is IList)
                    {
                        IList list = (IList)accessInfo.Parent.Value;
                        return GetListElementType(list);
                    }
                }
            }

            return TypeInfo.GetSystemType(accessInfo.TypeInfo.BuiltInType, accessInfo.TypeInfo.ValueRank);
        }

        /// <summary>
        /// Returns the data type of the value.
        /// </summary>
        private string GetDataTypeString(AccessInfo accessInfo)
        {
            Type type = GetDataType(accessInfo);

            if (type == null)
            {
                return accessInfo.TypeInfo.ToString();
            }

            return type.Name;
        }

        /// <summary>
        /// Adds the value with the specified name to the control.
        /// </summary>
        private void ShowNamedValue(AccessInfo info)
        {
            DataRow row = m_dataset.Tables[0].NewRow();

            row[0] = info;
            row[1] = (info.Name != null) ? info.Name : "unknown";
            row[2] = GetDataTypeString(info);
            row[3] = ValueToString(info.Value, info.TypeInfo);
            row[4] = ImageList.Images[ClientUtils.GetImageIndex(Attributes.Value, info.Value)];

            m_dataset.Tables[0].Rows.Add(row);
        }

        /// <summary>
        /// Displays a value in the control.
        /// </summary>
        private void ShowTextValue(object value, TypeInfo typeInfo)
        {
            switch (typeInfo.BuiltInType)
            {
                case BuiltInType.ByteString:
                {
                    ShowTextValue((byte[])value);
                    break;
                }

                case BuiltInType.XmlElement:
                {
                    ShowTextValue((XmlElement)value);
                    break;
                }

                case BuiltInType.String:
                {
                    ShowTextValue((string)value);
                    break;
                }

                default:
                {
                    ShowTextValue(ValueToString(value, typeInfo));
                    break;
                }
            }
        }

        /// <summary>
        /// Displays a string in the control.
        /// </summary>
        private void ShowTextValue(string value)
        {
            ValuesDV.Visible = false;
            TextValueTB.Visible = true;

            if (value != null && value.Length > MaxDisplayTextLength)
            {
                TextValueTB.ScrollBars = ScrollBars.Both;
            }
            else
            {
                TextValueTB.ScrollBars = ScrollBars.None;
            }

            TextValueTB.Font = new Font("Segoe UI", TextValueTB.Font.Size);
            TextValueTB.Text = value;
        }

        /// <summary>
        /// Displays a complete byte string in the control.
        /// </summary>
        private void ShowTextValue(byte[] value)
        {
            ValuesDV.Visible = false;
            TextValueTB.Visible = true;

            StringBuilder buffer = new StringBuilder();

            if (value != null)
            {
                for (int ii = 0; ii < value.Length; ii++)
                {
                    if (buffer.Length > 0 && (ii % 30) == 0)
                    {
                        buffer.Append("\r\n");
                    }

                    buffer.AppendFormat("{0:X2} ", value[ii]);
                }
            }

            TextValueTB.Font = new Font("Courier New", TextValueTB.Font.Size);
            TextValueTB.Text = buffer.ToString();
        }

        /// <summary>
        /// Displays a complete XML element in the control.
        /// </summary>
        private void ShowTextValue(XmlElement value)
        {
            ValuesDV.Visible = false;
            TextValueTB.Visible = true;

            StringBuilder buffer = new StringBuilder();

            if (value != null)
            {
                XmlWriterSettings settings = new XmlWriterSettings();
                settings.Indent = true;
                settings.OmitXmlDeclaration = true;
                settings.NewLineHandling = NewLineHandling.Replace;
                settings.NewLineChars = "\r\n";
                settings.IndentChars = "    ";

                using (XmlWriter writer = XmlWriter.Create(buffer, settings))
                {
                    using (XmlNodeReader reader = new XmlNodeReader(value))
                    {
                        writer.WriteNode(reader, false);
                    }
                }
            }

            TextValueTB.Font = new Font("Courier New", TextValueTB.Font.Size);
            TextValueTB.Text = buffer.ToString();
        }

        /// <summary>
        /// Converts a value to a string for display in the grid.
        /// </summary>
        private string ValueToString(object value, TypeInfo typeInfo)
        {
            if (value == null)
            {
                return String.Empty;
            }

            if (value is Variant variant)
            {
                value = variant.Value;

                if (value != null)
                {
                    typeInfo = variant.TypeInfo;

                    if (typeInfo == null)
                    {
                        typeInfo = TypeInfo.Construct(value);
                    }
                }
            }

            if (typeInfo.ValueRank >= 0)
            {
                StringBuilder buffer = new StringBuilder();

                if (value is System.Collections.IEnumerable enumerable)
                {
                    buffer.Append("{ ");

                    foreach (object element in enumerable)
                    {
                        if (buffer.Length > 2)
                        {
                            buffer.Append(" | ");
                        }

                        if (buffer.Length > MaxDisplayTextLength)
                        {
                            buffer.Append("...");
                            break;
                        }

                        buffer.Append(ValueToString(element, new TypeInfo(typeInfo.BuiltInType, ValueRanks.Scalar)));
                    }

                    buffer.Append(" }");
                }

                return buffer.ToString();
            }

            switch (typeInfo.BuiltInType)
            {
                case BuiltInType.String:
                {
                    string text = (string)value;

                    if (text != null && text.Length > MaxDisplayTextLength)
                    {
                        return text.Substring(0, MaxDisplayTextLength) + "...";
                    }

                    return text;
                }

                case BuiltInType.ByteString:
                {
                    StringBuilder buffer = new StringBuilder();

                    byte[] bytes = (byte[])value;

                    for (int ii = 0; ii < bytes.Length; ii++)
                    {
                        if (buffer.Length > MaxDisplayTextLength)
                        {
                            buffer.Append("...");
                            break;
                        }

                        buffer.AppendFormat("{0:X2}", bytes[ii]);
                    }

                    return buffer.ToString();
                }

                case BuiltInType.Enumeration:
                {
                    return ((int)value).ToString();
                }

                case BuiltInType.ExtensionObject:
                {
                    string text = null;

                    if (value is ExtensionObject extension)
                    {
                        if (extension.Body is byte[])
                        {
                            return ValueToString(extension.Body, new TypeInfo(BuiltInType.ByteString, ValueRanks.Scalar));
                        }

                        if (extension.Body is XmlElement)
                        {
                            return ValueToString(extension.Body, new TypeInfo(BuiltInType.XmlElement, ValueRanks.Scalar));
                        }

                        if (extension.Body is IEncodeable)
                        {
                            text = new Variant(extension).ToString();
                        }
                    }

                    if (text == null)
                    {
                        if (value is IEncodeable encodeable)
                        {
                            text = new Variant(encodeable).ToString();
                        }
                    }

                    if (text != null && text.Length > MaxDisplayTextLength)
                    {
                        return text.Substring(0, MaxDisplayTextLength) + "...";
                    }

                    return text;
                }
            }

            return (string)TypeInfo.Cast(value, BuiltInType.String);
        }

        /// <summary>
        /// Whether the value can be edited in the grid view.
        /// </summary>
        private bool IsSimpleValue(AccessInfo info)
        {
            if (info == null || info.TypeInfo == null)
            {
                return true;
            }

            TypeInfo typeInfo = info.TypeInfo;
            object value = info.Value;

            if (value is Variant)
            {
                Variant variant = (Variant)info.Value;
                typeInfo = variant.TypeInfo;
                value = variant.Value;

                if (typeInfo == null)
                {
                    typeInfo = TypeInfo.Construct(value);
                }
            }

            if (typeInfo.ValueRank >= 0)
            {
                return false;
            }
            
            switch (typeInfo.BuiltInType)
            {
                case BuiltInType.String:
                {
                    if (value is string text && text.Length >= MaxDisplayTextLength)
                    {
                        return false;
                    }

                    return true;
                }

                case BuiltInType.ByteString:
                case BuiltInType.XmlElement:
                case BuiltInType.QualifiedName:
                case BuiltInType.LocalizedText:
                case BuiltInType.DataValue:
                case BuiltInType.ExtensionObject:
                {
                    return false;
                }
            }

            return true;
        }
        #endregion

        private void NavigationMENU_Click(object sender, EventArgs e)
        {
            try
            {
                EndEdit();

                if (sender is ToolStripItem item)
                {
                    // remove all menu items appearing after the selected item.
                    for (int ii = NavigationMENU.Items.Count-1; ii >= 0; ii--)
                    {
                        ToolStripItem target = NavigationMENU.Items[ii];
                        NavigationMENU.Items.Remove(target);

                        if (Object.ReferenceEquals(target, item))
                        {
                            break;
                        }
                    }

                    // show the current value.
                    AccessInfo info = (AccessInfo)item.Tag;
                    ShowValue(info);
                }
            }
            catch (Exception exception)
            {
                ClientUtils.HandleException(this.Text, exception);
            }
        }

        private void ValuesDV_DoubleClick(object sender, EventArgs e)
        {
            try
            {
                foreach (DataGridViewCell cell in ValuesDV.SelectedCells)
                {
                    DataRowView source = ValuesDV.Rows[cell.RowIndex].DataBoundItem as DataRowView;

                    if (cell.ColumnIndex == 3)
                    {
                        AccessInfo info = (AccessInfo)source.Row[0];
                        ShowValue(info);
                    }
                    
                    break;
                }
            }
            catch (Exception exception)
            {
                ClientUtils.HandleException(this.Text, exception);
            }
        }

        private void ValuesDV_CellValidating(object sender, DataGridViewCellValidatingEventArgs e)
        {
            try
            {
                if (this.Visible && e.ColumnIndex == 3)
                {
                    DataRowView source = ValuesDV.Rows[e.RowIndex].DataBoundItem as DataRowView;
                    AccessInfo info = (AccessInfo)source.Row[0];

                    if (IsSimpleValue(info))
                    {
                        TypeInfo.Cast(e.FormattedValue, info.TypeInfo.BuiltInType);
                    }
                }
            }
            catch (Exception exception)
            {
                ClientUtils.HandleException(this.Text, exception);
                e.Cancel = true;
            }
        }

        private void ValuesDV_CellValueChanged(object sender, DataGridViewCellEventArgs e)
        {
            try
            {
                if (this.Visible && e.RowIndex >= 0 && e.ColumnIndex == 3)
                {
                    DataRowView source = ValuesDV.Rows[e.RowIndex].DataBoundItem as DataRowView;
                    AccessInfo info = (AccessInfo)source.Row[0];

                    if (IsSimpleValue(info))
                    {
                        object newValue = TypeInfo.Cast((string)source.Row[3], info.TypeInfo.BuiltInType);
                        info.Value = newValue;
                        UpdateParent(info);
                    }
                }
            }
            catch (Exception exception)
            {
                ClientUtils.HandleException(this.Text, exception);
            }
        }

        /// <summary>
        /// Recusivesly updates the parent values.
        /// </summary>
        private void UpdateParent(AccessInfo info)
        {
            if (info.Parent == null)
            {
                return;
            }

            object parentValue = info.Parent.Value;

            if (info.Parent.TypeInfo.BuiltInType == BuiltInType.Variant && info.Parent.TypeInfo.ValueRank < 0)
            {
                parentValue = ((Variant)info.Parent.Value).Value;
            }

            if (info.PropertyInfo != null && info.Parent.TypeInfo.ValueRank < 0)
            {
                if (parentValue is ExtensionObject extension)
                {
                    parentValue = extension.Body;
                }

                info.PropertyInfo.SetValue(parentValue, info.Value, null);
            }

            else if (info.Indexes != null)
            {
                int[] indexes = info.Indexes;

                if (parentValue is Matrix matrix)
                {
                    int count = 0;
                    int block = 1;

                    for (int ii = info.Indexes.Length-1; ii >= 0 ; ii--)
                    {
                        count += info.Indexes[ii] * block;
                        block *= matrix.Dimensions[ii];
                    }

                    array = matrix.Elements;
                    indexes = new int[] { count };
                }

                if (parentValue is Array array)
                {
                    if (info.Parent.TypeInfo.BuiltInType == BuiltInType.Variant && info.Parent.TypeInfo.ValueRank >= 0)
                    {
                        array.SetValue(new Variant(info.Value), indexes);
                    }
                    else
                    {
                        array.SetValue(info.Value, indexes);
                    }
                }
                else
                {
                    IList list = parentValue as IList;

                    if (info.Parent.TypeInfo.BuiltInType == BuiltInType.Variant && info.Parent.TypeInfo.ValueRank >= 0)
                    {
                        list[indexes[0]] = new Variant(info.Value);
                    }
                    else
                    {
                        list[indexes[0]] = info.Value;
                    }
                }
            }

            if (info.Parent != null)
            {
                UpdateParent(info.Parent);
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs(36,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs(32,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs(305,21): error CS0841: Cannot use local variable 'array' before it is declared,D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs(305,60): error CS0136: A local or parameter named 'list' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs(322,43): error CS0136: A local or parameter named 'array' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs(277,17): error CS0165: Use of unassigned local variable 'array',D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs(703,25): error CS0165: Use of unassigned local variable 'matrix',D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs(1489,21): error CS0841: Cannot use local variable 'array' before it is declared,D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Common\Client\EditComplexValueCtrl.cs(36,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 35 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using System.Reflection;
using System.Runtime.Serialization;
using System.Xml;
using System.Xml.Serialization;

using Opc.Ua.Client;
using Opc.Ua.Client.Controls;

namespace Opc.Ua.Client.Controls
{
    /// <summary>
    /// Displays a hierarchical view of a complex value.
    /// </summary>
    public partial class DataListCtrl : Opc.Ua.Client.Controls.BaseListCtrl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DataListCtrl"/> class.
        /// </summary>
        public DataListCtrl()
        {
            InitializeComponent();                        
			SetColumns(m_ColumnNames);
        }

        #region Private Fields
        /// <summary>
		/// The columns to display in the control.
		/// </summary>
		private readonly object[][] m_ColumnNames = new object[][]
		{
			new object[] { "Name",  HorizontalAlignment.Left, null },  
			new object[] { "Value", HorizontalAlignment.Left, null, 250 }, 
			new object[] { "Type",  HorizontalAlignment.Left, null } 
		};

        private bool m_latestValue = true;
        private bool m_expanding;
        private int m_depth;
        private Font m_defaultFont;
        private MonitoredItem m_monitoredItem;

        private const string UnknownType  = "(unknown)";
        private const string NullValue    = "(null)";
        private const string ExpandIcon   = "ExpandPlus";
        private const string CollapseIcon = "ExpandMinus";
		#endregion

        #region Public Interface
        /// <summary>
        /// Whether to update the control when the value changes.
        /// </summary>
        public bool AutoUpdate
        {
            get { return UpdatesMI.Checked;  }
            set { UpdatesMI.Checked = value; }
        }

        /// <summary>
        /// Whether to only display the latest value for a monitored item.
        /// </summary>
        public bool LatestValue
        {
            get { return m_latestValue;  }
            set { m_latestValue = value; }
        }
        
        /// <summary>
        /// The monitored item associated with the value.
        /// </summary>
        public MonitoredItem MonitoredItem
        {
            get { return m_monitoredItem;  }
            set { m_monitoredItem = value; }
        }

        /// <summary>
        /// Clears the contents of the control,
        /// </summary>
        public void Clear()
        {
            ItemsLV.Items.Clear();
            AdjustColumns();
        }
        
        /// <summary>
        /// Displays a value in the control.
        /// </summary>
        public void ShowValue(object value)
        {
            ShowValue(value, false);
        }

        /// <summary>
        /// Displays a value in the control.
        /// </summary>
        public void ShowValue(object value, bool overwrite)
        {
            if (!overwrite)
            {
                Clear();
            }

            if (value is byte[])
            {
                m_defaultFont = new Font("Courier New", 8.25F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0)));
            }
            else
            {            
                m_defaultFont = ItemsLV.Font;
            }

            m_expanding = false;
            m_depth = 0;
                        
            // show the value.
            int index = 0;
            ShowValue(ref index, ref overwrite, value);

            // adjust columns.
            AdjustColumns();
        }
		#endregion
        
        #region Overridden Methods
        /// <summary>
        /// Enables the menu items.
        /// </summary>
        protected override void EnableMenuItems(ListViewItem clickedItem)
        {
            RefreshMI.Enabled = true;
            ClearMI.Enabled   = true;

            if (ItemsLV.SelectedItems.Count == 1)
            {
                ValueState state = ItemsLV.SelectedItems[0].Tag as ValueState;
                EditMI.Enabled = IsEditableType(state.Component);
            }
        }
		#endregion
        
        #region ValueState Class
        /// <summary>
        /// Stores the state associated with an item.
        /// </summary>
        private class ValueState
        {
            public bool Expanded = false;
            public bool Expandable = false;
            public object Value = null;
            public object Component = null;
            public object ComponentId = null;
            public object ComponentIndex = null;
        }
		#endregion

        #region Private Members
        /// <summary>
        /// Returns true is the value is an editable type.
        /// </summary>
        private bool IsEditableType(object value)
        {
            if (value is bool)       return true;
            if (value is sbyte)      return true;
            if (value is byte)       return true;
            if (value is short)      return true;
            if (value is ushort)     return true;
            if (value is int)        return true;
            if (value is uint)       return true;
            if (value is long)       return true;
            if (value is ulong)      return true;
            if (value is float)      return true;
            if (value is double)     return true;
            if (value is string)     return true;
            if (value is DateTime)   return true;
            if (value is Guid)       return true;
            if (value is LocalizedText) return true;

            return false;
        }

        /// <summary>
        /// Shows the components of a value in the control.
        /// </summary>        
        private void ShowChildren(ListViewItem listItem)
        {            
            ValueState state = listItem.Tag as ValueState;

            if (state == null || !state.Expandable || state.Expanded)
            {
                return;
            }

            m_expanding = true;
            m_depth = listItem.IndentCount+1;
            
            state.Expanded = true;
            listItem.ImageKey = CollapseIcon;

            int index = listItem.Index+1;
            bool overwrite = false;

            ShowValue(ref index, ref overwrite, state.Component);

            AdjustColumns();
        }
        
        /// <summary>
        /// Hides the components of a value in the control.
        /// </summary>  
        private void HideChildren(ListViewItem listItem)
        {
            ValueState state = listItem.Tag as ValueState;

            if (state == null || !state.Expandable || !state.Expanded)
            {
                return;
            }

            for (int ii = listItem.Index+1; ii < ItemsLV.Items.Count;)
            {
                ListViewItem childItem = ItemsLV.Items[ii];
                
                if (childItem.IndentCount <= listItem.IndentCount)
                {
                    break;
                }

                childItem.Remove();
            }

            state.Expanded = false;
            listItem.ImageKey = ExpandIcon;
        }

        /// <summary>
        /// Returns the list item at the specified index.
        /// </summary>
        private ListViewItem GetListItem(int index, ref bool overwrite, string name, string type)
        {
            ListViewItem listitem = null;
            
            // switch to detail view as soon as an item is added.
            if (ItemsLV.View == View.List)
            {
                ItemsLV.Items.Clear();                
                ItemsLV.View = View.Details;
            }

            // check if there is an item that could be re-used.
            if (!m_expanding && index < ItemsLV.Items.Count)
            {                
                listitem = ItemsLV.Items[index];

                // check if still possible to overwrite values.
                if (overwrite)
                {
                    if (listitem.SubItems[0].Text != name || listitem.SubItems[2].Text != type)
                    {
                        overwrite = false;
                    }
                }
                
                listitem.SubItems[0].Text = name;
                listitem.SubItems[2].Text = type;

                return listitem;
            }
            
            overwrite = false;

            listitem = new ListViewItem(name);

            listitem.SubItems.Add(String.Empty);
            listitem.SubItems.Add(type);
            
            listitem.Font        = m_defaultFont;
            listitem.ImageKey    = ExpandIcon;
            listitem.IndentCount = m_depth;
            listitem.Tag         = new ValueState();

            if (!m_expanding)
            {
                ItemsLV.Items.Add(listitem);
            }
            else
            {
                ItemsLV.Items.Insert(index, listitem);
            }
                
            return listitem;
        }
        
        /// <summary>
        /// Returns true if the type can be expanded.
        /// </summary>
        private bool IsExpandableType(object value)
        {
            // check for null.
            if (value == null)
            {
                return false;
            }

            // check for Variant.
            if (value is Variant variant)
            {
                return IsExpandableType(variant.Value);
            }
            
            // check for bytes.
            byte[] bytes = value as byte[];

            if (bytes != null)
            {
                return false;
            }           
            
            // check for xml element.
            XmlElement xml = value as XmlElement;

            if (xml != null)
            {
                if (xml.ChildNodes.Count == 1 && xml.ChildNodes[0] is XmlText)
                {
                    return false;
                }

                return xml.HasChildNodes;
            }           
            
            // check for array.
            Array array = value as Array;

            if (array == null)
            {
                Matrix matrix = value as Matrix;

                if (matrix != null)
                {
                    array = matrix.ToArray();
                }
            }

            if (array != null)
            {
                return array.Length > 0;
            }           
            
            // check for list.
            IList list = value as IList;

            if (list != null)
            {
                return list.Count > 0;
            }
            
            // check for encodeable object.
            IEncodeable encodeable = value as IEncodeable;

            if (encodeable != null)
            {
                return true;
            }

            // check for extension object.
            ExtensionObject extension = value as ExtensionObject;
            
            if (extension != null)
            {
                return IsExpandableType(extension.Body);
            }
            
            // check for data value.
            DataValue datavalue = value as DataValue;
            
            if (datavalue != null)
            {
                return true;
            }
            
            // check for event value.
            EventFieldList eventFields = value as EventFieldList;
            
            if (eventFields != null)
            {
                return true;
            }

            // must be a simple value.
            return false;
        }

        /// <summary>
        /// Formats a value for display in the control.
        /// </summary>
        private string GetValueText(object value)
        {
            // check for null.
            if (value == null)
            {
                return "(null)";
            }
            
            // format bytes.
            byte[] bytes = value as byte[];

            if (bytes != null)
            {
                StringBuilder buffer = new StringBuilder();

                for (int ii = 0; ii < bytes.Length; ii++)
                {
                    if (ii != 0 && ii%16 == 0)
                    {
                        buffer.Append(" ");
                    }

                    buffer.AppendFormat("{0:X2} ", bytes[ii]);
                }

                return buffer.ToString();
            }           
            
            // format xml element.
            XmlElement xml = value as XmlElement;

            if (xml != null)
            {
                // return the entire element if not expandable.
                if (!IsExpandableType(xml))
                {
                    return xml.OuterXml;
                }
                
                // show only the start tag.
                string text = xml.OuterXml;

                int index = text.IndexOf('>');

                if (index != -1)
                {
                    text = text.Substring(0, index);
                }
                
                return text;
            }           
            
            // format array.
            Array array = value as Array;

            if (array != null)
            {
                if (array.Rank > 1)
                {
                    int[] lenghts = new int[array.Rank];

                    for (int i = 0; i < array.Rank; ++i)
                    {
                        lenghts[i] = array.GetLength(i);
                    }

                    return Utils.Format("{1}[{0}]", string.Join(",", lenghts), value.GetType().GetElementType().Name);
                }
                else
                {
                    return Utils.Format("{1}[{0}]", array.Length, value.GetType().GetElementType().Name);
                }
            }
            
            // format list.
            IList list = value as IList;

            if (list != null)
            {
                string type = value.GetType().Name;

                if (type.EndsWith("Collection"))
                {
                    type = type.Substring(0, type.Length - "Collection".Length);
                }
                else
                {
                    type = "Object";
                }

                return Utils.Format("{1}[{0}]", list.Count, type);
            }
            
            // format encodeable object.
            IEncodeable encodeable = value as IEncodeable;

            if (encodeable != null)
            {
                return encodeable.GetType().Name;
            }

            // format extension object.
            ExtensionObject extension = value as ExtensionObject;
            
            if (extension != null)
            {
                return GetValueText(extension.Body);
            }
            
            // check for event value.
            EventFieldList eventFields = value as EventFieldList;
            
            if (eventFields != null)
            {
                if (m_monitoredItem != null)
                {
                    return String.Format("{0}", m_monitoredItem.GetEventType(eventFields));
                }

                return eventFields.GetType().Name;
            }

            // check for data value.
            DataValue dataValue = value as DataValue;
            
            if (dataValue != null)
            {
                StringBuilder formattedValue = new StringBuilder();

                if (!StatusCode.IsGood(dataValue.StatusCode))
                {
                    formattedValue.Append("[");
                    formattedValue.AppendFormat("Q:{0}", dataValue.StatusCode);
                }

                DateTime now = DateTime.UtcNow;

                if ((dataValue != null) &&
                    ((dataValue.ServerTimestamp > now) || (dataValue.SourceTimestamp > now)))
                {
                    if (formattedValue.ToString().Length > 0)
                    {
                        formattedValue.Append(", ");
                    }
                    else
                    {
                        formattedValue.Append("[");
                    }

                    formattedValue.Append("T:future");
                }

                if (formattedValue.ToString().Length > 0)
                {
                    formattedValue.Append("] ");
                }

                formattedValue.AppendFormat("{0}", dataValue.Value);
                return formattedValue.ToString();
            }
            
            // use default formatting.
            return Utils.Format("{0}", value);
        }

        /// <summary>
        /// Updates the list with the specified value.
        /// </summary>
        private void UpdateList(
            ref int  index, 
            ref bool overwrite,
            object   value,
            object   componentValue,
            object   componentId,
            string   name,
            string   type)
        {
            // get the list item to update.
            ListViewItem listitem = GetListItem(index, ref overwrite, name, type);
            if (componentValue is StatusCode)
            {
                listitem.SubItems[1].Text = componentValue.ToString();
            }
            else
            {
                // update list item.
                listitem.SubItems[1].Text = GetValueText(componentValue);
            }            

            // move to next item.
            index++;

            ValueState state = listitem.Tag as ValueState;
            
            // recursively update sub-values if item is expanded.
            if (overwrite)
            {
                if (state.Expanded && state.Expandable)
                {
                    m_depth++;
                    ShowValue(ref index, ref overwrite, componentValue);
                    m_depth--;
                }
            }

            // update state.
            state.Expandable     = IsExpandableType(componentValue);
            state.Value          = value;
            state.Component      = componentValue;
            state.ComponentId    = componentId;
            state.ComponentIndex = index;

            if (!state.Expandable)
            {
                listitem.ImageKey = CollapseIcon;
            }
        }

        /// <summary>
        /// Updates the list with the specified value.
        /// </summary>
        private void UpdateList(
            ref int index,
            ref bool overwrite,
            object value,
            object componentValue,
            object componentId,
            string name,
            string type,
            bool enabled)
        {
            // get the list item to update.
            ListViewItem listitem = GetListItem(index, ref overwrite, name, type);

            if (!enabled)
            {
                listitem.ForeColor = Color.LightGray;
            }

            // update list item.
            listitem.SubItems[1].Text = GetValueText(componentValue);

            // move to next item.
            index++;

            ValueState state = listitem.Tag as ValueState;

            // recursively update sub-values if item is expanded.
            if (overwrite)
            {
                if (state.Expanded && state.Expandable)
                {
                    m_depth++;
                    ShowValue(ref index, ref overwrite, componentValue);
                    m_depth--;
                }
            }

            // update state.
            state.Expandable = IsExpandableType(componentValue);
            state.Value = value;
            state.Component = componentValue;
            state.ComponentId = componentId;
            state.ComponentIndex = index;

            if (!state.Expandable)
            {
                listitem.ImageKey = CollapseIcon;
            }
        }
        /// <summary>
        /// Shows property of an encodeable object in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, IEncodeable value, PropertyInfo property)
        {            
            // get the name of the property.
            string name = Utils.GetDataMemberName(property);

            if (name == null)
            {
                return;
            }
            
            // get the property value.
            object propertyValue = null;

            MethodInfo[] accessors = property.GetAccessors();

            for (int ii = 0; ii < accessors.Length; ii++)
            {
                if (accessors[ii].ReturnType == property.PropertyType)
                {
                    propertyValue = accessors[ii].Invoke(value, null);
                    break;
                }
            }
           
            if (propertyValue is Variant variant)
            {
                propertyValue = variant.Value;
            }
            
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                propertyValue,
                property,
                name,
                property.PropertyType.Name);
        }
        
        /// <summary>
        /// Shows the element of an array in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, Array value, int element)
        {            
            // get the name of the element.
            string name = Utils.Format("[{0}]", element);
                      
            // get the element value.
            object elementValue = null;

            if (value.Rank > 1)
            {
                int[] smallArrayDimmensions = new int[value.Rank - 1];
                int length = 1;

                for (int i = 0; i < value.Rank - 1; ++i)
                {
                    smallArrayDimmensions[i] = value.GetLength(i + 1);
                    length *= smallArrayDimmensions[i];
                }

                Array flatArray = Utils.FlattenArray(value);
                Array flatSmallArray = Array.CreateInstance(value.GetType().GetElementType(), length);
                Array.Copy(flatArray, element * value.GetLength(1), flatSmallArray, 0, length);
                Array smallArray = Array.CreateInstance(value.GetType().GetElementType(), smallArrayDimmensions);
                int[] indexes = new int[smallArrayDimmensions.Length];

                for (int ii = 0; ii < flatSmallArray.Length; ii++)
                {
                    smallArray.SetValue(flatSmallArray.GetValue(ii), indexes);

                    for (int jj = indexes.Length - 1; jj >= 0; jj--)
                    {
                        indexes[jj]++;

                        if (indexes[jj] < smallArrayDimmensions[jj])
                        {
                            break;
                        }

                        indexes[jj] = 0;
                    }
                }

                elementValue = smallArray;
            }
            else
            {
                elementValue = value.GetValue(element);
            }
            
            // get the type name.
            string type = null;

            if (elementValue != null)
            {
                type = elementValue.GetType().Name;
            }
            
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                elementValue,
                element,
                name,
                type);
        }

        /// <summary>
        /// Shows the element of an array in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, Array value, int element, bool enabled)
        {
            // get the name of the element.
            string name = Utils.Format("[{0}]", element);

            // get the element value.
            object elementValue = value.GetValue(element);

            // get the type name.
            string type = null;

            if (elementValue != null)
            {
                type = elementValue.GetType().Name;
            }

            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                elementValue,
                element,
                name,
                type,
                enabled);
        }

        /// <summary>
        /// Asks for confirmation before expanding a long list.
        /// </summary>
        private bool PromptOnLongList(int length)
        {            
            if (length < 256)
            {
                return true;
            }
                
            DialogResult result = MessageBox.Show("It may take a long time to display the list are you sure you want to continue?", "Warning", MessageBoxButtons.YesNo);

            if (result == DialogResult.Yes)
            {
                return true;
            }
                
            return false;
        }

        /// <summary>
        /// Shows the element of a list in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, IList value, int element)
        {            
            // get the name of the element.
            string name = Utils.Format("[{0}]", element);
                      
            // get the element value.
            object elementValue = value[element];
            
            // get the type name.
            string type = null;

            if (elementValue != null)
            {
                type = elementValue.GetType().Name;
            }
                        
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                elementValue,
                element,
                name,
                type);
        }
        
        /// <summary>
        /// Shows an XML element in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, XmlElement value, int childIndex)
        {        
            // ignore children that are not elements.
            XmlElement child = value.ChildNodes[childIndex] as XmlElement;

            if (child == null)
            {
                return;
            }
            
            // get the name of the element.
            string name = Utils.Format("{0}", child.Name);
            
            // get the type name.
            string type = value.GetType().Name;
                        
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                child,
                childIndex,
                name,
                type);
        }        
                
        /// <summary>
        /// Shows an event in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, EventFieldList value, int fieldIndex)
        {        
            // ignore children that are not elements.
            object field = value.EventFields[fieldIndex].Value;

            if (field == null)
            {
                return;
            }
            
            // get the name of the element.
            string name = null;

            if (m_monitoredItem != null)
            {                
                name = m_monitoredItem.GetFieldName(fieldIndex);
            }
            
            // get the type name.
            string type = value.GetType().Name;
                        
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                field,
                fieldIndex,
                name,
                type);
        }        
        
        /// <summary>
        /// Shows a byte array in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, byte[] value, int blockStart)
        {           
            // get the name of the element.
            string name = Utils.Format("[{0:X4}]", blockStart);
                      
            int bytesLeft = value.Length - blockStart;
            
            if (bytesLeft > 16)
            {
                bytesLeft = 16;
            }

            // get the element value.
            byte[] blockValue = new byte[bytesLeft];
            Array.Copy(value, blockStart, blockValue, 0, bytesLeft);
            
            // get the type name.
            string type = value.GetType().Name;
                        
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                blockValue,
                blockStart,
                name,
                type);
        }
        
        /// <summary>
        /// Shows a data value in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, DataValue value, int component)
        {      
            string name = null;
            object componentValue = null;

            switch (component)
            {
                case 0:
                {
                    name = "Value";
                    componentValue = value.Value;

                    ExtensionObject extension = componentValue as ExtensionObject;
                    
                    if (extension != null)
                    {
                        componentValue = extension.Body;
                    }

                    break;
                }

                case 1:
                {
                    name = "StatusCode";
                    componentValue = value.StatusCode;
                    break;
                }

                case 2:
                {
                    if (value.SourceTimestamp != DateTime.MinValue)
                    {
                        name = "SourceTimestamp";
                        componentValue = value.SourceTimestamp;
                    }

                    break;
                }

                case 3:
                {
                    if (value.ServerTimestamp != DateTime.MinValue)
                    {
                        name = "ServerTimestamp";
                        componentValue = value.ServerTimestamp;
                    }

                    break;
                }
            }

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                component,
                name,
                type);
        }

        /// <summary>
        /// Shows a node id in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, NodeId value, int component)
        {      
            string name = null;
            object componentValue = null;

            switch (component)
            {
                case 0:
                {
                    name = "IdType";
                    componentValue = value.IdType;
                    break;
                }

                case 1:
                {
                    name = "Identifier";
                    componentValue = value.Identifier;
                    break;
                }

                case 2:
                {
                    name = "NamespaceIndex";
                    componentValue = value.NamespaceIndex;
                    break;
                }
            }

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                component,
                name,
                type);
        }
        
        /// <summary>
        /// Shows am expanded node id in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, ExpandedNodeId value, int component)
        {      
            string name = null;
            object componentValue = null;

            switch (component)
            {
                case 0:
                {
                    name = "IdType";
                    componentValue = value.IdType;
                    break;
                }

                case 1:
                {
                    name = "Identifier";
                    componentValue = value.Identifier;
                    break;
                }

                case 2:
                {
                    name = "NamespaceIndex";
                    componentValue = value.NamespaceIndex;
                    break;
                }

                case 3:
                {
                    name = "NamespaceUri";
                    componentValue = value.NamespaceUri;
                    break;
                }
            }

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                component,
                name,
                type);
        }
        
        /// <summary>
        /// Shows qualified name in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, QualifiedName value, int component)
        {      
            string name = null;
            object componentValue = null;

            switch (component)
            {
                case 0:
                {
                    name = "Name";
                    componentValue = value.Name;
                    break;
                }

                case 1:
                {
                    name = "NamespaceIndex";
                    componentValue = value.NamespaceIndex;
                    break;
                }
            }

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                component,
                name,
                type);
        }
        
        /// <summary>
        /// Shows localized text in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, LocalizedText value, int component)
        {      
            string name = null;
            object componentValue = null;

            switch (component)
            {
                case 0:
                {
                    name = "Text";
                    componentValue = value.Text;
                    break;
                }

                case 1:
                {
                    name = "Locale";
                    componentValue = value.Locale;
                    break;
                }
            }

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                component,
                name,
                type);
        }
        
        /// <summary>
        /// Shows a string in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, string value)
        {      
            string name = "Value";
            object componentValue = value;

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                0,
                name,
                type);
        }

        /// <summary>
        /// Shows a value in control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, object value)
        {
            if (value == null)
            {
                return;
            }

            // show monitored items.
            MonitoredItem monitoredItem = value as MonitoredItem;

            if (monitoredItem != null)
            {
                m_monitoredItem = monitoredItem;
                ShowValue(ref index, ref overwrite, monitoredItem.LastValue);
                return;
            }            
            
            // show data changes
            MonitoredItemNotification datachange = value as MonitoredItemNotification;

            if (datachange != null)
            {
                ShowValue(ref index, ref overwrite, datachange.Value);
                return;
            }

            // show write value with IndexRange
            WriteValue writevalue = value as WriteValue;

            if (writevalue != null)
            {
                // check if the value is an array
                Array arrayvalue = writevalue.Value.Value as Array;

                if (arrayvalue != null)
                {
                    NumericRange indexRange;
                    ServiceResult result = NumericRange.Validate(writevalue.IndexRange, out indexRange);

                    if (ServiceResult.IsGood(result) && indexRange != NumericRange.Empty)
                    {
                        for (int ii = 0; ii < arrayvalue.Length; ii++)
                        {
                            bool enabled = ((indexRange.Begin <= ii && indexRange.End >= ii) ||
                                            (indexRange.End < 0 && indexRange.Begin == ii));

                            ShowValue(ref index, ref overwrite, arrayvalue, ii, enabled);
                        }

                        return;
                    }
                }
            }

            // show events
            EventFieldList eventFields = value as EventFieldList;

            if (eventFields != null)
            {                
                for (int ii = 0; ii < eventFields.EventFields.Count; ii++)
                {
                    ShowValue(ref index, ref overwrite, eventFields, ii);
                }

                return;
            }

            // show extension bodies.
            ExtensionObject extension = value as ExtensionObject;

            if (extension != null)
            {
                ShowValue(ref index, ref overwrite, extension.Body);
                return;
            }

            // show encodeables.
            IEncodeable encodeable = value as IEncodeable;

            if (encodeable != null)
            {
                PropertyInfo[] properties = encodeable.GetType().GetProperties();

                foreach (PropertyInfo property in properties)
                {
                    ShowValue(ref index, ref overwrite, encodeable, property);
                }

                return;
            }
                        
            // show bytes.
            byte[] bytes = value as byte[];

            if (bytes != null)
            {
                if (!PromptOnLongList(bytes.Length/16))
                {
                    return;
                }

                for (int ii = 0; ii < bytes.Length; ii+=16)
                {
                    ShowValue(ref index, ref overwrite, bytes, ii);
                }
                
                return;
            }

            // show arrays
            Array array = value as Array;

            if (array == null)
            {
                Matrix matrix = value as Matrix;
                
                if (matrix != null)
                {
                    array = matrix.ToArray();
                }
            }

            if (array != null)
            {
                if (!PromptOnLongList(array.GetLength(0)))
                {
                    return;
                }

                for (int ii = 0; ii < array.GetLength(0); ii++)
                {
                    ShowValue(ref index, ref overwrite, array, ii);
                }

                return;
            }

            // show lists
            IList list = value as IList;

            if (list != null)
            {
                if (!PromptOnLongList(list.Count))
                {
                    return;
                }

                for (int ii = 0; ii < list.Count; ii++)
                {
                    ShowValue(ref index, ref overwrite, list, ii);
                }

                return;
            }
            
            // show xml elements
            XmlElement xml = value as XmlElement;
            
            if (xml != null)
            {
                if (!PromptOnLongList(xml.ChildNodes.Count))
                {
                    return;
                }

                for (int ii = 0; ii < xml.ChildNodes.Count; ii++)
                {
                    ShowValue(ref index, ref overwrite, xml, ii);
                }

                return;
            }
            
            // show data value.
            DataValue datavalue = value as DataValue;

            if (datavalue != null)
            {
                ShowValue(ref index, ref overwrite, datavalue, 0);
                ShowValue(ref index, ref overwrite, datavalue, 1);
                ShowValue(ref index, ref overwrite, datavalue, 2);
                ShowValue(ref index, ref overwrite, datavalue, 3);
                return;
            }

            // show node id value.
            NodeId nodeId = value as NodeId;

            if (nodeId != null)
            {
                ShowValue(ref index, ref overwrite, nodeId, 0);
                ShowValue(ref index, ref overwrite, nodeId, 1);
                ShowValue(ref index, ref overwrite, nodeId, 2);
                return;
            }

            // show expanded node id value.
            ExpandedNodeId expandedNodeId = value as ExpandedNodeId;

            if (expandedNodeId != null)
            {
                ShowValue(ref index, ref overwrite, expandedNodeId, 0);
                ShowValue(ref index, ref overwrite, expandedNodeId, 1);
                ShowValue(ref index, ref overwrite, expandedNodeId, 2);
                ShowValue(ref index, ref overwrite, expandedNodeId, 3);
                return;
            }            

            // show qualified name value.
            QualifiedName qualifiedName = value as QualifiedName;

            if (qualifiedName != null)
            {
                ShowValue(ref index, ref overwrite, qualifiedName, 0);
                ShowValue(ref index, ref overwrite, qualifiedName, 1);
                return;
            }

            // show qualified name value.
            LocalizedText localizedText = value as LocalizedText;

            if (localizedText != null)
            {
                ShowValue(ref index, ref overwrite, localizedText, 0);
                ShowValue(ref index, ref overwrite, localizedText, 1);
                return;
            }
            
            // show variant.
            Variant? variant = value as Variant?;

            if (variant != null)
            {
                ShowValue(ref index, ref overwrite, variant.Value.Value);
                return;
            }

            // show unknown types as strings.
            ShowValue(ref index, ref overwrite, String.Format("{0}", value));
        }

        private void ItemsLV_MouseClick(object sender, MouseEventArgs e)
        {
            try
            {                
                if (e.Button != MouseButtons.Left)
                {
                    return;
                }
                
                ListViewItem listItem = ItemsLV.GetItemAt(e.X, e.Y);

                if (listItem == null)
                {
                    return;
                }

                ValueState state = listItem.Tag as ValueState;
                
                if (state == null || !state.Expandable)
                {
                    return;
                }
                
                if (state.Expanded)
                {
                    HideChildren(listItem);
                }
                else
                {
                    ShowChildren(listItem);
                }
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }
		#endregion
        
        #region Event Handlers
        private void UpdatesMI_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                /*
                if (m_monitoredItem != null)
                {
                    if (UpdatesMI.Checked)
                    {
                        m_monitoredItem.Notification += m_MonitoredItemNotification;
                    }
                    else
                    {
                        m_monitoredItem.Notification -= m_MonitoredItemNotification;
                    }
                }
                */
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private void RefreshMI_Click(object sender, EventArgs e)
        {
            try
            {
                /*
                Clear();
                ShowValue(m_monitoredItem);
                */
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private void ClearMI_Click(object sender, EventArgs e)
        {
            try
            {
                Clear();
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private void EditMI_Click(object sender, EventArgs e)
        {
            try
            {
                if (ItemsLV.SelectedItems.Count != 1)
                {
                    return;
                }

                ValueState state = ItemsLV.SelectedItems[0].Tag as ValueState;

                if (!IsEditableType(state.Component))
                {
                    return;
                }

                object value = null;
                if (state.Component is LocalizedText)
                {
                    value = new StringValueEditDlg().ShowDialog(state.Component.ToString());
                    if (value != null)
                    {
                        value = new LocalizedText(((LocalizedText)state.Component).Key, ((LocalizedText)state.Component).Locale, value.ToString());
                    }
                }
                else
                {
                    value = new SimpleValueEditDlg().ShowDialog(state.Component, state.Component.GetType());
                }

                if (value == null)
                {
                    return;
                }

                if (state.Value is IEncodeable)
                {
                    PropertyInfo property = (PropertyInfo)state.ComponentId;
                    
                    MethodInfo[] accessors = property.GetAccessors();

                    for (int ii = 0; ii < accessors.Length; ii++)
                    {
                        if (accessors[ii].ReturnType == typeof(void))
                        {
                            accessors[ii].Invoke(state.Value, new object[] { value });
                            state.Component = value;
                            break;
                        }
                    }
                }
                
                DataValue datavalue = state.Value as DataValue;

                if (datavalue != null)
                {
                    int component = (int)state.ComponentId;

                    switch (component)
                    {
                        case 0: { datavalue.Value = value; break; }
                    }
                }

                if (state.Value is IList)
                {
                    int ii = (int)state.ComponentId;
                    ((IList)state.Value)[ii] = value;
                    state.Component = value;
                }

                m_expanding = false;
                int index = (int)state.ComponentIndex - 1;
                int indentCount = ItemsLV.Items[index].IndentCount;

                while (index > 0 && ItemsLV.Items[index - 1].IndentCount == indentCount)
                {
                    --index;
                }

                bool overwrite = true;
                ShowValue(ref index, ref overwrite, state.Value);                
            }
            catch (Exception exception)
            {
                GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private void PopupMenu_Opening(object sender, CancelEventArgs e)
        {
            try
            {
                EditMI.Enabled = false;

                if (ItemsLV.SelectedItems.Count != 1)
                {
                    return;
                }

                EditMI.Enabled = (ItemsLV.SelectedItems[0].ForeColor != Color.LightGray);
            }
            catch (Exception exception)
            {
                GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using System.Reflection;
using System.Runtime.Serialization;
using System.Xml;
using System.Xml.Serialization;

using Opc.Ua.Client;
using Opc.Ua.Client.Controls;

namespace Opc.Ua.Client.Controls
{
    /// <summary>
    /// Displays a hierarchical view of a complex value.
    /// </summary>
    public partial class DataListCtrl : Opc.Ua.Client.Controls.BaseListCtrl
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DataListCtrl"/> class.
        /// </summary>
        public DataListCtrl()
        {
            InitializeComponent();                        
			SetColumns(m_ColumnNames);
        }

        #region Private Fields
        /// <summary>
		/// The columns to display in the control.
		/// </summary>
		private readonly object[][] m_ColumnNames = new object[][]
		{
			new object[] { "Name",  HorizontalAlignment.Left, null },  
			new object[] { "Value", HorizontalAlignment.Left, null, 250 }, 
			new object[] { "Type",  HorizontalAlignment.Left, null } 
		};

        private bool m_latestValue = true;
        private bool m_expanding;
        private int m_depth;
        private Font m_defaultFont;
        private MonitoredItem m_monitoredItem;

        private const string UnknownType  = "(unknown)";
        private const string NullValue    = "(null)";
        private const string ExpandIcon   = "ExpandPlus";
        private const string CollapseIcon = "ExpandMinus";
		#endregion

        #region Public Interface
        /// <summary>
        /// Whether to update the control when the value changes.
        /// </summary>
        public bool AutoUpdate
        {
            get { return UpdatesMI.Checked;  }
            set { UpdatesMI.Checked = value; }
        }

        /// <summary>
        /// Whether to only display the latest value for a monitored item.
        /// </summary>
        public bool LatestValue
        {
            get { return m_latestValue;  }
            set { m_latestValue = value; }
        }
        
        /// <summary>
        /// The monitored item associated with the value.
        /// </summary>
        public MonitoredItem MonitoredItem
        {
            get { return m_monitoredItem;  }
            set { m_monitoredItem = value; }
        }

        /// <summary>
        /// Clears the contents of the control,
        /// </summary>
        public void Clear()
        {
            ItemsLV.Items.Clear();
            AdjustColumns();
        }
        
        /// <summary>
        /// Displays a value in the control.
        /// </summary>
        public void ShowValue(object value)
        {
            ShowValue(value, false);
        }

        /// <summary>
        /// Displays a value in the control.
        /// </summary>
        public void ShowValue(object value, bool overwrite)
        {
            if (!overwrite)
            {
                Clear();
            }

            if (value is byte[])
            {
                m_defaultFont = new Font("Courier New", 8.25F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0)));
            }
            else
            {            
                m_defaultFont = ItemsLV.Font;
            }

            m_expanding = false;
            m_depth = 0;
                        
            // show the value.
            int index = 0;
            ShowValue(ref index, ref overwrite, value);

            // adjust columns.
            AdjustColumns();
        }
		#endregion
        
        #region Overridden Methods
        /// <summary>
        /// Enables the menu items.
        /// </summary>
        protected override void EnableMenuItems(ListViewItem clickedItem)
        {
            RefreshMI.Enabled = true;
            ClearMI.Enabled   = true;

            if (ItemsLV.SelectedItems.Count == 1)
            {
                ValueState state = ItemsLV.SelectedItems[0].Tag as ValueState;
                EditMI.Enabled = IsEditableType(state.Component);
            }
        }
		#endregion
        
        #region ValueState Class
        /// <summary>
        /// Stores the state associated with an item.
        /// </summary>
        private class ValueState
        {
            public bool Expanded = false;
            public bool Expandable = false;
            public object Value = null;
            public object Component = null;
            public object ComponentId = null;
            public object ComponentIndex = null;
        }
		#endregion

        #region Private Members
        /// <summary>
        /// Returns true is the value is an editable type.
        /// </summary>
        private bool IsEditableType(object value)
        {
            if (value is bool)       return true;
            if (value is sbyte)      return true;
            if (value is byte)       return true;
            if (value is short)      return true;
            if (value is ushort)     return true;
            if (value is int)        return true;
            if (value is uint)       return true;
            if (value is long)       return true;
            if (value is ulong)      return true;
            if (value is float)      return true;
            if (value is double)     return true;
            if (value is string)     return true;
            if (value is DateTime)   return true;
            if (value is Guid)       return true;
            if (value is LocalizedText) return true;

            return false;
        }

        /// <summary>
        /// Shows the components of a value in the control.
        /// </summary>        
        private void ShowChildren(ListViewItem listItem)
        {            
            ValueState state = listItem.Tag as ValueState;

            if (state == null || !state.Expandable || state.Expanded)
            {
                return;
            }

            m_expanding = true;
            m_depth = listItem.IndentCount+1;
            
            state.Expanded = true;
            listItem.ImageKey = CollapseIcon;

            int index = listItem.Index+1;
            bool overwrite = false;

            ShowValue(ref index, ref overwrite, state.Component);

            AdjustColumns();
        }
        
        /// <summary>
        /// Hides the components of a value in the control.
        /// </summary>  
        private void HideChildren(ListViewItem listItem)
        {
            ValueState state = listItem.Tag as ValueState;

            if (state == null || !state.Expandable || !state.Expanded)
            {
                return;
            }

            for (int ii = listItem.Index+1; ii < ItemsLV.Items.Count;)
            {
                ListViewItem childItem = ItemsLV.Items[ii];
                
                if (childItem.IndentCount <= listItem.IndentCount)
                {
                    break;
                }

                childItem.Remove();
            }

            state.Expanded = false;
            listItem.ImageKey = ExpandIcon;
        }

        /// <summary>
        /// Returns the list item at the specified index.
        /// </summary>
        private ListViewItem GetListItem(int index, ref bool overwrite, string name, string type)
        {
            ListViewItem listitem = null;
            
            // switch to detail view as soon as an item is added.
            if (ItemsLV.View == View.List)
            {
                ItemsLV.Items.Clear();                
                ItemsLV.View = View.Details;
            }

            // check if there is an item that could be re-used.
            if (!m_expanding && index < ItemsLV.Items.Count)
            {                
                listitem = ItemsLV.Items[index];

                // check if still possible to overwrite values.
                if (overwrite)
                {
                    if (listitem.SubItems[0].Text != name || listitem.SubItems[2].Text != type)
                    {
                        overwrite = false;
                    }
                }
                
                listitem.SubItems[0].Text = name;
                listitem.SubItems[2].Text = type;

                return listitem;
            }
            
            overwrite = false;

            listitem = new ListViewItem(name);

            listitem.SubItems.Add(String.Empty);
            listitem.SubItems.Add(type);
            
            listitem.Font        = m_defaultFont;
            listitem.ImageKey    = ExpandIcon;
            listitem.IndentCount = m_depth;
            listitem.Tag         = new ValueState();

            if (!m_expanding)
            {
                ItemsLV.Items.Add(listitem);
            }
            else
            {
                ItemsLV.Items.Insert(index, listitem);
            }
                
            return listitem;
        }
        
        /// <summary>
        /// Returns true if the type can be expanded.
        /// </summary>
        private bool IsExpandableType(object value)
        {
            // check for null.
            if (value == null)
            {
                return false;
            }

            // check for Variant.
            if (value is Variant variant)
            {
                return IsExpandableType(variant.Value);
            }

            // check for bytes.

            if (value is byte[] bytes)
            {
                return false;
            }           

            // check for xml element.

            if (value is XmlElement xml)
            {
                if (xml.ChildNodes.Count == 1 && xml.ChildNodes[0] is XmlText)
                {
                    return false;
                }

                return xml.HasChildNodes;
            }           
            // check for array.

            if (array == null)
            {
                if (value is Matrix matrix)
                {
                    array = matrix.ToArray();
                }
            }

            if (value is Array array)
            {
                return array.Length > 0;
            }           

            // check for list.

            if (value is IList list)
            {
                return list.Count > 0;
            }

            // check for encodeable object.

            if (value is IEncodeable encodeable)
            {
                return true;
            }

            // check for extension object.
            
            if (value is ExtensionObject extension)
            {
                return IsExpandableType(extension.Body);
            }

            // check for data value.
            
            if (value is DataValue datavalue)
            {
                return true;
            }

            // check for event value.
            
            if (value is EventFieldList eventFields)
            {
                return true;
            }

            // must be a simple value.
            return false;
        }

        /// <summary>
        /// Formats a value for display in the control.
        /// </summary>
        private string GetValueText(object value)
        {
            // check for null.
            if (value == null)
            {
                return "(null)";
            }

            // format bytes.

            if (value is byte[] bytes)
            {
                StringBuilder buffer = new StringBuilder();

                for (int ii = 0; ii < bytes.Length; ii++)
                {
                    if (ii != 0 && ii%16 == 0)
                    {
                        buffer.Append(" ");
                    }

                    buffer.AppendFormat("{0:X2} ", bytes[ii]);
                }

                return buffer.ToString();
            }           

            // format xml element.

            if (value is XmlElement xml)
            {
                // return the entire element if not expandable.
                if (!IsExpandableType(xml))
                {
                    return xml.OuterXml;
                }
                
                // show only the start tag.
                string text = xml.OuterXml;

                int index = text.IndexOf('>');

                if (index != -1)
                {
                    text = text.Substring(0, index);
                }
                
                return text;
            }           

            // format array.

            if (value is Array array)
            {
                if (array.Rank > 1)
                {
                    int[] lenghts = new int[array.Rank];

                    for (int i = 0; i < array.Rank; ++i)
                    {
                        lenghts[i] = array.GetLength(i);
                    }

                    return Utils.Format("{1}[{0}]", string.Join(",", lenghts), value.GetType().GetElementType().Name);
                }
                else
                {
                    return Utils.Format("{1}[{0}]", array.Length, value.GetType().GetElementType().Name);
                }
            }

            // format list.

            if (value is IList list)
            {
                string type = value.GetType().Name;

                if (type.EndsWith("Collection"))
                {
                    type = type.Substring(0, type.Length - "Collection".Length);
                }
                else
                {
                    type = "Object";
                }

                return Utils.Format("{1}[{0}]", list.Count, type);
            }

            // format encodeable object.

            if (value is IEncodeable encodeable)
            {
                return encodeable.GetType().Name;
            }

            // format extension object.
            
            if (value is ExtensionObject extension)
            {
                return GetValueText(extension.Body);
            }

            // check for event value.
            
            if (value is EventFieldList eventFields)
            {
                if (m_monitoredItem != null)
                {
                    return String.Format("{0}", m_monitoredItem.GetEventType(eventFields));
                }

                return eventFields.GetType().Name;
            }

            // check for data value.
            
            if (value is DataValue dataValue)
            {
                StringBuilder formattedValue = new StringBuilder();

                if (!StatusCode.IsGood(dataValue.StatusCode))
                {
                    formattedValue.Append("[");
                    formattedValue.AppendFormat("Q:{0}", dataValue.StatusCode);
                }

                DateTime now = DateTime.UtcNow;

                if ((value is DataValue dataValue) &&
                    ((dataValue.ServerTimestamp > now) || (dataValue.SourceTimestamp > now)))
                {
                    if (formattedValue.ToString().Length > 0)
                    {
                        formattedValue.Append(", ");
                    }
                    else
                    {
                        formattedValue.Append("[");
                    }

                    formattedValue.Append("T:future");
                }

                if (formattedValue.ToString().Length > 0)
                {
                    formattedValue.Append("] ");
                }

                formattedValue.AppendFormat("{0}", dataValue.Value);
                return formattedValue.ToString();
            }
            
            // use default formatting.
            return Utils.Format("{0}", value);
        }

        /// <summary>
        /// Updates the list with the specified value.
        /// </summary>
        private void UpdateList(
            ref int  index, 
            ref bool overwrite,
            object   value,
            object   componentValue,
            object   componentId,
            string   name,
            string   type)
        {
            // get the list item to update.
            ListViewItem listitem = GetListItem(index, ref overwrite, name, type);
            if (componentValue is StatusCode)
            {
                listitem.SubItems[1].Text = componentValue.ToString();
            }
            else
            {
                // update list item.
                listitem.SubItems[1].Text = GetValueText(componentValue);
            }            

            // move to next item.
            index++;

            ValueState state = listitem.Tag as ValueState;
            
            // recursively update sub-values if item is expanded.
            if (overwrite)
            {
                if (state.Expanded && state.Expandable)
                {
                    m_depth++;
                    ShowValue(ref index, ref overwrite, componentValue);
                    m_depth--;
                }
            }

            // update state.
            state.Expandable     = IsExpandableType(componentValue);
            state.Value          = value;
            state.Component      = componentValue;
            state.ComponentId    = componentId;
            state.ComponentIndex = index;

            if (!state.Expandable)
            {
                listitem.ImageKey = CollapseIcon;
            }
        }

        /// <summary>
        /// Updates the list with the specified value.
        /// </summary>
        private void UpdateList(
            ref int index,
            ref bool overwrite,
            object value,
            object componentValue,
            object componentId,
            string name,
            string type,
            bool enabled)
        {
            // get the list item to update.
            ListViewItem listitem = GetListItem(index, ref overwrite, name, type);

            if (!enabled)
            {
                listitem.ForeColor = Color.LightGray;
            }

            // update list item.
            listitem.SubItems[1].Text = GetValueText(componentValue);

            // move to next item.
            index++;

            ValueState state = listitem.Tag as ValueState;

            // recursively update sub-values if item is expanded.
            if (overwrite)
            {
                if (state.Expanded && state.Expandable)
                {
                    m_depth++;
                    ShowValue(ref index, ref overwrite, componentValue);
                    m_depth--;
                }
            }

            // update state.
            state.Expandable = IsExpandableType(componentValue);
            state.Value = value;
            state.Component = componentValue;
            state.ComponentId = componentId;
            state.ComponentIndex = index;

            if (!state.Expandable)
            {
                listitem.ImageKey = CollapseIcon;
            }
        }
        /// <summary>
        /// Shows property of an encodeable object in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, IEncodeable value, PropertyInfo property)
        {            
            // get the name of the property.
            string name = Utils.GetDataMemberName(property);

            if (name == null)
            {
                return;
            }
            
            // get the property value.
            object propertyValue = null;

            MethodInfo[] accessors = property.GetAccessors();

            for (int ii = 0; ii < accessors.Length; ii++)
            {
                if (accessors[ii].ReturnType == property.PropertyType)
                {
                    propertyValue = accessors[ii].Invoke(value, null);
                    break;
                }
            }
           
            if (propertyValue is Variant variant)
            {
                propertyValue = variant.Value;
            }
            
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                propertyValue,
                property,
                name,
                property.PropertyType.Name);
        }
        
        /// <summary>
        /// Shows the element of an array in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, Array value, int element)
        {            
            // get the name of the element.
            string name = Utils.Format("[{0}]", element);
                      
            // get the element value.
            object elementValue = null;

            if (value.Rank > 1)
            {
                int[] smallArrayDimmensions = new int[value.Rank - 1];
                int length = 1;

                for (int i = 0; i < value.Rank - 1; ++i)
                {
                    smallArrayDimmensions[i] = value.GetLength(i + 1);
                    length *= smallArrayDimmensions[i];
                }

                Array flatArray = Utils.FlattenArray(value);
                Array flatSmallArray = Array.CreateInstance(value.GetType().GetElementType(), length);
                Array.Copy(flatArray, element * value.GetLength(1), flatSmallArray, 0, length);
                Array smallArray = Array.CreateInstance(value.GetType().GetElementType(), smallArrayDimmensions);
                int[] indexes = new int[smallArrayDimmensions.Length];

                for (int ii = 0; ii < flatSmallArray.Length; ii++)
                {
                    smallArray.SetValue(flatSmallArray.GetValue(ii), indexes);

                    for (int jj = indexes.Length - 1; jj >= 0; jj--)
                    {
                        indexes[jj]++;

                        if (indexes[jj] < smallArrayDimmensions[jj])
                        {
                            break;
                        }

                        indexes[jj] = 0;
                    }
                }

                elementValue = smallArray;
            }
            else
            {
                elementValue = value.GetValue(element);
            }
            
            // get the type name.
            string type = null;

            if (elementValue != null)
            {
                type = elementValue.GetType().Name;
            }
            
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                elementValue,
                element,
                name,
                type);
        }

        /// <summary>
        /// Shows the element of an array in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, Array value, int element, bool enabled)
        {
            // get the name of the element.
            string name = Utils.Format("[{0}]", element);

            // get the element value.
            object elementValue = value.GetValue(element);

            // get the type name.
            string type = null;

            if (elementValue != null)
            {
                type = elementValue.GetType().Name;
            }

            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                elementValue,
                element,
                name,
                type,
                enabled);
        }

        /// <summary>
        /// Asks for confirmation before expanding a long list.
        /// </summary>
        private bool PromptOnLongList(int length)
        {            
            if (length < 256)
            {
                return true;
            }
                
            DialogResult result = MessageBox.Show("It may take a long time to display the list are you sure you want to continue?", "Warning", MessageBoxButtons.YesNo);

            if (result == DialogResult.Yes)
            {
                return true;
            }
                
            return false;
        }

        /// <summary>
        /// Shows the element of a list in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, IList value, int element)
        {            
            // get the name of the element.
            string name = Utils.Format("[{0}]", element);
                      
            // get the element value.
            object elementValue = value[element];
            
            // get the type name.
            string type = null;

            if (elementValue != null)
            {
                type = elementValue.GetType().Name;
            }
                        
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                elementValue,
                element,
                name,
                type);
        }
        
        /// <summary>
        /// Shows an XML element in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, XmlElement value, int childIndex)
        {        
            // ignore children that are not elements.
            XmlElement child = value.ChildNodes[childIndex] as XmlElement;

            if (child == null)
            {
                return;
            }
            
            // get the name of the element.
            string name = Utils.Format("{0}", child.Name);
            
            // get the type name.
            string type = value.GetType().Name;
                        
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                child,
                childIndex,
                name,
                type);
        }        
                
        /// <summary>
        /// Shows an event in the control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, EventFieldList value, int fieldIndex)
        {        
            // ignore children that are not elements.
            object field = value.EventFields[fieldIndex].Value;

            if (field == null)
            {
                return;
            }
            
            // get the name of the element.
            string name = null;

            if (m_monitoredItem != null)
            {                
                name = m_monitoredItem.GetFieldName(fieldIndex);
            }
            
            // get the type name.
            string type = value.GetType().Name;
                        
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                field,
                fieldIndex,
                name,
                type);
        }        
        
        /// <summary>
        /// Shows a byte array in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, byte[] value, int blockStart)
        {           
            // get the name of the element.
            string name = Utils.Format("[{0:X4}]", blockStart);
                      
            int bytesLeft = value.Length - blockStart;
            
            if (bytesLeft > 16)
            {
                bytesLeft = 16;
            }

            // get the element value.
            byte[] blockValue = new byte[bytesLeft];
            Array.Copy(value, blockStart, blockValue, 0, bytesLeft);
            
            // get the type name.
            string type = value.GetType().Name;
                        
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                blockValue,
                blockStart,
                name,
                type);
        }
        
        /// <summary>
        /// Shows a data value in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, DataValue value, int component)
        {      
            string name = null;
            object componentValue = null;

            switch (component)
            {
                case 0:
                {
                    name = "Value";
                    componentValue = value.Value;

                    
                    if (componentValue is ExtensionObject extension)
                    {
                        componentValue = extension.Body;
                    }

                    break;
                }

                case 1:
                {
                    name = "StatusCode";
                    componentValue = value.StatusCode;
                    break;
                }

                case 2:
                {
                    if (value.SourceTimestamp != DateTime.MinValue)
                    {
                        name = "SourceTimestamp";
                        componentValue = value.SourceTimestamp;
                    }

                    break;
                }

                case 3:
                {
                    if (value.ServerTimestamp != DateTime.MinValue)
                    {
                        name = "ServerTimestamp";
                        componentValue = value.ServerTimestamp;
                    }

                    break;
                }
            }

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                component,
                name,
                type);
        }

        /// <summary>
        /// Shows a node id in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, NodeId value, int component)
        {      
            string name = null;
            object componentValue = null;

            switch (component)
            {
                case 0:
                {
                    name = "IdType";
                    componentValue = value.IdType;
                    break;
                }

                case 1:
                {
                    name = "Identifier";
                    componentValue = value.Identifier;
                    break;
                }

                case 2:
                {
                    name = "NamespaceIndex";
                    componentValue = value.NamespaceIndex;
                    break;
                }
            }

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                component,
                name,
                type);
        }
        
        /// <summary>
        /// Shows am expanded node id in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, ExpandedNodeId value, int component)
        {      
            string name = null;
            object componentValue = null;

            switch (component)
            {
                case 0:
                {
                    name = "IdType";
                    componentValue = value.IdType;
                    break;
                }

                case 1:
                {
                    name = "Identifier";
                    componentValue = value.Identifier;
                    break;
                }

                case 2:
                {
                    name = "NamespaceIndex";
                    componentValue = value.NamespaceIndex;
                    break;
                }

                case 3:
                {
                    name = "NamespaceUri";
                    componentValue = value.NamespaceUri;
                    break;
                }
            }

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                component,
                name,
                type);
        }
        
        /// <summary>
        /// Shows qualified name in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, QualifiedName value, int component)
        {      
            string name = null;
            object componentValue = null;

            switch (component)
            {
                case 0:
                {
                    name = "Name";
                    componentValue = value.Name;
                    break;
                }

                case 1:
                {
                    name = "NamespaceIndex";
                    componentValue = value.NamespaceIndex;
                    break;
                }
            }

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                component,
                name,
                type);
        }
        
        /// <summary>
        /// Shows localized text in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, LocalizedText value, int component)
        {      
            string name = null;
            object componentValue = null;

            switch (component)
            {
                case 0:
                {
                    name = "Text";
                    componentValue = value.Text;
                    break;
                }

                case 1:
                {
                    name = "Locale";
                    componentValue = value.Locale;
                    break;
                }
            }

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                component,
                name,
                type);
        }
        
        /// <summary>
        /// Shows a string in the control. 
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, string value)
        {      
            string name = "Value";
            object componentValue = value;

            // don't display empty components.
            if (name == null)
            {
                return;
            }

            // get the type name.
            string type = "(unknown)";

            if (componentValue != null)
            {
                type = componentValue.GetType().Name;
            }
           
            // update the list view.
            UpdateList(
                ref index,
                ref overwrite,
                value,
                componentValue,
                0,
                name,
                type);
        }

        /// <summary>
        /// Shows a value in control.
        /// </summary>
        private void ShowValue(ref int index, ref bool overwrite, object value)
        {
            if (value == null)
            {
                return;
            }

            // show monitored items.

            if (value is MonitoredItem monitoredItem)
            {
                m_monitoredItem = monitoredItem;
                ShowValue(ref index, ref overwrite, monitoredItem.LastValue);
                return;
            }            

            // show data changes

            if (value is MonitoredItemNotification datachange)
            {
                ShowValue(ref index, ref overwrite, datachange.Value);
                return;
            }

            // show write value with IndexRange

            if (value is WriteValue writevalue)
            {
                // check if the value is an array

                if (writevalue.Value.Value is Array arrayvalue)
                {
                    NumericRange indexRange;
                    ServiceResult result = NumericRange.Validate(writevalue.IndexRange, out indexRange);

                    if (ServiceResult.IsGood(result) && indexRange != NumericRange.Empty)
                    {
                        for (int ii = 0; ii < arrayvalue.Length; ii++)
                        {
                            bool enabled = ((indexRange.Begin <= ii && indexRange.End >= ii) ||
                                            (indexRange.End < 0 && indexRange.Begin == ii));

                            ShowValue(ref index, ref overwrite, arrayvalue, ii, enabled);
                        }

                        return;
                    }
                }
            }

            // show events

            if (value is EventFieldList eventFields)
            {                
                for (int ii = 0; ii < eventFields.EventFields.Count; ii++)
                {
                    ShowValue(ref index, ref overwrite, eventFields, ii);
                }

                return;
            }

            // show extension bodies.

            if (value is ExtensionObject extension)
            {
                ShowValue(ref index, ref overwrite, extension.Body);
                return;
            }

            // show encodeables.

            if (value is IEncodeable encodeable)
            {
                PropertyInfo[] properties = encodeable.GetType().GetProperties();

                foreach (PropertyInfo property in properties)
                {
                    ShowValue(ref index, ref overwrite, encodeable, property);
                }

                return;
            }

            // show bytes.

            if (value is byte[] bytes)
            {
                if (!PromptOnLongList(bytes.Length/16))
                {
                    return;
                }

                for (int ii = 0; ii < bytes.Length; ii+=16)
                {
                    ShowValue(ref index, ref overwrite, bytes, ii);
                }
                
                return;
            }
            // show arrays

            if (array == null)
            {
                if (value is Matrix matrix)
                {
                    array = matrix.ToArray();
                }
            }

            if (value is Array array)
            {
                if (!PromptOnLongList(array.GetLength(0)))
                {
                    return;
                }

                for (int ii = 0; ii < array.GetLength(0); ii++)
                {
                    ShowValue(ref index, ref overwrite, array, ii);
                }

                return;
            }

            // show lists

            if (value is IList list)
            {
                if (!PromptOnLongList(list.Count))
                {
                    return;
                }

                for (int ii = 0; ii < list.Count; ii++)
                {
                    ShowValue(ref index, ref overwrite, list, ii);
                }

                return;
            }

            // show xml elements
            
            if (value is XmlElement xml)
            {
                if (!PromptOnLongList(xml.ChildNodes.Count))
                {
                    return;
                }

                for (int ii = 0; ii < xml.ChildNodes.Count; ii++)
                {
                    ShowValue(ref index, ref overwrite, xml, ii);
                }

                return;
            }

            // show data value.

            if (value is DataValue datavalue)
            {
                ShowValue(ref index, ref overwrite, datavalue, 0);
                ShowValue(ref index, ref overwrite, datavalue, 1);
                ShowValue(ref index, ref overwrite, datavalue, 2);
                ShowValue(ref index, ref overwrite, datavalue, 3);
                return;
            }

            // show node id value.

            if (value is NodeId nodeId)
            {
                ShowValue(ref index, ref overwrite, nodeId, 0);
                ShowValue(ref index, ref overwrite, nodeId, 1);
                ShowValue(ref index, ref overwrite, nodeId, 2);
                return;
            }

            // show expanded node id value.

            if (value is ExpandedNodeId expandedNodeId)
            {
                ShowValue(ref index, ref overwrite, expandedNodeId, 0);
                ShowValue(ref index, ref overwrite, expandedNodeId, 1);
                ShowValue(ref index, ref overwrite, expandedNodeId, 2);
                ShowValue(ref index, ref overwrite, expandedNodeId, 3);
                return;
            }            

            // show qualified name value.

            if (value is QualifiedName qualifiedName)
            {
                ShowValue(ref index, ref overwrite, qualifiedName, 0);
                ShowValue(ref index, ref overwrite, qualifiedName, 1);
                return;
            }

            // show qualified name value.

            if (value is LocalizedText localizedText)
            {
                ShowValue(ref index, ref overwrite, localizedText, 0);
                ShowValue(ref index, ref overwrite, localizedText, 1);
                return;
            }
            
            // show variant.
            Variant? variant = value as Variant?;

            if (variant != null)
            {
                ShowValue(ref index, ref overwrite, variant.Value.Value);
                return;
            }

            // show unknown types as strings.
            ShowValue(ref index, ref overwrite, String.Format("{0}", value));
        }

        private void ItemsLV_MouseClick(object sender, MouseEventArgs e)
        {
            try
            {                
                if (e.Button != MouseButtons.Left)
                {
                    return;
                }
                
                ListViewItem listItem = ItemsLV.GetItemAt(e.X, e.Y);

                if (listItem == null)
                {
                    return;
                }

                ValueState state = listItem.Tag as ValueState;
                
                if (state == null || !state.Expandable)
                {
                    return;
                }
                
                if (state.Expanded)
                {
                    HideChildren(listItem);
                }
                else
                {
                    ShowChildren(listItem);
                }
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }
		#endregion
        
        #region Event Handlers
        private void UpdatesMI_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                /*
                if (m_monitoredItem != null)
                {
                    if (UpdatesMI.Checked)
                    {
                        m_monitoredItem.Notification += m_MonitoredItemNotification;
                    }
                    else
                    {
                        m_monitoredItem.Notification -= m_MonitoredItemNotification;
                    }
                }
                */
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private void RefreshMI_Click(object sender, EventArgs e)
        {
            try
            {
                /*
                Clear();
                ShowValue(m_monitoredItem);
                */
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private void ClearMI_Click(object sender, EventArgs e)
        {
            try
            {
                Clear();
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private void EditMI_Click(object sender, EventArgs e)
        {
            try
            {
                if (ItemsLV.SelectedItems.Count != 1)
                {
                    return;
                }

                ValueState state = ItemsLV.SelectedItems[0].Tag as ValueState;

                if (!IsEditableType(state.Component))
                {
                    return;
                }

                object value = null;
                if (state.Component is LocalizedText)
                {
                    value = new StringValueEditDlg().ShowDialog(state.Component.ToString());
                    if (value != null)
                    {
                        value = new LocalizedText(((LocalizedText)state.Component).Key, ((LocalizedText)state.Component).Locale, value.ToString());
                    }
                }
                else
                {
                    value = new SimpleValueEditDlg().ShowDialog(state.Component, state.Component.GetType());
                }

                if (value == null)
                {
                    return;
                }

                if (state.Value is IEncodeable)
                {
                    PropertyInfo property = (PropertyInfo)state.ComponentId;
                    
                    MethodInfo[] accessors = property.GetAccessors();

                    for (int ii = 0; ii < accessors.Length; ii++)
                    {
                        if (accessors[ii].ReturnType == typeof(void))
                        {
                            accessors[ii].Invoke(state.Value, new object[] { value });
                            state.Component = value;
                            break;
                        }
                    }
                }

                if (state.Value is DataValue datavalue)
                {
                    int component = (int)state.ComponentId;

                    switch (component)
                    {
                        case 0: { datavalue.Value = value; break; }
                    }
                }

                if (state.Value is IList)
                {
                    int ii = (int)state.ComponentId;
                    ((IList)state.Value)[ii] = value;
                    state.Component = value;
                }

                m_expanding = false;
                int index = (int)state.ComponentIndex - 1;
                int indentCount = ItemsLV.Items[index].IndentCount;

                while (index > 0 && ItemsLV.Items[index - 1].IndentCount == indentCount)
                {
                    --index;
                }

                bool overwrite = true;
                ShowValue(ref index, ref overwrite, state.Value);                
            }
            catch (Exception exception)
            {
                GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private void PopupMenu_Opening(object sender, CancelEventArgs e)
        {
            try
            {
                EditMI.Enabled = false;

                if (ItemsLV.SelectedItems.Count != 1)
                {
                    return;
                }

                EditMI.Enabled = (ItemsLV.SelectedItems[0].ForeColor != Color.LightGray);
            }
            catch (Exception exception)
            {
                GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(41,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(39,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(43,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(34,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(44,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(367,17): error CS0841: Cannot use local variable 'array' before it is declared,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(371,21): error CS0841: Cannot use local variable 'array' before it is declared,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(543,40): error CS0841: Cannot use local variable 'dataValue' before it is declared,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(546,58): error CS0841: Cannot use local variable 'dataValue' before it is declared,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(551,41): error CS0136: A local or parameter named 'dataValue' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(1415,17): error CS0841: Cannot use local variable 'array' before it is declared,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(1419,21): error CS0841: Cannot use local variable 'array' before it is declared,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(44,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(41,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(39,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(32,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(43,1): hidden CS8019: Unnecessary using directive.,D:\a\1\s\Applications\ClientControls.Net4\Configuration\Common (OLD)\DataListCtrl.cs(34,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 36 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificateListCtrl.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Security.Cryptography.X509Certificates;
using System.Reflection;
using System.Xml;
using System.IO;
using System.Runtime.Serialization;
using System.Threading.Tasks;
using Opc.Ua.Security.Certificates;

namespace Opc.Ua.Client.Controls
{
    /// <summary>
    /// Displays a list of certificates.
    /// </summary>
    public partial class CertificateListCtrl : Opc.Ua.Client.Controls.BaseListCtrl
    {
        #region Constructors
        /// <summary>
        /// Constructs the object.
        /// </summary>
        public CertificateListCtrl()
        {
            InitializeComponent();

            SetColumns(m_ColumnNames);
        }
        #endregion
       
        #region Private Fields
		// The columns to display in the control.		
		private readonly object[][] m_ColumnNames = new object[][]
		{ 
			new object[] { "Name",        HorizontalAlignment.Left, null },
			new object[] { "Type",        HorizontalAlignment.Left, null },
			new object[] { "Private Key", HorizontalAlignment.Center, null },
			new object[] { "Domains",     HorizontalAlignment.Left, null },  
			new object[] { "Uri ",        HorizontalAlignment.Left, null },  
			new object[] { "Valid Until", HorizontalAlignment.Left, null }
		};

        private CertificateStoreIdentifier m_storeId;
        private CertificateIdentifierCollection m_certificates;
        private IList<string> m_thumbprints;
        private List<ListViewItem> m_items;
        #endregion

        #region Public Interface
        /// <summary>
        /// The currently selected certificate.
        /// </summary>
        public X509Certificate2 SelectedCertificate
        {
            get
            {
                return SelectedTag as X509Certificate2;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this instance is empty store.
        /// </summary>
        public bool IsEmptyStore
        {
            get
            {
                if (m_items == null || m_items.Count == 0)
                {
                    return true;
                }

                return false;
            }
        }

        /// <summary>
        /// Removes all items in the list.
        /// </summary>
        internal void Clear()
        {
            ItemsLV.Items.Clear();
            Instructions = String.Empty;
            AdjustColumns();            
        }

        /// <summary>
        /// Sets the filter.
        /// </summary>
        /// <param name="filter">The filter.</param>
        internal void SetFilter(CertificateListFilter filter)
        {
            if (m_items == null || m_items.Count == 0)
            {
                return;
            }

            if (ItemsLV.View == View.List)
            {
                ItemsLV.Items.Clear();
                ItemsLV.View = View.Details;
            }

            for (int ii = 0; ii < m_items.Count; ii++)
            {
                ListViewItem item = m_items[ii];

                X509Certificate2 certificate = item.Tag as X509Certificate2;
                
                if (certificate == null)
                {
                    continue;
                }

                if (item.ListView != null)
                {
                    if (!filter.Match(certificate))
                    {
                        item.Remove();
                    }
                }
                else
                {
                    if (filter.Match(certificate))
                    {
                        ItemsLV.Items.Add(item);
                    }
                }
            }

            if (ItemsLV.Items.Count == 0)
            {
                Instructions = "No certificates meet the current filter criteria.";
                AdjustColumns();
                return;
            }
        }

        /// <summary>
        /// Displays the applications in the control.
        /// </summary>
        internal void Initialize(CertificateIdentifierCollection certificates)
        {
            ItemsLV.Items.Clear();

            m_certificates = certificates;

            if (m_certificates == null || m_certificates.Count == 0)
            {
                Instructions = "No certificates are in the store.";
                AdjustColumns();
                return;
            }

            // display the list.
            foreach (CertificateIdentifier certificate in certificates)
            {
                AddItem(certificate);
            }

            // save the unfiltered list.
            m_items = new List<ListViewItem>(ItemsLV.Items.Count);
            
            foreach (ListViewItem item in ItemsLV.Items)
            {
                m_items.Add(item);
            }

            AdjustColumns();
        }

        /// <summary>
        /// Displays the applications in the control.
        /// </summary>
        internal async Task Initialize(CertificateStoreIdentifier id, IList<string> thumbprints)
        {
            ItemsLV.Items.Clear();

            m_storeId = id;
            m_thumbprints = thumbprints;

            if (m_storeId == null || String.IsNullOrEmpty(m_storeId.StoreType) || String.IsNullOrEmpty(m_storeId.StorePath))
            {
                Instructions = "No certificates are in the store.";
                AdjustColumns();
                return ;
            }

            try
            {
                // get the store.
                using (ICertificateStore store = m_storeId.OpenStore())
                {
                    // only show certificates with the specified thumbprint.
                    if (thumbprints != null)
                    {
                        Instructions = "None of the selected certificates can be found in the store.";

                        foreach (string thumbprint in thumbprints)
                        {
                            X509Certificate2Collection certificates = await store.FindByThumbprint(thumbprint);

                            if (certificates.Count > 0)
                            {
                                AddItem(certificates[0]);
                            }
                        }
                    }

                    // show all certificates.
                    else
                    {
                        Instructions = "No certificates are in the store.";

                        X509Certificate2Collection certificates = await store.Enumerate();
                        foreach (X509Certificate2 certificate in certificates)
                        {
                            AddItem(certificate);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Instructions = "An error occurred opening the store: " + e.Message;
            }

            // save the unfiltered list.
            m_items = new List<ListViewItem>(ItemsLV.Items.Count);

            foreach (ListViewItem item in ItemsLV.Items)
            {
                m_items.Add(item);
            }

            AdjustColumns();

        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Handles a double click event.
        /// </summary>
        protected override void PickItems()
        {
            base.PickItems();
            ViewMI_Click(this, null);
        }

        /// <summary>
        /// Updates an item in the view.
        /// </summary>
        protected override void UpdateItem(ListViewItem listItem, object item)
        {
            X509Certificate2 certificate = item as X509Certificate2;

            if (certificate == null)
            {
                base.UpdateItem(listItem, item);
                return;
            }

			listItem.SubItems[0].Text = null;
            listItem.SubItems[1].Text = null;
            listItem.SubItems[2].Text = null;
            listItem.SubItems[3].Text = null;
            listItem.SubItems[4].Text = null;
            listItem.SubItems[5].Text = null;

            if (certificate != null)
            {
                List<string> fields = X509Utils.ParseDistinguishedName(certificate.Subject);

                for (int ii = 0; ii < fields.Count; ii++)
                {
                    if (fields[ii].StartsWith("CN="))
                    {
                        listItem.SubItems[0].Text = fields[ii].Substring(3);
                    }

                    if (fields[ii].StartsWith("DC="))
                    {
                        listItem.SubItems[1].Text = fields[ii].Substring(3);
                    }
                }

                if (String.IsNullOrEmpty(listItem.SubItems[0].Text))
                {
                    listItem.SubItems[0].Text = String.Format("{0}", certificate.Subject);
                }

                // determine certificate type.
                foreach (X509Extension extension in certificate.Extensions)
                {
                    X509BasicConstraintsExtension basicContraints = extension as X509BasicConstraintsExtension;

                    if (basicContraints != null)
                    {
                        if (basicContraints.CertificateAuthority)
                        {
                            listItem.SubItems[1].Text = "CA";
                        }
                        else
                        {
                            listItem.SubItems[1].Text = "End-Entity";
                        }

                        break;
                    }
                }

                // check if a private key is available.
                if (certificate.HasPrivateKey)
                {
                    listItem.SubItems[2].Text = "Yes";
                }
                else
                {
                    listItem.SubItems[2].Text = "No";
                }

                // look up domains.
                IList<string> domains = X509Utils.GetDomainsFromCertficate(certificate);

                StringBuilder buffer = new StringBuilder();

                for (int ii = 0; ii < domains.Count; ii++)
                {
                    if (buffer.Length > 0)
                    {
                        buffer.Append(";");
                    }

                    buffer.Append(domains[ii]);
                }

                listItem.SubItems[3].Text = buffer.ToString();
                listItem.SubItems[4].Text = X509Utils.GetApplicationUriFromCertificate(certificate);
                listItem.SubItems[5].Text = String.Format("{0:yyyy-MM-dd}", certificate.NotAfter);
            }

            listItem.ImageKey = GuiUtils.Icons.Certificate;
            listItem.Tag = item;
        }

        /// <summary>
        /// Enables the menu items based on the current selection.
        /// </summary>
        protected override void EnableMenuItems(ListViewItem clickedItem)
        {
            base.EnableMenuItems(clickedItem);

            DeleteMI.Enabled = ItemsLV.SelectedItems.Count > 0;

            X509Certificate2 certificate = SelectedTag as X509Certificate2;

            if (certificate != null)
            {
                ViewMI.Enabled = true;
                CopyMI.Enabled = true;
            }

            IDataObject clipboardData = Clipboard.GetDataObject();
         
            if (clipboardData.GetDataPresent(DataFormats.Text)) 
            {
                PasteMI.Enabled = true;
            }
        }
        #endregion

        private async void ViewMI_Click(object sender, EventArgs e)
        {
            try
            {
                X509Certificate2 certificate = SelectedTag as X509Certificate2;

                if (certificate != null)
                {
                    CertificateIdentifier id = new CertificateIdentifier();
                    id.Certificate = certificate;

                    if (m_storeId != null)
                    {
                        id.StoreType = m_storeId.StoreType;
                        id.StorePath = m_storeId.StorePath;
                    }

                    await new ViewCertificateDlg().ShowDialog(id);
                }
            }
            catch (Exception exception)
            {
                GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private async void DeleteMI_Click(object sender, EventArgs e)
        {
            try
            {
                if (ItemsLV.SelectedItems.Count < 1)
                {
                    return;
                }

                DialogResult result = MessageBox.Show(
                    "Are you sure you wish to delete the certificates from the store?",
                    "Delete Certificate",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Exclamation);

                if (result != DialogResult.Yes)
                {
                    return;
                }

                // remove the certificates.
                List<ListViewItem> itemsToDelete = new List<ListViewItem>();
                bool yesToAll = false;

                using (ICertificateStore store = m_storeId.OpenStore())
                {
                    for (int ii = 0; ii < ItemsLV.SelectedItems.Count; ii++)
                    {
                        X509Certificate2 certificate = ItemsLV.SelectedItems[ii].Tag as X509Certificate2;

                        // check for private key.
                        X509Certificate2Collection certificate2 = await store.FindByThumbprint(certificate.Thumbprint);

                        if (!yesToAll && (certificate2.Count > 0) && certificate2[0].HasPrivateKey)
                        {
                            StringBuilder buffer = new StringBuilder();
                            buffer.Append("Certificate '");
                            buffer.Append(certificate2[0].Subject);
                            buffer.Append("'");
                            buffer.Append("Deleting it may cause applications to stop working.");
                            buffer.Append("\r\n");
                            buffer.Append("\r\n");
                            buffer.Append("Are you sure you wish to continue?.");

                            DialogResult yesno = new YesNoDlg().ShowDialog(buffer.ToString(), "Delete Private Key", true);

                            if (yesno == DialogResult.No)
                            {
                                continue;
                            }

                            yesToAll = yesno == DialogResult.Retry;
                        }

                        if (certificate != null)
                        {
                            await store.Delete(certificate.Thumbprint);
                            itemsToDelete.Add(ItemsLV.SelectedItems[ii]);
                        }
                    }
                }

                // remove the items.
                foreach (ListViewItem itemToDelete in itemsToDelete)
                {
                    itemToDelete.Remove();
                }
            }
            catch (Exception exception)
            {
                GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
                await Initialize(m_storeId, m_thumbprints);
            }
        }

        private void CopyMI_Click(object sender, EventArgs e)
        {
            try
			{                
                X509Certificate2 certificate = SelectedTag as X509Certificate2;

                if (certificate == null)
                {
                    return;
                }

                StringBuilder builder = new StringBuilder();
                XmlWriter writer = XmlWriter.Create(builder);

                try
                {
                    DataContractSerializer serializer = new DataContractSerializer(typeof(CertificateIdentifier));
                    CertificateIdentifier id = new CertificateIdentifier();
                    id.Certificate = certificate;
                    serializer.WriteObject(writer, id);
                }
                finally
                {
                    writer.Close();
                }

                ClipboardHack.SetData(DataFormats.Text, builder.ToString());
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private void PasteMI_Click(object sender, EventArgs e)
        {
            try
			{ 
                string xml = (string)ClipboardHack.GetData(DataFormats.Text);

                if (String.IsNullOrEmpty(xml))
                {
                    return;
                }
                    
                // deserialize the data.
                CertificateIdentifier id = null;

                using (XmlTextReader reader = new XmlTextReader(new StringReader(xml)))
                {
                    DataContractSerializer serializer = new DataContractSerializer(typeof(CertificateIdentifier));                    
                    id = (CertificateIdentifier)serializer.ReadObject(reader, false);
                }
                
                if (id.Certificate != null)
                {
                    using (ICertificateStore store = m_storeId.OpenStore())
                    {
                        store.Add(id.Certificate);
                    }

                    AddItem(id.Certificate);
                }
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Security.Cryptography.X509Certificates;
using System.Reflection;
using System.Xml;
using System.IO;
using System.Runtime.Serialization;
using System.Threading.Tasks;
using Opc.Ua.Security.Certificates;

namespace Opc.Ua.Client.Controls
{
    /// <summary>
    /// Displays a list of certificates.
    /// </summary>
    public partial class CertificateListCtrl : Opc.Ua.Client.Controls.BaseListCtrl
    {
        #region Constructors
        /// <summary>
        /// Constructs the object.
        /// </summary>
        public CertificateListCtrl()
        {
            InitializeComponent();

            SetColumns(m_ColumnNames);
        }
        #endregion
       
        #region Private Fields
		// The columns to display in the control.		
		private readonly object[][] m_ColumnNames = new object[][]
		{ 
			new object[] { "Name",        HorizontalAlignment.Left, null },
			new object[] { "Type",        HorizontalAlignment.Left, null },
			new object[] { "Private Key", HorizontalAlignment.Center, null },
			new object[] { "Domains",     HorizontalAlignment.Left, null },  
			new object[] { "Uri ",        HorizontalAlignment.Left, null },  
			new object[] { "Valid Until", HorizontalAlignment.Left, null }
		};

        private CertificateStoreIdentifier m_storeId;
        private CertificateIdentifierCollection m_certificates;
        private IList<string> m_thumbprints;
        private List<ListViewItem> m_items;
        #endregion

        #region Public Interface
        /// <summary>
        /// The currently selected certificate.
        /// </summary>
        public X509Certificate2 SelectedCertificate
        {
            get
            {
                return SelectedTag as X509Certificate2;
            }
        }

        /// <summary>
        /// Gets a value indicating whether this instance is empty store.
        /// </summary>
        public bool IsEmptyStore
        {
            get
            {
                if (m_items == null || m_items.Count == 0)
                {
                    return true;
                }

                return false;
            }
        }

        /// <summary>
        /// Removes all items in the list.
        /// </summary>
        internal void Clear()
        {
            ItemsLV.Items.Clear();
            Instructions = String.Empty;
            AdjustColumns();            
        }

        /// <summary>
        /// Sets the filter.
        /// </summary>
        /// <param name="filter">The filter.</param>
        internal void SetFilter(CertificateListFilter filter)
        {
            if (m_items == null || m_items.Count == 0)
            {
                return;
            }

            if (ItemsLV.View == View.List)
            {
                ItemsLV.Items.Clear();
                ItemsLV.View = View.Details;
            }

            for (int ii = 0; ii < m_items.Count; ii++)
            {
                ListViewItem item = m_items[ii];

                X509Certificate2 certificate = item.Tag as X509Certificate2;
                
                if (certificate == null)
                {
                    continue;
                }

                if (item.ListView != null)
                {
                    if (!filter.Match(certificate))
                    {
                        item.Remove();
                    }
                }
                else
                {
                    if (filter.Match(certificate))
                    {
                        ItemsLV.Items.Add(item);
                    }
                }
            }

            if (ItemsLV.Items.Count == 0)
            {
                Instructions = "No certificates meet the current filter criteria.";
                AdjustColumns();
                return;
            }
        }

        /// <summary>
        /// Displays the applications in the control.
        /// </summary>
        internal void Initialize(CertificateIdentifierCollection certificates)
        {
            ItemsLV.Items.Clear();

            m_certificates = certificates;

            if (m_certificates == null || m_certificates.Count == 0)
            {
                Instructions = "No certificates are in the store.";
                AdjustColumns();
                return;
            }

            // display the list.
            foreach (CertificateIdentifier certificate in certificates)
            {
                AddItem(certificate);
            }

            // save the unfiltered list.
            m_items = new List<ListViewItem>(ItemsLV.Items.Count);
            
            foreach (ListViewItem item in ItemsLV.Items)
            {
                m_items.Add(item);
            }

            AdjustColumns();
        }

        /// <summary>
        /// Displays the applications in the control.
        /// </summary>
        internal async Task Initialize(CertificateStoreIdentifier id, IList<string> thumbprints)
        {
            ItemsLV.Items.Clear();

            m_storeId = id;
            m_thumbprints = thumbprints;

            if (m_storeId == null || String.IsNullOrEmpty(m_storeId.StoreType) || String.IsNullOrEmpty(m_storeId.StorePath))
            {
                Instructions = "No certificates are in the store.";
                AdjustColumns();
                return ;
            }

            try
            {
                // get the store.
                using (ICertificateStore store = m_storeId.OpenStore())
                {
                    // only show certificates with the specified thumbprint.
                    if (thumbprints != null)
                    {
                        Instructions = "None of the selected certificates can be found in the store.";

                        foreach (string thumbprint in thumbprints)
                        {
                            X509Certificate2Collection certificates = await store.FindByThumbprint(thumbprint);

                            if (certificates.Count > 0)
                            {
                                AddItem(certificates[0]);
                            }
                        }
                    }

                    // show all certificates.
                    else
                    {
                        Instructions = "No certificates are in the store.";

                        X509Certificate2Collection certificates = await store.Enumerate();
                        foreach (X509Certificate2 certificate in certificates)
                        {
                            AddItem(certificate);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Instructions = "An error occurred opening the store: " + e.Message;
            }

            // save the unfiltered list.
            m_items = new List<ListViewItem>(ItemsLV.Items.Count);

            foreach (ListViewItem item in ItemsLV.Items)
            {
                m_items.Add(item);
            }

            AdjustColumns();

        }
        #endregion

        #region Overridden Methods
        /// <summary>
        /// Handles a double click event.
        /// </summary>
        protected override void PickItems()
        {
            base.PickItems();
            ViewMI_Click(this, null);
        }

        /// <summary>
        /// Updates an item in the view.
        /// </summary>
        protected override void UpdateItem(ListViewItem listItem, object item)
        {

            if (certificate == null)
            {
                base.UpdateItem(listItem, item);
                return;
            }

			listItem.SubItems[0].Text = null;
            listItem.SubItems[1].Text = null;
            listItem.SubItems[2].Text = null;
            listItem.SubItems[3].Text = null;
            listItem.SubItems[4].Text = null;
            listItem.SubItems[5].Text = null;

            if (item is X509Certificate2 certificate)
            {
                List<string> fields = X509Utils.ParseDistinguishedName(certificate.Subject);

                for (int ii = 0; ii < fields.Count; ii++)
                {
                    if (fields[ii].StartsWith("CN="))
                    {
                        listItem.SubItems[0].Text = fields[ii].Substring(3);
                    }

                    if (fields[ii].StartsWith("DC="))
                    {
                        listItem.SubItems[1].Text = fields[ii].Substring(3);
                    }
                }

                if (String.IsNullOrEmpty(listItem.SubItems[0].Text))
                {
                    listItem.SubItems[0].Text = String.Format("{0}", certificate.Subject);
                }

                // determine certificate type.
                foreach (X509Extension extension in certificate.Extensions)
                {
                    if (extension is X509BasicConstraintsExtension basicContraints)
                    {
                        if (basicContraints.CertificateAuthority)
                        {
                            listItem.SubItems[1].Text = "CA";
                        }
                        else
                        {
                            listItem.SubItems[1].Text = "End-Entity";
                        }

                        break;
                    }
                }

                // check if a private key is available.
                if (certificate.HasPrivateKey)
                {
                    listItem.SubItems[2].Text = "Yes";
                }
                else
                {
                    listItem.SubItems[2].Text = "No";
                }

                // look up domains.
                IList<string> domains = X509Utils.GetDomainsFromCertficate(certificate);

                StringBuilder buffer = new StringBuilder();

                for (int ii = 0; ii < domains.Count; ii++)
                {
                    if (buffer.Length > 0)
                    {
                        buffer.Append(";");
                    }

                    buffer.Append(domains[ii]);
                }

                listItem.SubItems[3].Text = buffer.ToString();
                listItem.SubItems[4].Text = X509Utils.GetApplicationUriFromCertificate(certificate);
                listItem.SubItems[5].Text = String.Format("{0:yyyy-MM-dd}", certificate.NotAfter);
            }

            listItem.ImageKey = GuiUtils.Icons.Certificate;
            listItem.Tag = item;
        }

        /// <summary>
        /// Enables the menu items based on the current selection.
        /// </summary>
        protected override void EnableMenuItems(ListViewItem clickedItem)
        {
            base.EnableMenuItems(clickedItem);

            DeleteMI.Enabled = ItemsLV.SelectedItems.Count > 0;

            if (SelectedTag is X509Certificate2 certificate)
            {
                ViewMI.Enabled = true;
                CopyMI.Enabled = true;
            }

            IDataObject clipboardData = Clipboard.GetDataObject();
         
            if (clipboardData.GetDataPresent(DataFormats.Text)) 
            {
                PasteMI.Enabled = true;
            }
        }
        #endregion

        private async void ViewMI_Click(object sender, EventArgs e)
        {
            try
            {
                if (SelectedTag is X509Certificate2 certificate)
                {
                    CertificateIdentifier id = new CertificateIdentifier();
                    id.Certificate = certificate;

                    if (m_storeId != null)
                    {
                        id.StoreType = m_storeId.StoreType;
                        id.StorePath = m_storeId.StorePath;
                    }

                    await new ViewCertificateDlg().ShowDialog(id);
                }
            }
            catch (Exception exception)
            {
                GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private async void DeleteMI_Click(object sender, EventArgs e)
        {
            try
            {
                if (ItemsLV.SelectedItems.Count < 1)
                {
                    return;
                }

                DialogResult result = MessageBox.Show(
                    "Are you sure you wish to delete the certificates from the store?",
                    "Delete Certificate",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Exclamation);

                if (result != DialogResult.Yes)
                {
                    return;
                }

                // remove the certificates.
                List<ListViewItem> itemsToDelete = new List<ListViewItem>();
                bool yesToAll = false;

                using (ICertificateStore store = m_storeId.OpenStore())
                {
                    for (int ii = 0; ii < ItemsLV.SelectedItems.Count; ii++)
                    {
                        X509Certificate2 certificate = ItemsLV.SelectedItems[ii].Tag as X509Certificate2;

                        // check for private key.
                        X509Certificate2Collection certificate2 = await store.FindByThumbprint(certificate.Thumbprint);

                        if (!yesToAll && (certificate2.Count > 0) && certificate2[0].HasPrivateKey)
                        {
                            StringBuilder buffer = new StringBuilder();
                            buffer.Append("Certificate '");
                            buffer.Append(certificate2[0].Subject);
                            buffer.Append("'");
                            buffer.Append("Deleting it may cause applications to stop working.");
                            buffer.Append("\r\n");
                            buffer.Append("\r\n");
                            buffer.Append("Are you sure you wish to continue?.");

                            DialogResult yesno = new YesNoDlg().ShowDialog(buffer.ToString(), "Delete Private Key", true);

                            if (yesno == DialogResult.No)
                            {
                                continue;
                            }

                            yesToAll = yesno == DialogResult.Retry;
                        }

                        if (certificate != null)
                        {
                            await store.Delete(certificate.Thumbprint);
                            itemsToDelete.Add(ItemsLV.SelectedItems[ii]);
                        }
                    }
                }

                // remove the items.
                foreach (ListViewItem itemToDelete in itemsToDelete)
                {
                    itemToDelete.Remove();
                }
            }
            catch (Exception exception)
            {
                GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
                await Initialize(m_storeId, m_thumbprints);
            }
        }

        private void CopyMI_Click(object sender, EventArgs e)
        {
            try
			{                
                X509Certificate2 certificate = SelectedTag as X509Certificate2;

                if (certificate == null)
                {
                    return;
                }

                StringBuilder builder = new StringBuilder();
                XmlWriter writer = XmlWriter.Create(builder);

                try
                {
                    DataContractSerializer serializer = new DataContractSerializer(typeof(CertificateIdentifier));
                    CertificateIdentifier id = new CertificateIdentifier();
                    id.Certificate = certificate;
                    serializer.WriteObject(writer, id);
                }
                finally
                {
                    writer.Close();
                }

                ClipboardHack.SetData(DataFormats.Text, builder.ToString());
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }

        private void PasteMI_Click(object sender, EventArgs e)
        {
            try
			{ 
                string xml = (string)ClipboardHack.GetData(DataFormats.Text);

                if (String.IsNullOrEmpty(xml))
                {
                    return;
                }
                    
                // deserialize the data.
                CertificateIdentifier id = null;

                using (XmlTextReader reader = new XmlTextReader(new StringReader(xml)))
                {
                    DataContractSerializer serializer = new DataContractSerializer(typeof(CertificateIdentifier));                    
                    id = (CertificateIdentifier)serializer.ReadObject(reader, false);
                }
                
                if (id.Certificate != null)
                {
                    using (ICertificateStore store = m_storeId.OpenStore())
                    {
                        store.Add(id.Certificate);
                    }

                    AddItem(id.Certificate);
                }
            }
            catch (Exception exception)
            {
				GuiUtils.HandleException(this.Text, MethodBase.GetCurrentMethod(), exception);
            }
        }
    }
}

---- Semantic diagnostics *before* transformation ----
D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificateListCtrl.cs(40,1): hidden CS8019: Unnecessary using directive.
---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificateListCtrl.cs(287,17): error CS0841: Cannot use local variable 'certificate' before it is declared,D:\a\1\s\Applications\ClientControls.Net4\Configuration\CertificateListCtrl.cs(40,1): hidden CS8019: Unnecessary using directive.
######################################################################


######################################################################
Nr: 37 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Applications\ReferenceServer\ReferenceServer.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using Opc.Ua;
using Opc.Ua.Server;

namespace Quickstarts.ReferenceServer
{
    /// <summary>
    /// Implements a basic Quickstart Server.
    /// </summary>
    /// <remarks>
    /// Each server instance must have one instance of a StandardServer object which is
    /// responsible for reading the configuration file, creating the endpoints and dispatching
    /// incoming requests to the appropriate handler.
    /// 
    /// This sub-class specifies non-configurable metadata such as Product Name and initializes
    /// the EmptyNodeManager which provides access to the data exposed by the Server.
    /// </remarks>
    public partial class ReferenceServer : ReverseConnectServer
    {
        #region Overridden Methods
        /// <summary>
        /// Creates the node managers for the server.
        /// </summary>
        /// <remarks>
        /// This method allows the sub-class create any additional node managers which it uses. The SDK
        /// always creates a CoreNodeManager which handles the built-in nodes defined by the specification.
        /// Any additional NodeManagers are expected to handle application specific nodes.
        /// </remarks>
        protected override MasterNodeManager CreateMasterNodeManager(IServerInternal server, ApplicationConfiguration configuration)
        {
            Utils.Trace("Creating the Node Managers.");

            List<INodeManager> nodeManagers = new List<INodeManager>();

            // create the custom node managers.
            nodeManagers.Add(new ReferenceNodeManager(server, configuration));

            // create master node manager.
            return new MasterNodeManager(server, configuration, null, nodeManagers.ToArray());
        }

        /// <summary>
        /// Loads the non-configurable properties for the application.
        /// </summary>
        /// <remarks>
        /// These properties are exposed by the server but cannot be changed by administrators.
        /// </remarks>
        protected override ServerProperties LoadServerProperties()
        {
            ServerProperties properties = new ServerProperties();

            properties.ManufacturerName = "OPC Foundation";
            properties.ProductName = "Quickstart Reference Server";
            properties.ProductUri = "http://opcfoundation.org/Quickstart/ReferenceServer/v1.04";
            properties.SoftwareVersion = Utils.GetAssemblySoftwareVersion();
            properties.BuildNumber = Utils.GetAssemblyBuildNumber();
            properties.BuildDate = Utils.GetAssemblyTimestamp();

            return properties;
        }

        /// <summary>
        /// Creates the resource manager for the server.
        /// </summary>
        protected override ResourceManager CreateResourceManager(IServerInternal server, ApplicationConfiguration configuration)
        {
            ResourceManager resourceManager = new ResourceManager(server, configuration);

            System.Reflection.FieldInfo[] fields = typeof(StatusCodes).GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);

            foreach (System.Reflection.FieldInfo field in fields)
            {
                uint? id = field.GetValue(typeof(StatusCodes)) as uint?;

                if (id != null)
                {
                    resourceManager.Add(id.Value, "en-US", field.Name);
                }
            }

            return resourceManager;
        }

        /// <summary>
        /// Initializes the server before it starts up.
        /// </summary>
        /// <remarks>
        /// This method is called before any startup processing occurs. The sub-class may update the 
        /// configuration object or do any other application specific startup tasks.
        /// </remarks>
        protected override void OnServerStarting(ApplicationConfiguration configuration)
        {
            Utils.Trace("The server is starting.");

            base.OnServerStarting(configuration);

            // it is up to the application to decide how to validate user identity tokens.
            // this function creates validator for X509 identity tokens.
            CreateUserIdentityValidators(configuration);
        }

        /// <summary>
        /// Called after the server has been started.
        /// </summary>
        protected override void OnServerStarted(IServerInternal server)
        {
            base.OnServerStarted(server);

            // request notifications when the user identity is changed. all valid users are accepted by default.
            server.SessionManager.ImpersonateUser += new ImpersonateEventHandler(SessionManager_ImpersonateUser);

            try
            {
                // allow a faster sampling interval for CurrentTime node.
                ServerInternal.Status.Variable.CurrentTime.MinimumSamplingInterval = 250;
            }
            catch
            { }

        }
        #endregion

        #region User Validation Functions
        /// <summary>
        /// Creates the objects used to validate the user identity tokens supported by the server.
        /// </summary>
        private void CreateUserIdentityValidators(ApplicationConfiguration configuration)
        {
            for (int ii = 0; ii < configuration.ServerConfiguration.UserTokenPolicies.Count; ii++)
            {
                UserTokenPolicy policy = configuration.ServerConfiguration.UserTokenPolicies[ii];

                // create a validator for a certificate token policy.
                if (policy.TokenType == UserTokenType.Certificate)
                {
                    // check if user certificate trust lists are specified in configuration.
                    if (configuration.SecurityConfiguration.TrustedUserCertificates != null &&
                        configuration.SecurityConfiguration.UserIssuerCertificates != null)
                    {
                        CertificateValidator certificateValidator = new CertificateValidator();
                        certificateValidator.Update(configuration.SecurityConfiguration).Wait();
                        certificateValidator.Update(configuration.SecurityConfiguration.UserIssuerCertificates,
                            configuration.SecurityConfiguration.TrustedUserCertificates,
                            configuration.SecurityConfiguration.RejectedCertificateStore);

                        // set custom validator for user certificates.
                        m_userCertificateValidator = certificateValidator.GetChannelValidator();
                    }
                }
            }
        }

        /// <summary>
        /// Called when a client tries to change its user identity.
        /// </summary>
        private void SessionManager_ImpersonateUser(Session session, ImpersonateEventArgs args)
        {
            // check for a user name token.
            UserNameIdentityToken userNameToken = args.NewIdentity as UserNameIdentityToken;

            if (userNameToken != null)
            {
                args.Identity = VerifyPassword(userNameToken);

                // set AuthenticatedUser role for accepted user/password authentication
                args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_AuthenticatedUser);

                if (args.Identity is SystemConfigurationIdentity)
                {
                    // set ConfigureAdmin role for user with permission to configure server
                    args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_ConfigureAdmin);
                    args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_SecurityAdmin);
                }

                return;
            }

            // check for x509 user token.
            X509IdentityToken x509Token = args.NewIdentity as X509IdentityToken;

            if (x509Token != null)
            {
                VerifyUserTokenCertificate(x509Token.Certificate);
                args.Identity = new UserIdentity(x509Token);
                Utils.Trace("X509 Token Accepted: {0}", args.Identity.DisplayName);

                // set AuthenticatedUser role for accepted certificate authentication
                args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_AuthenticatedUser);

                return;
            }

            // allow anonymous authentication and set Anonymous role for this authentication
            args.Identity = new UserIdentity();
            args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_Anonymous);
        }

        /// <summary>
        /// Validates the password for a username token.
        /// </summary>
        private IUserIdentity VerifyPassword(UserNameIdentityToken userNameToken)
        {
            var userName = userNameToken.UserName;
            var password = userNameToken.DecryptedPassword;
            if (String.IsNullOrEmpty(userName))
            {
                // an empty username is not accepted.
                throw ServiceResultException.Create(StatusCodes.BadIdentityTokenInvalid,
                    "Security token is not a valid username token. An empty username is not accepted.");
            }

            if (String.IsNullOrEmpty(password))
            {
                // an empty password is not accepted.
                throw ServiceResultException.Create(StatusCodes.BadIdentityTokenRejected,
                    "Security token is not a valid username token. An empty password is not accepted.");
            }

            // User with permission to configure server
            if (userName == "sysadmin" && password == "demo")
            {
                return new SystemConfigurationIdentity(new UserIdentity(userNameToken));
            }

            // standard users for CTT verification
            if (!((userName == "user1" && password == "password") ||
                (userName == "user2" && password == "password1")))
            {
                // construct translation object with default text.
                TranslationInfo info = new TranslationInfo(
                    "InvalidPassword",
                    "en-US",
                    "Invalid username or password.",
                    userName);

                // create an exception with a vendor defined sub-code.
                throw new ServiceResultException(new ServiceResult(
                    StatusCodes.BadUserAccessDenied,
                    "InvalidPassword",
                    LoadServerProperties().ProductUri,
                    new LocalizedText(info)));
            }

            return new UserIdentity(userNameToken);
        }

        /// <summary>
        /// Verifies that a certificate user token is trusted.
        /// </summary>
        private void VerifyUserTokenCertificate(X509Certificate2 certificate)
        {
            try
            {
                if (m_userCertificateValidator != null)
                {
                    m_userCertificateValidator.Validate(certificate);
                }
                else
                {
                    CertificateValidator.Validate(certificate);
                }
            }
            catch (Exception e)
            {
                TranslationInfo info;
                StatusCode result = StatusCodes.BadIdentityTokenRejected;
                ServiceResultException se = e as ServiceResultException;
                if (se != null && se.StatusCode == StatusCodes.BadCertificateUseNotAllowed)
                {
                    info = new TranslationInfo(
                        "InvalidCertificate",
                        "en-US",
                        "'{0}' is an invalid user certificate.",
                        certificate.Subject);

                    result = StatusCodes.BadIdentityTokenInvalid;
                }
                else
                {
                    // construct translation object with default text.
                    info = new TranslationInfo(
                        "UntrustedCertificate",
                        "en-US",
                        "'{0}' is not a trusted user certificate.",
                        certificate.Subject);
                }

                // create an exception with a vendor defined sub-code.
                throw new ServiceResultException(new ServiceResult(
                    result,
                    info.Key,
                    LoadServerProperties().ProductUri,
                    new LocalizedText(info)));
            }
        }
        #endregion

        #region Private Fields
        private ICertificateValidator m_userCertificateValidator;
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using Opc.Ua;
using Opc.Ua.Server;

namespace Quickstarts.ReferenceServer
{
    /// <summary>
    /// Implements a basic Quickstart Server.
    /// </summary>
    /// <remarks>
    /// Each server instance must have one instance of a StandardServer object which is
    /// responsible for reading the configuration file, creating the endpoints and dispatching
    /// incoming requests to the appropriate handler.
    /// 
    /// This sub-class specifies non-configurable metadata such as Product Name and initializes
    /// the EmptyNodeManager which provides access to the data exposed by the Server.
    /// </remarks>
    public partial class ReferenceServer : ReverseConnectServer
    {
        #region Overridden Methods
        /// <summary>
        /// Creates the node managers for the server.
        /// </summary>
        /// <remarks>
        /// This method allows the sub-class create any additional node managers which it uses. The SDK
        /// always creates a CoreNodeManager which handles the built-in nodes defined by the specification.
        /// Any additional NodeManagers are expected to handle application specific nodes.
        /// </remarks>
        protected override MasterNodeManager CreateMasterNodeManager(IServerInternal server, ApplicationConfiguration configuration)
        {
            Utils.Trace("Creating the Node Managers.");

            List<INodeManager> nodeManagers = new List<INodeManager>();

            // create the custom node managers.
            nodeManagers.Add(new ReferenceNodeManager(server, configuration));

            // create master node manager.
            return new MasterNodeManager(server, configuration, null, nodeManagers.ToArray());
        }

        /// <summary>
        /// Loads the non-configurable properties for the application.
        /// </summary>
        /// <remarks>
        /// These properties are exposed by the server but cannot be changed by administrators.
        /// </remarks>
        protected override ServerProperties LoadServerProperties()
        {
            ServerProperties properties = new ServerProperties();

            properties.ManufacturerName = "OPC Foundation";
            properties.ProductName = "Quickstart Reference Server";
            properties.ProductUri = "http://opcfoundation.org/Quickstart/ReferenceServer/v1.04";
            properties.SoftwareVersion = Utils.GetAssemblySoftwareVersion();
            properties.BuildNumber = Utils.GetAssemblyBuildNumber();
            properties.BuildDate = Utils.GetAssemblyTimestamp();

            return properties;
        }

        /// <summary>
        /// Creates the resource manager for the server.
        /// </summary>
        protected override ResourceManager CreateResourceManager(IServerInternal server, ApplicationConfiguration configuration)
        {
            ResourceManager resourceManager = new ResourceManager(server, configuration);

            System.Reflection.FieldInfo[] fields = typeof(StatusCodes).GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);

            foreach (System.Reflection.FieldInfo field in fields)
            {
                if (field.GetValue(typeof(StatusCodes)) is uint? id)
                {
                    resourceManager.Add(id.Value, "en-US", field.Name);
                }
            }

            return resourceManager;
        }

        /// <summary>
        /// Initializes the server before it starts up.
        /// </summary>
        /// <remarks>
        /// This method is called before any startup processing occurs. The sub-class may update the 
        /// configuration object or do any other application specific startup tasks.
        /// </remarks>
        protected override void OnServerStarting(ApplicationConfiguration configuration)
        {
            Utils.Trace("The server is starting.");

            base.OnServerStarting(configuration);

            // it is up to the application to decide how to validate user identity tokens.
            // this function creates validator for X509 identity tokens.
            CreateUserIdentityValidators(configuration);
        }

        /// <summary>
        /// Called after the server has been started.
        /// </summary>
        protected override void OnServerStarted(IServerInternal server)
        {
            base.OnServerStarted(server);

            // request notifications when the user identity is changed. all valid users are accepted by default.
            server.SessionManager.ImpersonateUser += new ImpersonateEventHandler(SessionManager_ImpersonateUser);

            try
            {
                // allow a faster sampling interval for CurrentTime node.
                ServerInternal.Status.Variable.CurrentTime.MinimumSamplingInterval = 250;
            }
            catch
            { }

        }
        #endregion

        #region User Validation Functions
        /// <summary>
        /// Creates the objects used to validate the user identity tokens supported by the server.
        /// </summary>
        private void CreateUserIdentityValidators(ApplicationConfiguration configuration)
        {
            for (int ii = 0; ii < configuration.ServerConfiguration.UserTokenPolicies.Count; ii++)
            {
                UserTokenPolicy policy = configuration.ServerConfiguration.UserTokenPolicies[ii];

                // create a validator for a certificate token policy.
                if (policy.TokenType == UserTokenType.Certificate)
                {
                    // check if user certificate trust lists are specified in configuration.
                    if (configuration.SecurityConfiguration.TrustedUserCertificates != null &&
                        configuration.SecurityConfiguration.UserIssuerCertificates != null)
                    {
                        CertificateValidator certificateValidator = new CertificateValidator();
                        certificateValidator.Update(configuration.SecurityConfiguration).Wait();
                        certificateValidator.Update(configuration.SecurityConfiguration.UserIssuerCertificates,
                            configuration.SecurityConfiguration.TrustedUserCertificates,
                            configuration.SecurityConfiguration.RejectedCertificateStore);

                        // set custom validator for user certificates.
                        m_userCertificateValidator = certificateValidator.GetChannelValidator();
                    }
                }
            }
        }

        /// <summary>
        /// Called when a client tries to change its user identity.
        /// </summary>
        private void SessionManager_ImpersonateUser(Session session, ImpersonateEventArgs args)
        {
            // check for a user name token.

            if (args.NewIdentity is UserNameIdentityToken userNameToken)
            {
                args.Identity = VerifyPassword(userNameToken);

                // set AuthenticatedUser role for accepted user/password authentication
                args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_AuthenticatedUser);

                if (args.Identity is SystemConfigurationIdentity)
                {
                    // set ConfigureAdmin role for user with permission to configure server
                    args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_ConfigureAdmin);
                    args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_SecurityAdmin);
                }

                return;
            }

            // check for x509 user token.

            if (args.NewIdentity is X509IdentityToken x509Token)
            {
                VerifyUserTokenCertificate(x509Token.Certificate);
                args.Identity = new UserIdentity(x509Token);
                Utils.Trace("X509 Token Accepted: {0}", args.Identity.DisplayName);

                // set AuthenticatedUser role for accepted certificate authentication
                args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_AuthenticatedUser);

                return;
            }

            // allow anonymous authentication and set Anonymous role for this authentication
            args.Identity = new UserIdentity();
            args.Identity.GrantedRoleIds.Add(ObjectIds.WellKnownRole_Anonymous);
        }

        /// <summary>
        /// Validates the password for a username token.
        /// </summary>
        private IUserIdentity VerifyPassword(UserNameIdentityToken userNameToken)
        {
            var userName = userNameToken.UserName;
            var password = userNameToken.DecryptedPassword;
            if (String.IsNullOrEmpty(userName))
            {
                // an empty username is not accepted.
                throw ServiceResultException.Create(StatusCodes.BadIdentityTokenInvalid,
                    "Security token is not a valid username token. An empty username is not accepted.");
            }

            if (String.IsNullOrEmpty(password))
            {
                // an empty password is not accepted.
                throw ServiceResultException.Create(StatusCodes.BadIdentityTokenRejected,
                    "Security token is not a valid username token. An empty password is not accepted.");
            }

            // User with permission to configure server
            if (userName == "sysadmin" && password == "demo")
            {
                return new SystemConfigurationIdentity(new UserIdentity(userNameToken));
            }

            // standard users for CTT verification
            if (!((userName == "user1" && password == "password") ||
                (userName == "user2" && password == "password1")))
            {
                // construct translation object with default text.
                TranslationInfo info = new TranslationInfo(
                    "InvalidPassword",
                    "en-US",
                    "Invalid username or password.",
                    userName);

                // create an exception with a vendor defined sub-code.
                throw new ServiceResultException(new ServiceResult(
                    StatusCodes.BadUserAccessDenied,
                    "InvalidPassword",
                    LoadServerProperties().ProductUri,
                    new LocalizedText(info)));
            }

            return new UserIdentity(userNameToken);
        }

        /// <summary>
        /// Verifies that a certificate user token is trusted.
        /// </summary>
        private void VerifyUserTokenCertificate(X509Certificate2 certificate)
        {
            try
            {
                if (m_userCertificateValidator != null)
                {
                    m_userCertificateValidator.Validate(certificate);
                }
                else
                {
                    CertificateValidator.Validate(certificate);
                }
            }
            catch (Exception e)
            {
                TranslationInfo info;
                StatusCode result = StatusCodes.BadIdentityTokenRejected;

                if (e is ServiceResultException se && se.StatusCode == StatusCodes.BadCertificateUseNotAllowed)
                {
                    info = new TranslationInfo(
                        "InvalidCertificate",
                        "en-US",
                        "'{0}' is an invalid user certificate.",
                        certificate.Subject);

                    result = StatusCodes.BadIdentityTokenInvalid;
                }
                else
                {
                    // construct translation object with default text.
                    info = new TranslationInfo(
                        "UntrustedCertificate",
                        "en-US",
                        "'{0}' is not a trusted user certificate.",
                        certificate.Subject);
                }

                // create an exception with a vendor defined sub-code.
                throw new ServiceResultException(new ServiceResult(
                    result,
                    info.Key,
                    LoadServerProperties().ProductUri,
                    new LocalizedText(info)));
            }
        }
        #endregion

        #region Private Fields
        private ICertificateValidator m_userCertificateValidator;
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Applications\ReferenceServer\ReferenceServer.cs(104,60): error CS8116: It is not legal to use nullable type 'uint?' in a pattern; use the underlying type 'uint' instead.
######################################################################


######################################################################
Nr: 38 - UsePatternMatchingRewriterR8
Filepath: D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs
Description: Error: The created Syntax Tree is semantically incorrect.
------------------------------------------------------------------------
---- Original Tree ----
using System;
using System.Collections.Generic;
using System.IO;

namespace Opc.Ua.PubSub.Configuration
{
    /// <summary>
    /// Entity responsible to configure a PubSub Application
    /// 
    /// It has methods for adding/removing configuration objects to a root <see cref="PubSubConfigurationDataType"/> object.
    /// When the root <see cref="PubSubConfigurationDataType"/> object is modified there are various events raised to allow reaction to configuration changes.
    /// Each child object from parent <see cref="PubSubConfigurationDataType"/> object has a configurationId associated to it and it can be used to alter configuration. 
    /// The configurationId can be obtained using the <see cref="UaPubSubConfigurator.FindIdForObject(object)"/> method.
    /// </summary>
    public class UaPubSubConfigurator
    {
        #region Private Fields
        /// <summary>
        /// Value of an uninitialized identifier.
        /// </summary>
        internal static uint InvalidId = 0;

        private object m_lock = new object();
        private PubSubConfigurationDataType m_pubSubConfiguration;
        private Dictionary<uint, object> m_idsToObjects;
        private Dictionary<object, uint> m_objectsToIds;
        private Dictionary<uint, PubSubState> m_idsToPubSubState;
        private Dictionary<uint, uint> m_idsToParentId;
        private uint m_nextId = 1;
        #endregion

        #region Public Events
        /// <summary>
        /// Event that is triggered when a published data set is added to the configurator
        /// </summary>
        public event EventHandler<PublishedDataSetEventArgs> PublishedDataSetAdded;

        /// <summary>
        /// Event that is triggered when a published data set is removed from the configurator
        /// </summary>
        public event EventHandler<PublishedDataSetEventArgs> PublishedDataSetRemoved;

        /// <summary>
        /// Event that is triggered when an extension field is added to a published data set
        /// </summary>
        public event EventHandler<ExtensionFieldEventArgs> ExtensionFieldAdded;

        /// <summary>
        /// Event that is triggered when an extension field is removed from a published data set
        /// </summary>
        public event EventHandler<ExtensionFieldEventArgs> ExtensionFieldRemoved;

        /// <summary>
        /// Event that is triggered when a connection is added to the configurator
        /// </summary>
        public event EventHandler<ConnectionEventArgs> ConnectionAdded;

        /// <summary>
        /// Event that is triggered when a connection is removed from the configurator
        /// </summary>
        public event EventHandler<ConnectionEventArgs> ConnectionRemoved;

        /// <summary>
        /// Event that is triggered when a WriterGroup is added to a connection
        /// </summary>
        public event EventHandler<WriterGroupEventArgs> WriterGroupAdded;

        /// <summary>
        /// Event that is triggered when a WriterGroup is removed from a connection
        /// </summary>
        public event EventHandler<WriterGroupEventArgs> WriterGroupRemoved;

        /// <summary>
        /// Event that is triggered when a ReaderGroup is added to a connection
        /// </summary>
        public event EventHandler<ReaderGroupEventArgs> ReaderGroupAdded;

        /// <summary>
        /// Event that is triggered when a ReaderGroup is removed from a connection
        /// </summary>
        public event EventHandler<ReaderGroupEventArgs> ReaderGroupRemoved;

        /// <summary>
        /// Event that is triggered when a DataSetWriter is added to a WriterGroup
        /// </summary>
        public event EventHandler<DataSetWriterEventArgs> DataSetWriterAdded;

        /// <summary>
        /// Event that is triggered when a DataSetWriter is removed from a WriterGroup
        /// </summary>
        public event EventHandler<DataSetWriterEventArgs> DataSetWriterRemoved;

        /// <summary>
        /// Event that is triggered when a DataSetreader is added to a ReaderGroup
        /// </summary>
        public event EventHandler<DataSetReaderEventArgs> DataSetReaderAdded;

        /// <summary>
        /// Event that is triggered when a DataSetreader is removed from a ReaderGroup
        /// </summary>
        public event EventHandler<DataSetReaderEventArgs> DataSetReaderRemoved;

        /// <summary>
        /// Event raised when the state of a configuration object is changed
        /// </summary>
        public event EventHandler<PubSubStateChangedEventArgs> PubSubStateChanged;

        #endregion

        #region Constructor
        /// <summary>
        /// Create new instance of <see cref="UaPubSubConfigurator"/>.
        /// </summary>
        public UaPubSubConfigurator()
        {
            m_idsToObjects = new Dictionary<uint, object>();
            m_objectsToIds = new Dictionary<object, uint>();
            m_idsToPubSubState = new Dictionary<uint, PubSubState>();
            m_idsToParentId = new Dictionary<uint, uint>();

            m_pubSubConfiguration = new PubSubConfigurationDataType();
            m_pubSubConfiguration.Connections = new PubSubConnectionDataTypeCollection();
            m_pubSubConfiguration.PublishedDataSets = new PublishedDataSetDataTypeCollection();

            //remember configuration id 
            uint id = m_nextId++;
            m_objectsToIds.Add(m_pubSubConfiguration, id);
            m_idsToObjects.Add(id, m_pubSubConfiguration);
            m_idsToPubSubState.Add(id, GetInitialPubSubState(m_pubSubConfiguration));
        }
        #endregion

        #region Properties
        /// <summary>
        /// Get reference to <see cref="PubSubConfigurationDataType"/> instance that maintains the configuration for this <see cref="UaPubSubConfigurator"/>.
        /// </summary>
        public PubSubConfigurationDataType PubSubConfiguration { get { return m_pubSubConfiguration; } }
        #endregion

        #region Public Methods - Find

        /// <summary>
        /// Search a configured <see cref="PublishedDataSetDataType"/> with the specified name and return it
        /// </summary>
        /// <param name="name">Name of the object to be found.
        /// Returns null if name was not found.</param>
        /// <returns></returns>
        public PublishedDataSetDataType FindPublishedDataSetByName(string name)
        {
            foreach(PublishedDataSetDataType publishedDataSet in m_pubSubConfiguration.PublishedDataSets)
            {
                if (name == publishedDataSet.Name)
                {
                    return publishedDataSet;
                }
            }
            return null;
        }


        /// <summary>
        /// Search objects in current configuration and return them
        /// </summary>
        /// <param name="id">Id of the object to be found.
        /// Returns null if id was not found.</param>
        /// <returns></returns>
        public object FindObjectById(uint id)
        {
            if (m_idsToObjects.ContainsKey(id))
            {
                return m_idsToObjects[id];
            }
            return null;
        }

        /// <summary>
        /// Search id for specified configuration object.
        /// </summary>
        /// <param name="configurationObject">The object whose id is searched.</param>
        /// <returns>Returns <see cref="UaPubSubConfigurator.InvalidId"/> if object was not found.</returns>
        public uint FindIdForObject(object configurationObject)
        {
            if (m_objectsToIds.ContainsKey(configurationObject))
            {
                return m_objectsToIds[configurationObject];
            }
            return InvalidId;
        }

        /// <summary>
        /// Search <see cref="PubSubState"/> for specified configuration object.
        /// </summary>
        /// <param name="configurationObject">The object whose <see cref="PubSubState"/> is searched.</param>
        /// <returns>Returns <see cref="PubSubState"/> if the object.</returns>
        public PubSubState FindStateForObject(object configurationObject)
        {
            uint id = FindIdForObject(configurationObject);
            if (m_idsToPubSubState.ContainsKey(id))
            {
                return m_idsToPubSubState[id];
            }
            return PubSubState.Error;
        }

        /// <summary>
        /// Search <see cref="PubSubState"/> for specified configuration object.
        /// </summary>
        /// <param name="id">The id  of the object which <see cref="PubSubState"/> is searched.</param>
        /// <returns>Returns <see cref="PubSubState"/> if the object.</returns>
        public PubSubState FindStateForId(uint id)
        {
            if (m_idsToPubSubState.ContainsKey(id))
            {
                return m_idsToPubSubState[id];
            }
            return PubSubState.Error;
        }
        /// <summary>
        /// Find the parent configuration object for a configuration object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <returns></returns>
        public object FindParentForObject(object configurationObject)
        {
            uint id = FindIdForObject(configurationObject);
            if (id != InvalidId && m_idsToParentId.ContainsKey(id))
            {
                uint parentId = m_idsToParentId[id];
                return FindObjectById(parentId);
            }
            return null;
        }

        /// <summary>
        /// Find children ids for specified object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <returns></returns>
        public List<uint> FindChildrenIdsForObject(object configurationObject)
        {
            uint parentId = FindIdForObject(configurationObject);

            List<uint> childrenIds = new List<uint>();
            if (parentId != InvalidId && m_idsToParentId.ContainsValue(parentId))
            {
                foreach (uint key in m_idsToParentId.Keys)
                {
                    if (m_idsToParentId[key] == parentId)
                    {
                        childrenIds.Add(key);
                    }
                }
            }
            return childrenIds;
        }
        #endregion

        #region Public Methods - LoadConfiguration
        /// <summary>
        /// Load the specified configuration 
        /// </summary>
        /// <param name="configFilePath"></param>
        /// <param name="replaceExisting"> flag that indicates if current configuration is overwritten</param>
        public void LoadConfiguration(string configFilePath, bool replaceExisting = true)
        {
            // validate input argument 
            if (configFilePath == null)
            {
                throw new ArgumentException(nameof(configFilePath));
            }
            if (!File.Exists(configFilePath))
            {
                throw new ArgumentException("The specified file {0} does not exist", configFilePath);
            }
            PubSubConfigurationDataType pubSubConfiguration = UaPubSubConfigurationHelper.LoadConfiguration(configFilePath);

            LoadConfiguration(pubSubConfiguration, replaceExisting);
        }

        /// <summary>
        /// Load the specified configuration 
        /// </summary>
        /// <param name="pubSubConfiguration"></param>
        /// <param name="replaceExisting"> flag that indicates if current configuration is overwritten</param>
        public void LoadConfiguration(PubSubConfigurationDataType pubSubConfiguration, bool replaceExisting = true)
        {
            lock (m_lock)
            {
                if (replaceExisting)
                {
                    //remove previous configured published data sets
                    if (m_pubSubConfiguration != null && m_pubSubConfiguration.PublishedDataSets.Count > 0)
                    {
                        foreach (PublishedDataSetDataType publishedDataSet in pubSubConfiguration.PublishedDataSets)
                        {
                            RemovePublishedDataSet(publishedDataSet);
                        }
                    }

                    //remove previous configured connections
                    if (m_pubSubConfiguration != null && m_pubSubConfiguration.Connections.Count > 0)
                    {
                        foreach (var connection in m_pubSubConfiguration.Connections.ToArray())
                        {
                            RemoveConnection(connection);
                        }
                    }

                    m_pubSubConfiguration.Connections.Clear();
                    m_pubSubConfiguration.PublishedDataSets.Clear();
                }

                //first load Published DataSet information
                foreach (PublishedDataSetDataType publishedDataSet in pubSubConfiguration.PublishedDataSets)
                {
                    AddPublishedDataSet(publishedDataSet);
                }

                foreach (PubSubConnectionDataType pubSubConnectionDataType in pubSubConfiguration.Connections)
                {
                    // handle empty names 
                    if (string.IsNullOrEmpty(pubSubConnectionDataType.Name))
                    {
                        //set default name 
                        pubSubConnectionDataType.Name = "Connection_" + (m_nextId + 1);
                    }
                    AddConnection(pubSubConnectionDataType);
                }
            }
        }
        #endregion

        #region Public Methods - PublishedDataSet
        /// <summary>
        /// Add a published data set to current configuration.
        /// </summary>
        /// <param name="publishedDataSetDataType">The <see cref="PublishedDataSetDataType"/> object to be added to configuration.</param>
        /// <returns></returns>
        public StatusCode AddPublishedDataSet(PublishedDataSetDataType publishedDataSetDataType)
        {
            if (m_objectsToIds.ContainsKey(publishedDataSetDataType))
            {
                throw new ArgumentException("This PublishedDataSetDataType instance is already added to the configuration.");
            }
            try
            {
                lock (m_lock)
                {
                    //validate duplicate name 
                    bool duplicateName = false;
                    foreach (var publishedDataSet in m_pubSubConfiguration.PublishedDataSets)
                    {
                        if (publishedDataSetDataType.Name == publishedDataSet.Name)
                        {
                            duplicateName = true;
                            break;
                        }
                    }
                    if (duplicateName)
                    {
                        Utils.Trace(Utils.TraceMasks.Error, "Attempted to add PublishedDataSetDataType with duplicate name = {0}", publishedDataSetDataType.Name);
                        return StatusCodes.BadBrowseNameDuplicated;
                    }

                    uint newPublishedDataSetId = m_nextId++;
                    //remember connection 
                    m_idsToObjects.Add(newPublishedDataSetId, publishedDataSetDataType);
                    m_objectsToIds.Add(publishedDataSetDataType, newPublishedDataSetId);
                    m_pubSubConfiguration.PublishedDataSets.Add(publishedDataSetDataType);

                    // raise PublishedDataSetAdded event
                    if (PublishedDataSetAdded != null)
                    {
                        PublishedDataSetAdded(this,
                            new PublishedDataSetEventArgs() { PublishedDataSetId = newPublishedDataSetId, PublishedDataSetDataType = publishedDataSetDataType });
                    }

                    if (publishedDataSetDataType.ExtensionFields == null)
                    {
                        publishedDataSetDataType.ExtensionFields = new KeyValuePairCollection();
                    }
                    KeyValuePairCollection extensionFields = new KeyValuePairCollection(publishedDataSetDataType.ExtensionFields);
                    publishedDataSetDataType.ExtensionFields.Clear();
                    foreach (KeyValuePair extensionField in extensionFields)
                    {
                        AddExtensionField(newPublishedDataSetId, extensionField);
                    }
                    return StatusCodes.Good;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddPublishedDataSet: Exception");
            }
            //todo implement state validation
            return StatusCodes.Bad; 
        }

        /// <summary>
        /// Removes a published data set from current configuration.
        /// </summary>
        /// <param name="publishedDataSetId">Id of the published data set to be removed.</param>
        /// <returns> 
        /// - <see cref="StatusCodes.Good"/> if operation is successful, 
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> otherwise.
        /// </returns>
        public StatusCode RemovePublishedDataSet(uint publishedDataSetId)
        {
            lock (m_lock)
            {
                PublishedDataSetDataType publishedDataSetDataType = FindObjectById(publishedDataSetId) as PublishedDataSetDataType;
                if (publishedDataSetDataType == null)
                {
                    // Unexpected exception 
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain PublishedDataSetDataType with ConfigId = {0}", publishedDataSetId);
                    return StatusCodes.Good;
                }
                return RemovePublishedDataSet(publishedDataSetDataType);
            }
        }

        /// <summary>
        /// Removes a published data set from current configuration.
        /// </summary>
        /// <param name="publishedDataSetDataType">The published data set to be removed.</param>
        /// <returns> 
        /// - <see cref="StatusCodes.Good"/> if operation is successful, 
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> otherwise.
        /// </returns>
        public StatusCode RemovePublishedDataSet(PublishedDataSetDataType publishedDataSetDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint publishedDataSetId = FindIdForObject(publishedDataSetDataType);
                    if (publishedDataSetDataType != null && publishedDataSetId != InvalidId)
                    {
                        /*A successful removal of the PublishedDataSetType Object removes all associated DataSetWriter Objects. 
                         * Before the Objects are removed, their state is changed to Disabled_0*/

                        // Find all associated DataSetWriter objects
                        foreach(var connection in m_pubSubConfiguration.Connections)
                        {
                            foreach(var writerGroup in connection.WriterGroups)
                            {
                                foreach(var dataSetWriter in writerGroup.DataSetWriters.ToArray())
                                {
                                    if (dataSetWriter.DataSetName == publishedDataSetDataType.Name)
                                    {
                                        RemoveDataSetWriter(dataSetWriter);
                                    }
                                }
                            }
                        }

                        m_pubSubConfiguration.PublishedDataSets.Remove(publishedDataSetDataType);

                        //remove all references from dictionaries
                        m_idsToObjects.Remove(publishedDataSetId);
                        m_objectsToIds.Remove(publishedDataSetDataType);
                        m_idsToParentId.Remove(publishedDataSetId);
                        m_idsToPubSubState.Remove(publishedDataSetId);

                        if (PublishedDataSetRemoved != null)
                        {
                            PublishedDataSetRemoved(this, new PublishedDataSetEventArgs()
                            {
                                PublishedDataSetId = publishedDataSetId,
                                PublishedDataSetDataType = publishedDataSetDataType
                            });
                        }
                        return StatusCodes.Good;
                    }
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemovePublishedDataSet: Exception");
            }

            return StatusCodes.BadNodeIdUnknown;
        }

        /// <summary>
        /// Add Extension field to the specified publishedDataset
        /// </summary>
        /// <param name="publishedDataSetConfigId"></param>
        /// <param name="extensionField"></param>
        /// <returns></returns>
        public StatusCode AddExtensionField(uint publishedDataSetConfigId, KeyValuePair extensionField)
        {
            lock (m_lock)
            {
                PublishedDataSetDataType publishedDataSetDataType = FindObjectById(publishedDataSetConfigId) as PublishedDataSetDataType;
                if (publishedDataSetDataType == null)
                {
                    return StatusCodes.BadNodeIdInvalid;
                }
                if (publishedDataSetDataType.ExtensionFields == null)
                {
                    publishedDataSetDataType.ExtensionFields = new KeyValuePairCollection();
                }
                else
                {
                    //validate duplicate name 
                    bool duplicateName = false;
                    foreach (KeyValuePair element in publishedDataSetDataType.ExtensionFields)
                    {
                        if (element.Key == extensionField.Key)
                        {
                            duplicateName = true;
                            break;
                        }
                    }
                    if (duplicateName)
                    {
                        Utils.Trace(Utils.TraceMasks.Error, "AddExtensionField -  A field with the name already exists. Duplicate name = {0}", extensionField.Key);
                        return StatusCodes.BadNodeIdExists;
                    }
                }
                uint newextensionFieldId = m_nextId++;
                //remember connection 
                m_idsToObjects.Add(newextensionFieldId, extensionField);
                m_objectsToIds.Add(extensionField, newextensionFieldId);     
                publishedDataSetDataType.ExtensionFields.Add(extensionField);

                // raise ExtensionFieldAdded event
                if (ExtensionFieldAdded != null)
                {
                    ExtensionFieldAdded(this,
                        new ExtensionFieldEventArgs() { PublishedDataSetId = publishedDataSetConfigId, ExtensionFieldId = newextensionFieldId, ExtensionField = extensionField });
                }

                return StatusCodes.Good;
            }
        }            

        /// <summary>
        /// Removes an extension field from a published data set
        /// </summary>
        /// <param name="publishedDataSetConfigId"></param>
        /// <param name="extensionFieldConfigId"></param>
        /// <returns></returns>
        public StatusCode RemoveExtensionField(uint publishedDataSetConfigId, uint extensionFieldConfigId)
        {
            lock (m_lock)
            {
                PublishedDataSetDataType publishedDataSetDataType = FindObjectById(publishedDataSetConfigId) as PublishedDataSetDataType;
                KeyValuePair extensionFieldToRemove = FindObjectById(extensionFieldConfigId) as KeyValuePair;
                if (publishedDataSetDataType == null || extensionFieldToRemove == null)
                {
                    return StatusCodes.BadNodeIdInvalid;
                }
                if (publishedDataSetDataType.ExtensionFields == null)
                {
                    publishedDataSetDataType.ExtensionFields = new KeyValuePairCollection();
                    return StatusCodes.BadNodeIdInvalid;
                }
                // locate the extension field 
                foreach(KeyValuePair extensionField in publishedDataSetDataType.ExtensionFields.ToArray())
                {
                    if (extensionField.Equals(extensionFieldToRemove))
                    {
                        publishedDataSetDataType.ExtensionFields.Remove(extensionFieldToRemove);

                        // raise ExtensionFieldRemoved event
                        if (ExtensionFieldRemoved != null)
                        {
                            ExtensionFieldRemoved(this,
                                new ExtensionFieldEventArgs() { PublishedDataSetId = publishedDataSetConfigId, ExtensionFieldId = extensionFieldConfigId, ExtensionField = extensionField });
                        }
                        return StatusCodes.Good;
                    }
                }                
            }
            return StatusCodes.BadNodeIdInvalid;
        }
        #endregion

        #region Public Methods - Connection
        /// <summary>
        /// Add a connection to current configuration.
        /// </summary>
        /// <param name="pubSubConnectionDataType">The <see cref="PubSubConnectionDataType"/> object that configures the new connection.</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The connection was added with success.
        /// - <see cref="StatusCodes.BadBrowseNameDuplicated"/> An Object with the name already exists.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error adding the connection.
        /// </returns>
        public StatusCode AddConnection(PubSubConnectionDataType pubSubConnectionDataType)
        {
            if (m_objectsToIds.ContainsKey(pubSubConnectionDataType))
            {
                throw new ArgumentException("This PubSubConnectionDataType instance is already added to the configuration.");
            }
            try
            {
                lock (m_lock)
                {
                    //validate connection name 
                    bool duplicateName = false;
                    foreach(var connection in m_pubSubConfiguration.Connections)
                    {
                        if (connection.Name == pubSubConnectionDataType.Name)
                        {
                            duplicateName = true;
                            break;
                        }
                    }
                    if (duplicateName)
                    {
                        Utils.Trace(Utils.TraceMasks.Error, "Attempted to add PubSubConnectionDataType with duplicate name = {0}", pubSubConnectionDataType.Name);
                        return StatusCodes.BadBrowseNameDuplicated;
                    }

                    // remember collections 
                    WriterGroupDataTypeCollection writerGroups = new WriterGroupDataTypeCollection(pubSubConnectionDataType.WriterGroups);
                    pubSubConnectionDataType.WriterGroups.Clear();
                    ReaderGroupDataTypeCollection readerGroups = new ReaderGroupDataTypeCollection(pubSubConnectionDataType.ReaderGroups);
                    pubSubConnectionDataType.ReaderGroups.Clear();

                    uint newConnectionId = m_nextId++;
                    //remember connection 
                    m_idsToObjects.Add(newConnectionId, pubSubConnectionDataType);
                    m_objectsToIds.Add(pubSubConnectionDataType, newConnectionId);
                    // remember parent id
                    m_idsToParentId.Add(newConnectionId, FindIdForObject(m_pubSubConfiguration));
                    //remember initial state
                    m_idsToPubSubState.Add(newConnectionId, GetInitialPubSubState(pubSubConnectionDataType));

                    m_pubSubConfiguration.Connections.Add(pubSubConnectionDataType);

                    // raise ConnectionAdded event
                    if (ConnectionAdded != null)
                    {
                        ConnectionAdded(this,
                            new ConnectionEventArgs() { ConnectionId = newConnectionId, PubSubConnectionDataType = pubSubConnectionDataType });
                    }
                    //handler reader & writer groups 
                    foreach (WriterGroupDataType writerGroup in writerGroups)
                    {
                        // handle empty names 
                        if (string.IsNullOrEmpty(writerGroup.Name))
                        {
                            //set default name 
                            writerGroup.Name = "WriterGroup_" + (m_nextId + 1);
                        }
                        AddWriterGroup(newConnectionId, writerGroup);
                    }
                    foreach (ReaderGroupDataType readerGroup in readerGroups)
                    {
                        // handle empty names 
                        if (string.IsNullOrEmpty(readerGroup.Name))
                        {
                            //set default name 
                            readerGroup.Name = "ReaderGroup_" + (m_nextId + 1);
                        }
                        AddReaderGroup(newConnectionId, readerGroup);
                    }

                    return StatusCodes.Good;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddConnection: Exception");
            }
            return StatusCodes.BadInvalidArgument;
        }

        /// <summary>
        /// Removes a connection from current configuration.
        /// </summary>
        /// <param name="connectionId">Id of the connection to be removed.</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The Connection was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the Connection.
        /// </returns>
        public StatusCode RemoveConnection(uint connectionId)
        {
            lock (m_lock)
            {
                PubSubConnectionDataType pubSubConnectionDataType = FindObjectById(connectionId) as PubSubConnectionDataType;
                if (pubSubConnectionDataType == null)
                {
                    // Unexpected exception 
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain PubSubConnectionDataType with ConfigId = {0}", connectionId);
                    return StatusCodes.BadNodeIdUnknown;
                }
                return RemoveConnection(pubSubConnectionDataType);
            }
        }

        /// <summary>
        /// Removes a connection from current configuration.
        /// </summary>
        /// <param name="pubSubConnectionDataType">The connection to be removed.</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The Connection was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the Connection.
        /// </returns>
        public StatusCode RemoveConnection(PubSubConnectionDataType pubSubConnectionDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint connectionId = FindIdForObject(pubSubConnectionDataType);
                    if (pubSubConnectionDataType != null && connectionId != InvalidId)
                    {
                        // remove children
                        WriterGroupDataTypeCollection writerGroups = new WriterGroupDataTypeCollection(pubSubConnectionDataType.WriterGroups);
                        foreach (var writerGroup in writerGroups)
                        {
                            RemoveWriterGroup(writerGroup);
                        }
                        ReaderGroupDataTypeCollection readerGroups = new ReaderGroupDataTypeCollection(pubSubConnectionDataType.ReaderGroups);
                        foreach (var readerGroup in readerGroups)
                        {
                            RemoveReaderGroup(readerGroup);
                        }
                        m_pubSubConfiguration.Connections.Remove(pubSubConnectionDataType);

                        //remove all references from dictionaries
                        m_idsToObjects.Remove(connectionId);
                        m_objectsToIds.Remove(pubSubConnectionDataType);
                        m_idsToParentId.Remove(connectionId);
                        m_idsToPubSubState.Remove(connectionId);

                        if (ConnectionRemoved != null)
                        {
                            ConnectionRemoved(this, new ConnectionEventArgs()
                            {
                                ConnectionId = connectionId,
                                PubSubConnectionDataType = pubSubConnectionDataType
                            });
                        }
                        return StatusCodes.Good;
                    }
                    return StatusCodes.BadNodeIdUnknown;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemoveConnection: Exception");
            }

            return StatusCodes.BadInvalidArgument;
        }
        #endregion

        #region Public Methods - WriterGroup
        /// <summary>
        /// Adds a writerGroup to the specified connection
        /// </summary>
        /// <param name="parentConnectionId"></param>
        /// <param name="writerGroupDataType"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The WriterGroup was added with success.
        /// - <see cref="StatusCodes.BadBrowseNameDuplicated"/> An Object with the name already exists.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error adding the WriterGroup.
        /// </returns>
        public StatusCode AddWriterGroup(uint parentConnectionId, WriterGroupDataType writerGroupDataType)
        {
            if (m_objectsToIds.ContainsKey(writerGroupDataType))
            {
                throw new ArgumentException("This WriterGroupDataType instance is already added to the configuration.");
            }
            if (!m_idsToObjects.ContainsKey(parentConnectionId))
            {
                throw new ArgumentException(String.Format("There is no connection with configurationId = {0} in current configuration.", parentConnectionId));
            }
            try
            {
                lock (m_lock)
                {
                    // remember collections 
                    DataSetWriterDataTypeCollection dataSetWriters = new DataSetWriterDataTypeCollection(writerGroupDataType.DataSetWriters);
                    writerGroupDataType.DataSetWriters.Clear();
                    PubSubConnectionDataType parentConnection = m_idsToObjects[parentConnectionId] as PubSubConnectionDataType;
                    if (parentConnection != null)
                    {
                        //validate duplicate name 
                        bool duplicateName = false;
                        foreach (var writerGroup in parentConnection.WriterGroups)
                        {
                            if (writerGroup.Name == writerGroupDataType.Name)
                            {
                                duplicateName = true;
                                break;
                            }
                        }
                        if (duplicateName)
                        {
                            Utils.Trace(Utils.TraceMasks.Error, "Attempted to add WriterGroupDataType with duplicate name = {0}", writerGroupDataType.Name);
                            return StatusCodes.BadBrowseNameDuplicated;
                        }

                        uint newWriterGroupId = m_nextId++;
                        //remember writer group 
                        m_idsToObjects.Add(newWriterGroupId, writerGroupDataType);
                        m_objectsToIds.Add(writerGroupDataType, newWriterGroupId);
                        parentConnection.WriterGroups.Add(writerGroupDataType);

                        // remember parent id
                        m_idsToParentId.Add(newWriterGroupId, parentConnectionId);
                        //remember initial state
                        m_idsToPubSubState.Add(newWriterGroupId, GetInitialPubSubState(writerGroupDataType));

                        // raise WriterGroupAdded event
                        if (WriterGroupAdded != null)
                        {
                            WriterGroupAdded(this,
                                new WriterGroupEventArgs() { ConnectionId = parentConnectionId, WriterGroupId = newWriterGroupId, WriterGroupDataType = writerGroupDataType });
                        }

                        //handler datasetWriters
                        foreach (DataSetWriterDataType datasetWriter in dataSetWriters)
                        {
                            // handle empty names 
                            if (string.IsNullOrEmpty(datasetWriter.Name))
                            {
                                //set default name 
                                datasetWriter.Name = "DataSetWriter_" + (m_nextId + 1);
                            }
                            AddDataSetWriter(newWriterGroupId, datasetWriter);
                        }

                        return StatusCodes.Good;
                    }
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddWriterGroup: Exception");
            }
            return StatusCodes.BadInvalidArgument;
        }

        /// <summary>
        /// Removes a WriterGroupDataType instance from current configuration specified by confgiId
        /// </summary>
        /// <param name="writerGroupId"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The WriterGroup was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the WriterGroup.
        /// </returns>
        public StatusCode RemoveWriterGroup(uint writerGroupId)
        {
            lock (m_lock)
            {
                WriterGroupDataType writerGroupDataType = FindObjectById(writerGroupId) as WriterGroupDataType;
                if (writerGroupDataType == null)
                {
                    // Unexpected exception 
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain WriterGroupDataType with ConfigId = {0}", writerGroupId);
                    return StatusCodes.BadNodeIdUnknown;
                }
                return RemoveWriterGroup(writerGroupDataType);
            }
        }

        /// <summary>
        /// Removes a WriterGroupDataType instance from current configuration
        /// </summary>
        /// <param name="writerGroupDataType">Instance to remove</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The WriterGroup was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the WriterGroup.
        /// </returns>
        public StatusCode RemoveWriterGroup(WriterGroupDataType writerGroupDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint writerGroupId = FindIdForObject(writerGroupDataType);
                    if (writerGroupDataType != null && writerGroupId != InvalidId)
                    {
                        // remove children
                        DataSetWriterDataTypeCollection dataSetWriters = new DataSetWriterDataTypeCollection(writerGroupDataType.DataSetWriters);
                        foreach (var dataSetWriter in dataSetWriters)
                        {
                            RemoveDataSetWriter(dataSetWriter);
                        }
                        // find parent connection
                        PubSubConnectionDataType parentConnection = FindParentForObject(writerGroupDataType) as PubSubConnectionDataType;
                        uint parentConnectionId = FindIdForObject(parentConnection);
                        if (parentConnection != null && parentConnectionId != InvalidId)
                        {
                            parentConnection.WriterGroups.Remove(writerGroupDataType);

                            //remove all references from dictionaries
                            m_idsToObjects.Remove(writerGroupId);
                            m_objectsToIds.Remove(writerGroupDataType);
                            m_idsToParentId.Remove(writerGroupId);
                            m_idsToPubSubState.Remove(writerGroupId);

                            if (WriterGroupRemoved != null)
                            {
                                WriterGroupRemoved(this, new WriterGroupEventArgs()
                                {
                                    WriterGroupId = writerGroupId,
                                    WriterGroupDataType = writerGroupDataType,
                                    ConnectionId = parentConnectionId
                                });
                            }
                            return StatusCodes.Good;
                        }
                    }

                    return StatusCodes.BadNodeIdUnknown;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemoveWriterGroup: Exception");
            }

            return StatusCodes.BadInvalidArgument;
        }
        #endregion

        #region Public Methods - DataSetWriter
        /// <summary>
        /// Adds a DataSetWriter to the specified writer group
        /// </summary>
        /// <param name="parentWriterGroupId"></param>
        /// <param name="dataSetWriterDataType"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetWriter was added with success.
        /// - <see cref="StatusCodes.BadBrowseNameDuplicated"/> An Object with the name already exists.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error adding the DataSetWriter.
        /// </returns>
        public StatusCode AddDataSetWriter(uint parentWriterGroupId, DataSetWriterDataType dataSetWriterDataType)
        {
            if (m_objectsToIds.ContainsKey(dataSetWriterDataType))
            {
                throw new ArgumentException("This DataSetWriterDataType instance is already added to the configuration.");
            }
            if (!m_idsToObjects.ContainsKey(parentWriterGroupId))
            {
                throw new ArgumentException(String.Format("There is no WriterGroup with configurationId = {0} in current configuration.", parentWriterGroupId));
            }
            try
            {
                lock (m_lock)
                {
                    WriterGroupDataType parentWriterGroup = m_idsToObjects[parentWriterGroupId] as WriterGroupDataType;
                    if (parentWriterGroup != null)
                    {
                        //validate duplicate name 
                        bool duplicateName = false;
                        foreach (var writer in parentWriterGroup.DataSetWriters)
                        {
                            if (writer.Name == dataSetWriterDataType.Name)
                            {
                                duplicateName = true;
                                break;
                            }
                        }
                        if (duplicateName)
                        {
                            Utils.Trace(Utils.TraceMasks.Error, "Attempted to add DataSetWriterDataType with duplicate name = {0}", dataSetWriterDataType.Name);
                            return StatusCodes.BadBrowseNameDuplicated;
                        }

                        uint newDataSetWriterId = m_nextId++;
                        //remember connection 
                        m_idsToObjects.Add(newDataSetWriterId, dataSetWriterDataType);
                        m_objectsToIds.Add(dataSetWriterDataType, newDataSetWriterId);
                        parentWriterGroup.DataSetWriters.Add(dataSetWriterDataType);

                        // remember parent id
                        m_idsToParentId.Add(newDataSetWriterId, parentWriterGroupId);

                        //remember initial state
                        m_idsToPubSubState.Add(newDataSetWriterId, GetInitialPubSubState(dataSetWriterDataType));

                        // raise DataSetWriterAdded event
                        if (DataSetWriterAdded != null)
                        {
                            DataSetWriterAdded(this,
                                new DataSetWriterEventArgs() { WriterGroupId = parentWriterGroupId, DataSetWriterId = newDataSetWriterId, DataSetWriterDataType = dataSetWriterDataType });
                        }

                        return StatusCodes.Good;
                    }
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddDataSetWriter: Exception");
            }
             return StatusCodes.BadInvalidArgument;
        }

        /// <summary>
        /// Removes a DataSetWriterDataType instance from current configuration specified by confgiId
        /// </summary>
        /// <param name="dataSetWriterId"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetWriter was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the DataSetWriter.
        /// </returns>
        public StatusCode RemoveDataSetWriter(uint dataSetWriterId)
        {
            lock (m_lock)
            {
                DataSetWriterDataType dataSetWriterDataType = FindObjectById(dataSetWriterId) as DataSetWriterDataType;
                if (dataSetWriterDataType == null)
                {
                    // Unexpected exception 
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain DataSetWriterDataType with ConfigId = {0}", dataSetWriterId);
                    return StatusCodes.BadNodeIdUnknown;
                }
                return RemoveDataSetWriter(dataSetWriterDataType);
            }
        }

        /// <summary>
        /// Removes a DataSetWriterDataType instance from current configuration
        /// </summary>
        /// <param name="dataSetWriterDataType">Instance to remove</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetWriter was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the DataSetWriter.
        /// </returns>
        public StatusCode RemoveDataSetWriter(DataSetWriterDataType dataSetWriterDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint dataSetWriterId = FindIdForObject(dataSetWriterDataType);
                    if (dataSetWriterDataType != null && dataSetWriterId != InvalidId)
                    {
                        // find parent writerGroup
                        WriterGroupDataType parentWriterGroup = FindParentForObject(dataSetWriterDataType) as WriterGroupDataType;
                        uint parentWriterGroupId = FindIdForObject(parentWriterGroup);
                        if (parentWriterGroup != null && parentWriterGroupId != InvalidId)
                        {
                            parentWriterGroup.DataSetWriters.Remove(dataSetWriterDataType);

                            //remove all references from dictionaries
                            m_idsToObjects.Remove(dataSetWriterId);
                            m_objectsToIds.Remove(dataSetWriterDataType);
                            m_idsToParentId.Remove(dataSetWriterId);
                            m_idsToPubSubState.Remove(dataSetWriterId);

                            if (DataSetWriterRemoved != null)
                            {
                                DataSetWriterRemoved(this, new DataSetWriterEventArgs()
                                {
                                    WriterGroupId = parentWriterGroupId,
                                    DataSetWriterDataType = dataSetWriterDataType,
                                    DataSetWriterId = dataSetWriterId
                                });
                            }
                            return StatusCodes.Good;
                        }
                    }
                    return StatusCodes.BadNodeIdUnknown;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemoveDataSetWriter: Exception");
            }

            return StatusCodes.BadInvalidArgument;
        }
        #endregion

        #region Public Methods - ReaderGroup
        /// <summary>
        /// Adds a readerGroup to the specified connection
        /// </summary>
        /// <param name="parentConnectionId"></param>
        /// <param name="readerGroupDataType"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The ReaderGroup was added with success.
        /// - <see cref="StatusCodes.BadBrowseNameDuplicated"/> An Object with the name already exists.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error adding the ReaderGroup.
        /// </returns>
        public StatusCode AddReaderGroup(uint parentConnectionId, ReaderGroupDataType readerGroupDataType)
        {
            if (m_objectsToIds.ContainsKey(readerGroupDataType))
            {
                throw new ArgumentException("This ReaderGroupDataType instance is already added to the configuration.");
            }
            if (!m_idsToObjects.ContainsKey(parentConnectionId))
            {
                throw new ArgumentException(String.Format("There is no connection with configurationId = {0} in current configuration.", parentConnectionId));
            }
            try
            {
                lock (m_lock)
                {
                    // remember collections 
                    DataSetReaderDataTypeCollection dataSetReaders = new DataSetReaderDataTypeCollection(readerGroupDataType.DataSetReaders);
                    readerGroupDataType.DataSetReaders.Clear();
                    PubSubConnectionDataType parentConnection = m_idsToObjects[parentConnectionId] as PubSubConnectionDataType;
                    if (parentConnection != null)
                    {
                        //validate duplicate name 
                        bool duplicateName = false;
                        foreach (var readerGroup in parentConnection.ReaderGroups)
                        {
                            if (readerGroup.Name == readerGroupDataType.Name)
                            {
                                duplicateName = true;
                                break;
                            }
                        }
                        if (duplicateName)
                        {
                            Utils.Trace(Utils.TraceMasks.Error, "Attempted to add ReaderGroupDataType with duplicate name = {0}", readerGroupDataType.Name);
                            return StatusCodes.BadBrowseNameDuplicated;
                        }

                        uint newReaderGroupId = m_nextId++;
                        //remember reader group 
                        m_idsToObjects.Add(newReaderGroupId, readerGroupDataType);
                        m_objectsToIds.Add(readerGroupDataType, newReaderGroupId);
                        parentConnection.ReaderGroups.Add(readerGroupDataType);

                        // remember parent id
                        m_idsToParentId.Add(newReaderGroupId, parentConnectionId);

                        //remember initial state
                        m_idsToPubSubState.Add(newReaderGroupId, GetInitialPubSubState(readerGroupDataType));

                        // raise ReaderGroupAdded event
                        if (ReaderGroupAdded != null)
                        {
                            ReaderGroupAdded(this,
                                new ReaderGroupEventArgs() { ConnectionId = parentConnectionId, ReaderGroupId = newReaderGroupId, ReaderGroupDataType = readerGroupDataType });
                        }

                        //handler datasetWriters
                        foreach (DataSetReaderDataType datasetReader in dataSetReaders)
                        {
                            // handle empty names 
                            if (string.IsNullOrEmpty(datasetReader.Name))
                            {
                                //set default name 
                                datasetReader.Name = "DataSetReader_" + (m_nextId + 1);
                            }
                            AddDataSetReader(newReaderGroupId, datasetReader);
                        }

                        return StatusCodes.Good;
                    }
                   
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddReaderGroup: Exception");
            }
            return StatusCodes.BadInvalidArgument;
        }

        /// <summary>
        /// Removes a ReaderGroupDataType instance from current configuration specified by confgiId
        /// </summary>
        /// <param name="readerGroupId"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The ReaderGroup was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the ReaderGroup.
        /// </returns>
        public StatusCode RemoveReaderGroup(uint readerGroupId)
        {
            lock (m_lock)
            {
                ReaderGroupDataType readerGroupDataType = FindObjectById(readerGroupId) as ReaderGroupDataType;
                if (readerGroupDataType == null)
                {
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain ReaderGroupDataType with ConfigId = {0}", readerGroupId);
                    return StatusCodes.BadInvalidArgument;
                }
                return RemoveReaderGroup(readerGroupDataType);
            }
        }

        /// <summary>
        /// Removes a ReaderGroupDataType instance from current configuration
        /// </summary>
        /// <param name="readerGroupDataType">Instance to remove</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The ReaderGroup was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the ReaderGroup.
        /// </returns>
        public StatusCode RemoveReaderGroup(ReaderGroupDataType readerGroupDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint readerGroupId = FindIdForObject(readerGroupDataType);
                    if (readerGroupDataType != null && readerGroupId != InvalidId)
                    {
                        // remove children
                        DataSetReaderDataTypeCollection dataSetReaders = new DataSetReaderDataTypeCollection(readerGroupDataType.DataSetReaders);
                        foreach (var dataSetReader in dataSetReaders)
                        {
                            RemoveDataSetReader(dataSetReader);
                        }
                        // find parent connection
                        PubSubConnectionDataType parentConnection = FindParentForObject(readerGroupDataType) as PubSubConnectionDataType;
                        uint parentConnectionId = FindIdForObject(parentConnection);
                        if (parentConnection != null && parentConnectionId != InvalidId)
                        {
                            parentConnection.ReaderGroups.Remove(readerGroupDataType);

                            //remove all references from dictionaries
                            m_idsToObjects.Remove(readerGroupId);
                            m_objectsToIds.Remove(readerGroupDataType);
                            m_idsToParentId.Remove(readerGroupId);
                            m_idsToPubSubState.Remove(readerGroupId);

                            if (ReaderGroupRemoved != null)
                            {
                                ReaderGroupRemoved(this, new ReaderGroupEventArgs()
                                {
                                    ReaderGroupId = readerGroupId,
                                    ReaderGroupDataType = readerGroupDataType,
                                    ConnectionId = parentConnectionId
                                });
                            }
                            return StatusCodes.Good;
                        }
                    }

                    return StatusCodes.BadNodeIdUnknown;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemoveReaderGroup: Exception");
            }

            return StatusCodes.BadInvalidArgument;
        }
        #endregion

        #region Public Methods - DataSetReader
        /// <summary>
        /// Adds a DataSetReader to the specified reader group
        /// </summary>
        /// <param name="parentReaderGroupId"></param>
        /// <param name="dataSetReaderDataType"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetReader was added with success.
        /// - <see cref="StatusCodes.BadBrowseNameDuplicated"/> An Object with the name already exists.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error adding the DataSetReader.
        /// </returns>
        public StatusCode AddDataSetReader(uint parentReaderGroupId, DataSetReaderDataType dataSetReaderDataType)
        {
            if (m_objectsToIds.ContainsKey(dataSetReaderDataType))
            {
                throw new ArgumentException("This DataSetReaderDataType instance is already added to the configuration.");
            }
            if (!m_idsToObjects.ContainsKey(parentReaderGroupId))
            {
                throw new ArgumentException(String.Format("There is no ReaderGroup with configurationId = {0} in current configuration.", parentReaderGroupId));
            }
            try
            {
                lock (m_lock)
                {
                    ReaderGroupDataType parentReaderGroup = m_idsToObjects[parentReaderGroupId] as ReaderGroupDataType;
                    if (parentReaderGroup != null)
                    {
                        //validate duplicate name 
                        bool duplicateName = false;
                        foreach (var reader in parentReaderGroup.DataSetReaders)
                        {
                            if (reader.Name == dataSetReaderDataType.Name)
                            {
                                duplicateName = true;
                                break;
                            }
                        }
                        if (duplicateName)
                        {
                            Utils.Trace(Utils.TraceMasks.Error, "Attempted to add DataSetReaderDataType with duplicate name = {0}", dataSetReaderDataType.Name);
                            return StatusCodes.BadBrowseNameDuplicated;
                        }

                        uint newDataSetReaderId = m_nextId++;
                        //remember connection 
                        m_idsToObjects.Add(newDataSetReaderId, dataSetReaderDataType);
                        m_objectsToIds.Add(dataSetReaderDataType, newDataSetReaderId);
                        parentReaderGroup.DataSetReaders.Add(dataSetReaderDataType);

                        // remember parent id
                        m_idsToParentId.Add(newDataSetReaderId, parentReaderGroupId);

                        //remember initial state
                        m_idsToPubSubState.Add(newDataSetReaderId, GetInitialPubSubState(dataSetReaderDataType));

                        // raise WriterGroupAdded event
                        if (DataSetReaderAdded != null)
                        {
                            DataSetReaderAdded(this,
                                new DataSetReaderEventArgs() { ReaderGroupId = parentReaderGroupId, DataSetReaderId = newDataSetReaderId, DataSetReaderDataType = dataSetReaderDataType });
                        }

                        return StatusCodes.Good;
                    }
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddDataSetReader: Exception");
            }
            return StatusCodes.BadInvalidArgument;
        }

        /// <summary>
        /// Removes a DataSetReaderDataType instance from current configuration specified by confgiId
        /// </summary>
        /// <param name="dataSetReaderId"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetWriter was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the DataSetWriter.
        /// </returns>
        public StatusCode RemoveDataSetReader(uint dataSetReaderId)
        {
            lock (m_lock)
            {
                DataSetReaderDataType dataSetReaderDataType = FindObjectById(dataSetReaderId) as DataSetReaderDataType;
                if (dataSetReaderDataType == null)
                {
                    // Unexpected exception 
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain DataSetReaderDataType with ConfigId = {0}", dataSetReaderId);
                    return StatusCodes.BadNodeIdUnknown;
                }
                return RemoveDataSetReader(dataSetReaderDataType);
            }
        }

        /// <summary>
        /// Removes a DataSetReaderDataType instance from current configuration
        /// </summary>
        /// <param name="dataSetReaderDataType">Instance to remove</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetWriter was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the DataSetWriter.
        /// </returns>
        public StatusCode RemoveDataSetReader(DataSetReaderDataType dataSetReaderDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint dataSetReaderId = FindIdForObject(dataSetReaderDataType);
                    if (dataSetReaderDataType != null && dataSetReaderId != InvalidId)
                    {
                        // find parent readerGroup
                        ReaderGroupDataType parentWriterGroup = FindParentForObject(dataSetReaderDataType) as ReaderGroupDataType;
                        uint parenReaderGroupId = FindIdForObject(parentWriterGroup);
                        if (parentWriterGroup != null && parenReaderGroupId != InvalidId)
                        {
                            parentWriterGroup.DataSetReaders.Remove(dataSetReaderDataType);

                            //remove all references from dictionaries
                            m_idsToObjects.Remove(dataSetReaderId);
                            m_objectsToIds.Remove(dataSetReaderDataType);
                            m_idsToParentId.Remove(dataSetReaderId);
                            m_idsToPubSubState.Remove(dataSetReaderId);

                            if (DataSetReaderRemoved != null)
                            {
                                DataSetReaderRemoved(this, new DataSetReaderEventArgs()
                                {
                                    ReaderGroupId = parenReaderGroupId,
                                    DataSetReaderDataType = dataSetReaderDataType,
                                    DataSetReaderId = dataSetReaderId
                                });
                            }
                            return StatusCodes.Good;
                        }
                    }
                    return StatusCodes.BadNodeIdUnknown;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemoveDataSetReader: Exception");
            }

            return StatusCodes.BadInvalidArgument;
        }
        #endregion

        #region Public Methods - Enable/Disable
        /// <summary> 
        /// Enable the specified configuration object specified by Id
        /// </summary>
        /// <param name="configurationId"></param>
        /// <returns></returns>
        public StatusCode Enable(uint configurationId)
        {
            return Enable(FindObjectById(configurationId));
        }

        /// <summary>
        /// Enable the specified configuration object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <returns></returns>
        public StatusCode Enable(object configurationObject)
        {
            if (configurationObject == null)
            {
                throw new ArgumentException("The parameter cannot be null.", nameof(configurationObject));
            }
            if (!m_objectsToIds.ContainsKey(configurationObject))
            {
                throw new ArgumentException("This {0} instance is not part of current configuration.", configurationObject.GetType().Name);
            }
            PubSubState currentState = FindStateForObject(configurationObject);
            if (currentState != PubSubState.Disabled)
            {
                Utils.Trace(Utils.TraceMasks.Information, "Attempted to call Enable() on an object that is not in Disabled state");
                return StatusCodes.BadInvalidState;
            }
            PubSubState parentState = PubSubState.Operational;
            if (configurationObject != m_pubSubConfiguration)
            {
                parentState = FindStateForObject(FindParentForObject(configurationObject));
            }

            if (parentState == PubSubState.Operational)
            {
                // Enabled and parent Operational
                SetStateForObject(configurationObject, PubSubState.Operational);
            }
            else
            {
                // Enabled but parent not Operational
                SetStateForObject(configurationObject, PubSubState.Paused);
            }
            UpdateChildrenState(configurationObject);
            return StatusCodes.Good;
        }


        /// <summary> 
        /// Disable the specified configuration object specified by Id
        /// </summary>
        /// <param name="configurationId"></param>
        /// <returns></returns>
        public StatusCode Disable(uint configurationId)
        {
            return Disable(FindObjectById(configurationId));
        }

        /// <summary>
        /// Disable the specified configuration object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <returns></returns>
        public StatusCode Disable(object configurationObject)
        {
            if (configurationObject == null)
            {
                throw new ArgumentException("The parameter cannot be null.", nameof(configurationObject));
            }
            if (!m_objectsToIds.ContainsKey(configurationObject))
            {
                throw new ArgumentException("This {0} instance is not part of current configuration.", configurationObject.GetType().Name);
            }
            PubSubState currentState = FindStateForObject(configurationObject);
            if (currentState == PubSubState.Disabled)
            {
                Utils.Trace(Utils.TraceMasks.Information, "Attempted to call Disable() on an object that is already in Disabled state");
                return StatusCodes.BadInvalidState;
            }

            SetStateForObject(configurationObject, PubSubState.Disabled);

            UpdateChildrenState(configurationObject);
            return StatusCodes.Good;
        }
        #endregion

        #region Private Methods

        /// <summary>
        /// Change state for the specified configuration object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <param name="newState"></param>
        private void SetStateForObject(object configurationObject, PubSubState newState)
        {
            uint id = FindIdForObject(configurationObject);
            if (id != InvalidId && m_idsToPubSubState.ContainsKey(id))
            {
                PubSubState oldState = m_idsToPubSubState[id];
                m_idsToPubSubState[id] = newState;
                if (PubSubStateChanged != null)
                {
                    PubSubStateChanged(this, new PubSubStateChangedEventArgs()
                    {
                        ConfigurationObject = configurationObject,
                        ConfigurationObjectId = id,
                        NewState = newState,
                        OldState = oldState
                    });
                }
                bool configurationObjectEnabled = (newState == PubSubState.Operational || newState == PubSubState.Paused);
                //update the Enabled flag in config object
                if (configurationObject is PubSubConfigurationDataType pubSubConfigurationDataType)
                {
                    pubSubConfigurationDataType.Enabled = configurationObjectEnabled;
                }
                else if (configurationObject is PubSubConnectionDataType pubSubConnectionDataType)
                {
                    pubSubConnectionDataType.Enabled = configurationObjectEnabled;
                }
                else if (configurationObject is WriterGroupDataType writerGroupDataType)
                {
                    writerGroupDataType.Enabled = configurationObjectEnabled;
                }
                else if (configurationObject is DataSetWriterDataType dataSetWriterDataType)
                {
                    dataSetWriterDataType.Enabled = configurationObjectEnabled;
                }
                else if (configurationObject is ReaderGroupDataType readerGroupDataType)
                {
                    readerGroupDataType.Enabled = configurationObjectEnabled;
                }
                else if (configurationObject is DataSetReaderDataType dataSetReaderDataType)
                {
                    dataSetReaderDataType.Enabled = configurationObjectEnabled;
                }
            }
        }

        /// <summary>
        /// Calculate and update the state for child objects of a configuration object (StATE MACHINE)
        /// </summary>
        /// <param name="configurationObject"></param>
        private void UpdateChildrenState(object configurationObject)
        {
            PubSubState parentState = FindStateForObject(configurationObject);
            //find child ids
            var childrenIds = FindChildrenIdsForObject(configurationObject);
            if (parentState == PubSubState.Operational)
            {
                // Enabled and parent Operational
                foreach (uint childId in childrenIds)
                {
                    PubSubState childState = FindStateForId(childId);
                    if (childState == PubSubState.Paused)
                    {
                        // become Operational if Parent changed to Operational
                        object childObject = FindObjectById(childId);
                        SetStateForObject(childObject, PubSubState.Operational);

                        UpdateChildrenState(childObject);
                    }
                }
            }
            else if (parentState == PubSubState.Disabled || parentState == PubSubState.Paused)
            {
                // Parent changed to Disabled or Paused
                foreach (uint childId in childrenIds)
                {
                    PubSubState childState = FindStateForId(childId);
                    if (childState == PubSubState.Operational || childState == PubSubState.Error)
                    {
                        // become Operational if Parent changed to Operational
                        object childObject = FindObjectById(childId);
                        SetStateForObject(childObject, PubSubState.Paused);

                        UpdateChildrenState(childObject);
                    }
                }
            }
        }

        /// <summary>
        /// Get <see cref="PubSubState"/> for an item depending on enabled flag and parent's <see cref="PubSubState"/>.
        /// </summary>
        /// <param name="enabled">Configured Enabled flag. </param>
        /// <param name="parentPubSubState"><see cref="PubSubState"/> of the parent configured object.</param>
        /// <returns></returns>
        private PubSubState GetInitialPubSubState(bool enabled, PubSubState parentPubSubState)
        {
            if (enabled)
            {
                if (parentPubSubState == PubSubState.Operational)
                {
                    // The PubSub component is operational.
                    return PubSubState.Operational;
                }
                else
                {
                    // The PubSub component is enabled but currently paused by a parent component. The
                    // parent component is either Disabled_0 or Paused_1.
                    return PubSubState.Paused;
                }
            }
            else
            {
                // PubSub component is configured but currently disabled.
                return PubSubState.Disabled;
            }
        }

        /// <summary>
        /// Calculate and return the initial state of a pub sub data type configuration object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <returns></returns>
        private PubSubState GetInitialPubSubState(object configurationObject)
        {
            bool configurationObjectEnabled = false;
            PubSubState parentPubSubState = PubSubState.Operational;
            uint parentId = InvalidId;

            if (configurationObject is PubSubConfigurationDataType pubSubConfigurationDataType)
            {
                configurationObjectEnabled = pubSubConfigurationDataType.Enabled;
            }
            else if (configurationObject is PubSubConnectionDataType pubSubConnectionDataType)
            {
                configurationObjectEnabled = pubSubConnectionDataType.Enabled;
                //find parent state 
                parentPubSubState = FindStateForObject(m_pubSubConfiguration);
            }
            else if (configurationObject is WriterGroupDataType writerGroupDataType)
            {
                configurationObjectEnabled = writerGroupDataType.Enabled;
                //find parent connection
                object parentConnection = FindParentForObject(configurationObject);
                //find parent state 
                parentPubSubState = FindStateForObject(parentConnection);
            }
            else if (configurationObject is DataSetWriterDataType dataSetWriterDataType)
            {
                configurationObjectEnabled = dataSetWriterDataType.Enabled;
                //find parent 
                object parentWriterGroup = FindParentForObject(configurationObject);
                //find parent state 
                parentPubSubState = FindStateForObject(parentWriterGroup);
            }
            else if (configurationObject is ReaderGroupDataType readerGroupDataType)
            {
                configurationObjectEnabled = readerGroupDataType.Enabled;
                //find parent connection
                object parentConnection = FindParentForObject(configurationObject);
                //find parent state 
                parentPubSubState = FindStateForObject(parentConnection);
            }
            else if (configurationObject is DataSetReaderDataType dataSetReaderDataType)
            {
                configurationObjectEnabled = dataSetReaderDataType.Enabled;
                //find parent 
                object parentReaderGroup = FindParentForObject(configurationObject);
                //find parent state 
                parentPubSubState = FindStateForObject(parentReaderGroup);
            }
            else
            {
                return PubSubState.Error;
            }
            return GetInitialPubSubState(configurationObjectEnabled, parentPubSubState);
        }
        #endregion
    }
}

---- Transformed Tree ----
using System;
using System.Collections.Generic;
using System.IO;

namespace Opc.Ua.PubSub.Configuration
{
    /// <summary>
    /// Entity responsible to configure a PubSub Application
    /// 
    /// It has methods for adding/removing configuration objects to a root <see cref="PubSubConfigurationDataType"/> object.
    /// When the root <see cref="PubSubConfigurationDataType"/> object is modified there are various events raised to allow reaction to configuration changes.
    /// Each child object from parent <see cref="PubSubConfigurationDataType"/> object has a configurationId associated to it and it can be used to alter configuration. 
    /// The configurationId can be obtained using the <see cref="UaPubSubConfigurator.FindIdForObject(object)"/> method.
    /// </summary>
    public class UaPubSubConfigurator
    {
        #region Private Fields
        /// <summary>
        /// Value of an uninitialized identifier.
        /// </summary>
        internal static uint InvalidId = 0;

        private object m_lock = new object();
        private PubSubConfigurationDataType m_pubSubConfiguration;
        private Dictionary<uint, object> m_idsToObjects;
        private Dictionary<object, uint> m_objectsToIds;
        private Dictionary<uint, PubSubState> m_idsToPubSubState;
        private Dictionary<uint, uint> m_idsToParentId;
        private uint m_nextId = 1;
        #endregion

        #region Public Events
        /// <summary>
        /// Event that is triggered when a published data set is added to the configurator
        /// </summary>
        public event EventHandler<PublishedDataSetEventArgs> PublishedDataSetAdded;

        /// <summary>
        /// Event that is triggered when a published data set is removed from the configurator
        /// </summary>
        public event EventHandler<PublishedDataSetEventArgs> PublishedDataSetRemoved;

        /// <summary>
        /// Event that is triggered when an extension field is added to a published data set
        /// </summary>
        public event EventHandler<ExtensionFieldEventArgs> ExtensionFieldAdded;

        /// <summary>
        /// Event that is triggered when an extension field is removed from a published data set
        /// </summary>
        public event EventHandler<ExtensionFieldEventArgs> ExtensionFieldRemoved;

        /// <summary>
        /// Event that is triggered when a connection is added to the configurator
        /// </summary>
        public event EventHandler<ConnectionEventArgs> ConnectionAdded;

        /// <summary>
        /// Event that is triggered when a connection is removed from the configurator
        /// </summary>
        public event EventHandler<ConnectionEventArgs> ConnectionRemoved;

        /// <summary>
        /// Event that is triggered when a WriterGroup is added to a connection
        /// </summary>
        public event EventHandler<WriterGroupEventArgs> WriterGroupAdded;

        /// <summary>
        /// Event that is triggered when a WriterGroup is removed from a connection
        /// </summary>
        public event EventHandler<WriterGroupEventArgs> WriterGroupRemoved;

        /// <summary>
        /// Event that is triggered when a ReaderGroup is added to a connection
        /// </summary>
        public event EventHandler<ReaderGroupEventArgs> ReaderGroupAdded;

        /// <summary>
        /// Event that is triggered when a ReaderGroup is removed from a connection
        /// </summary>
        public event EventHandler<ReaderGroupEventArgs> ReaderGroupRemoved;

        /// <summary>
        /// Event that is triggered when a DataSetWriter is added to a WriterGroup
        /// </summary>
        public event EventHandler<DataSetWriterEventArgs> DataSetWriterAdded;

        /// <summary>
        /// Event that is triggered when a DataSetWriter is removed from a WriterGroup
        /// </summary>
        public event EventHandler<DataSetWriterEventArgs> DataSetWriterRemoved;

        /// <summary>
        /// Event that is triggered when a DataSetreader is added to a ReaderGroup
        /// </summary>
        public event EventHandler<DataSetReaderEventArgs> DataSetReaderAdded;

        /// <summary>
        /// Event that is triggered when a DataSetreader is removed from a ReaderGroup
        /// </summary>
        public event EventHandler<DataSetReaderEventArgs> DataSetReaderRemoved;

        /// <summary>
        /// Event raised when the state of a configuration object is changed
        /// </summary>
        public event EventHandler<PubSubStateChangedEventArgs> PubSubStateChanged;

        #endregion

        #region Constructor
        /// <summary>
        /// Create new instance of <see cref="UaPubSubConfigurator"/>.
        /// </summary>
        public UaPubSubConfigurator()
        {
            m_idsToObjects = new Dictionary<uint, object>();
            m_objectsToIds = new Dictionary<object, uint>();
            m_idsToPubSubState = new Dictionary<uint, PubSubState>();
            m_idsToParentId = new Dictionary<uint, uint>();

            m_pubSubConfiguration = new PubSubConfigurationDataType();
            m_pubSubConfiguration.Connections = new PubSubConnectionDataTypeCollection();
            m_pubSubConfiguration.PublishedDataSets = new PublishedDataSetDataTypeCollection();

            //remember configuration id 
            uint id = m_nextId++;
            m_objectsToIds.Add(m_pubSubConfiguration, id);
            m_idsToObjects.Add(id, m_pubSubConfiguration);
            m_idsToPubSubState.Add(id, GetInitialPubSubState(m_pubSubConfiguration));
        }
        #endregion

        #region Properties
        /// <summary>
        /// Get reference to <see cref="PubSubConfigurationDataType"/> instance that maintains the configuration for this <see cref="UaPubSubConfigurator"/>.
        /// </summary>
        public PubSubConfigurationDataType PubSubConfiguration { get { return m_pubSubConfiguration; } }
        #endregion

        #region Public Methods - Find

        /// <summary>
        /// Search a configured <see cref="PublishedDataSetDataType"/> with the specified name and return it
        /// </summary>
        /// <param name="name">Name of the object to be found.
        /// Returns null if name was not found.</param>
        /// <returns></returns>
        public PublishedDataSetDataType FindPublishedDataSetByName(string name)
        {
            foreach(PublishedDataSetDataType publishedDataSet in m_pubSubConfiguration.PublishedDataSets)
            {
                if (name == publishedDataSet.Name)
                {
                    return publishedDataSet;
                }
            }
            return null;
        }


        /// <summary>
        /// Search objects in current configuration and return them
        /// </summary>
        /// <param name="id">Id of the object to be found.
        /// Returns null if id was not found.</param>
        /// <returns></returns>
        public object FindObjectById(uint id)
        {
            if (m_idsToObjects.ContainsKey(id))
            {
                return m_idsToObjects[id];
            }
            return null;
        }

        /// <summary>
        /// Search id for specified configuration object.
        /// </summary>
        /// <param name="configurationObject">The object whose id is searched.</param>
        /// <returns>Returns <see cref="UaPubSubConfigurator.InvalidId"/> if object was not found.</returns>
        public uint FindIdForObject(object configurationObject)
        {
            if (m_objectsToIds.ContainsKey(configurationObject))
            {
                return m_objectsToIds[configurationObject];
            }
            return InvalidId;
        }

        /// <summary>
        /// Search <see cref="PubSubState"/> for specified configuration object.
        /// </summary>
        /// <param name="configurationObject">The object whose <see cref="PubSubState"/> is searched.</param>
        /// <returns>Returns <see cref="PubSubState"/> if the object.</returns>
        public PubSubState FindStateForObject(object configurationObject)
        {
            uint id = FindIdForObject(configurationObject);
            if (m_idsToPubSubState.ContainsKey(id))
            {
                return m_idsToPubSubState[id];
            }
            return PubSubState.Error;
        }

        /// <summary>
        /// Search <see cref="PubSubState"/> for specified configuration object.
        /// </summary>
        /// <param name="id">The id  of the object which <see cref="PubSubState"/> is searched.</param>
        /// <returns>Returns <see cref="PubSubState"/> if the object.</returns>
        public PubSubState FindStateForId(uint id)
        {
            if (m_idsToPubSubState.ContainsKey(id))
            {
                return m_idsToPubSubState[id];
            }
            return PubSubState.Error;
        }
        /// <summary>
        /// Find the parent configuration object for a configuration object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <returns></returns>
        public object FindParentForObject(object configurationObject)
        {
            uint id = FindIdForObject(configurationObject);
            if (id != InvalidId && m_idsToParentId.ContainsKey(id))
            {
                uint parentId = m_idsToParentId[id];
                return FindObjectById(parentId);
            }
            return null;
        }

        /// <summary>
        /// Find children ids for specified object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <returns></returns>
        public List<uint> FindChildrenIdsForObject(object configurationObject)
        {
            uint parentId = FindIdForObject(configurationObject);

            List<uint> childrenIds = new List<uint>();
            if (parentId != InvalidId && m_idsToParentId.ContainsValue(parentId))
            {
                foreach (uint key in m_idsToParentId.Keys)
                {
                    if (m_idsToParentId[key] == parentId)
                    {
                        childrenIds.Add(key);
                    }
                }
            }
            return childrenIds;
        }
        #endregion

        #region Public Methods - LoadConfiguration
        /// <summary>
        /// Load the specified configuration 
        /// </summary>
        /// <param name="configFilePath"></param>
        /// <param name="replaceExisting"> flag that indicates if current configuration is overwritten</param>
        public void LoadConfiguration(string configFilePath, bool replaceExisting = true)
        {
            // validate input argument 
            if (configFilePath == null)
            {
                throw new ArgumentException(nameof(configFilePath));
            }
            if (!File.Exists(configFilePath))
            {
                throw new ArgumentException("The specified file {0} does not exist", configFilePath);
            }
            PubSubConfigurationDataType pubSubConfiguration = UaPubSubConfigurationHelper.LoadConfiguration(configFilePath);

            LoadConfiguration(pubSubConfiguration, replaceExisting);
        }

        /// <summary>
        /// Load the specified configuration 
        /// </summary>
        /// <param name="pubSubConfiguration"></param>
        /// <param name="replaceExisting"> flag that indicates if current configuration is overwritten</param>
        public void LoadConfiguration(PubSubConfigurationDataType pubSubConfiguration, bool replaceExisting = true)
        {
            lock (m_lock)
            {
                if (replaceExisting)
                {
                    //remove previous configured published data sets
                    if (m_pubSubConfiguration != null && m_pubSubConfiguration.PublishedDataSets.Count > 0)
                    {
                        foreach (PublishedDataSetDataType publishedDataSet in pubSubConfiguration.PublishedDataSets)
                        {
                            RemovePublishedDataSet(publishedDataSet);
                        }
                    }

                    //remove previous configured connections
                    if (m_pubSubConfiguration != null && m_pubSubConfiguration.Connections.Count > 0)
                    {
                        foreach (var connection in m_pubSubConfiguration.Connections.ToArray())
                        {
                            RemoveConnection(connection);
                        }
                    }

                    m_pubSubConfiguration.Connections.Clear();
                    m_pubSubConfiguration.PublishedDataSets.Clear();
                }

                //first load Published DataSet information
                foreach (PublishedDataSetDataType publishedDataSet in pubSubConfiguration.PublishedDataSets)
                {
                    AddPublishedDataSet(publishedDataSet);
                }

                foreach (PubSubConnectionDataType pubSubConnectionDataType in pubSubConfiguration.Connections)
                {
                    // handle empty names 
                    if (string.IsNullOrEmpty(pubSubConnectionDataType.Name))
                    {
                        //set default name 
                        pubSubConnectionDataType.Name = "Connection_" + (m_nextId + 1);
                    }
                    AddConnection(pubSubConnectionDataType);
                }
            }
        }
        #endregion

        #region Public Methods - PublishedDataSet
        /// <summary>
        /// Add a published data set to current configuration.
        /// </summary>
        /// <param name="publishedDataSetDataType">The <see cref="PublishedDataSetDataType"/> object to be added to configuration.</param>
        /// <returns></returns>
        public StatusCode AddPublishedDataSet(PublishedDataSetDataType publishedDataSetDataType)
        {
            if (m_objectsToIds.ContainsKey(publishedDataSetDataType))
            {
                throw new ArgumentException("This PublishedDataSetDataType instance is already added to the configuration.");
            }
            try
            {
                lock (m_lock)
                {
                    //validate duplicate name 
                    bool duplicateName = false;
                    foreach (var publishedDataSet in m_pubSubConfiguration.PublishedDataSets)
                    {
                        if (publishedDataSetDataType.Name == publishedDataSet.Name)
                        {
                            duplicateName = true;
                            break;
                        }
                    }
                    if (duplicateName)
                    {
                        Utils.Trace(Utils.TraceMasks.Error, "Attempted to add PublishedDataSetDataType with duplicate name = {0}", publishedDataSetDataType.Name);
                        return StatusCodes.BadBrowseNameDuplicated;
                    }

                    uint newPublishedDataSetId = m_nextId++;
                    //remember connection 
                    m_idsToObjects.Add(newPublishedDataSetId, publishedDataSetDataType);
                    m_objectsToIds.Add(publishedDataSetDataType, newPublishedDataSetId);
                    m_pubSubConfiguration.PublishedDataSets.Add(publishedDataSetDataType);

                    // raise PublishedDataSetAdded event
                    if (PublishedDataSetAdded != null)
                    {
                        PublishedDataSetAdded(this,
                            new PublishedDataSetEventArgs() { PublishedDataSetId = newPublishedDataSetId, PublishedDataSetDataType = publishedDataSetDataType });
                    }

                    if (publishedDataSetDataType.ExtensionFields == null)
                    {
                        publishedDataSetDataType.ExtensionFields = new KeyValuePairCollection();
                    }
                    KeyValuePairCollection extensionFields = new KeyValuePairCollection(publishedDataSetDataType.ExtensionFields);
                    publishedDataSetDataType.ExtensionFields.Clear();
                    foreach (KeyValuePair extensionField in extensionFields)
                    {
                        AddExtensionField(newPublishedDataSetId, extensionField);
                    }
                    return StatusCodes.Good;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddPublishedDataSet: Exception");
            }
            //todo implement state validation
            return StatusCodes.Bad; 
        }

        /// <summary>
        /// Removes a published data set from current configuration.
        /// </summary>
        /// <param name="publishedDataSetId">Id of the published data set to be removed.</param>
        /// <returns> 
        /// - <see cref="StatusCodes.Good"/> if operation is successful, 
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> otherwise.
        /// </returns>
        public StatusCode RemovePublishedDataSet(uint publishedDataSetId)
        {
            lock (m_lock)
            {
                PublishedDataSetDataType publishedDataSetDataType = FindObjectById(publishedDataSetId) as PublishedDataSetDataType;
                if (publishedDataSetDataType == null)
                {
                    // Unexpected exception 
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain PublishedDataSetDataType with ConfigId = {0}", publishedDataSetId);
                    return StatusCodes.Good;
                }
                return RemovePublishedDataSet(publishedDataSetDataType);
            }
        }

        /// <summary>
        /// Removes a published data set from current configuration.
        /// </summary>
        /// <param name="publishedDataSetDataType">The published data set to be removed.</param>
        /// <returns> 
        /// - <see cref="StatusCodes.Good"/> if operation is successful, 
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> otherwise.
        /// </returns>
        public StatusCode RemovePublishedDataSet(PublishedDataSetDataType publishedDataSetDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint publishedDataSetId = FindIdForObject(publishedDataSetDataType);
                    if (publishedDataSetDataType != null && publishedDataSetId != InvalidId)
                    {
                        /*A successful removal of the PublishedDataSetType Object removes all associated DataSetWriter Objects. 
                         * Before the Objects are removed, their state is changed to Disabled_0*/

                        // Find all associated DataSetWriter objects
                        foreach(var connection in m_pubSubConfiguration.Connections)
                        {
                            foreach(var writerGroup in connection.WriterGroups)
                            {
                                foreach(var dataSetWriter in writerGroup.DataSetWriters.ToArray())
                                {
                                    if (dataSetWriter.DataSetName == publishedDataSetDataType.Name)
                                    {
                                        RemoveDataSetWriter(dataSetWriter);
                                    }
                                }
                            }
                        }

                        m_pubSubConfiguration.PublishedDataSets.Remove(publishedDataSetDataType);

                        //remove all references from dictionaries
                        m_idsToObjects.Remove(publishedDataSetId);
                        m_objectsToIds.Remove(publishedDataSetDataType);
                        m_idsToParentId.Remove(publishedDataSetId);
                        m_idsToPubSubState.Remove(publishedDataSetId);

                        if (PublishedDataSetRemoved != null)
                        {
                            PublishedDataSetRemoved(this, new PublishedDataSetEventArgs()
                            {
                                PublishedDataSetId = publishedDataSetId,
                                PublishedDataSetDataType = publishedDataSetDataType
                            });
                        }
                        return StatusCodes.Good;
                    }
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemovePublishedDataSet: Exception");
            }

            return StatusCodes.BadNodeIdUnknown;
        }

        /// <summary>
        /// Add Extension field to the specified publishedDataset
        /// </summary>
        /// <param name="publishedDataSetConfigId"></param>
        /// <param name="extensionField"></param>
        /// <returns></returns>
        public StatusCode AddExtensionField(uint publishedDataSetConfigId, KeyValuePair extensionField)
        {
            lock (m_lock)
            {
                PublishedDataSetDataType publishedDataSetDataType = FindObjectById(publishedDataSetConfigId) as PublishedDataSetDataType;
                if (publishedDataSetDataType == null)
                {
                    return StatusCodes.BadNodeIdInvalid;
                }
                if (publishedDataSetDataType.ExtensionFields == null)
                {
                    publishedDataSetDataType.ExtensionFields = new KeyValuePairCollection();
                }
                else
                {
                    //validate duplicate name 
                    bool duplicateName = false;
                    foreach (KeyValuePair element in publishedDataSetDataType.ExtensionFields)
                    {
                        if (element.Key == extensionField.Key)
                        {
                            duplicateName = true;
                            break;
                        }
                    }
                    if (duplicateName)
                    {
                        Utils.Trace(Utils.TraceMasks.Error, "AddExtensionField -  A field with the name already exists. Duplicate name = {0}", extensionField.Key);
                        return StatusCodes.BadNodeIdExists;
                    }
                }
                uint newextensionFieldId = m_nextId++;
                //remember connection 
                m_idsToObjects.Add(newextensionFieldId, extensionField);
                m_objectsToIds.Add(extensionField, newextensionFieldId);     
                publishedDataSetDataType.ExtensionFields.Add(extensionField);

                // raise ExtensionFieldAdded event
                if (ExtensionFieldAdded != null)
                {
                    ExtensionFieldAdded(this,
                        new ExtensionFieldEventArgs() { PublishedDataSetId = publishedDataSetConfigId, ExtensionFieldId = newextensionFieldId, ExtensionField = extensionField });
                }

                return StatusCodes.Good;
            }
        }            

        /// <summary>
        /// Removes an extension field from a published data set
        /// </summary>
        /// <param name="publishedDataSetConfigId"></param>
        /// <param name="extensionFieldConfigId"></param>
        /// <returns></returns>
        public StatusCode RemoveExtensionField(uint publishedDataSetConfigId, uint extensionFieldConfigId)
        {
            lock (m_lock)
            {
                PublishedDataSetDataType publishedDataSetDataType = FindObjectById(publishedDataSetConfigId) as PublishedDataSetDataType;
                KeyValuePair extensionFieldToRemove = FindObjectById(extensionFieldConfigId) as KeyValuePair;
                if (publishedDataSetDataType == null || extensionFieldToRemove == null)
                {
                    return StatusCodes.BadNodeIdInvalid;
                }
                if (publishedDataSetDataType.ExtensionFields == null)
                {
                    publishedDataSetDataType.ExtensionFields = new KeyValuePairCollection();
                    return StatusCodes.BadNodeIdInvalid;
                }
                // locate the extension field 
                foreach(KeyValuePair extensionField in publishedDataSetDataType.ExtensionFields.ToArray())
                {
                    if (extensionField.Equals(extensionFieldToRemove))
                    {
                        publishedDataSetDataType.ExtensionFields.Remove(extensionFieldToRemove);

                        // raise ExtensionFieldRemoved event
                        if (ExtensionFieldRemoved != null)
                        {
                            ExtensionFieldRemoved(this,
                                new ExtensionFieldEventArgs() { PublishedDataSetId = publishedDataSetConfigId, ExtensionFieldId = extensionFieldConfigId, ExtensionField = extensionField });
                        }
                        return StatusCodes.Good;
                    }
                }                
            }
            return StatusCodes.BadNodeIdInvalid;
        }
        #endregion

        #region Public Methods - Connection
        /// <summary>
        /// Add a connection to current configuration.
        /// </summary>
        /// <param name="pubSubConnectionDataType">The <see cref="PubSubConnectionDataType"/> object that configures the new connection.</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The connection was added with success.
        /// - <see cref="StatusCodes.BadBrowseNameDuplicated"/> An Object with the name already exists.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error adding the connection.
        /// </returns>
        public StatusCode AddConnection(PubSubConnectionDataType pubSubConnectionDataType)
        {
            if (m_objectsToIds.ContainsKey(pubSubConnectionDataType))
            {
                throw new ArgumentException("This PubSubConnectionDataType instance is already added to the configuration.");
            }
            try
            {
                lock (m_lock)
                {
                    //validate connection name 
                    bool duplicateName = false;
                    foreach(var connection in m_pubSubConfiguration.Connections)
                    {
                        if (connection.Name == pubSubConnectionDataType.Name)
                        {
                            duplicateName = true;
                            break;
                        }
                    }
                    if (duplicateName)
                    {
                        Utils.Trace(Utils.TraceMasks.Error, "Attempted to add PubSubConnectionDataType with duplicate name = {0}", pubSubConnectionDataType.Name);
                        return StatusCodes.BadBrowseNameDuplicated;
                    }

                    // remember collections 
                    WriterGroupDataTypeCollection writerGroups = new WriterGroupDataTypeCollection(pubSubConnectionDataType.WriterGroups);
                    pubSubConnectionDataType.WriterGroups.Clear();
                    ReaderGroupDataTypeCollection readerGroups = new ReaderGroupDataTypeCollection(pubSubConnectionDataType.ReaderGroups);
                    pubSubConnectionDataType.ReaderGroups.Clear();

                    uint newConnectionId = m_nextId++;
                    //remember connection 
                    m_idsToObjects.Add(newConnectionId, pubSubConnectionDataType);
                    m_objectsToIds.Add(pubSubConnectionDataType, newConnectionId);
                    // remember parent id
                    m_idsToParentId.Add(newConnectionId, FindIdForObject(m_pubSubConfiguration));
                    //remember initial state
                    m_idsToPubSubState.Add(newConnectionId, GetInitialPubSubState(pubSubConnectionDataType));

                    m_pubSubConfiguration.Connections.Add(pubSubConnectionDataType);

                    // raise ConnectionAdded event
                    if (ConnectionAdded != null)
                    {
                        ConnectionAdded(this,
                            new ConnectionEventArgs() { ConnectionId = newConnectionId, PubSubConnectionDataType = pubSubConnectionDataType });
                    }
                    //handler reader & writer groups 
                    foreach (WriterGroupDataType writerGroup in writerGroups)
                    {
                        // handle empty names 
                        if (string.IsNullOrEmpty(writerGroup.Name))
                        {
                            //set default name 
                            writerGroup.Name = "WriterGroup_" + (m_nextId + 1);
                        }
                        AddWriterGroup(newConnectionId, writerGroup);
                    }
                    foreach (ReaderGroupDataType readerGroup in readerGroups)
                    {
                        // handle empty names 
                        if (string.IsNullOrEmpty(readerGroup.Name))
                        {
                            //set default name 
                            readerGroup.Name = "ReaderGroup_" + (m_nextId + 1);
                        }
                        AddReaderGroup(newConnectionId, readerGroup);
                    }

                    return StatusCodes.Good;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddConnection: Exception");
            }
            return StatusCodes.BadInvalidArgument;
        }

        /// <summary>
        /// Removes a connection from current configuration.
        /// </summary>
        /// <param name="connectionId">Id of the connection to be removed.</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The Connection was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the Connection.
        /// </returns>
        public StatusCode RemoveConnection(uint connectionId)
        {
            lock (m_lock)
            {
                PubSubConnectionDataType pubSubConnectionDataType = FindObjectById(connectionId) as PubSubConnectionDataType;
                if (pubSubConnectionDataType == null)
                {
                    // Unexpected exception 
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain PubSubConnectionDataType with ConfigId = {0}", connectionId);
                    return StatusCodes.BadNodeIdUnknown;
                }
                return RemoveConnection(pubSubConnectionDataType);
            }
        }

        /// <summary>
        /// Removes a connection from current configuration.
        /// </summary>
        /// <param name="pubSubConnectionDataType">The connection to be removed.</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The Connection was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the Connection.
        /// </returns>
        public StatusCode RemoveConnection(PubSubConnectionDataType pubSubConnectionDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint connectionId = FindIdForObject(pubSubConnectionDataType);
                    if (pubSubConnectionDataType != null && connectionId != InvalidId)
                    {
                        // remove children
                        WriterGroupDataTypeCollection writerGroups = new WriterGroupDataTypeCollection(pubSubConnectionDataType.WriterGroups);
                        foreach (var writerGroup in writerGroups)
                        {
                            RemoveWriterGroup(writerGroup);
                        }
                        ReaderGroupDataTypeCollection readerGroups = new ReaderGroupDataTypeCollection(pubSubConnectionDataType.ReaderGroups);
                        foreach (var readerGroup in readerGroups)
                        {
                            RemoveReaderGroup(readerGroup);
                        }
                        m_pubSubConfiguration.Connections.Remove(pubSubConnectionDataType);

                        //remove all references from dictionaries
                        m_idsToObjects.Remove(connectionId);
                        m_objectsToIds.Remove(pubSubConnectionDataType);
                        m_idsToParentId.Remove(connectionId);
                        m_idsToPubSubState.Remove(connectionId);

                        if (ConnectionRemoved != null)
                        {
                            ConnectionRemoved(this, new ConnectionEventArgs()
                            {
                                ConnectionId = connectionId,
                                PubSubConnectionDataType = pubSubConnectionDataType
                            });
                        }
                        return StatusCodes.Good;
                    }
                    return StatusCodes.BadNodeIdUnknown;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemoveConnection: Exception");
            }

            return StatusCodes.BadInvalidArgument;
        }
        #endregion

        #region Public Methods - WriterGroup
        /// <summary>
        /// Adds a writerGroup to the specified connection
        /// </summary>
        /// <param name="parentConnectionId"></param>
        /// <param name="writerGroupDataType"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The WriterGroup was added with success.
        /// - <see cref="StatusCodes.BadBrowseNameDuplicated"/> An Object with the name already exists.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error adding the WriterGroup.
        /// </returns>
        public StatusCode AddWriterGroup(uint parentConnectionId, WriterGroupDataType writerGroupDataType)
        {
            if (m_objectsToIds.ContainsKey(writerGroupDataType))
            {
                throw new ArgumentException("This WriterGroupDataType instance is already added to the configuration.");
            }
            if (!m_idsToObjects.ContainsKey(parentConnectionId))
            {
                throw new ArgumentException(String.Format("There is no connection with configurationId = {0} in current configuration.", parentConnectionId));
            }
            try
            {
                lock (m_lock)
                {
                    // remember collections 
                    DataSetWriterDataTypeCollection dataSetWriters = new DataSetWriterDataTypeCollection(writerGroupDataType.DataSetWriters);
                    writerGroupDataType.DataSetWriters.Clear();

                    if (m_idsToObjects[parentConnectionId] is PubSubConnectionDataType parentConnection)
                    {
                        //validate duplicate name 
                        bool duplicateName = false;
                        foreach (var writerGroup in parentConnection.WriterGroups)
                        {
                            if (writerGroup.Name == writerGroupDataType.Name)
                            {
                                duplicateName = true;
                                break;
                            }
                        }
                        if (duplicateName)
                        {
                            Utils.Trace(Utils.TraceMasks.Error, "Attempted to add WriterGroupDataType with duplicate name = {0}", writerGroupDataType.Name);
                            return StatusCodes.BadBrowseNameDuplicated;
                        }

                        uint newWriterGroupId = m_nextId++;
                        //remember writer group 
                        m_idsToObjects.Add(newWriterGroupId, writerGroupDataType);
                        m_objectsToIds.Add(writerGroupDataType, newWriterGroupId);
                        parentConnection.WriterGroups.Add(writerGroupDataType);

                        // remember parent id
                        m_idsToParentId.Add(newWriterGroupId, parentConnectionId);
                        //remember initial state
                        m_idsToPubSubState.Add(newWriterGroupId, GetInitialPubSubState(writerGroupDataType));

                        // raise WriterGroupAdded event
                        if (WriterGroupAdded != null)
                        {
                            WriterGroupAdded(this,
                                new WriterGroupEventArgs() { ConnectionId = parentConnectionId, WriterGroupId = newWriterGroupId, WriterGroupDataType = writerGroupDataType });
                        }

                        //handler datasetWriters
                        foreach (DataSetWriterDataType datasetWriter in dataSetWriters)
                        {
                            // handle empty names 
                            if (string.IsNullOrEmpty(datasetWriter.Name))
                            {
                                //set default name 
                                datasetWriter.Name = "DataSetWriter_" + (m_nextId + 1);
                            }
                            AddDataSetWriter(newWriterGroupId, datasetWriter);
                        }

                        return StatusCodes.Good;
                    }
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddWriterGroup: Exception");
            }
            return StatusCodes.BadInvalidArgument;
        }

        /// <summary>
        /// Removes a WriterGroupDataType instance from current configuration specified by confgiId
        /// </summary>
        /// <param name="writerGroupId"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The WriterGroup was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the WriterGroup.
        /// </returns>
        public StatusCode RemoveWriterGroup(uint writerGroupId)
        {
            lock (m_lock)
            {
                WriterGroupDataType writerGroupDataType = FindObjectById(writerGroupId) as WriterGroupDataType;
                if (writerGroupDataType == null)
                {
                    // Unexpected exception 
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain WriterGroupDataType with ConfigId = {0}", writerGroupId);
                    return StatusCodes.BadNodeIdUnknown;
                }
                return RemoveWriterGroup(writerGroupDataType);
            }
        }

        /// <summary>
        /// Removes a WriterGroupDataType instance from current configuration
        /// </summary>
        /// <param name="writerGroupDataType">Instance to remove</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The WriterGroup was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the WriterGroup.
        /// </returns>
        public StatusCode RemoveWriterGroup(WriterGroupDataType writerGroupDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint writerGroupId = FindIdForObject(writerGroupDataType);
                    if (writerGroupDataType != null && writerGroupId != InvalidId)
                    {
                        // remove children
                        DataSetWriterDataTypeCollection dataSetWriters = new DataSetWriterDataTypeCollection(writerGroupDataType.DataSetWriters);
                        foreach (var dataSetWriter in dataSetWriters)
                        {
                            RemoveDataSetWriter(dataSetWriter);
                        }
                        // find parent connection
                        uint parentConnectionId = FindIdForObject(parentConnection);

                        if (FindParentForObject(writerGroupDataType) is PubSubConnectionDataType parentConnection && parentConnectionId != InvalidId)
                        {
                            parentConnection.WriterGroups.Remove(writerGroupDataType);

                            //remove all references from dictionaries
                            m_idsToObjects.Remove(writerGroupId);
                            m_objectsToIds.Remove(writerGroupDataType);
                            m_idsToParentId.Remove(writerGroupId);
                            m_idsToPubSubState.Remove(writerGroupId);

                            if (WriterGroupRemoved != null)
                            {
                                WriterGroupRemoved(this, new WriterGroupEventArgs()
                                {
                                    WriterGroupId = writerGroupId,
                                    WriterGroupDataType = writerGroupDataType,
                                    ConnectionId = parentConnectionId
                                });
                            }
                            return StatusCodes.Good;
                        }
                    }

                    return StatusCodes.BadNodeIdUnknown;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemoveWriterGroup: Exception");
            }

            return StatusCodes.BadInvalidArgument;
        }
        #endregion

        #region Public Methods - DataSetWriter
        /// <summary>
        /// Adds a DataSetWriter to the specified writer group
        /// </summary>
        /// <param name="parentWriterGroupId"></param>
        /// <param name="dataSetWriterDataType"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetWriter was added with success.
        /// - <see cref="StatusCodes.BadBrowseNameDuplicated"/> An Object with the name already exists.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error adding the DataSetWriter.
        /// </returns>
        public StatusCode AddDataSetWriter(uint parentWriterGroupId, DataSetWriterDataType dataSetWriterDataType)
        {
            if (m_objectsToIds.ContainsKey(dataSetWriterDataType))
            {
                throw new ArgumentException("This DataSetWriterDataType instance is already added to the configuration.");
            }
            if (!m_idsToObjects.ContainsKey(parentWriterGroupId))
            {
                throw new ArgumentException(String.Format("There is no WriterGroup with configurationId = {0} in current configuration.", parentWriterGroupId));
            }
            try
            {
                lock (m_lock)
                {
                    if (m_idsToObjects[parentWriterGroupId] is WriterGroupDataType parentWriterGroup)
                    {
                        //validate duplicate name 
                        bool duplicateName = false;
                        foreach (var writer in parentWriterGroup.DataSetWriters)
                        {
                            if (writer.Name == dataSetWriterDataType.Name)
                            {
                                duplicateName = true;
                                break;
                            }
                        }
                        if (duplicateName)
                        {
                            Utils.Trace(Utils.TraceMasks.Error, "Attempted to add DataSetWriterDataType with duplicate name = {0}", dataSetWriterDataType.Name);
                            return StatusCodes.BadBrowseNameDuplicated;
                        }

                        uint newDataSetWriterId = m_nextId++;
                        //remember connection 
                        m_idsToObjects.Add(newDataSetWriterId, dataSetWriterDataType);
                        m_objectsToIds.Add(dataSetWriterDataType, newDataSetWriterId);
                        parentWriterGroup.DataSetWriters.Add(dataSetWriterDataType);

                        // remember parent id
                        m_idsToParentId.Add(newDataSetWriterId, parentWriterGroupId);

                        //remember initial state
                        m_idsToPubSubState.Add(newDataSetWriterId, GetInitialPubSubState(dataSetWriterDataType));

                        // raise DataSetWriterAdded event
                        if (DataSetWriterAdded != null)
                        {
                            DataSetWriterAdded(this,
                                new DataSetWriterEventArgs() { WriterGroupId = parentWriterGroupId, DataSetWriterId = newDataSetWriterId, DataSetWriterDataType = dataSetWriterDataType });
                        }

                        return StatusCodes.Good;
                    }
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddDataSetWriter: Exception");
            }
             return StatusCodes.BadInvalidArgument;
        }

        /// <summary>
        /// Removes a DataSetWriterDataType instance from current configuration specified by confgiId
        /// </summary>
        /// <param name="dataSetWriterId"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetWriter was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the DataSetWriter.
        /// </returns>
        public StatusCode RemoveDataSetWriter(uint dataSetWriterId)
        {
            lock (m_lock)
            {
                DataSetWriterDataType dataSetWriterDataType = FindObjectById(dataSetWriterId) as DataSetWriterDataType;
                if (dataSetWriterDataType == null)
                {
                    // Unexpected exception 
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain DataSetWriterDataType with ConfigId = {0}", dataSetWriterId);
                    return StatusCodes.BadNodeIdUnknown;
                }
                return RemoveDataSetWriter(dataSetWriterDataType);
            }
        }

        /// <summary>
        /// Removes a DataSetWriterDataType instance from current configuration
        /// </summary>
        /// <param name="dataSetWriterDataType">Instance to remove</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetWriter was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the DataSetWriter.
        /// </returns>
        public StatusCode RemoveDataSetWriter(DataSetWriterDataType dataSetWriterDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint dataSetWriterId = FindIdForObject(dataSetWriterDataType);
                    if (dataSetWriterDataType != null && dataSetWriterId != InvalidId)
                    {
                        // find parent writerGroup
                        uint parentWriterGroupId = FindIdForObject(parentWriterGroup);

                        if (FindParentForObject(dataSetWriterDataType) is WriterGroupDataType parentWriterGroup && parentWriterGroupId != InvalidId)
                        {
                            parentWriterGroup.DataSetWriters.Remove(dataSetWriterDataType);

                            //remove all references from dictionaries
                            m_idsToObjects.Remove(dataSetWriterId);
                            m_objectsToIds.Remove(dataSetWriterDataType);
                            m_idsToParentId.Remove(dataSetWriterId);
                            m_idsToPubSubState.Remove(dataSetWriterId);

                            if (DataSetWriterRemoved != null)
                            {
                                DataSetWriterRemoved(this, new DataSetWriterEventArgs()
                                {
                                    WriterGroupId = parentWriterGroupId,
                                    DataSetWriterDataType = dataSetWriterDataType,
                                    DataSetWriterId = dataSetWriterId
                                });
                            }
                            return StatusCodes.Good;
                        }
                    }
                    return StatusCodes.BadNodeIdUnknown;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemoveDataSetWriter: Exception");
            }

            return StatusCodes.BadInvalidArgument;
        }
        #endregion

        #region Public Methods - ReaderGroup
        /// <summary>
        /// Adds a readerGroup to the specified connection
        /// </summary>
        /// <param name="parentConnectionId"></param>
        /// <param name="readerGroupDataType"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The ReaderGroup was added with success.
        /// - <see cref="StatusCodes.BadBrowseNameDuplicated"/> An Object with the name already exists.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error adding the ReaderGroup.
        /// </returns>
        public StatusCode AddReaderGroup(uint parentConnectionId, ReaderGroupDataType readerGroupDataType)
        {
            if (m_objectsToIds.ContainsKey(readerGroupDataType))
            {
                throw new ArgumentException("This ReaderGroupDataType instance is already added to the configuration.");
            }
            if (!m_idsToObjects.ContainsKey(parentConnectionId))
            {
                throw new ArgumentException(String.Format("There is no connection with configurationId = {0} in current configuration.", parentConnectionId));
            }
            try
            {
                lock (m_lock)
                {
                    // remember collections 
                    DataSetReaderDataTypeCollection dataSetReaders = new DataSetReaderDataTypeCollection(readerGroupDataType.DataSetReaders);
                    readerGroupDataType.DataSetReaders.Clear();

                    if (m_idsToObjects[parentConnectionId] is PubSubConnectionDataType parentConnection)
                    {
                        //validate duplicate name 
                        bool duplicateName = false;
                        foreach (var readerGroup in parentConnection.ReaderGroups)
                        {
                            if (readerGroup.Name == readerGroupDataType.Name)
                            {
                                duplicateName = true;
                                break;
                            }
                        }
                        if (duplicateName)
                        {
                            Utils.Trace(Utils.TraceMasks.Error, "Attempted to add ReaderGroupDataType with duplicate name = {0}", readerGroupDataType.Name);
                            return StatusCodes.BadBrowseNameDuplicated;
                        }

                        uint newReaderGroupId = m_nextId++;
                        //remember reader group 
                        m_idsToObjects.Add(newReaderGroupId, readerGroupDataType);
                        m_objectsToIds.Add(readerGroupDataType, newReaderGroupId);
                        parentConnection.ReaderGroups.Add(readerGroupDataType);

                        // remember parent id
                        m_idsToParentId.Add(newReaderGroupId, parentConnectionId);

                        //remember initial state
                        m_idsToPubSubState.Add(newReaderGroupId, GetInitialPubSubState(readerGroupDataType));

                        // raise ReaderGroupAdded event
                        if (ReaderGroupAdded != null)
                        {
                            ReaderGroupAdded(this,
                                new ReaderGroupEventArgs() { ConnectionId = parentConnectionId, ReaderGroupId = newReaderGroupId, ReaderGroupDataType = readerGroupDataType });
                        }

                        //handler datasetWriters
                        foreach (DataSetReaderDataType datasetReader in dataSetReaders)
                        {
                            // handle empty names 
                            if (string.IsNullOrEmpty(datasetReader.Name))
                            {
                                //set default name 
                                datasetReader.Name = "DataSetReader_" + (m_nextId + 1);
                            }
                            AddDataSetReader(newReaderGroupId, datasetReader);
                        }

                        return StatusCodes.Good;
                    }
                   
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddReaderGroup: Exception");
            }
            return StatusCodes.BadInvalidArgument;
        }

        /// <summary>
        /// Removes a ReaderGroupDataType instance from current configuration specified by confgiId
        /// </summary>
        /// <param name="readerGroupId"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The ReaderGroup was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the ReaderGroup.
        /// </returns>
        public StatusCode RemoveReaderGroup(uint readerGroupId)
        {
            lock (m_lock)
            {
                ReaderGroupDataType readerGroupDataType = FindObjectById(readerGroupId) as ReaderGroupDataType;
                if (readerGroupDataType == null)
                {
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain ReaderGroupDataType with ConfigId = {0}", readerGroupId);
                    return StatusCodes.BadInvalidArgument;
                }
                return RemoveReaderGroup(readerGroupDataType);
            }
        }

        /// <summary>
        /// Removes a ReaderGroupDataType instance from current configuration
        /// </summary>
        /// <param name="readerGroupDataType">Instance to remove</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The ReaderGroup was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the ReaderGroup.
        /// </returns>
        public StatusCode RemoveReaderGroup(ReaderGroupDataType readerGroupDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint readerGroupId = FindIdForObject(readerGroupDataType);
                    if (readerGroupDataType != null && readerGroupId != InvalidId)
                    {
                        // remove children
                        DataSetReaderDataTypeCollection dataSetReaders = new DataSetReaderDataTypeCollection(readerGroupDataType.DataSetReaders);
                        foreach (var dataSetReader in dataSetReaders)
                        {
                            RemoveDataSetReader(dataSetReader);
                        }
                        // find parent connection
                        uint parentConnectionId = FindIdForObject(parentConnection);

                        if (FindParentForObject(readerGroupDataType) is PubSubConnectionDataType parentConnection && parentConnectionId != InvalidId)
                        {
                            parentConnection.ReaderGroups.Remove(readerGroupDataType);

                            //remove all references from dictionaries
                            m_idsToObjects.Remove(readerGroupId);
                            m_objectsToIds.Remove(readerGroupDataType);
                            m_idsToParentId.Remove(readerGroupId);
                            m_idsToPubSubState.Remove(readerGroupId);

                            if (ReaderGroupRemoved != null)
                            {
                                ReaderGroupRemoved(this, new ReaderGroupEventArgs()
                                {
                                    ReaderGroupId = readerGroupId,
                                    ReaderGroupDataType = readerGroupDataType,
                                    ConnectionId = parentConnectionId
                                });
                            }
                            return StatusCodes.Good;
                        }
                    }

                    return StatusCodes.BadNodeIdUnknown;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemoveReaderGroup: Exception");
            }

            return StatusCodes.BadInvalidArgument;
        }
        #endregion

        #region Public Methods - DataSetReader
        /// <summary>
        /// Adds a DataSetReader to the specified reader group
        /// </summary>
        /// <param name="parentReaderGroupId"></param>
        /// <param name="dataSetReaderDataType"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetReader was added with success.
        /// - <see cref="StatusCodes.BadBrowseNameDuplicated"/> An Object with the name already exists.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error adding the DataSetReader.
        /// </returns>
        public StatusCode AddDataSetReader(uint parentReaderGroupId, DataSetReaderDataType dataSetReaderDataType)
        {
            if (m_objectsToIds.ContainsKey(dataSetReaderDataType))
            {
                throw new ArgumentException("This DataSetReaderDataType instance is already added to the configuration.");
            }
            if (!m_idsToObjects.ContainsKey(parentReaderGroupId))
            {
                throw new ArgumentException(String.Format("There is no ReaderGroup with configurationId = {0} in current configuration.", parentReaderGroupId));
            }
            try
            {
                lock (m_lock)
                {
                    if (m_idsToObjects[parentReaderGroupId] is ReaderGroupDataType parentReaderGroup)
                    {
                        //validate duplicate name 
                        bool duplicateName = false;
                        foreach (var reader in parentReaderGroup.DataSetReaders)
                        {
                            if (reader.Name == dataSetReaderDataType.Name)
                            {
                                duplicateName = true;
                                break;
                            }
                        }
                        if (duplicateName)
                        {
                            Utils.Trace(Utils.TraceMasks.Error, "Attempted to add DataSetReaderDataType with duplicate name = {0}", dataSetReaderDataType.Name);
                            return StatusCodes.BadBrowseNameDuplicated;
                        }

                        uint newDataSetReaderId = m_nextId++;
                        //remember connection 
                        m_idsToObjects.Add(newDataSetReaderId, dataSetReaderDataType);
                        m_objectsToIds.Add(dataSetReaderDataType, newDataSetReaderId);
                        parentReaderGroup.DataSetReaders.Add(dataSetReaderDataType);

                        // remember parent id
                        m_idsToParentId.Add(newDataSetReaderId, parentReaderGroupId);

                        //remember initial state
                        m_idsToPubSubState.Add(newDataSetReaderId, GetInitialPubSubState(dataSetReaderDataType));

                        // raise WriterGroupAdded event
                        if (DataSetReaderAdded != null)
                        {
                            DataSetReaderAdded(this,
                                new DataSetReaderEventArgs() { ReaderGroupId = parentReaderGroupId, DataSetReaderId = newDataSetReaderId, DataSetReaderDataType = dataSetReaderDataType });
                        }

                        return StatusCodes.Good;
                    }
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.AddDataSetReader: Exception");
            }
            return StatusCodes.BadInvalidArgument;
        }

        /// <summary>
        /// Removes a DataSetReaderDataType instance from current configuration specified by confgiId
        /// </summary>
        /// <param name="dataSetReaderId"></param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetWriter was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the DataSetWriter.
        /// </returns>
        public StatusCode RemoveDataSetReader(uint dataSetReaderId)
        {
            lock (m_lock)
            {
                DataSetReaderDataType dataSetReaderDataType = FindObjectById(dataSetReaderId) as DataSetReaderDataType;
                if (dataSetReaderDataType == null)
                {
                    // Unexpected exception 
                    Utils.Trace(Utils.TraceMasks.Information, "Current configuration does not contain DataSetReaderDataType with ConfigId = {0}", dataSetReaderId);
                    return StatusCodes.BadNodeIdUnknown;
                }
                return RemoveDataSetReader(dataSetReaderDataType);
            }
        }

        /// <summary>
        /// Removes a DataSetReaderDataType instance from current configuration
        /// </summary>
        /// <param name="dataSetReaderDataType">Instance to remove</param>
        /// <returns>
        /// - <see cref="StatusCodes.Good"/> The DataSetWriter was removed with success.
        /// - <see cref="StatusCodes.BadNodeIdUnknown"/> The GroupId is unknown.
        /// - <see cref="StatusCodes.BadInvalidArgument"/> There was an error removing the DataSetWriter.
        /// </returns>
        public StatusCode RemoveDataSetReader(DataSetReaderDataType dataSetReaderDataType)
        {
            try
            {
                lock (m_lock)
                {
                    uint dataSetReaderId = FindIdForObject(dataSetReaderDataType);
                    if (dataSetReaderDataType != null && dataSetReaderId != InvalidId)
                    {
                        // find parent readerGroup
                        uint parenReaderGroupId = FindIdForObject(parentWriterGroup);

                        if (FindParentForObject(dataSetReaderDataType) is ReaderGroupDataType parentWriterGroup && parenReaderGroupId != InvalidId)
                        {
                            parentWriterGroup.DataSetReaders.Remove(dataSetReaderDataType);

                            //remove all references from dictionaries
                            m_idsToObjects.Remove(dataSetReaderId);
                            m_objectsToIds.Remove(dataSetReaderDataType);
                            m_idsToParentId.Remove(dataSetReaderId);
                            m_idsToPubSubState.Remove(dataSetReaderId);

                            if (DataSetReaderRemoved != null)
                            {
                                DataSetReaderRemoved(this, new DataSetReaderEventArgs()
                                {
                                    ReaderGroupId = parenReaderGroupId,
                                    DataSetReaderDataType = dataSetReaderDataType,
                                    DataSetReaderId = dataSetReaderId
                                });
                            }
                            return StatusCodes.Good;
                        }
                    }
                    return StatusCodes.BadNodeIdUnknown;
                }
            }
            catch (Exception ex)
            {
                // Unexpected exception 
                Utils.Trace(ex, "UaPubSubConfigurator.RemoveDataSetReader: Exception");
            }

            return StatusCodes.BadInvalidArgument;
        }
        #endregion

        #region Public Methods - Enable/Disable
        /// <summary> 
        /// Enable the specified configuration object specified by Id
        /// </summary>
        /// <param name="configurationId"></param>
        /// <returns></returns>
        public StatusCode Enable(uint configurationId)
        {
            return Enable(FindObjectById(configurationId));
        }

        /// <summary>
        /// Enable the specified configuration object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <returns></returns>
        public StatusCode Enable(object configurationObject)
        {
            if (configurationObject == null)
            {
                throw new ArgumentException("The parameter cannot be null.", nameof(configurationObject));
            }
            if (!m_objectsToIds.ContainsKey(configurationObject))
            {
                throw new ArgumentException("This {0} instance is not part of current configuration.", configurationObject.GetType().Name);
            }
            PubSubState currentState = FindStateForObject(configurationObject);
            if (currentState != PubSubState.Disabled)
            {
                Utils.Trace(Utils.TraceMasks.Information, "Attempted to call Enable() on an object that is not in Disabled state");
                return StatusCodes.BadInvalidState;
            }
            PubSubState parentState = PubSubState.Operational;
            if (configurationObject != m_pubSubConfiguration)
            {
                parentState = FindStateForObject(FindParentForObject(configurationObject));
            }

            if (parentState == PubSubState.Operational)
            {
                // Enabled and parent Operational
                SetStateForObject(configurationObject, PubSubState.Operational);
            }
            else
            {
                // Enabled but parent not Operational
                SetStateForObject(configurationObject, PubSubState.Paused);
            }
            UpdateChildrenState(configurationObject);
            return StatusCodes.Good;
        }


        /// <summary> 
        /// Disable the specified configuration object specified by Id
        /// </summary>
        /// <param name="configurationId"></param>
        /// <returns></returns>
        public StatusCode Disable(uint configurationId)
        {
            return Disable(FindObjectById(configurationId));
        }

        /// <summary>
        /// Disable the specified configuration object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <returns></returns>
        public StatusCode Disable(object configurationObject)
        {
            if (configurationObject == null)
            {
                throw new ArgumentException("The parameter cannot be null.", nameof(configurationObject));
            }
            if (!m_objectsToIds.ContainsKey(configurationObject))
            {
                throw new ArgumentException("This {0} instance is not part of current configuration.", configurationObject.GetType().Name);
            }
            PubSubState currentState = FindStateForObject(configurationObject);
            if (currentState == PubSubState.Disabled)
            {
                Utils.Trace(Utils.TraceMasks.Information, "Attempted to call Disable() on an object that is already in Disabled state");
                return StatusCodes.BadInvalidState;
            }

            SetStateForObject(configurationObject, PubSubState.Disabled);

            UpdateChildrenState(configurationObject);
            return StatusCodes.Good;
        }
        #endregion

        #region Private Methods

        /// <summary>
        /// Change state for the specified configuration object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <param name="newState"></param>
        private void SetStateForObject(object configurationObject, PubSubState newState)
        {
            uint id = FindIdForObject(configurationObject);
            if (id != InvalidId && m_idsToPubSubState.ContainsKey(id))
            {
                PubSubState oldState = m_idsToPubSubState[id];
                m_idsToPubSubState[id] = newState;
                if (PubSubStateChanged != null)
                {
                    PubSubStateChanged(this, new PubSubStateChangedEventArgs()
                    {
                        ConfigurationObject = configurationObject,
                        ConfigurationObjectId = id,
                        NewState = newState,
                        OldState = oldState
                    });
                }
                bool configurationObjectEnabled = (newState == PubSubState.Operational || newState == PubSubState.Paused);
                //update the Enabled flag in config object
                if (configurationObject is PubSubConfigurationDataType pubSubConfigurationDataType)
                {
                    pubSubConfigurationDataType.Enabled = configurationObjectEnabled;
                }
                else if (configurationObject is PubSubConnectionDataType pubSubConnectionDataType)
                {
                    pubSubConnectionDataType.Enabled = configurationObjectEnabled;
                }
                else if (configurationObject is WriterGroupDataType writerGroupDataType)
                {
                    writerGroupDataType.Enabled = configurationObjectEnabled;
                }
                else if (configurationObject is DataSetWriterDataType dataSetWriterDataType)
                {
                    dataSetWriterDataType.Enabled = configurationObjectEnabled;
                }
                else if (configurationObject is ReaderGroupDataType readerGroupDataType)
                {
                    readerGroupDataType.Enabled = configurationObjectEnabled;
                }
                else if (configurationObject is DataSetReaderDataType dataSetReaderDataType)
                {
                    dataSetReaderDataType.Enabled = configurationObjectEnabled;
                }
            }
        }

        /// <summary>
        /// Calculate and update the state for child objects of a configuration object (StATE MACHINE)
        /// </summary>
        /// <param name="configurationObject"></param>
        private void UpdateChildrenState(object configurationObject)
        {
            PubSubState parentState = FindStateForObject(configurationObject);
            //find child ids
            var childrenIds = FindChildrenIdsForObject(configurationObject);
            if (parentState == PubSubState.Operational)
            {
                // Enabled and parent Operational
                foreach (uint childId in childrenIds)
                {
                    PubSubState childState = FindStateForId(childId);
                    if (childState == PubSubState.Paused)
                    {
                        // become Operational if Parent changed to Operational
                        object childObject = FindObjectById(childId);
                        SetStateForObject(childObject, PubSubState.Operational);

                        UpdateChildrenState(childObject);
                    }
                }
            }
            else if (parentState == PubSubState.Disabled || parentState == PubSubState.Paused)
            {
                // Parent changed to Disabled or Paused
                foreach (uint childId in childrenIds)
                {
                    PubSubState childState = FindStateForId(childId);
                    if (childState == PubSubState.Operational || childState == PubSubState.Error)
                    {
                        // become Operational if Parent changed to Operational
                        object childObject = FindObjectById(childId);
                        SetStateForObject(childObject, PubSubState.Paused);

                        UpdateChildrenState(childObject);
                    }
                }
            }
        }

        /// <summary>
        /// Get <see cref="PubSubState"/> for an item depending on enabled flag and parent's <see cref="PubSubState"/>.
        /// </summary>
        /// <param name="enabled">Configured Enabled flag. </param>
        /// <param name="parentPubSubState"><see cref="PubSubState"/> of the parent configured object.</param>
        /// <returns></returns>
        private PubSubState GetInitialPubSubState(bool enabled, PubSubState parentPubSubState)
        {
            if (enabled)
            {
                if (parentPubSubState == PubSubState.Operational)
                {
                    // The PubSub component is operational.
                    return PubSubState.Operational;
                }
                else
                {
                    // The PubSub component is enabled but currently paused by a parent component. The
                    // parent component is either Disabled_0 or Paused_1.
                    return PubSubState.Paused;
                }
            }
            else
            {
                // PubSub component is configured but currently disabled.
                return PubSubState.Disabled;
            }
        }

        /// <summary>
        /// Calculate and return the initial state of a pub sub data type configuration object
        /// </summary>
        /// <param name="configurationObject"></param>
        /// <returns></returns>
        private PubSubState GetInitialPubSubState(object configurationObject)
        {
            bool configurationObjectEnabled = false;
            PubSubState parentPubSubState = PubSubState.Operational;
            uint parentId = InvalidId;

            if (configurationObject is PubSubConfigurationDataType pubSubConfigurationDataType)
            {
                configurationObjectEnabled = pubSubConfigurationDataType.Enabled;
            }
            else if (configurationObject is PubSubConnectionDataType pubSubConnectionDataType)
            {
                configurationObjectEnabled = pubSubConnectionDataType.Enabled;
                //find parent state 
                parentPubSubState = FindStateForObject(m_pubSubConfiguration);
            }
            else if (configurationObject is WriterGroupDataType writerGroupDataType)
            {
                configurationObjectEnabled = writerGroupDataType.Enabled;
                //find parent connection
                object parentConnection = FindParentForObject(configurationObject);
                //find parent state 
                parentPubSubState = FindStateForObject(parentConnection);
            }
            else if (configurationObject is DataSetWriterDataType dataSetWriterDataType)
            {
                configurationObjectEnabled = dataSetWriterDataType.Enabled;
                //find parent 
                object parentWriterGroup = FindParentForObject(configurationObject);
                //find parent state 
                parentPubSubState = FindStateForObject(parentWriterGroup);
            }
            else if (configurationObject is ReaderGroupDataType readerGroupDataType)
            {
                configurationObjectEnabled = readerGroupDataType.Enabled;
                //find parent connection
                object parentConnection = FindParentForObject(configurationObject);
                //find parent state 
                parentPubSubState = FindStateForObject(parentConnection);
            }
            else if (configurationObject is DataSetReaderDataType dataSetReaderDataType)
            {
                configurationObjectEnabled = dataSetReaderDataType.Enabled;
                //find parent 
                object parentReaderGroup = FindParentForObject(configurationObject);
                //find parent state 
                parentPubSubState = FindStateForObject(parentReaderGroup);
            }
            else
            {
                return PubSubState.Error;
            }
            return GetInitialPubSubState(configurationObjectEnabled, parentPubSubState);
        }
        #endregion
    }
}

---- Semantic diagnostics *before* transformation ----

---- Semantic diagnostics *after* transformation ----
D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs(926,67): error CS0841: Cannot use local variable 'parentConnection' before it is declared,D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs(1081,68): error CS0841: Cannot use local variable 'parentWriterGroup' before it is declared,D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs(1257,67): error CS0841: Cannot use local variable 'parentConnection' before it is declared,D:\a\1\s\Libraries\Opc.Ua.PubSub\Configuration\UaPubSubConfigurator.cs(1412,67): error CS0841: Cannot use local variable 'parentWriterGroup' before it is declared
######################################################################


